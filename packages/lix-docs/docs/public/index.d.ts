import { Generated, Selectable, Insertable, SelectQueryBuilder, Kysely, ExpressionBuilder, ExpressionWrapper, SqlBool } from 'kysely';
export { sql } from 'kysely';
import { JSONSchema, FromSchema } from 'json-schema-to-ts';
import { SqliteWasmDatabase } from 'sqlite-wasm-kysely';
import { ZettelDoc } from '@opral/zettel-ast';
export { jsonArrayFrom, jsonObjectFrom } from 'kysely/helpers/sqlite';
export { v7 as uuidV7 } from 'uuid';

type Change = Selectable<ChangeView>;
type NewChange = Insertable<ChangeView>;
type ChangeView = {
    id: Generated<string>;
    entity_id: string;
    schema_key: string;
    schema_version: string;
    file_id: string;
    plugin_key: string;
    created_at: Generated<string>;
    snapshot_content: Record<string, any> | null;
};

/**
 * Extended property schema that includes Lix-specific extensions
 */
type LixPropertySchema = JSONSchema & {
    "x-lix-generated"?: boolean;
};
declare const LixSchemaDefinition: {
    readonly $schema: "http://json-schema.org/draft-07/schema#";
    readonly title: "Lix Change Schema";
    readonly description: "A JSON schema document that also includes custom x-key and x-version properties for identification and versioning.";
    readonly allOf: readonly [{
        readonly $ref: "http://json-schema.org/draft-07/schema#";
    }, {
        readonly type: "object";
        readonly properties: {
            readonly "x-lix-unique": {
                readonly type: "array";
                readonly items: {
                    readonly type: "array";
                    readonly items: {
                        readonly type: "string";
                    };
                };
            };
            readonly "x-primary-key": {
                readonly type: "array";
                readonly items: {
                    readonly type: "string";
                };
            };
            readonly "x-lix-foreign-keys": {
                readonly type: "object";
                readonly additionalProperties: {
                    readonly type: "object";
                    readonly properties: {
                        readonly schemaKey: {
                            readonly type: "string";
                            readonly description: "The x-lix-key of the referenced schema";
                        };
                        readonly property: {
                            readonly type: "string";
                            readonly description: "The property name in the referenced schema";
                        };
                        readonly schemaVersion: {
                            readonly type: "string";
                            readonly pattern: "^\\d+\\.\\d+$";
                            readonly description: "Optional version of the referenced schema";
                        };
                    };
                    readonly required: readonly ["schemaKey", "property"];
                };
            };
            readonly "x-lix-key": {
                readonly type: "string";
                readonly description: "The key of the schema. The key is used to identify the schema. You must use a unique key for each schema.";
                readonly examples: readonly ["csv_plugin_cell"];
            };
            readonly "x-lix-version": {
                readonly type: "string";
                readonly description: "The version of the schema. Use the major version to signal breaking changes. Use the minor version to signal non-breaking changes.";
                readonly pattern: "^\\d+\\.\\d+$";
                readonly examples: readonly ["1.0"];
            };
            readonly properties: {
                readonly type: "object";
                readonly additionalProperties: {
                    readonly allOf: readonly [{
                        readonly $ref: "http://json-schema.org/draft-07/schema#";
                    }, {
                        readonly type: "object";
                        readonly properties: {
                            readonly "x-lix-generated": {
                                readonly type: "boolean";
                                readonly description: "Whether this property is auto-generated by the database";
                            };
                        };
                    }];
                };
            };
        };
        readonly required: readonly ["x-lix-key", "x-lix-version"];
    }];
};
/**
 * LixSchema
 *
 * A superset of JSON Schema (draft-07) that includes Lix-specific metadata
 * and supports custom extensions.
 *
 * Custom extensions may be added with any x-* prefix.
 */
type LixSchemaDefinition = JSONSchema & {
    /**
     * The key of the schema.
     *
     * The key is used to identify the schema. You must use a
     * unique key for each schema.
     *
     * @example
     *   "csv_plugin_cell"
     */
    "x-lix-key": string;
    /**
     * The version of the schema.
     *
     * Use the major version to signal breaking changes.
     * Use the minor version to signal non-breaking changes.
     *
     * @example
     *   "1.0"
     */
    "x-lix-version": string;
    "x-lix-primary-key"?: string[] | readonly string[];
    /**
     * Properties that must be unique per version.
     *
     * Not to be confused by `x-version` which is used for versioning the schema.
     *
     *
     * @example
     *   {
     *     "x-lix-unique": [
     *       // the id must be unique
     *       ["id"],
     *       // the name and age must be unique as well
     *       ["name", "age"],
     *     ],
     *     properties: {
     *       id: { type: "string" },
     *       name: { type: "string" },
     *       age: { type: "number" },
     *     },
     *   }
     */
    "x-lix-unique"?: string[][] | readonly (readonly string[])[];
    /**
     * Foreign key constraints referencing other schemas.
     *
     * @example
     *   {
     *     "x-lix-foreign-keys": {
     *       "author_id": {
     *         "schemaKey": "user_profile",
     *         "property": "id"
     *       },
     *       "category_id": {
     *         "schemaKey": "post_category",
     *         "property": "id"
     *       }
     *     }
     *   }
     */
    "x-lix-foreign-keys"?: {
        [localProperty: string]: {
            schemaKey: string;
            property: string;
            schemaVersion?: string;
        };
    };
    type: "object";
    properties?: {
        [key: string]: LixPropertySchema;
    };
};
/**
 * Marker type for database columns that are auto-generated.
 *
 * This type brands values as "generated" to enable special handling in insert/update
 * operations. Generated fields become optional in inserts since the database
 * provides default values.
 *
 * The type accepts T values directly for developer convenience while preserving
 * the generated marker for type transformations.
 *
 * @example
 * ```typescript
 * type Account = {
 *   id: LixGenerated<string>;  // Auto-generated UUID
 *   name: string;              // User-provided
 *   created_at: LixGenerated<string>;  // Auto-generated timestamp
 * };
 *
 * // In inserts, generated fields are optional
 * const newAccount: LixInsertable<Account> = {
 *   name: "John"  // id and created_at are optional
 * };
 * ```
 */
type LixGenerated<T> = T & {
    readonly __lixGenerated?: true;
};
/**
 * Check if a type has the LixGenerated brand
 */
type IsLixGenerated$1<T> = T extends {
    readonly __lixGenerated?: true;
} ? true : false;
/**
 * Extract the base type from LixGenerated<T>
 * Since LixGenerated<T> = T & { brand }, we need to extract T
 */
type ExtractFromGenerated$1<T> = T extends LixGenerated<infer U> ? U : T;
/**
 * Extract the select type from LixGenerated or return the type as-is
 */
type SelectType$1<T> = ExtractFromGenerated$1<T>;
/**
 * Extract the insert type from LixGenerated or return the type as-is
 */
type InsertType<T> = IsLixGenerated$1<T> extends true ? ExtractFromGenerated$1<T> | undefined : T;
/**
 * Extract the update type from LixGenerated or return the type as-is
 */
type UpdateType<T> = ExtractFromGenerated$1<T>;
/**
 * Evaluates to K if T can be null or undefined
 */
type IfNullable<T, K> = undefined extends T ? K : null extends T ? K : never;
/**
 * Evaluates to K if T can't be null or undefined
 */
type IfNotNullable<T, K> = undefined extends T ? never : null extends T ? never : T extends never ? never : K;
/**
 * Keys whose InsertType can be null or undefined (optional in inserts)
 */
type NullableInsertKeys<T> = {
    [K in keyof T]: IfNullable<InsertType<T[K]>, K>;
}[keyof T];
/**
 * Keys whose InsertType can't be null or undefined (required in inserts)
 */
type NonNullableInsertKeys<T> = {
    [K in keyof T]: IfNotNullable<InsertType<T[K]>, K>;
}[keyof T];
/**
 * Transform a type for insert operations.
 *
 * This type makes LixGenerated fields optional while keeping other required
 * fields mandatory. Use this when defining types for creating new entities.
 *
 * The database will automatically populate generated fields (like IDs,
 * timestamps) if not provided.
 *
 * @example
 * ```typescript
 * type Account = {
 *   id: LixGenerated<string>;
 *   name: string;
 *   email: string;
 *   created_at: LixGenerated<string>;
 * };
 *
 * type NewAccount = LixInsertable<Account>;
 * // Result: { name: string; email: string; id?: string; created_at?: string; }
 *
 * const account: NewAccount = {
 *   name: "John",
 *   email: "john@example.com"
 *   // id and created_at are optional
 * };
 * ```
 */
type LixInsertable<T> = {
    [K in NonNullableInsertKeys<T>]: InsertType<T[K]>;
} & {
    [K in NullableInsertKeys<T>]?: InsertType<T[K]>;
};
/**
 * Transform a type for update operations.
 *
 * This type makes all fields optional, allowing partial updates where you
 * only specify the fields you want to change. LixGenerated markers are
 * removed since you're providing explicit values.
 *
 * The database preserves existing values for any fields not included
 * in the update.
 *
 * @example
 * ```typescript
 * type Account = {
 *   id: LixGenerated<string>;
 *   name: string;
 *   email: string;
 *   updated_at: LixGenerated<string>;
 * };
 *
 * type AccountUpdate = LixUpdateable<Account>;
 * // Result: { id?: string; name?: string; email?: string; updated_at?: string; }
 *
 * // Update only the email
 * const updates: AccountUpdate = {
 *   email: "newemail@example.com"
 *   // Other fields remain unchanged
 * };
 * ```
 */
type LixUpdateable<T> = {
    [K in keyof T]?: UpdateType<T[K]>;
};
/**
 * Transform a type for select/query operations.
 *
 * This type unwraps all LixGenerated markers, giving you the actual runtime
 * types that will be returned from database queries. All fields are required
 * and have their base types.
 *
 * Use this type when defining the shape of data returned from queries or
 * when passing entity data to UI components.
 *
 * @example
 * ```typescript
 * type Account = {
 *   id: LixGenerated<string>;
 *   name: string;
 *   email: string;
 *   created_at: LixGenerated<string>;
 * };
 *
 * type AccountData = LixSelectable<Account>;
 * // Result: { id: string; name: string; email: string; created_at: string; }
 *
 * // Query results have this shape
 * const accounts: AccountData[] = await db
 *   .selectFrom("account")
 *   .selectAll()
 *   .execute();
 *
 * console.log(accounts[0].id);  // string (not LixGenerated<string>)
 * ```
 */
type LixSelectable<T> = {
    [K in keyof T]: SelectType$1<T[K]>;
};
/**
 * Transform object types with no properties from unknown to Record<string, any>
 */
type TransformEmptyObject<T> = T extends {
    [x: string]: unknown;
} ? Record<string, any> : T;
/**
 * Check if a schema property is an empty object type (no properties defined)
 */
type IsEmptyObjectSchema<P> = P extends {
    type: "object";
} ? P extends {
    properties: any;
} ? false : true : false;
/**
 * Get the nullable part of a type based on schema
 */
type GetNullablePart<P> = P extends {
    nullable: true;
} ? null : never;
/**
 * Internal type that applies LixGenerated markers to properties with x-lix-generated: true
 */
type ApplyLixGenerated<TSchema extends LixSchemaDefinition> = TSchema extends {
    properties: infer Props;
} ? {
    [K in keyof FromSchema<TSchema>]: K extends keyof Props ? Props[K] extends {
        "x-lix-generated": true;
    } ? LixGenerated<TransformEmptyObject<FromSchema<TSchema>[K]>> : IsEmptyObjectSchema<Props[K]> extends true ? Record<string, any> | GetNullablePart<Props[K]> : TransformEmptyObject<FromSchema<TSchema>[K]> : TransformEmptyObject<FromSchema<TSchema>[K]>;
} : never;
/**
 * Convert a LixSchemaDefinition to a TypeScript type.
 *
 * This type transformation:
 * 1. Converts JSON Schema properties to TypeScript types
 * 2. Wraps properties with `x-lix-generated: true` in LixGenerated markers
 * 3. Transforms `type: "object"` without properties to `Record<string, any>`
 *
 * The resulting type can be used with LixInsertable, LixUpdateable, and
 * LixSelectable for database operations.
 *
 * @example
 * ```typescript
 * const AccountSchema = {
 *   "x-lix-key": "account",
 *   "x-lix-version": "1.0",
 *   "x-lix-primary-key": ["id"],
 *   type: "object",
 *   properties: {
 *     id: { type: "string", "x-lix-generated": true },
 *     name: { type: "string" },
 *     email: { type: "string" },
 *     metadata: { type: "object" },  // Becomes Record<string, any>
 *     created_at: { type: "string", "x-lix-generated": true }
 *   },
 *   required: ["id", "name", "email"],
 *   additionalProperties: false
 * } as const satisfies LixSchemaDefinition;
 *
 * type Account = FromLixSchemaDefinition<typeof AccountSchema>;
 * // Result: {
 * //   id: LixGenerated<string>;
 * //   name: string;
 * //   email: string;
 * //   metadata: Record<string, any> | undefined;
 * //   created_at: LixGenerated<string> | undefined;
 * // }
 * ```
 */
type FromLixSchemaDefinition<T extends LixSchemaDefinition> = ApplyLixGenerated<T>;

declare const LixFileDescriptorSchema: {
    readonly "x-lix-key": "lix_file_descriptor";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["id"];
    readonly "x-lix-unique": readonly [readonly ["path"]];
    readonly type: "object";
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly path: {
            readonly type: "string";
            readonly pattern: "^/(?!.*//|.*\\\\)(?!.*/$|^/$).+";
            readonly description: "File path must start with a slash, not contain backslashes or consecutive slashes, and not end with a slash";
        };
        readonly metadata: {
            readonly type: "object";
            readonly nullable: true;
        };
    };
    readonly required: readonly ["id", "path"];
    readonly additionalProperties: false;
};
/**
 * The file descriptor type representing the stored metadata for a file.
 *
 * This contains the file's identity and metadata but not the actual file content.
 * The file content (data) is materialized separately by aggregating entities from plugins.
 */
type LixFileDescriptor = FromLixSchemaDefinition<typeof LixFileDescriptorSchema>;
/**
 * Complete file type combining the descriptor with materialized data.
 *
 * Uses "Lix" prefix to avoid collision with JavaScript's built-in File type.
 * This represents the full file as seen in views, combining:
 * - LixFileDescriptor: stored metadata (id, path, metadata)
 * - data: materialized file content from plugin entities
 */
type LixFile = LixFileDescriptor & {
    data: Uint8Array;
};

type LixPlugin = {
    key: string;
    /**
     * The glob pattern that should invoke `detectChanges()`.
     *
     * @example
     *   `**\/*.json` for all JSON files
     *   `**\/*.inlang` for all inlang files
     */
    detectChangesGlob?: string;
    /**
     * Detects changes between the `before` and `after` file update(s).
     *
     * `Before` is `undefined` if the file did not exist before (
     * the file was created).
     *
     * `After` is always defined. Either the file was updated, or
     * deleted. If the file is deleted, lix own change control
     * will handle the deletion. Hence, `after` is always be defined.
     */
    detectChanges?: ({ before, after, }: {
        before?: Omit<LixFile, "data"> & {
            data?: Uint8Array;
        };
        after: Omit<LixFile, "data"> & {
            data: Uint8Array;
        };
    }) => DetectedChange[];
    applyChanges?: ({ file, changes, }: {
        /**
         * The file to which the changes should be applied.
         *
         * The `file.data` might be undefined if the file does not
         * exist at the time of applying the changes. This can
         * happen when merging a version that created a new file
         * that did not exist in the target version. Or, a file
         * has been deleted and should be restored at a later point.
         */
        file: Omit<LixFile, "data"> & {
            data?: Uint8Array;
        };
        changes: Array<Change>;
    }) => {
        fileData: Uint8Array;
    };
    /**
     * UI components that are used to render the diff view.
     */
    diffUiComponent?: CustomElementConstructor;
};
/**
 * A detected change that lix ingests in to the database.
 *
 * - If the `snapshot` is `undefined`, the change is considered to be a deletion.
 * - The `schema` type can be narrowed by providing a change schema.
 *
 * @example
 *   Type narrowing with a change schema:
 *
 *   ```
 * 	 const FooV1Schema = {
 *     key: "plugin-name-foo-v1",
 *     type: "json",
 *     schema: {
 *       type: "object",
 *       properties: {
 *         name: { type: "string" },
 * 		   }
 *     }
 *   } as const satisfies ChangeSchema;
 *
 *   const detectedChange: DetectedChange<typeof FooV1Schema>
 *
 *   detectedChange.snapshot.name // string
 *   ```
 */
type DetectedChange<T = any> = {
    entity_id: string;
    schema: LixSchemaDefinition;
    /**
     * The change is considered a deletion if `snapshot_content` is `null`.
     */
    snapshot_content: T | null;
};
type UiDiffComponentProps = {
    diffs: Array<Pick<Change, "entity_id" | "plugin_key" | "schema_key"> & {
        snapshot_content_before: Record<string, any> | null;
        snapshot_content_after: Record<string, any> | null;
    }>;
};

declare const LixChangeSetSchema: {
    readonly "x-lix-key": "lix_change_set";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["id"];
    readonly type: "object";
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly metadata: {
            readonly type: "object";
            readonly nullable: true;
        };
    };
    readonly required: readonly ["id"];
    readonly additionalProperties: false;
};
type ChangeSet = FromLixSchemaDefinition<typeof LixChangeSetSchema>;
declare const LixChangeSetElementSchema: {
    readonly "x-lix-key": "lix_change_set_element";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-foreign-keys": {
        readonly change_set_id: {
            readonly schemaKey: "lix_change_set";
            readonly property: "id";
        };
        readonly change_id: {
            readonly schemaKey: "lix_change";
            readonly property: "id";
        };
        readonly schema_key: {
            readonly schemaKey: "lix_stored_schema";
            readonly property: "key";
        };
    };
    readonly "x-lix-primary-key": readonly ["change_set_id", "change_id"];
    readonly "x-lix-unique": readonly [readonly ["change_set_id", "entity_id", "schema_key", "file_id"]];
    readonly type: "object";
    readonly properties: {
        readonly change_set_id: {
            readonly type: "string";
        };
        readonly change_id: {
            readonly type: "string";
        };
        readonly entity_id: {
            readonly type: "string";
        };
        readonly schema_key: {
            readonly type: "string";
        };
        readonly file_id: {
            readonly type: "string";
        };
    };
    readonly required: readonly ["change_set_id", "change_id", "entity_id", "schema_key", "file_id"];
    readonly additionalProperties: false;
};
type ChangeSetElement = FromLixSchemaDefinition<typeof LixChangeSetElementSchema>;
declare const LixChangeSetEdgeSchema: {
    readonly "x-lix-key": "lix_change_set_edge";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["parent_id", "child_id"];
    readonly "x-lix-foreign-keys": {
        readonly parent_id: {
            readonly schemaKey: "lix_change_set";
            readonly property: "id";
        };
        readonly child_id: {
            readonly schemaKey: "lix_change_set";
            readonly property: "id";
        };
    };
    readonly type: "object";
    readonly properties: {
        readonly parent_id: {
            readonly type: "string";
        };
        readonly child_id: {
            readonly type: "string";
        };
    };
    readonly required: readonly ["parent_id", "child_id"];
    readonly additionalProperties: false;
};
type ChangeSetEdge = FromLixSchemaDefinition<typeof LixChangeSetEdgeSchema>;
declare const LixChangeSetLabelSchema: {
    readonly "x-lix-key": "lix_change_set_label";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["change_set_id", "label_id"];
    readonly "x-lix-foreign-keys": {
        readonly change_set_id: {
            readonly schemaKey: "lix_change_set";
            readonly property: "id";
        };
        readonly label_id: {
            readonly schemaKey: "lix_label";
            readonly property: "id";
        };
    };
    readonly type: "object";
    readonly properties: {
        readonly change_set_id: {
            readonly type: "string";
        };
        readonly label_id: {
            readonly type: "string";
        };
        readonly metadata: {
            readonly type: "object";
            readonly nullable: true;
        };
    };
    readonly required: readonly ["change_set_id", "label_id"];
    readonly additionalProperties: false;
};
type ChangeSetLabel = FromLixSchemaDefinition<typeof LixChangeSetLabelSchema>;
declare const LixChangeSetThreadSchema: {
    readonly "x-lix-key": "lix_change_set_thread";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["change_set_id", "thread_id"];
    readonly "x-lix-foreign-keys": {
        readonly change_set_id: {
            readonly schemaKey: "lix_change_set";
            readonly property: "id";
        };
        readonly thread_id: {
            readonly schemaKey: "lix_thread";
            readonly property: "id";
        };
    };
    readonly type: "object";
    readonly properties: {
        readonly change_set_id: {
            readonly type: "string";
        };
        readonly thread_id: {
            readonly type: "string";
        };
    };
    readonly required: readonly ["change_set_id", "thread_id"];
    readonly additionalProperties: false;
};
type ChangeSetThread = FromLixSchemaDefinition<typeof LixChangeSetThreadSchema>;

declare const LixVersionSchema: {
    readonly "x-lix-key": "lix_version";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["id"];
    readonly "x-lix-unique": readonly [readonly ["working_change_set_id"]];
    readonly "x-lix-foreign-keys": {
        readonly change_set_id: {
            readonly schemaKey: "lix_change_set";
            readonly property: "id";
        };
        readonly working_change_set_id: {
            readonly schemaKey: "lix_change_set";
            readonly property: "id";
        };
        readonly inherits_from_version_id: {
            readonly schemaKey: "lix_version";
            readonly property: "id";
        };
    };
    readonly type: "object";
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly name: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly change_set_id: {
            readonly type: "string";
        };
        readonly working_change_set_id: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly inherits_from_version_id: {
            readonly type: readonly ["string", "null"];
            readonly "x-lix-generated": true;
        };
        readonly hidden: {
            readonly type: "boolean";
            readonly "x-lix-generated": true;
        };
    };
    readonly required: readonly ["id", "name", "change_set_id", "working_change_set_id"];
    readonly additionalProperties: false;
};
declare const LixActiveVersionSchema: {
    readonly "x-lix-key": "lix_active_version";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["version_id"];
    readonly "x-lix-foreign-keys": {
        readonly version_id: {
            readonly schemaKey: "lix_version";
            readonly property: "id";
        };
    };
    readonly type: "object";
    readonly properties: {
        readonly version_id: {
            readonly type: "string";
        };
    };
    readonly required: readonly ["version_id"];
    readonly additionalProperties: false;
};
type Version = FromLixSchemaDefinition<typeof LixVersionSchema>;
type ActiveVersion = FromLixSchemaDefinition<typeof LixActiveVersionSchema>;

declare const LixStoredSchemaSchema: {
    readonly "x-lix-key": "lix_stored_schema";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["key", "version"];
    readonly type: "object";
    readonly properties: {
        readonly key: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly version: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly value: any;
    };
    readonly additionalProperties: false;
};
type StoredSchema = FromLixSchemaDefinition<typeof LixStoredSchemaSchema> & {
    value: any;
};

declare function applyKeyValueDatabaseSchema(sqlite: SqliteWasmDatabase): void;
declare const LixKeyValueSchema: {
    readonly "x-lix-key": "lix_key_value";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["key"];
    readonly type: "object";
    readonly properties: {
        readonly key: {
            readonly type: "string";
        };
        readonly value: any;
    };
    readonly required: readonly ["key", "value"];
    readonly additionalProperties: false;
};
type KeyValue = FromLixSchemaDefinition<typeof LixKeyValueSchema> & {
    value: any;
};

/**
 * Lix hooks system for listening to database lifecycle events.
 *
 * Hooks allow you to register callbacks that fire at specific points
 * in Lix's execution, such as when state changes are committed.
 */
type LixHooks = {
    /**
     * Listen to state commit events.
     *
     * Fires after any state mutation is committed to the database.
     * Useful for auto-saving, cache invalidation, sync operations, etc.
     *
     * @param handler - Function to call when state is committed
     * @returns Unsubscribe function to remove the listener
     *
     * @example
     * ```typescript
     * const unsubscribe = lix.hooks.onStateCommit(() => {
     *   console.log('State was committed!');
     *   storage.save();
     * });
     *
     * // Later, remove the listener
     * unsubscribe();
     * ```
     */
    onStateCommit: (handler: () => void) => () => void;
    /**
     * Listen to file change events.
     *
     * Note: This API will become redundant once subscriptions are implemented.
     *
     * Fires when a file is inserted, updated, or deleted in the database.
     * Useful for updating UI, triggering re-parsing, or synchronizing external systems.
     *
     * @param handler - Function to call when a file changes
     * @returns Unsubscribe function to remove the listener
     *
     * @example
     * ```typescript
     * const unsubscribe = lix.hooks.onFileChange((fileId, operation) => {
     *   console.log(`File ${fileId} was ${operation}`);
     *   if (operation === 'updated') {
     *     reloadEditor(fileId);
     *   }
     * });
     *
     * // Later, remove the listener
     * unsubscribe();
     * ```
     */
    onFileChange: (handler: (fileId: string, operation: "inserted" | "updated") => void) => () => void;
    /**
     * Internal method for emitting events.
     *
     * @internal
     * This method is for internal use only and should not be called directly.
     * Use this to emit events from state mutation functions.
     */
    _emit: (eventType: string, data?: any) => void;
};
/**
 * Creates a new hooks system for a Lix instance.
 *
 * Uses the native EventTarget API under the hood for efficient
 * event handling and automatic memory management.
 *
 * @returns LixHooks instance with event subscription methods
 */
declare function createHooks(): LixHooks;

type StateView = Omit<StateAllView, "version_id">;
type StateAllView = {
    entity_id: string;
    schema_key: string;
    file_id: string;
    plugin_key: string;
    snapshot_content: Record<string, any>;
    schema_version: string;
    version_id: string;
    created_at: Generated<string>;
    updated_at: Generated<string>;
    inherited_from_version_id: string | null;
    change_id: Generated<string>;
    untracked: Generated<boolean>;
};

/**
 * State history table interface for querying historical entity states.
 *
 * This view provides access to entity states at specific points in change set history,
 * with depth-based traversal for blame functionality and diff operations.
 */
interface StateHistoryTable {
    /** Unique identifier of the entity */
    entity_id: string;
    /** Schema type identifier (e.g., 'paragraph', 'comment') */
    schema_key: string;
    /** File identifier where this entity is stored */
    file_id: string;
    /** Plugin identifier that manages this entity type */
    plugin_key: string;
    /** JSON content of the entity at this point in history */
    snapshot_content: Record<string, any>;
    /** Version of the schema used for this entity */
    schema_version: string;
    /**
     * ID of the change that created this entity state.
     * Join with the `change` table to get created_at, author info, and other change metadata.
     * Example: `JOIN change ON state_history.change_id = change.id`
     */
    change_id: string;
    /**
     * The actual change set ID where this entity state was originally created.
     *
     * This represents the true origin changeset for each historical state, making it easy
     * to understand the provenance of each entity state without additional joins.
     *
     * For example, when viewing history you might see:
     * - depth 0: change_set_id = 'checkpoint-123' (current state created in checkpoint-123)
     * - depth 2: change_set_id = 'checkpoint-100' (historical state created in checkpoint-100)
     *
     * This tells you exactly where each state was created in the changeset graph.
     */
    change_set_id: string;
    /**
     * The root change set ID used as the starting point for traversing history.
     *
     * When querying history from a specific changeset, this field contains that
     * changeset ID for all returned rows. Used with `depth` to understand how
     * far back in history each entity state is from this root.
     *
     * For example, if you query `WHERE root_change_set_id = 'checkpoint-123'`,
     * all returned rows will have `root_change_set_id = 'checkpoint-123'`.
     */
    root_change_set_id: string;
    /**
     * Depth of this entity state relative to the root_change_set_id.
     * - depth = 0: Current state at the queried change_set_id
     * - depth = 1: One change set back in history (parent)
     * - depth = 2: Two change sets back in history (grandparent)
     * - etc.
     *
     * Depth is calculated by traversing the change set ancestry graph backwards
     * from the queried change_set_id through parent change set edges.
     * Used for blame functionality to show how entities evolved over time.
     */
    depth: number;
}
type StateHistoryView = Selectable<StateHistoryTable>;

declare const LixLogSchema: {
    readonly "x-lix-key": "lix_log";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["id"];
    readonly type: "object";
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly description: "The unique identifier of the log entry";
            readonly "x-lix-generated": true;
        };
        readonly key: {
            readonly type: "string";
            readonly description: "The key of the log entry";
        };
        readonly message: {
            readonly type: "string";
            readonly description: "The message of the log entry";
        };
        readonly level: {
            readonly type: "string";
            readonly description: "The level of the log entry";
        };
    };
    readonly required: readonly ["id", "key", "message", "level"];
    readonly additionalProperties: false;
};
type Log = FromLixSchemaDefinition<typeof LixLogSchema>;

declare const LixAccountSchema: {
    readonly "x-lix-key": "lix_account";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["id"];
    readonly type: "object";
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly name: {
            readonly type: "string";
        };
    };
    readonly required: readonly ["id", "name"];
    readonly additionalProperties: false;
};
type Account = FromLixSchemaDefinition<typeof LixAccountSchema>;
type ActiveAccountTable = {
    id: string;
    name: string;
};
type ActiveAccount = Selectable<ActiveAccountTable>;

declare const LixChangeAuthorSchema: {
    readonly "x-lix-key": "lix_change_author";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["change_id", "account_id"];
    readonly "x-lix-foreign-keys": {
        readonly change_id: {
            readonly schemaKey: "lix_change";
            readonly property: "id";
        };
        readonly account_id: {
            readonly schemaKey: "lix_account";
            readonly property: "id";
        };
    };
    readonly type: "object";
    readonly properties: {
        readonly change_id: {
            readonly type: "string";
        };
        readonly account_id: {
            readonly type: "string";
        };
    };
    readonly required: readonly ["change_id", "account_id"];
    readonly additionalProperties: false;
};
type ChangeAuthor = FromLixSchemaDefinition<typeof LixChangeAuthorSchema>;

declare const LixLabelSchema: {
    readonly "x-lix-key": "lix_label";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["id"];
    readonly type: "object";
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly name: {
            readonly type: "string";
        };
    };
    readonly required: readonly ["id", "name"];
    readonly additionalProperties: false;
};
type Label = FromLixSchemaDefinition<typeof LixLabelSchema>;

declare const LixThreadSchema: {
    readonly "x-lix-key": "lix_thread";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["id"];
    readonly type: "object";
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly metadata: {
            readonly type: "object";
            readonly nullable: true;
        };
    };
    readonly required: readonly ["id"];
    readonly additionalProperties: false;
};
declare const LixThreadCommentSchema: {
    readonly "x-lix-key": "lix_thread_comment";
    readonly "x-lix-version": "1.0";
    readonly "x-lix-primary-key": readonly ["id"];
    readonly "x-lix-foreign-keys": {
        readonly thread_id: {
            readonly schemaKey: "lix_thread";
            readonly property: "id";
        };
        readonly parent_id: {
            readonly schemaKey: "lix_thread_comment";
            readonly property: "id";
        };
    };
    readonly type: "object";
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly "x-lix-generated": true;
        };
        readonly thread_id: {
            readonly type: "string";
        };
        readonly parent_id: {
            readonly type: "string";
            readonly nullable: true;
        };
        readonly body: any;
    };
    readonly required: readonly ["id", "thread_id", "body"];
    readonly additionalProperties: false;
};
type Thread = FromLixSchemaDefinition<typeof LixThreadSchema>;
type ThreadComment = FromLixSchemaDefinition<typeof LixThreadCommentSchema> & {
    body: ZettelDoc;
};

/**
 * Base type for regular entity views (active version only) that include operational columns from the state table.
 * These views do NOT expose lixcol_version_id to prevent accidental version-specific operations.
 *
 * This type uses LixGenerated markers instead of Kysely's Generated type, making it compatible
 * with the Lix SDK's type transformation system.
 *
 * @example
 * ```typescript
 * // Define an entity view type for active version operations
 * export type AccountView = {
 *   id: LixGenerated<string>;
 *   name: string;
 * } & EntityStateColumns;
 * ```
 */
type EntityStateColumns = {
    /**
     * File identifier where this entity is stored.
     *
     * This references the file_id in the state table and links the entity
     * to a specific file in the Lix file system.
     */
    lixcol_file_id: LixGenerated<string>;
    /**
     * Version identifier this entity was inherited from during branching.
     *
     * - `null` if the entity was created in the current version
     * - Contains the source version_id if the entity was inherited from another version
     *
     * This is useful for tracking entity lineage across version branches.
     */
    lixcol_inherited_from_version_id: LixGenerated<string | null>;
    /**
     * Timestamp when this entity was created in the current version.
     *
     * **Important**: This timestamp is relative to the version, not global.
     * - When an entity is first created, this is the actual creation time
     * - When an entity is inherited from another version, this is the time it was inherited
     *
     * Format: ISO 8601 string (e.g., "2024-03-20T10:30:00.000Z")
     */
    lixcol_created_at: LixGenerated<string>;
    /**
     * Timestamp when this entity was last updated in the current version.
     *
     * **Important**: This timestamp is relative to the version, not global.
     * - Updates only when the entity is modified within the current version
     * - When first inherited, this equals lixcol_created_at
     *
     * Format: ISO 8601 string (e.g., "2024-03-20T10:30:00.000Z")
     */
    lixcol_updated_at: LixGenerated<string>;
    /**
     * Change identifier for the last modification to this entity.
     *
     * This references the change.id that last modified this entity, enabling
     * blame and diff functionality. Useful for tracking who made changes
     * and when they were made.
     */
    lixcol_change_id: LixGenerated<string>;
    /**
     * Whether this entity is stored as untracked state.
     *
     * - `false` (default): Entity follows normal change control and versioning
     * - `true`: Entity bypasses change control for UI state, temporary data, etc.
     *
     * Untracked entities don't create change records and have highest priority
     * in the state resolution order: untracked > tracked > inherited.
     */
    lixcol_untracked: LixGenerated<boolean>;
};

/**
 * Base type for _all entity views using LixGenerated markers instead of Kysely's Generated type.
 * This type is compatible with the Lix SDK's type transformation system and allows
 * cross-version entity operations.
 *
 * @example
 * ```typescript
 * // Define an entity type for cross-version operations
 * export type Account = {
 *   id: LixGenerated<string>;
 *   name: string;
 * } & EntityStateAllColumns;
 * ```
 */
type EntityStateAllColumns = {
    /**
     * File identifier where this entity is stored.
     *
     * This references the file_id in the state table and links the entity
     * to a specific file in the Lix file system.
     */
    lixcol_file_id: LixGenerated<string>;
    /**
     * Version identifier for this specific state of the entity.
     *
     * This column allows you to query and modify entities in specific versions.
     * Each version may have its own state for the same entity.
     */
    lixcol_version_id: LixGenerated<string>;
    /**
     * Timestamp when this entity was created in this version.
     *
     * **Important**: This timestamp is relative to the version specified by lixcol_version_id.
     * - When an entity is first created, this is the actual creation time
     * - When an entity is inherited from another version, this is the time it was inherited
     *
     * Format: ISO 8601 string (e.g., "2024-03-20T10:30:00.000Z")
     */
    lixcol_created_at: LixGenerated<string>;
    /**
     * Timestamp when this entity was last updated in this version.
     *
     * **Important**: This timestamp is relative to the version specified by lixcol_version_id.
     * - Updates only when the entity is modified within this specific version
     * - When first inherited, this equals lixcol_created_at
     *
     * Format: ISO 8601 string (e.g., "2024-03-20T10:30:00.000Z")
     */
    lixcol_updated_at: LixGenerated<string>;
    /**
     * Version identifier this entity was inherited from during branching.
     *
     * - `null` if the entity was created in this version
     * - Contains the source version_id if the entity was inherited from another version
     *
     * This is useful for tracking entity lineage across version branches.
     */
    lixcol_inherited_from_version_id: LixGenerated<string | null>;
    /**
     * Change identifier for the last modification to this entity.
     *
     * This references the change.id that last modified this entity, enabling
     * blame and diff functionality. Useful for tracking who made changes
     * and when they were made.
     */
    lixcol_change_id: LixGenerated<string>;
    /**
     * Whether this entity is stored as untracked state.
     *
     * - `false` (default): Entity follows normal change control and versioning
     * - `true`: Entity bypasses change control for UI state, temporary data, etc.
     *
     * Untracked entities don't create change records and have highest priority
     * in the state resolution order: untracked > tracked > inherited.
     */
    lixcol_untracked: LixGenerated<boolean>;
};

/**
 * Base type for entity history views using LixGenerated markers instead of Kysely's Generated type.
 * This type is compatible with the Lix SDK's type transformation system and provides
 * access to historical entity states.
 *
 * History views are read-only and show how entities evolved over time through changes.
 *
 * @example
 * ```typescript
 * // Define an entity history type
 * export type AccountHistory = {
 *   id: string;  // No LixGenerated marker in history views
 *   name: string;
 * } & StateEntityHistoryColumns;
 * ```
 */
type StateEntityHistoryColumns = {
    /**
     * File identifier where this entity is stored.
     *
     * This references the file_id in the state_history table and links the entity
     * to a specific file in the Lix file system.
     */
    lixcol_file_id: LixGenerated<string>;
    /**
     * Plugin identifier that manages this entity type.
     *
     * This identifies which plugin is responsible for this entity's behavior
     * and schema definition.
     */
    lixcol_plugin_key: LixGenerated<string>;
    /**
     * Version of the schema used for this entity at this point in history.
     *
     * Format: "major.minor" (e.g., "1.0", "2.1")
     * This allows tracking schema evolution over time.
     */
    lixcol_schema_version: LixGenerated<string>;
    /**
     * ID of the change that created this specific entity state.
     *
     * Each modification to an entity creates a new change, and this ID
     * references that specific change in the change table.
     */
    lixcol_change_id: LixGenerated<string>;
    /**
     * Change set ID that serves as the query root for depth calculation.
     *
     * When querying history, this represents the "perspective" from which
     * you're viewing the entity's history. The depth is calculated relative
     * to this change set.
     */
    lixcol_change_set_id: LixGenerated<string>;
    /**
     * The root change set ID used as the starting point for traversing history.
     *
     * When querying history from a specific changeset, this field contains that
     * changeset ID for all returned rows. Used with `depth` to understand how
     * far back in history each entity state is from this root.
     */
    lixcol_root_change_set_id: LixGenerated<string>;
    /**
     * Depth of this entity state relative to the queried change_set_id.
     *
     * - `0`: The entity state at the exact queried change set
     * - `1`: The entity state one change before the queried change set
     * - `2+`: Earlier states, going back in history
     *
     * This is useful for blame functionality and understanding how an entity
     * evolved to reach its current state.
     */
    lixcol_depth: LixGenerated<number>;
};

/**
 * Check if a type has the LixGenerated brand
 */
type IsLixGenerated<T> = T extends {
    readonly __lixGenerated?: true;
} ? true : false;
/**
 * Extract the base type from LixGenerated<T>
 * Since LixGenerated<T> = T & { brand }, we need to extract T
 */
type ExtractFromGenerated<T> = T extends LixGenerated<infer U> ? U : T;
/**
 * Extract the select type from LixGenerated or return the type as-is
 */
type SelectType<T> = ExtractFromGenerated<T>;
/**
 * Convert our LixGenerated types to Kysely's Generated types.
 * This adapter is used at the database boundary.
 */
type ToKysely<T> = {
    [K in keyof T]: IsLixGenerated<T[K]> extends true ? Generated<SelectType<T[K]>> : T[K];
};
/**
 * View type for entities in the active version only.
 *
 * This type combines your entity properties with Lix operational columns
 * (file_id, timestamps, etc.) while preserving LixGenerated markers for
 * database schema compatibility.
 *
 * Use this type when defining database views that work with the current
 * active version only.
 *
 * @example
 * ```typescript
 * // Define a view type for key-value entities
 * type KeyValueView = EntityStateView<KeyValue>;
 *
 * // The resulting type includes both entity properties and operational columns
 * // { key: string, value: any, lixcol_file_id: LixGenerated<string>, ... }
 * ```
 */
type EntityStateView<T> = T & EntityStateColumns;
/**
 * View type for entities across all versions.
 *
 * This type combines your entity properties with Lix operational columns
 * including the version_id, allowing you to query and manipulate entities
 * in specific versions.
 *
 * Use this type when defining database views that need to work across
 * multiple versions.
 *
 * @example
 * ```typescript
 * // Define a view type for key-value entities across versions
 * type KeyValueAllView = EntityStateAllView<KeyValue>;
 *
 * // Query entities in a specific version
 * await lix.db
 *   .selectFrom("key_value_all")
 *   .where("lixcol_version_id", "=", "v2")
 *   .selectAll()
 *   .execute();
 * ```
 */
type EntityStateAllView<T> = T & EntityStateAllColumns;
/**
 * View type for entity history (read-only).
 *
 * This type combines your entity properties with historical tracking columns,
 * allowing you to see how entities evolved over time through different change sets.
 *
 * History views are read-only and include change tracking information like
 * change_id, change_set_id, and depth for blame functionality.
 *
 * @example
 * ```typescript
 * // Define a history view type for key-value entities
 * type KeyValueHistoryView = EntityStateHistoryView<KeyValue>;
 *
 * // Query entity state at a specific change set
 * await lix.db
 *   .selectFrom("key_value_history")
 *   .where("lixcol_change_set_id", "=", changeSetId)
 *   .where("lixcol_depth", "=", 0)
 *   .selectAll()
 *   .execute();
 * ```
 */
type EntityStateHistoryView<T> = T & StateEntityHistoryColumns;
/**
 * Type for querying entities from the active version.
 *
 * This type unwraps all LixGenerated markers, giving you the actual runtime types
 * for entity properties and operational columns. Use this when working with
 * query results from the database or passing data to UI components.
 *
 * All properties are required and have their actual types (no LixGenerated wrappers).
 *
 * @example
 * ```typescript
 * // Use State type for UI components that display entity data
 * interface SettingsCardProps {
 *   setting: State<KeyValue>;
 * }
 *
 * function SettingsCard({ setting }: SettingsCardProps) {
 *   return (
 *     <div>
 *       <h3>{setting.key}</h3>
 *       <p>{setting.value}</p>
 *       <time>{setting.lixcol_updated_at}</time>
 *     </div>
 *   );
 * }
 *
 * // Query and pass to UI
 * const settings = await lix.db
 *   .selectFrom("key_value")
 *   .selectAll()
 *   .execute();
 *
 * settings.map(setting => <SettingsCard setting={setting} />);
 * ```
 */
type State<T> = LixSelectable<EntityStateView<T>>;
/**
 * Type for querying entities across all versions.
 *
 * This type unwraps all LixGenerated markers and includes the version_id column,
 * allowing you to work with entities from any version in the database.
 *
 * All properties are required and have their actual types (no LixGenerated wrappers).
 *
 * @example
 * ```typescript
 * // Use StateAll for version comparison UI
 * interface VersionDiffProps {
 *   oldValue: StateAll<KeyValue>;
 *   newValue: StateAll<KeyValue>;
 * }
 *
 * function VersionDiff({ oldValue, newValue }: VersionDiffProps) {
 *   return (
 *     <div>
 *       <h4>{oldValue.key}</h4>
 *       <div>Version {oldValue.lixcol_version_id}: {oldValue.value}</div>
 *       <div>Version {newValue.lixcol_version_id}: {newValue.value}</div>
 *     </div>
 *   );
 * }
 * ```
 */
type StateAll<T> = LixSelectable<EntityStateAllView<T>>;
/**
 * Type for querying entity history.
 *
 * This type unwraps all LixGenerated markers and includes historical tracking
 * columns like change_id, change_set_id, and depth. Use this for blame
 * functionality and understanding how entities evolved.
 *
 * History queries are read-only.
 *
 * @example
 * ```typescript
 * // Use StateHistory for blame UI
 * interface BlameViewProps {
 *   history: StateHistory<KeyValue>[];
 * }
 *
 * function BlameView({ history }: BlameViewProps) {
 *   return (
 *     <ul>
 *       {history.map(state => (
 *         <li key={state.lixcol_change_id}>
 *           <strong>Depth {state.lixcol_depth}:</strong> {state.value}
 *           <br />
 *           <small>Change: {state.lixcol_change_id}</small>
 *         </li>
 *       ))}
 *     </ul>
 *   );
 * }
 * ```
 */
type StateHistory<T> = LixSelectable<EntityStateHistoryView<T>>;
/**
 * Type for creating new entities in the active version.
 *
 * This type makes all LixGenerated columns optional (like id, timestamps),
 * while keeping other required fields mandatory. The database will
 * automatically populate generated fields if not provided.
 *
 * @example
 * ```typescript
 * // Use NewState for form data types
 * interface SettingsFormData {
 *   setting: NewState<KeyValue>;
 * }
 *
 * async function createSetting(formData: SettingsFormData) {
 *   // Only key and value are required
 *   const newSetting: NewState<KeyValue> = {
 *     key: formData.setting.key,
 *     value: formData.setting.value
 *     // lixcol_created_at, lixcol_file_id etc. are auto-generated
 *   };
 *
 *   await lix.db
 *     .insertInto("key_value")
 *     .values(newSetting)
 *     .execute();
 * }
 * ```
 */
type NewState<T> = LixInsertable<EntityStateView<T>>;
/**
 * Type for updating entities in the active version.
 *
 * This type makes all columns optional, allowing partial updates.
 * Only include the fields you want to change - the database will
 * preserve existing values for omitted fields.
 *
 * @example
 * ```typescript
 * // Use StateUpdate for update form data
 * interface UpdateSettingData {
 *   updates: StateUpdate<KeyValue>;
 * }
 *
 * async function updateSetting(key: string, updates: UpdateSettingData) {
 *   // Only update the fields that changed
 *   const patch: StateUpdate<KeyValue> = {
 *     value: updates.updates.value
 *     // key, timestamps, etc. remain unchanged
 *   };
 *
 *   await lix.db
 *     .updateTable("key_value")
 *     .set(patch)
 *     .where("key", "=", key)
 *     .execute();
 * }
 * ```
 */
type StateUpdate<T> = LixUpdateable<EntityStateView<T>>;
/**
 * Type for creating new entities with version control.
 *
 * This type includes lixcol_version_id for creating entities in specific
 * versions. Like NewState, it makes LixGenerated columns optional.
 *
 * @example
 * ```typescript
 * // Use NewStateAll for version-specific creation
 * async function createFeatureFlag(versionId: string, flag: {
 *   key: string;
 *   value: boolean;
 * }) {
 *   const newFlag: NewStateAll<KeyValue> = {
 *     key: flag.key,
 *     value: flag.value,
 *     lixcol_version_id: versionId  // Create in specific version
 *   };
 *
 *   await lix.db
 *     .insertInto("key_value_all")
 *     .values(newFlag)
 *     .execute();
 * }
 * ```
 */
type NewStateAll<T> = LixInsertable<EntityStateAllView<T>>;
/**
 * Type for updating entities in specific versions.
 *
 * This type makes all columns optional for partial updates and includes
 * version control. You can update entities in any version or change
 * an entity's version.
 *
 * @example
 * ```typescript
 * // Use StateAllUpdate for version-specific updates
 * async function toggleFeatureFlag(
 *   key: string,
 *   versionId: string,
 *   enabled: boolean
 * ) {
 *   const updates: StateAllUpdate<KeyValue> = {
 *     value: enabled
 *   };
 *
 *   await lix.db
 *     .updateTable("key_value_all")
 *     .set(updates)
 *     .where("key", "=", key)
 *     .where("lixcol_version_id", "=", versionId)
 *     .execute();
 * }
 * ```
 */
type StateAllUpdate<T> = LixUpdateable<EntityStateAllView<T>>;

/**
 * Utility type that generates database schema view entries for an entity schema.
 * Creates three views: normal (active version), all versions, and history.
 *
 * TSchema should be a LixSchemaDefinition (typeof SomeSchema).
 * TOverride allows you to provide partial type overrides for specific properties.
 *
 * @example
 * ```typescript
 * // Basic usage with schema definition
 * type LogViews = EntityViews<typeof LixLogSchema, "log">;
 *
 * // With partial property override
 * type ThreadCommentViews = EntityViews<
 *   typeof LixThreadCommentSchema,
 *   "thread_comment",
 *   { body: ZettelDoc }
 * >;
 * ```
 */
type EntityViews<TSchema extends LixSchemaDefinition, TViewName extends string, TOverride = object> = {
    [K in TViewName]: ToKysely<EntityStateView<FromLixSchemaDefinition<TSchema> & TOverride>>;
} & {
    [K in `${TViewName}_all`]: ToKysely<EntityStateAllView<FromLixSchemaDefinition<TSchema> & TOverride>>;
} & {
    [K in `${TViewName}_history`]: ToKysely<EntityStateHistoryView<FromLixSchemaDefinition<TSchema> & TOverride>>;
};

type LixDatabaseSchema = {
    state: StateView;
    state_all: StateAllView;
    state_history: StateHistoryView;
    active_account: ActiveAccountTable;
    change: ChangeView;
    active_version: ToKysely<ActiveVersion>;
} & EntityViews<typeof LixKeyValueSchema, "key_value", {
    value: KeyValue["value"];
}> & EntityViews<typeof LixAccountSchema, "account"> & EntityViews<typeof LixChangeSetSchema, "change_set"> & EntityViews<typeof LixChangeSetElementSchema, "change_set_element"> & EntityViews<typeof LixChangeSetEdgeSchema, "change_set_edge"> & EntityViews<typeof LixChangeSetLabelSchema, "change_set_label"> & EntityViews<typeof LixChangeSetThreadSchema, "change_set_thread"> & EntityViews<typeof LixChangeAuthorSchema, "change_author"> & EntityViews<typeof LixFileDescriptorSchema, "file", {
    data: Uint8Array;
}> & EntityViews<typeof LixLabelSchema, "label"> & EntityViews<typeof LixStoredSchemaSchema, "stored_schema", {
    value: any;
}> & EntityViews<typeof LixLogSchema, "log"> & EntityViews<typeof LixThreadSchema, "thread"> & EntityViews<typeof LixThreadCommentSchema, "thread_comment", {
    body: ThreadComment["body"];
}> & EntityViews<typeof LixVersionSchema, "version">;

/**
 * Storage adapter interface for Lix.
 */

interface LixStorageAdapter {
    open(): Promise<SqliteWasmDatabase>;
    close(): Promise<void>;
    import(blob: Blob): Promise<void>;
    export(): Promise<Blob>;
    /**
     * Called when state commits happen.
     * Optional method for storage adapters that want to persist on state changes.
     */
    onStateCommit?(): void;
}

/**
 * Micro-observable implementation following TC-39 Observable protocol.
 * ~25 lines of code for minimal footprint while maintaining spec compliance.
 */
declare global {
    interface SymbolConstructor {
        readonly observable: symbol;
    }
}
interface Observer<T> {
    next?: (value: T) => void;
    error?: (error: any) => void;
    complete?: () => void;
}
interface Subscription {
    unsubscribe(): void;
}
interface Observable<T> {
    subscribe(observer: Partial<Observer<T>>): Subscription;
    [Symbol.observable](): Observable<T>;
}
declare class LixObservable<T> implements Observable<T[]> {
    private subscriber;
    constructor(subscriber: (observer: Observer<T[]>) => (() => void) | void);
    subscribe(observer: Partial<Observer<T[]>>): Subscription;
    [Symbol.observable](): LixObservable<T>;
    subscribeTakeFirst(observer: Partial<Observer<T | undefined>>): Subscription;
    subscribeTakeFirstOrThrow(observer: Partial<Observer<T>>): Subscription;
}

/**
 * Options for the observe method.
 */
interface ObserveOptions {
    mode?: "array" | "first" | "firstOrThrow";
}
/**
 * Creates the observe function for a Lix instance.
 *
 * @param lix - The Lix instance to add observables to
 * @returns The observe function
 */
declare function createObserve(lix: Pick<Lix, "hooks">): <T>(query: SelectQueryBuilder<any, any, T>, options?: ObserveOptions) => LixObservable<T>;

type Lix = {
    /**
     * The raw SQLite instance.
     *
     * Required for advanced use cases that can't be
     * expressed with the db API.
     *
     * Use with caution, automatic transformation of
     * results like parsing json (similar to the db API)
     * is not guaranteed.
     */
    sqlite: SqliteWasmDatabase;
    db: Kysely<LixDatabaseSchema>;
    plugin: {
        getAll: () => Promise<LixPlugin[]>;
        getAllSync: () => LixPlugin[];
    };
    /**
     * Hooks for listening to database lifecycle events.
     *
     * Allows registering callbacks that fire at specific points
     * in Lix's execution, such as when state changes are committed.
     */
    hooks: LixHooks;
    /**
     * Closes the lix instance and its storage.
     */
    close: () => Promise<void>;
    observe: ReturnType<typeof createObserve>;
    /**
     * Serialises the Lix into a {@link Blob}.
     *
     * Use this helper to persist the current state to disk or send it to a
     * server. The blob contains the raw SQLite file representing the Lix
     * project.
     *
     * @example
     * ```ts
     * const blob = await lix.toBlob()
     * download(blob)
     * ```
     */
    toBlob: () => Promise<Blob>;
};
/**
 * Opens a Lix instance.
 *
 * Creates an in-memory database by default. If a blob is provided,
 * the database is initialized with that data. If a database is provided,
 * uses that database directly.
 *
 * TODO: Add storage abstraction to support:
 *   - OPFS storage (persistent in browser)
 *   - Node.js filesystem storage
 *   - Custom storage adapters
 *
 * @example
 * ```ts
 * // In-memory (default)
 * const lix = await openLix({})
 *
 * // From existing data
 * const lix = await openLix({ blob: existingLixFile })
 *
 * // With custom database (current approach)
 * const db = await createInMemoryDatabase({ readOnly: false })
 * const lix = await openLix({ database: db })
 * ```
 */
declare function openLix(args: {
    /**
     * The account that is opening this lix.
     *
     * Lix will automatically set the active account to the provided account.
     *
     * @example
     *   const account = localStorage.getItem("account")
     *   const lix = await openLix({ account })
     */
    account?: Account;
    /**
     * Lix file data to initialize the database with.
     */
    blob?: Blob;
    /**
     * Storage adapter for persisting lix data.
     *
     * @default InMemoryStorage
     */
    storage?: LixStorageAdapter;
    /**
     * Usecase are lix apps that define their own file format,
     * like inlang (unlike a markdown, csv, or json plugin).
     *
     * (+) avoids separating app code from plugin code and
     *     resulting bundling logic.
     *
     * (-) such a file format must always be opened with the
     *     file format sdk. the file is not portable
     *
     * @example
     *   const lix = await openLix({ providePlugins: [myPlugin] })
     */
    providePlugins?: LixPlugin[];
    /**
     * Set the key values when opening the lix.
     *
     * @example
     *   const lix = await openLix({ keyValues: [{ key: "lix_sync", value: "false" }] })
     */
    keyValues?: NewState<KeyValue>[];
}): Promise<Lix>;

/**
 * Inserts a new account into the Lix database.
 *
 * Accounts represent different identities working with the same Lix
 * file. Switching the active account is handled separately via
 * {@link switchAccount}.
 *
 * @example
 * ```ts
 * const account = await createAccount({ lix, name: "Jane" })
 * ```
 */
declare function createAccount(args: {
    lix: Pick<Lix, "db">;
    id?: Account["id"];
    name: Account["name"];
    lixcol_version_id?: string;
}): Promise<Account>;

/**
 * Switch the current account to the provided account.
 *
 * @example
 *
 *   One active account
 *
 *   ```ts
 *   await switchAccount({ lix, to: [otherAccount] });
 *   ```
 *
 * @example
 *
 *   Multiple active accounts
 *
 *   ```ts
 *   await switchAccount({ lix, to: [account1, account2] });
 *   ```
 */
declare function switchAccount(args: {
    lix: Pick<Lix, "db">;
    to: Pick<Account, "id" | "name">[];
}): Promise<void>;

/**
 * Creates a change set and optionally attaches elements, labels and parents.
 *
 * Change sets are the building blocks of versions and checkpoints. This
 * function inserts all provided relations in a single transaction and
 * returns the newly created record.
 *
 * @example
 * ```ts
 * const cs = await createChangeSet({ lix, elements: [{ change_id, entity_id }] })
 * ```
 */
declare function createChangeSet(args: {
    lix: Pick<Lix, "db">;
    id?: string;
    elements?: Omit<NewState<ChangeSetElement>, "change_set_id">[];
    labels?: Pick<Label, "id">[];
    /** Parent change sets that this change set will be a child of */
    parents?: Pick<ChangeSet, "id">[];
    /** Version ID where the change set should be stored. Defaults to active version */
    lixcol_version_id?: string;
}): Promise<ChangeSet & {
    lixcol_version_id: string;
}>;

/**
 * A Blob with an attached `._lix` property for easy access to some lix properties.
 *
 * For example, the `._lix` property provides immediate access to essential metadata
 * like `id` and `name` without needing to parse the file. This is particularly useful
 * for scenarios where you need to identify a Lix file before fully opening it.
 *
 * @example
 * // With `._lix`, the ID is instantly available:
 * const blob = await newLixFile();
 * console.log(blob._lix.id); // e.g., "z2k9j6d"
 *
 * @example
 * // Without `._lix`, you would need to open the lix to get its ID:
 * const blob = await newLixFile();
 * // Open the lix to access its metadata
 * const lix = await openLix({ blob });
 * const id = await lix.db.selectFrom("key_value")
 *   .where("key", "=", "lix_id")
 *   .select("value")
 *   .executeTakeFirst();
 * await lix.close();
 *
 */
interface NewLixBlob extends Blob {
    _lix: {
        id: string;
        name: string;
    };
}
/**
 * Creates a new Lix file as a {@link NewLixBlob}.
 *
 * This function bootstraps an in-memory SQLite database with the necessary
 * schema and metadata to represent a valid Lix project. The resulting
 * blob is ready to be persisted to disk, IndexedDB, or other storage.
 *
 * The returned blob has a `._lix` property for immediate access to the
 * lix identifier and name without needing to open the file.
 *
 * @example
 * ```ts
 * // Create a new lix file with default values
 * const blob = await newLixFile();
 * console.log(blob._lix.id); // e.g. "z2k9j6d"
 * console.log(blob._lix.name); // e.g. "blue-gorilla"
 * ```
 *
 * @example
 * ```ts
 * // Create a new lix file with specific key-values
 * const blob = await newLixFile({
 *   keyValues: [
 *     { key: "lix_name", value: "my-project", lixcol_version_id: "global" },
 *     { key: "lix_id", value: "custom-id", lixcol_version_id: "global" },
 *     { key: "my_custom_key", value: "my_custom_value", lixcol_version_id: "global" }
 *   ],
 * });
 * console.log(blob._lix.id); // "custom-id"
 * console.log(blob._lix.name); // "my-project"
 * ```
 */
declare function newLixFile(args?: {
    /**
     * Pre-populates the key-value store of the new lix file.
     *
     * Use this to set initial values for `lix_id`, `lix_name`, or other custom keys.
     * If `lix_id` or `lix_name` are not provided, they will be generated automatically.
     *
     * @example
     *  keyValues: [
     *    { key: "lix_name", value: "my-project", lixcol_version_id: "global" },
     *    { key: "lix_id", value: "custom-id", lixcol_version_id: "global" },
     *    { key: "my_custom_key", value: "my_custom_value", lixcol_version_id: "global" },
     *  ]
     */
    keyValues?: NewStateAll<KeyValue>[];
}): Promise<NewLixBlob>;

/**
 * In-memory storage adapter for Lix.
 *
 * Data is stored only for the lifetime of the JavaScript context.
 * When the page is refreshed or the application is closed, all data is lost.
 */
declare class InMemoryStorage implements LixStorageAdapter {
    private database?;
    /**
     * Opens an in-memory SQLite database.
     *
     * Creates a new empty lix if this is the first time opening.
     * Returns the same database instance on subsequent calls.
     */
    open(): Promise<SqliteWasmDatabase>;
    /**
     * Closes the database connection.
     *
     * Note: For in-memory databases, this just clears the reference.
     * The data is lost when the database is no longer referenced.
     */
    close(): Promise<void>;
    /**
     * Imports data from a blob, replacing the current database content.
     */
    import(blob: Blob): Promise<void>;
    /**
     * Exports the current database state as a blob.
     */
    export(): Promise<Blob>;
}

/**
 * OPFS (Origin Private File System) storage adapter for Lix.
 *
 * Provides persistent storage in the browser using the Origin Private File System API.
 * Data persists across browser sessions and page refreshes.
 *
 * Features auto-saving functionality when integrated with the hooks system.
 */
declare class OpfsStorage implements LixStorageAdapter {
    private database?;
    private readonly path;
    private opfsRoot?;
    private savePromise?;
    private pendingSave;
    /**
     * Creates a new OpfsStorage instance.
     *
     * @param args.path - Path/name of the file to store in OPFS
     */
    constructor(args: {
        path: string;
    });
    /**
     * Opens a database with OPFS persistence.
     *
     * Loads existing data from OPFS if available, otherwise creates a new lix.
     * Returns the same database instance on subsequent calls.
     */
    open(): Promise<SqliteWasmDatabase>;
    /**
     * Closes the database connection.
     *
     * Performs a final save to OPFS before closing.
     */
    close(): Promise<void>;
    /**
     * Imports data from a blob, replacing the current database content.
     *
     * Also saves the imported data to OPFS.
     */
    import(blob: Blob): Promise<void>;
    /**
     * Exports the current database state as a blob.
     */
    export(): Promise<Blob>;
    /**
     * Saves the current database state to OPFS.
     *
     * This method is called automatically during import/close,
     * and can be called manually or triggered by the hooks system.
     */
    private save;
    /**
     * Called when state commits happen.
     * Automatically saves the current state to OPFS.
     */
    onStateCommit(): void;
    /**
     * Batches save operations to avoid multiple concurrent saves.
     * Only one save operation will run at a time, with the latest state.
     */
    private batchedSave;
}

/**
 * Applies a change set to the lix.
 */
declare function applyChangeSet(args: {
    lix: Lix;
    changeSet: Pick<ChangeSet, "id">;
}): Promise<void>;

/**
 * Merges two change sets using a "source wins" strategy (until lix models conflicts).
 *
 * Creates a new change set containing the merged result. If an element
 * (identified by entity_id, file_id, schema_key) exists in both the source
 * and target change sets (considering their respective histories), the element
 * from the source change set's history takes precedence.
 *
 * @param args - The arguments for the merge operation.
 * @param args.lix - The Lix instance.
 * @param args.source - The source change set (only `id` is needed).
 * @param args.target - The target change set (only `id` is needed).
 *
 * @returns A Promise resolving to the newly created ChangeSet representing the merged state.
 */
declare function createMergeChangeSet(args: {
    lix: Lix;
    source: Pick<ChangeSet, "id">;
    target: Pick<ChangeSet, "id">;
}): Promise<ChangeSet>;

/**
 * Creates a "reverse" change set that undoes the changes made by the specified change set.
 *
 * @example
 *   ```ts
 *   const undoChangeSet = await createUndoChangeSet({
 *     lix,
 *     changeSet: targetChangeSet
 *   });
 *
 *   await applyChangeSet({
 *     lix,
 *     changeSet: undoChangeSet
 *   });
 *   ```
 *
 * @returns The newly created change set that contains the undo operations
 */
declare function createUndoChangeSet(args: {
    lix: Lix;
    changeSet: Pick<ChangeSet, "id">;
    labels?: Pick<Label, "id">[];
}): Promise<ChangeSet>;

/**
 * Converts the current working change set into a checkpoint.
 *
 * The working change set becomes immutable and receives the
 * `checkpoint` label. A fresh empty working change set is created so
 * that new changes can continue to accumulate.
 *
 * @example
 * ```ts
 * const { id } = await createCheckpoint({ lix })
 * ```
 */
declare function createCheckpoint(args: {
    lix: Lix;
}): Promise<{
    id: string;
}>;

/**
 * Creates a change set that enables a transition from a source state
 * (defined by `sourceChangeSet`) to a target state (defined by `targetChangeSet`).
 *
 * Applying the returned change set to the source state will result in a state
 * that matches the target state.
 *
 * - switch between state (switching versions, checkpoints, etc.)
 * - restore old state (applying the transition set on top of current state)
 */
declare function createTransitionChangeSet(args: {
    lix: Lix;
    sourceChangeSet: Pick<ChangeSet, "id">;
    targetChangeSet: Pick<ChangeSet, "id">;
}): Promise<ChangeSet>;

/**
 * Execute a query synchronously.
 *
 * ⚠️  MAJOR WARNING: This function is a PURE SQL LAYER without transformations!
 *
 * - JSON columns return as RAW JSON STRINGS, not parsed objects
 * - You must manually parse/stringify JSON data
 * - No automatic type conversions happen
 * - Results are raw SQLite values
 *
 * Only use this for triggers, database functions, or when you specifically
 * need synchronous database access and understand you're working with raw SQL.
 *
 * @example
 *   // JSON columns are returned as strings - you must parse manually:
 *   const result = executeSync({ lix, query });
 *   result[0].metadata = JSON.parse(result[0].metadata);
 */
declare function executeSync(args: {
    lix: Pick<Lix, "sqlite">;
    query: any;
}): Array<any>;

/**
 * Generate secure URL-friendly unique ID.
 *
 * Use https://zelark.github.io/nano-id-cc/ to calculate the length
 * of the ID for the use case with the alphabet provided in the
 * implementation.
 */
declare const nanoid: (size?: number) => string;

/**
 * Creates a label that can be attached to change sets.
 *
 * Labels help categorise change sets, for example "checkpoint" or
 * "reviewed". They are simple name identifiers stored per version.
 *
 * @example
 * ```ts
 * const label = await createLabel({ lix, name: "checkpoint" })
 * ```
 */
declare function createLabel(args: {
    lix: Pick<Lix, "db">;
    id?: Label["id"];
    name: Label["name"];
    lixcol_version_id?: string;
}): Promise<Label>;

/**
 * Directly creates a log entry in the Lix database without applying any filters.
 *
 * This function inserts the log entry regardless of the `lix_log_levels` setting
 * in the key-value store. It is the responsibility of the calling application
 * to implement any desired log level filtering before invoking this function.
 *
 * It is recommended to use dot notation for log keys (e.g., 'app.module.component').
 *
 * @example
 * // Directly log an info message
 *
 * if (shouldLog) {
 *   await createLog({
 *     lix,
 *     key: 'app.init',
 *     level: 'info',
 *     message: 'Application initialized'
 * });
 *
 * @returns A promise that resolves with the created log entry.
 */
declare function createLog(args: {
    lix: Pick<Lix, "sqlite" | "db">;
    message: string;
    level: string;
    key: string;
}): Promise<State<Log>>;

/**
 * A mock plugin that handles JSON data.
 *
 * Use this mock plugin for testing purposes. Do not
 * use this plugin in production! It may change at
 * any time.
 *
 * @example
 *   const lix = await openLix({
 *     providePlugins: [mockJsonPlugin],
 *   });
 */
declare const mockJsonPlugin: LixPlugin;

/**
 * Selects changes that have a label with the given name.
 *
 * @example
 *   ```ts
 *   await lix.db.selectFrom("change")
 *      .where(changeHasLabel({ name: "checkpoint" }))
 *      .selectAll()
 *      .execute();
 *   ```
 *
 * @example
 *   You can use eb.not() to negate the filter.
 *
 *   ```ts
 *   await lix.db.selectFrom("change")
 * 		.where((eb) => eb.not(changeHasLabel({ name: "checkpoint"})))
 * 		.selectAll()
 * 		.execute();
 *   ```
 */
declare function changeHasLabel(label: {
    id: string;
    name?: string;
} | {
    name: string;
    id?: string;
}): (eb: ExpressionBuilder<LixDatabaseSchema, "change">) => ExpressionWrapper<LixDatabaseSchema, "change", SqlBool>;

/**
 * Filters elements that are in the ancestry of the given change set(s).
 *
 * @param target - A target change set object (or its id), or an array of such objects/ids.
 * @param options - Optional options object (e.g., depth limit)
 * @returns A Kysely ExpressionBuilder function for filtering.
 *
 * @example
 * // Elements from the history of cs2 (object)
 * db.selectFrom("change_set_element")
 *   .where(changeSetElementInAncestryOf(cs2))
 *   .selectAll()
 *
 * // Elements from the history of cs2 (id)
 * db.selectFrom("change_set_element")
 *   .where(changeSetElementInAncestryOf(cs2.id))
 *   .selectAll()
 *
 * // Elements from the combined history of cs2 and cs4 (divergent branches)
 * db.selectFrom("change_set_element")
 *   .where(changeSetElementInAncestryOf([cs2, cs4]))
 *   .selectAll()
 */
declare function changeSetElementInAncestryOf(target: Pick<ChangeSet, "id"> | Array<Pick<ChangeSet, "id">>, options?: {
    depth?: number;
}): (eb: ExpressionBuilder<LixDatabaseSchema, "change_set_element">) => ExpressionWrapper<LixDatabaseSchema, "change_set_element", SqlBool>;

/**
 * Selects change sets that have a label with the given name.
 *
 * @example
 *   ```ts
 *   await lix.db.selectFrom("change_set")
 *      .where(changeSetHasLabel({ name: "checkpoint" }))
 *      .selectAll()
 *      .execute();
 *   ```
 *
 * @example
 *   You can use eb.not() to negate the filter.
 *
 *   ```ts
 *   await lix.db.selectFrom("change_set")
 * 		.where((eb) => eb.not(changeSetHasLabel({ name: "checkpoint" })))
 * 		.selectAll()
 * 		.execute();
 *   ```
 *
 * @example
 *   Id lookup also works:
 *
 *   ```ts
 *   await lix.db.selectFrom("change_set")
 * 		.where(changeSetHasLabel({ id: "39j9afj2" }))
 * 		.selectAll()
 * 		.execute();
 *   ```
 */
declare function changeSetHasLabel(label: {
    id: string;
    name?: string;
} | {
    name: string;
    id?: string;
}): (eb: ExpressionBuilder<LixDatabaseSchema, "change_set">) => ExpressionWrapper<LixDatabaseSchema, "change_set", SqlBool>;

/**
 * Filters change sets that are ancestors of the given change set.
 *
 * By default, this is **exclusive**, meaning it returns only change sets strictly
 * *before* the provided change set in the graph.
 *
 * Traverses the `change_set_edge` graph recursively, starting from the provided change set
 * (or its parents if exclusive), and returns all change sets reachable via parent edges.
 *
 * This filter is typically used to scope the graph before applying filters like `changeIsLeaf()`.
 *
 * ⚠️ This filter only defines the traversal scope — it does not filter changes directly.
 *
 * --- Options ---
 * - `includeSelf`: If `true`, includes the starting `changeSet` in the results. Defaults to `false`.
 * - `depth`: Limits the traversal depth. `depth: 1` selects only immediate parents (if exclusive)
 *   or the starting node and its immediate parents (if inclusive).
 *
 * --- Examples ---
 *
 * @example Selecting strict ancestors (default)
 * ```ts
 * db.selectFrom("change_set")
 *   .where(changeSetIsAncestorOf({ id: "cs3" }))
 *   .selectAll()
 * ```
 *
 * @example Selecting inclusive ancestors
 * ```ts
 * db.selectFrom("change_set")
 *   .where(changeSetIsAncestorOf({ id: "cs3" }, { includeSelf: true }))
 *   .selectAll()
 * ```
 *
 * @example Combining with changeSetIsDescendantOf to select change sets between two points in time
 * ```ts
 * // Select all change sets between startPoint and endPoint (inclusive)
 * db.selectFrom("change_set")
 *   .where(changeSetIsDescendantOf({ id: "startPoint" }))
 *   .where(changeSetIsAncestorOf({ id: "endPoint" }))
 *   .selectAll()
 * ```
 */
declare function changeSetIsAncestorOf(changeSet: Pick<ChangeSet, "id">, options?: {
    depth?: number;
    includeSelf?: boolean;
}): (eb: ExpressionBuilder<LixDatabaseSchema, "change_set">) => ExpressionWrapper<LixDatabaseSchema, "change_set", SqlBool>;

/**
 * Filters change sets that are descendants of the given change set.
 *
 * By default, this is **exclusive**, meaning it returns only change sets strictly
 * *after* the provided change set in the graph.
 *
 * Traverses the `change_set_edge` graph recursively, starting from the provided change set
 * (or its children if exclusive), and returns all change sets reachable via child edges.
 *
 * This filter is useful for finding changes made *after* a specific point in time (e.g., a checkpoint).
 *
 * ⚠️ This filter only defines the traversal scope — it does not filter changes directly.
 *
 * --- Options ---
 * - `includeSelf`: If `true`, includes the starting `changeSet` in the results. Defaults to `false`.
 * - `depth`: Limits the traversal depth. `depth: 1` selects only immediate children (if exclusive)
 *   or the starting node and its immediate children (if includeSelf is true).
 *
 * --- Examples ---
 *
 * @example Selecting strict descendants (default)
 * ```ts
 * db.selectFrom("change_set")
 *   .where(changeSetIsDescendantOf({ id: "cs1" }))
 *   .selectAll()
 * ```
 *
 * @example Combining with changeSetIsAncestorOf to select change sets between two points in time
 * ```ts
 * // Select all change sets between startPoint and endPoint (inclusive)
 * db.selectFrom("change_set")
 *   .where(changeSetIsDescendantOf({ id: "startPoint" }))
 *   .where(changeSetIsAncestorOf({ id: "endPoint" }))
 *   .selectAll()
 * ```
 */
declare function changeSetIsDescendantOf(changeSet: Pick<ChangeSet, "id">, options?: {
    depth?: number;
    includeSelf?: boolean;
}): (eb: ExpressionBuilder<LixDatabaseSchema, "change_set">) => ExpressionWrapper<LixDatabaseSchema, "change_set", SqlBool>;

/**
 * Filters the leaves of the given change set(s).
 *
 * An element is considered a **leaf** if no other element in the combined ancestry
 * of the target change sets redefines the same entity at a later point in the graph.
 *
 * @param target - A target change set object (or its id), or an array of such objects/ids.
 *
 * @example
 * // Find leaves relative to a single change set (object)
 * db.selectFrom("change_set_element")
 *   .where(changeSetElementIsLeafOf(cs))
 *   .selectAll()
 *
 * // Find leaves relative to a single change set (id)
 * db.selectFrom("change_set_element")
 *   .where(changeSetElementIsLeafOf(cs.id))
 *   .selectAll()
 *
 * // Find leaves relative to multiple change sets
 * db.selectFrom("change_set_element")
 *   .where(changeSetElementIsLeafOf([cs_source, cs_target]))
 *   .selectAll()
 */
declare function changeSetElementIsLeafOf(target: Pick<ChangeSet, "id"> | Array<Pick<ChangeSet, "id">>): (eb: ExpressionBuilder<LixDatabaseSchema, "change_set_element">) => ExpressionWrapper<LixDatabaseSchema, "change_set_element", SqlBool>;

/**
 * Returns the symmetric difference between two change sets.
 *
 * The symmetric difference is the set of changes
 * that exist in either one version but not both.
 * Modeled after https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/symmetricDifference
 *
 * @example
 *   ```ts
 *   await lix.db.selectFrom("change_set_element")
 *     .where(changeSetElementInSymmetricDifference(a: changeSetA, b: changeSetB))
 *     .selectAll()
 *     .execute();
 *   ```
 */
declare function changeSetElementInSymmetricDifference(a: Pick<ChangeSet, "id">, b: Pick<ChangeSet, "id">): (eb: ExpressionBuilder<LixDatabaseSchema, "change_set_element">) => ExpressionWrapper<LixDatabaseSchema, "change_set_element", SqlBool>;

type JSONType = string | number | boolean | null | JSONType[] | {
    [key: string]: JSONType;
};
/**
 * JSON schema definition for JSON values (object, array, string, number, boolean, null).
 *
 * @example
 *   const MySchema = {
 *     type: "object",
 *     properties: {
 *       myJsonField: JSONTypeSchema,
 *     },
 *   }
 */
declare const JSONTypeSchema: Record<string, any>;

/**
 * Validates that a schema conforms to the LixSchemaDefinition format
 * and then validates data against that schema.
 *
 * @param schema - The Lix schema definition to validate against
 * @param data - The data to validate
 * @returns true if both the schema and data are valid
 * @throws Error with validation details if either validation fails
 *
 * @example
 * ```typescript
 * const userSchema = {
 *   "x-lix-key": "user",
 *   "x-lix-version": "1.0",
 *   type: "object",
 *   properties: {
 *     id: { type: "string" },
 *     name: { type: "string" },
 *     age: { type: "number" }
 *   },
 *   required: ["id", "name"]
 * } as const satisfies LixSchemaDefinition;
 *
 * const userData = {
 *   id: "123",
 *   name: "John Doe",
 *   age: 30
 * };
 *
 * try {
 *   validateLixSchema(userSchema, userData); // returns true
 * } catch (error) {
 *   console.error("Validation failed:", error);
 * }
 * ```
 */
declare function validateLixSchema(schema: unknown, data: unknown): boolean;
/**
 * Validates only the Lix schema definition format.
 * Use this when you only need to check if a schema is valid.
 *
 * @param schema - The schema to validate
 * @returns true if the schema is valid
 * @throws Error with validation details if validation fails
 *
 * @example
 * ```typescript
 * const schema = {
 *   "x-lix-key": "product",
 *   "x-lix-version": "1.0",
 *   type: "object",
 *   properties: {
 *     id: { type: "string" }
 *   }
 * };
 *
 * try {
 *   validateLixSchemaDefinition(schema); // returns true
 * } catch (error) {
 *   console.error("Invalid schema:", error);
 * }
 * ```
 */
declare function validateLixSchemaDefinition(schema: unknown): boolean;

/**
 * Key value storage interface.
 */
type LspEnvironment = {
    getLix(args: {
        id: string;
    }): Promise<Blob | undefined>;
    /**
     * If a lix exists on the server.
     */
    hasLix(args: {
        id: string;
    }): Promise<boolean>;
    /**
     * Set's a lix.
     */
    setLix(args: {
        id: string;
        blob: Blob;
    }): Promise<void>;
    /**
     * Opens a lix.
     *
     * The server will return a connection id that can be used to close the lix.
     */
    openLix(args: {
        id: string;
    }): Promise<{
        lix: Lix;
        id: string;
        connectionId: string;
    }>;
    /**
     * Closes a lix.
     *
     * The connection id is returned when opening a lix.
     *
     * @example
     *   const { lix, connectionId } = await openLix({ id: 'my-lix' });
     *   // do stuff with the lix
     *   await closeLix({ connectionId });
     */
    closeLix(args: {
        id: string;
        connectionId: string;
    }): Promise<void>;
};

type LixServerProtocolHandler = (request: Request) => Promise<Response>;
type LixServerProtocolHandlerContext = {
    request: Request;
    environment: LspEnvironment;
    params?: Record<string, string | undefined>;
};
/**
 * The handler for the lix server protocol.
 *
 * @example
 *   Usage with a server framework.
 *
 *   ```ts
 * 	 // any server framework goes
 *   // here, like express, polka, etc.
 *   // frameworks that do not use
 *   // web standard Request and Response
 *   // objects will need to be mapped.
 *   const app = new Hono();
 *
 *   const lspHandler = createServerProtocolHandler({ storage });
 *
 *   app.use('/lsp/*', async (req) => {
 *      await lspHandler(req);
 *   });
 *   ```
 *
 * @example
 *   Testing the handler.
 *
 *   ```ts
 *   const lspHandler = createServerProtocolHandler({ storage });
 *   const request = new Request('/lsp/new', {
 *     method: 'POST',
 *     body: new Blob(['...']),
 *   });
 *
 *   const response = await lspHandler(request);
 *
 *   expect(response).to(...);
 *   ```
 */
declare function createServerProtocolHandler(args: {
    environment: LspEnvironment;
}): Promise<LixServerProtocolHandler>;

/**
 * Create an in-memory storage.
 *
 * Great for testing or quick prototyping.
 */
declare const createLspInMemoryEnvironment: () => LspEnvironment;

/**
 * Starts a new discussion thread.
 *
 * Threads allow collaborators to attach comments to a specific
 * version or entity. Initial comments can be provided and will be
 * inserted sequentially.
 *
 * @example
 * ```ts
 * const thread = await createThread({ lix, comments: [{ body: "Hello" }] })
 * ```
 */
declare function createThread(args: {
    lix: Lix;
    id?: string;
    comments?: Pick<NewState<ThreadComment>, "body">[];
    /** defaults to global */
    versionId?: string;
}): Promise<Thread & {
    lixcol_version_id: string;
    comments: (ThreadComment & {
        lixcol_version_id: string;
    })[];
}>;

/**
 * Adds a comment to an existing thread.
 *
 * The comment inherits the version context from the thread and can
 * be nested by supplying a parent id.
 *
 * @example
 * ```ts
 * await createThreadComment({ lix, thread_id, body: "Thanks" })
 * ```
 */
declare function createThreadComment(args: {
    lix: Lix;
} & NewState<ThreadComment>): Promise<State<ThreadComment>>;

/**
 * Creates a new version.
 *
 * The changeSet can be any change set e.g. another version, a checkpoint, etc.
 *
 * @example
 *   const version = await createVersion({ lix, changeSet: otherVersion.change_set_id });
 */
declare function createVersion(args: {
    lix: Lix;
    id?: Version["id"];
    changeSet?: Pick<ChangeSet, "id">;
    name?: Version["name"];
    inherits_from_version_id?: Version["inherits_from_version_id"];
}): Promise<Version>;

/**
 * Switches the current Version to the given Version.
 *
 * The Version must already exist before calling this function.
 *
 * @example
 *   ```ts
 *   await switchVersion({ lix, to: otherVersion });
 *   ```
 *
 * @example
 *   Switching to a newly created version.
 *
 *   ```ts
 *   await lix.db.transaction().execute(async (trx) => {
 *      const newVersion = await createVersion({ lix: { db: trx }, changeSet: { id: currentVersion.change_set_id } });
 *      await switchVersion({ lix: { db: trx }, to: newVersion });
 *   });
 *   ```
 */
declare function switchVersion(args: {
    lix: Lix;
    to: Pick<Version, "id">;
}): Promise<void>;

export { type Account, type ActiveAccount, type ActiveVersion, type Change, type ChangeAuthor, type ChangeSet, type ChangeSetEdge, type ChangeSetElement, type ChangeSetLabel, type ChangeSetThread, type DetectedChange, type EntityStateAllView, type EntityStateHistoryView, type EntityStateView, type FromLixSchemaDefinition, InMemoryStorage, type JSONType, JSONTypeSchema, type KeyValue, type Label, type Lix, LixAccountSchema, LixChangeAuthorSchema, LixChangeSetEdgeSchema, LixChangeSetElementSchema, LixChangeSetLabelSchema, LixChangeSetSchema, LixChangeSetThreadSchema, type LixDatabaseSchema, type LixFile, type LixFileDescriptor, LixFileDescriptorSchema, type LixGenerated, type LixHooks, type LixInsertable, LixKeyValueSchema, LixLabelSchema, LixLogSchema, LixObservable, type LixPlugin, LixSchemaDefinition, type LixSelectable, type LixServerProtocolHandlerContext, type LixStorageAdapter, LixStoredSchemaSchema, LixThreadCommentSchema, LixThreadSchema, type LixUpdateable, LixVersionSchema, type Log, type NewChange, type NewState, type NewStateAll, OpfsStorage, type State, type StateAll, type StateAllUpdate, type StateHistory, type StateUpdate, type StoredSchema, type Thread, type ThreadComment, type ToKysely, type UiDiffComponentProps, type Version, applyChangeSet, applyKeyValueDatabaseSchema, changeHasLabel, changeSetElementInAncestryOf, changeSetElementInSymmetricDifference, changeSetElementIsLeafOf, changeSetHasLabel, changeSetIsAncestorOf, changeSetIsDescendantOf, createAccount, createChangeSet, createCheckpoint, createHooks, createLabel, createLog, createLspInMemoryEnvironment, createMergeChangeSet, createServerProtocolHandler, createThread, createThreadComment, createTransitionChangeSet, createUndoChangeSet, createVersion, executeSync, mockJsonPlugin, nanoid, newLixFile, openLix, switchAccount, switchVersion, validateLixSchema, validateLixSchemaDefinition };
