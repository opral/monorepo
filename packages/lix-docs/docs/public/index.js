import crypto2 from 'crypto';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// ../../node_modules/.pnpm/human-id@4.1.1/node_modules/human-id/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/human-id@4.1.1/node_modules/human-id/dist/index.js"(exports) {
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minLength = exports.maxLength = exports.poolSize = exports.humanId = exports.adverbs = exports.verbs = exports.nouns = exports.adjectives = void 0;
    exports.adjectives = ["afraid", "all", "angry", "beige", "big", "better", "bitter", "blue", "brave", "breezy", "bright", "brown", "bumpy", "busy", "calm", "chatty", "chilly", "chubby", "clean", "clear", "clever", "cold", "crazy", "cruel", "cuddly", "curly", "curvy", "cute", "common", "cold", "cool", "cyan", "dark", "deep", "dirty", "dry", "dull", "eager", "early", "easy", "eight", "eighty", "eleven", "empty", "every", "evil", "fair", "famous", "fast", "fancy", "few", "fine", "fifty", "five", "flat", "fluffy", "floppy", "forty", "four", "free", "fresh", "fruity", "full", "funny", "fuzzy", "gentle", "giant", "gold", "good", "great", "green", "grumpy", "happy", "heavy", "hip", "honest", "hot", "huge", "hungry", "icy", "itchy", "khaki", "kind", "large", "late", "lazy", "lemon", "legal", "light", "little", "long", "loose", "loud", "lovely", "lucky", "major", "many", "mean", "metal", "mighty", "modern", "moody", "nasty", "neat", "new", "nice", "nine", "ninety", "odd", "old", "olive", "open", "orange", "pink", "plain", "plenty", "polite", "poor", "pretty", "proud", "public", "puny", "petite", "purple", "quick", "quiet", "rare", "real", "ready", "red", "rich", "ripe", "rotten", "rude", "sad", "salty", "seven", "shaggy", "shaky", "sharp", "shiny", "short", "shy", "silent", "silly", "silver", "six", "sixty", "slick", "slimy", "slow", "small", "smart", "smooth", "social", "soft", "solid", "some", "sour", "spicy", "spotty", "stale", "strong", "stupid", "sweet", "swift", "tall", "tame", "tangy", "tasty", "ten", "tender", "thick", "thin", "thirty", "three", "tidy", "tiny", "tired", "tough", "tricky", "true", "twelve", "twenty", "two", "upset", "vast", "violet", "warm", "weak", "wet", "whole", "wicked", "wide", "wild", "wise", "witty", "yellow", "young", "yummy"];
    exports.nouns = ["apes", "animals", "areas", "bars", "banks", "baths", "breads", "bushes", "cloths", "clowns", "clubs", "hoops", "loops", "memes", "papers", "parks", "paths", "showers", "sides", "signs", "sites", "streets", "teeth", "tires", "webs", "actors", "ads", "adults", "aliens", "ants", "apples", "baboons", "badgers", "bags", "bananas", "bats", "beans", "bears", "beds", "beers", "bees", "berries", "bikes", "birds", "boats", "bobcats", "books", "bottles", "boxes", "brooms", "buckets", "bugs", "buses", "buttons", "camels", "cases", "cameras", "candies", "candles", "carpets", "carrots", "carrots", "cars", "cats", "chairs", "chefs", "chicken", "clocks", "clouds", "coats", "cobras", "coins", "corners", "colts", "comics", "cooks", "cougars", "regions", "results", "cows", "crabs", "crabs", "crews", "cups", "cities", "cycles", "dancers", "days", "deer", "dingos", "dodos", "dogs", "dolls", "donkeys", "donuts", "doodles", "doors", "dots", "dragons", "drinks", "dryers", "ducks", "ducks", "eagles", "ears", "eels", "eggs", "ends", "mammals", "emus", "experts", "eyes", "facts", "falcons", "fans", "feet", "files", "flies", "flowers", "forks", "foxes", "friends", "frogs", "games", "garlics", "geckos", "geese", "ghosts", "ghosts", "gifts", "glasses", "goats", "grapes", "groups", "guests", "hairs", "hands", "hats", "heads", "hornets", "horses", "hotels", "hounds", "houses", "humans", "icons", "ideas", "impalas", "insects", "islands", "items", "jars", "jeans", "jobs", "jokes", "keys", "kids", "kings", "kiwis", "knives", "lamps", "lands", "laws", "lemons", "lies", "lights", "lines", "lions", "lizards", "llamas", "mails", "mangos", "maps", "masks", "meals", "melons", "mice", "mirrors", "moments", "moles", "monkeys", "months", "moons", "moose", "mugs", "nails", "needles", "news", "nights", "numbers", "olives", "onions", "oranges", "otters", "owls", "pandas", "pans", "pants", "papayas", "parents", "parts", "parrots", "paws", "peaches", "pears", "peas", "pens", "pets", "phones", "pianos", "pigs", "pillows", "places", "planes", "planets", "plants", "plums", "poems", "poets", "points", "pots", "pugs", "pumas", "queens", "rabbits", "radios", "rats", "ravens", "readers", "rice", "rings", "rivers", "rockets", "rocks", "rooms", "roses", "rules", "schools", "bats", "seals", "seas", "sheep", "shirts", "shoes", "shrimps", "singers", "sloths", "snails", "snakes", "socks", "spiders", "spies", "spoons", "squids", "stars", "states", "steaks", "wings", "suits", "suns", "swans", "symbols", "tables", "taxes", "taxis", "teams", "terms", "things", "ties", "tigers", "times", "tips", "toes", "towns", "tools", "toys", "trains", "trams", "trees", "turkeys", "turtles", "vans", "views", "walls", "walls", "wasps", "waves", "ways", "weeks", "windows", "wolves", "women", "wombats", "words", "worlds", "worms", "yaks", "years", "zebras", "zoos"];
    exports.verbs = ["accept", "act", "add", "admire", "agree", "allow", "appear", "argue", "arrive", "ask", "attack", "attend", "bake", "bathe", "battle", "beam", "beg", "begin", "behave", "bet", "boil", "bow", "brake", "brush", "build", "burn", "buy", "call", "camp", "care", "carry", "change", "cheat", "check", "cheer", "chew", "clap", "clean", "cough", "count", "cover", "crash", "create", "cross", "cry", "cut", "dance", "decide", "deny", "design", "dig", "divide", "do", "double", "doubt", "draw", "dream", "dress", "drive", "drop", "drum", "eat", "end", "enter", "enjoy", "exist", "fail", "fall", "feel", "fetch", "film", "find", "fix", "flash", "float", "flow", "fly", "fold", "follow", "fry", "give", "glow", "go", "grab", "greet", "grin", "grow", "guess", "hammer", "hang", "happen", "heal", "hear", "help", "hide", "hope", "hug", "hunt", "invent", "invite", "itch", "jam", "jog", "join", "joke", "judge", "juggle", "jump", "kick", "kiss", "kneel", "knock", "know", "laugh", "lay", "lead", "learn", "leave", "lick", "like", "lie", "listen", "live", "look", "lose", "love", "make", "march", "marry", "mate", "matter", "melt", "mix", "move", "nail", "notice", "obey", "occur", "open", "own", "pay", "peel", "play", "poke", "post", "press", "prove", "pull", "pump", "pick", "punch", "push", "raise", "read", "refuse", "relate", "relax", "remain", "repair", "repeat", "reply", "report", "rescue", "rest", "retire", "return", "rhyme", "ring", "roll", "rule", "run", "rush", "say", "scream", "see", "search", "sell", "send", "serve", "shake", "share", "shave", "shine", "show", "shop", "shout", "sin", "sink", "sing", "sip", "sit", "sleep", "slide", "smash", "smell", "smile", "smoke", "sneeze", "sniff", "sort", "speak", "spend", "stand", "start", "stay", "stick", "stop", "stare", "study", "strive", "swim", "switch", "take", "talk", "tan", "tap", "taste", "teach", "tease", "tell", "thank", "think", "throw", "tickle", "tie", "trade", "train", "travel", "try", "turn", "type", "unite", "vanish", "visit", "wait", "walk", "warn", "wash", "watch", "wave", "wear", "win", "wink", "wish", "wonder", "work", "worry", "write", "yawn", "yell"];
    exports.adverbs = ["bravely", "brightly", "busily", "daily", "freely", "hungrily", "joyously", "knowlingly", "lazily", "oddly", "mysteriously", "noisily", "politely", "quickly", "quietly", "rapidly", "safely", "sleepily", "slowly", "truly", "yearly"];
    function random2(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    function longest(arr) {
      return arr.reduce(function(a, b) {
        return a.length > b.length ? a : b;
      });
    }
    function shortest(arr) {
      return arr.reduce(function(a, b) {
        return a.length < b.length ? a : b;
      });
    }
    function humanId5(options) {
      if (options === void 0) {
        options = {};
      }
      if (typeof options === "string")
        options = { separator: options };
      if (typeof options === "boolean")
        options = { capitalize: options };
      var _a = options.separator, separator = _a === void 0 ? "" : _a, _b = options.capitalize, capitalize = _b === void 0 ? true : _b, _c = options.adjectiveCount, adjectiveCount = _c === void 0 ? 1 : _c, _d = options.addAdverb, addAdverb = _d === void 0 ? false : _d;
      var res = __spreadArray(__spreadArray(__spreadArray([], __spreadArray([], Array(adjectiveCount), true).map(function(_) {
        return random2(exports.adjectives);
      }), true), [
        random2(exports.nouns),
        random2(exports.verbs)
      ], false), addAdverb ? [random2(exports.adverbs)] : [], true);
      if (capitalize)
        res = res.map(function(r) {
          return r.charAt(0).toUpperCase() + r.substr(1);
        });
      return res.join(separator);
    }
    exports.humanId = humanId5;
    function poolSize(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.adjectiveCount, adjectiveCount = _a === void 0 ? 1 : _a, _b = options.addAdverb, addAdverb = _b === void 0 ? false : _b;
      return exports.adjectives.length * adjectiveCount * exports.nouns.length * exports.verbs.length * (addAdverb ? exports.adverbs.length : 1);
    }
    exports.poolSize = poolSize;
    function maxLength(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.adjectiveCount, adjectiveCount = _a === void 0 ? 1 : _a, _b = options.addAdverb, addAdverb = _b === void 0 ? false : _b, _c = options.separator, separator = _c === void 0 ? "" : _c;
      return longest(exports.adjectives).length * adjectiveCount + adjectiveCount * separator.length + longest(exports.nouns).length + separator.length + longest(exports.verbs).length + (addAdverb ? longest(exports.adverbs).length + separator.length : 0);
    }
    exports.maxLength = maxLength;
    function minLength(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.adjectiveCount, adjectiveCount = _a === void 0 ? 1 : _a, _b = options.addAdverb, addAdverb = _b === void 0 ? false : _b, _c = options.separator, separator = _c === void 0 ? "" : _c;
      return shortest(exports.adjectives).length * adjectiveCount + adjectiveCount * separator.length + shortest(exports.nouns).length + separator.length + shortest(exports.verbs).length + (addAdverb ? shortest(exports.adverbs).length + separator.length : 0);
    }
    exports.minLength = minLength;
    exports.default = humanId5;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw2 = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw2(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type2;
    (function(Type3) {
      Type3[Type3["Num"] = 0] = "Num";
      Type3[Type3["Str"] = 1] = "Str";
    })(Type2 || (exports.Type = Type2 = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber2 = dataPropType === Type2.Num;
        return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js"(exports, module) {
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve2 = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve2(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js"(exports, module) {
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module.exports = {
      HEX
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js"(exports, module) {
    var { HEX } = require_scopedChars();
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host, opts = {}) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components, options) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host, { });
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js"(exports, module) {
    var UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module.exports = SCHEMES;
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js"(exports, module) {
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
    var SCHEMES = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse2(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse2(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse2(serialize(base, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse2(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse2(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (v2, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code = value.charCodeAt(i);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse2(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && !parsed.path && parsed.query === void 0) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path !== void 0 && parsed.path.length) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment !== void 0 && parsed.fragment.length) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse: parse2
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv3 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v2;
        if (typeof schemaKeyRef == "string") {
          v2 = this.getSchema(schemaKeyRef);
          if (!v2)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v2 = this.compile(schemaKeyRef);
        }
        const valid = v2(data);
        if (!("$async" in v2))
          this.errors = v2.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema2, _meta) {
          await loadMetaSchema.call(this, _schema2.$schema);
          const sch = this._addSchema(_schema2, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema2 = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema2.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema2, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv3.ValidationError = validation_error_1.default;
    Ajv3.MissingRefError = ref_error_1.default;
    exports.default = Ajv3;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v2 = getValidate(cxt, sch);
          callRef(cxt, v2, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v2, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v2, passCxt)}`);
          addEvaluatedFrom(v2);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js"(exports, module) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv3 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v2) => this.addVocabulary(v2));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv3;
    module.exports = exports = Ajv3;
    module.exports.Ajv = Ajv3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv3;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// ../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto2.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var native_default = {
  randomUUID: crypto2.randomUUID
};

// ../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js
var _seqLow = null;
var _seqHigh = null;
var _msecs = 0;
function v7(options, buf, offset) {
  options = options || {};
  let i = buf && offset || 0;
  const b = buf || new Uint8Array(16);
  const rnds = options.random || (options.rng || rng)();
  const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let seq = options.seq !== void 0 ? options.seq : null;
  let seqHigh = _seqHigh;
  let seqLow = _seqLow;
  if (msecs > _msecs && options.msecs === void 0) {
    _msecs = msecs;
    if (seq !== null) {
      seqHigh = null;
      seqLow = null;
    }
  }
  if (seq !== null) {
    if (seq > 2147483647) {
      seq = 2147483647;
    }
    seqHigh = seq >>> 19 & 4095;
    seqLow = seq & 524287;
  }
  if (seqHigh === null || seqLow === null) {
    seqHigh = rnds[6] & 127;
    seqHigh = seqHigh << 8 | rnds[7];
    seqLow = rnds[8] & 63;
    seqLow = seqLow << 8 | rnds[9];
    seqLow = seqLow << 5 | rnds[10] >>> 3;
  }
  if (msecs + 1e4 > _msecs && seq === null) {
    if (++seqLow > 524287) {
      seqLow = 0;
      if (++seqHigh > 4095) {
        seqHigh = 0;
        _msecs++;
      }
    }
  } else {
    _msecs = msecs;
  }
  _seqHigh = seqHigh;
  _seqLow = seqLow;
  b[i++] = _msecs / 1099511627776 & 255;
  b[i++] = _msecs / 4294967296 & 255;
  b[i++] = _msecs / 16777216 & 255;
  b[i++] = _msecs / 65536 & 255;
  b[i++] = _msecs / 256 & 255;
  b[i++] = _msecs & 255;
  b[i++] = seqHigh >>> 4 & 15 | 112;
  b[i++] = seqHigh & 255;
  b[i++] = seqLow >>> 13 & 63 | 128;
  b[i++] = seqLow >>> 5 & 255;
  b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
  b[i++] = rnds[11];
  b[i++] = rnds[12];
  b[i++] = rnds[13];
  b[i++] = rnds[14];
  b[i++] = rnds[15];
  return buf || unsafeStringify(b);
}
var v7_default = v7;

// ../lix-sdk/src/account/create-account.ts
async function createAccount(args) {
  const executeInTransaction = async (trx) => {
    var _a;
    const accountId = args.id || v7_default();
    await trx.insertInto("account_all").values({
      id: accountId,
      name: args.name,
      lixcol_version_id: (_a = args.lixcol_version_id) != null ? _a : trx.selectFrom("active_version").select("version_id")
    }).execute();
    const account = await trx.selectFrom("account_all").selectAll().where("id", "=", accountId).executeTakeFirstOrThrow();
    return account;
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/account/switch-account.ts
async function switchAccount(args) {
  const executeInTransaction = async (trx) => {
    await trx.deleteFrom("active_account").execute();
    await trx.insertInto("active_account").values(
      args.to.map((account) => ({
        id: account.id,
        name: account.name
      }))
    ).execute();
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/account/schema.ts
var import_human_id = __toESM(require_dist());

// ../lix-sdk/src/database/nano-id.ts
var insecureRandom = (array) => {
  for (let i = 0; i < array.length; i++) {
    array[i] = Math.floor(Math.random() * 256);
  }
  return array;
};
var random = (bytes) => {
  const array = new Uint8Array(bytes);
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    return crypto.getRandomValues(array);
  }
  return insecureRandom(array);
};
var customRandom = (alphabet, defaultSize, getRandom) => {
  const mask = (2 << Math.log2(alphabet.length - 1)) - 1;
  const step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      const bytes = getRandom(step);
      let j = step | 0;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length >= size) return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size | 0, random);
var _nanoIdAlphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
var nanoid = customAlphabet(_nanoIdAlphabet);

// ../lix-sdk/src/entity-views/entity-state.ts
function createEntityStateView(args) {
  var _a;
  const view_name = (_a = args.overrideName) != null ? _a : args.schema["x-lix-key"];
  createSingleEntityView({
    ...args,
    viewName: view_name,
    stateTable: "state"
  });
}
function createSingleEntityView(args) {
  var _a, _b, _c;
  if (!args.schema["x-lix-primary-key"]) {
    throw new Error(
      `Schema must define 'x-lix-primary-key' for entity view generation`
    );
  }
  const view_name = args.viewName;
  const schema_key = args.schema["x-lix-key"];
  const properties = Object.keys(args.schema.properties);
  const primaryKeys = args.schema["x-lix-primary-key"];
  const fileId = args.hardcodedFileId ? `'${args.hardcodedFileId}'` : "NEW.lixcol_file_id";
  const entityIdNew = primaryKeys.length === 1 ? `NEW.${primaryKeys[0]}` : `(${primaryKeys.map((key) => `NEW.${key}`).join(" || '::' || ")})`;
  const entityIdOld = primaryKeys.length === 1 ? `OLD.${primaryKeys[0]}` : `(${primaryKeys.map((key) => `OLD.${key}`).join(" || '::' || ")})`;
  if (args.defaultValues) {
    for (const [prop, defaultFn] of Object.entries(args.defaultValues)) {
      const udfName = `${schema_key}_default_${prop}`;
      const needsRow = defaultFn.length > 0;
      if (needsRow) {
        args.lix.sqlite.createFunction(
          udfName,
          (...rowValues) => {
            const actualValues = rowValues.slice(1);
            const row = {};
            properties.forEach((prop2, index) => {
              let value = actualValues[index];
              if (typeof value === "string" && (value.startsWith("{") || value.startsWith("["))) {
                try {
                  value = JSON.parse(value);
                } catch (e) {
                }
              }
              row[prop2] = value;
            });
            return defaultFn(row);
          },
          { arity: -1 }
        );
      } else {
        args.lix.sqlite.createFunction(
          udfName,
          () => defaultFn(),
          { arity: 0 }
        );
      }
    }
  }
  const generateDefaults = (properties2) => {
    if (!args.defaultValues) {
      return properties2.map((prop) => `NEW.${prop} AS ${prop}`).join(",\n        ");
    }
    const rowValuesArgs = properties2.map((prop) => `NEW.${prop}`).join(", ");
    return properties2.map((prop) => {
      const defaultFn = args.defaultValues[prop];
      if (defaultFn) {
        const needsRow = defaultFn.length > 0;
        const fnCall = needsRow ? `${schema_key}_default_${prop}(${rowValuesArgs})` : `${schema_key}_default_${prop}()`;
        return `COALESCE(NEW.${prop}, ${fnCall}) AS ${prop}`;
      } else {
        return `NEW.${prop} AS ${prop}`;
      }
    }).join(",\n        ");
  };
  const defaultsSubquery = generateDefaults(properties);
  const hasDefaults = args.defaultValues && Object.keys(args.defaultValues).length > 0;
  const operationalColumns = [
    "inherited_from_version_id AS lixcol_inherited_from_version_id",
    "created_at AS lixcol_created_at",
    "updated_at AS lixcol_updated_at",
    "file_id AS lixcol_file_id",
    "change_id AS lixcol_change_id",
    "untracked AS lixcol_untracked"
  ];
  const versionIdReference = args.hardcodedVersionId ? `'${args.hardcodedVersionId}'` : "(SELECT version_id FROM active_version)";
  const oldVersionIdReference = args.hardcodedVersionId ? `'${args.hardcodedVersionId}'` : "(SELECT version_id FROM active_version)";
  const generateValidationSQL = (rules) => {
    return rules.map(
      (rule) => `
			SELECT CASE
				WHEN NOT (${rule.condition})
				THEN RAISE(FAIL, '${rule.errorMessage.replace(/'/g, "''")}')
			END;`
    ).join("\n");
  };
  const insertValidationSQL = ((_a = args.validation) == null ? void 0 : _a.onInsert) ? generateValidationSQL(args.validation.onInsert) : "";
  const updateValidationSQL = ((_b = args.validation) == null ? void 0 : _b.onUpdate) ? generateValidationSQL(args.validation.onUpdate) : "";
  const deleteValidationSQL = ((_c = args.validation) == null ? void 0 : _c.onDelete) ? generateValidationSQL(args.validation.onDelete) : "";
  const sqlQuery = `
    CREATE VIEW IF NOT EXISTS ${view_name} AS
      SELECT
        ${Object.keys(args.schema.properties).map(
    (prop) => `json_extract(snapshot_content, '$.${prop}') AS ${prop}`
  ).join(",\n        ")},
        ${operationalColumns.join(",\n        ")}
      FROM ${args.stateTable}
      WHERE schema_key = '${schema_key}';

      CREATE TRIGGER IF NOT EXISTS ${view_name}_insert
      INSTEAD OF INSERT ON ${view_name}
      BEGIN      
        ${insertValidationSQL}
        INSERT INTO state_all (
          entity_id,
          schema_key,
          file_id,
          plugin_key,
          snapshot_content,
          schema_version,
          version_id,
          untracked
        ) ${hasDefaults ? `
        SELECT 
          ${entityIdNew.replace(/NEW\./g, "with_default_values.")},
          '${schema_key}',
          ${fileId.replace(/NEW\./g, "with_default_values.")},
          '${args.pluginKey}',
          json_object(${properties.map((prop) => `'${prop}', with_default_values.${prop}`).join(", ")}),
          '${args.schema["x-lix-version"]}',
          ${versionIdReference.replace(/NEW\./g, "with_default_values.")},
          with_default_values.lixcol_untracked
        FROM (
          SELECT
            ${defaultsSubquery},
            NEW.lixcol_file_id AS lixcol_file_id,
            NEW.lixcol_untracked AS lixcol_untracked
        ) AS with_default_values` : `
        VALUES (
          ${entityIdNew},
          '${schema_key}',
          ${fileId},
          '${args.pluginKey}',
          json_object(${properties.map((prop) => `'${prop}', NEW.${prop}`).join(", ")}),
          '${args.schema["x-lix-version"]}',
          ${versionIdReference},
          NEW.lixcol_untracked
        )`};
      END;

      CREATE TRIGGER IF NOT EXISTS ${view_name}_update
      INSTEAD OF UPDATE ON ${view_name}
      BEGIN
        ${updateValidationSQL}
        UPDATE state_all
        SET
          entity_id = ${entityIdNew},
          schema_key = '${schema_key}',
          file_id = ${fileId},
          plugin_key = '${args.pluginKey}',
          snapshot_content = json_object(${properties.map((prop) => `'${prop}', NEW.${prop}`).join(", ")}),
          version_id = ${versionIdReference},
          untracked = NEW.lixcol_untracked
        WHERE
          state_all.entity_id = ${entityIdOld}
          AND state_all.schema_key = '${schema_key}'
          AND state_all.file_id = ${args.hardcodedFileId ? `'${args.hardcodedFileId}'` : "OLD.lixcol_file_id"}
          AND state_all.version_id = ${oldVersionIdReference};
      END;

      CREATE TRIGGER IF NOT EXISTS ${view_name}_delete
      INSTEAD OF DELETE ON ${view_name}
      BEGIN
        ${deleteValidationSQL}
        DELETE FROM state_all
        WHERE entity_id = ${entityIdOld}
        AND schema_key = '${schema_key}'
        AND file_id = ${args.hardcodedFileId ? `'${args.hardcodedFileId}'` : "OLD.lixcol_file_id"}
        ${args.hardcodedVersionId ? `AND version_id = '${args.hardcodedVersionId}'` : ""};
      END;
    `;
  args.lix.sqlite.exec(sqlQuery);
}

// ../lix-sdk/src/entity-views/entity-state-all.ts
function createEntityStateAllView(args) {
  var _a;
  const view_name = (_a = args.overrideName) != null ? _a : args.schema["x-lix-key"] + "_all";
  createSingleEntityAllView({
    ...args,
    viewName: view_name,
    stateTable: "state_all"
  });
}
function createSingleEntityAllView(args) {
  var _a, _b, _c;
  if (!args.schema["x-lix-primary-key"]) {
    throw new Error(
      `Schema must define 'x-lix-primary-key' for entity view generation`
    );
  }
  const view_name = args.viewName;
  const schema_key = args.schema["x-lix-key"];
  const properties = Object.keys(args.schema.properties);
  const primaryKeys = args.schema["x-lix-primary-key"];
  const fileId = args.hardcodedFileId ? `'${args.hardcodedFileId}'` : "NEW.lixcol_file_id";
  const entityIdNew = primaryKeys.length === 1 ? `NEW.${primaryKeys[0]}` : `(${primaryKeys.map((key) => `NEW.${key}`).join(" || '::' || ")})`;
  const entityIdOld = primaryKeys.length === 1 ? `OLD.${primaryKeys[0]}` : `(${primaryKeys.map((key) => `OLD.${key}`).join(" || '::' || ")})`;
  if (args.defaultValues) {
    for (const [prop, defaultFn] of Object.entries(args.defaultValues)) {
      const udfName = `${schema_key}_default_${prop}`;
      const needsRow = defaultFn.length > 0;
      if (needsRow) {
        args.lix.sqlite.createFunction(
          udfName,
          (...rowValues) => {
            const actualValues = rowValues.slice(1);
            const row = {};
            properties.forEach((prop2, index) => {
              let value = actualValues[index];
              if (typeof value === "string" && (value.startsWith("{") || value.startsWith("["))) {
                try {
                  value = JSON.parse(value);
                } catch (e) {
                }
              }
              row[prop2] = value;
            });
            return defaultFn(row);
          },
          { arity: -1 }
        );
      } else {
        args.lix.sqlite.createFunction(
          udfName,
          () => defaultFn(),
          { arity: 0 }
        );
      }
    }
  }
  const generateDefaults = (properties2) => {
    if (!args.defaultValues) {
      return properties2.map((prop) => `NEW.${prop} AS ${prop}`).join(",\n        ");
    }
    const rowValuesArgs = properties2.map((prop) => `NEW.${prop}`).join(", ");
    return properties2.map((prop) => {
      const defaultFn = args.defaultValues[prop];
      if (defaultFn) {
        const needsRow = defaultFn.length > 0;
        const fnCall = needsRow ? `${schema_key}_default_${prop}(${rowValuesArgs})` : `${schema_key}_default_${prop}()`;
        return `COALESCE(NEW.${prop}, ${fnCall}) AS ${prop}`;
      } else {
        return `NEW.${prop} AS ${prop}`;
      }
    }).join(",\n        ");
  };
  const defaultsSubquery = generateDefaults(properties);
  const hasDefaults = args.defaultValues && Object.keys(args.defaultValues).length > 0;
  const operationalColumns = [
    "version_id AS lixcol_version_id",
    "inherited_from_version_id AS lixcol_inherited_from_version_id",
    "created_at AS lixcol_created_at",
    "updated_at AS lixcol_updated_at",
    "file_id AS lixcol_file_id",
    "change_id AS lixcol_change_id",
    "untracked AS lixcol_untracked"
  ];
  const versionIdReference = args.hardcodedVersionId ? `'${args.hardcodedVersionId}'` : "NEW.lixcol_version_id";
  const versionIdInDefaults = "NEW.lixcol_version_id AS lixcol_version_id,";
  const oldVersionIdReference = args.hardcodedVersionId ? `'${args.hardcodedVersionId}'` : "OLD.lixcol_version_id";
  const generateValidationSQL = (rules) => {
    return rules.map(
      (rule) => `
			SELECT CASE
				WHEN NOT (${rule.condition})
				THEN RAISE(FAIL, '${rule.errorMessage.replace(/'/g, "''")}')
			END;`
    ).join("\n");
  };
  const insertValidationSQL = ((_a = args.validation) == null ? void 0 : _a.onInsert) ? generateValidationSQL(args.validation.onInsert) : "";
  const updateValidationSQL = ((_b = args.validation) == null ? void 0 : _b.onUpdate) ? generateValidationSQL(args.validation.onUpdate) : "";
  const deleteValidationSQL = ((_c = args.validation) == null ? void 0 : _c.onDelete) ? generateValidationSQL(args.validation.onDelete) : "";
  const sqlQuery = `
    CREATE VIEW IF NOT EXISTS ${view_name} AS
      SELECT
        ${Object.keys(args.schema.properties).map(
    (prop) => `json_extract(snapshot_content, '$.${prop}') AS ${prop}`
  ).join(",\n        ")},
        ${operationalColumns.join(",\n        ")}
      FROM ${args.stateTable}
      WHERE schema_key = '${schema_key}';

      CREATE TRIGGER IF NOT EXISTS ${view_name}_insert
      INSTEAD OF INSERT ON ${view_name}
      BEGIN      
        ${insertValidationSQL}
        INSERT INTO state_all (
          entity_id,
          schema_key,
          file_id,
          plugin_key,
          snapshot_content,
          schema_version,
          version_id,
          untracked
        ) ${hasDefaults ? `
        SELECT 
          ${entityIdNew.replace(/NEW\./g, "with_default_values.")},
          '${schema_key}',
          ${fileId.replace(/NEW\./g, "with_default_values.")},
          '${args.pluginKey}',
          json_object(${properties.map((prop) => `'${prop}', with_default_values.${prop}`).join(", ")}),
          '${args.schema["x-lix-version"]}',
          ${versionIdReference.replace(/NEW\./g, "with_default_values.")},
          with_default_values.lixcol_untracked
        FROM (
          SELECT
            ${defaultsSubquery},
            ${versionIdInDefaults}
            NEW.lixcol_file_id AS lixcol_file_id,
            NEW.lixcol_untracked AS lixcol_untracked
        ) AS with_default_values` : `
        VALUES (
          ${entityIdNew},
          '${schema_key}',
          ${fileId},
          '${args.pluginKey}',
          json_object(${properties.map((prop) => `'${prop}', NEW.${prop}`).join(", ")}),
          '${args.schema["x-lix-version"]}',
          ${versionIdReference},
          NEW.lixcol_untracked
        )`};
      END;

      CREATE TRIGGER IF NOT EXISTS ${view_name}_update
      INSTEAD OF UPDATE ON ${view_name}
      BEGIN
        ${updateValidationSQL}
        UPDATE state_all
        SET
          entity_id = ${entityIdNew},
          schema_key = '${schema_key}',
          file_id = ${fileId},
          plugin_key = '${args.pluginKey}',
          snapshot_content = json_object(${properties.map((prop) => `'${prop}', NEW.${prop}`).join(", ")}),
          version_id = ${versionIdReference},
          untracked = NEW.lixcol_untracked
        WHERE
          state_all.entity_id = ${entityIdOld}
          AND state_all.schema_key = '${schema_key}'
          AND state_all.file_id = ${args.hardcodedFileId ? `'${args.hardcodedFileId}'` : "OLD.lixcol_file_id"}
          AND state_all.version_id = ${oldVersionIdReference};
      END;

      CREATE TRIGGER IF NOT EXISTS ${view_name}_delete
      INSTEAD OF DELETE ON ${view_name}
      BEGIN
        ${deleteValidationSQL}
        DELETE FROM state_all
        WHERE entity_id = ${entityIdOld}
        AND schema_key = '${schema_key}'
        AND file_id = ${args.hardcodedFileId ? `'${args.hardcodedFileId}'` : "OLD.lixcol_file_id"}
        ${args.hardcodedVersionId ? `AND version_id = '${args.hardcodedVersionId}'` : ""};
      END;
    `;
  args.lix.sqlite.exec(sqlQuery);
}

// ../lix-sdk/src/entity-views/entity-state-history.ts
function createEntityStateHistoryView(args) {
  var _a;
  if (!args.schema["x-lix-primary-key"]) {
    throw new Error(
      `Schema must define 'x-lix-primary-key' for entity history view generation`
    );
  }
  const view_name = (_a = args.overrideName) != null ? _a : args.schema["x-lix-key"] + "_history";
  const schema_key = args.schema["x-lix-key"];
  const properties = Object.keys(args.schema.properties);
  const sqlQuery = `
    CREATE VIEW IF NOT EXISTS ${view_name} AS
      SELECT
        ${properties.map(
    (prop) => `json_extract(snapshot_content, '$.${prop}') AS ${prop}`
  ).join(",\n        ")},
        entity_id,
        schema_key,
        file_id AS lixcol_file_id,
        plugin_key AS lixcol_plugin_key,
        schema_version AS lixcol_schema_version,
        change_id AS lixcol_change_id,
        change_set_id AS lixcol_change_set_id,
        depth AS lixcol_depth
      FROM state_history
      WHERE schema_key = '${schema_key}';
    `;
  args.lix.sqlite.exec(sqlQuery);
}

// ../lix-sdk/src/entity-views/entity-view-builder.ts
function createEntityViewsIfNotExists(args) {
  var _a;
  const view_name = (_a = args.overrideName) != null ? _a : args.schema["x-lix-key"];
  createEntityStateView({
    ...args,
    overrideName: view_name
  });
  createEntityStateAllView({
    ...args,
    overrideName: view_name + "_all"
  });
  createEntityStateHistoryView({
    lix: args.lix,
    schema: args.schema,
    overrideName: view_name + "_history"
  });
}

// ../lix-sdk/src/account/schema.ts
function applyAccountDatabaseSchema(sqlite) {
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixAccountSchema,
    overrideName: "account",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix",
    defaultValues: {
      id: () => nanoid()
    }
  });
  sqlite.exec(`
		-- current account(s)
		-- temp table because current accounts are session
		-- specific and should not be persisted
		CREATE TEMP TABLE IF NOT EXISTS active_account (
			id TEXT PRIMARY KEY,
			name TEXT NOT NULL
			-- can't use foreign keys in temp tables... :(
		) STRICT;
	`);
  const anonymousAccountName = `Anonymous ${(0, import_human_id.humanId)({
    capitalize: true,
    adjectiveCount: 0,
    separator: "_"
  }).split("_")[0].slice(0, -1)}`;
  sqlite.exec(`
		-- default to a new account
		INSERT INTO active_account (id, name) values (nano_id(), '${anonymousAccountName}');
	`);
}
var LixAccountSchema = {
  "x-lix-key": "lix_account",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["id"],
  type: "object",
  properties: {
    id: { type: "string", "x-lix-generated": true },
    name: { type: "string" }
  },
  required: ["id", "name"],
  additionalProperties: false
};

// ../lix-sdk/src/change/schema.ts
function applyChangeDatabaseSchema(sqlite) {
  return sqlite.exec(`
  CREATE TABLE IF NOT EXISTS internal_change (
    id TEXT PRIMARY KEY DEFAULT (uuid_v7()),
    entity_id TEXT NOT NULL,
    schema_key TEXT NOT NULL,
    schema_version TEXT NOT NULL,
    file_id TEXT NOT NULL,
    plugin_key TEXT NOT NULL,
    snapshot_id TEXT NOT NULL, -- Foreign key to internal_snapshot
    created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')) NOT NULL CHECK (created_at LIKE '%Z'),

    UNIQUE (id, entity_id, file_id, schema_key),
    FOREIGN KEY(snapshot_id) REFERENCES internal_snapshot(id)
  ) STRICT;

  CREATE VIEW IF NOT EXISTS change AS
  SELECT 
    c.*,
    (SELECT json(s.content)
     FROM internal_snapshot s
     WHERE s.id = c.snapshot_id) AS snapshot_content
  FROM internal_change AS c;

  CREATE TRIGGER IF NOT EXISTS change_insert
  INSTEAD OF INSERT ON change
  BEGIN
    -- Insert the snapshot first (if there's content)
    INSERT INTO internal_snapshot (id, content)
    SELECT 
      uuid_v7(), 
      jsonb(NEW.snapshot_content)
    WHERE NEW.snapshot_content IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM internal_snapshot WHERE id = 'no-content' AND NEW.snapshot_content IS NULL);
    
    -- Insert the change, referencing the snapshot
    INSERT INTO internal_change (
      id,
      entity_id,
      schema_key,
      schema_version,
      file_id,
      plugin_key,
      snapshot_id,
      created_at
    ) VALUES (
      COALESCE(NEW.id, uuid_v7()),
      NEW.entity_id,
      NEW.schema_key,
      NEW.schema_version,
      NEW.file_id,
      NEW.plugin_key,
      CASE 
        WHEN NEW.snapshot_content IS NULL THEN 'no-content'
        ELSE (SELECT id FROM internal_snapshot WHERE content = jsonb(NEW.snapshot_content) ORDER BY id DESC LIMIT 1)
      END,
      COALESCE(NEW.created_at, strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
    );
  END;
`);
}

// ../lix-sdk/src/change-author/schema.ts
function applyChangeAuthorDatabaseSchema(sqlite) {
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixChangeAuthorSchema,
    overrideName: "change_author",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix"
  });
}
var LixChangeAuthorSchema = {
  "x-lix-key": "lix_change_author",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["change_id", "account_id"],
  "x-lix-foreign-keys": {
    change_id: {
      schemaKey: "lix_change",
      property: "id"
    },
    account_id: {
      schemaKey: "lix_account",
      property: "id"
    }
  },
  type: "object",
  properties: {
    change_id: { type: "string" },
    account_id: { type: "string" }
  },
  required: ["change_id", "account_id"],
  additionalProperties: false
};

// ../lix-sdk/src/change-set/schema.ts
function applyChangeSetDatabaseSchema(sqlite) {
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixChangeSetSchema,
    overrideName: "change_set",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix",
    defaultValues: {
      id: () => nanoid()
    }
  });
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixChangeSetElementSchema,
    overrideName: "change_set_element",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix"
  });
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixChangeSetEdgeSchema,
    overrideName: "change_set_edge",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix"
  });
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixChangeSetThreadSchema,
    overrideName: "change_set_thread",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix"
  });
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixChangeSetLabelSchema,
    overrideName: "change_set_label",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix"
  });
  return sqlite;
}
var LixChangeSetSchema = {
  "x-lix-key": "lix_change_set",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["id"],
  type: "object",
  properties: {
    id: { type: "string", "x-lix-generated": true },
    metadata: { type: "object", nullable: true }
  },
  required: ["id"],
  additionalProperties: false
};
var LixChangeSetElementSchema = {
  "x-lix-key": "lix_change_set_element",
  "x-lix-version": "1.0",
  "x-lix-foreign-keys": {
    change_set_id: {
      schemaKey: "lix_change_set",
      property: "id"
    },
    change_id: {
      schemaKey: "lix_change",
      property: "id"
    },
    schema_key: {
      schemaKey: "lix_stored_schema",
      property: "key"
    }
  },
  "x-lix-primary-key": ["change_set_id", "change_id"],
  "x-lix-unique": [["change_set_id", "entity_id", "schema_key", "file_id"]],
  type: "object",
  properties: {
    change_set_id: { type: "string" },
    change_id: { type: "string" },
    entity_id: { type: "string" },
    schema_key: { type: "string" },
    file_id: { type: "string" }
  },
  required: [
    "change_set_id",
    "change_id",
    "entity_id",
    "schema_key",
    "file_id"
  ],
  additionalProperties: false
};
var LixChangeSetEdgeSchema = {
  "x-lix-key": "lix_change_set_edge",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["parent_id", "child_id"],
  "x-lix-foreign-keys": {
    parent_id: {
      schemaKey: "lix_change_set",
      property: "id"
    },
    child_id: {
      schemaKey: "lix_change_set",
      property: "id"
    }
  },
  type: "object",
  properties: {
    parent_id: { type: "string" },
    child_id: { type: "string" }
  },
  required: ["parent_id", "child_id"],
  additionalProperties: false
};
var LixChangeSetLabelSchema = {
  "x-lix-key": "lix_change_set_label",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["change_set_id", "label_id"],
  "x-lix-foreign-keys": {
    change_set_id: {
      schemaKey: "lix_change_set",
      property: "id"
    },
    label_id: {
      schemaKey: "lix_label",
      property: "id"
    }
  },
  type: "object",
  properties: {
    change_set_id: { type: "string" },
    label_id: { type: "string" },
    metadata: { type: "object", nullable: true }
  },
  required: ["change_set_id", "label_id"],
  additionalProperties: false
};
var LixChangeSetThreadSchema = {
  "x-lix-key": "lix_change_set_thread",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["change_set_id", "thread_id"],
  "x-lix-foreign-keys": {
    change_set_id: {
      schemaKey: "lix_change_set",
      property: "id"
    },
    thread_id: {
      schemaKey: "lix_thread",
      property: "id"
    }
  },
  type: "object",
  properties: {
    change_set_id: { type: "string" },
    thread_id: { type: "string" }
  },
  required: ["change_set_id", "thread_id"],
  additionalProperties: false
};

// ../lix-sdk/src/change-set/create-change-set.ts
async function createChangeSet(args) {
  const executeInTransaction = async (trx) => {
    var _a, _b, _c;
    const csId = (_a = args.id) != null ? _a : nanoid();
    if (args.lixcol_version_id) {
      await trx.insertInto("change_set_all").values({
        id: csId,
        lixcol_version_id: args.lixcol_version_id
      }).executeTakeFirstOrThrow();
    } else {
      await trx.insertInto("change_set").values({
        id: csId
      }).executeTakeFirstOrThrow();
    }
    if (args.elements && args.elements.length > 0) {
      if (args.lixcol_version_id) {
        await trx.insertInto("change_set_element_all").values(
          args.elements.map((element) => ({
            change_set_id: csId,
            lixcol_version_id: args.lixcol_version_id,
            ...element
          }))
        ).execute();
      } else {
        await trx.insertInto("change_set_element").values(
          args.elements.map((element) => ({
            change_set_id: csId,
            ...element
          }))
        ).execute();
      }
    }
    if (args.labels && args.labels.length > 0) {
      if (args.lixcol_version_id) {
        await trx.insertInto("change_set_label_all").values(
          args.labels.map((label) => ({
            lixcol_version_id: args.lixcol_version_id,
            label_id: label.id,
            change_set_id: csId
          }))
        ).execute();
      } else {
        await trx.insertInto("change_set_label").values(
          args.labels.map((label) => ({
            label_id: label.id,
            change_set_id: csId
          }))
        ).execute();
      }
    }
    for (const parent of (_b = args.parents) != null ? _b : []) {
      if (args.lixcol_version_id) {
        await trx.insertInto("change_set_edge_all").values({
          parent_id: parent.id,
          child_id: csId,
          lixcol_version_id: args.lixcol_version_id
        }).execute();
      } else {
        await trx.insertInto("change_set_edge").values({
          parent_id: parent.id,
          child_id: csId
        }).execute();
      }
    }
    const changeSet = await trx.selectFrom("change_set_all").selectAll().where("id", "=", csId).where(
      "lixcol_version_id",
      "=",
      (_c = args.lixcol_version_id) != null ? _c : trx.selectFrom("active_version").select("version_id")
    ).executeTakeFirstOrThrow();
    return changeSet;
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/object-utils.js
function isUndefined(obj) {
  return typeof obj === "undefined" || obj === void 0;
}
function isString(obj) {
  return typeof obj === "string";
}
function isNumber(obj) {
  return typeof obj === "number";
}
function isBoolean(obj) {
  return typeof obj === "boolean";
}
function isNull(obj) {
  return obj === null;
}
function isDate(obj) {
  return obj instanceof Date;
}
function isBigInt(obj) {
  return typeof obj === "bigint";
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function isPlainObject(obj) {
  if (!isObject(obj) || getTag(obj) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(obj) === null) {
    return true;
  }
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function freeze(obj) {
  return Object.freeze(obj);
}
function asArray(arg) {
  if (isReadonlyArray(arg)) {
    return arg;
  } else {
    return [arg];
  }
}
function isReadonlyArray(arg) {
  return Array.isArray(arg);
}
function noop(obj) {
  return obj;
}
var toString = Object.prototype.toString;
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return toString.call(value);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/alter-table-node.js
var AlterTableNode = freeze({
  is(node) {
    return node.kind === "AlterTableNode";
  },
  create(table) {
    return freeze({
      kind: "AlterTableNode",
      table
    });
  },
  cloneWithTableProps(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumnAlteration(node, columnAlteration) {
    return freeze({
      ...node,
      columnAlterations: node.columnAlterations ? [...node.columnAlterations, columnAlteration] : [columnAlteration]
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/identifier-node.js
var IdentifierNode = freeze({
  is(node) {
    return node.kind === "IdentifierNode";
  },
  create(name) {
    return freeze({
      kind: "IdentifierNode",
      name
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/create-index-node.js
var CreateIndexNode = freeze({
  is(node) {
    return node.kind === "CreateIndexNode";
  },
  create(name) {
    return freeze({
      kind: "CreateIndexNode",
      name: IdentifierNode.create(name)
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumns(node, columns) {
    return freeze({
      ...node,
      columns: [...node.columns || [], ...columns]
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/create-schema-node.js
var CreateSchemaNode = freeze({
  is(node) {
    return node.kind === "CreateSchemaNode";
  },
  create(schema, params) {
    return freeze({
      kind: "CreateSchemaNode",
      schema: IdentifierNode.create(schema),
      ...params
    });
  },
  cloneWith(createSchema, params) {
    return freeze({
      ...createSchema,
      ...params
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/create-table-node.js
var ON_COMMIT_ACTIONS = ["preserve rows", "delete rows", "drop"];
var CreateTableNode = freeze({
  is(node) {
    return node.kind === "CreateTableNode";
  },
  create(table) {
    return freeze({
      kind: "CreateTableNode",
      table,
      columns: freeze([])
    });
  },
  cloneWithColumn(createTable, column) {
    return freeze({
      ...createTable,
      columns: freeze([...createTable.columns, column])
    });
  },
  cloneWithConstraint(createTable, constraint) {
    return freeze({
      ...createTable,
      constraints: createTable.constraints ? freeze([...createTable.constraints, constraint]) : freeze([constraint])
    });
  },
  cloneWithFrontModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      frontModifiers: createTable.frontModifiers ? freeze([...createTable.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithEndModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      endModifiers: createTable.endModifiers ? freeze([...createTable.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWith(createTable, params) {
    return freeze({
      ...createTable,
      ...params
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/schemable-identifier-node.js
var SchemableIdentifierNode = freeze({
  is(node) {
    return node.kind === "SchemableIdentifierNode";
  },
  create(identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      identifier: IdentifierNode.create(identifier)
    });
  },
  createWithSchema(schema, identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      schema: IdentifierNode.create(schema),
      identifier: IdentifierNode.create(identifier)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/drop-index-node.js
var DropIndexNode = freeze({
  is(node) {
    return node.kind === "DropIndexNode";
  },
  create(name, params) {
    return freeze({
      kind: "DropIndexNode",
      name: SchemableIdentifierNode.create(name),
      ...params
    });
  },
  cloneWith(dropIndex, props) {
    return freeze({
      ...dropIndex,
      ...props
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/drop-schema-node.js
var DropSchemaNode = freeze({
  is(node) {
    return node.kind === "DropSchemaNode";
  },
  create(schema, params) {
    return freeze({
      kind: "DropSchemaNode",
      schema: IdentifierNode.create(schema),
      ...params
    });
  },
  cloneWith(dropSchema, params) {
    return freeze({
      ...dropSchema,
      ...params
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/drop-table-node.js
var DropTableNode = freeze({
  is(node) {
    return node.kind === "DropTableNode";
  },
  create(table, params) {
    return freeze({
      kind: "DropTableNode",
      table,
      ...params
    });
  },
  cloneWith(dropIndex, params) {
    return freeze({
      ...dropIndex,
      ...params
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/alias-node.js
var AliasNode = freeze({
  is(node) {
    return node.kind === "AliasNode";
  },
  create(node, alias) {
    return freeze({
      kind: "AliasNode",
      node,
      alias
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/table-node.js
var TableNode = freeze({
  is(node) {
    return node.kind === "TableNode";
  },
  create(table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.create(table)
    });
  },
  createWithSchema(schema, table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.createWithSchema(schema, table)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/operation-node-source.js
function isOperationNodeSource(obj) {
  return isObject(obj) && isFunction(obj.toOperationNode);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/expression/expression.js
function isExpression(obj) {
  return isObject(obj) && "expressionType" in obj && isOperationNodeSource(obj);
}
function isAliasedExpression(obj) {
  return isObject(obj) && "expression" in obj && isString(obj.alias) && isOperationNodeSource(obj);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/select-modifier-node.js
var SelectModifierNode = freeze({
  is(node) {
    return node.kind === "SelectModifierNode";
  },
  create(modifier, of) {
    return freeze({
      kind: "SelectModifierNode",
      modifier,
      of
    });
  },
  createWithExpression(modifier) {
    return freeze({
      kind: "SelectModifierNode",
      rawModifier: modifier
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/and-node.js
var AndNode = freeze({
  is(node) {
    return node.kind === "AndNode";
  },
  create(left, right) {
    return freeze({
      kind: "AndNode",
      left,
      right
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/or-node.js
var OrNode = freeze({
  is(node) {
    return node.kind === "OrNode";
  },
  create(left, right) {
    return freeze({
      kind: "OrNode",
      left,
      right
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/on-node.js
var OnNode = freeze({
  is(node) {
    return node.kind === "OnNode";
  },
  create(filter) {
    return freeze({
      kind: "OnNode",
      on: filter
    });
  },
  cloneWithOperation(onNode, operator, operation) {
    return freeze({
      ...onNode,
      on: operator === "And" ? AndNode.create(onNode.on, operation) : OrNode.create(onNode.on, operation)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/join-node.js
var JoinNode = freeze({
  is(node) {
    return node.kind === "JoinNode";
  },
  create(joinType, table) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: void 0
    });
  },
  createWithOn(joinType, table, on) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: OnNode.create(on)
    });
  },
  cloneWithOn(joinNode, operation) {
    return freeze({
      ...joinNode,
      on: joinNode.on ? OnNode.cloneWithOperation(joinNode.on, "And", operation) : OnNode.create(operation)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/binary-operation-node.js
var BinaryOperationNode = freeze({
  is(node) {
    return node.kind === "BinaryOperationNode";
  },
  create(leftOperand, operator, rightOperand) {
    return freeze({
      kind: "BinaryOperationNode",
      leftOperand,
      operator,
      rightOperand
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/operator-node.js
var COMPARISON_OPERATORS = [
  "=",
  "==",
  "!=",
  "<>",
  ">",
  ">=",
  "<",
  "<=",
  "in",
  "not in",
  "is",
  "is not",
  "like",
  "not like",
  "match",
  "ilike",
  "not ilike",
  "@>",
  "<@",
  "^@",
  "&&",
  "?",
  "?&",
  "?|",
  "!<",
  "!>",
  "<=>",
  "!~",
  "~",
  "~*",
  "!~*",
  "@@",
  "@@@",
  "!!",
  "<->",
  "regexp",
  "is distinct from",
  "is not distinct from"
];
var ARITHMETIC_OPERATORS = [
  "+",
  "-",
  "*",
  "/",
  "%",
  "^",
  "&",
  "|",
  "#",
  "<<",
  ">>"
];
var JSON_OPERATORS = ["->", "->>"];
var BINARY_OPERATORS = [
  ...COMPARISON_OPERATORS,
  ...ARITHMETIC_OPERATORS,
  "&&",
  "||"
];
var UNARY_FILTER_OPERATORS = ["exists", "not exists"];
var UNARY_OPERATORS = ["not", "-", ...UNARY_FILTER_OPERATORS];
var OPERATORS = [
  ...BINARY_OPERATORS,
  ...JSON_OPERATORS,
  ...UNARY_OPERATORS,
  "between",
  "between symmetric"
];
var OperatorNode = freeze({
  is(node) {
    return node.kind === "OperatorNode";
  },
  create(operator) {
    return freeze({
      kind: "OperatorNode",
      operator
    });
  }
});
function isJSONOperator(op) {
  return isString(op) && JSON_OPERATORS.includes(op);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/column-node.js
var ColumnNode = freeze({
  is(node) {
    return node.kind === "ColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ColumnNode",
      column: IdentifierNode.create(column)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/select-all-node.js
var SelectAllNode = freeze({
  is(node) {
    return node.kind === "SelectAllNode";
  },
  create() {
    return freeze({
      kind: "SelectAllNode"
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/reference-node.js
var ReferenceNode = freeze({
  is(node) {
    return node.kind === "ReferenceNode";
  },
  create(column, table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column
    });
  },
  createSelectAll(table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column: SelectAllNode.create()
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/dynamic/dynamic-reference-builder.js
var _dynamicReference;
var DynamicReferenceBuilder = class {
  constructor(reference) {
    __privateAdd(this, _dynamicReference);
    __privateSet(this, _dynamicReference, reference);
  }
  get dynamicReference() {
    return __privateGet(this, _dynamicReference);
  }
  /**
   * @private
   *
   * This needs to be here just so that the typings work. Without this
   * the generated .d.ts file contains no reference to the type param R
   * which causes this type to be equal to DynamicReferenceBuilder with
   * any R.
   */
  get refType() {
    return void 0;
  }
  toOperationNode() {
    return parseSimpleReferenceExpression(__privateGet(this, _dynamicReference));
  }
};
_dynamicReference = new WeakMap();
function isDynamicReferenceBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString(obj.dynamicReference);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/order-by-item-node.js
var OrderByItemNode = freeze({
  is(node) {
    return node.kind === "OrderByItemNode";
  },
  create(orderBy, direction) {
    return freeze({
      kind: "OrderByItemNode",
      orderBy,
      direction
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/raw-node.js
var RawNode = freeze({
  is(node) {
    return node.kind === "RawNode";
  },
  create(sqlFragments, parameters) {
    return freeze({
      kind: "RawNode",
      sqlFragments: freeze(sqlFragments),
      parameters: freeze(parameters)
    });
  },
  createWithSql(sql2) {
    return RawNode.create([sql2], []);
  },
  createWithChild(child) {
    return RawNode.create(["", ""], [child]);
  },
  createWithChildren(children) {
    return RawNode.create(new Array(children.length + 1).fill(""), children);
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/order-by-parser.js
function isOrderByDirection(thing) {
  return thing === "asc" || thing === "desc";
}
function parseOrderBy(args) {
  if (args.length === 2) {
    return [parseOrderByItem(args[0], args[1])];
  }
  if (args.length === 1) {
    const [orderBy] = args;
    if (Array.isArray(orderBy)) {
      return orderBy.map((item) => parseOrderByItem(item));
    }
    return [parseOrderByItem(orderBy)];
  }
  throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);
}
function parseOrderByItem(ref, direction) {
  const parsedRef = parseOrderByExpression(ref);
  if (OrderByItemNode.is(parsedRef)) {
    if (direction) {
      throw new Error("Cannot specify direction twice!");
    }
    return parsedRef;
  }
  return OrderByItemNode.create(parsedRef, parseOrderByDirectionExpression(direction));
}
function parseOrderByExpression(expr) {
  if (isExpressionOrFactory(expr)) {
    return parseExpression(expr);
  }
  if (isDynamicReferenceBuilder(expr)) {
    return expr.toOperationNode();
  }
  const [ref, direction] = expr.split(" ");
  if (direction) {
    if (!isOrderByDirection(direction)) {
      throw new Error(`Invalid order by direction: ${direction}`);
    }
    return OrderByItemNode.create(parseStringReference(ref), parseOrderByDirectionExpression(direction));
  }
  return parseStringReference(expr);
}
function parseOrderByDirectionExpression(expr) {
  if (!expr) {
    return void 0;
  }
  if (expr === "asc" || expr === "desc") {
    return RawNode.createWithSql(expr);
  }
  return expr.toOperationNode();
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/json-reference-node.js
var JSONReferenceNode = freeze({
  is(node) {
    return node.kind === "JSONReferenceNode";
  },
  create(reference, traversal) {
    return freeze({
      kind: "JSONReferenceNode",
      reference,
      traversal
    });
  },
  cloneWithTraversal(node, traversal) {
    return freeze({
      ...node,
      traversal
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/json-operator-chain-node.js
var JSONOperatorChainNode = freeze({
  is(node) {
    return node.kind === "JSONOperatorChainNode";
  },
  create(operator) {
    return freeze({
      kind: "JSONOperatorChainNode",
      operator,
      values: freeze([])
    });
  },
  cloneWithValue(node, value) {
    return freeze({
      ...node,
      values: freeze([...node.values, value])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/json-path-node.js
var JSONPathNode = freeze({
  is(node) {
    return node.kind === "JSONPathNode";
  },
  create(inOperator) {
    return freeze({
      kind: "JSONPathNode",
      inOperator,
      pathLegs: freeze([])
    });
  },
  cloneWithLeg(jsonPathNode, pathLeg) {
    return freeze({
      ...jsonPathNode,
      pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/reference-parser.js
function parseSimpleReferenceExpression(exp) {
  if (isString(exp)) {
    return parseStringReference(exp);
  }
  return exp.toOperationNode();
}
function parseReferenceExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return arg.map((it) => parseReferenceExpression(it));
  } else {
    return [parseReferenceExpression(arg)];
  }
}
function parseReferenceExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return parseSimpleReferenceExpression(exp);
}
function parseJSONReference(ref, op) {
  const referenceNode = parseStringReference(ref);
  if (isJSONOperator(op)) {
    return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));
  }
  const opWithoutLastChar = op.slice(0, -1);
  if (isJSONOperator(opWithoutLastChar)) {
    return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));
  }
  throw new Error(`Invalid JSON operator: ${op}`);
}
function parseStringReference(ref) {
  const COLUMN_SEPARATOR = ".";
  if (!ref.includes(COLUMN_SEPARATOR)) {
    return ReferenceNode.create(ColumnNode.create(ref));
  }
  const parts = ref.split(COLUMN_SEPARATOR).map(trim);
  if (parts.length === 3) {
    return parseStringReferenceWithTableAndSchema(parts);
  }
  if (parts.length === 2) {
    return parseStringReferenceWithTable(parts);
  }
  throw new Error(`invalid column reference ${ref}`);
}
function parseAliasedStringReference(ref) {
  const ALIAS_SEPARATOR = " as ";
  if (ref.includes(ALIAS_SEPARATOR)) {
    const [columnRef, alias] = ref.split(ALIAS_SEPARATOR).map(trim);
    return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias));
  } else {
    return parseStringReference(ref);
  }
}
function parseColumnName(column) {
  return ColumnNode.create(column);
}
function parseOrderedColumnName(column) {
  const ORDER_SEPARATOR = " ";
  if (column.includes(ORDER_SEPARATOR)) {
    const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim);
    if (!isOrderByDirection(order)) {
      throw new Error(`invalid order direction "${order}" next to "${columnName}"`);
    }
    return parseOrderBy([columnName, order])[0];
  } else {
    return parseColumnName(column);
  }
}
function parseStringReferenceWithTableAndSchema(parts) {
  const [schema, table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema, table));
}
function parseStringReferenceWithTable(parts) {
  const [table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table));
}
function trim(str) {
  return str.trim();
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/primitive-value-list-node.js
var PrimitiveValueListNode = freeze({
  is(node) {
    return node.kind === "PrimitiveValueListNode";
  },
  create(values) {
    return freeze({
      kind: "PrimitiveValueListNode",
      values: freeze([...values])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/value-list-node.js
var ValueListNode = freeze({
  is(node) {
    return node.kind === "ValueListNode";
  },
  create(values) {
    return freeze({
      kind: "ValueListNode",
      values: freeze(values)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/value-node.js
var ValueNode = freeze({
  is(node) {
    return node.kind === "ValueNode";
  },
  create(value) {
    return freeze({
      kind: "ValueNode",
      value
    });
  },
  createImmediate(value) {
    return freeze({
      kind: "ValueNode",
      value,
      immediate: true
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/value-parser.js
function parseValueExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return parseValueExpressionList(arg);
  }
  return parseValueExpression(arg);
}
function parseValueExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return ValueNode.create(exp);
}
function isSafeImmediateValue(value) {
  return isNumber(value) || isBoolean(value) || isNull(value);
}
function parseSafeImmediateValue(value) {
  if (!isSafeImmediateValue(value)) {
    throw new Error(`unsafe immediate value ${JSON.stringify(value)}`);
  }
  return ValueNode.createImmediate(value);
}
function parseValueExpressionList(arg) {
  if (arg.some(isExpressionOrFactory)) {
    return ValueListNode.create(arg.map((it) => parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(arg);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/parens-node.js
var ParensNode = freeze({
  is(node) {
    return node.kind === "ParensNode";
  },
  create(node) {
    return freeze({
      kind: "ParensNode",
      node
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/binary-operation-parser.js
function parseValueBinaryOperationOrExpression(args) {
  if (args.length === 3) {
    return parseValueBinaryOperation(args[0], args[1], args[2]);
  } else if (args.length === 1) {
    return parseValueExpression(args[0]);
  }
  throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
function parseValueBinaryOperation(left, operator, right) {
  if (isIsOperator(operator) && needsIsOperator(right)) {
    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), ValueNode.createImmediate(right));
  }
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseValueExpressionOrList(right));
}
function parseReferentialBinaryOperation(left, operator, right) {
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseReferenceExpression(right));
}
function parseFilterObject(obj, combinator) {
  return parseFilterList(Object.entries(obj).filter(([, v2]) => !isUndefined(v2)).map(([k, v2]) => parseValueBinaryOperation(k, needsIsOperator(v2) ? "is" : "=", v2)), combinator);
}
function parseFilterList(list, combinator, withParens = true) {
  const combine = combinator === "and" ? AndNode.create : OrNode.create;
  if (list.length === 0) {
    return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create("="), ValueNode.createImmediate(combinator === "and" ? 1 : 0));
  }
  let node = toOperationNode(list[0]);
  for (let i = 1; i < list.length; ++i) {
    node = combine(node, toOperationNode(list[i]));
  }
  if (list.length > 1 && withParens) {
    return ParensNode.create(node);
  }
  return node;
}
function isIsOperator(operator) {
  return operator === "is" || operator === "is not";
}
function needsIsOperator(value) {
  return isNull(value) || isBoolean(value);
}
function parseOperator(operator) {
  if (isString(operator) && OPERATORS.includes(operator)) {
    return OperatorNode.create(operator);
  }
  if (isOperationNodeSource(operator)) {
    return operator.toOperationNode();
  }
  throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function toOperationNode(nodeOrSource) {
  return isOperationNodeSource(nodeOrSource) ? nodeOrSource.toOperationNode() : nodeOrSource;
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/order-by-node.js
var OrderByNode = freeze({
  is(node) {
    return node.kind === "OrderByNode";
  },
  create(items) {
    return freeze({
      kind: "OrderByNode",
      items: freeze([...items])
    });
  },
  cloneWithItems(orderBy, items) {
    return freeze({
      ...orderBy,
      items: freeze([...orderBy.items, ...items])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/partition-by-node.js
var PartitionByNode = freeze({
  is(node) {
    return node.kind === "PartitionByNode";
  },
  create(items) {
    return freeze({
      kind: "PartitionByNode",
      items: freeze(items)
    });
  },
  cloneWithItems(partitionBy, items) {
    return freeze({
      ...partitionBy,
      items: freeze([...partitionBy.items, ...items])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/over-node.js
var OverNode = freeze({
  is(node) {
    return node.kind === "OverNode";
  },
  create() {
    return freeze({
      kind: "OverNode"
    });
  },
  cloneWithOrderByItems(overNode, items) {
    return freeze({
      ...overNode,
      orderBy: overNode.orderBy ? OrderByNode.cloneWithItems(overNode.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithPartitionByItems(overNode, items) {
    return freeze({
      ...overNode,
      partitionBy: overNode.partitionBy ? PartitionByNode.cloneWithItems(overNode.partitionBy, items) : PartitionByNode.create(items)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/from-node.js
var FromNode = freeze({
  is(node) {
    return node.kind === "FromNode";
  },
  create(froms) {
    return freeze({
      kind: "FromNode",
      froms: freeze(froms)
    });
  },
  cloneWithFroms(from, froms) {
    return freeze({
      ...from,
      froms: freeze([...from.froms, ...froms])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/group-by-node.js
var GroupByNode = freeze({
  is(node) {
    return node.kind === "GroupByNode";
  },
  create(items) {
    return freeze({
      kind: "GroupByNode",
      items: freeze(items)
    });
  },
  cloneWithItems(groupBy, items) {
    return freeze({
      ...groupBy,
      items: freeze([...groupBy.items, ...items])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/having-node.js
var HavingNode = freeze({
  is(node) {
    return node.kind === "HavingNode";
  },
  create(filter) {
    return freeze({
      kind: "HavingNode",
      having: filter
    });
  },
  cloneWithOperation(havingNode, operator, operation) {
    return freeze({
      ...havingNode,
      having: operator === "And" ? AndNode.create(havingNode.having, operation) : OrNode.create(havingNode.having, operation)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/select-query-node.js
var SelectQueryNode = freeze({
  is(node) {
    return node.kind === "SelectQueryNode";
  },
  create(withNode) {
    return freeze({
      kind: "SelectQueryNode",
      ...withNode && { with: withNode }
    });
  },
  createFrom(fromItems, withNode) {
    return freeze({
      kind: "SelectQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  cloneWithSelections(select, selections) {
    return freeze({
      ...select,
      selections: select.selections ? freeze([...select.selections, ...selections]) : freeze(selections)
    });
  },
  cloneWithDistinctOn(select, expressions) {
    return freeze({
      ...select,
      distinctOn: select.distinctOn ? freeze([...select.distinctOn, ...expressions]) : freeze(expressions)
    });
  },
  cloneWithFrontModifier(select, modifier) {
    return freeze({
      ...select,
      frontModifiers: select.frontModifiers ? freeze([...select.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithOrderByItems(selectNode, items) {
    return freeze({
      ...selectNode,
      orderBy: selectNode.orderBy ? OrderByNode.cloneWithItems(selectNode.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithGroupByItems(selectNode, items) {
    return freeze({
      ...selectNode,
      groupBy: selectNode.groupBy ? GroupByNode.cloneWithItems(selectNode.groupBy, items) : GroupByNode.create(items)
    });
  },
  cloneWithLimit(selectNode, limit) {
    return freeze({
      ...selectNode,
      limit
    });
  },
  cloneWithOffset(selectNode, offset) {
    return freeze({
      ...selectNode,
      offset
    });
  },
  cloneWithFetch(selectNode, fetch2) {
    return freeze({
      ...selectNode,
      fetch: fetch2
    });
  },
  cloneWithHaving(selectNode, operation) {
    return freeze({
      ...selectNode,
      having: selectNode.having ? HavingNode.cloneWithOperation(selectNode.having, "And", operation) : HavingNode.create(operation)
    });
  },
  cloneWithSetOperations(selectNode, setOperations) {
    return freeze({
      ...selectNode,
      setOperations: selectNode.setOperations ? freeze([...selectNode.setOperations, ...setOperations]) : freeze([...setOperations])
    });
  },
  cloneWithoutSelections(select) {
    return freeze({
      ...select,
      selections: []
    });
  },
  cloneWithoutLimit(select) {
    return freeze({
      ...select,
      limit: void 0
    });
  },
  cloneWithoutOffset(select) {
    return freeze({
      ...select,
      offset: void 0
    });
  },
  cloneWithoutOrderBy(select) {
    return freeze({
      ...select,
      orderBy: void 0
    });
  },
  cloneWithoutGroupBy(select) {
    return freeze({
      ...select,
      groupBy: void 0
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/prevent-await.js
function preventAwait(clazz, message) {
  Object.defineProperties(clazz.prototype, {
    then: {
      enumerable: false,
      value: () => {
        throw new Error(message);
      }
    }
  });
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/join-builder.js
var _props;
var _JoinBuilder = class _JoinBuilder {
  constructor(props) {
    __privateAdd(this, _props);
    __privateSet(this, _props, freeze(props));
  }
  on(...args) {
    return new _JoinBuilder({
      ...__privateGet(this, _props),
      joinNode: JoinNode.cloneWithOn(__privateGet(this, _props).joinNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Just like {@link WhereInterface.whereRef} but adds an item to the join's
   * `on` clause instead.
   *
   * See {@link WhereInterface.whereRef} for documentation and examples.
   */
  onRef(lhs, op, rhs) {
    return new _JoinBuilder({
      ...__privateGet(this, _props),
      joinNode: JoinNode.cloneWithOn(__privateGet(this, _props).joinNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  /**
   * Adds `on true`.
   */
  onTrue() {
    return new _JoinBuilder({
      ...__privateGet(this, _props),
      joinNode: JoinNode.cloneWithOn(__privateGet(this, _props).joinNode, RawNode.createWithSql("true"))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props).joinNode;
  }
};
_props = new WeakMap();
var JoinBuilder = _JoinBuilder;
preventAwait(JoinBuilder, "don't await JoinBuilder instances. They are never executed directly and are always just a part of a query.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/partition-by-item-node.js
var PartitionByItemNode = freeze({
  is(node) {
    return node.kind === "PartitionByItemNode";
  },
  create(partitionBy) {
    return freeze({
      kind: "PartitionByItemNode",
      partitionBy
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/partition-by-parser.js
function parsePartitionBy(partitionBy) {
  return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/over-builder.js
var _props2;
var _OverBuilder = class _OverBuilder {
  constructor(props) {
    __privateAdd(this, _props2);
    __privateSet(this, _props2, freeze(props));
  }
  /**
   * Adds an order by clause item inside the over function.
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over(
   *       ob => ob.orderBy('first_name', 'asc').orderBy('last_name', 'asc')
   *     ).as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over(order by "first_name" asc, "last_name" asc) as "average_age"
   * from "person"
   * ```
   */
  orderBy(orderBy, direction) {
    return new _OverBuilder({
      overNode: OverNode.cloneWithOrderByItems(__privateGet(this, _props2).overNode, parseOrderBy([orderBy, direction]))
    });
  }
  partitionBy(partitionBy) {
    return new _OverBuilder({
      overNode: OverNode.cloneWithPartitionByItems(__privateGet(this, _props2).overNode, parsePartitionBy(partitionBy))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props2).overNode;
  }
};
_props2 = new WeakMap();
var OverBuilder = _OverBuilder;
preventAwait(OverBuilder, "don't await OverBuilder instances. They are never executed directly and are always just a part of a query.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/selection-node.js
var SelectionNode = freeze({
  is(node) {
    return node.kind === "SelectionNode";
  },
  create(selection) {
    return freeze({
      kind: "SelectionNode",
      selection
    });
  },
  createSelectAll() {
    return freeze({
      kind: "SelectionNode",
      selection: SelectAllNode.create()
    });
  },
  createSelectAllFromTable(table) {
    return freeze({
      kind: "SelectionNode",
      selection: ReferenceNode.createSelectAll(table)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/select-parser.js
function parseSelectArg(selection) {
  if (isFunction(selection)) {
    return parseSelectArg(selection(expressionBuilder()));
  } else if (isReadonlyArray(selection)) {
    return selection.map((it) => parseSelectExpression(it));
  } else {
    return [parseSelectExpression(selection)];
  }
}
function parseSelectExpression(selection) {
  if (isString(selection)) {
    return SelectionNode.create(parseAliasedStringReference(selection));
  } else if (isDynamicReferenceBuilder(selection)) {
    return SelectionNode.create(selection.toOperationNode());
  } else {
    return SelectionNode.create(parseAliasedExpression(selection));
  }
}
function parseSelectAll(table) {
  if (!table) {
    return [SelectionNode.createSelectAll()];
  } else if (Array.isArray(table)) {
    return table.map(parseSelectAllArg);
  } else {
    return [parseSelectAllArg(table)];
  }
}
function parseSelectAllArg(table) {
  if (isString(table)) {
    return SelectionNode.createSelectAllFromTable(parseTable(table));
  }
  throw new Error(`invalid value selectAll expression: ${JSON.stringify(table)}`);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/values-node.js
var ValuesNode = freeze({
  is(node) {
    return node.kind === "ValuesNode";
  },
  create(values) {
    return freeze({
      kind: "ValuesNode",
      values: freeze(values)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/default-insert-value-node.js
var DefaultInsertValueNode = freeze({
  is(node) {
    return node.kind === "DefaultInsertValueNode";
  },
  create() {
    return freeze({
      kind: "DefaultInsertValueNode"
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/insert-values-parser.js
function parseInsertExpression(arg) {
  const objectOrList = isFunction(arg) ? arg(expressionBuilder()) : arg;
  const list = isReadonlyArray(objectOrList) ? objectOrList : freeze([objectOrList]);
  return parseInsertColumnsAndValues(list);
}
function parseInsertColumnsAndValues(rows) {
  const columns = parseColumnNamesAndIndexes(rows);
  return [
    freeze([...columns.keys()].map(ColumnNode.create)),
    ValuesNode.create(rows.map((row) => parseRowValues(row, columns)))
  ];
}
function parseColumnNamesAndIndexes(rows) {
  const columns = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const cols = Object.keys(row);
    for (const col of cols) {
      if (!columns.has(col) && row[col] !== void 0) {
        columns.set(col, columns.size);
      }
    }
  }
  return columns;
}
function parseRowValues(row, columns) {
  const rowColumns = Object.keys(row);
  const rowValues = Array.from({
    length: columns.size
  });
  let hasUndefinedOrComplexColumns = false;
  let indexedRowColumns = rowColumns.length;
  for (const col of rowColumns) {
    const columnIdx = columns.get(col);
    if (isUndefined(columnIdx)) {
      indexedRowColumns--;
      continue;
    }
    const value = row[col];
    if (isUndefined(value) || isExpressionOrFactory(value)) {
      hasUndefinedOrComplexColumns = true;
    }
    rowValues[columnIdx] = value;
  }
  const hasMissingColumns = indexedRowColumns < columns.size;
  if (hasMissingColumns || hasUndefinedOrComplexColumns) {
    const defaultValue = DefaultInsertValueNode.create();
    return ValueListNode.create(rowValues.map((it) => isUndefined(it) ? defaultValue : parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(rowValues);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/insert-query-node.js
var InsertQueryNode = freeze({
  is(node) {
    return node.kind === "InsertQueryNode";
  },
  create(into, withNode, replace) {
    return freeze({
      kind: "InsertQueryNode",
      into,
      ...withNode && { with: withNode },
      replace
    });
  },
  createWithoutInto() {
    return freeze({
      kind: "InsertQueryNode"
    });
  },
  cloneWith(insertQuery, props) {
    return freeze({
      ...insertQuery,
      ...props
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/update-query-node.js
var UpdateQueryNode = freeze({
  is(node) {
    return node.kind === "UpdateQueryNode";
  },
  create(table, withNode) {
    return freeze({
      kind: "UpdateQueryNode",
      table,
      ...withNode && { with: withNode }
    });
  },
  createWithoutTable() {
    return freeze({
      kind: "UpdateQueryNode"
    });
  },
  cloneWithFromItems(updateQuery, fromItems) {
    return freeze({
      ...updateQuery,
      from: updateQuery.from ? FromNode.cloneWithFroms(updateQuery.from, fromItems) : FromNode.create(fromItems)
    });
  },
  cloneWithUpdates(updateQuery, updates) {
    return freeze({
      ...updateQuery,
      updates: updateQuery.updates ? freeze([...updateQuery.updates, ...updates]) : updates
    });
  },
  cloneWithLimit(updateQuery, limit) {
    return freeze({
      ...updateQuery,
      limit
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/using-node.js
var UsingNode = freeze({
  is(node) {
    return node.kind === "UsingNode";
  },
  create(tables) {
    return freeze({
      kind: "UsingNode",
      tables: freeze(tables)
    });
  },
  cloneWithTables(using, tables) {
    return freeze({
      ...using,
      tables: freeze([...using.tables, ...tables])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/delete-query-node.js
var DeleteQueryNode = freeze({
  is(node) {
    return node.kind === "DeleteQueryNode";
  },
  create(fromItems, withNode) {
    return freeze({
      kind: "DeleteQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  cloneWithOrderByItems(deleteNode, items) {
    return freeze({
      ...deleteNode,
      orderBy: deleteNode.orderBy ? OrderByNode.cloneWithItems(deleteNode.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithoutOrderBy(deleteNode) {
    return freeze({
      ...deleteNode,
      orderBy: void 0
    });
  },
  cloneWithLimit(deleteNode, limit) {
    return freeze({
      ...deleteNode,
      limit
    });
  },
  cloneWithoutLimit(deleteNode) {
    return freeze({
      ...deleteNode,
      limit: void 0
    });
  },
  cloneWithUsing(deleteNode, tables) {
    return freeze({
      ...deleteNode,
      using: deleteNode.using !== void 0 ? UsingNode.cloneWithTables(deleteNode.using, tables) : UsingNode.create(tables)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/where-node.js
var WhereNode = freeze({
  is(node) {
    return node.kind === "WhereNode";
  },
  create(filter) {
    return freeze({
      kind: "WhereNode",
      where: filter
    });
  },
  cloneWithOperation(whereNode, operator, operation) {
    return freeze({
      ...whereNode,
      where: operator === "And" ? AndNode.create(whereNode.where, operation) : OrNode.create(whereNode.where, operation)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/returning-node.js
var ReturningNode = freeze({
  is(node) {
    return node.kind === "ReturningNode";
  },
  create(selections) {
    return freeze({
      kind: "ReturningNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(returning, selections) {
    return freeze({
      ...returning,
      selections: returning.selections ? freeze([...returning.selections, ...selections]) : freeze(selections)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/explain-node.js
var ExplainNode = freeze({
  is(node) {
    return node.kind === "ExplainNode";
  },
  create(format, options) {
    return freeze({
      kind: "ExplainNode",
      format,
      options
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/when-node.js
var WhenNode = freeze({
  is(node) {
    return node.kind === "WhenNode";
  },
  create(condition) {
    return freeze({
      kind: "WhenNode",
      condition
    });
  },
  cloneWithResult(whenNode, result) {
    return freeze({
      ...whenNode,
      result
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/merge-query-node.js
var MergeQueryNode = freeze({
  is(node) {
    return node.kind === "MergeQueryNode";
  },
  create(into, withNode) {
    return freeze({
      kind: "MergeQueryNode",
      into,
      ...withNode && { with: withNode }
    });
  },
  cloneWithUsing(mergeNode, using) {
    return freeze({
      ...mergeNode,
      using
    });
  },
  cloneWithWhen(mergeNode, when) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([...mergeNode.whens, when]) : freeze([when])
    });
  },
  cloneWithThen(mergeNode, then) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([
        ...mergeNode.whens.slice(0, -1),
        WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then)
      ]) : void 0
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/output-node.js
var OutputNode = freeze({
  is(node) {
    return node.kind === "OutputNode";
  },
  create(selections) {
    return freeze({
      kind: "OutputNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(output, selections) {
    return freeze({
      ...output,
      selections: output.selections ? freeze([...output.selections, ...selections]) : freeze(selections)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/query-node.js
var QueryNode = freeze({
  is(node) {
    return SelectQueryNode.is(node) || InsertQueryNode.is(node) || UpdateQueryNode.is(node) || DeleteQueryNode.is(node) || MergeQueryNode.is(node);
  },
  cloneWithEndModifier(node, modifier) {
    return freeze({
      ...node,
      endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithWhere(node, operation) {
    return freeze({
      ...node,
      where: node.where ? WhereNode.cloneWithOperation(node.where, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithJoin(node, join) {
    return freeze({
      ...node,
      joins: node.joins ? freeze([...node.joins, join]) : freeze([join])
    });
  },
  cloneWithReturning(node, selections) {
    return freeze({
      ...node,
      returning: node.returning ? ReturningNode.cloneWithSelections(node.returning, selections) : ReturningNode.create(selections)
    });
  },
  cloneWithoutReturning(node) {
    return freeze({
      ...node,
      returning: void 0
    });
  },
  cloneWithoutWhere(node) {
    return freeze({
      ...node,
      where: void 0
    });
  },
  cloneWithExplain(node, format, options) {
    return freeze({
      ...node,
      explain: ExplainNode.create(format, options == null ? void 0 : options.toOperationNode())
    });
  },
  cloneWithTop(node, top) {
    return freeze({
      ...node,
      top
    });
  },
  cloneWithOutput(node, selections) {
    return freeze({
      ...node,
      output: node.output ? OutputNode.cloneWithSelections(node.output, selections) : OutputNode.create(selections)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/column-update-node.js
var ColumnUpdateNode = freeze({
  is(node) {
    return node.kind === "ColumnUpdateNode";
  },
  create(column, value) {
    return freeze({
      kind: "ColumnUpdateNode",
      column,
      value
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/update-set-parser.js
function parseUpdate(...args) {
  if (args.length === 2) {
    return [
      ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1]))
    ];
  }
  return parseUpdateObjectExpression(args[0]);
}
function parseUpdateObjectExpression(update) {
  const updateObj = isFunction(update) ? update(expressionBuilder()) : update;
  return Object.entries(updateObj).filter(([_, value]) => value !== void 0).map(([key, value]) => {
    return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value));
  });
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/on-duplicate-key-node.js
var OnDuplicateKeyNode = freeze({
  is(node) {
    return node.kind === "OnDuplicateKeyNode";
  },
  create(updates) {
    return freeze({
      kind: "OnDuplicateKeyNode",
      updates
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/insert-result.js
var InsertResult = class {
  constructor(insertId, numInsertedOrUpdatedRows) {
    /**
     * The auto incrementing primary key of the inserted row.
     *
     * This property can be undefined when the query contains an `on conflict`
     * clause that makes the query succeed even when nothing gets inserted.
     *
     * This property is always undefined on dialects like PostgreSQL that
     * don't return the inserted id by default. On those dialects you need
     * to use the {@link ReturningInterface.returning | returning} method.
     */
    __publicField(this, "insertId");
    /**
     * Affected rows count.
     */
    __publicField(this, "numInsertedOrUpdatedRows");
    this.insertId = insertId;
    this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/no-result-error.js
var NoResultError = class extends Error {
  constructor(node) {
    super("no result");
    /**
     * The operation node tree of the query that was executed.
     */
    __publicField(this, "node");
    this.node = node;
  }
};
function isNoResultErrorConstructor(fn) {
  return Object.prototype.hasOwnProperty.call(fn, "prototype");
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/on-conflict-node.js
var OnConflictNode = freeze({
  is(node) {
    return node.kind === "OnConflictNode";
  },
  create() {
    return freeze({
      kind: "OnConflictNode"
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithIndexWhere(node, operation) {
    return freeze({
      ...node,
      indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithIndexOrWhere(node, operation) {
    return freeze({
      ...node,
      indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateWhere(node, operation) {
    return freeze({
      ...node,
      updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateOrWhere(node, operation) {
    return freeze({
      ...node,
      updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithoutIndexWhere(node) {
    return freeze({
      ...node,
      indexWhere: void 0
    });
  },
  cloneWithoutUpdateWhere(node) {
    return freeze({
      ...node,
      updateWhere: void 0
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/on-conflict-builder.js
var _props3;
var _OnConflictBuilder = class _OnConflictBuilder {
  constructor(props) {
    __privateAdd(this, _props3);
    __privateSet(this, _props3, freeze(props));
  }
  /**
   * Specify a single column as the conflict target.
   *
   * Also see the {@link columns}, {@link constraint} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  column(column) {
    const columnNode = ColumnNode.create(column);
    return new _OnConflictBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWith(__privateGet(this, _props3).onConflictNode, {
        columns: __privateGet(this, _props3).onConflictNode.columns ? freeze([...__privateGet(this, _props3).onConflictNode.columns, columnNode]) : freeze([columnNode])
      })
    });
  }
  /**
   * Specify a list of columns as the conflict target.
   *
   * Also see the {@link column}, {@link constraint} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  columns(columns) {
    const columnNodes = columns.map(ColumnNode.create);
    return new _OnConflictBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWith(__privateGet(this, _props3).onConflictNode, {
        columns: __privateGet(this, _props3).onConflictNode.columns ? freeze([...__privateGet(this, _props3).onConflictNode.columns, ...columnNodes]) : freeze(columnNodes)
      })
    });
  }
  /**
   * Specify a specific constraint by name as the conflict target.
   *
   * Also see the {@link column}, {@link columns} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  constraint(constraintName) {
    return new _OnConflictBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWith(__privateGet(this, _props3).onConflictNode, {
        constraint: IdentifierNode.create(constraintName)
      })
    });
  }
  /**
   * Specify an expression as the conflict target.
   *
   * This can be used if the unique index is an expression index.
   *
   * Also see the {@link column}, {@link columns} and {@link constraint}
   * methods for alternative ways to specify the conflict target.
   */
  expression(expression) {
    return new _OnConflictBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWith(__privateGet(this, _props3).onConflictNode, {
        indexExpression: expression.toOperationNode()
      })
    });
  }
  where(...args) {
    return new _OnConflictBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWithIndexWhere(__privateGet(this, _props3).onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new _OnConflictBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWithIndexWhere(__privateGet(this, _props3).onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new _OnConflictBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWithoutIndexWhere(__privateGet(this, _props3).onConflictNode)
    });
  }
  /**
   * Adds the "do nothing" conflict action.
   *
   * ### Examples
   *
   * ```ts
   * const id = 1
   * const first_name = 'John'
   *
   * await db
   *   .insertInto('person')
   *   .values({ first_name, id })
   *   .onConflict((oc) => oc
   *     .column('id')
   *     .doNothing()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "id")
   * values ($1, $2)
   * on conflict ("id") do nothing
   * ```
   */
  doNothing() {
    return new OnConflictDoNothingBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWith(__privateGet(this, _props3).onConflictNode, {
        doNothing: true
      })
    });
  }
  /**
   * Adds the "do update set" conflict action.
   *
   * ### Examples
   *
   * ```ts
   * const id = 1
   * const first_name = 'John'
   *
   * await db
   *   .insertInto('person')
   *   .values({ first_name, id })
   *   .onConflict((oc) => oc
   *     .column('id')
   *     .doUpdateSet({ first_name })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "id")
   * values ($1, $2)
   * on conflict ("id")
   * do update set "first_name" = $3
   * ```
   *
   * In the next example we use the `ref` method to reference
   * columns of the virtual table `excluded` in a type-safe way
   * to create an upsert operation:
   *
   * ```ts
   * import type { NewPerson } from 'type-editor' // imaginary module
   *
   * async function upsertPerson(person: NewPerson): Promise<void> {
   *   await db.insertInto('person')
   *     .values(person)
   *     .onConflict((oc) => oc
   *       .column('id')
   *       .doUpdateSet((eb) => ({
   *         first_name: eb.ref('excluded.first_name'),
   *         last_name: eb.ref('excluded.last_name')
   *       })
   *     )
   *   )
   *   .execute()
   * }
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name")
   * values ($1, $2)
   * on conflict ("id")
   * do update set
   *  "first_name" = excluded."first_name",
   *  "last_name" = excluded."last_name"
   * ```
   */
  doUpdateSet(update) {
    return new OnConflictUpdateBuilder({
      ...__privateGet(this, _props3),
      onConflictNode: OnConflictNode.cloneWith(__privateGet(this, _props3).onConflictNode, {
        updates: parseUpdateObjectExpression(update)
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
};
_props3 = new WeakMap();
var OnConflictBuilder = _OnConflictBuilder;
preventAwait(OnConflictBuilder, "don't await OnConflictBuilder instances.");
var _props4;
var OnConflictDoNothingBuilder = class {
  constructor(props) {
    __privateAdd(this, _props4);
    __privateSet(this, _props4, freeze(props));
  }
  toOperationNode() {
    return __privateGet(this, _props4).onConflictNode;
  }
};
_props4 = new WeakMap();
preventAwait(OnConflictDoNothingBuilder, "don't await OnConflictDoNothingBuilder instances.");
var _props5;
var _OnConflictUpdateBuilder = class _OnConflictUpdateBuilder {
  constructor(props) {
    __privateAdd(this, _props5);
    __privateSet(this, _props5, freeze(props));
  }
  where(...args) {
    return new _OnConflictUpdateBuilder({
      ...__privateGet(this, _props5),
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(__privateGet(this, _props5).onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Specify a where condition for the update operation.
   *
   * See {@link WhereInterface.whereRef} for more info.
   */
  whereRef(lhs, op, rhs) {
    return new _OnConflictUpdateBuilder({
      ...__privateGet(this, _props5),
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(__privateGet(this, _props5).onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new _OnConflictUpdateBuilder({
      ...__privateGet(this, _props5),
      onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(__privateGet(this, _props5).onConflictNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props5).onConflictNode;
  }
};
_props5 = new WeakMap();
var OnConflictUpdateBuilder = _OnConflictUpdateBuilder;
preventAwait(OnConflictUpdateBuilder, "don't await OnConflictUpdateBuilder instances.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/top-node.js
var TopNode = freeze({
  is(node) {
    return node.kind === "TopNode";
  },
  create(expression, modifiers) {
    return freeze({
      kind: "TopNode",
      expression,
      modifiers
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/top-parser.js
function parseTop(expression, modifiers) {
  if (!isNumber(expression) && !isBigInt(expression)) {
    throw new Error(`Invalid top expression: ${expression}`);
  }
  if (!isUndefined(modifiers) && !isTopModifiers(modifiers)) {
    throw new Error(`Invalid top modifiers: ${modifiers}`);
  }
  return TopNode.create(expression, modifiers);
}
function isTopModifiers(modifiers) {
  return modifiers === "percent" || modifiers === "with ties" || modifiers === "percent with ties";
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/insert-query-builder.js
var _props6;
var _InsertQueryBuilder = class _InsertQueryBuilder {
  constructor(props) {
    __privateAdd(this, _props6);
    __privateSet(this, _props6, freeze(props));
  }
  /**
   * Sets the values to insert for an {@link Kysely.insertInto | insert} query.
   *
   * This method takes an object whose keys are column names and values are
   * values to insert. In addition to the column's type, the values can be
   * raw {@link sql} snippets or select queries.
   *
   * You must provide all fields you haven't explicitly marked as nullable
   * or optional using {@link Generated} or {@link ColumnType}.
   *
   * The return value of an `insert` query is an instance of {@link InsertResult}. The
   * {@link InsertResult.insertId | insertId} field holds the auto incremented primary
   * key if the database returned one.
   *
   * On PostgreSQL and some other dialects, you need to call `returning` to get
   * something out of the query.
   *
   * Also see the {@link expression} method for inserting the result of a select
   * query or any other expression.
   *
   * ### Examples
   *
   * <!-- siteExample("insert", "Single row", 10) -->
   *
   * Insert a single row:
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40
   *   })
   *   .executeTakeFirst()
   *
   * // `insertId` is only available on dialects that
   * // automatically return the id of the inserted row
   * // such as MySQL and SQLite. On PostgreSQL, for example,
   * // you need to add a `returning` clause to the query to
   * // get anything out. See the "returning data" example.
   * console.log(result.insertId)
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` (`first_name`, `last_name`, `age`) values (?, ?, ?)
   * ```
   *
   * <!-- siteExample("insert", "Multiple rows", 20) -->
   *
   * On dialects that support it (for example PostgreSQL) you can insert multiple
   * rows by providing an array. Note that the return value is once again very
   * dialect-specific. Some databases may only return the id of the *last* inserted
   * row and some return nothing at all unless you call `returning`.
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values([{
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40,
   *   }, {
   *     first_name: 'Arnold',
   *     last_name: 'Schwarzenegger',
   *     age: 70,
   *   }])
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age") values (($1, $2, $3), ($4, $5, $6))
   * ```
   *
   * <!-- siteExample("insert", "Returning data", 30) -->
   *
   * On supported dialects like PostgreSQL you need to chain `returning` to the query to get
   * the inserted row's columns (or any other expression) as the return value. `returning`
   * works just like `select`. Refer to `select` method's examples and documentation for
   * more info.
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40,
   *   })
   *   .returning(['id', 'first_name as name'])
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age") values ($1, $2, $3) returning "id", "first_name" as "name"
   * ```
   *
   * <!-- siteExample("insert", "Complex values", 40) -->
   *
   * In addition to primitives, the values can also be arbitrary expressions.
   * You can build the expressions by using a callback and calling the methods
   * on the expression builder passed to it:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const ani = "Ani"
   * const ston = "ston"
   *
   * const result = await db
   *   .insertInto('person')
   *   .values(({ ref, selectFrom, fn }) => ({
   *     first_name: 'Jennifer',
   *     last_name: sql<string>`concat(${ani}, ${ston})`,
   *     middle_name: ref('first_name'),
   *     age: selectFrom('person')
   *       .select(fn.avg<number>('age').as('avg_age')),
   *   }))
   *   .executeTakeFirst()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" (
   *   "first_name",
   *   "last_name",
   *   "middle_name",
   *   "age"
   * )
   * values (
   *   $1,
   *   concat($2, $3),
   *   "first_name",
   *   (select avg("age") as "avg_age" from "person")
   * )
   * ```
   *
   * You can also use the callback version of subqueries or raw expressions:
   *
   * ```ts
   * await db.with('jennifer', (db) => db
   *   .selectFrom('person')
   *   .where('first_name', '=', 'Jennifer')
   *   .select(['id', 'first_name', 'gender'])
   *   .limit(1)
   * ).insertInto('pet').values((eb) => ({
   *   owner_id: eb.selectFrom('jennifer').select('id'),
   *   name: eb.selectFrom('jennifer').select('first_name'),
   *   species: 'cat',
   * }))
   * .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * with "jennifer" as (
   *   select "id", "first_name", "gender"
   *   from "person"
   *   where "first_name" = $1
   *   limit $2
   * )
   * insert into "pet" ("owner_id", "name", "species")
   * values (
   *  (select "id" from "jennifer"),
   *  (select "first_name" from "jennifer"),
   *  $3
   * )
   * ```
   */
  values(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: InsertQueryNode.cloneWith(__privateGet(this, _props6).queryNode, {
        columns,
        values
      })
    });
  }
  /**
   * Sets the columns to insert.
   *
   * The {@link values} method sets both the columns and the values and this method
   * is not needed. But if you are using the {@link expression} method, you can use
   * this method to set the columns to insert.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .columns(['first_name'])
   *   .expression((eb) => eb.selectFrom('pet').select('pet.name'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name")
   * select "pet"."name" from "pet"
   * ```
   */
  columns(columns) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: InsertQueryNode.cloneWith(__privateGet(this, _props6).queryNode, {
        columns: freeze(columns.map(ColumnNode.create))
      })
    });
  }
  /**
   * Insert an arbitrary expression. For example the result of a select query.
   *
   * ### Examples
   *
   * <!-- siteExample("insert", "Insert subquery", 50) -->
   *
   * You can create an `INSERT INTO SELECT FROM` query using the `expression` method.
   * This API doesn't follow our WYSIWYG principles and might be a bit difficult to
   * remember. The reasons for this design stem from implementation difficulties.
   *
   * ```ts
   * const result = await db.insertInto('person')
   *   .columns(['first_name', 'last_name', 'age'])
   *   .expression((eb) => eb
   *     .selectFrom('pet')
   *     .select((eb) => [
   *       'pet.name',
   *       eb.val('Petson').as('last_name'),
   *       eb.lit(7).as('age'),
   *     ])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age")
   * select "pet"."name", $1 as "last_name", 7 as "age from "pet"
   * ```
   */
  expression(expression) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: InsertQueryNode.cloneWith(__privateGet(this, _props6).queryNode, {
        values: parseExpression(expression)
      })
    });
  }
  /**
   * Creates an `insert into "person" default values` query.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .defaultValues()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" default values
   * ```
   */
  defaultValues() {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: InsertQueryNode.cloneWith(__privateGet(this, _props6).queryNode, {
        defaultValues: true
      })
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .modifyEnd(sql`-- This is a comment`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` ("first_name", "last_name", "gender")
   * values (?, ?, ?) -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props6).queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Changes an `insert into` query to an `insert ignore into` query.
   *
   * If you use the ignore modifier, ignorable errors that occur while executing the
   * insert statement are ignored. For example, without ignore, a row that duplicates
   * an existing unique index or primary key value in the table causes a duplicate-key
   * error and the statement is aborted. With ignore, the row is discarded and no error
   * occurs.
   *
   * This is only supported on some dialects like MySQL. On most dialects you should
   * use the {@link onConflict} method.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .ignore()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert ignore into `person` ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  ignore() {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: InsertQueryNode.cloneWith(__privateGet(this, _props6).queryNode, {
        ignore: true
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert top into` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Insert the first 5 rows:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .top(5)
   *   .columns(['first_name', 'gender'])
   *   .expression(
   *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * insert top(5) into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
   * ```
   *
   * Insert the first 50 percent of rows:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .top(50, 'percent')
   *   .columns(['first_name', 'gender'])
   *   .expression(
   *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * insert top(50) percent into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
   * ```
   */
  top(expression, modifiers) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: QueryNode.cloneWithTop(__privateGet(this, _props6).queryNode, parseTop(expression, modifiers))
    });
  }
  /**
   * Adds an `on conflict` clause to the query.
   *
   * `on conflict` is only supported by some dialects like PostgreSQL and SQLite. On MySQL
   * you can use {@link ignore} and {@link onDuplicateKeyUpdate} to achieve similar results.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name")
   * do update set "species" = $4
   * ```
   *
   * You can provide the name of the constraint instead of a column name:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .constraint('pet_name_key')
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict on constraint "pet_name_key"
   * do update set "species" = $4
   * ```
   *
   * You can also specify an expression as the conflict target in case
   * the unique index is an expression index:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .expression(sql<string>`lower(name)`)
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict (lower(name))
   * do update set "species" = $4
   * ```
   *
   * You can add a filter for the update statement like this:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doUpdateSet({ species: 'hamster' })
   *     .where('excluded.name', '!=', 'Catto')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name")
   * do update set "species" = $4
   * where "excluded"."name" != $5
   * ```
   *
   * You can create an `on conflict do nothing` clauses like this:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doNothing()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name") do nothing
   * ```
   *
   * You can refer to the columns of the virtual `excluded` table
   * in a type-safe way using a callback and the `ref` method of
   * `ExpressionBuilder`:
   *
   * ```ts
   * await db.insertInto('person')
   *   .values({
   *     id: 1,
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .onConflict(oc => oc
   *     .column('id')
   *     .doUpdateSet({
   *       first_name: (eb) => eb.ref('excluded.first_name'),
   *       last_name: (eb) => eb.ref('excluded.last_name')
   *     })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("id", "first_name", "last_name", "gender")
   * values ($1, $2, $3, $4)
   * on conflict ("id")
   * do update set
   *  "first_name" = "excluded"."first_name",
   *  "last_name" = "excluded"."last_name"
   * ```
   */
  onConflict(callback) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: InsertQueryNode.cloneWith(__privateGet(this, _props6).queryNode, {
        onConflict: callback(new OnConflictBuilder({
          onConflictNode: OnConflictNode.create()
        })).toOperationNode()
      })
    });
  }
  /**
   * Adds `on duplicate key update` to the query.
   *
   * If you specify `on duplicate key update`, and a row is inserted that would cause
   * a duplicate value in a unique index or primary key, an update of the old row occurs.
   *
   * This is only implemented by some dialects like MySQL. On most dialects you should
   * use {@link onConflict} instead.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values({
   *     id: 1,
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .onDuplicateKeyUpdate({ updated_at: new Date().toISOString() })
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` (`id`, `first_name`, `last_name`, `gender`)
   * values (?, ?, ?, ?)
   * on duplicate key update `updated_at` = ?
   * ```
   */
  onDuplicateKeyUpdate(update) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: InsertQueryNode.cloneWith(__privateGet(this, _props6).queryNode, {
        onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update))
      })
    });
  }
  returning(selection) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: QueryNode.cloneWithReturning(__privateGet(this, _props6).queryNode, parseSelectArg(selection))
    });
  }
  returningAll() {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: QueryNode.cloneWithReturning(__privateGet(this, _props6).queryNode, parseSelectAll())
    });
  }
  output(args) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props6).queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props6).queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .values({ first_name: 'James', last_name: 'Smith', gender: 'male' })
   *   .returning(['first_name'])
   *   .clearReturning()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "gender") values ($1, $2, $3)
   * ```
   */
  clearReturning() {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: QueryNode.cloneWithoutReturning(__privateGet(this, _props6).queryNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.insertInto('person')
   *   .values({ first_name: 'John', last_name: 'Doe', gender: 'male' })
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { NewPerson } from 'type-editor' // imaginary module
   *
   * async function insertPerson(values: NewPerson, returnLastName: boolean) {
   *   return await db
   *     .insertInto('person')
   *     .values(values)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `insertPerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6)
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `InsertQueryBuilder` with a new output type.
   */
  $castTo() {
    return new _InsertQueryBuilder(__privateGet(this, _props6));
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query based on {@link values} input
   * when using {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const person = await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *     nullable_column: 'hell yeah!'
   *   })
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const person = await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *     nullable_column: 'hell yeah!'
   *   })
   *   .returningAll()
   *   .$narrowType<{ nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new _InsertQueryBuilder(__privateGet(this, _props6));
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { NewPerson, NewPet, Species } from 'type-editor' // imaginary module
   *
   * async function insertPersonAndPet(person: NewPerson, pet: Omit<NewPet, 'owner_id'>) {
   *   return await db
   *     .with('new_person', (qb) => qb
   *       .insertInto('person')
   *       .values(person)
   *       .returning('id')
   *       .$assertType<{ id: number }>()
   *     )
   *     .with('new_pet', (qb) => qb
   *       .insertInto('pet')
   *       .values((eb) => ({
   *         owner_id: eb.selectFrom('new_person').select('id'),
   *         ...pet
   *       }))
   *       .returning(['name as pet_name', 'species'])
   *       .$assertType<{ pet_name: string, species: Species }>()
   *     )
   *     .selectFrom(['new_person', 'new_pet'])
   *     .selectAll()
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   */
  $assertType() {
    return new _InsertQueryBuilder(__privateGet(this, _props6));
  }
  /**
   * Returns a copy of this InsertQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      executor: __privateGet(this, _props6).executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return __privateGet(this, _props6).executor.transformQuery(__privateGet(this, _props6).queryNode, __privateGet(this, _props6).queryId);
  }
  compile() {
    return __privateGet(this, _props6).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props6).queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    var _a;
    const compiledQuery = this.compile();
    const result = await __privateGet(this, _props6).executor.executeQuery(compiledQuery, __privateGet(this, _props6).queryId);
    const { adapter } = __privateGet(this, _props6).executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new InsertResult(
        result.insertId,
        // TODO: remove numUpdatedOrDeletedRows.
        (_a = result.numAffectedRows) != null ? _a : result.numUpdatedOrDeletedRows
      )
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = __privateGet(this, _props6).executor.stream(compiledQuery, chunkSize, __privateGet(this, _props6).queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new _InsertQueryBuilder({
      ...__privateGet(this, _props6),
      queryNode: QueryNode.cloneWithExplain(__privateGet(this, _props6).queryNode, format, options)
    });
    return await builder.execute();
  }
};
_props6 = new WeakMap();
var InsertQueryBuilder = _InsertQueryBuilder;
preventAwait(InsertQueryBuilder, "don't await InsertQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/delete-result.js
var DeleteResult = class {
  constructor(numDeletedRows) {
    __publicField(this, "numDeletedRows");
    this.numDeletedRows = numDeletedRows;
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/limit-node.js
var LimitNode = freeze({
  is(node) {
    return node.kind === "LimitNode";
  },
  create(limit) {
    return freeze({
      kind: "LimitNode",
      limit
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/delete-query-builder.js
var _props7;
var _DeleteQueryBuilder = class _DeleteQueryBuilder {
  constructor(props) {
    __privateAdd(this, _props7);
    __privateSet(this, _props7, freeze(props));
  }
  where(...args) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithWhere(__privateGet(this, _props7).queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithWhere(__privateGet(this, _props7).queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithoutWhere(__privateGet(this, _props7).queryNode)
    });
  }
  /**
   * Changes a `delete from` query into a `delete top from` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Delete the first 5 rows:
   *
   * ```ts
   * await db
   *   .deleteFrom('person')
   *   .top(5)
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * delete top(5) from "person" where "age" > @1
   * ```
   *
   * Delete the first 50% of rows:
   *
   * ```ts
   * await db
   *   .deleteFrom('person')
   *   .top(50, 'percent')
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * delete top(50) percent from "person" where "age" > @1
   * ```
   */
  top(expression, modifiers) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithTop(__privateGet(this, _props7).queryNode, parseTop(expression, modifiers))
    });
  }
  using(tables) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: DeleteQueryNode.cloneWithUsing(__privateGet(this, _props7).queryNode, parseTableExpressionOrList(tables))
    });
  }
  innerJoin(...args) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props7).queryNode, parseJoin("InnerJoin", args))
    });
  }
  leftJoin(...args) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props7).queryNode, parseJoin("LeftJoin", args))
    });
  }
  rightJoin(...args) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props7).queryNode, parseJoin("RightJoin", args))
    });
  }
  fullJoin(...args) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props7).queryNode, parseJoin("FullJoin", args))
    });
  }
  returning(selection) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithReturning(__privateGet(this, _props7).queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithReturning(__privateGet(this, _props7).queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props7).queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props7).queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .clearReturning()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max"
   * ```
   */
  clearReturning() {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithoutReturning(__privateGet(this, _props7).queryNode)
    });
  }
  /**
   * Clears the `limit` clause from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .limit(5)
   *   .clearLimit()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max" returning *
   * ```
   */
  clearLimit() {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: DeleteQueryNode.cloneWithoutLimit(__privateGet(this, _props7).queryNode)
    });
  }
  /**
   * Clears the `order by` clause from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .orderBy('id')
   *   .clearOrderBy()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max" returning *
   * ```
   */
  clearOrderBy() {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: DeleteQueryNode.cloneWithoutOrderBy(__privateGet(this, _props7).queryNode)
    });
  }
  /**
   * Adds an `order by` clause to the query.
   *
   * `orderBy` calls are additive. To order by multiple columns, call `orderBy`
   * multiple times.
   *
   * The first argument is the expression to order by and the second is the
   * order (`asc` or `desc`).
   *
   * An `order by` clause in a delete query is only supported by some dialects
   * like MySQL.
   *
   * See {@link SelectQueryBuilder.orderBy} for more examples.
   *
   * ### Examples
   *
   * Delete 5 oldest items in a table:
   *
   * ```ts
   * await db
   *   .deleteFrom('pet')
   *   .orderBy('created_at')
   *   .limit(5)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `pet`
   * order by `created_at`
   * limit ?
   * ```
   */
  orderBy(orderBy, direction) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: DeleteQueryNode.cloneWithOrderByItems(__privateGet(this, _props7).queryNode, parseOrderBy([orderBy, direction]))
    });
  }
  /**
   * Adds a limit clause to the query.
   *
   * A limit clause in a delete query is only supported by some dialects
   * like MySQL.
   *
   * ### Examples
   *
   * Delete 5 oldest items in a table:
   *
   * ```ts
   * await db
   *   .deleteFrom('pet')
   *   .orderBy('created_at')
   *   .limit(5)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `pet` order by `created_at` limit ?
   * ```
   */
  limit(limit) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: DeleteQueryNode.cloneWithLimit(__privateGet(this, _props7).queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.deleteFrom('person')
   *   .where('first_name', '=', 'John')
   *   .modifyEnd(sql`-- This is a comment`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `person`
   * where `first_name` = "John" -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props7).queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.deleteFrom('person')
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * async function deletePerson(id: number, returnLastName: boolean) {
   *   return await db
   *     .deleteFrom('person')
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `deletePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7)
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `DeleteQueryBuilder` with a new output type.
   */
  $castTo() {
    return new _DeleteQueryBuilder(__privateGet(this, _props7));
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query when using {@link where} and {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const person = await db.deleteFrom('person')
   *   .where('id', '=', 3)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const person = await db.deleteFrom('person')
   *   .where('id', '=', 3)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .$narrowType<{ nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new _DeleteQueryBuilder(__privateGet(this, _props7));
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { Species } from 'type-editor' // imaginary module
   *
   * async function deletePersonAndPets(personId: number) {
   *   return await db
   *     .with('deleted_person', (qb) => qb
   *        .deleteFrom('person')
   *        .where('id', '=', personId)
   *        .returning('first_name')
   *        .$assertType<{ first_name: string }>()
   *     )
   *     .with('deleted_pets', (qb) => qb
   *       .deleteFrom('pet')
   *       .where('owner_id', '=', personId)
   *       .returning(['name as pet_name', 'species'])
   *       .$assertType<{ pet_name: string, species: Species }>()
   *     )
   *     .selectFrom(['deleted_person', 'deleted_pets'])
   *     .selectAll()
   *     .execute()
   * }
   * ```
   */
  $assertType() {
    return new _DeleteQueryBuilder(__privateGet(this, _props7));
  }
  /**
   * Returns a copy of this DeleteQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      executor: __privateGet(this, _props7).executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return __privateGet(this, _props7).executor.transformQuery(__privateGet(this, _props7).queryNode, __privateGet(this, _props7).queryId);
  }
  compile() {
    return __privateGet(this, _props7).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props7).queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    var _a, _b;
    const compiledQuery = this.compile();
    const result = await __privateGet(this, _props7).executor.executeQuery(compiledQuery, __privateGet(this, _props7).queryId);
    const { adapter } = __privateGet(this, _props7).executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new DeleteResult(
        // TODO: remove numUpdatedOrDeletedRows.
        (_b = (_a = result.numAffectedRows) != null ? _a : result.numUpdatedOrDeletedRows) != null ? _b : BigInt(0)
      )
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = __privateGet(this, _props7).executor.stream(compiledQuery, chunkSize, __privateGet(this, _props7).queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new _DeleteQueryBuilder({
      ...__privateGet(this, _props7),
      queryNode: QueryNode.cloneWithExplain(__privateGet(this, _props7).queryNode, format, options)
    });
    return await builder.execute();
  }
};
_props7 = new WeakMap();
var DeleteQueryBuilder = _DeleteQueryBuilder;
preventAwait(DeleteQueryBuilder, "don't await DeleteQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/update-result.js
var UpdateResult = class {
  constructor(numUpdatedRows, numChangedRows) {
    /**
     * The number of rows the update query updated (even if not changed).
     */
    __publicField(this, "numUpdatedRows");
    /**
     * The number of rows the update query changed.
     *
     * This is **optional** and only supported in dialects such as MySQL.
     * You would probably use {@link numUpdatedRows} in most cases.
     */
    __publicField(this, "numChangedRows");
    this.numUpdatedRows = numUpdatedRows;
    this.numChangedRows = numChangedRows;
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/update-query-builder.js
var _props8;
var _UpdateQueryBuilder = class _UpdateQueryBuilder {
  constructor(props) {
    __privateAdd(this, _props8);
    __privateSet(this, _props8, freeze(props));
  }
  where(...args) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithWhere(__privateGet(this, _props8).queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithWhere(__privateGet(this, _props8).queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithoutWhere(__privateGet(this, _props8).queryNode)
    });
  }
  /**
   * Changes an `update` query into a `update top` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Update the first row:
   *
   * ```ts
   * await db.updateTable('person')
   *   .top(1)
   *   .set({ first_name: 'Foo' })
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * update top(1) "person" set "first_name" = @1 where "age" > @2
   * ```
   *
   * Update the 50% first rows:
   *
   * ```ts
   * await db.updateTable('person')
   *   .top(50, 'percent')
   *   .set({ first_name: 'Foo' })
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * update top(50) percent "person" set "first_name" = @1 where "age" > @2
   * ```
   */
  top(expression, modifiers) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithTop(__privateGet(this, _props8).queryNode, parseTop(expression, modifiers))
    });
  }
  from(from) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: UpdateQueryNode.cloneWithFromItems(__privateGet(this, _props8).queryNode, parseTableExpressionOrList(from))
    });
  }
  innerJoin(...args) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props8).queryNode, parseJoin("InnerJoin", args))
    });
  }
  leftJoin(...args) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props8).queryNode, parseJoin("LeftJoin", args))
    });
  }
  rightJoin(...args) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props8).queryNode, parseJoin("RightJoin", args))
    });
  }
  fullJoin(...args) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props8).queryNode, parseJoin("FullJoin", args))
    });
  }
  /**
   * Adds a limit clause to the update query for supported databases, such as MySQL.
   *
   * ### Examples
   *
   * Update the first 2 rows in the 'person' table:
   *
   * ```ts
   * await db
   *   .updateTable('person')
   *   .set({ first_name: 'Foo' })
   *   .limit(2)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * update `person` set `first_name` = ? limit ?
   * ```
   */
  limit(limit) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: UpdateQueryNode.cloneWithLimit(__privateGet(this, _props8).queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  set(...args) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: UpdateQueryNode.cloneWithUpdates(__privateGet(this, _props8).queryNode, parseUpdate(...args))
    });
  }
  returning(selection) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithReturning(__privateGet(this, _props8).queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithReturning(__privateGet(this, _props8).queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props8).queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props8).queryNode, parseSelectAll(table))
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.updateTable('person')
   *   .set({ age: 39 })
   *   .where('first_name', '=', 'John')
   *   .modifyEnd(sql.raw('-- This is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * update `person`
   * set `age` = 39
   * where `first_name` = "John" -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props8).queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * db.updateTable('person')
   *   .returningAll()
   *   .set({ age: 39 })
   *   .where('first_name', '=', 'John')
   *   .clearReturning()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * update "person" set "age" = 39 where "first_name" = "John"
   * ```
   */
  clearReturning() {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithoutReturning(__privateGet(this, _props8).queryNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * const values = {
   *   first_name: 'John',
   * } satisfies PersonUpdate
   *
   * db.updateTable('person')
   *   .set(values)
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {
   *   return await db
   *     .updateTable('person')
   *     .set(updates)
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `updatePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8)
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `UpdateQueryBuilder` with a new output type.
   */
  $castTo() {
    return new _UpdateQueryBuilder(__privateGet(this, _props8));
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query based on {@link set} input
   * when using {@link where} and/or {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const id = 1
   * const now = new Date().toISOString()
   *
   * const person = await db.updateTable('person')
   *   .set({ deleted_at: now })
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const id = 1
   * const now = new Date().toISOString()
   *
   * const person = await db.updateTable('person')
   *   .set({ deleted_at: now })
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .$narrowType<{ deleted_at: Date; nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new _UpdateQueryBuilder(__privateGet(this, _props8));
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate, PetUpdate, Species } from 'type-editor' // imaginary module
   *
   * const person = {
   *   id: 1,
   *   gender: 'other',
   * } satisfies PersonUpdate
   *
   * const pet = {
   *   name: 'Fluffy',
   * } satisfies PetUpdate
   *
   * const result = await db
   *   .with('updated_person', (qb) => qb
   *     .updateTable('person')
   *     .set(person)
   *     .where('id', '=', person.id)
   *     .returning('first_name')
   *     .$assertType<{ first_name: string }>()
   *   )
   *   .with('updated_pet', (qb) => qb
   *     .updateTable('pet')
   *     .set(pet)
   *     .where('owner_id', '=', person.id)
   *     .returning(['name as pet_name', 'species'])
   *     .$assertType<{ pet_name: string, species: Species }>()
   *   )
   *   .selectFrom(['updated_person', 'updated_pet'])
   *   .selectAll()
   *   .executeTakeFirstOrThrow()
   * ```
   */
  $assertType() {
    return new _UpdateQueryBuilder(__privateGet(this, _props8));
  }
  /**
   * Returns a copy of this UpdateQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      executor: __privateGet(this, _props8).executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return __privateGet(this, _props8).executor.transformQuery(__privateGet(this, _props8).queryNode, __privateGet(this, _props8).queryId);
  }
  compile() {
    return __privateGet(this, _props8).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props8).queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    var _a, _b;
    const compiledQuery = this.compile();
    const result = await __privateGet(this, _props8).executor.executeQuery(compiledQuery, __privateGet(this, _props8).queryId);
    const { adapter } = __privateGet(this, _props8).executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new UpdateResult(
        // TODO: remove numUpdatedOrDeletedRows.
        // TODO: https://github.com/kysely-org/kysely/pull/431#discussion_r1172330899
        (_b = (_a = result.numAffectedRows) != null ? _a : result.numUpdatedOrDeletedRows) != null ? _b : BigInt(0),
        result.numChangedRows
      )
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = __privateGet(this, _props8).executor.stream(compiledQuery, chunkSize, __privateGet(this, _props8).queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new _UpdateQueryBuilder({
      ...__privateGet(this, _props8),
      queryNode: QueryNode.cloneWithExplain(__privateGet(this, _props8).queryNode, format, options)
    });
    return await builder.execute();
  }
};
_props8 = new WeakMap();
var UpdateQueryBuilder = _UpdateQueryBuilder;
preventAwait(UpdateQueryBuilder, "don't await UpdateQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/common-table-expression-name-node.js
var CommonTableExpressionNameNode = freeze({
  is(node) {
    return node.kind === "CommonTableExpressionNameNode";
  },
  create(tableName, columnNames) {
    return freeze({
      kind: "CommonTableExpressionNameNode",
      table: TableNode.create(tableName),
      columns: columnNames ? freeze(columnNames.map(ColumnNode.create)) : void 0
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/common-table-expression-node.js
var CommonTableExpressionNode = freeze({
  is(node) {
    return node.kind === "CommonTableExpressionNode";
  },
  create(name, expression) {
    return freeze({
      kind: "CommonTableExpressionNode",
      name,
      expression
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/cte-builder.js
var _props9;
var _CTEBuilder = class _CTEBuilder {
  constructor(props) {
    __privateAdd(this, _props9);
    __privateSet(this, _props9, freeze(props));
  }
  /**
   * Makes the common table expression materialized.
   */
  materialized() {
    return new _CTEBuilder({
      ...__privateGet(this, _props9),
      node: CommonTableExpressionNode.cloneWith(__privateGet(this, _props9).node, {
        materialized: true
      })
    });
  }
  /**
   * Makes the common table expression not materialized.
   */
  notMaterialized() {
    return new _CTEBuilder({
      ...__privateGet(this, _props9),
      node: CommonTableExpressionNode.cloneWith(__privateGet(this, _props9).node, {
        materialized: false
      })
    });
  }
  toOperationNode() {
    return __privateGet(this, _props9).node;
  }
};
_props9 = new WeakMap();
var CTEBuilder = _CTEBuilder;
preventAwait(CTEBuilder, "don't await CTEBuilder instances. They are never executed directly and are always just a part of a query.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/with-parser.js
function parseCommonTableExpression(nameOrBuilderCallback, expression) {
  const expressionNode = expression(createQueryCreator()).toOperationNode();
  if (isFunction(nameOrBuilderCallback)) {
    return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();
  }
  return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);
}
function cteBuilderFactory(expressionNode) {
  return (name) => {
    return new CTEBuilder({
      node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name), expressionNode)
    });
  };
}
function parseCommonTableExpressionName(name) {
  if (name.includes("(")) {
    const parts = name.split(/[\(\)]/);
    const table = parts[0];
    const columns = parts[1].split(",").map((it) => it.trim());
    return CommonTableExpressionNameNode.create(table, columns);
  } else {
    return CommonTableExpressionNameNode.create(name);
  }
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/with-node.js
var WithNode = freeze({
  is(node) {
    return node.kind === "WithNode";
  },
  create(expression, params) {
    return freeze({
      kind: "WithNode",
      expressions: freeze([expression]),
      ...params
    });
  },
  cloneWithExpression(withNode, expression) {
    return freeze({
      ...withNode,
      expressions: freeze([...withNode.expressions, expression])
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/random-string.js
var CHARS = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9"
];
function randomString(length) {
  let chars = "";
  for (let i = 0; i < length; ++i) {
    chars += randomChar();
  }
  return chars;
}
function randomChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/query-id.js
function createQueryId() {
  return new LazyQueryId();
}
var _queryId;
var LazyQueryId = class {
  constructor() {
    __privateAdd(this, _queryId);
  }
  get queryId() {
    if (__privateGet(this, _queryId) === void 0) {
      __privateSet(this, _queryId, randomString(8));
    }
    return __privateGet(this, _queryId);
  }
};
_queryId = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/require-all-props.js
function requireAllProps(obj) {
  return obj;
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/operation-node-transformer.js
var _transformers;
var OperationNodeTransformer = class {
  constructor() {
    __publicField(this, "nodeStack", []);
    __privateAdd(this, _transformers, freeze({
      AliasNode: this.transformAlias.bind(this),
      ColumnNode: this.transformColumn.bind(this),
      IdentifierNode: this.transformIdentifier.bind(this),
      SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
      RawNode: this.transformRaw.bind(this),
      ReferenceNode: this.transformReference.bind(this),
      SelectQueryNode: this.transformSelectQuery.bind(this),
      SelectionNode: this.transformSelection.bind(this),
      TableNode: this.transformTable.bind(this),
      FromNode: this.transformFrom.bind(this),
      SelectAllNode: this.transformSelectAll.bind(this),
      AndNode: this.transformAnd.bind(this),
      OrNode: this.transformOr.bind(this),
      ValueNode: this.transformValue.bind(this),
      ValueListNode: this.transformValueList.bind(this),
      PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
      ParensNode: this.transformParens.bind(this),
      JoinNode: this.transformJoin.bind(this),
      OperatorNode: this.transformOperator.bind(this),
      WhereNode: this.transformWhere.bind(this),
      InsertQueryNode: this.transformInsertQuery.bind(this),
      DeleteQueryNode: this.transformDeleteQuery.bind(this),
      ReturningNode: this.transformReturning.bind(this),
      CreateTableNode: this.transformCreateTable.bind(this),
      AddColumnNode: this.transformAddColumn.bind(this),
      ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
      DropTableNode: this.transformDropTable.bind(this),
      DataTypeNode: this.transformDataType.bind(this),
      OrderByNode: this.transformOrderBy.bind(this),
      OrderByItemNode: this.transformOrderByItem.bind(this),
      GroupByNode: this.transformGroupBy.bind(this),
      GroupByItemNode: this.transformGroupByItem.bind(this),
      UpdateQueryNode: this.transformUpdateQuery.bind(this),
      ColumnUpdateNode: this.transformColumnUpdate.bind(this),
      LimitNode: this.transformLimit.bind(this),
      OffsetNode: this.transformOffset.bind(this),
      OnConflictNode: this.transformOnConflict.bind(this),
      OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
      CreateIndexNode: this.transformCreateIndex.bind(this),
      DropIndexNode: this.transformDropIndex.bind(this),
      ListNode: this.transformList.bind(this),
      PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
      UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
      ReferencesNode: this.transformReferences.bind(this),
      CheckConstraintNode: this.transformCheckConstraint.bind(this),
      WithNode: this.transformWith.bind(this),
      CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
      CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
      HavingNode: this.transformHaving.bind(this),
      CreateSchemaNode: this.transformCreateSchema.bind(this),
      DropSchemaNode: this.transformDropSchema.bind(this),
      AlterTableNode: this.transformAlterTable.bind(this),
      DropColumnNode: this.transformDropColumn.bind(this),
      RenameColumnNode: this.transformRenameColumn.bind(this),
      AlterColumnNode: this.transformAlterColumn.bind(this),
      ModifyColumnNode: this.transformModifyColumn.bind(this),
      AddConstraintNode: this.transformAddConstraint.bind(this),
      DropConstraintNode: this.transformDropConstraint.bind(this),
      ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
      CreateViewNode: this.transformCreateView.bind(this),
      DropViewNode: this.transformDropView.bind(this),
      GeneratedNode: this.transformGenerated.bind(this),
      DefaultValueNode: this.transformDefaultValue.bind(this),
      OnNode: this.transformOn.bind(this),
      ValuesNode: this.transformValues.bind(this),
      SelectModifierNode: this.transformSelectModifier.bind(this),
      CreateTypeNode: this.transformCreateType.bind(this),
      DropTypeNode: this.transformDropType.bind(this),
      ExplainNode: this.transformExplain.bind(this),
      DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
      AggregateFunctionNode: this.transformAggregateFunction.bind(this),
      OverNode: this.transformOver.bind(this),
      PartitionByNode: this.transformPartitionBy.bind(this),
      PartitionByItemNode: this.transformPartitionByItem.bind(this),
      SetOperationNode: this.transformSetOperation.bind(this),
      BinaryOperationNode: this.transformBinaryOperation.bind(this),
      UnaryOperationNode: this.transformUnaryOperation.bind(this),
      UsingNode: this.transformUsing.bind(this),
      FunctionNode: this.transformFunction.bind(this),
      CaseNode: this.transformCase.bind(this),
      WhenNode: this.transformWhen.bind(this),
      JSONReferenceNode: this.transformJSONReference.bind(this),
      JSONPathNode: this.transformJSONPath.bind(this),
      JSONPathLegNode: this.transformJSONPathLeg.bind(this),
      JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
      TupleNode: this.transformTuple.bind(this),
      MergeQueryNode: this.transformMergeQuery.bind(this),
      MatchedNode: this.transformMatched.bind(this),
      AddIndexNode: this.transformAddIndex.bind(this),
      CastNode: this.transformCast.bind(this),
      FetchNode: this.transformFetch.bind(this),
      TopNode: this.transformTop.bind(this),
      OutputNode: this.transformOutput.bind(this)
    }));
  }
  transformNode(node) {
    if (!node) {
      return node;
    }
    this.nodeStack.push(node);
    const out = this.transformNodeImpl(node);
    this.nodeStack.pop();
    return freeze(out);
  }
  transformNodeImpl(node) {
    return __privateGet(this, _transformers)[node.kind](node);
  }
  transformNodeList(list) {
    if (!list) {
      return list;
    }
    return freeze(list.map((node) => this.transformNode(node)));
  }
  transformSelectQuery(node) {
    return requireAllProps({
      kind: "SelectQueryNode",
      from: this.transformNode(node.from),
      selections: this.transformNodeList(node.selections),
      distinctOn: this.transformNodeList(node.distinctOn),
      joins: this.transformNodeList(node.joins),
      groupBy: this.transformNode(node.groupBy),
      orderBy: this.transformNode(node.orderBy),
      where: this.transformNode(node.where),
      frontModifiers: this.transformNodeList(node.frontModifiers),
      endModifiers: this.transformNodeList(node.endModifiers),
      limit: this.transformNode(node.limit),
      offset: this.transformNode(node.offset),
      with: this.transformNode(node.with),
      having: this.transformNode(node.having),
      explain: this.transformNode(node.explain),
      setOperations: this.transformNodeList(node.setOperations),
      fetch: this.transformNode(node.fetch),
      top: this.transformNode(node.top)
    });
  }
  transformSelection(node) {
    return requireAllProps({
      kind: "SelectionNode",
      selection: this.transformNode(node.selection)
    });
  }
  transformColumn(node) {
    return requireAllProps({
      kind: "ColumnNode",
      column: this.transformNode(node.column)
    });
  }
  transformAlias(node) {
    return requireAllProps({
      kind: "AliasNode",
      node: this.transformNode(node.node),
      alias: this.transformNode(node.alias)
    });
  }
  transformTable(node) {
    return requireAllProps({
      kind: "TableNode",
      table: this.transformNode(node.table)
    });
  }
  transformFrom(node) {
    return requireAllProps({
      kind: "FromNode",
      froms: this.transformNodeList(node.froms)
    });
  }
  transformReference(node) {
    return requireAllProps({
      kind: "ReferenceNode",
      column: this.transformNode(node.column),
      table: this.transformNode(node.table)
    });
  }
  transformAnd(node) {
    return requireAllProps({
      kind: "AndNode",
      left: this.transformNode(node.left),
      right: this.transformNode(node.right)
    });
  }
  transformOr(node) {
    return requireAllProps({
      kind: "OrNode",
      left: this.transformNode(node.left),
      right: this.transformNode(node.right)
    });
  }
  transformValueList(node) {
    return requireAllProps({
      kind: "ValueListNode",
      values: this.transformNodeList(node.values)
    });
  }
  transformParens(node) {
    return requireAllProps({
      kind: "ParensNode",
      node: this.transformNode(node.node)
    });
  }
  transformJoin(node) {
    return requireAllProps({
      kind: "JoinNode",
      joinType: node.joinType,
      table: this.transformNode(node.table),
      on: this.transformNode(node.on)
    });
  }
  transformRaw(node) {
    return requireAllProps({
      kind: "RawNode",
      sqlFragments: freeze([...node.sqlFragments]),
      parameters: this.transformNodeList(node.parameters)
    });
  }
  transformWhere(node) {
    return requireAllProps({
      kind: "WhereNode",
      where: this.transformNode(node.where)
    });
  }
  transformInsertQuery(node) {
    return requireAllProps({
      kind: "InsertQueryNode",
      into: this.transformNode(node.into),
      columns: this.transformNodeList(node.columns),
      values: this.transformNode(node.values),
      returning: this.transformNode(node.returning),
      onConflict: this.transformNode(node.onConflict),
      onDuplicateKey: this.transformNode(node.onDuplicateKey),
      endModifiers: this.transformNodeList(node.endModifiers),
      with: this.transformNode(node.with),
      ignore: node.ignore,
      replace: node.replace,
      explain: this.transformNode(node.explain),
      defaultValues: node.defaultValues,
      top: this.transformNode(node.top),
      output: this.transformNode(node.output)
    });
  }
  transformValues(node) {
    return requireAllProps({
      kind: "ValuesNode",
      values: this.transformNodeList(node.values)
    });
  }
  transformDeleteQuery(node) {
    return requireAllProps({
      kind: "DeleteQueryNode",
      from: this.transformNode(node.from),
      using: this.transformNode(node.using),
      joins: this.transformNodeList(node.joins),
      where: this.transformNode(node.where),
      returning: this.transformNode(node.returning),
      endModifiers: this.transformNodeList(node.endModifiers),
      with: this.transformNode(node.with),
      orderBy: this.transformNode(node.orderBy),
      limit: this.transformNode(node.limit),
      explain: this.transformNode(node.explain),
      top: this.transformNode(node.top),
      output: this.transformNode(node.output)
    });
  }
  transformReturning(node) {
    return requireAllProps({
      kind: "ReturningNode",
      selections: this.transformNodeList(node.selections)
    });
  }
  transformCreateTable(node) {
    return requireAllProps({
      kind: "CreateTableNode",
      table: this.transformNode(node.table),
      columns: this.transformNodeList(node.columns),
      constraints: this.transformNodeList(node.constraints),
      temporary: node.temporary,
      ifNotExists: node.ifNotExists,
      onCommit: node.onCommit,
      frontModifiers: this.transformNodeList(node.frontModifiers),
      endModifiers: this.transformNodeList(node.endModifiers),
      selectQuery: this.transformNode(node.selectQuery)
    });
  }
  transformColumnDefinition(node) {
    return requireAllProps({
      kind: "ColumnDefinitionNode",
      column: this.transformNode(node.column),
      dataType: this.transformNode(node.dataType),
      references: this.transformNode(node.references),
      primaryKey: node.primaryKey,
      autoIncrement: node.autoIncrement,
      unique: node.unique,
      notNull: node.notNull,
      unsigned: node.unsigned,
      defaultTo: this.transformNode(node.defaultTo),
      check: this.transformNode(node.check),
      generated: this.transformNode(node.generated),
      frontModifiers: this.transformNodeList(node.frontModifiers),
      endModifiers: this.transformNodeList(node.endModifiers),
      nullsNotDistinct: node.nullsNotDistinct,
      identity: node.identity,
      ifNotExists: node.ifNotExists
    });
  }
  transformAddColumn(node) {
    return requireAllProps({
      kind: "AddColumnNode",
      column: this.transformNode(node.column)
    });
  }
  transformDropTable(node) {
    return requireAllProps({
      kind: "DropTableNode",
      table: this.transformNode(node.table),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformOrderBy(node) {
    return requireAllProps({
      kind: "OrderByNode",
      items: this.transformNodeList(node.items)
    });
  }
  transformOrderByItem(node) {
    return requireAllProps({
      kind: "OrderByItemNode",
      orderBy: this.transformNode(node.orderBy),
      direction: this.transformNode(node.direction)
    });
  }
  transformGroupBy(node) {
    return requireAllProps({
      kind: "GroupByNode",
      items: this.transformNodeList(node.items)
    });
  }
  transformGroupByItem(node) {
    return requireAllProps({
      kind: "GroupByItemNode",
      groupBy: this.transformNode(node.groupBy)
    });
  }
  transformUpdateQuery(node) {
    return requireAllProps({
      kind: "UpdateQueryNode",
      table: this.transformNode(node.table),
      from: this.transformNode(node.from),
      joins: this.transformNodeList(node.joins),
      where: this.transformNode(node.where),
      updates: this.transformNodeList(node.updates),
      returning: this.transformNode(node.returning),
      endModifiers: this.transformNodeList(node.endModifiers),
      with: this.transformNode(node.with),
      explain: this.transformNode(node.explain),
      limit: this.transformNode(node.limit),
      top: this.transformNode(node.top),
      output: this.transformNode(node.output)
    });
  }
  transformColumnUpdate(node) {
    return requireAllProps({
      kind: "ColumnUpdateNode",
      column: this.transformNode(node.column),
      value: this.transformNode(node.value)
    });
  }
  transformLimit(node) {
    return requireAllProps({
      kind: "LimitNode",
      limit: this.transformNode(node.limit)
    });
  }
  transformOffset(node) {
    return requireAllProps({
      kind: "OffsetNode",
      offset: this.transformNode(node.offset)
    });
  }
  transformOnConflict(node) {
    return requireAllProps({
      kind: "OnConflictNode",
      columns: this.transformNodeList(node.columns),
      constraint: this.transformNode(node.constraint),
      indexExpression: this.transformNode(node.indexExpression),
      indexWhere: this.transformNode(node.indexWhere),
      updates: this.transformNodeList(node.updates),
      updateWhere: this.transformNode(node.updateWhere),
      doNothing: node.doNothing
    });
  }
  transformOnDuplicateKey(node) {
    return requireAllProps({
      kind: "OnDuplicateKeyNode",
      updates: this.transformNodeList(node.updates)
    });
  }
  transformCreateIndex(node) {
    return requireAllProps({
      kind: "CreateIndexNode",
      name: this.transformNode(node.name),
      table: this.transformNode(node.table),
      columns: this.transformNodeList(node.columns),
      unique: node.unique,
      using: this.transformNode(node.using),
      ifNotExists: node.ifNotExists,
      where: this.transformNode(node.where),
      nullsNotDistinct: node.nullsNotDistinct
    });
  }
  transformList(node) {
    return requireAllProps({
      kind: "ListNode",
      items: this.transformNodeList(node.items)
    });
  }
  transformDropIndex(node) {
    return requireAllProps({
      kind: "DropIndexNode",
      name: this.transformNode(node.name),
      table: this.transformNode(node.table),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformPrimaryKeyConstraint(node) {
    return requireAllProps({
      kind: "PrimaryKeyConstraintNode",
      columns: this.transformNodeList(node.columns),
      name: this.transformNode(node.name)
    });
  }
  transformUniqueConstraint(node) {
    return requireAllProps({
      kind: "UniqueConstraintNode",
      columns: this.transformNodeList(node.columns),
      name: this.transformNode(node.name),
      nullsNotDistinct: node.nullsNotDistinct
    });
  }
  transformForeignKeyConstraint(node) {
    return requireAllProps({
      kind: "ForeignKeyConstraintNode",
      columns: this.transformNodeList(node.columns),
      references: this.transformNode(node.references),
      name: this.transformNode(node.name),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate
    });
  }
  transformSetOperation(node) {
    return requireAllProps({
      kind: "SetOperationNode",
      operator: node.operator,
      expression: this.transformNode(node.expression),
      all: node.all
    });
  }
  transformReferences(node) {
    return requireAllProps({
      kind: "ReferencesNode",
      table: this.transformNode(node.table),
      columns: this.transformNodeList(node.columns),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate
    });
  }
  transformCheckConstraint(node) {
    return requireAllProps({
      kind: "CheckConstraintNode",
      expression: this.transformNode(node.expression),
      name: this.transformNode(node.name)
    });
  }
  transformWith(node) {
    return requireAllProps({
      kind: "WithNode",
      expressions: this.transformNodeList(node.expressions),
      recursive: node.recursive
    });
  }
  transformCommonTableExpression(node) {
    return requireAllProps({
      kind: "CommonTableExpressionNode",
      name: this.transformNode(node.name),
      materialized: node.materialized,
      expression: this.transformNode(node.expression)
    });
  }
  transformCommonTableExpressionName(node) {
    return requireAllProps({
      kind: "CommonTableExpressionNameNode",
      table: this.transformNode(node.table),
      columns: this.transformNodeList(node.columns)
    });
  }
  transformHaving(node) {
    return requireAllProps({
      kind: "HavingNode",
      having: this.transformNode(node.having)
    });
  }
  transformCreateSchema(node) {
    return requireAllProps({
      kind: "CreateSchemaNode",
      schema: this.transformNode(node.schema),
      ifNotExists: node.ifNotExists
    });
  }
  transformDropSchema(node) {
    return requireAllProps({
      kind: "DropSchemaNode",
      schema: this.transformNode(node.schema),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformAlterTable(node) {
    return requireAllProps({
      kind: "AlterTableNode",
      table: this.transformNode(node.table),
      renameTo: this.transformNode(node.renameTo),
      setSchema: this.transformNode(node.setSchema),
      columnAlterations: this.transformNodeList(node.columnAlterations),
      addConstraint: this.transformNode(node.addConstraint),
      dropConstraint: this.transformNode(node.dropConstraint),
      addIndex: this.transformNode(node.addIndex),
      dropIndex: this.transformNode(node.dropIndex)
    });
  }
  transformDropColumn(node) {
    return requireAllProps({
      kind: "DropColumnNode",
      column: this.transformNode(node.column)
    });
  }
  transformRenameColumn(node) {
    return requireAllProps({
      kind: "RenameColumnNode",
      column: this.transformNode(node.column),
      renameTo: this.transformNode(node.renameTo)
    });
  }
  transformAlterColumn(node) {
    return requireAllProps({
      kind: "AlterColumnNode",
      column: this.transformNode(node.column),
      dataType: this.transformNode(node.dataType),
      dataTypeExpression: this.transformNode(node.dataTypeExpression),
      setDefault: this.transformNode(node.setDefault),
      dropDefault: node.dropDefault,
      setNotNull: node.setNotNull,
      dropNotNull: node.dropNotNull
    });
  }
  transformModifyColumn(node) {
    return requireAllProps({
      kind: "ModifyColumnNode",
      column: this.transformNode(node.column)
    });
  }
  transformAddConstraint(node) {
    return requireAllProps({
      kind: "AddConstraintNode",
      constraint: this.transformNode(node.constraint)
    });
  }
  transformDropConstraint(node) {
    return requireAllProps({
      kind: "DropConstraintNode",
      constraintName: this.transformNode(node.constraintName),
      ifExists: node.ifExists,
      modifier: node.modifier
    });
  }
  transformCreateView(node) {
    return requireAllProps({
      kind: "CreateViewNode",
      name: this.transformNode(node.name),
      temporary: node.temporary,
      orReplace: node.orReplace,
      ifNotExists: node.ifNotExists,
      materialized: node.materialized,
      columns: this.transformNodeList(node.columns),
      as: this.transformNode(node.as)
    });
  }
  transformDropView(node) {
    return requireAllProps({
      kind: "DropViewNode",
      name: this.transformNode(node.name),
      ifExists: node.ifExists,
      materialized: node.materialized,
      cascade: node.cascade
    });
  }
  transformGenerated(node) {
    return requireAllProps({
      kind: "GeneratedNode",
      byDefault: node.byDefault,
      always: node.always,
      identity: node.identity,
      stored: node.stored,
      expression: this.transformNode(node.expression)
    });
  }
  transformDefaultValue(node) {
    return requireAllProps({
      kind: "DefaultValueNode",
      defaultValue: this.transformNode(node.defaultValue)
    });
  }
  transformOn(node) {
    return requireAllProps({
      kind: "OnNode",
      on: this.transformNode(node.on)
    });
  }
  transformSelectModifier(node) {
    return requireAllProps({
      kind: "SelectModifierNode",
      modifier: node.modifier,
      rawModifier: this.transformNode(node.rawModifier),
      of: this.transformNodeList(node.of)
    });
  }
  transformCreateType(node) {
    return requireAllProps({
      kind: "CreateTypeNode",
      name: this.transformNode(node.name),
      enum: this.transformNode(node.enum)
    });
  }
  transformDropType(node) {
    return requireAllProps({
      kind: "DropTypeNode",
      name: this.transformNode(node.name),
      ifExists: node.ifExists
    });
  }
  transformExplain(node) {
    return requireAllProps({
      kind: "ExplainNode",
      format: node.format,
      options: this.transformNode(node.options)
    });
  }
  transformSchemableIdentifier(node) {
    return requireAllProps({
      kind: "SchemableIdentifierNode",
      schema: this.transformNode(node.schema),
      identifier: this.transformNode(node.identifier)
    });
  }
  transformAggregateFunction(node) {
    return requireAllProps({
      kind: "AggregateFunctionNode",
      aggregated: this.transformNodeList(node.aggregated),
      distinct: node.distinct,
      orderBy: this.transformNode(node.orderBy),
      filter: this.transformNode(node.filter),
      func: node.func,
      over: this.transformNode(node.over)
    });
  }
  transformOver(node) {
    return requireAllProps({
      kind: "OverNode",
      orderBy: this.transformNode(node.orderBy),
      partitionBy: this.transformNode(node.partitionBy)
    });
  }
  transformPartitionBy(node) {
    return requireAllProps({
      kind: "PartitionByNode",
      items: this.transformNodeList(node.items)
    });
  }
  transformPartitionByItem(node) {
    return requireAllProps({
      kind: "PartitionByItemNode",
      partitionBy: this.transformNode(node.partitionBy)
    });
  }
  transformBinaryOperation(node) {
    return requireAllProps({
      kind: "BinaryOperationNode",
      leftOperand: this.transformNode(node.leftOperand),
      operator: this.transformNode(node.operator),
      rightOperand: this.transformNode(node.rightOperand)
    });
  }
  transformUnaryOperation(node) {
    return requireAllProps({
      kind: "UnaryOperationNode",
      operator: this.transformNode(node.operator),
      operand: this.transformNode(node.operand)
    });
  }
  transformUsing(node) {
    return requireAllProps({
      kind: "UsingNode",
      tables: this.transformNodeList(node.tables)
    });
  }
  transformFunction(node) {
    return requireAllProps({
      kind: "FunctionNode",
      func: node.func,
      arguments: this.transformNodeList(node.arguments)
    });
  }
  transformCase(node) {
    return requireAllProps({
      kind: "CaseNode",
      value: this.transformNode(node.value),
      when: this.transformNodeList(node.when),
      else: this.transformNode(node.else),
      isStatement: node.isStatement
    });
  }
  transformWhen(node) {
    return requireAllProps({
      kind: "WhenNode",
      condition: this.transformNode(node.condition),
      result: this.transformNode(node.result)
    });
  }
  transformJSONReference(node) {
    return requireAllProps({
      kind: "JSONReferenceNode",
      reference: this.transformNode(node.reference),
      traversal: this.transformNode(node.traversal)
    });
  }
  transformJSONPath(node) {
    return requireAllProps({
      kind: "JSONPathNode",
      inOperator: this.transformNode(node.inOperator),
      pathLegs: this.transformNodeList(node.pathLegs)
    });
  }
  transformJSONPathLeg(node) {
    return requireAllProps({
      kind: "JSONPathLegNode",
      type: node.type,
      value: node.value
    });
  }
  transformJSONOperatorChain(node) {
    return requireAllProps({
      kind: "JSONOperatorChainNode",
      operator: this.transformNode(node.operator),
      values: this.transformNodeList(node.values)
    });
  }
  transformTuple(node) {
    return requireAllProps({
      kind: "TupleNode",
      values: this.transformNodeList(node.values)
    });
  }
  transformMergeQuery(node) {
    return requireAllProps({
      kind: "MergeQueryNode",
      into: this.transformNode(node.into),
      using: this.transformNode(node.using),
      whens: this.transformNodeList(node.whens),
      with: this.transformNode(node.with),
      top: this.transformNode(node.top),
      endModifiers: this.transformNodeList(node.endModifiers),
      output: this.transformNode(node.output)
    });
  }
  transformMatched(node) {
    return requireAllProps({
      kind: "MatchedNode",
      not: node.not,
      bySource: node.bySource
    });
  }
  transformAddIndex(node) {
    return requireAllProps({
      kind: "AddIndexNode",
      name: this.transformNode(node.name),
      columns: this.transformNodeList(node.columns),
      unique: node.unique,
      using: this.transformNode(node.using),
      ifNotExists: node.ifNotExists
    });
  }
  transformCast(node) {
    return requireAllProps({
      kind: "CastNode",
      expression: this.transformNode(node.expression),
      dataType: this.transformNode(node.dataType)
    });
  }
  transformFetch(node) {
    return requireAllProps({
      kind: "FetchNode",
      rowCount: this.transformNode(node.rowCount),
      modifier: node.modifier
    });
  }
  transformTop(node) {
    return requireAllProps({
      kind: "TopNode",
      expression: node.expression,
      modifiers: node.modifiers
    });
  }
  transformOutput(node) {
    return requireAllProps({
      kind: "OutputNode",
      selections: this.transformNodeList(node.selections)
    });
  }
  transformDataType(node) {
    return node;
  }
  transformSelectAll(node) {
    return node;
  }
  transformIdentifier(node) {
    return node;
  }
  transformValue(node) {
    return node;
  }
  transformPrimitiveValueList(node) {
    return node;
  }
  transformOperator(node) {
    return node;
  }
  transformDefaultInsertValue(node) {
    return node;
  }
};
_transformers = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/plugin/with-schema/with-schema-transformer.js
var ROOT_OPERATION_NODES = freeze({
  AlterTableNode: true,
  CreateIndexNode: true,
  CreateSchemaNode: true,
  CreateTableNode: true,
  CreateTypeNode: true,
  CreateViewNode: true,
  DeleteQueryNode: true,
  DropIndexNode: true,
  DropSchemaNode: true,
  DropTableNode: true,
  DropTypeNode: true,
  DropViewNode: true,
  InsertQueryNode: true,
  RawNode: true,
  SelectQueryNode: true,
  UpdateQueryNode: true,
  MergeQueryNode: true
});
var SCHEMALESS_FUNCTIONS = {
  json_agg: true,
  to_json: true
};
var _schema, _schemableIds, _ctes, _WithSchemaTransformer_instances, transformTableArgsWithoutSchemas_fn, isRootOperationNode_fn, collectSchemableIds_fn, collectCTEs_fn, collectSchemableIdsFromTableExpr_fn, collectSchemableId_fn, collectCTEIds_fn;
var WithSchemaTransformer = class extends OperationNodeTransformer {
  constructor(schema) {
    super();
    __privateAdd(this, _WithSchemaTransformer_instances);
    __privateAdd(this, _schema);
    __privateAdd(this, _schemableIds, /* @__PURE__ */ new Set());
    __privateAdd(this, _ctes, /* @__PURE__ */ new Set());
    __privateSet(this, _schema, schema);
  }
  transformNodeImpl(node) {
    if (!__privateMethod(this, _WithSchemaTransformer_instances, isRootOperationNode_fn).call(this, node)) {
      return super.transformNodeImpl(node);
    }
    const ctes = __privateMethod(this, _WithSchemaTransformer_instances, collectCTEs_fn).call(this, node);
    for (const cte of ctes) {
      __privateGet(this, _ctes).add(cte);
    }
    const tables = __privateMethod(this, _WithSchemaTransformer_instances, collectSchemableIds_fn).call(this, node);
    for (const table of tables) {
      __privateGet(this, _schemableIds).add(table);
    }
    const transformed = super.transformNodeImpl(node);
    for (const table of tables) {
      __privateGet(this, _schemableIds).delete(table);
    }
    for (const cte of ctes) {
      __privateGet(this, _ctes).delete(cte);
    }
    return transformed;
  }
  transformSchemableIdentifier(node) {
    const transformed = super.transformSchemableIdentifier(node);
    if (transformed.schema || !__privateGet(this, _schemableIds).has(node.identifier.name)) {
      return transformed;
    }
    return {
      ...transformed,
      schema: IdentifierNode.create(__privateGet(this, _schema))
    };
  }
  transformReferences(node) {
    const transformed = super.transformReferences(node);
    if (transformed.table.table.schema) {
      return transformed;
    }
    return {
      ...transformed,
      table: TableNode.createWithSchema(__privateGet(this, _schema), transformed.table.table.identifier.name)
    };
  }
  transformAggregateFunction(node) {
    return {
      ...super.transformAggregateFunction({ ...node, aggregated: [] }),
      aggregated: __privateMethod(this, _WithSchemaTransformer_instances, transformTableArgsWithoutSchemas_fn).call(this, node, "aggregated")
    };
  }
  transformFunction(node) {
    return {
      ...super.transformFunction({ ...node, arguments: [] }),
      arguments: __privateMethod(this, _WithSchemaTransformer_instances, transformTableArgsWithoutSchemas_fn).call(this, node, "arguments")
    };
  }
};
_schema = new WeakMap();
_schemableIds = new WeakMap();
_ctes = new WeakMap();
_WithSchemaTransformer_instances = new WeakSet();
transformTableArgsWithoutSchemas_fn = function(node, argsKey) {
  return SCHEMALESS_FUNCTIONS[node.func] ? node[argsKey].map((arg) => !TableNode.is(arg) || arg.table.schema ? this.transformNode(arg) : {
    ...arg,
    table: this.transformIdentifier(arg.table.identifier)
  }) : this.transformNodeList(node[argsKey]);
};
isRootOperationNode_fn = function(node) {
  return node.kind in ROOT_OPERATION_NODES;
};
collectSchemableIds_fn = function(node) {
  const schemableIds = /* @__PURE__ */ new Set();
  if ("name" in node && node.name && SchemableIdentifierNode.is(node.name)) {
    __privateMethod(this, _WithSchemaTransformer_instances, collectSchemableId_fn).call(this, node.name, schemableIds);
  }
  if ("from" in node && node.from) {
    for (const from of node.from.froms) {
      __privateMethod(this, _WithSchemaTransformer_instances, collectSchemableIdsFromTableExpr_fn).call(this, from, schemableIds);
    }
  }
  if ("into" in node && node.into) {
    __privateMethod(this, _WithSchemaTransformer_instances, collectSchemableIdsFromTableExpr_fn).call(this, node.into, schemableIds);
  }
  if ("table" in node && node.table) {
    __privateMethod(this, _WithSchemaTransformer_instances, collectSchemableIdsFromTableExpr_fn).call(this, node.table, schemableIds);
  }
  if ("joins" in node && node.joins) {
    for (const join of node.joins) {
      __privateMethod(this, _WithSchemaTransformer_instances, collectSchemableIdsFromTableExpr_fn).call(this, join.table, schemableIds);
    }
  }
  if ("using" in node && node.using) {
    __privateMethod(this, _WithSchemaTransformer_instances, collectSchemableIdsFromTableExpr_fn).call(this, node.using, schemableIds);
  }
  return schemableIds;
};
collectCTEs_fn = function(node) {
  const ctes = /* @__PURE__ */ new Set();
  if ("with" in node && node.with) {
    __privateMethod(this, _WithSchemaTransformer_instances, collectCTEIds_fn).call(this, node.with, ctes);
  }
  return ctes;
};
collectSchemableIdsFromTableExpr_fn = function(node, schemableIds) {
  const table = TableNode.is(node) ? node : AliasNode.is(node) && TableNode.is(node.node) ? node.node : null;
  if (table) {
    __privateMethod(this, _WithSchemaTransformer_instances, collectSchemableId_fn).call(this, table.table, schemableIds);
  }
};
collectSchemableId_fn = function(node, schemableIds) {
  const id = node.identifier.name;
  if (!__privateGet(this, _schemableIds).has(id) && !__privateGet(this, _ctes).has(id)) {
    schemableIds.add(id);
  }
};
collectCTEIds_fn = function(node, ctes) {
  for (const expr of node.expressions) {
    const cteId = expr.name.table.table.identifier.name;
    if (!__privateGet(this, _ctes).has(cteId)) {
      ctes.add(cteId);
    }
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/plugin/with-schema/with-schema-plugin.js
var _transformer;
var WithSchemaPlugin = class {
  constructor(schema) {
    __privateAdd(this, _transformer);
    __privateSet(this, _transformer, new WithSchemaTransformer(schema));
  }
  transformQuery(args) {
    return __privateGet(this, _transformer).transformNode(args.node);
  }
  async transformResult(args) {
    return args.result;
  }
};
_transformer = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/matched-node.js
var MatchedNode = freeze({
  is(node) {
    return node.kind === "MatchedNode";
  },
  create(not, bySource = false) {
    return freeze({
      kind: "MatchedNode",
      not,
      bySource
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/merge-parser.js
function parseMergeWhen(type, args, refRight) {
  return WhenNode.create(parseFilterList([
    MatchedNode.create(!type.isMatched, type.bySource),
    ...args && args.length > 0 ? [
      args.length === 3 && refRight ? parseReferentialBinaryOperation(args[0], args[1], args[2]) : parseValueBinaryOperationOrExpression(args)
    ] : []
  ], "and", false));
}
function parseMergeThen(result) {
  if (isString(result)) {
    return RawNode.create([result], []);
  }
  if (isOperationNodeSource(result)) {
    return result.toOperationNode();
  }
  return result;
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/deferred.js
var _promise, _resolve, _reject;
var Deferred = class {
  constructor() {
    __privateAdd(this, _promise);
    __privateAdd(this, _resolve);
    __privateAdd(this, _reject);
    __publicField(this, "resolve", (value) => {
      if (__privateGet(this, _resolve)) {
        __privateGet(this, _resolve).call(this, value);
      }
    });
    __publicField(this, "reject", (reason) => {
      if (__privateGet(this, _reject)) {
        __privateGet(this, _reject).call(this, reason);
      }
    });
    __privateSet(this, _promise, new Promise((resolve, reject) => {
      __privateSet(this, _reject, reject);
      __privateSet(this, _resolve, resolve);
    }));
  }
  get promise() {
    return __privateGet(this, _promise);
  }
};
_promise = new WeakMap();
_resolve = new WeakMap();
_reject = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/log-once.js
var LOGGED_MESSAGES = /* @__PURE__ */ new Set();
function logOnce(message) {
  if (LOGGED_MESSAGES.has(message)) {
    return;
  }
  LOGGED_MESSAGES.add(message);
  console.log(message);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-executor/query-executor-base.js
var NO_PLUGINS = freeze([]);
var _plugins, _QueryExecutorBase_instances, transformResult_fn;
var QueryExecutorBase = class {
  constructor(plugins = NO_PLUGINS) {
    __privateAdd(this, _QueryExecutorBase_instances);
    __privateAdd(this, _plugins);
    __privateSet(this, _plugins, plugins);
  }
  get plugins() {
    return __privateGet(this, _plugins);
  }
  transformQuery(node, queryId) {
    for (const plugin of __privateGet(this, _plugins)) {
      const transformedNode = plugin.transformQuery({ node, queryId });
      if (transformedNode.kind === node.kind) {
        node = transformedNode;
      } else {
        throw new Error([
          `KyselyPlugin.transformQuery must return a node`,
          `of the same kind that was given to it.`,
          `The plugin was given a ${node.kind}`,
          `but it returned a ${transformedNode.kind}`
        ].join(" "));
      }
    }
    return node;
  }
  async executeQuery(compiledQuery, queryId) {
    return await this.provideConnection(async (connection) => {
      const result = await connection.executeQuery(compiledQuery);
      const transformedResult = await __privateMethod(this, _QueryExecutorBase_instances, transformResult_fn).call(this, result, queryId);
      warnOfOutdatedDriverOrPlugins(result, transformedResult);
      return transformedResult;
    });
  }
  async *stream(compiledQuery, chunkSize, queryId) {
    const connectionDefer = new Deferred();
    const connectionReleaseDefer = new Deferred();
    this.provideConnection(async (connection2) => {
      connectionDefer.resolve(connection2);
      return await connectionReleaseDefer.promise;
    }).catch((ex) => connectionDefer.reject(ex));
    const connection = await connectionDefer.promise;
    try {
      for await (const result of connection.streamQuery(compiledQuery, chunkSize)) {
        yield await __privateMethod(this, _QueryExecutorBase_instances, transformResult_fn).call(this, result, queryId);
      }
    } finally {
      connectionReleaseDefer.resolve();
    }
  }
};
_plugins = new WeakMap();
_QueryExecutorBase_instances = new WeakSet();
transformResult_fn = async function(result, queryId) {
  for (const plugin of __privateGet(this, _plugins)) {
    result = await plugin.transformResult({ result, queryId });
  }
  return result;
};
function warnOfOutdatedDriverOrPlugins(result, transformedResult) {
  const { numAffectedRows } = result;
  if (numAffectedRows === void 0 && result.numUpdatedOrDeletedRows === void 0 || numAffectedRows !== void 0 && transformedResult.numAffectedRows !== void 0) {
    return;
  }
  logOnce("kysely:warning: outdated driver/plugin detected! QueryResult.numUpdatedOrDeletedRows is deprecated and will be removed in a future release.");
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-executor/noop-query-executor.js
var NoopQueryExecutor = class _NoopQueryExecutor extends QueryExecutorBase {
  get adapter() {
    throw new Error("this query cannot be compiled to SQL");
  }
  compileQuery() {
    throw new Error("this query cannot be compiled to SQL");
  }
  provideConnection() {
    throw new Error("this query cannot be executed");
  }
  withConnectionProvider() {
    throw new Error("this query cannot have a connection provider");
  }
  withPlugin(plugin) {
    return new _NoopQueryExecutor([...this.plugins, plugin]);
  }
  withPlugins(plugins) {
    return new _NoopQueryExecutor([...this.plugins, ...plugins]);
  }
  withPluginAtFront(plugin) {
    return new _NoopQueryExecutor([plugin, ...this.plugins]);
  }
  withoutPlugins() {
    return new _NoopQueryExecutor([]);
  }
};
var NOOP_QUERY_EXECUTOR = new NoopQueryExecutor();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/merge-result.js
var MergeResult = class {
  constructor(numChangedRows) {
    __publicField(this, "numChangedRows");
    this.numChangedRows = numChangedRows;
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/merge-query-builder.js
var _props10;
var _MergeQueryBuilder = class _MergeQueryBuilder {
  constructor(props) {
    __privateAdd(this, _props10);
    __privateSet(this, _props10, freeze(props));
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .mergeInto('person')
   *   .using('pet', 'pet.owner_id', 'person.id')
   *   .whenMatched()
   *   .thenDelete()
   *   .modifyEnd(sql.raw('-- this is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person" using "pet" on "pet"."owner_id" = "person"."id" when matched then delete -- this is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new _MergeQueryBuilder({
      ...__privateGet(this, _props10),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props10).queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Changes a `merge into` query to an `merge top into` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Affect 5 matched rows at most:
   *
   * ```ts
   * await db.mergeInto('person')
   *   .top(5)
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * merge top(5) into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   *
   * Affect 50% of matched rows:
   *
   * ```ts
   * await db.mergeInto('person')
   *   .top(50, 'percent')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * merge top(50) percent into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  top(expression, modifiers) {
    return new _MergeQueryBuilder({
      ...__privateGet(this, _props10),
      queryNode: QueryNode.cloneWithTop(__privateGet(this, _props10).queryNode, parseTop(expression, modifiers))
    });
  }
  using(...args) {
    return new WheneableMergeQueryBuilder({
      ...__privateGet(this, _props10),
      queryNode: MergeQueryNode.cloneWithUsing(__privateGet(this, _props10).queryNode, parseJoin("Using", args))
    });
  }
  output(args) {
    return new _MergeQueryBuilder({
      ...__privateGet(this, _props10),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props10).queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _MergeQueryBuilder({
      ...__privateGet(this, _props10),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props10).queryNode, parseSelectAll(table))
    });
  }
};
_props10 = new WeakMap();
var MergeQueryBuilder = _MergeQueryBuilder;
preventAwait(MergeQueryBuilder, "don't await MergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
var _props11, _WheneableMergeQueryBuilder_instances, whenMatched_fn, whenNotMatched_fn;
var _WheneableMergeQueryBuilder = class _WheneableMergeQueryBuilder {
  constructor(props) {
    __privateAdd(this, _WheneableMergeQueryBuilder_instances);
    __privateAdd(this, _props11);
    __privateSet(this, _props11, freeze(props));
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .mergeInto('person')
   *   .using('pet', 'pet.owner_id', 'person.id')
   *   .whenMatched()
   *   .thenDelete()
   *   .modifyEnd(sql.raw('-- this is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person" using "pet" on "pet"."owner_id" = "person"."id" when matched then delete -- this is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new _WheneableMergeQueryBuilder({
      ...__privateGet(this, _props11),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props11).queryNode, modifier.toOperationNode())
    });
  }
  /**
   * See {@link MergeQueryBuilder.top}.
   */
  top(expression, modifiers) {
    return new _WheneableMergeQueryBuilder({
      ...__privateGet(this, _props11),
      queryNode: QueryNode.cloneWithTop(__privateGet(this, _props11).queryNode, parseTop(expression, modifiers))
    });
  }
  /**
   * Adds a simple `when matched` clause to the query.
   *
   * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
   *
   * For a simple `when not matched` clause, see {@link whenNotMatched}.
   *
   * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  whenMatched() {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenMatched_fn).call(this, []);
  }
  whenMatchedAnd(...args) {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenMatched_fn).call(this, args);
  }
  /**
   * Adds the `when matched` clause to the query with an `and` condition. But unlike
   * {@link whenMatchedAnd}, this method accepts a column reference as the 3rd argument.
   *
   * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
   * for that method for more examples.
   */
  whenMatchedAndRef(lhs, op, rhs) {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenMatched_fn).call(this, [lhs, op, rhs], true);
  }
  /**
   * Adds a simple `when not matched` clause to the query.
   *
   * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
   *
   * For a simple `when matched` clause, see {@link whenMatched}.
   *
   * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenNotMatched()
   *   .thenInsertValues({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when not matched then
   *   insert ("first_name", "last_name") values ($1, $2)
   * ```
   */
  whenNotMatched() {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenNotMatched_fn).call(this, []);
  }
  whenNotMatchedAnd(...args) {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenNotMatched_fn).call(this, args);
  }
  /**
   * Adds the `when not matched` clause to the query with an `and` condition. But unlike
   * {@link whenNotMatchedAnd}, this method accepts a column reference as the 3rd argument.
   *
   * Unlike {@link whenMatchedAndRef}, you cannot reference columns from the target table.
   *
   * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
   * for that method for more examples.
   */
  whenNotMatchedAndRef(lhs, op, rhs) {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenNotMatched_fn).call(this, [lhs, op, rhs], true);
  }
  /**
   * Adds a simple `when not matched by source` clause to the query.
   *
   * Supported in MS SQL Server.
   *
   * Similar to {@link whenNotMatched}, but returns a {@link MatchedThenableMergeQueryBuilder}.
   */
  whenNotMatchedBySource() {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenNotMatched_fn).call(this, [], false, true);
  }
  whenNotMatchedBySourceAnd(...args) {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenNotMatched_fn).call(this, args, false, true);
  }
  /**
   * Adds the `when not matched by source` clause to the query with an `and` condition.
   *
   * Similar to {@link whenNotMatchedAndRef}, but you can reference columns from
   * the target table, and not from source table and returns a {@link MatchedThenableMergeQueryBuilder}.
   */
  whenNotMatchedBySourceAndRef(lhs, op, rhs) {
    return __privateMethod(this, _WheneableMergeQueryBuilder_instances, whenNotMatched_fn).call(this, [lhs, op, rhs], true, true);
  }
  output(args) {
    return new _WheneableMergeQueryBuilder({
      ...__privateGet(this, _props11),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props11).queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new _WheneableMergeQueryBuilder({
      ...__privateGet(this, _props11),
      queryNode: QueryNode.cloneWithOutput(__privateGet(this, _props11).queryNode, parseSelectAll(table))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.updateTable('person')
   *   .set({ first_name: 'John' })
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {
   *   return await db
   *     .updateTable('person')
   *     .set(updates)
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `updatePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _WheneableMergeQueryBuilder({
      ...__privateGet(this, _props11)
    });
  }
  toOperationNode() {
    return __privateGet(this, _props11).executor.transformQuery(__privateGet(this, _props11).queryNode, __privateGet(this, _props11).queryId);
  }
  compile() {
    return __privateGet(this, _props11).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props11).queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result = await __privateGet(this, _props11).executor.executeQuery(compiledQuery, __privateGet(this, _props11).queryId);
    if (compiledQuery.query.output && __privateGet(this, _props11).executor.adapter.supportsOutput) {
      return result.rows;
    }
    return [new MergeResult(result.numAffectedRows)];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
};
_props11 = new WeakMap();
_WheneableMergeQueryBuilder_instances = new WeakSet();
whenMatched_fn = function(args, refRight) {
  return new MatchedThenableMergeQueryBuilder({
    ...__privateGet(this, _props11),
    queryNode: MergeQueryNode.cloneWithWhen(__privateGet(this, _props11).queryNode, parseMergeWhen({ isMatched: true }, args, refRight))
  });
};
whenNotMatched_fn = function(args, refRight = false, bySource = false) {
  const props = {
    ...__privateGet(this, _props11),
    queryNode: MergeQueryNode.cloneWithWhen(__privateGet(this, _props11).queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight))
  };
  const Builder = bySource ? MatchedThenableMergeQueryBuilder : NotMatchedThenableMergeQueryBuilder;
  return new Builder(props);
};
var WheneableMergeQueryBuilder = _WheneableMergeQueryBuilder;
preventAwait(WheneableMergeQueryBuilder, "don't await WheneableMergeQueryBuilder instances directly. To execute the query you need to call `execute`.");
var _props12;
var MatchedThenableMergeQueryBuilder = class {
  constructor(props) {
    __privateAdd(this, _props12);
    __privateSet(this, _props12, freeze(props));
  }
  /**
   * Performs the `delete` action.
   *
   * To perform the `do nothing` action, see {@link thenDoNothing}.
   *
   * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  thenDelete() {
    return new WheneableMergeQueryBuilder({
      ...__privateGet(this, _props12),
      queryNode: MergeQueryNode.cloneWithThen(__privateGet(this, _props12).queryNode, parseMergeThen("delete"))
    });
  }
  /**
   * Performs the `do nothing` action.
   *
   * This is supported in PostgreSQL.
   *
   * To perform the `delete` action, see {@link thenDelete}.
   *
   * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDoNothing()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   do nothing
   * ```
   */
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...__privateGet(this, _props12),
      queryNode: MergeQueryNode.cloneWithThen(__privateGet(this, _props12).queryNode, parseMergeThen("do nothing"))
    });
  }
  /**
   * Perform an `update` operation with a full-fledged {@link UpdateQueryBuilder}.
   * This is handy when multiple `set` invocations are needed.
   *
   * For a shorthand version of this method, see {@link thenUpdateSet}.
   *
   * To perform the `delete` action, see {@link thenDelete}.
   *
   * To perform the `do nothing` action, see {@link thenDoNothing}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenUpdate((ub) => ub
   *     .set(sql`metadata['has_pets']`, 'Y')
   *     .set({
   *       updated_at: new Date().toISOString(),
   *     })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   update set metadata['has_pets'] = $1, "updated_at" = $2
   * ```
   */
  thenUpdate(set) {
    return new WheneableMergeQueryBuilder({
      ...__privateGet(this, _props12),
      queryNode: MergeQueryNode.cloneWithThen(__privateGet(this, _props12).queryNode, parseMergeThen(set(new UpdateQueryBuilder({
        queryId: __privateGet(this, _props12).queryId,
        executor: NOOP_QUERY_EXECUTOR,
        queryNode: UpdateQueryNode.createWithoutTable()
      }))))
    });
  }
  thenUpdateSet(...args) {
    return this.thenUpdate((ub) => ub.set(...args));
  }
};
_props12 = new WeakMap();
preventAwait(MatchedThenableMergeQueryBuilder, "don't await MatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
var _props13;
var NotMatchedThenableMergeQueryBuilder = class {
  constructor(props) {
    __privateAdd(this, _props13);
    __privateSet(this, _props13, freeze(props));
  }
  /**
   * Performs the `do nothing` action.
   *
   * This is supported in PostgreSQL.
   *
   * To perform the `insert` action, see {@link thenInsertValues}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenNotMatched()
   *   .thenDoNothing()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when not matched then
   *   do nothing
   * ```
   */
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...__privateGet(this, _props13),
      queryNode: MergeQueryNode.cloneWithThen(__privateGet(this, _props13).queryNode, parseMergeThen("do nothing"))
    });
  }
  thenInsertValues(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new WheneableMergeQueryBuilder({
      ...__privateGet(this, _props13),
      queryNode: MergeQueryNode.cloneWithThen(__privateGet(this, _props13).queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {
        columns,
        values
      })))
    });
  }
};
_props13 = new WeakMap();
preventAwait(NotMatchedThenableMergeQueryBuilder, "don't await NotMatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-creator.js
var _props14;
var _QueryCreator = class _QueryCreator {
  constructor(props) {
    __privateAdd(this, _props14);
    __privateSet(this, _props14, freeze(props));
  }
  selectFrom(from) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _props14).executor,
      queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), __privateGet(this, _props14).withNode)
    });
  }
  selectNoFrom(selection) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _props14).executor,
      queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(__privateGet(this, _props14).withNode), parseSelectArg(selection))
    });
  }
  /**
   * Creates an insert query.
   *
   * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
   * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
   * the inserted row if the db returned one.
   *
   * See the {@link InsertQueryBuilder.values | values} method for more info and examples. Also see
   * the {@link ReturningInterface.returning | returning} method for a way to return columns
   * on supported databases like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .executeTakeFirst()
   *
   * console.log(result.insertId)
   * ```
   *
   * Some databases like PostgreSQL support the `returning` method:
   *
   * ```ts
   * const { id } = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .returning('id')
   *   .executeTakeFirstOrThrow()
   * ```
   */
  insertInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _props14).executor,
      queryNode: InsertQueryNode.create(parseTable(table), __privateGet(this, _props14).withNode)
    });
  }
  /**
   * Creates a replace query.
   *
   * A MySQL-only statement similar to {@link InsertQueryBuilder.onDuplicateKeyUpdate}
   * that deletes and inserts values on collision instead of updating existing rows.
   *
   * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
   * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
   * the inserted row if the db returned one.
   *
   * See the {@link InsertQueryBuilder.values | values} method for more info and examples.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .replaceInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .executeTakeFirst()
   *
   * console.log(result.insertId)
   * ```
   */
  replaceInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _props14).executor,
      queryNode: InsertQueryNode.create(parseTable(table), __privateGet(this, _props14).withNode, true)
    });
  }
  deleteFrom(tables) {
    return new DeleteQueryBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _props14).executor,
      queryNode: DeleteQueryNode.create(parseTableExpressionOrList(tables), __privateGet(this, _props14).withNode)
    });
  }
  updateTable(table) {
    return new UpdateQueryBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _props14).executor,
      queryNode: UpdateQueryNode.create(parseTableExpression(table), __privateGet(this, _props14).withNode)
    });
  }
  mergeInto(targetTable) {
    return new MergeQueryBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _props14).executor,
      queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), __privateGet(this, _props14).withNode)
    });
  }
  /**
   * Creates a `with` query (Common Table Expression).
   *
   * ### Examples
   *
   * <!-- siteExample("cte", "Simple selects", 10) -->
   *
   * Common table expressions (CTE) are a great way to modularize complex queries.
   * Essentially they allow you to run multiple separate queries within a
   * single roundtrip to the DB.
   *
   * Since CTEs are a part of the main query, query optimizers inside DB
   * engines are able to optimize the overall query. For example, postgres
   * is able to inline the CTEs inside the using queries if it decides it's
   * faster.
   *
   * ```ts
   * const result = await db
   *   // Create a CTE called `jennifers` that selects all
   *   // persons named 'Jennifer'.
   *   .with('jennifers', (db) => db
   *     .selectFrom('person')
   *     .where('first_name', '=', 'Jennifer')
   *     .select(['id', 'age'])
   *   )
   *   // Select all rows from the `jennifers` CTE and
   *   // further filter it.
   *   .with('adult_jennifers', (db) => db
   *     .selectFrom('jennifers')
   *     .where('age', '>', 18)
   *     .select(['id', 'age'])
   *   )
   *   // Finally select all adult jennifers that are
   *   // also younger than 60.
   *   .selectFrom('adult_jennifers')
   *   .where('age', '<', 60)
   *   .selectAll()
   *   .execute()
   * ```
   *
   * <!-- siteExample("cte", "Inserts, updates and deletions", 20) -->
   *
   * Some databases like postgres also allow you to run other queries than selects
   * in CTEs. On these databases CTEs are extremely powerful:
   *
   * ```ts
   * const result = await db
   *   .with('new_person', (db) => db
   *     .insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       age: 35,
   *     })
   *     .returning('id')
   *   )
   *   .with('new_pet', (db) => db
   *     .insertInto('pet')
   *     .values({
   *       name: 'Doggo',
   *       species: 'dog',
   *       is_favorite: true,
   *       // Use the id of the person we just inserted.
   *       owner_id: db
   *         .selectFrom('new_person')
   *         .select('id')
   *     })
   *     .returning('id')
   *   )
   *   .selectFrom(['new_person', 'new_pet'])
   *   .select([
   *     'new_person.id as person_id',
   *     'new_pet.id as pet_id'
   *   ])
   *   .execute()
   * ```
   *
   * The CTE name can optionally specify column names in addition to
   * a name. In that case Kysely requires the expression to retun
   * rows with the same columns.
   *
   * ```ts
   * await db
   *   .with('jennifers(id, age)', (db) => db
   *     .selectFrom('person')
   *     .where('first_name', '=', 'Jennifer')
   *     // This is ok since we return columns with the same
   *     // names as specified by `jennifers(id, age)`.
   *     .select(['id', 'age'])
   *   )
   *   .selectFrom('jennifers')
   *   .selectAll()
   *   .execute()
   * ```
   *
   * The first argument can also be a callback. The callback is passed
   * a `CTEBuilder` instance that can be used to configure the CTE:
   *
   * ```ts
   * await db
   *   .with(
   *     (cte) => cte('jennifers').materialized(),
   *     (db) => db
   *       .selectFrom('person')
   *       .where('first_name', '=', 'Jennifer')
   *       .select(['id', 'age'])
   *   )
   *   .selectFrom('jennifers')
   *   .selectAll()
   *   .execute()
   * ```
   */
  with(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new _QueryCreator({
      ...__privateGet(this, _props14),
      withNode: __privateGet(this, _props14).withNode ? WithNode.cloneWithExpression(__privateGet(this, _props14).withNode, cte) : WithNode.create(cte)
    });
  }
  /**
   * Creates a recursive `with` query (Common Table Expression).
   *
   * Note that recursiveness is a property of the whole `with` statement.
   * You cannot have recursive and non-recursive CTEs in a same `with` statement.
   * Therefore the recursiveness is determined by the **first** `with` or
   * `withRecusive` call you make.
   *
   * See the {@link with} method for examples and more documentation.
   */
  withRecursive(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new _QueryCreator({
      ...__privateGet(this, _props14),
      withNode: __privateGet(this, _props14).withNode ? WithNode.cloneWithExpression(__privateGet(this, _props14).withNode, cte) : WithNode.create(cte, { recursive: true })
    });
  }
  /**
   * Returns a copy of this query creator instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new _QueryCreator({
      ...__privateGet(this, _props14),
      executor: __privateGet(this, _props14).executor.withPlugin(plugin)
    });
  }
  /**
   * Returns a copy of this query creator instance without any plugins.
   */
  withoutPlugins() {
    return new _QueryCreator({
      ...__privateGet(this, _props14),
      executor: __privateGet(this, _props14).executor.withoutPlugins()
    });
  }
  /**
   * Sets the schema to be used for all table references that don't explicitly
   * specify a schema.
   *
   * This only affects the query created through the builder returned from
   * this method and doesn't modify the `db` instance.
   *
   * See [this recipe](https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md)
   * for a more detailed explanation.
   *
   * ### Examples
   *
   * ```
   * await db
   *   .withSchema('mammals')
   *   .selectFrom('pet')
   *   .selectAll()
   *   .innerJoin('public.person', 'public.person.id', 'pet.owner_id')
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select * from "mammals"."pet"
   * inner join "public"."person"
   * on "public"."person"."id" = "mammals"."pet"."owner_id"
   * ```
   *
   * `withSchema` is smart enough to not add schema for aliases,
   * common table expressions or other places where the schema
   * doesn't belong to:
   *
   * ```
   * await db
   *   .withSchema('mammals')
   *   .selectFrom('pet as p')
   *   .select('p.name')
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p"."name" from "mammals"."pet" as "p"
   * ```
   */
  withSchema(schema) {
    return new _QueryCreator({
      ...__privateGet(this, _props14),
      executor: __privateGet(this, _props14).executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
};
_props14 = new WeakMap();
var QueryCreator = _QueryCreator;

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/parse-utils.js
function createQueryCreator() {
  return new QueryCreator({
    executor: NOOP_QUERY_EXECUTOR
  });
}
function createJoinBuilder(joinType, table) {
  return new JoinBuilder({
    joinNode: JoinNode.create(joinType, parseTableExpression(table))
  });
}
function createOverBuilder() {
  return new OverBuilder({
    overNode: OverNode.create()
  });
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/join-parser.js
function parseJoin(joinType, args) {
  if (args.length === 3) {
    return parseSingleOnJoin(joinType, args[0], args[1], args[2]);
  } else if (args.length === 2) {
    return parseCallbackJoin(joinType, args[0], args[1]);
  } else {
    throw new Error("not implemented");
  }
}
function parseCallbackJoin(joinType, from, callback) {
  return callback(createJoinBuilder(joinType, from)).toOperationNode();
}
function parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {
  return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, "=", rhsColumn));
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/offset-node.js
var OffsetNode = freeze({
  is(node) {
    return node.kind === "OffsetNode";
  },
  create(offset) {
    return freeze({
      kind: "OffsetNode",
      offset
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/group-by-item-node.js
var GroupByItemNode = freeze({
  is(node) {
    return node.kind === "GroupByItemNode";
  },
  create(groupBy) {
    return freeze({
      kind: "GroupByItemNode",
      groupBy
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/group-by-parser.js
function parseGroupBy(groupBy) {
  groupBy = isFunction(groupBy) ? groupBy(expressionBuilder()) : groupBy;
  return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/set-operation-node.js
var SetOperationNode = freeze({
  is(node) {
    return node.kind === "SetOperationNode";
  },
  create(operator, expression, all) {
    return freeze({
      kind: "SetOperationNode",
      operator,
      expression,
      all
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/set-operation-parser.js
function parseSetOperations(operator, expression, all) {
  if (isFunction(expression)) {
    expression = expression(createExpressionBuilder());
  }
  if (!isReadonlyArray(expression)) {
    expression = [expression];
  }
  return expression.map((expr) => SetOperationNode.create(operator, parseExpression(expr), all));
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/expression/expression-wrapper.js
var _node;
var _ExpressionWrapper = class _ExpressionWrapper {
  constructor(node) {
    __privateAdd(this, _node);
    __privateSet(this, _node, node);
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(__privateGet(this, _node), parseValueBinaryOperationOrExpression(args)));
  }
  and(...args) {
    return new AndWrapper(AndNode.create(__privateGet(this, _node), parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `ExpressionWrapper` with a new output type.
   */
  $castTo() {
    return new _ExpressionWrapper(__privateGet(this, _node));
  }
  /**
   * Omit null from the expression's type.
   *
   * This function can be useful in cases where you know an expression can't be
   * null, but Kysely is unable to infer it.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of `this` with a new output type.
   */
  $notNull() {
    return new _ExpressionWrapper(__privateGet(this, _node));
  }
  toOperationNode() {
    return __privateGet(this, _node);
  }
};
_node = new WeakMap();
var ExpressionWrapper = _ExpressionWrapper;
var _expr, _alias;
var AliasedExpressionWrapper = class {
  constructor(expr, alias) {
    __privateAdd(this, _expr);
    __privateAdd(this, _alias);
    __privateSet(this, _expr, expr);
    __privateSet(this, _alias, alias);
  }
  /** @private */
  get expression() {
    return __privateGet(this, _expr);
  }
  /** @private */
  get alias() {
    return __privateGet(this, _alias);
  }
  toOperationNode() {
    return AliasNode.create(__privateGet(this, _expr).toOperationNode(), isOperationNodeSource(__privateGet(this, _alias)) ? __privateGet(this, _alias).toOperationNode() : IdentifierNode.create(__privateGet(this, _alias)));
  }
};
_expr = new WeakMap();
_alias = new WeakMap();
var _node2;
var _OrWrapper = class _OrWrapper {
  constructor(node) {
    __privateAdd(this, _node2);
    __privateSet(this, _node2, node);
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new _OrWrapper(OrNode.create(__privateGet(this, _node2), parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `OrWrapper` with a new output type.
   */
  $castTo() {
    return new _OrWrapper(__privateGet(this, _node2));
  }
  toOperationNode() {
    return ParensNode.create(__privateGet(this, _node2));
  }
};
_node2 = new WeakMap();
var OrWrapper = _OrWrapper;
var _node3;
var _AndWrapper = class _AndWrapper {
  constructor(node) {
    __privateAdd(this, _node3);
    __privateSet(this, _node3, node);
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  and(...args) {
    return new _AndWrapper(AndNode.create(__privateGet(this, _node3), parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `AndWrapper` with a new output type.
   */
  $castTo() {
    return new _AndWrapper(__privateGet(this, _node3));
  }
  toOperationNode() {
    return ParensNode.create(__privateGet(this, _node3));
  }
};
_node3 = new WeakMap();
var AndWrapper = _AndWrapper;

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/fetch-node.js
var FetchNode = {
  is(node) {
    return node.kind === "FetchNode";
  },
  create(rowCount, modifier) {
    return {
      kind: "FetchNode",
      rowCount: ValueNode.create(rowCount),
      modifier
    };
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/fetch-parser.js
function parseFetch(rowCount, modifier) {
  if (!isNumber(rowCount) && !isBigInt(rowCount)) {
    throw new Error(`Invalid fetch row count: ${rowCount}`);
  }
  if (!isFetchModifier(modifier)) {
    throw new Error(`Invalid fetch modifier: ${modifier}`);
  }
  return FetchNode.create(rowCount, modifier);
}
function isFetchModifier(value) {
  return value === "only" || value === "with ties";
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/select-query-builder.js
var _props15;
var _SelectQueryBuilderImpl = class _SelectQueryBuilderImpl {
  constructor(props) {
    __privateAdd(this, _props15);
    __privateSet(this, _props15, freeze(props));
  }
  get expressionType() {
    return void 0;
  }
  get isSelectQueryBuilder() {
    return true;
  }
  where(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithWhere(__privateGet(this, _props15).queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithWhere(__privateGet(this, _props15).queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  having(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithHaving(__privateGet(this, _props15).queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  havingRef(lhs, op, rhs) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithHaving(__privateGet(this, _props15).queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  select(selection) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithSelections(__privateGet(this, _props15).queryNode, parseSelectArg(selection))
    });
  }
  distinctOn(selection) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithDistinctOn(__privateGet(this, _props15).queryNode, parseReferenceExpressionOrList(selection))
    });
  }
  modifyFront(modifier) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithFrontModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  modifyEnd(modifier) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  distinct() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithFrontModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.create("Distinct"))
    });
  }
  forUpdate(of) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.create("ForUpdate", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forShare(of) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.create("ForShare", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forKeyShare(of) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.create("ForKeyShare", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forNoKeyUpdate(of) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.create("ForNoKeyUpdate", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  skipLocked() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.create("SkipLocked"))
    });
  }
  noWait() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithEndModifier(__privateGet(this, _props15).queryNode, SelectModifierNode.create("NoWait"))
    });
  }
  selectAll(table) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithSelections(__privateGet(this, _props15).queryNode, parseSelectAll(table))
    });
  }
  innerJoin(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props15).queryNode, parseJoin("InnerJoin", args))
    });
  }
  leftJoin(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props15).queryNode, parseJoin("LeftJoin", args))
    });
  }
  rightJoin(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props15).queryNode, parseJoin("RightJoin", args))
    });
  }
  fullJoin(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props15).queryNode, parseJoin("FullJoin", args))
    });
  }
  innerJoinLateral(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props15).queryNode, parseJoin("LateralInnerJoin", args))
    });
  }
  leftJoinLateral(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithJoin(__privateGet(this, _props15).queryNode, parseJoin("LateralLeftJoin", args))
    });
  }
  orderBy(...args) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithOrderByItems(__privateGet(this, _props15).queryNode, parseOrderBy(args))
    });
  }
  groupBy(groupBy) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithGroupByItems(__privateGet(this, _props15).queryNode, parseGroupBy(groupBy))
    });
  }
  limit(limit) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithLimit(__privateGet(this, _props15).queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  offset(offset) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithOffset(__privateGet(this, _props15).queryNode, OffsetNode.create(parseValueExpression(offset)))
    });
  }
  fetch(rowCount, modifier = "only") {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithFetch(__privateGet(this, _props15).queryNode, parseFetch(rowCount, modifier))
    });
  }
  top(expression, modifiers) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithTop(__privateGet(this, _props15).queryNode, parseTop(expression, modifiers))
    });
  }
  union(expression) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithSetOperations(__privateGet(this, _props15).queryNode, parseSetOperations("union", expression, false))
    });
  }
  unionAll(expression) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithSetOperations(__privateGet(this, _props15).queryNode, parseSetOperations("union", expression, true))
    });
  }
  intersect(expression) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithSetOperations(__privateGet(this, _props15).queryNode, parseSetOperations("intersect", expression, false))
    });
  }
  intersectAll(expression) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithSetOperations(__privateGet(this, _props15).queryNode, parseSetOperations("intersect", expression, true))
    });
  }
  except(expression) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithSetOperations(__privateGet(this, _props15).queryNode, parseSetOperations("except", expression, false))
    });
  }
  exceptAll(expression) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithSetOperations(__privateGet(this, _props15).queryNode, parseSetOperations("except", expression, true))
    });
  }
  as(alias) {
    return new AliasedSelectQueryBuilderImpl(this, alias);
  }
  clearSelect() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithoutSelections(__privateGet(this, _props15).queryNode)
    });
  }
  clearWhere() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithoutWhere(__privateGet(this, _props15).queryNode)
    });
  }
  clearLimit() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithoutLimit(__privateGet(this, _props15).queryNode)
    });
  }
  clearOffset() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithoutOffset(__privateGet(this, _props15).queryNode)
    });
  }
  clearOrderBy() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithoutOrderBy(__privateGet(this, _props15).queryNode)
    });
  }
  clearGroupBy() {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: SelectQueryNode.cloneWithoutGroupBy(__privateGet(this, _props15).queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15)
    });
  }
  $castTo() {
    return new _SelectQueryBuilderImpl(__privateGet(this, _props15));
  }
  $narrowType() {
    return new _SelectQueryBuilderImpl(__privateGet(this, _props15));
  }
  $assertType() {
    return new _SelectQueryBuilderImpl(__privateGet(this, _props15));
  }
  $asTuple() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  withPlugin(plugin) {
    return new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      executor: __privateGet(this, _props15).executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return __privateGet(this, _props15).executor.transformQuery(__privateGet(this, _props15).queryNode, __privateGet(this, _props15).queryId);
  }
  compile() {
    return __privateGet(this, _props15).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props15).queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await __privateGet(this, _props15).executor.executeQuery(compiledQuery, __privateGet(this, _props15).queryId);
    return result.rows;
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === void 0) {
      const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error;
    }
    return result;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream = __privateGet(this, _props15).executor.stream(compiledQuery, chunkSize, __privateGet(this, _props15).queryId);
    for await (const item of stream) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new _SelectQueryBuilderImpl({
      ...__privateGet(this, _props15),
      queryNode: QueryNode.cloneWithExplain(__privateGet(this, _props15).queryNode, format, options)
    });
    return await builder.execute();
  }
};
_props15 = new WeakMap();
var SelectQueryBuilderImpl = _SelectQueryBuilderImpl;
preventAwait(SelectQueryBuilderImpl, "don't await SelectQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");
function createSelectQueryBuilder(props) {
  return new SelectQueryBuilderImpl(props);
}
var _queryBuilder, _alias2;
var AliasedSelectQueryBuilderImpl = class {
  constructor(queryBuilder, alias) {
    __privateAdd(this, _queryBuilder);
    __privateAdd(this, _alias2);
    __privateSet(this, _queryBuilder, queryBuilder);
    __privateSet(this, _alias2, alias);
  }
  get expression() {
    return __privateGet(this, _queryBuilder);
  }
  get alias() {
    return __privateGet(this, _alias2);
  }
  get isAliasedSelectQueryBuilder() {
    return true;
  }
  toOperationNode() {
    return AliasNode.create(__privateGet(this, _queryBuilder).toOperationNode(), IdentifierNode.create(__privateGet(this, _alias2)));
  }
};
_queryBuilder = new WeakMap();
_alias2 = new WeakMap();
preventAwait(AliasedSelectQueryBuilderImpl, "don't await AliasedSelectQueryBuilder instances directly. AliasedSelectQueryBuilder should never be executed directly since it's always a part of another query.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/aggregate-function-node.js
var AggregateFunctionNode = freeze({
  is(node) {
    return node.kind === "AggregateFunctionNode";
  },
  create(aggregateFunction, aggregated = []) {
    return freeze({
      kind: "AggregateFunctionNode",
      func: aggregateFunction,
      aggregated
    });
  },
  cloneWithDistinct(aggregateFunctionNode) {
    return freeze({
      ...aggregateFunctionNode,
      distinct: true
    });
  },
  cloneWithOrderBy(aggregateFunctionNode, orderItems) {
    return freeze({
      ...aggregateFunctionNode,
      orderBy: aggregateFunctionNode.orderBy ? OrderByNode.cloneWithItems(aggregateFunctionNode.orderBy, orderItems) : OrderByNode.create(orderItems)
    });
  },
  cloneWithFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "And", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOrFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "Or", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOver(aggregateFunctionNode, over) {
    return freeze({
      ...aggregateFunctionNode,
      over
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/function-node.js
var FunctionNode = freeze({
  is(node) {
    return node.kind === "FunctionNode";
  },
  create(func, args) {
    return freeze({
      kind: "FunctionNode",
      func,
      arguments: args
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/aggregate-function-builder.js
var _props16;
var _AggregateFunctionBuilder = class _AggregateFunctionBuilder {
  constructor(props) {
    __privateAdd(this, _props16);
    __privateSet(this, _props16, freeze(props));
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  /**
   * Returns an aliased version of the function.
   *
   * In addition to slapping `as "the_alias"` to the end of the SQL,
   * this method also provides strict typing:
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.count<number>('id').as('person_count')
   *   )
   *   .executeTakeFirstOrThrow()
   *
   * // `person_count: number` field exists in the result type.
   * console.log(result.person_count)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select count("id") as "person_count"
   * from "person"
   * ```
   */
  as(alias) {
    return new AliasedAggregateFunctionBuilder(this, alias);
  }
  /**
   * Adds a `distinct` clause inside the function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select((eb) =>
   *     eb.fn.count<number>('first_name').distinct().as('first_name_count')
   *   )
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select count(distinct "first_name") as "first_name_count"
   * from "person"
   * ```
   */
  distinct() {
    return new _AggregateFunctionBuilder({
      ...__privateGet(this, _props16),
      aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(__privateGet(this, _props16).aggregateFunctionNode)
    });
  }
  /**
   * Adds an `order by` clause inside the aggregate function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .select((eb) =>
   *     eb.fn.jsonAgg('pet').orderBy('pet.name').as('person_pets')
   *   )
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select json_agg("pet" order by "pet"."name") as "person_pets"
   * from "person"
   * inner join "pet" ON "pet"."owner_id" = "person"."id"
   * ```
   */
  orderBy(orderBy, direction) {
    return new _AggregateFunctionBuilder({
      ...__privateGet(this, _props16),
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOrderBy(__privateGet(this, _props16).aggregateFunctionNode, parseOrderBy([orderBy, direction]))
    });
  }
  filterWhere(...args) {
    return new _AggregateFunctionBuilder({
      ...__privateGet(this, _props16),
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(__privateGet(this, _props16).aggregateFunctionNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Adds a `filter` clause with a nested `where` clause after the function, where
   * both sides of the operator are references to columns.
   *
   * Similar to {@link WhereInterface}'s `whereRef` method.
   *
   * ### Examples
   *
   * Count people with same first and last names versus general public:
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select((eb) => [
   *     eb.fn
   *       .count<number>('id')
   *       .filterWhereRef('first_name', '=', 'last_name')
   *       .as('repeat_name_count'),
   *     eb.fn.count<number>('id').as('total_count'),
   *   ])
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select
   *   count("id") filter(where "first_name" = "last_name") as "repeat_name_count",
   *   count("id") as "total_count"
   * from "person"
   * ```
   */
  filterWhereRef(lhs, op, rhs) {
    return new _AggregateFunctionBuilder({
      ...__privateGet(this, _props16),
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(__privateGet(this, _props16).aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  /**
   * Adds an `over` clause (window functions) after the function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over().as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over() as "average_age"
   * from "person"
   * ```
   *
   * Also supports passing a callback that returns an over builder,
   * allowing to add partition by and sort by clauses inside over.
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over(
   *       ob => ob.partitionBy('last_name').orderBy('first_name', 'asc')
   *     ).as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over(partition by "last_name" order by "first_name" asc) as "average_age"
   * from "person"
   * ```
   */
  over(over) {
    const builder = createOverBuilder();
    return new _AggregateFunctionBuilder({
      ...__privateGet(this, _props16),
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(__privateGet(this, _props16).aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode())
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  /**
   * Casts the expression to the given type.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `AggregateFunctionBuilder` with a new output type.
   */
  $castTo() {
    return new _AggregateFunctionBuilder(__privateGet(this, _props16));
  }
  /**
   * Omit null from the expression's type.
   *
   * This function can be useful in cases where you know an expression can't be
   * null, but Kysely is unable to infer it.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of `this` with a new output type.
   */
  $notNull() {
    return new _AggregateFunctionBuilder(__privateGet(this, _props16));
  }
  toOperationNode() {
    return __privateGet(this, _props16).aggregateFunctionNode;
  }
};
_props16 = new WeakMap();
var AggregateFunctionBuilder = _AggregateFunctionBuilder;
preventAwait(AggregateFunctionBuilder, "don't await AggregateFunctionBuilder instances. They are never executed directly and are always just a part of a query.");
var _aggregateFunctionBuilder, _alias3;
var AliasedAggregateFunctionBuilder = class {
  constructor(aggregateFunctionBuilder, alias) {
    __privateAdd(this, _aggregateFunctionBuilder);
    __privateAdd(this, _alias3);
    __privateSet(this, _aggregateFunctionBuilder, aggregateFunctionBuilder);
    __privateSet(this, _alias3, alias);
  }
  /** @private */
  get expression() {
    return __privateGet(this, _aggregateFunctionBuilder);
  }
  /** @private */
  get alias() {
    return __privateGet(this, _alias3);
  }
  toOperationNode() {
    return AliasNode.create(__privateGet(this, _aggregateFunctionBuilder).toOperationNode(), IdentifierNode.create(__privateGet(this, _alias3)));
  }
};
_aggregateFunctionBuilder = new WeakMap();
_alias3 = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/function-module.js
function createFunctionModule() {
  const fn = (name, args) => {
    return new ExpressionWrapper(FunctionNode.create(name, parseReferenceExpressionOrList(args != null ? args : [])));
  };
  const agg = (name, args) => {
    return new AggregateFunctionBuilder({
      aggregateFunctionNode: AggregateFunctionNode.create(name, args ? parseReferenceExpressionOrList(args) : void 0)
    });
  };
  return Object.assign(fn, {
    agg,
    avg(column) {
      return agg("avg", [column]);
    },
    coalesce(...values) {
      return fn("coalesce", values);
    },
    count(column) {
      return agg("count", [column]);
    },
    countAll(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("count", parseSelectAll(table))
      });
    },
    max(column) {
      return agg("max", [column]);
    },
    min(column) {
      return agg("min", [column]);
    },
    sum(column) {
      return agg("sum", [column]);
    },
    any(column) {
      return fn("any", [column]);
    },
    jsonAgg(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("json_agg", [
          isString(table) ? parseTable(table) : table.toOperationNode()
        ])
      });
    },
    toJson(table) {
      return new ExpressionWrapper(FunctionNode.create("to_json", [
        isString(table) ? parseTable(table) : table.toOperationNode()
      ]));
    }
  });
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/unary-operation-node.js
var UnaryOperationNode = freeze({
  is(node) {
    return node.kind === "UnaryOperationNode";
  },
  create(operator, operand) {
    return freeze({
      kind: "UnaryOperationNode",
      operator,
      operand
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/unary-operation-parser.js
function parseUnaryOperation(operator, operand) {
  return UnaryOperationNode.create(OperatorNode.create(operator), parseReferenceExpression(operand));
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/case-node.js
var CaseNode = freeze({
  is(node) {
    return node.kind === "CaseNode";
  },
  create(value) {
    return freeze({
      kind: "CaseNode",
      value
    });
  },
  cloneWithWhen(caseNode, when) {
    return freeze({
      ...caseNode,
      when: freeze(caseNode.when ? [...caseNode.when, when] : [when])
    });
  },
  cloneWithThen(caseNode, then) {
    return freeze({
      ...caseNode,
      when: caseNode.when ? freeze([
        ...caseNode.when.slice(0, -1),
        WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then)
      ]) : void 0
    });
  },
  cloneWith(caseNode, props) {
    return freeze({
      ...caseNode,
      ...props
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/case-builder.js
var _props17;
var CaseBuilder = class {
  constructor(props) {
    __privateAdd(this, _props17);
    __privateSet(this, _props17, freeze(props));
  }
  when(...args) {
    return new CaseThenBuilder({
      ...__privateGet(this, _props17),
      node: CaseNode.cloneWithWhen(__privateGet(this, _props17).node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
};
_props17 = new WeakMap();
var _props18;
var CaseThenBuilder = class {
  constructor(props) {
    __privateAdd(this, _props18);
    __privateSet(this, _props18, freeze(props));
  }
  then(valueExpression) {
    return new CaseWhenBuilder({
      ...__privateGet(this, _props18),
      node: CaseNode.cloneWithThen(__privateGet(this, _props18).node, isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression))
    });
  }
};
_props18 = new WeakMap();
var _props19;
var CaseWhenBuilder = class {
  constructor(props) {
    __privateAdd(this, _props19);
    __privateSet(this, _props19, freeze(props));
  }
  when(...args) {
    return new CaseThenBuilder({
      ...__privateGet(this, _props19),
      node: CaseNode.cloneWithWhen(__privateGet(this, _props19).node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
  else(valueExpression) {
    return new CaseEndBuilder({
      ...__privateGet(this, _props19),
      node: CaseNode.cloneWith(__privateGet(this, _props19).node, {
        else: isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression)
      })
    });
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(__privateGet(this, _props19).node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(__privateGet(this, _props19).node, { isStatement: true }));
  }
};
_props19 = new WeakMap();
var _props20;
var CaseEndBuilder = class {
  constructor(props) {
    __privateAdd(this, _props20);
    __privateSet(this, _props20, freeze(props));
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(__privateGet(this, _props20).node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(__privateGet(this, _props20).node, { isStatement: true }));
  }
};
_props20 = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/json-path-leg-node.js
var JSONPathLegNode = freeze({
  is(node) {
    return node.kind === "JSONPathLegNode";
  },
  create(type, value) {
    return freeze({
      kind: "JSONPathLegNode",
      type,
      value
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-builder/json-path-builder.js
var _node4, _JSONPathBuilder_instances, createBuilderWithPathLeg_fn;
var JSONPathBuilder = class {
  constructor(node) {
    __privateAdd(this, _JSONPathBuilder_instances);
    __privateAdd(this, _node4);
    __privateSet(this, _node4, node);
  }
  /**
   * Access an element of a JSON array in a specific location.
   *
   * Since there's no guarantee an element exists in the given array location, the
   * resulting type is always nullable. If you're sure the element exists, you
   * should use {@link SelectQueryBuilder.$assertType} to narrow the type safely.
   *
   * See also {@link key} to access properties of JSON objects.
   *
   * ### Examples
   *
   * ```ts
   * await db.selectFrom('person')
   *   .select(eb =>
   *     eb.ref('nicknames', '->').at(0).as('primary_nickname')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "nicknames"->0 as "primary_nickname" from "person"
   *```
   *
   * Combined with {@link key}:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('experience', '->').at(0).key('role').as('first_role')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "experience"->0->'role' as "first_role" from "person"
   * ```
   *
   * You can use `'last'` to access the last element of the array in MySQL:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->$').at('last').as('last_nickname')
   * )
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * select `nicknames`->'$[last]' as `last_nickname` from `person`
   * ```
   *
   * Or `'#-1'` in SQLite:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->>$').at('#-1').as('last_nickname')
   * )
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * select "nicknames"->>'$[#-1]' as `last_nickname` from `person`
   * ```
   */
  at(index) {
    return __privateMethod(this, _JSONPathBuilder_instances, createBuilderWithPathLeg_fn).call(this, "ArrayLocation", index);
  }
  /**
   * Access a property of a JSON object.
   *
   * If a field is optional, the resulting type will be nullable.
   *
   * See also {@link at} to access elements of JSON arrays.
   *
   * ### Examples
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('address', '->').key('city').as('city')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "address"->'city' as "city" from "person"
   * ```
   *
   * Going deeper:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('profile', '->$').key('website').key('url').as('website_url')
   * )
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * select `profile`->'$.website.url' as `website_url` from `person`
   * ```
   *
   * Combined with {@link at}:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('profile', '->').key('addresses').at(0).key('city').as('city')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "profile"->'addresses'->0->'city' as "city" from "person"
   * ```
   */
  key(key) {
    return __privateMethod(this, _JSONPathBuilder_instances, createBuilderWithPathLeg_fn).call(this, "Member", key);
  }
};
_node4 = new WeakMap();
_JSONPathBuilder_instances = new WeakSet();
createBuilderWithPathLeg_fn = function(legType, value) {
  if (JSONReferenceNode.is(__privateGet(this, _node4))) {
    return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(__privateGet(this, _node4), JSONPathNode.is(__privateGet(this, _node4).traversal) ? JSONPathNode.cloneWithLeg(__privateGet(this, _node4).traversal, JSONPathLegNode.create(legType, value)) : JSONOperatorChainNode.cloneWithValue(__privateGet(this, _node4).traversal, ValueNode.createImmediate(value))));
  }
  return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(__privateGet(this, _node4), JSONPathLegNode.create(legType, value)));
};
var _node5;
var _TraversedJSONPathBuilder = class _TraversedJSONPathBuilder extends JSONPathBuilder {
  constructor(node) {
    super(node);
    __privateAdd(this, _node5);
    __privateSet(this, _node5, node);
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias) {
    return new AliasedJSONPathBuilder(this, alias);
  }
  /**
   * Change the output type of the json path.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `JSONPathBuilder` with a new output type.
   */
  $castTo() {
    return new _TraversedJSONPathBuilder(__privateGet(this, _node5));
  }
  $notNull() {
    return new _TraversedJSONPathBuilder(__privateGet(this, _node5));
  }
  toOperationNode() {
    return __privateGet(this, _node5);
  }
};
_node5 = new WeakMap();
var TraversedJSONPathBuilder = _TraversedJSONPathBuilder;
var _jsonPath, _alias4;
var AliasedJSONPathBuilder = class {
  constructor(jsonPath, alias) {
    __privateAdd(this, _jsonPath);
    __privateAdd(this, _alias4);
    __privateSet(this, _jsonPath, jsonPath);
    __privateSet(this, _alias4, alias);
  }
  /** @private */
  get expression() {
    return __privateGet(this, _jsonPath);
  }
  /** @private */
  get alias() {
    return __privateGet(this, _alias4);
  }
  toOperationNode() {
    return AliasNode.create(__privateGet(this, _jsonPath).toOperationNode(), isOperationNodeSource(__privateGet(this, _alias4)) ? __privateGet(this, _alias4).toOperationNode() : IdentifierNode.create(__privateGet(this, _alias4)));
  }
};
_jsonPath = new WeakMap();
_alias4 = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/tuple-node.js
var TupleNode = freeze({
  is(node) {
    return node.kind === "TupleNode";
  },
  create(values) {
    return freeze({
      kind: "TupleNode",
      values: freeze(values)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/data-type-node.js
var SIMPLE_COLUMN_DATA_TYPES = [
  "varchar",
  "char",
  "text",
  "integer",
  "int2",
  "int4",
  "int8",
  "smallint",
  "bigint",
  "boolean",
  "real",
  "double precision",
  "float4",
  "float8",
  "decimal",
  "numeric",
  "binary",
  "bytea",
  "date",
  "datetime",
  "time",
  "timetz",
  "timestamp",
  "timestamptz",
  "serial",
  "bigserial",
  "uuid",
  "json",
  "jsonb",
  "blob",
  "varbinary",
  "int4range",
  "int4multirange",
  "int8range",
  "int8multirange",
  "numrange",
  "nummultirange",
  "tsrange",
  "tsmultirange",
  "tstzrange",
  "tstzmultirange",
  "daterange",
  "datemultirange"
];
var COLUMN_DATA_TYPE_REGEX = [
  /^varchar\(\d+\)$/,
  /^char\(\d+\)$/,
  /^decimal\(\d+, \d+\)$/,
  /^numeric\(\d+, \d+\)$/,
  /^binary\(\d+\)$/,
  /^datetime\(\d+\)$/,
  /^time\(\d+\)$/,
  /^timetz\(\d+\)$/,
  /^timestamp\(\d+\)$/,
  /^timestamptz\(\d+\)$/,
  /^varbinary\(\d+\)$/
];
var DataTypeNode = freeze({
  is(node) {
    return node.kind === "DataTypeNode";
  },
  create(dataType) {
    return freeze({
      kind: "DataTypeNode",
      dataType
    });
  }
});
function isColumnDataType(dataType) {
  if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType)) {
    return true;
  }
  if (COLUMN_DATA_TYPE_REGEX.some((r) => r.test(dataType))) {
    return true;
  }
  return false;
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/data-type-parser.js
function parseDataTypeExpression(dataType) {
  if (isOperationNodeSource(dataType)) {
    return dataType.toOperationNode();
  }
  if (isColumnDataType(dataType)) {
    return DataTypeNode.create(dataType);
  }
  throw new Error(`invalid column data type ${JSON.stringify(dataType)}`);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/cast-node.js
var CastNode = freeze({
  is(node) {
    return node.kind === "CastNode";
  },
  create(expression, dataType) {
    return freeze({
      kind: "CastNode",
      expression,
      dataType
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/expression/expression-builder.js
function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
  function binary(lhs, op, rhs) {
    return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
  }
  function unary(op, expr) {
    return new ExpressionWrapper(parseUnaryOperation(op, expr));
  }
  const eb = Object.assign(binary, {
    fn: void 0,
    eb: void 0,
    selectFrom(table) {
      return createSelectQueryBuilder({
        queryId: createQueryId(),
        executor,
        queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table))
      });
    },
    case(reference) {
      return new CaseBuilder({
        node: CaseNode.create(isUndefined(reference) ? void 0 : parseReferenceExpression(reference))
      });
    },
    ref(reference, op) {
      if (isUndefined(op)) {
        return new ExpressionWrapper(parseStringReference(reference));
      }
      return new JSONPathBuilder(parseJSONReference(reference, op));
    },
    jsonPath() {
      return new JSONPathBuilder(JSONPathNode.create());
    },
    table(table) {
      return new ExpressionWrapper(parseTable(table));
    },
    val(value) {
      return new ExpressionWrapper(parseValueExpression(value));
    },
    refTuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseReferenceExpression)));
    },
    tuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseValueExpression)));
    },
    lit(value) {
      return new ExpressionWrapper(parseSafeImmediateValue(value));
    },
    unary,
    not(expr) {
      return unary("not", expr);
    },
    exists(expr) {
      return unary("exists", expr);
    },
    neg(expr) {
      return unary("-", expr);
    },
    between(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    betweenSymmetric(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between symmetric"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    and(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "and"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "and"));
    },
    or(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "or"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "or"));
    },
    parens(...args) {
      const node = parseValueBinaryOperationOrExpression(args);
      if (ParensNode.is(node)) {
        return new ExpressionWrapper(node);
      } else {
        return new ExpressionWrapper(ParensNode.create(node));
      }
    },
    cast(expr, dataType) {
      return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType)));
    },
    withSchema(schema) {
      return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema)));
    }
  });
  eb.fn = createFunctionModule();
  eb.eb = eb;
  return eb;
}
function expressionBuilder(_) {
  return createExpressionBuilder();
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/expression-parser.js
function parseExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid expression: ${JSON.stringify(exp)}`);
}
function parseAliasedExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);
}
function isExpressionOrFactory(obj) {
  return isExpression(obj) || isAliasedExpression(obj) || isFunction(obj);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/table-parser.js
function parseTableExpressionOrList(table) {
  if (isReadonlyArray(table)) {
    return table.map((it) => parseTableExpression(it));
  } else {
    return [parseTableExpression(table)];
  }
}
function parseTableExpression(table) {
  if (isString(table)) {
    return parseAliasedTable(table);
  } else {
    return parseAliasedExpression(table);
  }
}
function parseAliasedTable(from) {
  const ALIAS_SEPARATOR = " as ";
  if (from.includes(ALIAS_SEPARATOR)) {
    const [table, alias] = from.split(ALIAS_SEPARATOR).map(trim2);
    return AliasNode.create(parseTable(table), IdentifierNode.create(alias));
  } else {
    return parseTable(from);
  }
}
function parseTable(from) {
  const SCHEMA_SEPARATOR = ".";
  if (from.includes(SCHEMA_SEPARATOR)) {
    const [schema, table] = from.split(SCHEMA_SEPARATOR).map(trim2);
    return TableNode.createWithSchema(schema, table);
  } else {
    return TableNode.create(from);
  }
}
function trim2(str) {
  return str.trim();
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/add-column-node.js
var AddColumnNode = freeze({
  is(node) {
    return node.kind === "AddColumnNode";
  },
  create(column) {
    return freeze({
      kind: "AddColumnNode",
      column
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/column-definition-node.js
var ColumnDefinitionNode = freeze({
  is(node) {
    return node.kind === "ColumnDefinitionNode";
  },
  create(column, dataType) {
    return freeze({
      kind: "ColumnDefinitionNode",
      column: ColumnNode.create(column),
      dataType
    });
  },
  cloneWithFrontModifier(node, modifier) {
    return freeze({
      ...node,
      frontModifiers: node.frontModifiers ? freeze([...node.frontModifiers, modifier]) : [modifier]
    });
  },
  cloneWithEndModifier(node, modifier) {
    return freeze({
      ...node,
      endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : [modifier]
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/drop-column-node.js
var DropColumnNode = freeze({
  is(node) {
    return node.kind === "DropColumnNode";
  },
  create(column) {
    return freeze({
      kind: "DropColumnNode",
      column: ColumnNode.create(column)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/rename-column-node.js
var RenameColumnNode = freeze({
  is(node) {
    return node.kind === "RenameColumnNode";
  },
  create(column, newColumn) {
    return freeze({
      kind: "RenameColumnNode",
      column: ColumnNode.create(column),
      renameTo: ColumnNode.create(newColumn)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/check-constraint-node.js
var CheckConstraintNode = freeze({
  is(node) {
    return node.kind === "CheckConstraintNode";
  },
  create(expression, constraintName) {
    return freeze({
      kind: "CheckConstraintNode",
      expression,
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/references-node.js
var ON_MODIFY_FOREIGN_ACTIONS = [
  "no action",
  "restrict",
  "cascade",
  "set null",
  "set default"
];
var ReferencesNode = freeze({
  is(node) {
    return node.kind === "ReferencesNode";
  },
  create(table, columns) {
    return freeze({
      kind: "ReferencesNode",
      table,
      columns: freeze([...columns])
    });
  },
  cloneWithOnDelete(references, onDelete) {
    return freeze({
      ...references,
      onDelete
    });
  },
  cloneWithOnUpdate(references, onUpdate) {
    return freeze({
      ...references,
      onUpdate
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/default-value-parser.js
function parseDefaultValueExpression(value) {
  return isOperationNodeSource(value) ? value.toOperationNode() : ValueNode.createImmediate(value);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/generated-node.js
var GeneratedNode = freeze({
  is(node) {
    return node.kind === "GeneratedNode";
  },
  create(params) {
    return freeze({
      kind: "GeneratedNode",
      ...params
    });
  },
  createWithExpression(expression) {
    return freeze({
      kind: "GeneratedNode",
      always: true,
      expression
    });
  },
  cloneWith(node, params) {
    return freeze({
      ...node,
      ...params
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/default-value-node.js
var DefaultValueNode = freeze({
  is(node) {
    return node.kind === "DefaultValueNode";
  },
  create(defaultValue) {
    return freeze({
      kind: "DefaultValueNode",
      defaultValue
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/on-modify-action-parser.js
function parseOnModifyForeignAction(action) {
  if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnModifyForeignAction ${action}`);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/column-definition-builder.js
var _node6;
var _ColumnDefinitionBuilder = class _ColumnDefinitionBuilder {
  constructor(node) {
    __privateAdd(this, _node6);
    __privateSet(this, _node6, node);
  }
  /**
   * Adds `auto_increment` or `autoincrement` to the column definition
   * depending on the dialect.
   *
   * Some dialects like PostgreSQL don't support this. On PostgreSQL
   * you can use the `serial` or `bigserial` data type instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.autoIncrement().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key auto_increment
   * )
   * ```
   */
  autoIncrement() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), { autoIncrement: true }));
  }
  /**
   * Makes the column an identity column.
   *
   * This only works on some dialects like MS SQL Server (MSSQL).
   *
   * For PostgreSQL's `generated always as identity` use {@link generatedAlwaysAsIdentity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.identity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MSSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer identity primary key
   * )
   * ```
   */
  identity() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), { identity: true }));
  }
  /**
   * Makes the column the primary key.
   *
   * If you want to specify a composite primary key use the
   * {@link CreateTableBuilder.addPrimaryKeyConstraint} method.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key
   * )
   */
  primaryKey() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), { primaryKey: true }));
  }
  /**
   * Adds a foreign key constraint for the column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id', 'integer', (col) => col.references('person.id'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id")
   * )
   * ```
   */
  references(ref) {
    const references = parseStringReference(ref);
    if (!references.table || SelectAllNode.is(references.column)) {
      throw new Error(`invalid call references('${ref}'). The reference must have format table.column or schema.table.column`);
    }
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      references: ReferencesNode.create(references.table, [
        references.column
      ])
    }));
  }
  /**
   * Adds an `on delete` constraint for the foreign key column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'owner_id',
   *     'integer',
   *     (col) => col.references('person.id').onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id") on delete cascade
   * )
   * ```
   */
  onDelete(onDelete) {
    if (!__privateGet(this, _node6).references) {
      throw new Error("on delete constraint can only be added for foreign keys");
    }
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      references: ReferencesNode.cloneWithOnDelete(__privateGet(this, _node6).references, parseOnModifyForeignAction(onDelete))
    }));
  }
  /**
   * Adds an `on update` constraint for the foreign key column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'owner_id',
   *     'integer',
   *     (col) => col.references('person.id').onUpdate('cascade')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id") on update cascade
   * )
   * ```
   */
  onUpdate(onUpdate) {
    if (!__privateGet(this, _node6).references) {
      throw new Error("on update constraint can only be added for foreign keys");
    }
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      references: ReferencesNode.cloneWithOnUpdate(__privateGet(this, _node6).references, parseOnModifyForeignAction(onUpdate))
    }));
  }
  /**
   * Adds a unique constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('email', 'varchar(255)', col => col.unique())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `email` varchar(255) unique
   * )
   * ```
   */
  unique() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), { unique: true }));
  }
  /**
   * Adds a `not null` constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(255)', col => col.notNull())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `first_name` varchar(255) not null
   * )
   * ```
   */
  notNull() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), { notNull: true }));
  }
  /**
   * Adds a `unsigned` modifier for the column.
   *
   * This only works on some dialects like MySQL.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('age', 'integer', col => col.unsigned())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `age` integer unsigned
   * )
   * ```
   */
  unsigned() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), { unsigned: true }));
  }
  /**
   * Adds a default value constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('number_of_legs', 'integer', (col) => col.defaultTo(4))
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `number_of_legs` integer default 4
   * )
   * ```
   *
   * Values passed to `defaultTo` are interpreted as value literals by default. You can define
   * an arbitrary SQL expression using the {@link sql} template tag:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'created_at',
   *     'timestamp',
   *     (col) => col.defaultTo(sql`CURRENT_TIMESTAMP`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `created_at` timestamp default CURRENT_TIMESTAMP
   * )
   * ```
   */
  defaultTo(value) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value))
    }));
  }
  /**
   * Adds a check constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('number_of_legs', 'integer', (col) =>
   *     col.check(sql`number_of_legs < 5`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `number_of_legs` integer check (number_of_legs < 5)
   * )
   * ```
   */
  check(expression) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      check: CheckConstraintNode.create(expression.toOperationNode())
    }));
  }
  /**
   * Makes the column a generated column using a `generated always as` statement.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('full_name', 'varchar(255)',
   *     (col) => col.generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name))
   * )
   * ```
   */
  generatedAlwaysAs(expression) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      generated: GeneratedNode.createWithExpression(expression.toOperationNode())
    }));
  }
  /**
   * Adds the `generated always as identity` specifier.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.generatedAlwaysAsIdentity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer generated always as identity primary key
   * )
   * ```
   */
  generatedAlwaysAsIdentity() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      generated: GeneratedNode.create({ identity: true, always: true })
    }));
  }
  /**
   * Adds the `generated by default as identity` specifier on supported dialects.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.generatedByDefaultAsIdentity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer generated by default as identity primary key
   * )
   * ```
   */
  generatedByDefaultAsIdentity() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      generated: GeneratedNode.create({ identity: true, byDefault: true })
    }));
  }
  /**
   * Makes a generated column stored instead of virtual. This method can only
   * be used with {@link generatedAlwaysAs}
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('full_name', 'varchar(255)', (col) => col
   *     .generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
   *     .stored()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name)) stored
   * )
   * ```
   */
  stored() {
    if (!__privateGet(this, _node6).generated) {
      throw new Error("stored() can only be called after generatedAlwaysAs");
    }
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), {
      generated: GeneratedNode.cloneWith(__privateGet(this, _node6).generated, {
        stored: true
      })
    }));
  }
  /**
   * This can be used to add any additional SQL right after the column's data type.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn(
   *     'first_name',
   *     'varchar(36)',
   *     (col) => col.modifyFront(sql`collate utf8mb4_general_ci`).notNull()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `first_name` varchar(36) collate utf8mb4_general_ci not null
   * )
   * ```
   */
  modifyFront(modifier) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(__privateGet(this, _node6), modifier.toOperationNode()));
  }
  /**
   * Adds `nulls not distinct` specifier.
   * Should be used with `unique` constraint.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(30)', col => col.unique().nullsNotDistinct())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer primary key,
   *   "first_name" varchar(30) unique nulls not distinct
   * )
   * ```
   */
  nullsNotDistinct() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), { nullsNotDistinct: true }));
  }
  /**
   * Adds `if not exists` specifier. This only works for PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addColumn('email', 'varchar(255)', col => col.unique().ifNotExists())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * alter table "person" add column if not exists "email" varchar(255) unique
   * ```
   */
  ifNotExists() {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(__privateGet(this, _node6), { ifNotExists: true }));
  }
  /**
   * This can be used to add any additional SQL to the end of the column definition.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn(
   *     'age',
   *     'integer',
   *     col => col.unsigned()
   *       .notNull()
   *       .modifyEnd(sql`comment ${sql.lit('it is not polite to ask a woman her age')}`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `age` integer unsigned not null comment 'it is not polite to ask a woman her age'
   * )
   * ```
   */
  modifyEnd(modifier) {
    return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(__privateGet(this, _node6), modifier.toOperationNode()));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _node6);
  }
};
_node6 = new WeakMap();
var ColumnDefinitionBuilder = _ColumnDefinitionBuilder;
preventAwait(ColumnDefinitionBuilder, "don't await ColumnDefinitionBuilder instances directly.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/modify-column-node.js
var ModifyColumnNode = freeze({
  is(node) {
    return node.kind === "ModifyColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ModifyColumnNode",
      column
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/foreign-key-constraint-node.js
var ForeignKeyConstraintNode = freeze({
  is(node) {
    return node.kind === "ForeignKeyConstraintNode";
  },
  create(sourceColumns, targetTable, targetColumns, constraintName) {
    return freeze({
      kind: "ForeignKeyConstraintNode",
      columns: sourceColumns,
      references: ReferencesNode.create(targetTable, targetColumns),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/foreign-key-constraint-builder.js
var _node7;
var _ForeignKeyConstraintBuilder = class _ForeignKeyConstraintBuilder {
  constructor(node) {
    __privateAdd(this, _node7);
    __privateSet(this, _node7, node);
  }
  onDelete(onDelete) {
    return new _ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(__privateGet(this, _node7), {
      onDelete: parseOnModifyForeignAction(onDelete)
    }));
  }
  onUpdate(onUpdate) {
    return new _ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(__privateGet(this, _node7), {
      onUpdate: parseOnModifyForeignAction(onUpdate)
    }));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _node7);
  }
};
_node7 = new WeakMap();
var ForeignKeyConstraintBuilder = _ForeignKeyConstraintBuilder;
preventAwait(ForeignKeyConstraintBuilder, "don't await ForeignKeyConstraintBuilder instances directly.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/add-constraint-node.js
var AddConstraintNode = freeze({
  is(node) {
    return node.kind === "AddConstraintNode";
  },
  create(constraint) {
    return freeze({
      kind: "AddConstraintNode",
      constraint
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/unique-constraint-node.js
var UniqueConstraintNode = freeze({
  is(node) {
    return node.kind === "UniqueConstraintNode";
  },
  create(columns, constraintName, nullsNotDistinct) {
    return freeze({
      kind: "UniqueConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0,
      nullsNotDistinct
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/drop-constraint-node.js
var DropConstraintNode = freeze({
  is(node) {
    return node.kind === "DropConstraintNode";
  },
  create(constraintName) {
    return freeze({
      kind: "DropConstraintNode",
      constraintName: IdentifierNode.create(constraintName)
    });
  },
  cloneWith(dropConstraint, props) {
    return freeze({
      ...dropConstraint,
      ...props
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/alter-column-node.js
var AlterColumnNode = freeze({
  is(node) {
    return node.kind === "AlterColumnNode";
  },
  create(column, prop, value) {
    return freeze({
      kind: "AlterColumnNode",
      column: ColumnNode.create(column),
      [prop]: value
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/alter-column-builder.js
var _column;
var AlterColumnBuilder = class {
  constructor(column) {
    __privateAdd(this, _column);
    __privateSet(this, _column, column);
  }
  setDataType(dataType) {
    return new AlteredColumnBuilder(AlterColumnNode.create(__privateGet(this, _column), "dataType", parseDataTypeExpression(dataType)));
  }
  setDefault(value) {
    return new AlteredColumnBuilder(AlterColumnNode.create(__privateGet(this, _column), "setDefault", parseDefaultValueExpression(value)));
  }
  dropDefault() {
    return new AlteredColumnBuilder(AlterColumnNode.create(__privateGet(this, _column), "dropDefault", true));
  }
  setNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(__privateGet(this, _column), "setNotNull", true));
  }
  dropNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(__privateGet(this, _column), "dropNotNull", true));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
};
_column = new WeakMap();
preventAwait(AlterColumnBuilder, "don't await AlterColumnBuilder instances");
var _alterColumnNode;
var AlteredColumnBuilder = class {
  constructor(alterColumnNode) {
    __privateAdd(this, _alterColumnNode);
    __privateSet(this, _alterColumnNode, alterColumnNode);
  }
  toOperationNode() {
    return __privateGet(this, _alterColumnNode);
  }
};
_alterColumnNode = new WeakMap();
preventAwait(AlteredColumnBuilder, "don't await AlteredColumnBuilder instances");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/alter-table-executor.js
var _props21;
var AlterTableExecutor = class {
  constructor(props) {
    __privateAdd(this, _props21);
    __privateSet(this, _props21, freeze(props));
  }
  toOperationNode() {
    return __privateGet(this, _props21).executor.transformQuery(__privateGet(this, _props21).node, __privateGet(this, _props21).queryId);
  }
  compile() {
    return __privateGet(this, _props21).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props21).queryId);
  }
  async execute() {
    await __privateGet(this, _props21).executor.executeQuery(this.compile(), __privateGet(this, _props21).queryId);
  }
};
_props21 = new WeakMap();
preventAwait(AlterTableExecutor, "don't await AlterTableExecutor instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/alter-table-add-foreign-key-constraint-builder.js
var _props22;
var _AlterTableAddForeignKeyConstraintBuilder = class _AlterTableAddForeignKeyConstraintBuilder {
  constructor(props) {
    __privateAdd(this, _props22);
    __privateSet(this, _props22, freeze(props));
  }
  onDelete(onDelete) {
    return new _AlterTableAddForeignKeyConstraintBuilder({
      ...__privateGet(this, _props22),
      constraintBuilder: __privateGet(this, _props22).constraintBuilder.onDelete(onDelete)
    });
  }
  onUpdate(onUpdate) {
    return new _AlterTableAddForeignKeyConstraintBuilder({
      ...__privateGet(this, _props22),
      constraintBuilder: __privateGet(this, _props22).constraintBuilder.onUpdate(onUpdate)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props22).executor.transformQuery(AlterTableNode.cloneWithTableProps(__privateGet(this, _props22).node, {
      addConstraint: AddConstraintNode.create(__privateGet(this, _props22).constraintBuilder.toOperationNode())
    }), __privateGet(this, _props22).queryId);
  }
  compile() {
    return __privateGet(this, _props22).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props22).queryId);
  }
  async execute() {
    await __privateGet(this, _props22).executor.executeQuery(this.compile(), __privateGet(this, _props22).queryId);
  }
};
_props22 = new WeakMap();
var AlterTableAddForeignKeyConstraintBuilder = _AlterTableAddForeignKeyConstraintBuilder;
preventAwait(AlterTableAddForeignKeyConstraintBuilder, "don't await AlterTableAddForeignKeyConstraintBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/alter-table-drop-constraint-builder.js
var _props23;
var _AlterTableDropConstraintBuilder = class _AlterTableDropConstraintBuilder {
  constructor(props) {
    __privateAdd(this, _props23);
    __privateSet(this, _props23, freeze(props));
  }
  ifExists() {
    return new _AlterTableDropConstraintBuilder({
      ...__privateGet(this, _props23),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props23).node, {
        dropConstraint: DropConstraintNode.cloneWith(__privateGet(this, _props23).node.dropConstraint, {
          ifExists: true
        })
      })
    });
  }
  cascade() {
    return new _AlterTableDropConstraintBuilder({
      ...__privateGet(this, _props23),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props23).node, {
        dropConstraint: DropConstraintNode.cloneWith(__privateGet(this, _props23).node.dropConstraint, {
          modifier: "cascade"
        })
      })
    });
  }
  restrict() {
    return new _AlterTableDropConstraintBuilder({
      ...__privateGet(this, _props23),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props23).node, {
        dropConstraint: DropConstraintNode.cloneWith(__privateGet(this, _props23).node.dropConstraint, {
          modifier: "restrict"
        })
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props23).executor.transformQuery(__privateGet(this, _props23).node, __privateGet(this, _props23).queryId);
  }
  compile() {
    return __privateGet(this, _props23).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props23).queryId);
  }
  async execute() {
    await __privateGet(this, _props23).executor.executeQuery(this.compile(), __privateGet(this, _props23).queryId);
  }
};
_props23 = new WeakMap();
var AlterTableDropConstraintBuilder = _AlterTableDropConstraintBuilder;
preventAwait(AlterTableDropConstraintBuilder, "don't await AlterTableDropConstraintBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/primary-constraint-node.js
var PrimaryConstraintNode = freeze({
  is(node) {
    return node.kind === "PrimaryKeyConstraintNode";
  },
  create(columns, constraintName) {
    return freeze({
      kind: "PrimaryKeyConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/add-index-node.js
var AddIndexNode = freeze({
  is(node) {
    return node.kind === "AddIndexNode";
  },
  create(name) {
    return freeze({
      kind: "AddIndexNode",
      name: IdentifierNode.create(name)
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumns(node, columns) {
    return freeze({
      ...node,
      columns: [...node.columns || [], ...columns]
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/alter-table-add-index-builder.js
var _props24;
var _AlterTableAddIndexBuilder = class _AlterTableAddIndexBuilder {
  constructor(props) {
    __privateAdd(this, _props24);
    __privateSet(this, _props24, freeze(props));
  }
  /**
   * Makes the index unique.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_index')
   *   .unique()
   *   .column('email')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add unique index `person_first_name_index` (`email`)
   * ```
   */
  unique() {
    return new _AlterTableAddIndexBuilder({
      ...__privateGet(this, _props24),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props24).node, {
        addIndex: AddIndexNode.cloneWith(__privateGet(this, _props24).node.addIndex, {
          unique: true
        })
      })
    });
  }
  /**
   * Adds a column to the index.
   *
   * Also see {@link columns} for adding multiple columns at once or {@link expression}
   * for specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_and_age_index')
   *   .column('first_name')
   *   .column('age desc')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
   * ```
   */
  column(column) {
    return new _AlterTableAddIndexBuilder({
      ...__privateGet(this, _props24),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props24).node, {
        addIndex: AddIndexNode.cloneWithColumns(__privateGet(this, _props24).node.addIndex, [
          parseOrderedColumnName(column)
        ])
      })
    });
  }
  /**
   * Specifies a list of columns for the index.
   *
   * Also see {@link column} for adding a single column or {@link expression} for
   * specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_and_age_index')
   *   .columns(['first_name', 'age desc'])
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
   * ```
   */
  columns(columns) {
    return new _AlterTableAddIndexBuilder({
      ...__privateGet(this, _props24),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props24).node, {
        addIndex: AddIndexNode.cloneWithColumns(__privateGet(this, _props24).node.addIndex, columns.map(parseOrderedColumnName))
      })
    });
  }
  /**
   * Specifies an arbitrary expression for the index.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_index')
   *   .expression(sql<boolean>`(first_name < 'Sami')`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_index` ((first_name < 'Sami'))
   * ```
   */
  expression(expression) {
    return new _AlterTableAddIndexBuilder({
      ...__privateGet(this, _props24),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props24).node, {
        addIndex: AddIndexNode.cloneWithColumns(__privateGet(this, _props24).node.addIndex, [
          expression.toOperationNode()
        ])
      })
    });
  }
  using(indexType) {
    return new _AlterTableAddIndexBuilder({
      ...__privateGet(this, _props24),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props24).node, {
        addIndex: AddIndexNode.cloneWith(__privateGet(this, _props24).node.addIndex, {
          using: RawNode.createWithSql(indexType)
        })
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props24).executor.transformQuery(__privateGet(this, _props24).node, __privateGet(this, _props24).queryId);
  }
  compile() {
    return __privateGet(this, _props24).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props24).queryId);
  }
  async execute() {
    await __privateGet(this, _props24).executor.executeQuery(this.compile(), __privateGet(this, _props24).queryId);
  }
};
_props24 = new WeakMap();
var AlterTableAddIndexBuilder = _AlterTableAddIndexBuilder;
preventAwait(AlterTableAddIndexBuilder, "don't await AlterTableAddIndexBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/unique-constraint-builder.js
var _node8;
var _UniqueConstraintNodeBuilder = class _UniqueConstraintNodeBuilder {
  constructor(node) {
    __privateAdd(this, _node8);
    __privateSet(this, _node8, node);
  }
  toOperationNode() {
    return __privateGet(this, _node8);
  }
  /**
   * Adds `nulls not distinct` to the unique constraint definition
   *
   * Supported by PostgreSQL dialect only
   */
  nullsNotDistinct() {
    return new _UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(__privateGet(this, _node8), { nullsNotDistinct: true }));
  }
};
_node8 = new WeakMap();
var UniqueConstraintNodeBuilder = _UniqueConstraintNodeBuilder;
preventAwait(UniqueConstraintNodeBuilder, "don't await UniqueConstraintNodeBuilder instances directly.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/alter-table-builder.js
var _props25;
var AlterTableBuilder = class {
  constructor(props) {
    __privateAdd(this, _props25);
    __privateSet(this, _props25, freeze(props));
  }
  renameTo(newTableName) {
    return new AlterTableExecutor({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props25).node, {
        renameTo: parseTable(newTableName)
      })
    });
  }
  setSchema(newSchema) {
    return new AlterTableExecutor({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props25).node, {
        setSchema: IdentifierNode.create(newSchema)
      })
    });
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props25).node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props25).node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props25).node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props25).node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props25).node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  /**
   * See {@link CreateTableBuilder.addUniqueConstraint}
   */
  addUniqueConstraint(constraintName, columns, build = noop) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props25).node, {
        addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode())
      })
    });
  }
  /**
   * See {@link CreateTableBuilder.addCheckConstraint}
   */
  addCheckConstraint(constraintName, checkExpression) {
    return new AlterTableExecutor({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props25).node, {
        addConstraint: AddConstraintNode.create(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName))
      })
    });
  }
  /**
   * See {@link CreateTableBuilder.addForeignKeyConstraint}
   *
   * Unlike {@link CreateTableBuilder.addForeignKeyConstraint} this method returns
   * the constraint builder and doesn't take a callback as the last argument. This
   * is because you can only add one column per `ALTER TABLE` query.
   */
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...__privateGet(this, _props25),
      constraintBuilder: new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName))
    });
  }
  /**
   * See {@link CreateTableBuilder.addPrimaryKeyConstraint}
   */
  addPrimaryKeyConstraint(constraintName, columns) {
    return new AlterTableExecutor({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props25).node, {
        addConstraint: AddConstraintNode.create(PrimaryConstraintNode.create(columns, constraintName))
      })
    });
  }
  dropConstraint(constraintName) {
    return new AlterTableDropConstraintBuilder({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props25).node, {
        dropConstraint: DropConstraintNode.create(constraintName)
      })
    });
  }
  /**
   * This can be used to add index to table.
   *
   *  ### Examples
   *
   * ```ts
   * db.schema.alterTable('person')
   *   .addIndex('person_email_index')
   *   .column('email')
   *   .unique()
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add unique index `person_email_index` (`email`)
   * ```
   */
  addIndex(indexName) {
    return new AlterTableAddIndexBuilder({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props25).node, {
        addIndex: AddIndexNode.create(indexName)
      })
    });
  }
  /**
   * This can be used to drop index from table.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.alterTable('person')
   *   .dropIndex('person_email_index')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` drop index `test_first_name_index`
   * ```
   */
  dropIndex(indexName) {
    return new AlterTableExecutor({
      ...__privateGet(this, _props25),
      node: AlterTableNode.cloneWithTableProps(__privateGet(this, _props25).node, {
        dropIndex: DropIndexNode.create(indexName)
      })
    });
  }
  /**
   * Calls the given function passing `this` as the only argument.
   *
   * See {@link CreateTableBuilder.$call}
   */
  $call(func) {
    return func(this);
  }
};
_props25 = new WeakMap();
preventAwait(AlterTableBuilder, "don't await AlterTableBuilder instances");
var _props26;
var _AlterTableColumnAlteringBuilder = class _AlterTableColumnAlteringBuilder {
  constructor(props) {
    __privateAdd(this, _props26);
    __privateSet(this, _props26, freeze(props));
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new _AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props26),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props26).node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new _AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props26),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props26).node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new _AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props26),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props26).node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new _AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props26),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props26).node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build = noop) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new _AlterTableColumnAlteringBuilder({
      ...__privateGet(this, _props26),
      node: AlterTableNode.cloneWithColumnAlteration(__privateGet(this, _props26).node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  toOperationNode() {
    return __privateGet(this, _props26).executor.transformQuery(__privateGet(this, _props26).node, __privateGet(this, _props26).queryId);
  }
  compile() {
    return __privateGet(this, _props26).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props26).queryId);
  }
  async execute() {
    await __privateGet(this, _props26).executor.executeQuery(this.compile(), __privateGet(this, _props26).queryId);
  }
};
_props26 = new WeakMap();
var AlterTableColumnAlteringBuilder = _AlterTableColumnAlteringBuilder;
preventAwait(AlterTableColumnAlteringBuilder, "don't await AlterTableColumnAlteringBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-transformer.js
var ImmediateValueTransformer = class extends OperationNodeTransformer {
  transformValue(node) {
    return {
      ...super.transformValue(node),
      immediate: true
    };
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/create-index-builder.js
var _props27;
var _CreateIndexBuilder = class _CreateIndexBuilder {
  constructor(props) {
    __privateAdd(this, _props27);
    __privateSet(this, _props27, freeze(props));
  }
  /**
   * Adds the "if not exists" modifier.
   *
   * If the index already exists, no error is thrown if this method has been called.
   */
  ifNotExists() {
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: CreateIndexNode.cloneWith(__privateGet(this, _props27).node, {
        ifNotExists: true
      })
    });
  }
  /**
   * Makes the index unique.
   */
  unique() {
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: CreateIndexNode.cloneWith(__privateGet(this, _props27).node, {
        unique: true
      })
    });
  }
  /**
   * Adds `nulls not distinct` specifier to index.
   * This only works on some dialects like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createIndex('person_first_name_index')
   *  .on('person')
   *  .column('first_name')
   *  .nullsNotDistinct()
   *  .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_index"
   * on "test" ("first_name")
   * nulls not distinct;
   * ```
   */
  nullsNotDistinct() {
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: CreateIndexNode.cloneWith(__privateGet(this, _props27).node, {
        nullsNotDistinct: true
      })
    });
  }
  /**
   * Specifies the table for the index.
   */
  on(table) {
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: CreateIndexNode.cloneWith(__privateGet(this, _props27).node, {
        table: parseTable(table)
      })
    });
  }
  /**
   * Adds a column to the index.
   *
   * Also see {@link columns} for adding multiple columns at once or {@link expression}
   * for specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .createIndex('person_first_name_and_age_index')
   *         .on('person')
   *         .column('first_name')
   *         .column('age desc')
   *         .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
   * ```
   */
  column(column) {
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: CreateIndexNode.cloneWithColumns(__privateGet(this, _props27).node, [
        parseOrderedColumnName(column)
      ])
    });
  }
  /**
   * Specifies a list of columns for the index.
   *
   * Also see {@link column} for adding a single column or {@link expression} for
   * specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .createIndex('person_first_name_and_age_index')
   *         .on('person')
   *         .columns(['first_name', 'age desc'])
   *         .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
   * ```
   */
  columns(columns) {
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: CreateIndexNode.cloneWithColumns(__privateGet(this, _props27).node, columns.map(parseOrderedColumnName))
    });
  }
  /**
   * Specifies an arbitrary expression for the index.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createIndex('person_first_name_index')
   *   .on('person')
   *   .expression(sql`first_name COLLATE "fi_FI"`)
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_index" on "person" (first_name COLLATE "fi_FI")
   * ```
   */
  expression(expression) {
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: CreateIndexNode.cloneWithColumns(__privateGet(this, _props27).node, [
        expression.toOperationNode()
      ])
    });
  }
  using(indexType) {
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: CreateIndexNode.cloneWith(__privateGet(this, _props27).node, {
        using: RawNode.createWithSql(indexType)
      })
    });
  }
  where(...args) {
    const transformer = new ImmediateValueTransformer();
    return new _CreateIndexBuilder({
      ...__privateGet(this, _props27),
      node: QueryNode.cloneWithWhere(__privateGet(this, _props27).node, transformer.transformNode(parseValueBinaryOperationOrExpression(args)))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props27).executor.transformQuery(__privateGet(this, _props27).node, __privateGet(this, _props27).queryId);
  }
  compile() {
    return __privateGet(this, _props27).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props27).queryId);
  }
  async execute() {
    await __privateGet(this, _props27).executor.executeQuery(this.compile(), __privateGet(this, _props27).queryId);
  }
};
_props27 = new WeakMap();
var CreateIndexBuilder = _CreateIndexBuilder;
preventAwait(CreateIndexBuilder, "don't await CreateIndexBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/create-schema-builder.js
var _props28;
var _CreateSchemaBuilder = class _CreateSchemaBuilder {
  constructor(props) {
    __privateAdd(this, _props28);
    __privateSet(this, _props28, freeze(props));
  }
  ifNotExists() {
    return new _CreateSchemaBuilder({
      ...__privateGet(this, _props28),
      node: CreateSchemaNode.cloneWith(__privateGet(this, _props28).node, { ifNotExists: true })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props28).executor.transformQuery(__privateGet(this, _props28).node, __privateGet(this, _props28).queryId);
  }
  compile() {
    return __privateGet(this, _props28).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props28).queryId);
  }
  async execute() {
    await __privateGet(this, _props28).executor.executeQuery(this.compile(), __privateGet(this, _props28).queryId);
  }
};
_props28 = new WeakMap();
var CreateSchemaBuilder = _CreateSchemaBuilder;
preventAwait(CreateSchemaBuilder, "don't await CreateSchemaBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/on-commit-action-parse.js
function parseOnCommitAction(action) {
  if (ON_COMMIT_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnCommitAction ${action}`);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/create-table-builder.js
var _props29;
var _CreateTableBuilder = class _CreateTableBuilder {
  constructor(props) {
    __privateAdd(this, _props29);
    __privateSet(this, _props29, freeze(props));
  }
  /**
   * Adds the "temporary" modifier.
   *
   * Use this to create a temporary table.
   */
  temporary() {
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWith(__privateGet(this, _props29).node, {
        temporary: true
      })
    });
  }
  /**
   * Adds an "on commit" statement.
   *
   * This can be used in conjunction with temporary tables on supported databases
   * like PostgreSQL.
   */
  onCommit(onCommit) {
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWith(__privateGet(this, _props29).node, {
        onCommit: parseOnCommitAction(onCommit)
      })
    });
  }
  /**
   * Adds the "if not exists" modifier.
   *
   * If the table already exists, no error is thrown if this method has been called.
   */
  ifNotExists() {
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWith(__privateGet(this, _props29).node, {
        ifNotExists: true
      })
    });
  }
  /**
   * Adds a column to the table.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey())
   *   .addColumn('first_name', 'varchar(50)', (col) => col.notNull())
   *   .addColumn('last_name', 'varchar(255)')
   *   .addColumn('bank_balance', 'numeric(8, 2)')
   *   // You can specify any data type using the `sql` tag if the types
   *   // don't include it.
   *   .addColumn('data', sql`any_type_here`)
   *   .addColumn('parent_id', 'integer', (col) =>
   *     col.references('person.id').onDelete('cascade')
   *   )
   * ```
   *
   * With this method, it's once again good to remember that Kysely just builds the
   * query and doesn't provide the same API for all databases. For example, some
   * databases like older MySQL don't support the `references` statement in the
   * column definition. Instead foreign key constraints need to be defined in the
   * `create table` query. See the next example:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', (col) => col.primaryKey())
   *   .addColumn('parent_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'person_parent_id_fk',
   *     ['parent_id'],
   *     'person',
   *     ['id'],
   *     (cb) => cb.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * Another good example is that PostgreSQL doesn't support the `auto_increment`
   * keyword and you need to define an autoincrementing column for example using
   * `serial`:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'serial', (col) => col.primaryKey())
   *   .execute()
   * ```
   */
  addColumn(columnName, dataType, build = noop) {
    const columnBuilder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWithColumn(__privateGet(this, _props29).node, columnBuilder.toOperationNode())
    });
  }
  /**
   * Adds a primary key constraint for one or more columns.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addPrimaryKeyConstraint('primary_key', ['first_name', 'last_name'])
   *   .execute()
   * ```
   */
  addPrimaryKeyConstraint(constraintName, columns) {
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWithConstraint(__privateGet(this, _props29).node, PrimaryConstraintNode.create(columns, constraintName))
    });
  }
  /**
   * Adds a unique constraint for one or more columns.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addUniqueConstraint(
   *     'first_name_last_name_unique',
   *     ['first_name', 'last_name']
   *   )
   *   .execute()
   * ```
   *
   * In dialects such as PostgreSQL you can specify `nulls not distinct` as follows:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addUniqueConstraint(
   *     'first_name_last_name_unique',
   *     ['first_name', 'last_name'],
   *     (cb) => cb.nullsNotDistinct()
   *   )
   *   .execute()
   * ```
   */
  addUniqueConstraint(constraintName, columns, build = noop) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWithConstraint(__privateGet(this, _props29).node, uniqueConstraintBuilder.toOperationNode())
    });
  }
  /**
   * Adds a check constraint.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('animal')
   *   .addColumn('number_of_legs', 'integer')
   *   .addCheckConstraint('check_legs', sql`number_of_legs < 5`)
   *   .execute()
   * ```
   */
  addCheckConstraint(constraintName, checkExpression) {
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWithConstraint(__privateGet(this, _props29).node, CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName))
    });
  }
  /**
   * Adds a foreign key constraint.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'owner_id_foreign',
   *     ['owner_id'],
   *     'person',
   *     ['id'],
   *   )
   *   .execute()
   * ```
   *
   * Add constraint for multiple columns:
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id1', 'integer')
   *   .addColumn('owner_id2', 'integer')
   *   .addForeignKeyConstraint(
   *     'owner_id_foreign',
   *     ['owner_id1', 'owner_id2'],
   *     'person',
   *     ['id1', 'id2'],
   *     (cb) => cb.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   */
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop) {
    const builder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWithConstraint(__privateGet(this, _props29).node, builder.toOperationNode())
    });
  }
  /**
   * This can be used to add any additional SQL to the front of the query __after__ the `create` keyword.
   *
   * Also see {@link temporary}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .modifyFront(sql`global temporary`)
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
   *   .addColumn('last_name', 'varchar(64)', col => col.notNull())
   *   .execute()
   * ```
   *
   * The generated SQL (Postgres):
   *
   * ```sql
   * create global temporary table "person" (
   *   "id" integer primary key,
   *   "first_name" varchar(64) not null,
   *   "last_name" varchar(64) not null
   * )
   * ```
   */
  modifyFront(modifier) {
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWithFrontModifier(__privateGet(this, _props29).node, modifier.toOperationNode())
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * Also see {@link onCommit}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
   *   .addColumn('last_name', 'varchar(64)', col => col.notNull())
   *   .modifyEnd(sql`collate utf8_unicode_ci`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `first_name` varchar(64) not null,
   *   `last_name` varchar(64) not null
   * ) collate utf8_unicode_ci
   * ```
   */
  modifyEnd(modifier) {
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWithEndModifier(__privateGet(this, _props29).node, modifier.toOperationNode())
    });
  }
  /**
   * Allows to create table from `select` query.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('copy')
   *   .temporary()
   *   .as(db.selectFrom('person').select(['first_name', 'last_name']))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create temporary table "copy" as
   * select "first_name", "last_name" from "person"
   * ```
   */
  as(expression) {
    return new _CreateTableBuilder({
      ...__privateGet(this, _props29),
      node: CreateTableNode.cloneWith(__privateGet(this, _props29).node, {
        selectQuery: parseExpression(expression)
      })
    });
  }
  /**
   * Calls the given function passing `this` as the only argument.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('test')
   *   .$call((builder) => builder.addColumn('id', 'integer'))
   *   .execute()
   * ```
   *
   * This is useful for creating reusable functions that can be called with a builder.
   *
   * ```ts
   * import { type CreateTableBuilder, sql } from 'kysely'
   *
   * const addDefaultColumns = (ctb: CreateTableBuilder<any, any>) => {
   *   return ctb
   *     .addColumn('id', 'integer', (col) => col.notNull())
   *     .addColumn('created_at', 'date', (col) =>
   *       col.notNull().defaultTo(sql`now()`)
   *     )
   *     .addColumn('updated_at', 'date', (col) =>
   *       col.notNull().defaultTo(sql`now()`)
   *     )
   * }
   *
   * await db.schema
   *   .createTable('test')
   *   .$call(addDefaultColumns)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props29).executor.transformQuery(__privateGet(this, _props29).node, __privateGet(this, _props29).queryId);
  }
  compile() {
    return __privateGet(this, _props29).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props29).queryId);
  }
  async execute() {
    await __privateGet(this, _props29).executor.executeQuery(this.compile(), __privateGet(this, _props29).queryId);
  }
};
_props29 = new WeakMap();
var CreateTableBuilder = _CreateTableBuilder;
preventAwait(CreateTableBuilder, "don't await CreateTableBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/drop-index-builder.js
var _props30;
var _DropIndexBuilder = class _DropIndexBuilder {
  constructor(props) {
    __privateAdd(this, _props30);
    __privateSet(this, _props30, freeze(props));
  }
  /**
   * Specifies the table the index was created for. This is not needed
   * in all dialects.
   */
  on(table) {
    return new _DropIndexBuilder({
      ...__privateGet(this, _props30),
      node: DropIndexNode.cloneWith(__privateGet(this, _props30).node, {
        table: parseTable(table)
      })
    });
  }
  ifExists() {
    return new _DropIndexBuilder({
      ...__privateGet(this, _props30),
      node: DropIndexNode.cloneWith(__privateGet(this, _props30).node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new _DropIndexBuilder({
      ...__privateGet(this, _props30),
      node: DropIndexNode.cloneWith(__privateGet(this, _props30).node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props30).executor.transformQuery(__privateGet(this, _props30).node, __privateGet(this, _props30).queryId);
  }
  compile() {
    return __privateGet(this, _props30).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props30).queryId);
  }
  async execute() {
    await __privateGet(this, _props30).executor.executeQuery(this.compile(), __privateGet(this, _props30).queryId);
  }
};
_props30 = new WeakMap();
var DropIndexBuilder = _DropIndexBuilder;
preventAwait(DropIndexBuilder, "don't await DropIndexBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/drop-schema-builder.js
var _props31;
var _DropSchemaBuilder = class _DropSchemaBuilder {
  constructor(props) {
    __privateAdd(this, _props31);
    __privateSet(this, _props31, freeze(props));
  }
  ifExists() {
    return new _DropSchemaBuilder({
      ...__privateGet(this, _props31),
      node: DropSchemaNode.cloneWith(__privateGet(this, _props31).node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new _DropSchemaBuilder({
      ...__privateGet(this, _props31),
      node: DropSchemaNode.cloneWith(__privateGet(this, _props31).node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props31).executor.transformQuery(__privateGet(this, _props31).node, __privateGet(this, _props31).queryId);
  }
  compile() {
    return __privateGet(this, _props31).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props31).queryId);
  }
  async execute() {
    await __privateGet(this, _props31).executor.executeQuery(this.compile(), __privateGet(this, _props31).queryId);
  }
};
_props31 = new WeakMap();
var DropSchemaBuilder = _DropSchemaBuilder;
preventAwait(DropSchemaBuilder, "don't await DropSchemaBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/drop-table-builder.js
var _props32;
var _DropTableBuilder = class _DropTableBuilder {
  constructor(props) {
    __privateAdd(this, _props32);
    __privateSet(this, _props32, freeze(props));
  }
  ifExists() {
    return new _DropTableBuilder({
      ...__privateGet(this, _props32),
      node: DropTableNode.cloneWith(__privateGet(this, _props32).node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new _DropTableBuilder({
      ...__privateGet(this, _props32),
      node: DropTableNode.cloneWith(__privateGet(this, _props32).node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props32).executor.transformQuery(__privateGet(this, _props32).node, __privateGet(this, _props32).queryId);
  }
  compile() {
    return __privateGet(this, _props32).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props32).queryId);
  }
  async execute() {
    await __privateGet(this, _props32).executor.executeQuery(this.compile(), __privateGet(this, _props32).queryId);
  }
};
_props32 = new WeakMap();
var DropTableBuilder = _DropTableBuilder;
preventAwait(DropTableBuilder, "don't await DropTableBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/create-view-node.js
var CreateViewNode = freeze({
  is(node) {
    return node.kind === "CreateViewNode";
  },
  create(name) {
    return freeze({
      kind: "CreateViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(createView, params) {
    return freeze({
      ...createView,
      ...params
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-plugin.js
var _transformer2;
var ImmediateValuePlugin = class {
  constructor() {
    __privateAdd(this, _transformer2, new ImmediateValueTransformer());
  }
  transformQuery(args) {
    return __privateGet(this, _transformer2).transformNode(args.node);
  }
  transformResult(args) {
    return Promise.resolve(args.result);
  }
};
_transformer2 = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/create-view-builder.js
var _props33;
var _CreateViewBuilder = class _CreateViewBuilder {
  constructor(props) {
    __privateAdd(this, _props33);
    __privateSet(this, _props33, freeze(props));
  }
  /**
   * Adds the "temporary" modifier.
   *
   * Use this to create a temporary view.
   */
  temporary() {
    return new _CreateViewBuilder({
      ...__privateGet(this, _props33),
      node: CreateViewNode.cloneWith(__privateGet(this, _props33).node, {
        temporary: true
      })
    });
  }
  materialized() {
    return new _CreateViewBuilder({
      ...__privateGet(this, _props33),
      node: CreateViewNode.cloneWith(__privateGet(this, _props33).node, {
        materialized: true
      })
    });
  }
  /**
   * Only implemented on some dialects like SQLite. On most dialects, use {@link orReplace}.
   */
  ifNotExists() {
    return new _CreateViewBuilder({
      ...__privateGet(this, _props33),
      node: CreateViewNode.cloneWith(__privateGet(this, _props33).node, {
        ifNotExists: true
      })
    });
  }
  orReplace() {
    return new _CreateViewBuilder({
      ...__privateGet(this, _props33),
      node: CreateViewNode.cloneWith(__privateGet(this, _props33).node, {
        orReplace: true
      })
    });
  }
  columns(columns) {
    return new _CreateViewBuilder({
      ...__privateGet(this, _props33),
      node: CreateViewNode.cloneWith(__privateGet(this, _props33).node, {
        columns: columns.map(parseColumnName)
      })
    });
  }
  /**
   * Sets the select query or a `values` statement that creates the view.
   *
   * WARNING!
   * Some dialects don't support parameterized queries in DDL statements and therefore
   * the query or raw {@link sql } expression passed here is interpolated into a single
   * string opening an SQL injection vulnerability. DO NOT pass unchecked user input
   * into the query or raw expression passed to this method!
   */
  as(query) {
    const queryNode = query.withPlugin(new ImmediateValuePlugin()).toOperationNode();
    return new _CreateViewBuilder({
      ...__privateGet(this, _props33),
      node: CreateViewNode.cloneWith(__privateGet(this, _props33).node, {
        as: queryNode
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props33).executor.transformQuery(__privateGet(this, _props33).node, __privateGet(this, _props33).queryId);
  }
  compile() {
    return __privateGet(this, _props33).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props33).queryId);
  }
  async execute() {
    await __privateGet(this, _props33).executor.executeQuery(this.compile(), __privateGet(this, _props33).queryId);
  }
};
_props33 = new WeakMap();
var CreateViewBuilder = _CreateViewBuilder;
preventAwait(CreateViewBuilder, "don't await CreateViewBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/drop-view-node.js
var DropViewNode = freeze({
  is(node) {
    return node.kind === "DropViewNode";
  },
  create(name) {
    return freeze({
      kind: "DropViewNode",
      name: SchemableIdentifierNode.create(name)
    });
  },
  cloneWith(dropView, params) {
    return freeze({
      ...dropView,
      ...params
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/drop-view-builder.js
var _props34;
var _DropViewBuilder = class _DropViewBuilder {
  constructor(props) {
    __privateAdd(this, _props34);
    __privateSet(this, _props34, freeze(props));
  }
  materialized() {
    return new _DropViewBuilder({
      ...__privateGet(this, _props34),
      node: DropViewNode.cloneWith(__privateGet(this, _props34).node, {
        materialized: true
      })
    });
  }
  ifExists() {
    return new _DropViewBuilder({
      ...__privateGet(this, _props34),
      node: DropViewNode.cloneWith(__privateGet(this, _props34).node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new _DropViewBuilder({
      ...__privateGet(this, _props34),
      node: DropViewNode.cloneWith(__privateGet(this, _props34).node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props34).executor.transformQuery(__privateGet(this, _props34).node, __privateGet(this, _props34).queryId);
  }
  compile() {
    return __privateGet(this, _props34).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props34).queryId);
  }
  async execute() {
    await __privateGet(this, _props34).executor.executeQuery(this.compile(), __privateGet(this, _props34).queryId);
  }
};
_props34 = new WeakMap();
var DropViewBuilder = _DropViewBuilder;
preventAwait(DropViewBuilder, "don't await DropViewBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/create-type-node.js
var CreateTypeNode = freeze({
  is(node) {
    return node.kind === "CreateTypeNode";
  },
  create(name) {
    return freeze({
      kind: "CreateTypeNode",
      name
    });
  },
  cloneWithEnum(createType, values) {
    return freeze({
      ...createType,
      enum: ValueListNode.create(values.map((value) => ValueNode.createImmediate(value)))
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/create-type-builder.js
var _props35;
var _CreateTypeBuilder = class _CreateTypeBuilder {
  constructor(props) {
    __privateAdd(this, _props35);
    __privateSet(this, _props35, freeze(props));
  }
  toOperationNode() {
    return __privateGet(this, _props35).executor.transformQuery(__privateGet(this, _props35).node, __privateGet(this, _props35).queryId);
  }
  /**
   * Creates an anum type.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createType('species').asEnum(['cat', 'dog', 'frog'])
   * ```
   */
  asEnum(values) {
    return new _CreateTypeBuilder({
      ...__privateGet(this, _props35),
      node: CreateTypeNode.cloneWithEnum(__privateGet(this, _props35).node, values)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  compile() {
    return __privateGet(this, _props35).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props35).queryId);
  }
  async execute() {
    await __privateGet(this, _props35).executor.executeQuery(this.compile(), __privateGet(this, _props35).queryId);
  }
};
_props35 = new WeakMap();
var CreateTypeBuilder = _CreateTypeBuilder;
preventAwait(CreateTypeBuilder, "don't await CreateTypeBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/drop-type-node.js
var DropTypeNode = freeze({
  is(node) {
    return node.kind === "DropTypeNode";
  },
  create(name) {
    return freeze({
      kind: "DropTypeNode",
      name
    });
  },
  cloneWith(dropType, params) {
    return freeze({
      ...dropType,
      ...params
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/drop-type-builder.js
var _props36;
var _DropTypeBuilder = class _DropTypeBuilder {
  constructor(props) {
    __privateAdd(this, _props36);
    __privateSet(this, _props36, freeze(props));
  }
  ifExists() {
    return new _DropTypeBuilder({
      ...__privateGet(this, _props36),
      node: DropTypeNode.cloneWith(__privateGet(this, _props36).node, {
        ifExists: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return __privateGet(this, _props36).executor.transformQuery(__privateGet(this, _props36).node, __privateGet(this, _props36).queryId);
  }
  compile() {
    return __privateGet(this, _props36).executor.compileQuery(this.toOperationNode(), __privateGet(this, _props36).queryId);
  }
  async execute() {
    await __privateGet(this, _props36).executor.executeQuery(this.compile(), __privateGet(this, _props36).queryId);
  }
};
_props36 = new WeakMap();
var DropTypeBuilder = _DropTypeBuilder;
preventAwait(DropTypeBuilder, "don't await DropTypeBuilder instances directly. To execute the query you need to call `execute`");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/parser/identifier-parser.js
function parseSchemableIdentifier(id) {
  const SCHEMA_SEPARATOR = ".";
  if (id.includes(SCHEMA_SEPARATOR)) {
    const parts = id.split(SCHEMA_SEPARATOR).map(trim3);
    if (parts.length === 2) {
      return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);
    } else {
      throw new Error(`invalid schemable identifier ${id}`);
    }
  } else {
    return SchemableIdentifierNode.create(id);
  }
}
function trim3(str) {
  return str.trim();
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/schema/schema.js
var _executor;
var _SchemaModule = class _SchemaModule {
  constructor(executor) {
    __privateAdd(this, _executor);
    __privateSet(this, _executor, executor);
  }
  /**
   * Create a new table.
   *
   * ### Examples
   *
   * This example creates a new table with columns `id`, `first_name`,
   * `last_name` and `gender`:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('first_name', 'varchar', col => col.notNull())
   *   .addColumn('last_name', 'varchar', col => col.notNull())
   *   .addColumn('gender', 'varchar')
   *   .execute()
   * ```
   *
   * This example creates a table with a foreign key. Not all database
   * engines support column-level foreign key constraint definitions.
   * For example if you are using MySQL 5.X see the next example after
   * this one.
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('owner_id', 'integer', col => col
   *     .references('person.id')
   *     .onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * This example adds a foreign key constraint for a columns just
   * like the previous example, but using a table-level statement.
   * On MySQL 5.X you need to define foreign key constraints like
   * this:
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('owner_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'pet_owner_id_foreign', ['owner_id'], 'person', ['id'],
   *     (constraint) => constraint.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   */
  createTable(table) {
    return new CreateTableBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: CreateTableNode.create(parseTable(table))
    });
  }
  /**
   * Drop a table.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropTable('person')
   *   .execute()
   * ```
   */
  dropTable(table) {
    return new DropTableBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: DropTableNode.create(parseTable(table))
    });
  }
  /**
   * Create a new index.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createIndex('person_full_name_unique_index')
   *   .on('person')
   *   .columns(['first_name', 'last_name'])
   *   .execute()
   * ```
   */
  createIndex(indexName) {
    return new CreateIndexBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: CreateIndexNode.create(indexName)
    });
  }
  /**
   * Drop an index.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropIndex('person_full_name_unique_index')
   *   .execute()
   * ```
   */
  dropIndex(indexName) {
    return new DropIndexBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: DropIndexNode.create(indexName)
    });
  }
  /**
   * Create a new schema.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createSchema('some_schema')
   *   .execute()
   * ```
   */
  createSchema(schema) {
    return new CreateSchemaBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: CreateSchemaNode.create(schema)
    });
  }
  /**
   * Drop a schema.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropSchema('some_schema')
   *   .execute()
   * ```
   */
  dropSchema(schema) {
    return new DropSchemaBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: DropSchemaNode.create(schema)
    });
  }
  /**
   * Alter a table.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .alterColumn('first_name', (ac) => ac.setDataType('text'))
   *   .execute()
   * ```
   */
  alterTable(table) {
    return new AlterTableBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: AlterTableNode.create(parseTable(table))
    });
  }
  /**
   * Create a new view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createView('dogs')
   *   .orReplace()
   *   .as(db.selectFrom('pet').selectAll().where('species', '=', 'dog'))
   *   .execute()
   * ```
   */
  createView(viewName) {
    return new CreateViewBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: CreateViewNode.create(viewName)
    });
  }
  /**
   * Drop a view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropView('dogs')
   *   .ifExists()
   *   .execute()
   * ```
   */
  dropView(viewName) {
    return new DropViewBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: DropViewNode.create(viewName)
    });
  }
  /**
   * Create a new type.
   *
   * Only some dialects like PostgreSQL have user-defined types.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createType('species')
   *   .asEnum(['dog', 'cat', 'frog'])
   *   .execute()
   * ```
   */
  createType(typeName) {
    return new CreateTypeBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: CreateTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  /**
   * Drop a type.
   *
   * Only some dialects like PostgreSQL have user-defined types.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropType('species')
   *   .ifExists()
   *   .execute()
   * ```
   */
  dropType(typeName) {
    return new DropTypeBuilder({
      queryId: createQueryId(),
      executor: __privateGet(this, _executor),
      node: DropTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  /**
   * Returns a copy of this schema module with the given plugin installed.
   */
  withPlugin(plugin) {
    return new _SchemaModule(__privateGet(this, _executor).withPlugin(plugin));
  }
  /**
   * Returns a copy of this schema module  without any plugins.
   */
  withoutPlugins() {
    return new _SchemaModule(__privateGet(this, _executor).withoutPlugins());
  }
  /**
   * See {@link QueryCreator.withSchema}
   */
  withSchema(schema) {
    return new _SchemaModule(__privateGet(this, _executor).withPluginAtFront(new WithSchemaPlugin(schema)));
  }
};
_executor = new WeakMap();
var SchemaModule = _SchemaModule;

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/dynamic/dynamic.js
var DynamicModule = class {
  /**
   * Creates a dynamic reference to a column that is not know at compile time.
   *
   * Kysely is built in a way that by default you can't refer to tables or columns
   * that are not actually visible in the current query and context. This is all
   * done by TypeScript at compile time, which means that you need to know the
   * columns and tables at compile time. This is not always the case of course.
   *
   * This method is meant to be used in those cases where the column names
   * come from the user input or are not otherwise known at compile time.
   *
   * WARNING! Unlike values, column names are not escaped by the database engine
   * or Kysely and if you pass in unchecked column names using this method, you
   * create an SQL injection vulnerability. Always __always__ validate the user
   * input before passing it to this method.
   *
   * There are couple of examples below for some use cases, but you can pass
   * `ref` to other methods as well. If the types allow you to pass a `ref`
   * value to some place, it should work.
   *
   * ### Examples
   *
   * Filter by a column not know at compile time:
   *
   * ```ts
   * async function someQuery(filterColumn: string, filterValue: string) {
   *   const { ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom('person')
   *     .selectAll()
   *     .where(ref(filterColumn), '=', filterValue)
   *     .execute()
   * }
   *
   * someQuery('first_name', 'Arnold')
   * someQuery('person.last_name', 'Aniston')
   * ```
   *
   * Order by a column not know at compile time:
   *
   * ```ts
   * async function someQuery(orderBy: string) {
   *   const { ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom('person')
   *     .select('person.first_name as fn')
   *     .orderBy(ref(orderBy))
   *     .execute()
   * }
   *
   * someQuery('fn')
   * ```
   *
   * In this example we add selections dynamically:
   *
   * ```ts
   * const { ref } = db.dynamic
   *
   * // Some column name provided by the user. Value not known at compile time.
   * const columnFromUserInput: PossibleColumns = 'birthdate';
   *
   * // A type that lists all possible values `columnFromUserInput` can have.
   * // You can use `keyof Person` if any column of an interface is allowed.
   * type PossibleColumns = 'last_name' | 'first_name' | 'birthdate'
   *
   * const [person] = await db.selectFrom('person')
   *   .select([
   *     ref<PossibleColumns>(columnFromUserInput),
   *     'id'
   *   ])
   *   .execute()
   *
   * // The resulting type contains all `PossibleColumns` as optional fields
   * // because we cannot know which field was actually selected before
   * // running the code.
   * const lastName: string | null | undefined = person?.last_name
   * const firstName: string | undefined = person?.first_name
   * const birthDate: Date | null | undefined = person?.birthdate
   *
   * // The result type also contains the compile time selection `id`.
   * person?.id
   * ```
   */
  ref(reference) {
    return new DynamicReferenceBuilder(reference);
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/driver/default-connection-provider.js
var _driver;
var DefaultConnectionProvider = class {
  constructor(driver) {
    __privateAdd(this, _driver);
    __privateSet(this, _driver, driver);
  }
  async provideConnection(consumer) {
    const connection = await __privateGet(this, _driver).acquireConnection();
    try {
      return await consumer(connection);
    } finally {
      await __privateGet(this, _driver).releaseConnection(connection);
    }
  }
};
_driver = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-executor/default-query-executor.js
var _compiler, _adapter, _connectionProvider;
var _DefaultQueryExecutor = class _DefaultQueryExecutor extends QueryExecutorBase {
  constructor(compiler, adapter, connectionProvider, plugins = []) {
    super(plugins);
    __privateAdd(this, _compiler);
    __privateAdd(this, _adapter);
    __privateAdd(this, _connectionProvider);
    __privateSet(this, _compiler, compiler);
    __privateSet(this, _adapter, adapter);
    __privateSet(this, _connectionProvider, connectionProvider);
  }
  get adapter() {
    return __privateGet(this, _adapter);
  }
  compileQuery(node) {
    return __privateGet(this, _compiler).compileQuery(node);
  }
  provideConnection(consumer) {
    return __privateGet(this, _connectionProvider).provideConnection(consumer);
  }
  withPlugins(plugins) {
    return new _DefaultQueryExecutor(__privateGet(this, _compiler), __privateGet(this, _adapter), __privateGet(this, _connectionProvider), [...this.plugins, ...plugins]);
  }
  withPlugin(plugin) {
    return new _DefaultQueryExecutor(__privateGet(this, _compiler), __privateGet(this, _adapter), __privateGet(this, _connectionProvider), [...this.plugins, plugin]);
  }
  withPluginAtFront(plugin) {
    return new _DefaultQueryExecutor(__privateGet(this, _compiler), __privateGet(this, _adapter), __privateGet(this, _connectionProvider), [plugin, ...this.plugins]);
  }
  withConnectionProvider(connectionProvider) {
    return new _DefaultQueryExecutor(__privateGet(this, _compiler), __privateGet(this, _adapter), connectionProvider, [...this.plugins]);
  }
  withoutPlugins() {
    return new _DefaultQueryExecutor(__privateGet(this, _compiler), __privateGet(this, _adapter), __privateGet(this, _connectionProvider), []);
  }
};
_compiler = new WeakMap();
_adapter = new WeakMap();
_connectionProvider = new WeakMap();
var DefaultQueryExecutor = _DefaultQueryExecutor;

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/performance-now.js
function performanceNow() {
  if (typeof performance !== "undefined" && isFunction(performance.now)) {
    return performance.now();
  } else {
    return Date.now();
  }
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/driver/runtime-driver.js
var _driver2, _log, _initPromise, _initDone, _destroyPromise, _connections, _RuntimeDriver_instances, needsLogging_fn, addLogging_fn, logError_fn, logQuery_fn, calculateDurationMillis_fn;
var RuntimeDriver = class {
  constructor(driver, log) {
    __privateAdd(this, _RuntimeDriver_instances);
    __privateAdd(this, _driver2);
    __privateAdd(this, _log);
    __privateAdd(this, _initPromise);
    __privateAdd(this, _initDone);
    __privateAdd(this, _destroyPromise);
    __privateAdd(this, _connections, /* @__PURE__ */ new WeakSet());
    __privateSet(this, _initDone, false);
    __privateSet(this, _driver2, driver);
    __privateSet(this, _log, log);
  }
  async init() {
    if (__privateGet(this, _destroyPromise)) {
      throw new Error("driver has already been destroyed");
    }
    if (!__privateGet(this, _initPromise)) {
      __privateSet(this, _initPromise, __privateGet(this, _driver2).init().then(() => {
        __privateSet(this, _initDone, true);
      }).catch((err) => {
        __privateSet(this, _initPromise, void 0);
        return Promise.reject(err);
      }));
    }
    await __privateGet(this, _initPromise);
  }
  async acquireConnection() {
    if (__privateGet(this, _destroyPromise)) {
      throw new Error("driver has already been destroyed");
    }
    if (!__privateGet(this, _initDone)) {
      await this.init();
    }
    const connection = await __privateGet(this, _driver2).acquireConnection();
    if (!__privateGet(this, _connections).has(connection)) {
      if (__privateMethod(this, _RuntimeDriver_instances, needsLogging_fn).call(this)) {
        __privateMethod(this, _RuntimeDriver_instances, addLogging_fn).call(this, connection);
      }
      __privateGet(this, _connections).add(connection);
    }
    return connection;
  }
  async releaseConnection(connection) {
    await __privateGet(this, _driver2).releaseConnection(connection);
  }
  beginTransaction(connection, settings) {
    return __privateGet(this, _driver2).beginTransaction(connection, settings);
  }
  commitTransaction(connection) {
    return __privateGet(this, _driver2).commitTransaction(connection);
  }
  rollbackTransaction(connection) {
    return __privateGet(this, _driver2).rollbackTransaction(connection);
  }
  async destroy() {
    if (!__privateGet(this, _initPromise)) {
      return;
    }
    await __privateGet(this, _initPromise);
    if (!__privateGet(this, _destroyPromise)) {
      __privateSet(this, _destroyPromise, __privateGet(this, _driver2).destroy().catch((err) => {
        __privateSet(this, _destroyPromise, void 0);
        return Promise.reject(err);
      }));
    }
    await __privateGet(this, _destroyPromise);
  }
};
_driver2 = new WeakMap();
_log = new WeakMap();
_initPromise = new WeakMap();
_initDone = new WeakMap();
_destroyPromise = new WeakMap();
_connections = new WeakMap();
_RuntimeDriver_instances = new WeakSet();
needsLogging_fn = function() {
  return __privateGet(this, _log).isLevelEnabled("query") || __privateGet(this, _log).isLevelEnabled("error");
};
// This method monkey patches the database connection's executeQuery method
// by adding logging code around it. Monkey patching is not pretty, but it's
// the best option in this case.
addLogging_fn = function(connection) {
  const executeQuery = connection.executeQuery;
  connection.executeQuery = async (compiledQuery) => {
    let caughtError;
    const startTime = performanceNow();
    try {
      return await executeQuery.call(connection, compiledQuery);
    } catch (error) {
      caughtError = error;
      await __privateMethod(this, _RuntimeDriver_instances, logError_fn).call(this, error, compiledQuery, startTime);
      throw error;
    } finally {
      if (!caughtError) {
        await __privateMethod(this, _RuntimeDriver_instances, logQuery_fn).call(this, compiledQuery, startTime);
      }
    }
  };
};
logError_fn = async function(error, compiledQuery, startTime) {
  await __privateGet(this, _log).error(() => ({
    level: "error",
    error,
    query: compiledQuery,
    queryDurationMillis: __privateMethod(this, _RuntimeDriver_instances, calculateDurationMillis_fn).call(this, startTime)
  }));
};
logQuery_fn = async function(compiledQuery, startTime) {
  await __privateGet(this, _log).query(() => ({
    level: "query",
    query: compiledQuery,
    queryDurationMillis: __privateMethod(this, _RuntimeDriver_instances, calculateDurationMillis_fn).call(this, startTime)
  }));
};
calculateDurationMillis_fn = function(startTime) {
  return performanceNow() - startTime;
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/driver/single-connection-provider.js
var ignoreError = () => {
};
var _connection, _runningPromise, _SingleConnectionProvider_instances, run_fn;
var SingleConnectionProvider = class {
  constructor(connection) {
    __privateAdd(this, _SingleConnectionProvider_instances);
    __privateAdd(this, _connection);
    __privateAdd(this, _runningPromise);
    __privateSet(this, _connection, connection);
  }
  async provideConnection(consumer) {
    while (__privateGet(this, _runningPromise)) {
      await __privateGet(this, _runningPromise).catch(ignoreError);
    }
    __privateSet(this, _runningPromise, __privateMethod(this, _SingleConnectionProvider_instances, run_fn).call(this, consumer).finally(() => {
      __privateSet(this, _runningPromise, void 0);
    }));
    return __privateGet(this, _runningPromise);
  }
};
_connection = new WeakMap();
_runningPromise = new WeakMap();
_SingleConnectionProvider_instances = new WeakSet();
run_fn = async function(runner) {
  return await runner(__privateGet(this, _connection));
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/driver/driver.js
var TRANSACTION_ISOLATION_LEVELS = [
  "read uncommitted",
  "read committed",
  "repeatable read",
  "serializable",
  "snapshot"
];

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/log.js
freeze(["query", "error"]);
var _levels, _logger;
var Log = class {
  constructor(config) {
    __privateAdd(this, _levels);
    __privateAdd(this, _logger);
    if (isFunction(config)) {
      __privateSet(this, _logger, config);
      __privateSet(this, _levels, freeze({
        query: true,
        error: true
      }));
    } else {
      __privateSet(this, _logger, defaultLogger);
      __privateSet(this, _levels, freeze({
        query: config.includes("query"),
        error: config.includes("error")
      }));
    }
  }
  isLevelEnabled(level) {
    return __privateGet(this, _levels)[level];
  }
  async query(getEvent) {
    if (__privateGet(this, _levels).query) {
      await __privateGet(this, _logger).call(this, getEvent());
    }
  }
  async error(getEvent) {
    if (__privateGet(this, _levels).error) {
      await __privateGet(this, _logger).call(this, getEvent());
    }
  }
};
_levels = new WeakMap();
_logger = new WeakMap();
function defaultLogger(event) {
  var _a;
  if (event.level === "query") {
    console.log(`kysely:query: ${event.query.sql}`);
    console.log(`kysely:query: duration: ${event.queryDurationMillis.toFixed(1)}ms`);
  } else if (event.level === "error") {
    if (event.error instanceof Error) {
      console.error(`kysely:error: ${(_a = event.error.stack) != null ? _a : event.error.message}`);
    } else {
      console.error(`kysely:error: ${JSON.stringify({
        error: event.error,
        query: event.query.sql,
        queryDurationMillis: event.queryDurationMillis
      })}`);
    }
  }
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/compilable.js
function isCompilable(value) {
  return isObject(value) && isFunction(value.compile);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/kysely.js
var _props37;
var _Kysely = class _Kysely extends QueryCreator {
  constructor(args) {
    var _a, _b;
    let superProps;
    let props;
    if (isKyselyProps(args)) {
      superProps = { executor: args.executor };
      props = { ...args };
    } else {
      const dialect = args.dialect;
      const driver = dialect.createDriver();
      const compiler = dialect.createQueryCompiler();
      const adapter = dialect.createAdapter();
      const log = new Log((_a = args.log) != null ? _a : []);
      const runtimeDriver = new RuntimeDriver(driver, log);
      const connectionProvider = new DefaultConnectionProvider(runtimeDriver);
      const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, (_b = args.plugins) != null ? _b : []);
      superProps = { executor };
      props = {
        config: args,
        executor,
        dialect,
        driver: runtimeDriver
      };
    }
    super(superProps);
    __privateAdd(this, _props37);
    __privateSet(this, _props37, freeze(props));
  }
  /**
   * Returns the {@link SchemaModule} module for building database schema.
   */
  get schema() {
    return new SchemaModule(__privateGet(this, _props37).executor);
  }
  /**
   * Returns a the {@link DynamicModule} module.
   *
   * The {@link DynamicModule} module can be used to bypass strict typing and
   * passing in dynamic values for the queries.
   */
  get dynamic() {
    return new DynamicModule();
  }
  /**
   * Returns a {@link DatabaseIntrospector | database introspector}.
   */
  get introspection() {
    return __privateGet(this, _props37).dialect.createIntrospector(this.withoutPlugins());
  }
  case(value) {
    return new CaseBuilder({
      node: CaseNode.create(isUndefined(value) ? void 0 : parseExpression(value))
    });
  }
  /**
   * Returns a {@link FunctionModule} that can be used to write somewhat type-safe function
   * calls.
   *
   * ```ts
   * const { count } = db.fn
   *
   * await db.selectFrom('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .select([
   *     'id',
   *     count('pet.id').as('person_count'),
   *   ])
   *   .groupBy('person.id')
   *   .having(count('pet.id'), '>', 10)
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "person"."id", count("pet"."id") as "person_count"
   * from "person"
   * inner join "pet" on "pet"."owner_id" = "person"."id"
   * group by "person"."id"
   * having count("pet"."id") > $1
   * ```
   *
   * Why "somewhat" type-safe? Because the function calls are not bound to the
   * current query context. They allow you to reference columns and tables that
   * are not in the current query. E.g. remove the `innerJoin` from the previous
   * query and TypeScript won't even complain.
   *
   * If you want to make the function calls fully type-safe, you can use the
   * {@link ExpressionBuilder.fn} getter for a query context-aware, stricter {@link FunctionModule}.
   *
   * ```ts
   * await db.selectFrom('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .select((eb) => [
   *     'person.id',
   *     eb.fn.count('pet.id').as('pet_count')
   *   ])
   *   .groupBy('person.id')
   *   .having((eb) => eb.fn.count('pet.id'), '>', 10)
   *   .execute()
   * ```
   */
  get fn() {
    return createFunctionModule();
  }
  /**
   * Creates a {@link TransactionBuilder} that can be used to run queries inside a transaction.
   *
   * The returned {@link TransactionBuilder} can be used to configure the transaction. The
   * {@link TransactionBuilder.execute} method can then be called to run the transaction.
   * {@link TransactionBuilder.execute} takes a function that is run inside the
   * transaction. If the function throws an exception,
   * 1. the exception is caught,
   * 2. the transaction is rolled back, and
   * 3. the exception is thrown again.
   * Otherwise the transaction is committed.
   *
   * The callback function passed to the {@link TransactionBuilder.execute | execute}
   * method gets the transaction object as its only argument. The transaction is
   * of type {@link Transaction} which inherits {@link Kysely}. Any query
   * started through the transaction object is executed inside the transaction.
   *
   * ### Examples
   *
   * <!-- siteExample("transactions", "Simple transaction", 10) -->
   *
   * This example inserts two rows in a transaction. If an exception is thrown inside
   * the callback passed to the `execute` method,
   * 1. the exception is caught,
   * 2. the transaction is rolled back, and
   * 3. the exception is thrown again.
   * Otherwise the transaction is committed.
   *
   * ```ts
   * const catto = await db.transaction().execute(async (trx) => {
   *   const jennifer = await trx.insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       last_name: 'Aniston',
   *       age: 40,
   *     })
   *     .returning('id')
   *     .executeTakeFirstOrThrow()
   *
   *   return await trx.insertInto('pet')
   *     .values({
   *       owner_id: jennifer.id,
   *       name: 'Catto',
   *       species: 'cat',
   *       is_favorite: false,
   *     })
   *     .returningAll()
   *     .executeTakeFirst()
   * })
   * ```
   *
   * Setting the isolation level:
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   *
   * await db
   *   .transaction()
   *   .setIsolationLevel('serializable')
   *   .execute(async (trx) => {
   *     await doStuff(trx)
   *   })
   *
   * async function doStuff(kysely: typeof db) {
   *   // ...
   * }
   * ```
   */
  transaction() {
    return new TransactionBuilder({ ...__privateGet(this, _props37) });
  }
  /**
   * Provides a kysely instance bound to a single database connection.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .connection()
   *   .execute(async (db) => {
   *     // `db` is an instance of `Kysely` that's bound to a single
   *     // database connection. All queries executed through `db` use
   *     // the same connection.
   *     await doStuff(db)
   *   })
   *
   * async function doStuff(kysely: typeof db) {
   *   // ...
   * }
   * ```
   */
  connection() {
    return new ConnectionBuilder({ ...__privateGet(this, _props37) });
  }
  /**
   * Returns a copy of this Kysely instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new _Kysely({
      ...__privateGet(this, _props37),
      executor: __privateGet(this, _props37).executor.withPlugin(plugin)
    });
  }
  /**
   * Returns a copy of this Kysely instance without any plugins.
   */
  withoutPlugins() {
    return new _Kysely({
      ...__privateGet(this, _props37),
      executor: __privateGet(this, _props37).executor.withoutPlugins()
    });
  }
  /**
   * @override
   */
  withSchema(schema) {
    return new _Kysely({
      ...__privateGet(this, _props37),
      executor: __privateGet(this, _props37).executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  /**
   * Returns a copy of this Kysely instance with tables added to its
   * database type.
   *
   * This method only modifies the types and doesn't affect any of the
   * executed queries in any way.
   *
   * ### Examples
   *
   * The following example adds and uses a temporary table:
   *
   * ```ts
   * await db.schema
   *   .createTable('temp_table')
   *   .temporary()
   *   .addColumn('some_column', 'integer')
   *   .execute()
   *
   * const tempDb = db.withTables<{
   *   temp_table: {
   *     some_column: number
   *   }
   * }>()
   *
   * await tempDb
   *   .insertInto('temp_table')
   *   .values({ some_column: 100 })
   *   .execute()
   * ```
   */
  withTables() {
    return new _Kysely({ ...__privateGet(this, _props37) });
  }
  /**
   * Releases all resources and disconnects from the database.
   *
   * You need to call this when you are done using the `Kysely` instance.
   */
  async destroy() {
    await __privateGet(this, _props37).driver.destroy();
  }
  /**
   * Returns true if this `Kysely` instance is a transaction.
   *
   * You can also use `db instanceof Transaction`.
   */
  get isTransaction() {
    return false;
  }
  /**
   * @internal
   * @private
   */
  getExecutor() {
    return __privateGet(this, _props37).executor;
  }
  /**
   * Executes a given compiled query or query builder.
   *
   * See {@link https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#execute-compiled-queries splitting build, compile and execute code recipe} for more information.
   */
  executeQuery(query, queryId = createQueryId()) {
    const compiledQuery = isCompilable(query) ? query.compile() : query;
    return this.getExecutor().executeQuery(compiledQuery, queryId);
  }
};
_props37 = new WeakMap();
var Kysely = _Kysely;
var _props38;
var _Transaction = class _Transaction extends Kysely {
  constructor(props) {
    super(props);
    __privateAdd(this, _props38);
    __privateSet(this, _props38, props);
  }
  // The return type is `true` instead of `boolean` to make Kysely<DB>
  // unassignable to Transaction<DB> while allowing assignment the
  // other way around.
  get isTransaction() {
    return true;
  }
  transaction() {
    throw new Error("calling the transaction method for a Transaction is not supported");
  }
  connection() {
    throw new Error("calling the connection method for a Transaction is not supported");
  }
  async destroy() {
    throw new Error("calling the destroy method for a Transaction is not supported");
  }
  withPlugin(plugin) {
    return new _Transaction({
      ...__privateGet(this, _props38),
      executor: __privateGet(this, _props38).executor.withPlugin(plugin)
    });
  }
  withoutPlugins() {
    return new _Transaction({
      ...__privateGet(this, _props38),
      executor: __privateGet(this, _props38).executor.withoutPlugins()
    });
  }
  withSchema(schema) {
    return new _Transaction({
      ...__privateGet(this, _props38),
      executor: __privateGet(this, _props38).executor.withPluginAtFront(new WithSchemaPlugin(schema))
    });
  }
  withTables() {
    return new _Transaction({ ...__privateGet(this, _props38) });
  }
};
_props38 = new WeakMap();
var Transaction = _Transaction;
function isKyselyProps(obj) {
  return isObject(obj) && isObject(obj.config) && isObject(obj.driver) && isObject(obj.executor) && isObject(obj.dialect);
}
var _props39;
var ConnectionBuilder = class {
  constructor(props) {
    __privateAdd(this, _props39);
    __privateSet(this, _props39, freeze(props));
  }
  async execute(callback) {
    return __privateGet(this, _props39).executor.provideConnection(async (connection) => {
      const executor = __privateGet(this, _props39).executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const db = new Kysely({
        ...__privateGet(this, _props39),
        executor
      });
      return await callback(db);
    });
  }
};
_props39 = new WeakMap();
preventAwait(ConnectionBuilder, "don't await ConnectionBuilder instances directly. To execute the query you need to call the `execute` method");
var _props40;
var _TransactionBuilder = class _TransactionBuilder {
  constructor(props) {
    __privateAdd(this, _props40);
    __privateSet(this, _props40, freeze(props));
  }
  setIsolationLevel(isolationLevel) {
    return new _TransactionBuilder({
      ...__privateGet(this, _props40),
      isolationLevel
    });
  }
  async execute(callback) {
    const { isolationLevel, ...kyselyProps } = __privateGet(this, _props40);
    const settings = { isolationLevel };
    validateTransactionSettings(settings);
    return __privateGet(this, _props40).executor.provideConnection(async (connection) => {
      const executor = __privateGet(this, _props40).executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const transaction = new Transaction({
        ...kyselyProps,
        executor
      });
      try {
        await __privateGet(this, _props40).driver.beginTransaction(connection, settings);
        const result = await callback(transaction);
        await __privateGet(this, _props40).driver.commitTransaction(connection);
        return result;
      } catch (error) {
        await __privateGet(this, _props40).driver.rollbackTransaction(connection);
        throw error;
      }
    });
  }
};
_props40 = new WeakMap();
var TransactionBuilder = _TransactionBuilder;
preventAwait(TransactionBuilder, "don't await TransactionBuilder instances directly. To execute the transaction you need to call the `execute` method");
function validateTransactionSettings(settings) {
  if (settings.isolationLevel && !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {
    throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);
  }
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/raw-builder/raw-builder.js
var _props41, _RawBuilderImpl_instances, getExecutor_fn, toOperationNode_fn, compile_fn;
var _RawBuilderImpl = class _RawBuilderImpl {
  constructor(props) {
    __privateAdd(this, _RawBuilderImpl_instances);
    __privateAdd(this, _props41);
    __privateSet(this, _props41, freeze(props));
  }
  get expressionType() {
    return void 0;
  }
  get isRawBuilder() {
    return true;
  }
  as(alias) {
    return new AliasedRawBuilderImpl(this, alias);
  }
  $castTo() {
    return new _RawBuilderImpl({ ...__privateGet(this, _props41) });
  }
  $notNull() {
    return new _RawBuilderImpl(__privateGet(this, _props41));
  }
  withPlugin(plugin) {
    return new _RawBuilderImpl({
      ...__privateGet(this, _props41),
      plugins: __privateGet(this, _props41).plugins !== void 0 ? freeze([...__privateGet(this, _props41).plugins, plugin]) : freeze([plugin])
    });
  }
  toOperationNode() {
    return __privateMethod(this, _RawBuilderImpl_instances, toOperationNode_fn).call(this, __privateMethod(this, _RawBuilderImpl_instances, getExecutor_fn).call(this));
  }
  compile(executorProvider) {
    return __privateMethod(this, _RawBuilderImpl_instances, compile_fn).call(this, __privateMethod(this, _RawBuilderImpl_instances, getExecutor_fn).call(this, executorProvider));
  }
  async execute(executorProvider) {
    const executor = __privateMethod(this, _RawBuilderImpl_instances, getExecutor_fn).call(this, executorProvider);
    return executor.executeQuery(__privateMethod(this, _RawBuilderImpl_instances, compile_fn).call(this, executor), __privateGet(this, _props41).queryId);
  }
};
_props41 = new WeakMap();
_RawBuilderImpl_instances = new WeakSet();
getExecutor_fn = function(executorProvider) {
  const executor = executorProvider !== void 0 ? executorProvider.getExecutor() : NOOP_QUERY_EXECUTOR;
  return __privateGet(this, _props41).plugins !== void 0 ? executor.withPlugins(__privateGet(this, _props41).plugins) : executor;
};
toOperationNode_fn = function(executor) {
  return executor.transformQuery(__privateGet(this, _props41).rawNode, __privateGet(this, _props41).queryId);
};
compile_fn = function(executor) {
  return executor.compileQuery(__privateMethod(this, _RawBuilderImpl_instances, toOperationNode_fn).call(this, executor), __privateGet(this, _props41).queryId);
};
var RawBuilderImpl = _RawBuilderImpl;
function createRawBuilder(props) {
  return new RawBuilderImpl(props);
}
preventAwait(RawBuilderImpl, "don't await RawBuilder instances directly. To execute the query you need to call `execute`");
var _rawBuilder, _alias5;
var AliasedRawBuilderImpl = class {
  constructor(rawBuilder, alias) {
    __privateAdd(this, _rawBuilder);
    __privateAdd(this, _alias5);
    __privateSet(this, _rawBuilder, rawBuilder);
    __privateSet(this, _alias5, alias);
  }
  get expression() {
    return __privateGet(this, _rawBuilder);
  }
  get alias() {
    return __privateGet(this, _alias5);
  }
  get rawBuilder() {
    return __privateGet(this, _rawBuilder);
  }
  toOperationNode() {
    return AliasNode.create(__privateGet(this, _rawBuilder).toOperationNode(), isOperationNodeSource(__privateGet(this, _alias5)) ? __privateGet(this, _alias5).toOperationNode() : IdentifierNode.create(__privateGet(this, _alias5)));
  }
};
_rawBuilder = new WeakMap();
_alias5 = new WeakMap();
preventAwait(AliasedRawBuilderImpl, "don't await AliasedRawBuilder instances directly. AliasedRawBuilder should never be executed directly since it's always a part of another query.");

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/raw-builder/sql.js
var sql = Object.assign((sqlFragments, ...parameters) => {
  var _a;
  return createRawBuilder({
    queryId: createQueryId(),
    rawNode: RawNode.create(sqlFragments, (_a = parameters == null ? void 0 : parameters.map(parseParameter)) != null ? _a : [])
  });
}, {
  ref(columnReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseStringReference(columnReference))
    });
  },
  val(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseValueExpression(value))
    });
  },
  value(value) {
    return this.val(value);
  },
  table(tableReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseTable(tableReference))
    });
  },
  id(...ids) {
    const fragments = new Array(ids.length + 1).fill(".");
    fragments[0] = "";
    fragments[fragments.length - 1] = "";
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create))
    });
  },
  lit(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(ValueNode.createImmediate(value))
    });
  },
  literal(value) {
    return this.lit(value);
  },
  raw(sql2) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithSql(sql2)
    });
  },
  join(array, separator = sql`, `) {
    const nodes = new Array(2 * array.length - 1);
    const sep = separator.toOperationNode();
    for (let i = 0; i < array.length; ++i) {
      nodes[2 * i] = parseParameter(array[i]);
      if (i !== array.length - 1) {
        nodes[2 * i + 1] = sep;
      }
    }
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChildren(nodes)
    });
  }
});
function parseParameter(param) {
  if (isOperationNodeSource(param)) {
    return param.toOperationNode();
  }
  return parseValueExpression(param);
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/operation-node/operation-node-visitor.js
var _visitors;
var OperationNodeVisitor = class {
  constructor() {
    __publicField(this, "nodeStack", []);
    __privateAdd(this, _visitors, freeze({
      AliasNode: this.visitAlias.bind(this),
      ColumnNode: this.visitColumn.bind(this),
      IdentifierNode: this.visitIdentifier.bind(this),
      SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
      RawNode: this.visitRaw.bind(this),
      ReferenceNode: this.visitReference.bind(this),
      SelectQueryNode: this.visitSelectQuery.bind(this),
      SelectionNode: this.visitSelection.bind(this),
      TableNode: this.visitTable.bind(this),
      FromNode: this.visitFrom.bind(this),
      SelectAllNode: this.visitSelectAll.bind(this),
      AndNode: this.visitAnd.bind(this),
      OrNode: this.visitOr.bind(this),
      ValueNode: this.visitValue.bind(this),
      ValueListNode: this.visitValueList.bind(this),
      PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
      ParensNode: this.visitParens.bind(this),
      JoinNode: this.visitJoin.bind(this),
      OperatorNode: this.visitOperator.bind(this),
      WhereNode: this.visitWhere.bind(this),
      InsertQueryNode: this.visitInsertQuery.bind(this),
      DeleteQueryNode: this.visitDeleteQuery.bind(this),
      ReturningNode: this.visitReturning.bind(this),
      CreateTableNode: this.visitCreateTable.bind(this),
      AddColumnNode: this.visitAddColumn.bind(this),
      ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
      DropTableNode: this.visitDropTable.bind(this),
      DataTypeNode: this.visitDataType.bind(this),
      OrderByNode: this.visitOrderBy.bind(this),
      OrderByItemNode: this.visitOrderByItem.bind(this),
      GroupByNode: this.visitGroupBy.bind(this),
      GroupByItemNode: this.visitGroupByItem.bind(this),
      UpdateQueryNode: this.visitUpdateQuery.bind(this),
      ColumnUpdateNode: this.visitColumnUpdate.bind(this),
      LimitNode: this.visitLimit.bind(this),
      OffsetNode: this.visitOffset.bind(this),
      OnConflictNode: this.visitOnConflict.bind(this),
      OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
      CreateIndexNode: this.visitCreateIndex.bind(this),
      DropIndexNode: this.visitDropIndex.bind(this),
      ListNode: this.visitList.bind(this),
      PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
      UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
      ReferencesNode: this.visitReferences.bind(this),
      CheckConstraintNode: this.visitCheckConstraint.bind(this),
      WithNode: this.visitWith.bind(this),
      CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
      CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),
      HavingNode: this.visitHaving.bind(this),
      CreateSchemaNode: this.visitCreateSchema.bind(this),
      DropSchemaNode: this.visitDropSchema.bind(this),
      AlterTableNode: this.visitAlterTable.bind(this),
      DropColumnNode: this.visitDropColumn.bind(this),
      RenameColumnNode: this.visitRenameColumn.bind(this),
      AlterColumnNode: this.visitAlterColumn.bind(this),
      ModifyColumnNode: this.visitModifyColumn.bind(this),
      AddConstraintNode: this.visitAddConstraint.bind(this),
      DropConstraintNode: this.visitDropConstraint.bind(this),
      ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
      CreateViewNode: this.visitCreateView.bind(this),
      DropViewNode: this.visitDropView.bind(this),
      GeneratedNode: this.visitGenerated.bind(this),
      DefaultValueNode: this.visitDefaultValue.bind(this),
      OnNode: this.visitOn.bind(this),
      ValuesNode: this.visitValues.bind(this),
      SelectModifierNode: this.visitSelectModifier.bind(this),
      CreateTypeNode: this.visitCreateType.bind(this),
      DropTypeNode: this.visitDropType.bind(this),
      ExplainNode: this.visitExplain.bind(this),
      DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
      AggregateFunctionNode: this.visitAggregateFunction.bind(this),
      OverNode: this.visitOver.bind(this),
      PartitionByNode: this.visitPartitionBy.bind(this),
      PartitionByItemNode: this.visitPartitionByItem.bind(this),
      SetOperationNode: this.visitSetOperation.bind(this),
      BinaryOperationNode: this.visitBinaryOperation.bind(this),
      UnaryOperationNode: this.visitUnaryOperation.bind(this),
      UsingNode: this.visitUsing.bind(this),
      FunctionNode: this.visitFunction.bind(this),
      CaseNode: this.visitCase.bind(this),
      WhenNode: this.visitWhen.bind(this),
      JSONReferenceNode: this.visitJSONReference.bind(this),
      JSONPathNode: this.visitJSONPath.bind(this),
      JSONPathLegNode: this.visitJSONPathLeg.bind(this),
      JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
      TupleNode: this.visitTuple.bind(this),
      MergeQueryNode: this.visitMergeQuery.bind(this),
      MatchedNode: this.visitMatched.bind(this),
      AddIndexNode: this.visitAddIndex.bind(this),
      CastNode: this.visitCast.bind(this),
      FetchNode: this.visitFetch.bind(this),
      TopNode: this.visitTop.bind(this),
      OutputNode: this.visitOutput.bind(this)
    }));
    __publicField(this, "visitNode", (node) => {
      this.nodeStack.push(node);
      __privateGet(this, _visitors)[node.kind](node);
      this.nodeStack.pop();
    });
  }
  get parentNode() {
    return this.nodeStack[this.nodeStack.length - 2];
  }
};
_visitors = new WeakMap();

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-compiler/default-query-compiler.js
var _sql, _parameters;
var DefaultQueryCompiler = class extends OperationNodeVisitor {
  constructor() {
    super(...arguments);
    __privateAdd(this, _sql, "");
    __privateAdd(this, _parameters, []);
  }
  get numParameters() {
    return __privateGet(this, _parameters).length;
  }
  compileQuery(node) {
    __privateSet(this, _sql, "");
    __privateSet(this, _parameters, []);
    this.nodeStack.splice(0, this.nodeStack.length);
    this.visitNode(node);
    return freeze({
      query: node,
      sql: this.getSql(),
      parameters: [...__privateGet(this, _parameters)]
    });
  }
  getSql() {
    return __privateGet(this, _sql);
  }
  visitSelectQuery(node) {
    var _a, _b;
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !InsertQueryNode.is(this.parentNode) && !CreateTableNode.is(this.parentNode) && !CreateViewNode.is(this.parentNode) && !SetOperationNode.is(this.parentNode);
    if (this.parentNode === void 0 && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("select");
    if (node.distinctOn) {
      this.append(" ");
      this.compileDistinctOn(node.distinctOn);
    }
    if ((_a = node.frontModifiers) == null ? void 0 : _a.length) {
      this.append(" ");
      this.compileList(node.frontModifiers, " ");
    }
    if (node.top) {
      this.append(" ");
      this.visitNode(node.top);
    }
    if (node.selections) {
      this.append(" ");
      this.compileList(node.selections);
    }
    if (node.from) {
      this.append(" ");
      this.visitNode(node.from);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.groupBy) {
      this.append(" ");
      this.visitNode(node.groupBy);
    }
    if (node.having) {
      this.append(" ");
      this.visitNode(node.having);
    }
    if (node.setOperations) {
      this.append(" ");
      this.compileList(node.setOperations, " ");
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.offset) {
      this.append(" ");
      this.visitNode(node.offset);
    }
    if (node.fetch) {
      this.append(" ");
      this.visitNode(node.fetch);
    }
    if ((_b = node.endModifiers) == null ? void 0 : _b.length) {
      this.append(" ");
      this.compileList(this.sortSelectModifiers([...node.endModifiers]), " ");
    }
    if (wrapInParens) {
      this.append(")");
    }
  }
  visitFrom(node) {
    this.append("from ");
    this.compileList(node.froms);
  }
  visitSelection(node) {
    this.visitNode(node.selection);
  }
  visitColumn(node) {
    this.visitNode(node.column);
  }
  compileDistinctOn(expressions) {
    this.append("distinct on (");
    this.compileList(expressions);
    this.append(")");
  }
  compileList(nodes, separator = ", ") {
    const lastIndex = nodes.length - 1;
    for (let i = 0; i <= lastIndex; i++) {
      this.visitNode(nodes[i]);
      if (i < lastIndex) {
        this.append(separator);
      }
    }
  }
  visitWhere(node) {
    this.append("where ");
    this.visitNode(node.where);
  }
  visitHaving(node) {
    this.append("having ");
    this.visitNode(node.having);
  }
  visitInsertQuery(node) {
    var _a;
    const rootQueryNode = this.nodeStack.find(QueryNode.is);
    const isSubQuery = rootQueryNode !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append(node.replace ? "replace" : "insert");
    if (node.ignore) {
      this.append(" ignore");
    }
    if (node.top) {
      this.append(" ");
      this.visitNode(node.top);
    }
    if (node.into) {
      this.append(" into ");
      this.visitNode(node.into);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.values) {
      this.append(" ");
      this.visitNode(node.values);
    }
    if (node.defaultValues) {
      this.append(" ");
      this.append("default values");
    }
    if (node.onConflict) {
      this.append(" ");
      this.visitNode(node.onConflict);
    }
    if (node.onDuplicateKey) {
      this.append(" ");
      this.visitNode(node.onDuplicateKey);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append(")");
    }
    if ((_a = node.endModifiers) == null ? void 0 : _a.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitValues(node) {
    this.append("values ");
    this.compileList(node.values);
  }
  visitDeleteQuery(node) {
    var _a;
    const isSubQuery = this.nodeStack.find(QueryNode.is) !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("delete ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    this.visitNode(node.from);
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.using) {
      this.append(" ");
      this.visitNode(node.using);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery) {
      this.append(")");
    }
    if ((_a = node.endModifiers) == null ? void 0 : _a.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitReturning(node) {
    this.append("returning ");
    this.compileList(node.selections);
  }
  visitAlias(node) {
    this.visitNode(node.node);
    this.append(" as ");
    this.visitNode(node.alias);
  }
  visitReference(node) {
    if (node.table) {
      this.visitNode(node.table);
      this.append(".");
    }
    this.visitNode(node.column);
  }
  visitSelectAll(_) {
    this.append("*");
  }
  visitIdentifier(node) {
    this.append(this.getLeftIdentifierWrapper());
    this.compileUnwrappedIdentifier(node);
    this.append(this.getRightIdentifierWrapper());
  }
  compileUnwrappedIdentifier(node) {
    if (!isString(node.name)) {
      throw new Error("a non-string identifier was passed to compileUnwrappedIdentifier.");
    }
    this.append(this.sanitizeIdentifier(node.name));
  }
  visitAnd(node) {
    this.visitNode(node.left);
    this.append(" and ");
    this.visitNode(node.right);
  }
  visitOr(node) {
    this.visitNode(node.left);
    this.append(" or ");
    this.visitNode(node.right);
  }
  visitValue(node) {
    if (node.immediate) {
      this.appendImmediateValue(node.value);
    } else {
      this.appendValue(node.value);
    }
  }
  visitValueList(node) {
    this.append("(");
    this.compileList(node.values);
    this.append(")");
  }
  visitTuple(node) {
    this.append("(");
    this.compileList(node.values);
    this.append(")");
  }
  visitPrimitiveValueList(node) {
    this.append("(");
    const { values } = node;
    for (let i = 0; i < values.length; ++i) {
      this.appendValue(values[i]);
      if (i !== values.length - 1) {
        this.append(", ");
      }
    }
    this.append(")");
  }
  visitParens(node) {
    this.append("(");
    this.visitNode(node.node);
    this.append(")");
  }
  visitJoin(node) {
    this.append(JOIN_TYPE_SQL[node.joinType]);
    this.append(" ");
    this.visitNode(node.table);
    if (node.on) {
      this.append(" ");
      this.visitNode(node.on);
    }
  }
  visitOn(node) {
    this.append("on ");
    this.visitNode(node.on);
  }
  visitRaw(node) {
    const { sqlFragments, parameters: params } = node;
    for (let i = 0; i < sqlFragments.length; ++i) {
      this.append(sqlFragments[i]);
      if (params.length > i) {
        this.visitNode(params[i]);
      }
    }
  }
  visitOperator(node) {
    this.append(node.operator);
  }
  visitTable(node) {
    this.visitNode(node.table);
  }
  visitSchemableIdentifier(node) {
    if (node.schema) {
      this.visitNode(node.schema);
      this.append(".");
    }
    this.visitNode(node.identifier);
  }
  visitCreateTable(node) {
    var _a;
    this.append("create ");
    if (node.frontModifiers && node.frontModifiers.length > 0) {
      this.compileList(node.frontModifiers, " ");
      this.append(" ");
    }
    if (node.temporary) {
      this.append("temporary ");
    }
    this.append("table ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.table);
    if (node.selectQuery) {
      this.append(" as ");
      this.visitNode(node.selectQuery);
    } else {
      this.append(" (");
      this.compileList([...node.columns, ...(_a = node.constraints) != null ? _a : []]);
      this.append(")");
      if (node.onCommit) {
        this.append(" on commit ");
        this.append(node.onCommit);
      }
      if (node.endModifiers && node.endModifiers.length > 0) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
  }
  visitColumnDefinition(node) {
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.column);
    this.append(" ");
    this.visitNode(node.dataType);
    if (node.unsigned) {
      this.append(" unsigned");
    }
    if (node.frontModifiers && node.frontModifiers.length > 0) {
      this.append(" ");
      this.compileList(node.frontModifiers, " ");
    }
    if (node.generated) {
      this.append(" ");
      this.visitNode(node.generated);
    }
    if (node.identity) {
      this.append(" identity");
    }
    if (node.defaultTo) {
      this.append(" ");
      this.visitNode(node.defaultTo);
    }
    if (node.notNull) {
      this.append(" not null");
    }
    if (node.unique) {
      this.append(" unique");
    }
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node.primaryKey) {
      this.append(" primary key");
    }
    if (node.autoIncrement) {
      this.append(" ");
      this.append(this.getAutoIncrement());
    }
    if (node.references) {
      this.append(" ");
      this.visitNode(node.references);
    }
    if (node.check) {
      this.append(" ");
      this.visitNode(node.check);
    }
    if (node.endModifiers && node.endModifiers.length > 0) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  getAutoIncrement() {
    return "auto_increment";
  }
  visitReferences(node) {
    this.append("references ");
    this.visitNode(node.table);
    this.append(" (");
    this.compileList(node.columns);
    this.append(")");
    if (node.onDelete) {
      this.append(" on delete ");
      this.append(node.onDelete);
    }
    if (node.onUpdate) {
      this.append(" on update ");
      this.append(node.onUpdate);
    }
  }
  visitDropTable(node) {
    this.append("drop table ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.table);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitDataType(node) {
    this.append(node.dataType);
  }
  visitOrderBy(node) {
    this.append("order by ");
    this.compileList(node.items);
  }
  visitOrderByItem(node) {
    this.visitNode(node.orderBy);
    if (node.direction) {
      this.append(" ");
      this.visitNode(node.direction);
    }
  }
  visitGroupBy(node) {
    this.append("group by ");
    this.compileList(node.items);
  }
  visitGroupByItem(node) {
    this.visitNode(node.groupBy);
  }
  visitUpdateQuery(node) {
    var _a;
    const rootQueryNode = this.nodeStack.find(QueryNode.is);
    const isSubQuery = rootQueryNode !== node;
    if (!isSubQuery && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("update ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    if (node.table) {
      this.visitNode(node.table);
      this.append(" ");
    }
    this.append("set ");
    if (node.updates) {
      this.compileList(node.updates);
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.from) {
      this.append(" ");
      this.visitNode(node.from);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
      this.append(")");
    }
    if ((_a = node.endModifiers) == null ? void 0 : _a.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitColumnUpdate(node) {
    this.visitNode(node.column);
    this.append(" = ");
    this.visitNode(node.value);
  }
  visitLimit(node) {
    this.append("limit ");
    this.visitNode(node.limit);
  }
  visitOffset(node) {
    this.append("offset ");
    this.visitNode(node.offset);
  }
  visitOnConflict(node) {
    this.append("on conflict");
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    } else if (node.constraint) {
      this.append(" on constraint ");
      this.visitNode(node.constraint);
    } else if (node.indexExpression) {
      this.append(" (");
      this.visitNode(node.indexExpression);
      this.append(")");
    }
    if (node.indexWhere) {
      this.append(" ");
      this.visitNode(node.indexWhere);
    }
    if (node.doNothing === true) {
      this.append(" do nothing");
    } else if (node.updates) {
      this.append(" do update set ");
      this.compileList(node.updates);
      if (node.updateWhere) {
        this.append(" ");
        this.visitNode(node.updateWhere);
      }
    }
  }
  visitOnDuplicateKey(node) {
    this.append("on duplicate key update ");
    this.compileList(node.updates);
  }
  visitCreateIndex(node) {
    this.append("create ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
  }
  visitDropIndex(node) {
    this.append("drop index ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitCreateSchema(node) {
    this.append("create schema ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.schema);
  }
  visitDropSchema(node) {
    this.append("drop schema ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.schema);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitPrimaryKeyConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("primary key (");
    this.compileList(node.columns);
    this.append(")");
  }
  visitUniqueConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("unique");
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    this.append(" (");
    this.compileList(node.columns);
    this.append(")");
  }
  visitCheckConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("check (");
    this.visitNode(node.expression);
    this.append(")");
  }
  visitForeignKeyConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("foreign key (");
    this.compileList(node.columns);
    this.append(") ");
    this.visitNode(node.references);
    if (node.onDelete) {
      this.append(" on delete ");
      this.append(node.onDelete);
    }
    if (node.onUpdate) {
      this.append(" on update ");
      this.append(node.onUpdate);
    }
  }
  visitList(node) {
    this.compileList(node.items);
  }
  visitWith(node) {
    this.append("with ");
    if (node.recursive) {
      this.append("recursive ");
    }
    this.compileList(node.expressions);
  }
  visitCommonTableExpression(node) {
    this.visitNode(node.name);
    this.append(" as ");
    if (isBoolean(node.materialized)) {
      if (!node.materialized) {
        this.append("not ");
      }
      this.append("materialized ");
    }
    this.visitNode(node.expression);
  }
  visitCommonTableExpressionName(node) {
    this.visitNode(node.table);
    if (node.columns) {
      this.append("(");
      this.compileList(node.columns);
      this.append(")");
    }
  }
  visitAlterTable(node) {
    this.append("alter table ");
    this.visitNode(node.table);
    this.append(" ");
    if (node.renameTo) {
      this.append("rename to ");
      this.visitNode(node.renameTo);
    }
    if (node.setSchema) {
      this.append("set schema ");
      this.visitNode(node.setSchema);
    }
    if (node.addConstraint) {
      this.visitNode(node.addConstraint);
    }
    if (node.dropConstraint) {
      this.visitNode(node.dropConstraint);
    }
    if (node.columnAlterations) {
      this.compileColumnAlterations(node.columnAlterations);
    }
    if (node.addIndex) {
      this.visitNode(node.addIndex);
    }
    if (node.dropIndex) {
      this.visitNode(node.dropIndex);
    }
  }
  visitAddColumn(node) {
    this.append("add column ");
    this.visitNode(node.column);
  }
  visitRenameColumn(node) {
    this.append("rename column ");
    this.visitNode(node.column);
    this.append(" to ");
    this.visitNode(node.renameTo);
  }
  visitDropColumn(node) {
    this.append("drop column ");
    this.visitNode(node.column);
  }
  visitAlterColumn(node) {
    this.append("alter column ");
    this.visitNode(node.column);
    this.append(" ");
    if (node.dataType) {
      if (this.announcesNewColumnDataType()) {
        this.append("type ");
      }
      this.visitNode(node.dataType);
      if (node.dataTypeExpression) {
        this.append("using ");
        this.visitNode(node.dataTypeExpression);
      }
    }
    if (node.setDefault) {
      this.append("set default ");
      this.visitNode(node.setDefault);
    }
    if (node.dropDefault) {
      this.append("drop default");
    }
    if (node.setNotNull) {
      this.append("set not null");
    }
    if (node.dropNotNull) {
      this.append("drop not null");
    }
  }
  visitModifyColumn(node) {
    this.append("modify column ");
    this.visitNode(node.column);
  }
  visitAddConstraint(node) {
    this.append("add ");
    this.visitNode(node.constraint);
  }
  visitDropConstraint(node) {
    this.append("drop constraint ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.constraintName);
    if (node.modifier === "cascade") {
      this.append(" cascade");
    } else if (node.modifier === "restrict") {
      this.append(" restrict");
    }
  }
  visitSetOperation(node) {
    this.append(node.operator);
    this.append(" ");
    if (node.all) {
      this.append("all ");
    }
    this.visitNode(node.expression);
  }
  visitCreateView(node) {
    this.append("create ");
    if (node.orReplace) {
      this.append("or replace ");
    }
    if (node.materialized) {
      this.append("materialized ");
    }
    if (node.temporary) {
      this.append("temporary ");
    }
    this.append("view ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    this.append(" ");
    if (node.columns) {
      this.append("(");
      this.compileList(node.columns);
      this.append(") ");
    }
    if (node.as) {
      this.append("as ");
      this.visitNode(node.as);
    }
  }
  visitDropView(node) {
    this.append("drop ");
    if (node.materialized) {
      this.append("materialized ");
    }
    this.append("view ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitGenerated(node) {
    this.append("generated ");
    if (node.always) {
      this.append("always ");
    }
    if (node.byDefault) {
      this.append("by default ");
    }
    this.append("as ");
    if (node.identity) {
      this.append("identity");
    }
    if (node.expression) {
      this.append("(");
      this.visitNode(node.expression);
      this.append(")");
    }
    if (node.stored) {
      this.append(" stored");
    }
  }
  visitDefaultValue(node) {
    this.append("default ");
    this.visitNode(node.defaultValue);
  }
  visitSelectModifier(node) {
    if (node.rawModifier) {
      this.visitNode(node.rawModifier);
    } else {
      this.append(SELECT_MODIFIER_SQL[node.modifier]);
    }
    if (node.of) {
      this.append(" of ");
      this.compileList(node.of, ", ");
    }
  }
  visitCreateType(node) {
    this.append("create type ");
    this.visitNode(node.name);
    if (node.enum) {
      this.append(" as enum ");
      this.visitNode(node.enum);
    }
  }
  visitDropType(node) {
    this.append("drop type ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
  }
  visitExplain(node) {
    this.append("explain");
    if (node.options || node.format) {
      this.append(" ");
      this.append(this.getLeftExplainOptionsWrapper());
      if (node.options) {
        this.visitNode(node.options);
        if (node.format) {
          this.append(this.getExplainOptionsDelimiter());
        }
      }
      if (node.format) {
        this.append("format");
        this.append(this.getExplainOptionAssignment());
        this.append(node.format);
      }
      this.append(this.getRightExplainOptionsWrapper());
    }
  }
  visitDefaultInsertValue(_) {
    this.append("default");
  }
  visitAggregateFunction(node) {
    this.append(node.func);
    this.append("(");
    if (node.distinct) {
      this.append("distinct ");
    }
    this.compileList(node.aggregated);
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    this.append(")");
    if (node.filter) {
      this.append(" filter(");
      this.visitNode(node.filter);
      this.append(")");
    }
    if (node.over) {
      this.append(" ");
      this.visitNode(node.over);
    }
  }
  visitOver(node) {
    this.append("over(");
    if (node.partitionBy) {
      this.visitNode(node.partitionBy);
      if (node.orderBy) {
        this.append(" ");
      }
    }
    if (node.orderBy) {
      this.visitNode(node.orderBy);
    }
    this.append(")");
  }
  visitPartitionBy(node) {
    this.append("partition by ");
    this.compileList(node.items);
  }
  visitPartitionByItem(node) {
    this.visitNode(node.partitionBy);
  }
  visitBinaryOperation(node) {
    this.visitNode(node.leftOperand);
    this.append(" ");
    this.visitNode(node.operator);
    this.append(" ");
    this.visitNode(node.rightOperand);
  }
  visitUnaryOperation(node) {
    this.visitNode(node.operator);
    if (!this.isMinusOperator(node.operator)) {
      this.append(" ");
    }
    this.visitNode(node.operand);
  }
  isMinusOperator(node) {
    return OperatorNode.is(node) && node.operator === "-";
  }
  visitUsing(node) {
    this.append("using ");
    this.compileList(node.tables);
  }
  visitFunction(node) {
    this.append(node.func);
    this.append("(");
    this.compileList(node.arguments);
    this.append(")");
  }
  visitCase(node) {
    this.append("case");
    if (node.value) {
      this.append(" ");
      this.visitNode(node.value);
    }
    if (node.when) {
      this.append(" ");
      this.compileList(node.when, " ");
    }
    if (node.else) {
      this.append(" else ");
      this.visitNode(node.else);
    }
    this.append(" end");
    if (node.isStatement) {
      this.append(" case");
    }
  }
  visitWhen(node) {
    this.append("when ");
    this.visitNode(node.condition);
    if (node.result) {
      this.append(" then ");
      this.visitNode(node.result);
    }
  }
  visitJSONReference(node) {
    this.visitNode(node.reference);
    this.visitNode(node.traversal);
  }
  visitJSONPath(node) {
    if (node.inOperator) {
      this.visitNode(node.inOperator);
    }
    this.append("'$");
    for (const pathLeg of node.pathLegs) {
      this.visitNode(pathLeg);
    }
    this.append("'");
  }
  visitJSONPathLeg(node) {
    const isArrayLocation = node.type === "ArrayLocation";
    this.append(isArrayLocation ? "[" : ".");
    this.append(String(node.value));
    if (isArrayLocation) {
      this.append("]");
    }
  }
  visitJSONOperatorChain(node) {
    for (let i = 0, len = node.values.length; i < len; i++) {
      if (i === len - 1) {
        this.visitNode(node.operator);
      } else {
        this.append("->");
      }
      this.visitNode(node.values[i]);
    }
  }
  visitMergeQuery(node) {
    var _a;
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("merge ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    this.append("into ");
    this.visitNode(node.into);
    if (node.using) {
      this.append(" ");
      this.visitNode(node.using);
    }
    if (node.whens) {
      this.append(" ");
      this.compileList(node.whens, " ");
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if ((_a = node.endModifiers) == null ? void 0 : _a.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitMatched(node) {
    if (node.not) {
      this.append("not ");
    }
    this.append("matched");
    if (node.bySource) {
      this.append(" by source");
    }
  }
  visitAddIndex(node) {
    this.append("add ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    this.visitNode(node.name);
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
  }
  visitCast(node) {
    this.append("cast(");
    this.visitNode(node.expression);
    this.append(" as ");
    this.visitNode(node.dataType);
    this.append(")");
  }
  visitFetch(node) {
    this.append("fetch next ");
    this.visitNode(node.rowCount);
    this.append(` rows ${node.modifier}`);
  }
  visitOutput(node) {
    this.append("output ");
    this.compileList(node.selections);
  }
  visitTop(node) {
    this.append(`top(${node.expression})`);
    if (node.modifiers) {
      this.append(` ${node.modifiers}`);
    }
  }
  append(str) {
    __privateSet(this, _sql, __privateGet(this, _sql) + str);
  }
  appendValue(parameter) {
    this.addParameter(parameter);
    this.append(this.getCurrentParameterPlaceholder());
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getCurrentParameterPlaceholder() {
    return "$" + this.numParameters;
  }
  getLeftExplainOptionsWrapper() {
    return "(";
  }
  getExplainOptionAssignment() {
    return " ";
  }
  getExplainOptionsDelimiter() {
    return ", ";
  }
  getRightExplainOptionsWrapper() {
    return ")";
  }
  sanitizeIdentifier(identifier) {
    const leftWrap = this.getLeftIdentifierWrapper();
    const rightWrap = this.getRightIdentifierWrapper();
    let sanitized = "";
    for (const c of identifier) {
      sanitized += c;
      if (c === leftWrap) {
        sanitized += leftWrap;
      } else if (c === rightWrap) {
        sanitized += rightWrap;
      }
    }
    return sanitized;
  }
  addParameter(parameter) {
    __privateGet(this, _parameters).push(parameter);
  }
  appendImmediateValue(value) {
    if (isString(value)) {
      this.append(`'${value}'`);
    } else if (isNumber(value) || isBoolean(value)) {
      this.append(value.toString());
    } else if (isNull(value)) {
      this.append("null");
    } else if (isDate(value)) {
      this.appendImmediateValue(value.toISOString());
    } else if (isBigInt(value)) {
      this.appendImmediateValue(value.toString());
    } else {
      throw new Error(`invalid immediate value ${value}`);
    }
  }
  sortSelectModifiers(arr) {
    arr.sort((left, right) => left.modifier && right.modifier ? SELECT_MODIFIER_PRIORITY[left.modifier] - SELECT_MODIFIER_PRIORITY[right.modifier] : 1);
    return freeze(arr);
  }
  compileColumnAlterations(columnAlterations) {
    this.compileList(columnAlterations);
  }
  /**
   * controls whether the dialect adds a "type" keyword before a column's new data
   * type in an ALTER TABLE statement.
   */
  announcesNewColumnDataType() {
    return true;
  }
};
_sql = new WeakMap();
_parameters = new WeakMap();
var SELECT_MODIFIER_SQL = freeze({
  ForKeyShare: "for key share",
  ForNoKeyUpdate: "for no key update",
  ForUpdate: "for update",
  ForShare: "for share",
  NoWait: "nowait",
  SkipLocked: "skip locked",
  Distinct: "distinct"
});
var SELECT_MODIFIER_PRIORITY = freeze({
  ForKeyShare: 1,
  ForNoKeyUpdate: 1,
  ForUpdate: 1,
  ForShare: 1,
  NoWait: 2,
  SkipLocked: 2,
  Distinct: 0
});
var JOIN_TYPE_SQL = freeze({
  InnerJoin: "inner join",
  LeftJoin: "left join",
  RightJoin: "right join",
  FullJoin: "full join",
  LateralInnerJoin: "inner join lateral",
  LateralLeftJoin: "left join lateral",
  Using: "using"
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/query-compiler/compiled-query.js
var CompiledQuery = freeze({
  raw(sql2, parameters = []) {
    return freeze({
      sql: sql2,
      query: RawNode.createWithSql(sql2),
      parameters: freeze(parameters)
    });
  }
});

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/dialect/dialect-adapter-base.js
var DialectAdapterBase = class {
  get supportsCreateIfNotExists() {
    return true;
  }
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return false;
  }
  get supportsOutput() {
    return false;
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/dialect/sqlite/sqlite-query-compiler.js
var ID_WRAP_REGEX = /"/g;
var SqliteQueryCompiler = class extends DefaultQueryCompiler {
  getCurrentParameterPlaceholder() {
    return "?";
  }
  getLeftExplainOptionsWrapper() {
    return "";
  }
  getRightExplainOptionsWrapper() {
    return "";
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getAutoIncrement() {
    return "autoincrement";
  }
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX, '""');
  }
  visitDefaultInsertValue(_) {
    this.append("null");
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/migration/migrator.js
var DEFAULT_MIGRATION_TABLE = "kysely_migration";
var DEFAULT_MIGRATION_LOCK_TABLE = "kysely_migration_lock";
freeze({ __noMigrations__: true });

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/dialect/sqlite/sqlite-introspector.js
var _db, _SqliteIntrospector_instances, tablesQuery_fn, getTableMetadata_fn;
var SqliteIntrospector = class {
  constructor(db) {
    __privateAdd(this, _SqliteIntrospector_instances);
    __privateAdd(this, _db);
    __privateSet(this, _db, db);
  }
  async getSchemas() {
    return [];
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    return await __privateMethod(this, _SqliteIntrospector_instances, getTableMetadata_fn).call(this, options);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
};
_db = new WeakMap();
_SqliteIntrospector_instances = new WeakSet();
tablesQuery_fn = function(qb, options) {
  let tablesQuery = qb.selectFrom("sqlite_master").where("type", "in", ["table", "view"]).where("name", "not like", "sqlite_%").select(["name", "sql", "type"]).orderBy("name");
  if (!options.withInternalKyselyTables) {
    tablesQuery = tablesQuery.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
  }
  return tablesQuery;
};
getTableMetadata_fn = async function(options) {
  var _a, _b;
  const tablesResult = await __privateMethod(this, _SqliteIntrospector_instances, tablesQuery_fn).call(this, __privateGet(this, _db), options).execute();
  const tableMetadata = await __privateGet(this, _db).with("table_list", (qb) => __privateMethod(this, _SqliteIntrospector_instances, tablesQuery_fn).call(this, qb, options)).selectFrom([
    "table_list as tl",
    sql`pragma_table_info(tl.name)`.as("p")
  ]).select([
    "tl.name as table",
    "p.cid",
    "p.name",
    "p.type",
    "p.notnull",
    "p.dflt_value",
    "p.pk"
  ]).orderBy(["tl.name", "p.cid"]).execute();
  const columnsByTable = {};
  for (const row of tableMetadata) {
    (_b = columnsByTable[_a = row.table]) != null ? _b : columnsByTable[_a] = [];
    columnsByTable[row.table].push(row);
  }
  return tablesResult.map(({ name, sql: sql2, type }) => {
    var _a2, _b2, _c, _d, _e, _f;
    let autoIncrementCol = (_e = (_d = (_c = (_b2 = (_a2 = sql2 == null ? void 0 : sql2.split(/[\(\),]/)) == null ? void 0 : _a2.find((it) => it.toLowerCase().includes("autoincrement"))) == null ? void 0 : _b2.trimStart()) == null ? void 0 : _c.split(/\s+/)) == null ? void 0 : _d[0]) == null ? void 0 : _e.replace(/["`]/g, "");
    const columns = (_f = columnsByTable[name]) != null ? _f : [];
    if (!autoIncrementCol) {
      const pkCols = columns.filter((r) => r.pk > 0);
      if (pkCols.length === 1 && pkCols[0].type.toLowerCase() === "integer") {
        autoIncrementCol = pkCols[0].name;
      }
    }
    return {
      name,
      isView: type === "view",
      columns: columns.map((col) => ({
        name: col.name,
        dataType: col.type,
        isNullable: !col.notnull,
        isAutoIncrementing: col.name === autoIncrementCol,
        hasDefaultValue: col.dflt_value != null,
        comment: void 0
      }))
    };
  });
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/dialect/sqlite/sqlite-adapter.js
var SqliteAdapter = class extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return true;
  }
  async acquireMigrationLock(_db2, _opt) {
  }
  async releaseMigrationLock(_db2, _opt) {
  }
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/plugin/parse-json-results/parse-json-results-plugin.js
var _objectStrategy;
var ParseJSONResultsPlugin = class {
  constructor(opt = {}) {
    __publicField(this, "opt");
    __privateAdd(this, _objectStrategy);
    this.opt = opt;
    __privateSet(this, _objectStrategy, opt.objectStrategy || "in-place");
  }
  // noop
  transformQuery(args) {
    return args.node;
  }
  async transformResult(args) {
    return {
      ...args.result,
      rows: parseArray(args.result.rows, __privateGet(this, _objectStrategy))
    };
  }
};
_objectStrategy = new WeakMap();
function parseArray(arr, objectStrategy) {
  const target = objectStrategy === "create" ? new Array(arr.length) : arr;
  for (let i = 0; i < arr.length; ++i) {
    target[i] = parse(arr[i], objectStrategy);
  }
  return target;
}
function parse(obj, objectStrategy) {
  if (isString(obj)) {
    return parseString(obj);
  }
  if (Array.isArray(obj)) {
    return parseArray(obj, objectStrategy);
  }
  if (isPlainObject(obj)) {
    return parseObject(obj, objectStrategy);
  }
  return obj;
}
function parseString(str) {
  if (maybeJson(str)) {
    try {
      return parse(JSON.parse(str), "in-place");
    } catch (err) {
    }
  }
  return str;
}
function maybeJson(value) {
  return value.match(/^[\[\{]/) != null;
}
function parseObject(obj, objectStrategy) {
  const target = objectStrategy === "create" ? {} : obj;
  for (const key in obj) {
    target[key] = parse(obj[key], objectStrategy);
  }
  return target;
}

// ../lix-sdk/src/change-set/apply-change-set.ts
async function applyChangeSet(args) {
  const executeInTransaction = async (trx) => {
    const version = await trx.selectFrom("active_version").innerJoin("version", "version.id", "active_version.version_id").selectAll("version").executeTakeFirstOrThrow();
    await trx.updateTable("version").set({ change_set_id: args.changeSet.id }).where("id", "=", version.id).execute();
    if (version.change_set_id !== args.changeSet.id) {
      const existingEdge = await trx.selectFrom("change_set_edge_all").where("parent_id", "=", version.change_set_id).where("child_id", "=", args.changeSet.id).where("lixcol_version_id", "=", "global").selectAll().executeTakeFirst();
      if (!existingEdge) {
        await trx.insertInto("change_set_edge_all").values({
          parent_id: version.change_set_id,
          child_id: args.changeSet.id,
          lixcol_version_id: "global"
        }).execute();
      }
    }
    const changesResult = await trx.selectFrom("change").innerJoin(
      "change_set_element_all",
      "change_set_element_all.change_id",
      "change.id"
    ).where("change_set_element_all.change_set_id", "=", args.changeSet.id).where("change_set_element_all.lixcol_version_id", "=", "global").selectAll("change").select(sql`${version.id}`.as("version_id")).execute();
    for (const change of changesResult) {
      const cacheKey = {
        entity_id: change.entity_id,
        schema_key: change.schema_key,
        file_id: change.file_id,
        version_id: version.id
      };
      if (change.snapshot_content === null) {
        await trx.deleteFrom("internal_state_cache").where("entity_id", "=", cacheKey.entity_id).where("schema_key", "=", cacheKey.schema_key).where("file_id", "=", cacheKey.file_id).where("version_id", "=", version.id).execute();
      } else {
        await trx.insertInto("internal_state_cache").values({
          ...cacheKey,
          plugin_key: change.plugin_key,
          inheritance_delete_marker: change.snapshot_content === null ? 1 : 0,
          snapshot_content: JSON.stringify(change.snapshot_content),
          schema_version: change.schema_version,
          created_at: change.created_at,
          updated_at: change.created_at,
          change_id: change.id
        }).onConflict(
          (oc) => oc.columns(["entity_id", "schema_key", "file_id", "version_id"]).doUpdateSet({
            plugin_key: change.plugin_key,
            snapshot_content: sql`excluded.snapshot_content`,
            schema_version: change.schema_version,
            updated_at: change.created_at
          })
        ).execute();
      }
    }
    const changesGroupedByFile = Object.groupBy(
      changesResult,
      (c) => c.file_id
    );
    const plugins = await args.lix.plugin.getAll();
    for (const [file_id, changes] of Object.entries(changesGroupedByFile)) {
      if (!(changes == null ? void 0 : changes.length)) continue;
      if (file_id === "lix") {
        continue;
      }
      const hasLixOwnEntityChanges = changes.some(
        (c) => c.plugin_key === "lix_own_entity"
      );
      if (hasLixOwnEntityChanges) {
        continue;
      }
      const hasFileDeletion = changes.some(
        (c) => c.snapshot_content === null && c.schema_key === "lix_file"
      );
      if (hasFileDeletion) {
        await trx.deleteFrom("file").where("id", "=", file_id).execute();
        continue;
      }
      const file = await trx.selectFrom("file").where("id", "=", file_id).selectAll().executeTakeFirstOrThrow();
      const groupByPlugin = Object.groupBy(changes, (c) => c.plugin_key);
      for (const [pluginKey, pluginChanges] of Object.entries(groupByPlugin)) {
        if (!(pluginChanges == null ? void 0 : pluginChanges.length)) continue;
        const plugin = plugins.find((p) => p.key === pluginKey);
        if (!plugin) {
          throw new Error(`Plugin with key ${pluginKey} not found`);
        }
        if (!plugin.applyChanges) {
          throw new Error(
            `Plugin with key ${pluginKey} does not support applying changes`
          );
        }
        const { fileData } = plugin.applyChanges({
          changes: pluginChanges,
          file
        });
        await trx.updateTable("file").set({ data: fileData }).where("id", "=", file.id).execute();
      }
    }
  };
  return args.lix.db.isTransaction ? executeInTransaction(args.lix.db) : args.lix.db.transaction().execute(executeInTransaction);
}

// ../lix-sdk/src/query-filter/change-set-element-in-ancestry-of.ts
function changeSetElementInAncestryOf(target, options) {
  const depthLimit = options == null ? void 0 : options.depth;
  const targetsArray = Array.isArray(target) ? target : [target];
  if (targetsArray.length === 0) {
    throw new Error(
      "changeSetElementInAncestryOf requires at least one target change set."
    );
  }
  const targetIds = targetsArray.map(
    (cs) => typeof cs === "object" && cs !== null ? cs.id : cs
  );
  return () => sql`
      change_set_element.change_set_id IN (
        WITH RECURSIVE ancestors(id, depth) AS (
          SELECT id, 0 AS depth FROM change_set WHERE id IN (${sql.join(targetIds.map((id) => sql.lit(id)))})
          UNION ALL
          SELECT change_set_edge.parent_id, ancestors.depth + 1
          FROM change_set_edge
          JOIN ancestors ON change_set_edge.child_id = ancestors.id
          ${depthLimit !== void 0 ? sql`WHERE ancestors.depth < ${sql.lit(depthLimit)}` : sql``}
        )
        SELECT id FROM ancestors
      )
    `;
}

// ../lix-sdk/src/query-filter/change-set-element-is-leaf-of.ts
function changeSetElementIsLeafOf(target) {
  const targetsArray = Array.isArray(target) ? target : [target];
  if (targetsArray.length === 0) {
    throw new Error(
      "changeSetElementIsLeafOf requires at least one targetChangeSet."
    );
  }
  const ids = targetsArray.map(
    (cs) => typeof cs === "object" && cs !== null ? cs.id : cs
  );
  const changeSetIds = ids.map((id) => sql`SELECT ${sql.lit(id)} as id`).reduce((acc, curr) => acc ? sql`${acc} UNION ALL ${curr}` : curr);
  return () => sql`
      -- Element must exist within the combined ancestry
      change_set_element.change_set_id IN (
        WITH RECURSIVE combined_ancestry(id) AS (
          ${changeSetIds}
          UNION -- Use UNION here to combine heads with recursive parent lookup (deduplicates)
          SELECT cse.parent_id
          FROM change_set_edge cse
          JOIN combined_ancestry a ON cse.child_id = a.id
          WHERE cse.parent_id IS NOT NULL
        )
        SELECT id FROM combined_ancestry
      )
      AND
      -- And it must be a leaf within that combined ancestry
      NOT EXISTS (
        WITH RECURSIVE
        -- Combined Ancestry: All change sets from ALL targetChangeSets upwards
        combined_ancestry(id) AS (
          ${changeSetIds}
          UNION -- Use UNION here to combine heads with recursive parent lookup (deduplicates)
          SELECT cse.parent_id
          FROM change_set_edge cse
          JOIN combined_ancestry a ON cse.child_id = a.id
          WHERE cse.parent_id IS NOT NULL
        ),
        -- Descendants: All change sets from the current element's change set downwards
        -- (relative to the element being checked, NOT the target heads)
        descendants(id) AS (
          SELECT change_set_element.change_set_id
          UNION ALL
          SELECT cse.child_id
          FROM change_set_edge cse
          JOIN descendants d ON cse.parent_id = d.id
        )
        -- Check for a newer element defining the same entity
        SELECT 1
        FROM change_set_element AS newer_cse
        WHERE
          -- Same entity definition
          newer_cse.entity_id = change_set_element.entity_id
          AND newer_cse.file_id = change_set_element.file_id
          AND newer_cse.schema_key = change_set_element.schema_key
          -- Different element instance
          AND (newer_cse.change_set_id != change_set_element.change_set_id 
               OR newer_cse.change_id != change_set_element.change_id)
          -- Newer element must be in the combined ancestry of the target change sets
          AND newer_cse.change_set_id IN (SELECT id FROM combined_ancestry)
          -- Newer element's change set must be a descendant of the current element's change set
          AND newer_cse.change_set_id IN (SELECT id FROM descendants)
      )
    `;
}

// ../lix-sdk/src/change-set/create-merge-change-set.ts
async function createMergeChangeSet(args) {
  const executeInTransaction = async (trx) => {
    const mergedElements = await trx.with(
      "SourceLeaves",
      (db) => db.selectFrom("change_set_element").where(changeSetElementInAncestryOf([args.source])).where(changeSetElementIsLeafOf([args.source])).selectAll("change_set_element")
    ).with(
      "TargetLeaves",
      (db) => db.selectFrom("change_set_element").where(changeSetElementInAncestryOf([args.target])).where(changeSetElementIsLeafOf([args.target])).selectAll("change_set_element")
    ).selectFrom("SourceLeaves").selectAll().union(
      (db) => db.selectFrom("TargetLeaves").selectAll().where(
        ({ not, exists, selectFrom }) => not(
          exists(
            // ...that do NOT have a corresponding entity in SourceLeaves
            selectFrom("SourceLeaves").select("SourceLeaves.entity_id").whereRef(
              "SourceLeaves.entity_id",
              "=",
              "TargetLeaves.entity_id"
            ).whereRef(
              "SourceLeaves.file_id",
              "=",
              "TargetLeaves.file_id"
            ).whereRef(
              "SourceLeaves.schema_key",
              "=",
              "TargetLeaves.schema_key"
            )
          )
        )
      )
      // End WHERE NOT EXISTS
    ).execute();
    const newChangeSet = await createChangeSet({
      lix: { ...args.lix, db: trx },
      elements: mergedElements.map((ce) => ({
        change_id: ce.change_id,
        entity_id: ce.entity_id,
        schema_key: ce.schema_key,
        file_id: ce.file_id
      })),
      parents: [args.source, args.target]
    });
    return newChangeSet;
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/change-set/create-undo-change-set.ts
async function createUndoChangeSet(args) {
  const executeInTransaction = async (trx) => {
    const parents = await trx.selectFrom("change_set_edge_all").where("lixcol_version_id", "=", "global").where("child_id", "=", args.changeSet.id).select("parent_id").execute();
    if (parents.length > 1) {
      throw new Error(
        "Cannot undo change sets with multiple parents (merge scenarios not yet supported)"
      );
    }
    const targetChanges = await trx.selectFrom("change").innerJoin(
      "change_set_element_all",
      "change_set_element_all.change_id",
      "change.id"
    ).where("change_set_element_all.lixcol_version_id", "=", "global").where("change_set_element_all.change_set_id", "=", args.changeSet.id).selectAll("change").execute();
    const undoChanges = [];
    for (const change of targetChanges) {
      if (parents.length === 0) {
        undoChanges.push({
          entity_id: change.entity_id,
          file_id: change.file_id,
          plugin_key: change.plugin_key,
          schema_key: change.schema_key,
          schema_version: change.schema_version,
          snapshot_content: null
          // Mark as deletion
        });
      } else {
        const parentChangeSet = parents[0].parent_id;
        const previousChange = await trx.selectFrom("change").innerJoin(
          "change_set_element",
          "change_set_element.change_id",
          "change.id"
        ).where("change_set_element.change_set_id", "=", parentChangeSet).where("change_set_element.entity_id", "=", change.entity_id).where("change_set_element.file_id", "=", change.file_id).where("change_set_element.schema_key", "=", change.schema_key).selectAll("change").executeTakeFirst();
        if (previousChange) {
          undoChanges.push({
            id: v7_default(),
            entity_id: change.entity_id,
            file_id: change.file_id,
            plugin_key: change.plugin_key,
            schema_key: change.schema_key,
            schema_version: change.schema_version,
            snapshot_content: previousChange.snapshot_content
            // Restore previous snapshot
          });
        } else {
          undoChanges.push({
            id: v7_default(),
            entity_id: change.entity_id,
            file_id: change.file_id,
            plugin_key: change.plugin_key,
            schema_key: change.schema_key,
            schema_version: change.schema_version,
            snapshot_content: null
            // Mark as deletion
          });
        }
      }
    }
    const createdUndoChanges = undoChanges.length > 0 ? await trx.insertInto("change").values(undoChanges).returningAll().execute() : [];
    const undoChangeSet = await createChangeSet({
      lix: { ...args.lix, db: trx },
      labels: args.labels,
      lixcol_version_id: "global",
      elements: createdUndoChanges.map((change) => ({
        change_id: change.id,
        entity_id: change.entity_id,
        schema_key: change.schema_key,
        file_id: change.file_id
      }))
    });
    return undoChangeSet;
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/change-set/create-checkpoint.ts
async function createCheckpoint(args) {
  const executeInTransaction = async (trx) => {
    const activeVersion = await trx.selectFrom("active_version").innerJoin("version", "version.id", "active_version.version_id").selectAll("version").executeTakeFirstOrThrow();
    const workingChangeSetId = activeVersion.working_change_set_id;
    const parentChangeSetId = activeVersion.change_set_id;
    const workingElements = await trx.selectFrom("change_set_element_all").where("change_set_id", "=", workingChangeSetId).where("lixcol_version_id", "=", "global").selectAll().execute();
    if (workingElements.length === 0) {
      throw new Error(
        "No changes in working change set to create a checkpoint for."
      );
    }
    await trx.insertInto("change_set_edge_all").values({
      parent_id: parentChangeSetId,
      child_id: workingChangeSetId,
      lixcol_version_id: "global"
    }).execute();
    const newWorkingChangeSetId = nanoid();
    await trx.insertInto("change_set_all").values({
      id: newWorkingChangeSetId,
      lixcol_version_id: "global"
    }).execute();
    const checkpointLabel = await trx.selectFrom("label").where("name", "=", "checkpoint").select("id").executeTakeFirstOrThrow();
    await trx.insertInto("change_set_label_all").values({
      change_set_id: workingChangeSetId,
      label_id: checkpointLabel.id,
      lixcol_version_id: "global"
    }).execute();
    await trx.updateTable("version").where("id", "=", activeVersion.id).set({
      change_set_id: workingChangeSetId,
      // becomes checkpoint
      working_change_set_id: newWorkingChangeSetId
    }).execute();
    await trx.insertInto("change_set_edge_all").values({
      parent_id: workingChangeSetId,
      child_id: newWorkingChangeSetId,
      lixcol_version_id: "global"
    }).execute();
    return {
      id: workingChangeSetId
    };
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/change-set/create-transition-change-set.ts
async function createTransitionChangeSet(args) {
  const executeInTransaction = async (trx) => {
    const leafChangesToApply = await trx.selectFrom("change").innerJoin(
      "change_set_element",
      "change_set_element.change_id",
      "change.id"
    ).where(changeSetElementInAncestryOf([args.targetChangeSet])).where(changeSetElementIsLeafOf([args.targetChangeSet])).select([
      "change.id",
      "change.entity_id",
      "change.schema_key",
      "change.file_id"
    ]).distinct().execute();
    const leafEntitiesToDelete = await trx.selectFrom("change").innerJoin(
      "change_set_element",
      "change_set_element.change_id",
      "change.id"
    ).where(changeSetElementInAncestryOf([{ id: args.sourceChangeSet.id }])).where(changeSetElementIsLeafOf([{ id: args.sourceChangeSet.id }])).where(
      ({ not, exists, selectFrom }) => not(
        exists(
          selectFrom("change as target_leaf_check").innerJoin(
            "change_set_element as target_cs_elem",
            "target_cs_elem.change_id",
            "target_leaf_check.id"
          ).whereRef("target_leaf_check.id", "=", "change.id").where(changeSetElementInAncestryOf([args.targetChangeSet])).where(changeSetElementIsLeafOf([args.targetChangeSet])).select("target_leaf_check.id")
        )
      )
    ).where(
      ({ not, exists, selectFrom }) => not(
        exists(
          selectFrom("change as restored_entity_check").innerJoin(
            "change_set_element as restored_cs_elem",
            "restored_cs_elem.change_id",
            "restored_entity_check.id"
          ).whereRef(
            "restored_entity_check.entity_id",
            "=",
            "change.entity_id"
          ).where(changeSetElementInAncestryOf([args.targetChangeSet])).where(changeSetElementIsLeafOf([args.targetChangeSet])).select("restored_entity_check.id")
        )
      )
    ).select([
      "change.id",
      "change.entity_id",
      "change.plugin_key",
      "change.schema_version",
      "change.schema_key",
      "change.file_id"
    ]).distinct().execute();
    const deleteChanges = leafEntitiesToDelete.length > 0 ? await trx.insertInto("change").values(
      leafEntitiesToDelete.map((c) => ({
        schema_key: c.schema_key,
        schema_version: c.schema_version,
        plugin_key: c.plugin_key,
        entity_id: c.entity_id,
        file_id: c.file_id,
        // delete change
        snapshot_id: "no-content"
      }))
    ).returning(["id", "entity_id", "schema_key", "file_id"]).execute() : [];
    const combinedChanges = [...leafChangesToApply, ...deleteChanges];
    if (combinedChanges.length === 0) {
      throw new Error("No changes to apply in the transition change set.");
    }
    const transitionChangeSet = await createChangeSet({
      lix: { ...args.lix, db: trx },
      elements: combinedChanges.map((change) => ({
        change_id: change.id,
        entity_id: change.entity_id,
        schema_key: change.schema_key,
        file_id: change.file_id
      }))
    });
    return transitionChangeSet;
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/version/schema.ts
var import_human_id2 = __toESM(require_dist());
function applyVersionDatabaseSchema(sqlite) {
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixVersionSchema,
    overrideName: "version",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix",
    hardcodedVersionId: "global",
    defaultValues: {
      id: () => nanoid(),
      name: () => (0, import_human_id2.humanId)(),
      working_change_set_id: () => nanoid(),
      inherits_from_version_id: () => "global",
      hidden: () => false
    }
  });
  sqlite.exec(`
		CREATE VIEW IF NOT EXISTS active_version AS
		SELECT
			json_extract(snapshot_content, '$.version_id') AS version_id,
			inherited_from_version_id AS lixcol_inherited_from_version_id,
			created_at AS lixcol_created_at,
			updated_at AS lixcol_updated_at,
			file_id AS lixcol_file_id,
			change_id AS lixcol_change_id,
			untracked AS lixcol_untracked
		FROM state_all
		WHERE schema_key = 'lix_active_version' AND version_id = 'global';

		CREATE TRIGGER IF NOT EXISTS active_version_insert
		INSTEAD OF INSERT ON active_version
		BEGIN
			INSERT INTO state_all (
				entity_id,
				schema_key,
				file_id,
				plugin_key,
				snapshot_content,
				schema_version,
				version_id,
				untracked
			) VALUES (
				'active',
				'lix_active_version',
				'lix',
				'lix_own_entity',
				json_object('version_id', NEW.version_id),
				'1.0',
				'global',
				1
			);
		END;

		CREATE TRIGGER IF NOT EXISTS active_version_update
		INSTEAD OF UPDATE ON active_version
		BEGIN
			UPDATE state_all
			SET
				snapshot_content = json_object('version_id', NEW.version_id),
				untracked = 1
			WHERE
				entity_id = 'active'
				AND schema_key = 'lix_active_version'
				AND version_id = 'global';
		END;

		CREATE TRIGGER IF NOT EXISTS active_version_delete
		INSTEAD OF DELETE ON active_version
		BEGIN
			DELETE FROM state_all
			WHERE entity_id = 'active'
			AND schema_key = 'lix_active_version'
			AND version_id = 'global';
		END;
	`);
}
var LixVersionSchema = {
  "x-lix-key": "lix_version",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["id"],
  "x-lix-unique": [["working_change_set_id"]],
  "x-lix-foreign-keys": {
    change_set_id: {
      schemaKey: "lix_change_set",
      property: "id"
    },
    working_change_set_id: {
      schemaKey: "lix_change_set",
      property: "id"
    },
    inherits_from_version_id: {
      schemaKey: "lix_version",
      property: "id"
    }
  },
  type: "object",
  properties: {
    id: { type: "string", "x-lix-generated": true },
    name: { type: "string", "x-lix-generated": true },
    change_set_id: { type: "string" },
    working_change_set_id: { type: "string", "x-lix-generated": true },
    inherits_from_version_id: {
      type: ["string", "null"],
      "x-lix-generated": true
    },
    hidden: { type: "boolean", "x-lix-generated": true }
  },
  required: ["id", "name", "change_set_id", "working_change_set_id"],
  additionalProperties: false
};

// ../lix-sdk/src/snapshot/schema.ts
function applySnapshotDatabaseSchema(sqlite) {
  return sqlite.exec(`
  CREATE TABLE IF NOT EXISTS internal_snapshot (
    id TEXT PRIMARY KEY DEFAULT (uuid_v7()),
    content BLOB -- jsonb or binary file
  ) STRICT;

  INSERT OR IGNORE INTO internal_snapshot (id, content)
  VALUES ('no-content', NULL);
`);
}

// ../lix-sdk/src/schema-definition/json-type.ts
var JSONTypeSchema = {
  anyOf: [
    { type: "object" },
    { type: "array" },
    { type: "string" },
    { type: "number" },
    { type: "boolean" },
    { type: "null" }
  ]
};
function isJsonType(def) {
  if (def.type) {
    const types = Array.isArray(def.type) ? def.type : [def.type];
    if (types.includes("object") || types.includes("array")) return true;
  }
  if (Array.isArray(def.anyOf)) {
    if (def.anyOf.some(
      (sub) => sub.type === "object" || sub.type === "array"
    ))
      return true;
  }
  return false;
}

// ../lix-sdk/src/stored-schema/schema.ts
function applyStoredSchemaDatabaseSchema(sqlite) {
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixStoredSchemaSchema,
    overrideName: "stored_schema",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix",
    defaultValues: {
      key: (row) => {
        var _a;
        return ((_a = row.value) == null ? void 0 : _a["x-lix-key"]) || "";
      },
      version: (row) => {
        var _a;
        return ((_a = row.value) == null ? void 0 : _a["x-lix-version"]) || "";
      }
    },
    validation: {
      onInsert: [
        {
          condition: "NEW.key IS NULL OR NEW.key = json_extract(NEW.value, '$.x-lix-key')",
          errorMessage: `Inserted key does not match value.x-lix-key: key=" || NEW.key || " x-lix-key=" || json_extract(NEW.value, '$.x-lix-key')`
        },
        {
          condition: "NEW.version IS NULL OR NEW.version = json_extract(NEW.value, '$.x-lix-version')",
          errorMessage: `Inserted version does not match value.x-lix-version: version=" || NEW.version || " x-lix-version=" || json_extract(NEW.value, '$.x-lix-version')`
        }
      ],
      onUpdate: [
        {
          condition: "0",
          // Always fail
          errorMessage: "Schemas are immutable and cannot be updated for backwards compatibility. Bump the version number instead."
        }
      ]
    }
  });
}
var LixStoredSchemaSchema = {
  "x-lix-key": "lix_stored_schema",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["key", "version"],
  type: "object",
  properties: {
    key: { type: "string", "x-lix-generated": true },
    version: { type: "string", "x-lix-generated": true },
    value: JSONTypeSchema
  },
  additionalProperties: false
};

// ../lix-sdk/src/key-value/schema.ts
function applyKeyValueDatabaseSchema(sqlite) {
  return createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixKeyValueSchema,
    overrideName: "key_value",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix"
  });
}
var LixKeyValueSchema = {
  "x-lix-key": "lix_key_value",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["key"],
  type: "object",
  properties: {
    key: { type: "string" },
    value: JSONTypeSchema
  },
  required: ["key", "value"],
  additionalProperties: false
};

// ../lix-sdk/src/database/execute-sync.ts
function executeSync(args) {
  const compiledQuery = args.query.compile();
  const columnNames = [];
  const result = args.lix.sqlite.exec({
    sql: compiledQuery.sql,
    bind: compiledQuery.parameters,
    returnValue: "resultRows",
    columnNames
  });
  return result.map((row) => {
    const obj = {};
    columnNames.forEach((columnName, index) => {
      obj[columnName] = row[index];
    });
    return obj;
  });
}

// ../lix-sdk/src/log/create-lix-own-log.ts
var DEFAULT_LOG_LEVELS = ["info", "warn", "error"];
function createLixOwnLogSync(args) {
  const logLevels = executeSync({
    lix: args.lix,
    query: args.lix.db.selectFrom("key_value").select("value").where("key", "=", "lix_log_levels")
  })[0];
  const shouldLog = logLevels === void 0 && DEFAULT_LOG_LEVELS.includes(args.level) || (logLevels == null ? void 0 : logLevels.value) && logLevels.value.includes("*") || (logLevels == null ? void 0 : logLevels.value.includes(args.level));
  if (!shouldLog) {
    return void 0;
  }
  executeSync({
    lix: args.lix,
    query: args.lix.db.insertInto("log").values({
      key: args.key,
      message: args.message,
      level: args.level
    })
  });
}

// ../lix-sdk/src/file/unknown-file-fallback-plugin.ts
var LixUnknownFileSchema = {
  type: "object",
  properties: {
    value: {
      type: "string",
      contentEncoding: "base64",
      description: "Base64-encoded binary file data"
    }
  },
  "x-lix-key": "lix_unknown_file",
  "x-lix-version": "1.0"
};
function base64ToBytes(base64) {
  const binString = atob(base64);
  return Uint8Array.from(binString, (m) => m.codePointAt(0));
}
function bytesToBase64(bytes) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}
var lixUnknownFileFallbackPlugin = {
  key: "lix_unknown_file_fallback_plugin",
  detectChangesGlob: "*",
  // Matches all files
  detectChanges: ({ before, after }) => {
    const detectedChanges = [];
    const beforeData = before == null ? void 0 : before.data;
    const afterData = after.data;
    const beforeBase64 = beforeData ? bytesToBase64(beforeData) : "";
    const afterBase64 = afterData ? bytesToBase64(afterData) : "";
    if (beforeBase64 !== afterBase64) {
      detectedChanges.push({
        schema: LixUnknownFileSchema,
        entity_id: after.id,
        snapshot_content: { value: afterBase64 }
        // Store as Unicode-safe base64 string
      });
    }
    return detectedChanges;
  },
  applyChanges: ({ file, changes }) => {
    var _a;
    if (changes.length > 1) {
      throw new Error(
        `[lix_unknown_file_fallback_plugin] Expected exactly one change for file ${file.id}, but received ${changes.length} changes`
      );
    }
    if (changes.length === 0) {
      throw new Error(
        `[lix_unknown_file_fallback_plugin] Expected exactly one change for file ${file.id}, but received no changes`
      );
    }
    const fileChange = changes[0];
    if (fileChange.entity_id !== file.id) {
      throw new Error(
        `[lix_unknown_file_fallback_plugin] Expected change for file ${file.id}, but received change for entity ${fileChange.entity_id}`
      );
    }
    if (typeof ((_a = fileChange.snapshot_content) == null ? void 0 : _a.value) === "string") {
      return {
        fileData: base64ToBytes(fileChange.snapshot_content.value)
      };
    }
    throw new Error(
      `[lix_unknown_file_fallback_plugin] Expected base64 string content for file ${file.id}, but received ${typeof fileChange.snapshot_content}`
    );
  }
};

// ../lix-sdk/src/file/store-detected-change-schema.ts
function storeDetectedChangeSchema(args) {
  const schemaKey = args.schema["x-lix-key"];
  const schemaVersion = args.schema["x-lix-version"];
  const existingSchema = executeSync({
    lix: args.lix,
    query: args.lix.db.selectFrom("stored_schema").where("key", "=", schemaKey).where("version", "=", schemaVersion).select(["key", "version", "value"]).limit(1)
  })[0];
  if (existingSchema) {
    const existingSchemaJson = typeof existingSchema.value === "string" ? existingSchema.value : JSON.stringify(existingSchema.value);
    const newSchemaJson = JSON.stringify(args.schema);
    if (existingSchemaJson !== newSchemaJson) {
      throw new Error(
        `Schema differs from stored version for key '${schemaKey}' version '${schemaVersion}'. Please bump the schema version (x-lix-version) to use a different schema.`
      );
    }
  } else {
    executeSync({
      lix: args.lix,
      query: args.lix.db.insertInto("stored_schema").values({
        key: schemaKey,
        version: schemaVersion,
        value: args.schema,
        lixcol_untracked: args.untracked || false
      })
    });
  }
}

// ../lix-sdk/src/file/file-handlers.ts
function globSync(args) {
  var _a;
  const columnNames = [];
  const result = args.lix.sqlite.exec({
    sql: `SELECT CASE WHEN ? GLOB ? THEN 1 ELSE 0 END AS matches`,
    bind: [args.path, args.glob],
    returnValue: "resultRows",
    columnNames
  });
  return ((_a = result[0]) == null ? void 0 : _a[0]) === 1;
}
function handleFileInsert(args) {
  executeSync({
    lix: args.lix,
    query: args.lix.db.insertInto("state_all").values({
      entity_id: args.file.id,
      schema_key: LixFileDescriptorSchema["x-lix-key"],
      file_id: args.file.id,
      plugin_key: "lix_own_entity",
      snapshot_content: {
        id: args.file.id,
        path: args.file.path,
        metadata: args.file.metadata || null
      },
      schema_version: LixFileDescriptorSchema["x-lix-version"],
      version_id: args.versionId,
      untracked: args.untracked || false
    })
  });
  const plugins = args.lix.plugin.getAllSync();
  let foundPlugin = false;
  let hasChanges = false;
  for (const plugin of plugins) {
    if (!plugin.detectChangesGlob || !globSync({
      lix: args.lix,
      path: args.file.path,
      glob: plugin.detectChangesGlob
    })) {
      continue;
    }
    foundPlugin = true;
    if (plugin.detectChanges === void 0) {
      createLixOwnLogSync({
        lix: args.lix,
        key: "lix_file_no_plugin",
        level: "warn",
        message: `File inserted at ${args.file.path} but plugin does not support detecting changes`
      });
      continue;
    }
    const detectedChanges = plugin.detectChanges({
      after: args.file
    });
    if (detectedChanges.length > 0) {
      hasChanges = true;
      for (const change of detectedChanges) {
        storeDetectedChangeSchema({
          lix: args.lix,
          schema: change.schema,
          untracked: args.untracked || false
        });
      }
      for (const change of detectedChanges) {
        executeSync({
          lix: args.lix,
          query: args.lix.db.insertInto("state_all").values({
            entity_id: change.entity_id,
            schema_key: change.schema["x-lix-key"],
            file_id: args.file.id,
            plugin_key: plugin.key,
            snapshot_content: change.snapshot_content,
            schema_version: change.schema["x-lix-version"],
            version_id: args.versionId,
            untracked: args.untracked || false
          })
        });
      }
    }
  }
  if (!foundPlugin) {
    createLixOwnLogSync({
      lix: args.lix,
      key: "lix_file_no_plugin",
      level: "warn",
      message: `File inserted at ${args.file.path} but no plugin available to detect changes`
    });
    if (lixUnknownFileFallbackPlugin.detectChanges) {
      const detectedChanges = lixUnknownFileFallbackPlugin.detectChanges({
        after: args.file
      });
      if (detectedChanges.length > 0) {
        for (const change of detectedChanges) {
          storeDetectedChangeSchema({
            lix: args.lix,
            schema: change.schema
          });
        }
        for (const change of detectedChanges) {
          executeSync({
            lix: args.lix,
            query: args.lix.db.insertInto("state_all").values({
              entity_id: change.entity_id,
              schema_key: change.schema["x-lix-key"],
              file_id: args.file.id,
              plugin_key: lixUnknownFileFallbackPlugin.key,
              snapshot_content: change.snapshot_content,
              schema_version: change.schema["x-lix-version"],
              version_id: args.versionId,
              untracked: args.untracked || false
            })
          });
        }
      }
    }
  } else {
    if (!hasChanges) {
      createLixOwnLogSync({
        lix: args.lix,
        key: "lix_file_no_changes_detected",
        level: "debug",
        message: `File inserted at ${args.file.path} but plugin detected no changes`
      });
    }
  }
  args.lix.hooks._emit("file_change", {
    fileId: args.file.id,
    operation: "inserted"
  });
  return 0;
}
function handleFileUpdate(args) {
  executeSync({
    lix: args.lix,
    query: args.lix.db.updateTable("state_all").set({
      snapshot_content: {
        id: args.file.id,
        path: args.file.path,
        metadata: args.file.metadata || null
      },
      untracked: args.untracked || false
    }).where("entity_id", "=", args.file.id).where("schema_key", "=", "lix_file_descriptor").where("version_id", "=", args.versionId)
  });
  const currentFile = executeSync({
    lix: args.lix,
    query: args.lix.db.selectFrom("file_all").where("id", "=", args.file.id).where("lixcol_version_id", "=", args.versionId).selectAll()
  })[0];
  if (currentFile) {
    const plugins = args.lix.plugin.getAllSync();
    let foundPlugin = false;
    let hasChanges = false;
    for (const plugin of plugins) {
      if (!plugin.detectChangesGlob || !globSync({
        lix: args.lix,
        path: args.file.path,
        glob: plugin.detectChangesGlob
      })) {
        continue;
      }
      foundPlugin = true;
      if (plugin.detectChanges === void 0) {
        createLixOwnLogSync({
          lix: args.lix,
          key: "lix_file_no_plugin",
          level: "warn",
          message: `File updated at ${args.file.path} but plugin does not support detecting changes`
        });
        continue;
      }
      const detectedChanges = plugin.detectChanges({
        before: currentFile,
        after: args.file
      });
      if (detectedChanges.length > 0) {
        hasChanges = true;
        for (const change of detectedChanges) {
          storeDetectedChangeSchema({
            lix: args.lix,
            schema: change.schema,
            untracked: args.untracked || false
          });
        }
        for (const change of detectedChanges) {
          if (change.snapshot_content === null) {
            executeSync({
              lix: args.lix,
              query: args.lix.db.deleteFrom("state_all").where("entity_id", "=", change.entity_id).where("schema_key", "=", change.schema["x-lix-key"]).where("file_id", "=", args.file.id).where("version_id", "=", args.versionId)
            });
          } else {
            executeSync({
              lix: args.lix,
              query: args.lix.db.insertInto("state_all").values({
                entity_id: change.entity_id,
                schema_key: change.schema["x-lix-key"],
                file_id: args.file.id,
                plugin_key: plugin.key,
                snapshot_content: change.snapshot_content,
                schema_version: change.schema["x-lix-version"],
                version_id: args.versionId,
                untracked: args.untracked || false
              })
            });
          }
        }
      }
    }
    if (!foundPlugin) {
      createLixOwnLogSync({
        lix: args.lix,
        key: "lix_file_no_plugin",
        level: "warn",
        message: `File updated at ${args.file.path} but no plugin available to detect changes`
      });
      if (lixUnknownFileFallbackPlugin.detectChanges) {
        const detectedChanges = lixUnknownFileFallbackPlugin.detectChanges({
          before: currentFile,
          after: args.file
        });
        if (detectedChanges.length > 0) {
          for (const change of detectedChanges) {
            storeDetectedChangeSchema({
              lix: args.lix,
              schema: change.schema,
              untracked: args.untracked || false
            });
          }
          for (const change of detectedChanges) {
            if (change.snapshot_content === null) {
              executeSync({
                lix: args.lix,
                query: args.lix.db.deleteFrom("state_all").where("entity_id", "=", change.entity_id).where("schema_key", "=", change.schema["x-lix-key"]).where("file_id", "=", args.file.id).where("version_id", "=", args.versionId)
              });
            } else {
              executeSync({
                lix: args.lix,
                query: args.lix.db.insertInto("state_all").values({
                  entity_id: change.entity_id,
                  schema_key: change.schema["x-lix-key"],
                  file_id: args.file.id,
                  plugin_key: lixUnknownFileFallbackPlugin.key,
                  snapshot_content: change.snapshot_content,
                  schema_version: change.schema["x-lix-version"],
                  version_id: args.versionId,
                  untracked: args.untracked || false
                })
              });
            }
          }
        }
      }
    } else if (!hasChanges) {
      createLixOwnLogSync({
        lix: args.lix,
        key: "lix_file_no_changes_detected",
        level: "debug",
        message: `File updated at ${args.file.path} but plugin detected no changes`
      });
    }
  }
  args.lix.hooks._emit("file_change", {
    fileId: args.file.id,
    operation: "updated"
  });
  return 0;
}

// ../lix-sdk/src/file/materialize-file-data.ts
function globSync2(args) {
  var _a;
  const columnNames = [];
  const result = args.lix.sqlite.exec({
    sql: `SELECT CASE WHEN ? GLOB ? THEN 1 ELSE 0 END AS matches`,
    bind: [args.path, args.glob],
    returnValue: "resultRows",
    columnNames
  });
  return ((_a = result[0]) == null ? void 0 : _a[0]) === 1;
}
function materializeFileData(args) {
  const plugins = args.lix.plugin.getAllSync();
  for (const plugin of plugins) {
    if (!plugin.detectChangesGlob || !globSync2({
      lix: args.lix,
      path: args.file.path,
      glob: plugin.detectChangesGlob
    })) {
      continue;
    }
    if (!plugin.applyChanges) {
      continue;
    }
    const changes2 = executeSync({
      lix: args.lix,
      query: args.lix.db.selectFrom("state_all").where("plugin_key", "=", plugin.key).where("file_id", "=", args.file.id).where("version_id", "=", args.versionId).select([
        "entity_id",
        "schema_key",
        "file_id",
        "plugin_key",
        "snapshot_content",
        "version_id"
      ])
    });
    const formattedChanges2 = changes2.map((change) => ({
      ...change,
      snapshot_content: typeof change.snapshot_content === "string" ? JSON.parse(change.snapshot_content) : change.snapshot_content
    }));
    const file2 = plugin.applyChanges({
      file: args.file,
      changes: formattedChanges2
    });
    return file2.fileData;
  }
  const changes = executeSync({
    lix: args.lix,
    query: args.lix.db.selectFrom("state_all").where("plugin_key", "=", lixUnknownFileFallbackPlugin.key).where("file_id", "=", args.file.id).where("version_id", "=", args.versionId).select([
      "entity_id",
      "schema_key",
      "file_id",
      "plugin_key",
      "snapshot_content",
      "version_id"
    ])
  });
  const formattedChanges = changes.map((change) => ({
    ...change,
    snapshot_content: typeof change.snapshot_content === "string" ? JSON.parse(change.snapshot_content) : change.snapshot_content
  }));
  if (formattedChanges.length === 0) {
    throw new Error(
      `[materializeFileData] No changes found for file ${args.file.id} with plugin ${lixUnknownFileFallbackPlugin.key}. Cannot materialize file data.`
    );
  }
  const file = lixUnknownFileFallbackPlugin.applyChanges({
    file: args.file,
    changes: formattedChanges
  });
  return file.fileData;
}

// ../lix-sdk/src/file/materialize-file-data-at-changeset.ts
function globSync3(args) {
  var _a;
  const columnNames = [];
  const result = args.lix.sqlite.exec({
    sql: `SELECT CASE WHEN ? GLOB ? THEN 1 ELSE 0 END AS matches`,
    bind: [args.path, args.glob],
    returnValue: "resultRows",
    columnNames
  });
  return ((_a = result[0]) == null ? void 0 : _a[0]) === 1;
}
function materializeFileDataAtChangeset(args) {
  const plugins = args.lix.plugin.getAllSync();
  for (const plugin of plugins) {
    if (!plugin.detectChangesGlob || !globSync3({
      lix: args.lix,
      path: args.file.path,
      glob: plugin.detectChangesGlob
    })) {
      continue;
    }
    if (!plugin.applyChanges) {
      continue;
    }
    const changes2 = executeSync({
      lix: args.lix,
      query: selectFileChanges({
        lix: args.lix,
        pluginKey: plugin.key,
        fileId: args.file.id,
        rootChangeSetId: args.rootChangeSetId,
        depth: args.depth
      })
    });
    const formattedChanges2 = changes2.map((change) => ({
      ...change,
      snapshot_content: typeof change.snapshot_content === "string" ? JSON.parse(change.snapshot_content) : change.snapshot_content
    }));
    const file2 = plugin.applyChanges({
      file: args.file,
      changes: formattedChanges2
    });
    return file2.fileData;
  }
  const changes = executeSync({
    lix: args.lix,
    query: selectFileChanges({
      lix: args.lix,
      pluginKey: lixUnknownFileFallbackPlugin.key,
      fileId: args.file.id,
      rootChangeSetId: args.rootChangeSetId,
      depth: args.depth
    })
  });
  const formattedChanges = changes.map((change) => ({
    ...change,
    snapshot_content: typeof change.snapshot_content === "string" ? JSON.parse(change.snapshot_content) : change.snapshot_content
  }));
  if (formattedChanges.length === 0) {
    throw new Error(
      `[materializeFileDataAtChangeset] No changes found for file ${args.file.id} with plugin ${lixUnknownFileFallbackPlugin.key} at root changeset ${args.rootChangeSetId} depth ${args.depth}. Cannot materialize file data.`
    );
  }
  const file = lixUnknownFileFallbackPlugin.applyChanges({
    file: args.file,
    changes: formattedChanges
  });
  return file.fileData;
}
function selectFileChanges(args) {
  return args.lix.db.selectFrom("state_history as sh1").where("sh1.plugin_key", "=", args.pluginKey).where("sh1.file_id", "=", args.fileId).where("sh1.root_change_set_id", "=", args.rootChangeSetId).where("sh1.depth", ">=", args.depth).where(
    "sh1.depth",
    "=",
    (eb) => (
      // This subquery finds the "leaf state" for each entity at the requested depth in history.
      //
      // What this does: "For each entity in the file, find its most recent state that existed
      // at or before the requested depth. Some entities might have changed at depth 0, others
      // might be unchanged since depth 5 - we need all of them to reconstruct the complete file."
      //
      // Example: Requesting depth=1 for a JSON file
      // - "name" entity: last changed at depth=3 (unchanged for 3 changesets)
      // - "value" entity: last changed at depth=1 (changed 1 changeset ago)
      // - "description" entity: last changed at depth=0 (just changed)
      //
      // Result: We get "name" from depth=3 and "value" from depth=1 (ignoring "description" at depth=0)
      //
      // args.depth: The depth we want to reconstruct the file at (0=current, higher=further back in history)
      // >= args.depth: Go backwards in history to find all entities that existed at or before this point
      // min(depth): For each entity, get its most recent state (leaf) at or after the requested depth
      eb.selectFrom("state_history as sh2").select((eb2) => eb2.fn.min("sh2.depth").as("min_depth")).whereRef("sh2.entity_id", "=", "sh1.entity_id").whereRef("sh2.file_id", "=", "sh1.file_id").whereRef("sh2.plugin_key", "=", "sh1.plugin_key").whereRef("sh2.root_change_set_id", "=", "sh1.root_change_set_id").where("sh2.depth", ">=", args.depth)
    )
  ).select([
    "sh1.entity_id",
    "sh1.schema_key",
    "sh1.file_id",
    "sh1.plugin_key",
    "sh1.snapshot_content"
  ]);
}

// ../lix-sdk/src/file/schema.ts
function applyFileDatabaseSchema(lix) {
  lix.sqlite.createFunction({
    name: "handle_file_insert",
    arity: 6,
    xFunc: (_ctx, ...args) => {
      let metadata = args[3];
      if (typeof metadata === "string" && metadata !== null) {
        try {
          metadata = JSON.parse(metadata);
        } catch (e) {
        }
      }
      const result = handleFileInsert({
        lix,
        file: {
          id: args[0],
          path: args[1],
          data: args[2],
          metadata
        },
        versionId: args[4],
        untracked: Boolean(args[5])
      });
      return result;
    },
    deterministic: true
  });
  lix.sqlite.createFunction({
    name: "handle_file_update",
    arity: 6,
    xFunc: (_ctx, ...args) => {
      let metadata = args[3];
      if (typeof metadata === "string" && metadata !== null) {
        try {
          metadata = JSON.parse(metadata);
        } catch (e) {
        }
      }
      const result = handleFileUpdate({
        lix,
        file: {
          id: args[0],
          path: args[1],
          data: args[2],
          metadata
        },
        versionId: args[4],
        untracked: Boolean(args[5])
      });
      return result;
    },
    deterministic: true
  });
  lix.sqlite.createFunction({
    name: "materialize_file_data",
    arity: 4,
    deterministic: false,
    xFunc: (_ctx, ...args) => {
      return materializeFileData({
        lix,
        file: {
          id: args[0],
          path: args[1],
          metadata: args[3]
        },
        versionId: args[2]
      });
    }
  });
  lix.sqlite.createFunction({
    name: "materialize_file_data_at_changeset",
    arity: 5,
    deterministic: false,
    xFunc: (_ctx, ...args) => {
      return materializeFileDataAtChangeset({
        lix,
        file: {
          id: args[0],
          path: args[1],
          metadata: args[4]
        },
        rootChangeSetId: args[2],
        depth: args[3]
      });
    }
  });
  lix.sqlite.exec(`
  CREATE VIEW IF NOT EXISTS file AS
	SELECT
		json_extract(snapshot_content, '$.id') AS id,
		json_extract(snapshot_content, '$.path') AS path,
		materialize_file_data(
			json_extract(snapshot_content, '$.id'), 
			json_extract(snapshot_content, '$.path'), 
			(SELECT version_id FROM active_version),
			json_extract(snapshot_content, '$.metadata')
		) AS data,
		json_extract(snapshot_content, '$.metadata') AS metadata,
		inherited_from_version_id AS lixcol_inherited_from_version_id,
		created_at AS lixcol_created_at,
		updated_at AS lixcol_updated_at,
		change_id AS lixcol_change_id,
		untracked AS lixcol_untracked
	FROM state
	WHERE schema_key = 'lix_file_descriptor';

  CREATE VIEW IF NOT EXISTS file_all AS
	SELECT
		json_extract(snapshot_content, '$.id') AS id,
		json_extract(snapshot_content, '$.path') AS path,
		materialize_file_data(
			json_extract(snapshot_content, '$.id'), 
			json_extract(snapshot_content, '$.path'), 
			version_id,
			json_extract(snapshot_content, '$.metadata')
		) AS data,
		json_extract(snapshot_content, '$.metadata') AS metadata,
		version_id AS lixcol_version_id,
		inherited_from_version_id AS lixcol_inherited_from_version_id,
		created_at AS lixcol_created_at,
		updated_at AS lixcol_updated_at,
		change_id AS lixcol_change_id,
		untracked AS lixcol_untracked
	FROM state_all
	WHERE schema_key = 'lix_file_descriptor';


  CREATE TRIGGER IF NOT EXISTS file_insert
  INSTEAD OF INSERT ON file
  BEGIN
      SELECT handle_file_insert(
        COALESCE(NEW.id, nano_id()),
        NEW.path,
        NEW.data,
        NEW.metadata,
        (SELECT version_id FROM active_version),
        COALESCE(NEW.lixcol_untracked, 0)
      );
  END;

  CREATE TRIGGER IF NOT EXISTS file_update
  INSTEAD OF UPDATE ON file
  BEGIN
      SELECT handle_file_update(
        NEW.id,
        NEW.path,
        NEW.data,
        NEW.metadata,
        (SELECT version_id FROM active_version),
        COALESCE(NEW.lixcol_untracked, 0)
      );
  END;

  CREATE TRIGGER IF NOT EXISTS file_delete
  INSTEAD OF DELETE ON file
  BEGIN
      -- Delete all non-lix_file entities associated with this file first
      DELETE FROM state_all
      WHERE file_id = OLD.id
        AND version_id = (SELECT version_id FROM active_version)
        AND schema_key != 'lix_file_descriptor';
        
      -- Delete the file entity itself
      DELETE FROM state_all
      WHERE entity_id = OLD.id
        AND schema_key = 'lix_file_descriptor'
        AND version_id = (SELECT version_id FROM active_version);
  END;

  CREATE TRIGGER IF NOT EXISTS file_all_insert
  INSTEAD OF INSERT ON file_all
  BEGIN
      SELECT handle_file_insert(
        COALESCE(NEW.id, nano_id()),
        NEW.path,
        NEW.data,
        NEW.metadata,
        COALESCE(NEW.lixcol_version_id, (SELECT version_id FROM active_version)),
        COALESCE(NEW.lixcol_untracked, 0)
      );
  END;

  CREATE TRIGGER IF NOT EXISTS file_all_update
  INSTEAD OF UPDATE ON file_all
  BEGIN
      SELECT handle_file_update(
        NEW.id,
        NEW.path,
        NEW.data,
        NEW.metadata,
        COALESCE(NEW.lixcol_version_id, OLD.lixcol_version_id),
        COALESCE(NEW.lixcol_untracked, 0)
      );
  END;

  CREATE TRIGGER IF NOT EXISTS file_all_delete
  INSTEAD OF DELETE ON file_all
  BEGIN
      -- Delete all non-lix_file entities associated with this file first
      DELETE FROM state_all
      WHERE file_id = OLD.id
        AND version_id = OLD.lixcol_version_id
        AND schema_key != 'lix_file_descriptor';
        
      -- Delete the file entity itself
      DELETE FROM state_all
      WHERE entity_id = OLD.id
        AND schema_key = 'lix_file_descriptor'
        AND version_id = OLD.lixcol_version_id;
  END;

  CREATE VIEW IF NOT EXISTS file_history AS
  SELECT
    json_extract(snapshot_content, '$.id') AS id,
    json_extract(snapshot_content, '$.path') AS path,
    materialize_file_data_at_changeset(
      json_extract(snapshot_content, '$.id'),
      json_extract(snapshot_content, '$.path'),
      root_change_set_id,
      depth,
      json_extract(snapshot_content, '$.metadata')
    ) AS data,
    json_extract(snapshot_content, '$.metadata') AS metadata,
    file_id AS lixcol_file_id,
    plugin_key AS lixcol_plugin_key,
    schema_version AS lixcol_schema_version,
    change_id AS lixcol_change_id,
    change_set_id AS lixcol_change_set_id,
    root_change_set_id AS lixcol_root_change_set_id,
    depth AS lixcol_depth
  FROM state_history
  WHERE schema_key = 'lix_file_descriptor';
`);
}
var LixFileDescriptorSchema = {
  "x-lix-key": "lix_file_descriptor",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["id"],
  "x-lix-unique": [["path"]],
  type: "object",
  properties: {
    id: { type: "string", "x-lix-generated": true },
    path: {
      type: "string",
      pattern: "^/(?!.*//|.*\\\\)(?!.*/$|^/$).+",
      description: "File path must start with a slash, not contain backslashes or consecutive slashes, and not end with a slash"
    },
    metadata: {
      type: "object",
      nullable: true
    }
  },
  required: ["id", "path"],
  additionalProperties: false
};

// ../lix-sdk/src/log/schema.ts
function applyLogDatabaseSchema(sqlite) {
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixLogSchema,
    overrideName: "log",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix",
    defaultValues: { id: () => nanoid() }
  });
  return sqlite;
}
var LixLogSchema = {
  "x-lix-key": "lix_log",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["id"],
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "The unique identifier of the log entry",
      "x-lix-generated": true
    },
    key: {
      type: "string",
      description: "The key of the log entry"
    },
    message: {
      type: "string",
      description: "The message of the log entry"
    },
    level: {
      type: "string",
      description: "The level of the log entry"
    }
  },
  required: ["id", "key", "message", "level"],
  additionalProperties: false
};

// ../lix-sdk/src/label/schema.ts
function applyLabelDatabaseSchema(sqlite) {
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixLabelSchema,
    overrideName: "label",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix",
    defaultValues: { id: () => nanoid() }
  });
  return sqlite;
}
var LixLabelSchema = {
  "x-lix-key": "lix_label",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["id"],
  type: "object",
  properties: {
    id: { type: "string", "x-lix-generated": true },
    name: { type: "string" }
  },
  required: ["id", "name"],
  additionalProperties: false
};

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var value_exports = {};
__export(value_exports, {
  HasPropertyKey: () => HasPropertyKey,
  IsArray: () => IsArray,
  IsAsyncIterator: () => IsAsyncIterator,
  IsBigInt: () => IsBigInt,
  IsBoolean: () => IsBoolean,
  IsDate: () => IsDate,
  IsFunction: () => IsFunction,
  IsIterator: () => IsIterator,
  IsNull: () => IsNull,
  IsNumber: () => IsNumber,
  IsObject: () => IsObject,
  IsRegExp: () => IsRegExp,
  IsString: () => IsString,
  IsSymbol: () => IsSymbol,
  IsUint8Array: () => IsUint8Array,
  IsUndefined: () => IsUndefined
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === void 0;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return Clone(schema) ;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === void 0;
}
function IsNumber2(value) {
  return typeof value === "number";
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject2 = IsObject2(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject2 : isObject2 && !IsArray2(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined2 = IsUndefined2(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined2 || value === null : isUndefined2;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== void 0 ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
var TypeBoxError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArgument(value) {
  return IsKindOf(value, "Argument");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator2(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt2(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean2(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate2(value) {
  return IsKindOf(value, "Date");
}
function IsFunction2(value) {
  return IsKindOf(value, "Function");
}
function IsInteger(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator2(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull2(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString2(value) {
  return IsKindOf(value, "String");
}
function IsSymbol2(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array2(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArgument(value) || IsArray3(value) || IsBoolean2(value) || IsBigInt2(value) || IsAsyncIterator2(value) || IsComputed(value) || IsConstructor(value) || IsDate2(value) || IsFunction2(value) || IsInteger(value) || IsIntersect(value) || IsIterator2(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull2(value) || IsNumber3(value) || IsObject3(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString2(value) || IsSymbol2(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array2(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var type_exports = {};
__export(type_exports, {
  IsAny: () => IsAny2,
  IsArgument: () => IsArgument2,
  IsArray: () => IsArray4,
  IsAsyncIterator: () => IsAsyncIterator3,
  IsBigInt: () => IsBigInt3,
  IsBoolean: () => IsBoolean3,
  IsComputed: () => IsComputed2,
  IsConstructor: () => IsConstructor2,
  IsDate: () => IsDate3,
  IsFunction: () => IsFunction3,
  IsImport: () => IsImport,
  IsInteger: () => IsInteger2,
  IsIntersect: () => IsIntersect2,
  IsIterator: () => IsIterator3,
  IsKind: () => IsKind2,
  IsKindOf: () => IsKindOf2,
  IsLiteral: () => IsLiteral2,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralString: () => IsLiteralString,
  IsLiteralValue: () => IsLiteralValue2,
  IsMappedKey: () => IsMappedKey2,
  IsMappedResult: () => IsMappedResult2,
  IsNever: () => IsNever2,
  IsNot: () => IsNot2,
  IsNull: () => IsNull3,
  IsNumber: () => IsNumber4,
  IsObject: () => IsObject4,
  IsOptional: () => IsOptional2,
  IsPromise: () => IsPromise2,
  IsProperties: () => IsProperties,
  IsReadonly: () => IsReadonly2,
  IsRecord: () => IsRecord2,
  IsRecursive: () => IsRecursive,
  IsRef: () => IsRef2,
  IsRegExp: () => IsRegExp3,
  IsSchema: () => IsSchema2,
  IsString: () => IsString3,
  IsSymbol: () => IsSymbol3,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsThis: () => IsThis2,
  IsTransform: () => IsTransform2,
  IsTuple: () => IsTuple2,
  IsUint8Array: () => IsUint8Array3,
  IsUndefined: () => IsUndefined4,
  IsUnion: () => IsUnion2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnknown: () => IsUnknown2,
  IsUnsafe: () => IsUnsafe2,
  IsVoid: () => IsVoid2,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError
});
var TypeGuardUnknownTypeError = class extends TypeBoxError {
};
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch (e) {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0; i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
  return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator3(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt3(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean3(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate3(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction3(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger2(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator3(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull3(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise2(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString3(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol3(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && // empty
  (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array3(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArgument2(value) || IsArray4(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed2(value) || IsConstructor2(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect2(value) || IsIterator3(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull3(value) || IsNumber4(value) || IsObject4(value) || IsPromise2(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array3(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
var TemplateLiteralParserError = class extends TypeBoxError {
};
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index; scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index; scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0; index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
var TemplateLiteralFiniteError = class extends TypeBoxError {
};
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
var TemplateLiteralGenerateError = class extends TypeBoxError {
};
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim4 = syntax.trim().replace(/"|'/g, "");
  return trim4 === "boolean" ? yield Boolean2() : trim4 === "number" ? yield Number2() : trim4 === "bigint" ? yield BigInt2() : trim4 === "string" ? yield String2() : yield (() => {
    const literals = trim4.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2; i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0; i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
var TemplateLiteralPatternError = class extends TypeBoxError {
};
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger(schema) ? `${acc}${PatternNumber}` : IsBigInt2(schema) ? `${acc}${PatternNumber}` : IsString2(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean2(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger(type) ? ["[number]"] : [])];
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  var _a;
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple((_a = type.items) != null ? _a : [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable != null ? enable : true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  var _a;
  const options = { ...T };
  return (
    // unevaluated modifier types
    IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : (
      // unevaluated mapped types
      IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : (
        // unevaluated types
        IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction2(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator2(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator2(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, (_a = T.items) != null ? _a : []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise(T) ? Promise2(FromSchemaType(K, T.item), options) : T
      )
    )
  );
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable != null ? enable : true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  return [];
}
function KeyOfPropertyKeys(type) {
  var _a;
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2((_a = type.items) != null ? _a : []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
var ExtendsResolverError = class extends TypeBoxError {
};
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight() : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight() : type_exports.IsAny(right) ? FromAnyRight() : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema) => type_exports.IsAny(schema) || type_exports.IsUnknown(schema)) ? ExtendsResult.True : type_exports.IsUnion(right) ? ExtendsResult.Union : type_exports.IsUnknown(right) ? ExtendsResult.True : type_exports.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult.True : type_exports.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !type_exports.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? FromStringRight(left) : type_exports.IsNumber(right) ? FromNumberRight(left) : type_exports.IsInteger(right) ? FromIntegerRight(left) : type_exports.IsBoolean(right) ? FromBooleanRight(left) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return type_exports.IsNot(left) ? Visit3(UnwrapTNot(left), right) : type_exports.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && type_exports.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports.IsString(schema.properties.description.anyOf[0]) && type_exports.IsUndefined(schema.properties.description.anyOf[1]) || type_exports.IsString(schema.properties.description.anyOf[1]) && type_exports.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike(right) || type_exports.IsString(left) && IsObjectStringLike(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike(right) || type_exports.IsNumber(left) && IsObjectNumberLike(right) || type_exports.IsInteger(left) && IsObjectNumberLike(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || type_exports.IsDate(left) && IsObjectDateLike(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike(right) || type_exports.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : !type_exports.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !type_exports.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : PatternStringExact in schema.patternProperties ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key2, Value] = [RecordKey(right), RecordValue(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key2) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key2) ? Visit3(left, Value) : type_exports.IsString(left) && type_exports.IsNumber(Key2) ? Visit3(left, Value) : type_exports.IsArray(left) && type_exports.IsNumber(Key2) ? Visit3(left, Value) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : !type_exports.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = type_exports.IsRegExp(left) ? String2() : left;
  const R = type_exports.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult.True : type_exports.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : type_exports.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return type_exports.IsArray(right) && left.items !== void 0 && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult.True : type_exports.IsUnknown(left) ? ExtendsResult.False : type_exports.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : type_exports.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !type_exports.IsTuple(right) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsRecord(right) ? FromRecordRight(left, right) : type_exports.IsVoid(right) ? FromVoidRight(left) : type_exports.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight() : type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsAny(right) ? FromAnyRight() : type_exports.IsString(right) ? FromStringRight(left) : type_exports.IsNumber(right) ? FromNumberRight(left) : type_exports.IsInteger(right) ? FromIntegerRight(left) : type_exports.IsBoolean(right) ? FromBooleanRight(left) : type_exports.IsArray(right) ? FromArrayRight(left) : type_exports.IsTuple(right) ? FromTupleRight(left) : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult.True : type_exports.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight(left, right) : type_exports.IsUnion(right) ? FromUnionRight(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight() : type_exports.IsAny(right) ? FromAnyRight() : type_exports.IsObject(right) ? FromObjectRight(left, right) : type_exports.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return (
    // resolvable
    type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot(left, right) : (
      // standard
      type_exports.IsAny(left) ? FromAny(left, right) : type_exports.IsArray(left) ? FromArray4(left, right) : type_exports.IsBigInt(left) ? FromBigInt(left, right) : type_exports.IsBoolean(left) ? FromBoolean(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : type_exports.IsConstructor(left) ? FromConstructor(left, right) : type_exports.IsDate(left) ? FromDate(left, right) : type_exports.IsFunction(left) ? FromFunction(left, right) : type_exports.IsInteger(left) ? FromInteger(left, right) : type_exports.IsIntersect(left) ? FromIntersect4(left, right) : type_exports.IsIterator(left) ? FromIterator(left, right) : type_exports.IsLiteral(left) ? FromLiteral2(left, right) : type_exports.IsNever(left) ? FromNever() : type_exports.IsNull(left) ? FromNull(left, right) : type_exports.IsNumber(left) ? FromNumber(left, right) : type_exports.IsObject(left) ? FromObject(left, right) : type_exports.IsRecord(left) ? FromRecord(left, right) : type_exports.IsString(left) ? FromString(left, right) : type_exports.IsSymbol(left) ? FromSymbol(left, right) : type_exports.IsTuple(left) ? FromTuple3(left, right) : type_exports.IsPromise(left) ? FromPromise2(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array(left, right) : type_exports.IsUndefined(left) ? FromUndefined(left, right) : type_exports.IsUnion(left) ? FromUnion6(left, right) : type_exports.IsUnknown(left) ? FromUnknown(left, right) : type_exports.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`)
    )
  );
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
  return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsBoolean2(key) ? FromBooleanKey(key, type, options) : IsInteger(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString2(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
  const pattern = RecordPattern(type);
  return pattern === PatternStringExact ? String2() : pattern === PatternNumberExact ? Number2() : String2({ pattern });
}
function RecordValue2(type) {
  return type.patternProperties[RecordPattern(type)];
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromFunction2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromIntersect5(args, type) {
  type.allOf = FromTypes(args, type.allOf);
  return type;
}
function FromUnion7(args, type) {
  type.anyOf = FromTypes(args, type.anyOf);
  return type;
}
function FromTuple4(args, type) {
  if (IsUndefined(type.items))
    return type;
  type.items = FromTypes(args, type.items);
  return type;
}
function FromArray5(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromAsyncIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromPromise3(args, type) {
  type.item = FromType(args, type.item);
  return type;
}
function FromObject2(args, type) {
  const mappedProperties = FromProperties11(args, type.properties);
  return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
  const mappedKey = FromType(args, RecordKey2(type));
  const mappedValue = FromType(args, RecordValue2(type));
  const result = Record(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
  const isReadonly = IsReadonly(type);
  const isOptional = IsOptional(type);
  const mapped = FromType(args, type);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
}
function FromTypes(args, types) {
  return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
  return IsConstructor(type) ? FromConstructor2(args, type) : IsFunction2(type) ? FromFunction2(args, type) : IsIntersect(type) ? FromIntersect5(args, type) : IsUnion(type) ? FromUnion7(args, type) : IsTuple(type) ? FromTuple4(args, type) : IsArray3(type) ? FromArray5(args, type) : IsAsyncIterator2(type) ? FromAsyncIterator2(args, type) : IsIterator2(type) ? FromIterator2(args, type) : IsPromise(type) ? FromPromise3(args, type) : IsObject3(type) ? FromObject2(args, type) : IsRecord(type) ? FromRecord2(args, type) : IsArgument(type) ? FromArgument(args, type) : type;
}
function Instantiate(type, args) {
  return FromType(args, CloneType(type));
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return (
    // Intrinsic-Mapped-Inference
    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : (
      // Standard-Inference
      IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : (
        // Default Type
        CreateType(schema, options)
      )
    )
  );
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return (
    // Mappable
    IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject5(type) : (
      // Intrinsic
      IsBigInt2(type) ? type : IsBoolean2(type) ? type : IsInteger(type) ? type : IsLiteral(type) ? type : IsNull2(type) ? type : IsNumber3(type) ? type : IsString2(type) ? type : IsSymbol2(type) ? type : IsUndefined3(type) ? type : (
        // Passthrough
        Object2({})
      )
    )
  );
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return (
    // Mappable
    IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject6(type) : (
      // Intrinsic
      IsBigInt2(type) ? type : IsBoolean2(type) ? type : IsInteger(type) ? type : IsLiteral(type) ? type : IsNull2(type) ? type : IsNumber3(type) ? type : IsString2(type) ? type : IsSymbol2(type) ? type : IsUndefined3(type) ? type : (
        // Passthrough
        Object2({})
      )
    )
  );
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type) {
  return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
  return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
  return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type) {
  const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
  const result = CloneType(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return (
    // Modifiers
    IsOptional(type) ? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type) : (
      // Transform
      IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : (
        // Types
        IsArray3(type) ? CreateType(FromArray6(moduleProperties, type.items), type) : IsAsyncIterator2(type) ? CreateType(FromAsyncIterator3(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor3(moduleProperties, type.parameters, type.returns), type) : IsFunction2(type) ? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect8(moduleProperties, type.allOf), type) : IsIterator2(type) ? CreateType(FromIterator3(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject7(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord3(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple5(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion10(moduleProperties, type.anyOf), type) : type
      )
    )
  );
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
var TModule = class {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  /** `[Json]` Imports a Type by Key. */
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  // prettier-ignore
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
};
function Module(properties) {
  return new TModule(properties);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction2(schema) ? Tuple(schema.parameters, options) : Never();
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  var _a;
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? (_a = T.items) != null ? _a : [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction2(schema) ? CreateType(schema.returns, options) : Never(options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
var TransformDecodeBuilder = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
};
var TransformEncodeBuilder = class {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
};
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  var _a;
  return CreateType({ [Kind]: (_a = options[Kind]) != null ? _a : "Unsafe" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var type_exports2 = {};
__export(type_exports2, {
  Any: () => Any,
  Argument: () => Argument,
  Array: () => Array2,
  AsyncIterator: () => AsyncIterator,
  Awaited: () => Awaited,
  BigInt: () => BigInt2,
  Boolean: () => Boolean2,
  Capitalize: () => Capitalize,
  Composite: () => Composite,
  Const: () => Const,
  Constructor: () => Constructor,
  ConstructorParameters: () => ConstructorParameters,
  Date: () => Date2,
  Enum: () => Enum,
  Exclude: () => Exclude,
  Extends: () => Extends,
  Extract: () => Extract,
  Function: () => Function2,
  Index: () => Index,
  InstanceType: () => InstanceType,
  Instantiate: () => Instantiate,
  Integer: () => Integer,
  Intersect: () => Intersect,
  Iterator: () => Iterator,
  KeyOf: () => KeyOf,
  Literal: () => Literal,
  Lowercase: () => Lowercase,
  Mapped: () => Mapped,
  Module: () => Module,
  Never: () => Never,
  Not: () => Not,
  Null: () => Null,
  Number: () => Number2,
  Object: () => Object2,
  Omit: () => Omit,
  Optional: () => Optional,
  Parameters: () => Parameters,
  Partial: () => Partial,
  Pick: () => Pick,
  Promise: () => Promise2,
  Readonly: () => Readonly,
  ReadonlyOptional: () => ReadonlyOptional,
  Record: () => Record,
  Recursive: () => Recursive,
  Ref: () => Ref,
  RegExp: () => RegExp2,
  Required: () => Required,
  Rest: () => Rest,
  ReturnType: () => ReturnType,
  String: () => String2,
  Symbol: () => Symbol2,
  TemplateLiteral: () => TemplateLiteral,
  Transform: () => Transform,
  Tuple: () => Tuple,
  Uint8Array: () => Uint8Array2,
  Uncapitalize: () => Uncapitalize,
  Undefined: () => Undefined,
  Union: () => Union,
  Unknown: () => Unknown,
  Unsafe: () => Unsafe,
  Uppercase: () => Uppercase,
  Void: () => Void
});

// ../../node_modules/.pnpm/@sinclair+typebox@0.34.37/node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = type_exports2;

// ../zettel/zettel-ast/dist/schema.js
var Key = Type.String({
  description: "Unique key for this node within the document",
  minLength: 6
});
Type.Intersect([
  Type.Object({
    type: Type.String(),
    zettel_key: Key
  }, {
    propertyNames: Type.String({
      pattern: "^(?!zettel_).*|^zettel_key$",
      description: "Property names must not start with 'zettel_' except 'zettel_key'"
    }),
    additionalProperties: true
  }),
  Type.Record(Type.String({ pattern: "^(?!zettel_).*|^zettel_key$" }), Type.Unknown())
]);
var Metadata = Type.Optional(Type.Record(Type.String(), Type.Unknown()));
var ZettelLinkMark = Type.Object({
  type: Type.Literal("zettel_link"),
  zettel_key: Key,
  href: Type.String({
    description: "The target URL of the link"
  }),
  metadata: Metadata
});
var ZettelBoldMark = Type.Object({
  type: Type.Literal("zettel_bold"),
  zettel_key: Key
});
var ZettelItalicMark = Type.Object({
  type: Type.Literal("zettel_italic"),
  zettel_key: Key
});
var CustomMark = Type.Object({
  type: Type.String({ pattern: "^(?!zettel_).*" }),
  zettel_key: Key
}, {
  additionalProperties: true,
  propertyNames: Type.String({ pattern: "^(?!zettel_).*|^zettel_key$" })
});
var ZettelSpan = Type.Object({
  type: Type.Literal("zettel_span"),
  zettel_key: Key,
  marks: Type.Optional(Type.Array(Type.Union([ZettelBoldMark, ZettelItalicMark, ZettelLinkMark, CustomMark]))),
  text: Type.String({ description: "The text content of this span" }),
  metadata: Metadata
});
var ZettelTextBlock = Type.Object({
  type: Type.Literal("zettel_text_block"),
  zettel_key: Key,
  style: Type.Union([
    Type.Literal("zettel_normal"),
    Type.String({
      description: "The key of a custom block. Renderers that don't support this block will render it as a zettel_normal block."
    })
  ]),
  children: Type.Array(ZettelSpan, {
    description: "Array of inline spans that make up the block content"
  }),
  metadata: Metadata
});
var CustomBlock = Type.Intersect([
  Type.Object({
    type: Type.String({ pattern: "^(?!zettel_text_block$).*" }),
    zettel_key: Key
  }, {
    propertyNames: Type.String({ pattern: "^(?!zettel_).*|^zettel_key$" }),
    additionalProperties: true
  }),
  Type.Record(Type.String({ pattern: "^(?!zettel_).*|^zettel_key$" }), Type.Unknown())
]);
var ZettelDoc = Type.Object({
  type: Type.Literal("zettel_doc"),
  content: Type.Array(Type.Union([ZettelTextBlock, CustomBlock]))
});
var ZettelDocJsonSchema = ZettelDoc;

// ../lix-sdk/src/thread/schema.ts
function applyThreadDatabaseSchema(sqlite) {
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixThreadSchema,
    overrideName: "thread",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix",
    defaultValues: {
      id: () => "nano_id()"
    }
  });
  createEntityViewsIfNotExists({
    lix: { sqlite },
    schema: LixThreadCommentSchema,
    overrideName: "thread_comment",
    pluginKey: "lix_own_entity",
    hardcodedFileId: "lix",
    defaultValues: {
      id: () => "nano_id()"
    }
  });
  return sqlite;
}
var LixThreadSchema = {
  "x-lix-key": "lix_thread",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["id"],
  type: "object",
  properties: {
    id: { type: "string", "x-lix-generated": true },
    metadata: { type: "object", nullable: true }
  },
  required: ["id"],
  additionalProperties: false
};
var LixThreadCommentSchema = {
  "x-lix-key": "lix_thread_comment",
  "x-lix-version": "1.0",
  "x-lix-primary-key": ["id"],
  "x-lix-foreign-keys": {
    thread_id: {
      schemaKey: "lix_thread",
      property: "id"
    },
    parent_id: {
      schemaKey: "lix_thread_comment",
      property: "id"
    }
  },
  type: "object",
  properties: {
    id: { type: "string", "x-lix-generated": true },
    thread_id: { type: "string" },
    parent_id: { type: "string", nullable: true },
    body: ZettelDocJsonSchema
  },
  required: ["id", "thread_id", "body"],
  additionalProperties: false
};

// ../lix-sdk/src/database/schema.ts
var LixSchemaViewMap = {
  version: LixVersionSchema,
  change_set: LixChangeSetSchema,
  change_set_element: LixChangeSetElementSchema,
  change_set_edge: LixChangeSetEdgeSchema,
  change_set_label: LixChangeSetLabelSchema,
  change_set_thread: LixChangeSetThreadSchema,
  file: LixFileDescriptorSchema,
  log: LixLogSchema,
  stored_schema: LixStoredSchemaSchema,
  key_value: LixKeyValueSchema,
  account: LixAccountSchema,
  change_author: LixChangeAuthorSchema,
  label: LixLabelSchema,
  thread: LixThreadSchema,
  thread_comment: LixThreadCommentSchema
};

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/util/json-object-args.js
function getJsonObjectArgs(node, table) {
  var _a;
  const args = [];
  for (const { selection: s } of (_a = node.selections) != null ? _a : []) {
    if (ReferenceNode.is(s) && ColumnNode.is(s.column)) {
      args.push(colName(s.column.column.name), colRef(table, s.column.column.name));
    } else if (ColumnNode.is(s)) {
      args.push(colName(s.column.name), colRef(table, s.column.name));
    } else if (AliasNode.is(s) && IdentifierNode.is(s.alias)) {
      args.push(colName(s.alias.name), colRef(table, s.alias.name));
    } else {
      throw new Error(`can't extract column names from the select query node`);
    }
  }
  return args;
}
function colName(col) {
  return new ExpressionWrapper(ValueNode.createImmediate(col));
}
function colRef(table, col) {
  return new ExpressionWrapper(ReferenceNode.create(ColumnNode.create(col), TableNode.create(table)));
}

// ../../node_modules/.pnpm/kysely@0.27.6/node_modules/kysely/dist/esm/helpers/sqlite.js
function jsonArrayFrom(expr) {
  return sql`(select coalesce(json_group_array(json_object(${sql.join(getSqliteJsonObjectArgs(expr.toOperationNode(), "agg"))})), '[]') from ${expr} as agg)`;
}
function jsonObjectFrom(expr) {
  return sql`(select json_object(${sql.join(getSqliteJsonObjectArgs(expr.toOperationNode(), "obj"))}) from ${expr} as obj)`;
}
function getSqliteJsonObjectArgs(node, table) {
  try {
    return getJsonObjectArgs(node, table);
  } catch (e) {
    throw new Error("SQLite jsonArrayFrom and jsonObjectFrom functions can only handle explicit selections due to limitations of the json_object function. selectAll() is not allowed in the subquery.");
  }
}

// ../lix-sdk/src/hooks/create-hooks.ts
function createHooks() {
  const eventTarget = new EventTarget();
  return {
    onStateCommit(handler) {
      eventTarget.addEventListener("state_commit", handler);
      return () => eventTarget.removeEventListener("state_commit", handler);
    },
    onFileChange(handler) {
      const wrappedHandler = (event) => {
        const customEvent = event;
        handler(customEvent.detail.fileId, customEvent.detail.operation);
      };
      eventTarget.addEventListener("file_change", wrappedHandler);
      return () => eventTarget.removeEventListener("file_change", wrappedHandler);
    },
    _emit(eventType, data) {
      eventTarget.dispatchEvent(new CustomEvent(eventType, { detail: data }));
    }
  };
}

// ../lix-sdk/src/label/create-label.ts
async function createLabel(args) {
  const executeInTransaction = async (trx) => {
    var _a, _b;
    const labelId = args.id || nanoid();
    await trx.insertInto("label_all").values({
      id: labelId,
      name: args.name,
      lixcol_version_id: (_a = args.lixcol_version_id) != null ? _a : trx.selectFrom("active_version").select("version_id")
    }).execute();
    const label = await trx.selectFrom("label_all").selectAll().where("id", "=", labelId).where(
      "lixcol_version_id",
      "=",
      (_b = args.lixcol_version_id) != null ? _b : trx.selectFrom("active_version").select("version_id")
    ).executeTakeFirstOrThrow();
    return label;
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../sqlite-wasm-kysely/dist/util/contentFromDatabase.js
var contentFromDatabase = (db) => {
  return db.sqlite3.capi.sqlite3_js_db_export(db);
};

// ../../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.48.0-build4/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs
var import_meta = {};
var sqlite3InitModule = (() => {
  var _scriptName = import_meta.url;
  return function(moduleArg = {}) {
    var moduleRtn;
    var Module2 = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    var readyPromise = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    const sqlite3InitModuleState = globalThis.sqlite3InitModuleState || Object.assign(/* @__PURE__ */ Object.create(null), {
      debugModule: () => {
      }
    });
    delete globalThis.sqlite3InitModuleState;
    sqlite3InitModuleState.debugModule(
      "globalThis.location =",
      globalThis.location
    );
    var moduleOverrides = Object.assign({}, Module2);
    var thisProgram = "./this.program";
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module2["locateFile"]) {
        return Module2["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptName) {
        scriptDirectory = _scriptName;
      }
      if (scriptDirectory.startsWith("blob:")) {
        scriptDirectory = "";
      } else {
        scriptDirectory = scriptDirectory.substr(
          0,
          scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
        );
      }
      {
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }
        readAsync = (url) => {
          return fetch(url, { credentials: "same-origin" }).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            }
            return Promise.reject(
              new Error(response.status + " : " + response.url)
            );
          });
        };
      }
    }
    var out = Module2["print"] || console.log.bind(console);
    var err = Module2["printErr"] || console.error.bind(console);
    Object.assign(Module2, moduleOverrides);
    moduleOverrides = null;
    if (Module2["arguments"]) Module2["arguments"];
    if (Module2["thisProgram"]) thisProgram = Module2["thisProgram"];
    var wasmBinary2 = Module2["wasmBinary"];
    var wasmMemory;
    var ABORT = false;
    var HEAP8, HEAPU8, HEAP16, HEAP32, HEAPU32, HEAP64;
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module2["HEAP8"] = HEAP8 = new Int8Array(b);
      Module2["HEAP16"] = HEAP16 = new Int16Array(b);
      Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module2["HEAPU16"] = new Uint16Array(b);
      Module2["HEAP32"] = HEAP32 = new Int32Array(b);
      Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module2["HEAPF32"] = new Float32Array(b);
      Module2["HEAPF64"] = new Float64Array(b);
      Module2["HEAP64"] = HEAP64 = new BigInt64Array(b);
      Module2["HEAPU64"] = new BigUint64Array(b);
    }
    if (Module2["wasmMemory"]) {
      wasmMemory = Module2["wasmMemory"];
    } else {
      var INITIAL_MEMORY = Module2["INITIAL_MEMORY"] || 16777216;
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_MEMORY / 65536,
        maximum: 32768
      });
    }
    updateMemoryViews();
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATPOSTRUN__ = [];
    function preRun() {
      var preRuns = Module2["preRun"];
      if (preRuns) {
        if (typeof preRuns == "function") preRuns = [preRuns];
        preRuns.forEach(addOnPreRun);
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      if (!Module2["noFSInit"] && !FS.initialized) FS.init();
      FS.ignorePermissions = false;
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      var postRuns = Module2["postRun"];
      if (postRuns) {
        if (typeof postRuns == "function") postRuns = [postRuns];
        postRuns.forEach(addOnPostRun);
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    function addRunDependency(id) {
      var _a;
      runDependencies++;
      (_a = Module2["monitorRunDependencies"]) == null ? void 0 : _a.call(Module2, runDependencies);
    }
    function removeRunDependency(id) {
      var _a;
      runDependencies--;
      (_a = Module2["monitorRunDependencies"]) == null ? void 0 : _a.call(Module2, runDependencies);
      if (runDependencies == 0) {
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      var _a;
      (_a = Module2["onAbort"]) == null ? void 0 : _a.call(Module2, what);
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
    function findWasmBinary() {
      if (Module2["locateFile"]) {
        var f = "sqlite3.wasm";
        if (!isDataURI(f)) {
          return locateFile(f);
        }
        return f;
      }
      return new URL("sqlite3.wasm", import_meta.url).href;
    }
    var wasmBinaryFile;
    function getBinarySync(file) {
      if (file == wasmBinaryFile && wasmBinary2) {
        return new Uint8Array(wasmBinary2);
      }
      if (readBinary) {
        return readBinary(file);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    function getBinaryPromise(binaryFile) {
      if (!wasmBinary2) {
        return readAsync(binaryFile).then(
          (response) => new Uint8Array(response),
          () => getBinarySync(binaryFile)
        );
      }
      return Promise.resolve().then(() => getBinarySync(binaryFile));
    }
    function instantiateArrayBuffer(binaryFile, imports, receiver) {
      return getBinaryPromise(binaryFile).then((binary) => {
        return WebAssembly.instantiate(binary, imports);
      }).then(receiver, (reason) => {
        err(`failed to asynchronously prepare wasm: ${reason}`);
        abort(reason);
      });
    }
    function instantiateAsync(binary, binaryFile, imports, callback) {
      if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {
        return fetch(binaryFile, { credentials: "same-origin" }).then(
          (response) => {
            var result = WebAssembly.instantiateStreaming(response, imports);
            return result.then(callback, function(reason) {
              err(`wasm streaming compile failed: ${reason}`);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(binaryFile, imports, callback);
            });
          }
        );
      }
      return instantiateArrayBuffer(binaryFile, imports, callback);
    }
    function getWasmImports() {
      return {
        env: wasmImports,
        wasi_snapshot_preview1: wasmImports
      };
    }
    function createWasm() {
      var info = getWasmImports();
      function receiveInstance(instance, module) {
        wasmExports = instance.exports;
        addOnInit(wasmExports["__wasm_call_ctors"]);
        removeRunDependency();
        return wasmExports;
      }
      addRunDependency();
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"]);
      }
      if (Module2["instantiateWasm"]) {
        try {
          return Module2["instantiateWasm"](info, receiveInstance);
        } catch (e) {
          err(`Module.instantiateWasm callback failed with error: ${e}`);
          readyPromiseReject(e);
        }
      }
      wasmBinaryFile != null ? wasmBinaryFile : wasmBinaryFile = findWasmBinary();
      instantiateAsync(
        wasmBinary2,
        wasmBinaryFile,
        info,
        receiveInstantiationResult
      ).catch(readyPromiseReject);
      return {};
    }
    var callRuntimeCallbacks = (callbacks) => {
      callbacks.forEach((f) => f(Module2));
    };
    Module2["noExitRuntime"] || true;
    var PATH = {
      isAbs: (path) => path.charAt(0) === "/",
      splitPath: (filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: (parts, allowAboveRoot) => {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === ".") {
            parts.splice(i, 1);
          } else if (last === "..") {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      },
      normalize: (path) => {
        var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
        path = PATH.normalizeArray(
          path.split("/").filter((p) => !!p),
          !isAbsolute
        ).join("/");
        if (!path && !isAbsolute) {
          path = ".";
        }
        if (path && trailingSlash) {
          path += "/";
        }
        return (isAbsolute ? "/" : "") + path;
      },
      dirname: (path) => {
        var result = PATH.splitPath(path), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: (path) => {
        if (path === "/") return "/";
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash === -1) return path;
        return path.substr(lastSlash + 1);
      },
      join: (...paths) => PATH.normalize(paths.join("/")),
      join2: (l, r) => PATH.normalize(l + "/" + r)
    };
    var initRandomFill = () => {
      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
        return (view) => crypto.getRandomValues(view);
      } else abort("initRandomDevice");
    };
    var randomFill = (view) => {
      return (randomFill = initRandomFill())(view);
    };
    var PATH_FS = {
      resolve: (...args) => {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? args[i] : FS.cwd();
          if (typeof path != "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path) {
            return "";
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        resolvedPath = PATH.normalizeArray(
          resolvedPath.split("/").filter((p) => !!p),
          !resolvedAbsolute
        ).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      },
      relative: (from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim4(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== "") break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "") break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim4(from.split("/"));
        var toParts = trim4(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }
    };
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(
            55296 | ch >> 10,
            56320 | ch & 1023
          );
        }
      }
      return str;
    };
    var FS_stdin_getChar_buffer = [];
    var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(
        stringy,
        u8array,
        0,
        u8array.length
      );
      u8array.length = numBytesWritten;
      return u8array;
    }
    var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (typeof window != "undefined" && typeof window.prompt == "function") {
          result = window.prompt("Input: ");
          if (result !== null) {
            result += "\n";
          }
        }
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result);
      }
      return FS_stdin_getChar_buffer.shift();
    };
    var TTY = {
      ttys: [],
      init() {
      },
      shutdown() {
      },
      register(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
        close(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        fsync(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        read(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0) break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }
      },
      default_tty_ops: {
        get_char(tty) {
          return FS_stdin_getChar();
        },
        put_char(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output));
            tty.output = [];
          }
        },
        ioctl_tcgets(tty) {
          return {
            c_iflag: 25856,
            c_oflag: 5,
            c_cflag: 191,
            c_lflag: 35387,
            c_cc: [
              3,
              28,
              127,
              21,
              4,
              0,
              1,
              0,
              17,
              19,
              26,
              0,
              18,
              15,
              23,
              22,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          };
        },
        ioctl_tcsets(tty, optional_actions, data) {
          return 0;
        },
        ioctl_tiocgwinsz(tty) {
          return [24, 80];
        }
      },
      default_tty1_ops: {
        put_char(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output));
            tty.output = [];
          }
        }
      }
    };
    var zeroMemory = (address, size) => {
      HEAPU8.fill(0, address, address + size);
    };
    var alignMemory = (size, alignment) => {
      return Math.ceil(size / alignment) * alignment;
    };
    var mmapAlloc = (size) => {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (ptr) zeroMemory(ptr, size);
      return ptr;
    };
    var MEMFS = {
      ops_table: null,
      mount(mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      },
      createNode(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        MEMFS.ops_table || (MEMFS.ops_table = {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        });
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
      getFileDataAsTypedArray(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(
          newCapacity,
          prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
        );
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      },
      resizeFileStorage(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(
              oldContents.subarray(0, Math.min(newSize, node.usedBytes))
            );
          }
          node.usedBytes = newSize;
        }
      },
      node_ops: {
        getattr(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup(parent, name) {
          throw FS.genericErrors[44];
        },
        mknod(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
        },
        unlink(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        rmdir(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        readdir(node) {
          var entries = [".", ".."];
          for (var key of Object.keys(node.contents)) {
            entries.push(key);
          }
          return entries;
        },
        symlink(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }
      },
      stream_ops: {
        read(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer[offset + i] = contents[position + i];
          }
          return size;
        },
        write(stream, buffer, offset, length, position, canOwn) {
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(
                buffer.subarray(offset, offset + length),
                position
              );
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(
              buffer.subarray(offset, offset + length),
              position
            );
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(
            stream.node.usedBytes,
            offset + length
          );
        },
        mmap(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            if (contents) {
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(
                    contents,
                    position,
                    position + length
                  );
                }
              }
              HEAP8.set(contents, ptr);
            }
          }
          return { ptr, allocated };
        },
        msync(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          return 0;
        }
      }
    };
    var asyncLoad = (url, onload, onerror, noRunDep) => {
      var dep = getUniqueRunDependency(`al ${url}`) ;
      readAsync(url).then(
        (arrayBuffer) => {
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency();
        },
        (err2) => {
          if (onerror) {
            onerror();
          } else {
            throw `Loading data file "${url}" failed.`;
          }
        }
      );
      if (dep) addRunDependency();
    };
    var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
    };
    var preloadPlugins = Module2["preloadPlugins"] || [];
    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
      if (typeof Browser != "undefined") Browser.init();
      var handled = false;
      preloadPlugins.forEach((plugin) => {
        if (handled) return;
        if (plugin["canHandle"](fullname)) {
          plugin["handle"](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    };
    var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
      function processData(byteArray) {
        function finish(byteArray2) {
          preFinish == null ? void 0 : preFinish();
          if (!dontCreateFile) {
            FS_createDataFile(
              parent,
              name,
              byteArray2,
              canRead,
              canWrite,
              canOwn
            );
          }
          onload == null ? void 0 : onload();
          removeRunDependency();
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          onerror == null ? void 0 : onerror();
          removeRunDependency();
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency();
      if (typeof url == "string") {
        asyncLoad(url, processData, onerror);
      } else {
        processData(url);
      }
    };
    var FS_modeStringToFlags = (str) => {
      var flagModes = {
        r: 0,
        "r+": 2,
        w: 512 | 64 | 1,
        "w+": 512 | 64 | 2,
        a: 1024 | 64 | 1,
        "a+": 1024 | 64 | 2
      };
      var flags = flagModes[str];
      if (typeof flags == "undefined") {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    };
    var FS_getMode = (canRead, canWrite) => {
      var mode = 0;
      if (canRead) mode |= 292 | 73;
      if (canWrite) mode |= 146;
      return mode;
    };
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: "/",
      initialized: false,
      ignorePermissions: true,
      ErrnoError: class {
        constructor(errno) {
          this.name = "ErrnoError";
          this.errno = errno;
        }
      },
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      readFiles: {},
      FSStream: class {
        constructor() {
          this.shared = {};
        }
        get object() {
          return this.node;
        }
        set object(val) {
          this.node = val;
        }
        get isRead() {
          return (this.flags & 2097155) !== 1;
        }
        get isWrite() {
          return (this.flags & 2097155) !== 0;
        }
        get isAppend() {
          return this.flags & 1024;
        }
        get flags() {
          return this.shared.flags;
        }
        set flags(val) {
          this.shared.flags = val;
        }
        get position() {
          return this.shared.position;
        }
        set position(val) {
          this.shared.position = val;
        }
      },
      FSNode: class {
        constructor(parent, name, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
          this.readMode = 292 | 73;
          this.writeMode = 146;
        }
        get read() {
          return (this.mode & this.readMode) === this.readMode;
        }
        set read(val) {
          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
        }
        get write() {
          return (this.mode & this.writeMode) === this.writeMode;
        }
        set write(val) {
          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
        }
        get isFolder() {
          return FS.isDir(this.mode);
        }
        get isDevice() {
          return FS.isChrdev(this.mode);
        }
      },
      lookupPath(path, opts = {}) {
        path = PATH_FS.resolve(path);
        if (!path) return { path: "", node: null };
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts);
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts = path.split("/").filter((p) => !!p);
        var current = FS.root;
        var current_path = "/";
        for (var i = 0; i < parts.length; i++) {
          var islast = i === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count + 1
              });
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return { path: current_path, node: current };
      },
      getPath(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
          }
          path = path ? `${node.name}/${path}` : node.name;
          node = node.parent;
        }
      },
      hashName(parentid, name) {
        var hash = 0;
        for (var i = 0; i < name.length; i++) {
          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
        }
        return (parentid + hash >>> 0) % FS.nameTable.length;
      },
      hashAddNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        return FS.lookup(parent, name);
      },
      createNode(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node;
      },
      destroyNode(node) {
        FS.hashRemoveNode(node);
      },
      isRoot(node) {
        return node === node.parent;
      },
      isMountpoint(node) {
        return !!node.mounted;
      },
      isFile(mode) {
        return (mode & 61440) === 32768;
      },
      isDir(mode) {
        return (mode & 61440) === 16384;
      },
      isLink(mode) {
        return (mode & 61440) === 40960;
      },
      isChrdev(mode) {
        return (mode & 61440) === 8192;
      },
      isBlkdev(mode) {
        return (mode & 61440) === 24576;
      },
      isFIFO(mode) {
        return (mode & 61440) === 4096;
      },
      isSocket(mode) {
        return (mode & 49152) === 49152;
      },
      flagsToPermissionString(flag) {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
          perms += "w";
        }
        return perms;
      },
      nodePermissions(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.includes("r") && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes("w") && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes("x") && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup(dir) {
        if (!FS.isDir(dir.mode)) return 54;
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
      mayCreate(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, "wx");
      },
      mayDelete(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd() {
        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStreamChecked(fd) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        return stream;
      },
      getStream: (fd) => FS.streams[fd],
      createStream(stream, fd = -1) {
        stream = Object.assign(new FS.FSStream(), stream);
        if (fd == -1) {
          fd = FS.nextfd();
        }
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream(fd) {
        FS.streams[fd] = null;
      },
      dupStream(origStream, fd = -1) {
        var _a, _b;
        var stream = FS.createStream(origStream, fd);
        (_b = (_a = stream.stream_ops) == null ? void 0 : _a.dup) == null ? void 0 : _b.call(_a, stream);
        return stream;
      },
      chrdev_stream_ops: {
        open(stream) {
          var _a, _b;
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          (_b = (_a = stream.stream_ops).open) == null ? void 0 : _b.call(_a, stream);
        },
        llseek() {
          throw new FS.ErrnoError(70);
        }
      },
      major: (dev) => dev >> 8,
      minor: (dev) => dev & 255,
      makedev: (ma, mi) => ma << 8 | mi,
      registerDevice(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: (dev) => FS.devices[dev],
      getMounts(mount) {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m = check.pop();
          mounts.push(m);
          check.push(...m.mounts);
        }
        return mounts;
      },
      syncfs(populate, callback) {
        if (typeof populate == "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err(
            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
          );
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount(type, opts, mountpoint) {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      },
      unmount(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },
      mknod(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === "." || name === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create(path, mode) {
        mode = mode !== void 0 ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
      mkdir(path, mode) {
        mode = mode !== void 0 ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
      mkdirTree(path, mode) {
        var dirs = path.split("/");
        var d = "";
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += "/" + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != 20) throw e;
          }
        }
      },
      mkdev(path, mode, dev) {
        if (typeof dev == "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
      symlink(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
          old_node.parent = new_dir;
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }
      },
      rmdir(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
      readdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
      readlink(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(
          FS.getPath(link.parent),
          link.node_ops.readlink(link)
        );
      },
      stat(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat(path) {
        return FS.stat(path, true);
      },
      chmod(path, mode, dontFollow) {
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: mode & 4095 | node.mode & -4096,
          timestamp: Date.now()
        });
      },
      lchmod(path, mode) {
        FS.chmod(path, mode, true);
      },
      fchmod(fd, mode) {
        var stream = FS.getStreamChecked(fd);
        FS.chmod(stream.node, mode);
      },
      chown(path, uid, gid, dontFollow) {
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
        });
      },
      lchown(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },
      fchown(fd, uid, gid) {
        var stream = FS.getStreamChecked(fd);
        FS.chown(stream.node, uid, gid);
      },
      truncate(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
      ftruncate(fd, len) {
        var stream = FS.getStreamChecked(fd);
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
      utime(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },
      open(path, flags, mode) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
        if (flags & 64) {
          mode = typeof mode == "undefined" ? 438 : mode;
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == "object") {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
          }
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags &= -513;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags & 512 && !created) {
          FS.truncate(node, 0);
        }
        flags &= -131713;
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          ungotten: [],
          error: false
        });
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module2["logReadFiles"] && !(flags & 1)) {
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },
      close(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed(stream) {
        return stream.fd === null;
      },
      llseek(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(
          stream,
          buffer,
          offset,
          length,
          position
        );
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
      write(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(
          stream,
          buffer,
          offset,
          length,
          position,
          canOwn
        );
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
      mmap(stream, length, position, prot, flags) {
        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        if (!length) {
          throw new FS.ErrnoError(28);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
      msync(stream, buffer, offset, length, mmapFlags) {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(
          stream,
          buffer,
          offset,
          length,
          mmapFlags
        );
      },
      ioctl(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile(path, opts = {}) {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error(`Invalid encoding type "${opts.encoding}"`);
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
      writeFile(path, data, opts = {}) {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream);
      },
      cwd: () => FS.currentPath,
      chdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories() {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      },
      createDefaultDevices() {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var randomBuffer = new Uint8Array(1024), randomLeft = 0;
        var randomByte = () => {
          if (randomLeft === 0) {
            randomLeft = randomFill(randomBuffer).byteLength;
          }
          return randomBuffer[--randomLeft];
        };
        FS.createDevice("/dev", "random", randomByte);
        FS.createDevice("/dev", "urandom", randomByte);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      },
      createSpecialDirectories() {
        FS.mkdir("/proc");
        var proc_self = FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount(
          {
            mount() {
              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
              node.node_ops = {
                lookup(parent, name) {
                  var fd = +name;
                  var stream = FS.getStreamChecked(fd);
                  var ret = {
                    parent: null,
                    mount: { mountpoint: "fake" },
                    node_ops: { readlink: () => stream.path }
                  };
                  ret.parent = ret;
                  return ret;
                }
              };
              return node;
            }
          },
          {},
          "/proc/self/fd"
        );
      },
      createStandardStreams(input, output, error) {
        if (input) {
          FS.createDevice("/dev", "stdin", input);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (output) {
          FS.createDevice("/dev", "stdout", null, output);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (error) {
          FS.createDevice("/dev", "stderr", null, error);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        FS.open("/dev/stdin", 0);
        FS.open("/dev/stdout", 1);
        FS.open("/dev/stderr", 1);
      },
      staticInit() {
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {
          MEMFS
        };
      },
      init(input, output, error) {
        FS.initialized = true;
        input != null ? input : input = Module2["stdin"];
        output != null ? output : output = Module2["stdout"];
        error != null ? error : error = Module2["stderr"];
        FS.createStandardStreams(input, output, error);
      },
      quit() {
        FS.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
      findObject(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
      analyzePath(path, dontResolveLastLink) {
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e) {
          ret.error = e.errno;
        }
        return ret;
      },
      createPath(parent, path, canRead, canWrite) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        var parts = path.split("/").reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
          }
          parent = current;
        }
        return current;
      },
      createFile(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS_getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
      createDataFile(parent, name, data, canRead, canWrite, canOwn) {
        var path = name;
        if (parent) {
          parent = typeof parent == "string" ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS_getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == "string") {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i)
              arr[i] = data.charCodeAt(i);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
      },
      createDevice(parent, name, input, output) {
        var _a, _b;
        var path = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS_getMode(!!input, !!output);
        (_b = (_a = FS.createDevice).major) != null ? _b : _a.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open(stream) {
            stream.seekable = false;
          },
          close(stream) {
            var _a2;
            if ((_a2 = output == null ? void 0 : output.buffer) == null ? void 0 : _a2.length) {
              output(10);
            }
          },
          read(stream, buffer, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0) break;
              bytesRead++;
              buffer[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },
      forceLoadFile(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest != "undefined") {
          throw new Error(
            "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
          );
        } else {
          try {
            obj.contents = readBinary(obj.url);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
      },
      createLazyFile(parent, name, url, canRead, canWrite) {
        class LazyUint8Array {
          constructor() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          }
          setDataGetter(getter) {
            this.getter = getter;
          }
          cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr.status
              );
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing) chunkSize = datalength;
            var doXHR = (from, to) => {
              if (from > to)
                throw new Error(
                  "invalid range (" + from + ", " + to + ") or no bytes requested!"
                );
              if (to > datalength - 1)
                throw new Error(
                  "only " + datalength + " bytes available! programmer error!"
                );
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error(
                  "Couldn't load " + url + ". Status: " + xhr2.status
                );
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              }
              return intArrayFromString(xhr2.responseText || "");
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out(
                "LazyFiles on gzip forces download of the whole file when length is accessed"
              );
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }
          get length() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
          get chunkSize() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
        if (typeof XMLHttpRequest != "undefined") {
          if (!ENVIRONMENT_IS_WORKER)
            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url };
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {
          usedBytes: {
            get: function() {
              return this.contents.length;
            }
          }
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = (...args) => {
            FS.forceLoadFile(node);
            return fn(...args);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length) return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position);
        };
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      }
    };
    var UTF8ToString = (ptr, maxBytesToRead) => {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      calculateAt(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },
      doStat(func, path, buf) {
        var stat = func(path);
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 4 >> 2] = stat.mode;
        HEAPU32[buf + 8 >> 2] = stat.nlink;
        HEAP32[buf + 12 >> 2] = stat.uid;
        HEAP32[buf + 16 >> 2] = stat.gid;
        HEAP32[buf + 20 >> 2] = stat.rdev;
        HEAP64[buf + 24 >> 3] = BigInt(stat.size);
        HEAP32[buf + 32 >> 2] = 4096;
        HEAP32[buf + 36 >> 2] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
        HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
        HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
        HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
        HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
        return 0;
      },
      doMsync(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
      getStreamFromFD(fd) {
        var stream = FS.getStreamChecked(fd);
        return stream;
      },
      varargs: void 0,
      getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }
    };
    function ___syscall_chmod(path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        FS.chmod(path, mode);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_faccessat(dirfd, path, amode, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (amode & ~7) {
          return -28;
        }
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = "";
        if (amode & 4) perms += "r";
        if (amode & 2) perms += "w";
        if (amode & 1) perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_fchmod(fd, mode) {
      try {
        FS.fchmod(fd, mode);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_fchown32(fd, owner, group) {
      try {
        FS.fchown(fd, owner, group);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function syscallGetVarargI() {
      var ret = HEAP32[+SYSCALLS.varargs >> 2];
      SYSCALLS.varargs += 4;
      return ret;
    }
    var syscallGetVarargP = syscallGetVarargI;
    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = syscallGetVarargI();
            if (arg < 0) {
              return -28;
            }
            while (FS.streams[arg]) {
              arg++;
            }
            var newStream;
            newStream = FS.dupStream(stream, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream.flags;
          case 4: {
            var arg = syscallGetVarargI();
            stream.flags |= arg;
            return 0;
          }
          case 12: {
            var arg = syscallGetVarargP();
            var offset = 0;
            HEAP16[arg + offset >> 1] = 2;
            return 0;
          }
          case 13:
          case 14:
            return 0;
        }
        return -28;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_fstat64(fd, buf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    var INT53_MAX = 9007199254740992;
    var INT53_MIN = -9007199254740992;
    var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
    function ___syscall_ftruncate64(fd, length) {
      length = bigintToI53Checked(length);
      try {
        if (isNaN(length)) return 61;
        FS.ftruncate(fd, length);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
    function ___syscall_getcwd(buf, size) {
      try {
        if (size === 0) return -28;
        var cwd = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
        if (size < cwdLengthInBytes) return -68;
        stringToUTF8(cwd, buf, size);
        return cwdLengthInBytes;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21505: {
            if (!stream.tty) return -59;
            if (stream.tty.ops.ioctl_tcgets) {
              var termios = stream.tty.ops.ioctl_tcgets(stream);
              var argp = syscallGetVarargP();
              HEAP32[argp >> 2] = termios.c_iflag || 0;
              HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
              HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
              HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
              for (var i = 0; i < 32; i++) {
                HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
              }
              return 0;
            }
            return 0;
          }
          case 21510:
          case 21511:
          case 21512: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21506:
          case 21507:
          case 21508: {
            if (!stream.tty) return -59;
            if (stream.tty.ops.ioctl_tcsets) {
              var argp = syscallGetVarargP();
              var c_iflag = HEAP32[argp >> 2];
              var c_oflag = HEAP32[argp + 4 >> 2];
              var c_cflag = HEAP32[argp + 8 >> 2];
              var c_lflag = HEAP32[argp + 12 >> 2];
              var c_cc = [];
              for (var i = 0; i < 32; i++) {
                c_cc.push(HEAP8[argp + i + 17]);
              }
              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
                c_iflag,
                c_oflag,
                c_cflag,
                c_lflag,
                c_cc
              });
            }
            return 0;
          }
          case 21519: {
            if (!stream.tty) return -59;
            var argp = syscallGetVarargP();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream.tty) return -59;
            return -28;
          }
          case 21531: {
            var argp = syscallGetVarargP();
            return FS.ioctl(stream, op, argp);
          }
          case 21523: {
            if (!stream.tty) return -59;
            if (stream.tty.ops.ioctl_tiocgwinsz) {
              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
              var argp = syscallGetVarargP();
              HEAP16[argp >> 1] = winsize[0];
              HEAP16[argp + 2 >> 1] = winsize[1];
            }
            return 0;
          }
          case 21524: {
            if (!stream.tty) return -59;
            return 0;
          }
          case 21515: {
            if (!stream.tty) return -59;
            return 0;
          }
          default:
            return -28;
        }
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_lstat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.lstat, path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_mkdirat(dirfd, path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        path = PATH.normalize(path);
        if (path[path.length - 1] === "/")
          path = path.substr(0, path.length - 1);
        FS.mkdir(path, mode, 0);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_newfstatat(dirfd, path, buf, flags) {
      try {
        path = SYSCALLS.getStr(path);
        var nofollow = flags & 256;
        var allowEmpty = flags & 4096;
        flags = flags & ~6400;
        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_openat(dirfd, path, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        var mode = varargs ? syscallGetVarargI() : 0;
        return FS.open(path, flags, mode).fd;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_rmdir(path) {
      try {
        path = SYSCALLS.getStr(path);
        FS.rmdir(path);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_stat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.stat, path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function ___syscall_unlinkat(dirfd, path, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (flags === 0) {
          FS.unlink(path);
        } else if (flags === 512) {
          FS.rmdir(path);
        } else {
          abort("Invalid flags passed to unlinkat");
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    var readI53FromI64 = (ptr) => {
      return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
    };
    function ___syscall_utimensat(dirfd, path, times, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path, true);
        var now = Date.now(), atime, mtime;
        if (!times) {
          atime = now;
          mtime = now;
        } else {
          var seconds = readI53FromI64(times);
          var nanoseconds = HEAP32[times + 8 >> 2];
          if (nanoseconds == 1073741823) {
            atime = now;
          } else if (nanoseconds == 1073741822) {
            atime = -1;
          } else {
            atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
          }
          times += 16;
          seconds = readI53FromI64(times);
          nanoseconds = HEAP32[times + 8 >> 2];
          if (nanoseconds == 1073741823) {
            mtime = now;
          } else if (nanoseconds == 1073741822) {
            mtime = -1;
          } else {
            mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
          }
        }
        if (mtime != -1 || atime != -1) {
          FS.utime(path, atime, mtime);
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    var nowIsMonotonic = 1;
    var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
    var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    var MONTH_DAYS_LEAP_CUMULATIVE = [
      0,
      31,
      60,
      91,
      121,
      152,
      182,
      213,
      244,
      274,
      305,
      335
    ];
    var MONTH_DAYS_REGULAR_CUMULATIVE = [
      0,
      31,
      59,
      90,
      120,
      151,
      181,
      212,
      243,
      273,
      304,
      334
    ];
    var ydayFromDate = (date) => {
      var leap = isLeapYear(date.getFullYear());
      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
      return yday;
    };
    function __localtime_js(time, tmPtr) {
      time = bigintToI53Checked(time);
      var date = new Date(time * 1e3);
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = ydayFromDate(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[tmPtr + 32 >> 2] = dst;
    }
    function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
      offset = bigintToI53Checked(offset);
      try {
        if (isNaN(offset)) return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        var res = FS.mmap(stream, len, offset, prot, flags);
        var ptr = res.ptr;
        HEAP32[allocated >> 2] = res.allocated;
        HEAPU32[addr >> 2] = ptr;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    function __munmap_js(addr, len, prot, flags, fd, offset) {
      offset = bigintToI53Checked(offset);
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, flags, offset);
        }
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    var __tzset_js = (timezone, daylight, std_name, dst_name) => {
      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
      var extractZone = (timezoneOffset) => {
        var sign = timezoneOffset >= 0 ? "-" : "+";
        var absOffset = Math.abs(timezoneOffset);
        var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
        var minutes = String(absOffset % 60).padStart(2, "0");
        return `UTC${sign}${hours}${minutes}`;
      };
      var winterName = extractZone(winterOffset);
      var summerName = extractZone(summerOffset);
      if (summerOffset < winterOffset) {
        stringToUTF8(winterName, std_name, 17);
        stringToUTF8(summerName, dst_name, 17);
      } else {
        stringToUTF8(winterName, dst_name, 17);
        stringToUTF8(summerName, std_name, 17);
      }
    };
    var _emscripten_date_now = () => Date.now();
    var _emscripten_get_now = () => performance.now();
    var getHeapMax = () => 2147483648;
    var growMemory = (size) => {
      var b = wasmMemory.buffer;
      var pages = (size - b.byteLength + 65535) / 65536 | 0;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {
      }
    };
    var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(
          overGrownHeapSize,
          requestedSize + 100663296
        );
        var newSize = Math.min(
          maxHeapSize,
          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)
        );
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    };
    var ENV = {};
    var getExecutableName = () => {
      return thisProgram || "./this.program";
    };
    var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
        var env = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: lang,
          _: getExecutableName()
        };
        for (var x in ENV) {
          if (ENV[x] === void 0) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(`${x}=${env[x]}`);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    };
    var stringToAscii = (str, buffer) => {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++] = str.charCodeAt(i);
      }
      HEAP8[buffer] = 0;
    };
    var _environ_get = (__environ, environ_buf) => {
      var bufSize = 0;
      getEnvStrings().forEach((string, i) => {
        var ptr = environ_buf + bufSize;
        HEAPU32[__environ + i * 4 >> 2] = ptr;
        stringToAscii(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    };
    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach((string) => bufSize += string.length + 1);
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    };
    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    function _fd_fdstat_get(fd, pbuf) {
      try {
        var rightsBase = 0;
        var rightsInheriting = 0;
        var flags = 0;
        {
          var stream = SYSCALLS.getStreamFromFD(fd);
          var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
        }
        HEAP8[pbuf] = type;
        HEAP16[pbuf + 2 >> 1] = flags;
        HEAP64[pbuf + 8 >> 3] = BigInt(rightsBase);
        HEAP64[pbuf + 16 >> 3] = BigInt(rightsInheriting);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    var doReadv = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break;
      }
      return ret;
    };
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    function _fd_seek(fd, offset, whence, newOffset) {
      offset = bigintToI53Checked(offset);
      try {
        if (isNaN(offset)) return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset, whence);
        HEAP64[newOffset >> 3] = BigInt(stream.position);
        if (stream.getdents && offset === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    function _fd_sync(fd) {
      var _a;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if ((_a = stream.stream_ops) == null ? void 0 : _a.fsync) {
          return stream.stream_ops.fsync(stream);
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    var doWritev = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) {
          break;
        }
      }
      return ret;
    };
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    FS.createPreloadedFile = FS_createPreloadedFile;
    FS.staticInit();
    var wasmImports = {
      __syscall_chmod: ___syscall_chmod,
      __syscall_faccessat: ___syscall_faccessat,
      __syscall_fchmod: ___syscall_fchmod,
      __syscall_fchown32: ___syscall_fchown32,
      __syscall_fcntl64: ___syscall_fcntl64,
      __syscall_fstat64: ___syscall_fstat64,
      __syscall_ftruncate64: ___syscall_ftruncate64,
      __syscall_getcwd: ___syscall_getcwd,
      __syscall_ioctl: ___syscall_ioctl,
      __syscall_lstat64: ___syscall_lstat64,
      __syscall_mkdirat: ___syscall_mkdirat,
      __syscall_newfstatat: ___syscall_newfstatat,
      __syscall_openat: ___syscall_openat,
      __syscall_readlinkat: ___syscall_readlinkat,
      __syscall_rmdir: ___syscall_rmdir,
      __syscall_stat64: ___syscall_stat64,
      __syscall_unlinkat: ___syscall_unlinkat,
      __syscall_utimensat: ___syscall_utimensat,
      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
      _localtime_js: __localtime_js,
      _mmap_js: __mmap_js,
      _munmap_js: __munmap_js,
      _tzset_js: __tzset_js,
      emscripten_date_now: _emscripten_date_now,
      emscripten_get_now: _emscripten_get_now,
      emscripten_resize_heap: _emscripten_resize_heap,
      environ_get: _environ_get,
      environ_sizes_get: _environ_sizes_get,
      fd_close: _fd_close,
      fd_fdstat_get: _fd_fdstat_get,
      fd_read: _fd_read,
      fd_seek: _fd_seek,
      fd_sync: _fd_sync,
      fd_write: _fd_write,
      memory: wasmMemory
    };
    var wasmExports = createWasm();
    Module2["_sqlite3_status64"] = (a0, a1, a2, a3) => (Module2["_sqlite3_status64"] = wasmExports["sqlite3_status64"])(a0, a1, a2, a3);
    Module2["_sqlite3_status"] = (a0, a1, a2, a3) => (Module2["_sqlite3_status"] = wasmExports["sqlite3_status"])(a0, a1, a2, a3);
    Module2["_sqlite3_db_status"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_db_status"] = wasmExports["sqlite3_db_status"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3_msize"] = (a0) => (Module2["_sqlite3_msize"] = wasmExports["sqlite3_msize"])(a0);
    Module2["_sqlite3_vfs_find"] = (a0) => (Module2["_sqlite3_vfs_find"] = wasmExports["sqlite3_vfs_find"])(a0);
    Module2["_sqlite3_initialize"] = () => (Module2["_sqlite3_initialize"] = wasmExports["sqlite3_initialize"])();
    Module2["_sqlite3_malloc"] = (a0) => (Module2["_sqlite3_malloc"] = wasmExports["sqlite3_malloc"])(a0);
    Module2["_sqlite3_free"] = (a0) => (Module2["_sqlite3_free"] = wasmExports["sqlite3_free"])(
      a0
    );
    Module2["_sqlite3_vfs_register"] = (a0, a1) => (Module2["_sqlite3_vfs_register"] = wasmExports["sqlite3_vfs_register"])(a0, a1);
    Module2["_sqlite3_vfs_unregister"] = (a0) => (Module2["_sqlite3_vfs_unregister"] = wasmExports["sqlite3_vfs_unregister"])(a0);
    Module2["_sqlite3_malloc64"] = (a0) => (Module2["_sqlite3_malloc64"] = wasmExports["sqlite3_malloc64"])(a0);
    Module2["_sqlite3_realloc"] = (a0, a1) => (Module2["_sqlite3_realloc"] = wasmExports["sqlite3_realloc"])(a0, a1);
    Module2["_sqlite3_realloc64"] = (a0, a1) => (Module2["_sqlite3_realloc64"] = wasmExports["sqlite3_realloc64"])(a0, a1);
    Module2["_sqlite3_value_text"] = (a0) => (Module2["_sqlite3_value_text"] = wasmExports["sqlite3_value_text"])(a0);
    Module2["_sqlite3_randomness"] = (a0, a1) => (Module2["_sqlite3_randomness"] = wasmExports["sqlite3_randomness"])(a0, a1);
    Module2["_sqlite3_stricmp"] = (a0, a1) => (Module2["_sqlite3_stricmp"] = wasmExports["sqlite3_stricmp"])(a0, a1);
    Module2["_sqlite3_strnicmp"] = (a0, a1, a2) => (Module2["_sqlite3_strnicmp"] = wasmExports["sqlite3_strnicmp"])(a0, a1, a2);
    Module2["_sqlite3_uri_parameter"] = (a0, a1) => (Module2["_sqlite3_uri_parameter"] = wasmExports["sqlite3_uri_parameter"])(a0, a1);
    Module2["_sqlite3_uri_boolean"] = (a0, a1, a2) => (Module2["_sqlite3_uri_boolean"] = wasmExports["sqlite3_uri_boolean"])(a0, a1, a2);
    Module2["_sqlite3_serialize"] = (a0, a1, a2, a3) => (Module2["_sqlite3_serialize"] = wasmExports["sqlite3_serialize"])(a0, a1, a2, a3);
    Module2["_sqlite3_prepare_v2"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_prepare_v2"] = wasmExports["sqlite3_prepare_v2"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3_step"] = (a0) => (Module2["_sqlite3_step"] = wasmExports["sqlite3_step"])(
      a0
    );
    Module2["_sqlite3_column_int64"] = (a0, a1) => (Module2["_sqlite3_column_int64"] = wasmExports["sqlite3_column_int64"])(a0, a1);
    Module2["_sqlite3_reset"] = (a0) => (Module2["_sqlite3_reset"] = wasmExports["sqlite3_reset"])(a0);
    Module2["_sqlite3_exec"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_exec"] = wasmExports["sqlite3_exec"])(
      a0,
      a1,
      a2,
      a3,
      a4
    );
    Module2["_sqlite3_column_int"] = (a0, a1) => (Module2["_sqlite3_column_int"] = wasmExports["sqlite3_column_int"])(a0, a1);
    Module2["_sqlite3_finalize"] = (a0) => (Module2["_sqlite3_finalize"] = wasmExports["sqlite3_finalize"])(a0);
    Module2["_sqlite3_file_control"] = (a0, a1, a2, a3) => (Module2["_sqlite3_file_control"] = wasmExports["sqlite3_file_control"])(a0, a1, a2, a3);
    Module2["_sqlite3_column_name"] = (a0, a1) => (Module2["_sqlite3_column_name"] = wasmExports["sqlite3_column_name"])(a0, a1);
    Module2["_sqlite3_column_text"] = (a0, a1) => (Module2["_sqlite3_column_text"] = wasmExports["sqlite3_column_text"])(a0, a1);
    Module2["_sqlite3_column_type"] = (a0, a1) => (Module2["_sqlite3_column_type"] = wasmExports["sqlite3_column_type"])(a0, a1);
    Module2["_sqlite3_errmsg"] = (a0) => (Module2["_sqlite3_errmsg"] = wasmExports["sqlite3_errmsg"])(a0);
    Module2["_sqlite3_deserialize"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_deserialize"] = wasmExports["sqlite3_deserialize"])(a0, a1, a2, a3, a4, a5);
    Module2["_sqlite3_clear_bindings"] = (a0) => (Module2["_sqlite3_clear_bindings"] = wasmExports["sqlite3_clear_bindings"])(a0);
    Module2["_sqlite3_value_blob"] = (a0) => (Module2["_sqlite3_value_blob"] = wasmExports["sqlite3_value_blob"])(a0);
    Module2["_sqlite3_value_bytes"] = (a0) => (Module2["_sqlite3_value_bytes"] = wasmExports["sqlite3_value_bytes"])(a0);
    Module2["_sqlite3_value_double"] = (a0) => (Module2["_sqlite3_value_double"] = wasmExports["sqlite3_value_double"])(a0);
    Module2["_sqlite3_value_int"] = (a0) => (Module2["_sqlite3_value_int"] = wasmExports["sqlite3_value_int"])(a0);
    Module2["_sqlite3_value_int64"] = (a0) => (Module2["_sqlite3_value_int64"] = wasmExports["sqlite3_value_int64"])(a0);
    Module2["_sqlite3_value_subtype"] = (a0) => (Module2["_sqlite3_value_subtype"] = wasmExports["sqlite3_value_subtype"])(a0);
    Module2["_sqlite3_value_pointer"] = (a0, a1) => (Module2["_sqlite3_value_pointer"] = wasmExports["sqlite3_value_pointer"])(a0, a1);
    Module2["_sqlite3_value_type"] = (a0) => (Module2["_sqlite3_value_type"] = wasmExports["sqlite3_value_type"])(a0);
    Module2["_sqlite3_value_nochange"] = (a0) => (Module2["_sqlite3_value_nochange"] = wasmExports["sqlite3_value_nochange"])(a0);
    Module2["_sqlite3_value_frombind"] = (a0) => (Module2["_sqlite3_value_frombind"] = wasmExports["sqlite3_value_frombind"])(a0);
    Module2["_sqlite3_value_dup"] = (a0) => (Module2["_sqlite3_value_dup"] = wasmExports["sqlite3_value_dup"])(a0);
    Module2["_sqlite3_value_free"] = (a0) => (Module2["_sqlite3_value_free"] = wasmExports["sqlite3_value_free"])(a0);
    Module2["_sqlite3_result_blob"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_blob"] = wasmExports["sqlite3_result_blob"])(a0, a1, a2, a3);
    Module2["_sqlite3_result_error_toobig"] = (a0) => (Module2["_sqlite3_result_error_toobig"] = wasmExports["sqlite3_result_error_toobig"])(a0);
    Module2["_sqlite3_result_error_nomem"] = (a0) => (Module2["_sqlite3_result_error_nomem"] = wasmExports["sqlite3_result_error_nomem"])(a0);
    Module2["_sqlite3_result_double"] = (a0, a1) => (Module2["_sqlite3_result_double"] = wasmExports["sqlite3_result_double"])(a0, a1);
    Module2["_sqlite3_result_error"] = (a0, a1, a2) => (Module2["_sqlite3_result_error"] = wasmExports["sqlite3_result_error"])(a0, a1, a2);
    Module2["_sqlite3_result_int"] = (a0, a1) => (Module2["_sqlite3_result_int"] = wasmExports["sqlite3_result_int"])(a0, a1);
    Module2["_sqlite3_result_int64"] = (a0, a1) => (Module2["_sqlite3_result_int64"] = wasmExports["sqlite3_result_int64"])(a0, a1);
    Module2["_sqlite3_result_null"] = (a0) => (Module2["_sqlite3_result_null"] = wasmExports["sqlite3_result_null"])(a0);
    Module2["_sqlite3_result_pointer"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_pointer"] = wasmExports["sqlite3_result_pointer"])(a0, a1, a2, a3);
    Module2["_sqlite3_result_subtype"] = (a0, a1) => (Module2["_sqlite3_result_subtype"] = wasmExports["sqlite3_result_subtype"])(a0, a1);
    Module2["_sqlite3_result_text"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_text"] = wasmExports["sqlite3_result_text"])(a0, a1, a2, a3);
    Module2["_sqlite3_result_zeroblob"] = (a0, a1) => (Module2["_sqlite3_result_zeroblob"] = wasmExports["sqlite3_result_zeroblob"])(a0, a1);
    Module2["_sqlite3_result_zeroblob64"] = (a0, a1) => (Module2["_sqlite3_result_zeroblob64"] = wasmExports["sqlite3_result_zeroblob64"])(a0, a1);
    Module2["_sqlite3_result_error_code"] = (a0, a1) => (Module2["_sqlite3_result_error_code"] = wasmExports["sqlite3_result_error_code"])(a0, a1);
    Module2["_sqlite3_user_data"] = (a0) => (Module2["_sqlite3_user_data"] = wasmExports["sqlite3_user_data"])(a0);
    Module2["_sqlite3_context_db_handle"] = (a0) => (Module2["_sqlite3_context_db_handle"] = wasmExports["sqlite3_context_db_handle"])(a0);
    Module2["_sqlite3_vtab_nochange"] = (a0) => (Module2["_sqlite3_vtab_nochange"] = wasmExports["sqlite3_vtab_nochange"])(a0);
    Module2["_sqlite3_vtab_in_first"] = (a0, a1) => (Module2["_sqlite3_vtab_in_first"] = wasmExports["sqlite3_vtab_in_first"])(a0, a1);
    Module2["_sqlite3_vtab_in_next"] = (a0, a1) => (Module2["_sqlite3_vtab_in_next"] = wasmExports["sqlite3_vtab_in_next"])(a0, a1);
    Module2["_sqlite3_aggregate_context"] = (a0, a1) => (Module2["_sqlite3_aggregate_context"] = wasmExports["sqlite3_aggregate_context"])(a0, a1);
    Module2["_sqlite3_get_auxdata"] = (a0, a1) => (Module2["_sqlite3_get_auxdata"] = wasmExports["sqlite3_get_auxdata"])(a0, a1);
    Module2["_sqlite3_set_auxdata"] = (a0, a1, a2, a3) => (Module2["_sqlite3_set_auxdata"] = wasmExports["sqlite3_set_auxdata"])(a0, a1, a2, a3);
    Module2["_sqlite3_column_count"] = (a0) => (Module2["_sqlite3_column_count"] = wasmExports["sqlite3_column_count"])(a0);
    Module2["_sqlite3_data_count"] = (a0) => (Module2["_sqlite3_data_count"] = wasmExports["sqlite3_data_count"])(a0);
    Module2["_sqlite3_column_blob"] = (a0, a1) => (Module2["_sqlite3_column_blob"] = wasmExports["sqlite3_column_blob"])(a0, a1);
    Module2["_sqlite3_column_bytes"] = (a0, a1) => (Module2["_sqlite3_column_bytes"] = wasmExports["sqlite3_column_bytes"])(a0, a1);
    Module2["_sqlite3_column_double"] = (a0, a1) => (Module2["_sqlite3_column_double"] = wasmExports["sqlite3_column_double"])(a0, a1);
    Module2["_sqlite3_column_value"] = (a0, a1) => (Module2["_sqlite3_column_value"] = wasmExports["sqlite3_column_value"])(a0, a1);
    Module2["_sqlite3_column_decltype"] = (a0, a1) => (Module2["_sqlite3_column_decltype"] = wasmExports["sqlite3_column_decltype"])(a0, a1);
    Module2["_sqlite3_bind_blob"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_bind_blob"] = wasmExports["sqlite3_bind_blob"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3_bind_double"] = (a0, a1, a2) => (Module2["_sqlite3_bind_double"] = wasmExports["sqlite3_bind_double"])(a0, a1, a2);
    Module2["_sqlite3_bind_int"] = (a0, a1, a2) => (Module2["_sqlite3_bind_int"] = wasmExports["sqlite3_bind_int"])(a0, a1, a2);
    Module2["_sqlite3_bind_int64"] = (a0, a1, a2) => (Module2["_sqlite3_bind_int64"] = wasmExports["sqlite3_bind_int64"])(a0, a1, a2);
    Module2["_sqlite3_bind_null"] = (a0, a1) => (Module2["_sqlite3_bind_null"] = wasmExports["sqlite3_bind_null"])(a0, a1);
    Module2["_sqlite3_bind_pointer"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_bind_pointer"] = wasmExports["sqlite3_bind_pointer"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3_bind_text"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_bind_text"] = wasmExports["sqlite3_bind_text"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3_bind_parameter_count"] = (a0) => (Module2["_sqlite3_bind_parameter_count"] = wasmExports["sqlite3_bind_parameter_count"])(a0);
    Module2["_sqlite3_bind_parameter_name"] = (a0, a1) => (Module2["_sqlite3_bind_parameter_name"] = wasmExports["sqlite3_bind_parameter_name"])(a0, a1);
    Module2["_sqlite3_bind_parameter_index"] = (a0, a1) => (Module2["_sqlite3_bind_parameter_index"] = wasmExports["sqlite3_bind_parameter_index"])(a0, a1);
    Module2["_sqlite3_db_handle"] = (a0) => (Module2["_sqlite3_db_handle"] = wasmExports["sqlite3_db_handle"])(a0);
    Module2["_sqlite3_stmt_readonly"] = (a0) => (Module2["_sqlite3_stmt_readonly"] = wasmExports["sqlite3_stmt_readonly"])(a0);
    Module2["_sqlite3_stmt_isexplain"] = (a0) => (Module2["_sqlite3_stmt_isexplain"] = wasmExports["sqlite3_stmt_isexplain"])(a0);
    Module2["_sqlite3_stmt_explain"] = (a0, a1) => (Module2["_sqlite3_stmt_explain"] = wasmExports["sqlite3_stmt_explain"])(a0, a1);
    Module2["_sqlite3_stmt_busy"] = (a0) => (Module2["_sqlite3_stmt_busy"] = wasmExports["sqlite3_stmt_busy"])(a0);
    Module2["_sqlite3_stmt_status"] = (a0, a1, a2) => (Module2["_sqlite3_stmt_status"] = wasmExports["sqlite3_stmt_status"])(a0, a1, a2);
    Module2["_sqlite3_sql"] = (a0) => (Module2["_sqlite3_sql"] = wasmExports["sqlite3_sql"])(a0);
    Module2["_sqlite3_expanded_sql"] = (a0) => (Module2["_sqlite3_expanded_sql"] = wasmExports["sqlite3_expanded_sql"])(a0);
    Module2["_sqlite3_preupdate_old"] = (a0, a1, a2) => (Module2["_sqlite3_preupdate_old"] = wasmExports["sqlite3_preupdate_old"])(a0, a1, a2);
    Module2["_sqlite3_preupdate_count"] = (a0) => (Module2["_sqlite3_preupdate_count"] = wasmExports["sqlite3_preupdate_count"])(a0);
    Module2["_sqlite3_preupdate_depth"] = (a0) => (Module2["_sqlite3_preupdate_depth"] = wasmExports["sqlite3_preupdate_depth"])(a0);
    Module2["_sqlite3_preupdate_blobwrite"] = (a0) => (Module2["_sqlite3_preupdate_blobwrite"] = wasmExports["sqlite3_preupdate_blobwrite"])(a0);
    Module2["_sqlite3_preupdate_new"] = (a0, a1, a2) => (Module2["_sqlite3_preupdate_new"] = wasmExports["sqlite3_preupdate_new"])(a0, a1, a2);
    Module2["_sqlite3_value_numeric_type"] = (a0) => (Module2["_sqlite3_value_numeric_type"] = wasmExports["sqlite3_value_numeric_type"])(a0);
    Module2["_sqlite3_set_authorizer"] = (a0, a1, a2) => (Module2["_sqlite3_set_authorizer"] = wasmExports["sqlite3_set_authorizer"])(a0, a1, a2);
    Module2["_sqlite3_strglob"] = (a0, a1) => (Module2["_sqlite3_strglob"] = wasmExports["sqlite3_strglob"])(a0, a1);
    Module2["_sqlite3_strlike"] = (a0, a1, a2) => (Module2["_sqlite3_strlike"] = wasmExports["sqlite3_strlike"])(a0, a1, a2);
    Module2["_sqlite3_auto_extension"] = (a0) => (Module2["_sqlite3_auto_extension"] = wasmExports["sqlite3_auto_extension"])(a0);
    Module2["_sqlite3_cancel_auto_extension"] = (a0) => (Module2["_sqlite3_cancel_auto_extension"] = wasmExports["sqlite3_cancel_auto_extension"])(a0);
    Module2["_sqlite3_reset_auto_extension"] = () => (Module2["_sqlite3_reset_auto_extension"] = wasmExports["sqlite3_reset_auto_extension"])();
    Module2["_sqlite3_prepare_v3"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_prepare_v3"] = wasmExports["sqlite3_prepare_v3"])(a0, a1, a2, a3, a4, a5);
    Module2["_sqlite3_create_module"] = (a0, a1, a2, a3) => (Module2["_sqlite3_create_module"] = wasmExports["sqlite3_create_module"])(a0, a1, a2, a3);
    Module2["_sqlite3_create_module_v2"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_create_module_v2"] = wasmExports["sqlite3_create_module_v2"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3_drop_modules"] = (a0, a1) => (Module2["_sqlite3_drop_modules"] = wasmExports["sqlite3_drop_modules"])(a0, a1);
    Module2["_sqlite3_declare_vtab"] = (a0, a1) => (Module2["_sqlite3_declare_vtab"] = wasmExports["sqlite3_declare_vtab"])(a0, a1);
    Module2["_sqlite3_vtab_on_conflict"] = (a0) => (Module2["_sqlite3_vtab_on_conflict"] = wasmExports["sqlite3_vtab_on_conflict"])(a0);
    Module2["_sqlite3_vtab_collation"] = (a0, a1) => (Module2["_sqlite3_vtab_collation"] = wasmExports["sqlite3_vtab_collation"])(a0, a1);
    Module2["_sqlite3_vtab_in"] = (a0, a1, a2) => (Module2["_sqlite3_vtab_in"] = wasmExports["sqlite3_vtab_in"])(a0, a1, a2);
    Module2["_sqlite3_vtab_rhs_value"] = (a0, a1, a2) => (Module2["_sqlite3_vtab_rhs_value"] = wasmExports["sqlite3_vtab_rhs_value"])(a0, a1, a2);
    Module2["_sqlite3_vtab_distinct"] = (a0) => (Module2["_sqlite3_vtab_distinct"] = wasmExports["sqlite3_vtab_distinct"])(a0);
    Module2["_sqlite3_keyword_name"] = (a0, a1, a2) => (Module2["_sqlite3_keyword_name"] = wasmExports["sqlite3_keyword_name"])(a0, a1, a2);
    Module2["_sqlite3_keyword_count"] = () => (Module2["_sqlite3_keyword_count"] = wasmExports["sqlite3_keyword_count"])();
    Module2["_sqlite3_keyword_check"] = (a0, a1) => (Module2["_sqlite3_keyword_check"] = wasmExports["sqlite3_keyword_check"])(a0, a1);
    Module2["_sqlite3_complete"] = (a0) => (Module2["_sqlite3_complete"] = wasmExports["sqlite3_complete"])(a0);
    Module2["_sqlite3_libversion"] = () => (Module2["_sqlite3_libversion"] = wasmExports["sqlite3_libversion"])();
    Module2["_sqlite3_libversion_number"] = () => (Module2["_sqlite3_libversion_number"] = wasmExports["sqlite3_libversion_number"])();
    Module2["_sqlite3_shutdown"] = () => (Module2["_sqlite3_shutdown"] = wasmExports["sqlite3_shutdown"])();
    Module2["_sqlite3_last_insert_rowid"] = (a0) => (Module2["_sqlite3_last_insert_rowid"] = wasmExports["sqlite3_last_insert_rowid"])(a0);
    Module2["_sqlite3_set_last_insert_rowid"] = (a0, a1) => (Module2["_sqlite3_set_last_insert_rowid"] = wasmExports["sqlite3_set_last_insert_rowid"])(a0, a1);
    Module2["_sqlite3_changes64"] = (a0) => (Module2["_sqlite3_changes64"] = wasmExports["sqlite3_changes64"])(a0);
    Module2["_sqlite3_changes"] = (a0) => (Module2["_sqlite3_changes"] = wasmExports["sqlite3_changes"])(a0);
    Module2["_sqlite3_total_changes64"] = (a0) => (Module2["_sqlite3_total_changes64"] = wasmExports["sqlite3_total_changes64"])(a0);
    Module2["_sqlite3_total_changes"] = (a0) => (Module2["_sqlite3_total_changes"] = wasmExports["sqlite3_total_changes"])(a0);
    Module2["_sqlite3_txn_state"] = (a0, a1) => (Module2["_sqlite3_txn_state"] = wasmExports["sqlite3_txn_state"])(a0, a1);
    Module2["_sqlite3_close_v2"] = (a0) => (Module2["_sqlite3_close_v2"] = wasmExports["sqlite3_close_v2"])(a0);
    Module2["_sqlite3_busy_handler"] = (a0, a1, a2) => (Module2["_sqlite3_busy_handler"] = wasmExports["sqlite3_busy_handler"])(a0, a1, a2);
    Module2["_sqlite3_progress_handler"] = (a0, a1, a2, a3) => (Module2["_sqlite3_progress_handler"] = wasmExports["sqlite3_progress_handler"])(a0, a1, a2, a3);
    Module2["_sqlite3_busy_timeout"] = (a0, a1) => (Module2["_sqlite3_busy_timeout"] = wasmExports["sqlite3_busy_timeout"])(a0, a1);
    Module2["_sqlite3_interrupt"] = (a0) => (Module2["_sqlite3_interrupt"] = wasmExports["sqlite3_interrupt"])(a0);
    Module2["_sqlite3_is_interrupted"] = (a0) => (Module2["_sqlite3_is_interrupted"] = wasmExports["sqlite3_is_interrupted"])(a0);
    Module2["_sqlite3_create_function"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (Module2["_sqlite3_create_function"] = wasmExports["sqlite3_create_function"])(
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7
    );
    Module2["_sqlite3_create_function_v2"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (Module2["_sqlite3_create_function_v2"] = wasmExports["sqlite3_create_function_v2"])(
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8
    );
    Module2["_sqlite3_create_window_function"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (Module2["_sqlite3_create_window_function"] = wasmExports["sqlite3_create_window_function"])(
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9
    );
    Module2["_sqlite3_overload_function"] = (a0, a1, a2) => (Module2["_sqlite3_overload_function"] = wasmExports["sqlite3_overload_function"])(a0, a1, a2);
    Module2["_sqlite3_trace_v2"] = (a0, a1, a2, a3) => (Module2["_sqlite3_trace_v2"] = wasmExports["sqlite3_trace_v2"])(a0, a1, a2, a3);
    Module2["_sqlite3_commit_hook"] = (a0, a1, a2) => (Module2["_sqlite3_commit_hook"] = wasmExports["sqlite3_commit_hook"])(a0, a1, a2);
    Module2["_sqlite3_update_hook"] = (a0, a1, a2) => (Module2["_sqlite3_update_hook"] = wasmExports["sqlite3_update_hook"])(a0, a1, a2);
    Module2["_sqlite3_rollback_hook"] = (a0, a1, a2) => (Module2["_sqlite3_rollback_hook"] = wasmExports["sqlite3_rollback_hook"])(a0, a1, a2);
    Module2["_sqlite3_preupdate_hook"] = (a0, a1, a2) => (Module2["_sqlite3_preupdate_hook"] = wasmExports["sqlite3_preupdate_hook"])(a0, a1, a2);
    Module2["_sqlite3_error_offset"] = (a0) => (Module2["_sqlite3_error_offset"] = wasmExports["sqlite3_error_offset"])(a0);
    Module2["_sqlite3_errcode"] = (a0) => (Module2["_sqlite3_errcode"] = wasmExports["sqlite3_errcode"])(a0);
    Module2["_sqlite3_extended_errcode"] = (a0) => (Module2["_sqlite3_extended_errcode"] = wasmExports["sqlite3_extended_errcode"])(a0);
    Module2["_sqlite3_errstr"] = (a0) => (Module2["_sqlite3_errstr"] = wasmExports["sqlite3_errstr"])(a0);
    Module2["_sqlite3_limit"] = (a0, a1, a2) => (Module2["_sqlite3_limit"] = wasmExports["sqlite3_limit"])(a0, a1, a2);
    Module2["_sqlite3_open"] = (a0, a1) => (Module2["_sqlite3_open"] = wasmExports["sqlite3_open"])(
      a0,
      a1
    );
    Module2["_sqlite3_open_v2"] = (a0, a1, a2, a3) => (Module2["_sqlite3_open_v2"] = wasmExports["sqlite3_open_v2"])(a0, a1, a2, a3);
    Module2["_sqlite3_create_collation"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_create_collation"] = wasmExports["sqlite3_create_collation"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3_create_collation_v2"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_create_collation_v2"] = wasmExports["sqlite3_create_collation_v2"])(a0, a1, a2, a3, a4, a5);
    Module2["_sqlite3_collation_needed"] = (a0, a1, a2) => (Module2["_sqlite3_collation_needed"] = wasmExports["sqlite3_collation_needed"])(a0, a1, a2);
    Module2["_sqlite3_get_autocommit"] = (a0) => (Module2["_sqlite3_get_autocommit"] = wasmExports["sqlite3_get_autocommit"])(a0);
    Module2["_sqlite3_table_column_metadata"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (Module2["_sqlite3_table_column_metadata"] = wasmExports["sqlite3_table_column_metadata"])(
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8
    );
    Module2["_sqlite3_extended_result_codes"] = (a0, a1) => (Module2["_sqlite3_extended_result_codes"] = wasmExports["sqlite3_extended_result_codes"])(a0, a1);
    Module2["_sqlite3_uri_key"] = (a0, a1) => (Module2["_sqlite3_uri_key"] = wasmExports["sqlite3_uri_key"])(a0, a1);
    Module2["_sqlite3_uri_int64"] = (a0, a1, a2) => (Module2["_sqlite3_uri_int64"] = wasmExports["sqlite3_uri_int64"])(a0, a1, a2);
    Module2["_sqlite3_db_name"] = (a0, a1) => (Module2["_sqlite3_db_name"] = wasmExports["sqlite3_db_name"])(a0, a1);
    Module2["_sqlite3_db_filename"] = (a0, a1) => (Module2["_sqlite3_db_filename"] = wasmExports["sqlite3_db_filename"])(a0, a1);
    Module2["_sqlite3_db_readonly"] = (a0, a1) => (Module2["_sqlite3_db_readonly"] = wasmExports["sqlite3_db_readonly"])(a0, a1);
    Module2["_sqlite3_compileoption_used"] = (a0) => (Module2["_sqlite3_compileoption_used"] = wasmExports["sqlite3_compileoption_used"])(a0);
    Module2["_sqlite3_compileoption_get"] = (a0) => (Module2["_sqlite3_compileoption_get"] = wasmExports["sqlite3_compileoption_get"])(a0);
    Module2["_sqlite3session_diff"] = (a0, a1, a2, a3) => (Module2["_sqlite3session_diff"] = wasmExports["sqlite3session_diff"])(a0, a1, a2, a3);
    Module2["_sqlite3session_attach"] = (a0, a1) => (Module2["_sqlite3session_attach"] = wasmExports["sqlite3session_attach"])(a0, a1);
    Module2["_sqlite3session_create"] = (a0, a1, a2) => (Module2["_sqlite3session_create"] = wasmExports["sqlite3session_create"])(a0, a1, a2);
    Module2["_sqlite3session_delete"] = (a0) => (Module2["_sqlite3session_delete"] = wasmExports["sqlite3session_delete"])(a0);
    Module2["_sqlite3session_table_filter"] = (a0, a1, a2) => (Module2["_sqlite3session_table_filter"] = wasmExports["sqlite3session_table_filter"])(a0, a1, a2);
    Module2["_sqlite3session_changeset"] = (a0, a1, a2) => (Module2["_sqlite3session_changeset"] = wasmExports["sqlite3session_changeset"])(a0, a1, a2);
    Module2["_sqlite3session_changeset_strm"] = (a0, a1, a2) => (Module2["_sqlite3session_changeset_strm"] = wasmExports["sqlite3session_changeset_strm"])(a0, a1, a2);
    Module2["_sqlite3session_patchset_strm"] = (a0, a1, a2) => (Module2["_sqlite3session_patchset_strm"] = wasmExports["sqlite3session_patchset_strm"])(a0, a1, a2);
    Module2["_sqlite3session_patchset"] = (a0, a1, a2) => (Module2["_sqlite3session_patchset"] = wasmExports["sqlite3session_patchset"])(a0, a1, a2);
    Module2["_sqlite3session_enable"] = (a0, a1) => (Module2["_sqlite3session_enable"] = wasmExports["sqlite3session_enable"])(a0, a1);
    Module2["_sqlite3session_indirect"] = (a0, a1) => (Module2["_sqlite3session_indirect"] = wasmExports["sqlite3session_indirect"])(a0, a1);
    Module2["_sqlite3session_isempty"] = (a0) => (Module2["_sqlite3session_isempty"] = wasmExports["sqlite3session_isempty"])(a0);
    Module2["_sqlite3session_memory_used"] = (a0) => (Module2["_sqlite3session_memory_used"] = wasmExports["sqlite3session_memory_used"])(a0);
    Module2["_sqlite3session_object_config"] = (a0, a1, a2) => (Module2["_sqlite3session_object_config"] = wasmExports["sqlite3session_object_config"])(a0, a1, a2);
    Module2["_sqlite3session_changeset_size"] = (a0) => (Module2["_sqlite3session_changeset_size"] = wasmExports["sqlite3session_changeset_size"])(a0);
    Module2["_sqlite3changeset_start"] = (a0, a1, a2) => (Module2["_sqlite3changeset_start"] = wasmExports["sqlite3changeset_start"])(a0, a1, a2);
    Module2["_sqlite3changeset_start_v2"] = (a0, a1, a2, a3) => (Module2["_sqlite3changeset_start_v2"] = wasmExports["sqlite3changeset_start_v2"])(a0, a1, a2, a3);
    Module2["_sqlite3changeset_start_strm"] = (a0, a1, a2) => (Module2["_sqlite3changeset_start_strm"] = wasmExports["sqlite3changeset_start_strm"])(a0, a1, a2);
    Module2["_sqlite3changeset_start_v2_strm"] = (a0, a1, a2, a3) => (Module2["_sqlite3changeset_start_v2_strm"] = wasmExports["sqlite3changeset_start_v2_strm"])(a0, a1, a2, a3);
    Module2["_sqlite3changeset_next"] = (a0) => (Module2["_sqlite3changeset_next"] = wasmExports["sqlite3changeset_next"])(a0);
    Module2["_sqlite3changeset_op"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3changeset_op"] = wasmExports["sqlite3changeset_op"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3changeset_pk"] = (a0, a1, a2) => (Module2["_sqlite3changeset_pk"] = wasmExports["sqlite3changeset_pk"])(a0, a1, a2);
    Module2["_sqlite3changeset_old"] = (a0, a1, a2) => (Module2["_sqlite3changeset_old"] = wasmExports["sqlite3changeset_old"])(a0, a1, a2);
    Module2["_sqlite3changeset_new"] = (a0, a1, a2) => (Module2["_sqlite3changeset_new"] = wasmExports["sqlite3changeset_new"])(a0, a1, a2);
    Module2["_sqlite3changeset_conflict"] = (a0, a1, a2) => (Module2["_sqlite3changeset_conflict"] = wasmExports["sqlite3changeset_conflict"])(a0, a1, a2);
    Module2["_sqlite3changeset_fk_conflicts"] = (a0, a1) => (Module2["_sqlite3changeset_fk_conflicts"] = wasmExports["sqlite3changeset_fk_conflicts"])(a0, a1);
    Module2["_sqlite3changeset_finalize"] = (a0) => (Module2["_sqlite3changeset_finalize"] = wasmExports["sqlite3changeset_finalize"])(a0);
    Module2["_sqlite3changeset_invert"] = (a0, a1, a2, a3) => (Module2["_sqlite3changeset_invert"] = wasmExports["sqlite3changeset_invert"])(a0, a1, a2, a3);
    Module2["_sqlite3changeset_invert_strm"] = (a0, a1, a2, a3) => (Module2["_sqlite3changeset_invert_strm"] = wasmExports["sqlite3changeset_invert_strm"])(a0, a1, a2, a3);
    Module2["_sqlite3changeset_apply_v2"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (Module2["_sqlite3changeset_apply_v2"] = wasmExports["sqlite3changeset_apply_v2"])(
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8
    );
    Module2["_sqlite3changeset_apply"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3changeset_apply"] = wasmExports["sqlite3changeset_apply"])(a0, a1, a2, a3, a4, a5);
    Module2["_sqlite3changeset_apply_v2_strm"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (Module2["_sqlite3changeset_apply_v2_strm"] = wasmExports["sqlite3changeset_apply_v2_strm"])(
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8
    );
    Module2["_sqlite3changeset_apply_strm"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3changeset_apply_strm"] = wasmExports["sqlite3changeset_apply_strm"])(a0, a1, a2, a3, a4, a5);
    Module2["_sqlite3changegroup_new"] = (a0) => (Module2["_sqlite3changegroup_new"] = wasmExports["sqlite3changegroup_new"])(a0);
    Module2["_sqlite3changegroup_add"] = (a0, a1, a2) => (Module2["_sqlite3changegroup_add"] = wasmExports["sqlite3changegroup_add"])(a0, a1, a2);
    Module2["_sqlite3changegroup_output"] = (a0, a1, a2) => (Module2["_sqlite3changegroup_output"] = wasmExports["sqlite3changegroup_output"])(a0, a1, a2);
    Module2["_sqlite3changegroup_add_strm"] = (a0, a1, a2) => (Module2["_sqlite3changegroup_add_strm"] = wasmExports["sqlite3changegroup_add_strm"])(a0, a1, a2);
    Module2["_sqlite3changegroup_output_strm"] = (a0, a1, a2) => (Module2["_sqlite3changegroup_output_strm"] = wasmExports["sqlite3changegroup_output_strm"])(a0, a1, a2);
    Module2["_sqlite3changegroup_delete"] = (a0) => (Module2["_sqlite3changegroup_delete"] = wasmExports["sqlite3changegroup_delete"])(a0);
    Module2["_sqlite3changeset_concat"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3changeset_concat"] = wasmExports["sqlite3changeset_concat"])(a0, a1, a2, a3, a4, a5);
    Module2["_sqlite3changeset_concat_strm"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3changeset_concat_strm"] = wasmExports["sqlite3changeset_concat_strm"])(a0, a1, a2, a3, a4, a5);
    Module2["_sqlite3session_config"] = (a0, a1) => (Module2["_sqlite3session_config"] = wasmExports["sqlite3session_config"])(a0, a1);
    Module2["_sqlite3_sourceid"] = () => (Module2["_sqlite3_sourceid"] = wasmExports["sqlite3_sourceid"])();
    Module2["_sqlite3__wasm_pstack_ptr"] = () => (Module2["_sqlite3__wasm_pstack_ptr"] = wasmExports["sqlite3__wasm_pstack_ptr"])();
    Module2["_sqlite3__wasm_pstack_restore"] = (a0) => (Module2["_sqlite3__wasm_pstack_restore"] = wasmExports["sqlite3__wasm_pstack_restore"])(a0);
    Module2["_sqlite3__wasm_pstack_alloc"] = (a0) => (Module2["_sqlite3__wasm_pstack_alloc"] = wasmExports["sqlite3__wasm_pstack_alloc"])(a0);
    Module2["_sqlite3__wasm_pstack_remaining"] = () => (Module2["_sqlite3__wasm_pstack_remaining"] = wasmExports["sqlite3__wasm_pstack_remaining"])();
    Module2["_sqlite3__wasm_pstack_quota"] = () => (Module2["_sqlite3__wasm_pstack_quota"] = wasmExports["sqlite3__wasm_pstack_quota"])();
    Module2["_sqlite3__wasm_db_error"] = (a0, a1, a2) => (Module2["_sqlite3__wasm_db_error"] = wasmExports["sqlite3__wasm_db_error"])(a0, a1, a2);
    Module2["_sqlite3__wasm_test_struct"] = (a0) => (Module2["_sqlite3__wasm_test_struct"] = wasmExports["sqlite3__wasm_test_struct"])(a0);
    Module2["_sqlite3__wasm_enum_json"] = () => (Module2["_sqlite3__wasm_enum_json"] = wasmExports["sqlite3__wasm_enum_json"])();
    Module2["_sqlite3__wasm_vfs_unlink"] = (a0, a1) => (Module2["_sqlite3__wasm_vfs_unlink"] = wasmExports["sqlite3__wasm_vfs_unlink"])(a0, a1);
    Module2["_sqlite3__wasm_db_vfs"] = (a0, a1) => (Module2["_sqlite3__wasm_db_vfs"] = wasmExports["sqlite3__wasm_db_vfs"])(a0, a1);
    Module2["_sqlite3__wasm_db_reset"] = (a0) => (Module2["_sqlite3__wasm_db_reset"] = wasmExports["sqlite3__wasm_db_reset"])(a0);
    Module2["_sqlite3__wasm_db_export_chunked"] = (a0, a1) => (Module2["_sqlite3__wasm_db_export_chunked"] = wasmExports["sqlite3__wasm_db_export_chunked"])(a0, a1);
    Module2["_sqlite3__wasm_db_serialize"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3__wasm_db_serialize"] = wasmExports["sqlite3__wasm_db_serialize"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3__wasm_vfs_create_file"] = (a0, a1, a2, a3) => (Module2["_sqlite3__wasm_vfs_create_file"] = wasmExports["sqlite3__wasm_vfs_create_file"])(a0, a1, a2, a3);
    Module2["_sqlite3__wasm_posix_create_file"] = (a0, a1, a2) => (Module2["_sqlite3__wasm_posix_create_file"] = wasmExports["sqlite3__wasm_posix_create_file"])(a0, a1, a2);
    Module2["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = (a0, a1) => (Module2["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = wasmExports["sqlite3__wasm_kvvfsMakeKeyOnPstack"])(a0, a1);
    Module2["_sqlite3__wasm_kvvfs_methods"] = () => (Module2["_sqlite3__wasm_kvvfs_methods"] = wasmExports["sqlite3__wasm_kvvfs_methods"])();
    Module2["_sqlite3__wasm_vtab_config"] = (a0, a1, a2) => (Module2["_sqlite3__wasm_vtab_config"] = wasmExports["sqlite3__wasm_vtab_config"])(a0, a1, a2);
    Module2["_sqlite3__wasm_db_config_ip"] = (a0, a1, a2, a3) => (Module2["_sqlite3__wasm_db_config_ip"] = wasmExports["sqlite3__wasm_db_config_ip"])(a0, a1, a2, a3);
    Module2["_sqlite3__wasm_db_config_pii"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3__wasm_db_config_pii"] = wasmExports["sqlite3__wasm_db_config_pii"])(a0, a1, a2, a3, a4);
    Module2["_sqlite3__wasm_db_config_s"] = (a0, a1, a2) => (Module2["_sqlite3__wasm_db_config_s"] = wasmExports["sqlite3__wasm_db_config_s"])(a0, a1, a2);
    Module2["_sqlite3__wasm_config_i"] = (a0, a1) => (Module2["_sqlite3__wasm_config_i"] = wasmExports["sqlite3__wasm_config_i"])(a0, a1);
    Module2["_sqlite3__wasm_config_ii"] = (a0, a1, a2) => (Module2["_sqlite3__wasm_config_ii"] = wasmExports["sqlite3__wasm_config_ii"])(a0, a1, a2);
    Module2["_sqlite3__wasm_config_j"] = (a0, a1) => (Module2["_sqlite3__wasm_config_j"] = wasmExports["sqlite3__wasm_config_j"])(a0, a1);
    Module2["_sqlite3__wasm_qfmt_token"] = (a0, a1) => (Module2["_sqlite3__wasm_qfmt_token"] = wasmExports["sqlite3__wasm_qfmt_token"])(a0, a1);
    Module2["_sqlite3__wasm_init_wasmfs"] = (a0) => (Module2["_sqlite3__wasm_init_wasmfs"] = wasmExports["sqlite3__wasm_init_wasmfs"])(a0);
    Module2["_sqlite3__wasm_test_intptr"] = (a0) => (Module2["_sqlite3__wasm_test_intptr"] = wasmExports["sqlite3__wasm_test_intptr"])(a0);
    Module2["_sqlite3__wasm_test_voidptr"] = (a0) => (Module2["_sqlite3__wasm_test_voidptr"] = wasmExports["sqlite3__wasm_test_voidptr"])(a0);
    Module2["_sqlite3__wasm_test_int64_max"] = () => (Module2["_sqlite3__wasm_test_int64_max"] = wasmExports["sqlite3__wasm_test_int64_max"])();
    Module2["_sqlite3__wasm_test_int64_min"] = () => (Module2["_sqlite3__wasm_test_int64_min"] = wasmExports["sqlite3__wasm_test_int64_min"])();
    Module2["_sqlite3__wasm_test_int64_times2"] = (a0) => (Module2["_sqlite3__wasm_test_int64_times2"] = wasmExports["sqlite3__wasm_test_int64_times2"])(a0);
    Module2["_sqlite3__wasm_test_int64_minmax"] = (a0, a1) => (Module2["_sqlite3__wasm_test_int64_minmax"] = wasmExports["sqlite3__wasm_test_int64_minmax"])(a0, a1);
    Module2["_sqlite3__wasm_test_int64ptr"] = (a0) => (Module2["_sqlite3__wasm_test_int64ptr"] = wasmExports["sqlite3__wasm_test_int64ptr"])(a0);
    Module2["_sqlite3__wasm_test_stack_overflow"] = (a0) => (Module2["_sqlite3__wasm_test_stack_overflow"] = wasmExports["sqlite3__wasm_test_stack_overflow"])(a0);
    Module2["_sqlite3__wasm_test_str_hello"] = (a0) => (Module2["_sqlite3__wasm_test_str_hello"] = wasmExports["sqlite3__wasm_test_str_hello"])(a0);
    Module2["_sqlite3__wasm_SQLTester_strglob"] = (a0, a1) => (Module2["_sqlite3__wasm_SQLTester_strglob"] = wasmExports["sqlite3__wasm_SQLTester_strglob"])(a0, a1);
    Module2["_malloc"] = (a0) => (Module2["_malloc"] = wasmExports["malloc"])(a0);
    Module2["_free"] = (a0) => (Module2["_free"] = wasmExports["free"])(a0);
    Module2["_realloc"] = (a0, a1) => (Module2["_realloc"] = wasmExports["realloc"])(a0, a1);
    var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["emscripten_builtin_memalign"])(a0, a1);
    Module2["wasmMemory"] = wasmMemory;
    var calledRun;
    var calledPrerun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun) run();
      if (!calledRun) dependenciesFulfilled = runCaller;
    };
    function run() {
      if (runDependencies > 0) {
        return;
      }
      if (!calledPrerun) {
        calledPrerun = 1;
        preRun();
        if (runDependencies > 0) {
          return;
        }
      }
      function doRun() {
        var _a;
        if (calledRun) return;
        calledRun = 1;
        Module2["calledRun"] = 1;
        if (ABORT) return;
        initRuntime();
        readyPromiseResolve(Module2);
        (_a = Module2["onRuntimeInitialized"]) == null ? void 0 : _a.call(Module2);
        postRun();
      }
      if (Module2["setStatus"]) {
        Module2["setStatus"]("Running...");
        setTimeout(() => {
          setTimeout(() => Module2["setStatus"](""), 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    if (Module2["preInit"]) {
      if (typeof Module2["preInit"] == "function")
        Module2["preInit"] = [Module2["preInit"]];
      while (Module2["preInit"].length > 0) {
        Module2["preInit"].pop()();
      }
    }
    run();
    if (!Module2.postRun) Module2.postRun = [];
    Module2.postRun.push(function(Module3) {
      globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(apiConfig = globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig) {
        if (sqlite3ApiBootstrap.sqlite3) {
          (sqlite3ApiBootstrap.sqlite3.config || console).warn(
            "sqlite3ApiBootstrap() called multiple times.",
            "Config and external initializers are ignored on calls after the first."
          );
          return sqlite3ApiBootstrap.sqlite3;
        }
        const config = Object.assign(
          /* @__PURE__ */ Object.create(null),
          {
            exports: void 0,
            memory: void 0,
            bigIntEnabled: (() => {
              if ("undefined" !== typeof Module3) {
                if (!!Module3.HEAPU64) return true;
              }
              return !!globalThis.BigInt64Array;
            })(),
            debug: console.debug.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console),
            log: console.log.bind(console),
            wasmfsOpfsDir: "/opfs",
            useStdAlloc: false
          },
          apiConfig || {}
        );
        Object.assign(
          config,
          {
            allocExportName: config.useStdAlloc ? "malloc" : "sqlite3_malloc",
            deallocExportName: config.useStdAlloc ? "free" : "sqlite3_free",
            reallocExportName: config.useStdAlloc ? "realloc" : "sqlite3_realloc"
          },
          config
        );
        ["exports", "memory", "wasmfsOpfsDir"].forEach((k) => {
          if ("function" === typeof config[k]) {
            config[k] = config[k]();
          }
        });
        delete globalThis.sqlite3ApiConfig;
        delete sqlite3ApiBootstrap.defaultConfig;
        const capi = /* @__PURE__ */ Object.create(null);
        const wasm = /* @__PURE__ */ Object.create(null);
        const __rcStr = (rc) => {
          return capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc) || "Unknown result code #" + rc;
        };
        const __isInt = (n) => "number" === typeof n && n === (n | 0);
        class SQLite3Error extends Error {
          constructor(...args) {
            let rc;
            if (args.length) {
              if (__isInt(args[0])) {
                rc = args[0];
                if (1 === args.length) {
                  super(__rcStr(args[0]));
                } else {
                  const rcStr = __rcStr(rc);
                  if ("object" === typeof args[1]) {
                    super(rcStr, args[1]);
                  } else {
                    args[0] = rcStr + ":";
                    super(args.join(" "));
                  }
                }
              } else {
                if (2 === args.length && "object" === typeof args[1]) {
                  super(...args);
                } else {
                  super(args.join(" "));
                }
              }
            }
            this.resultCode = rc || capi.SQLITE_ERROR;
            this.name = "SQLite3Error";
          }
        }
        SQLite3Error.toss = (...args) => {
          throw new SQLite3Error(...args);
        };
        const toss3 = SQLite3Error.toss;
        if (config.wasmfsOpfsDir && !/^\/[^/]+$/.test(config.wasmfsOpfsDir)) {
          toss3(
            "config.wasmfsOpfsDir must be falsy or in the form '/dir-name'."
          );
        }
        const isInt32 = (n) => {
          return "bigint" !== typeof n && !!(n === (n | 0) && n <= 2147483647 && n >= -2147483648);
        };
        const bigIntFits64 = function f(b) {
          if (!f._max) {
            f._max = BigInt("0x7fffffffffffffff");
            f._min = ~f._max;
          }
          return b >= f._min && b <= f._max;
        };
        const bigIntFits32 = (b) => b >= -/* @__PURE__ */ BigInt("0x7fffffff") - /* @__PURE__ */ BigInt("1") && b <= /* @__PURE__ */ BigInt("0x7fffffff");
        const bigIntFitsDouble = function f(b) {
          if (!f._min) {
            f._min = Number.MIN_SAFE_INTEGER;
            f._max = Number.MAX_SAFE_INTEGER;
          }
          return b >= f._min && b <= f._max;
        };
        const isTypedArray = (v2) => {
          return v2 && v2.constructor && isInt32(v2.constructor.BYTES_PER_ELEMENT) ? v2 : false;
        };
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const isSharedTypedArray = (aTypedArray) => aTypedArray.buffer instanceof __SAB;
        const typedArrayPart = (aTypedArray, begin, end) => {
          return isSharedTypedArray(aTypedArray) ? aTypedArray.slice(begin, end) : aTypedArray.subarray(begin, end);
        };
        const isBindableTypedArray = (v2) => {
          return v2 && (v2 instanceof Uint8Array || v2 instanceof Int8Array || v2 instanceof ArrayBuffer);
        };
        const isSQLableTypedArray = (v2) => {
          return v2 && (v2 instanceof Uint8Array || v2 instanceof Int8Array || v2 instanceof ArrayBuffer);
        };
        const affirmBindableTypedArray = (v2) => {
          return isBindableTypedArray(v2) || toss3("Value is not of a supported TypedArray type.");
        };
        const utf8Decoder = new TextDecoder("utf-8");
        const typedArrayToString = function(typedArray, begin, end) {
          return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));
        };
        const flexibleString = function(v2) {
          if (isSQLableTypedArray(v2)) {
            return typedArrayToString(
              v2 instanceof ArrayBuffer ? new Uint8Array(v2) : v2
            );
          } else if (Array.isArray(v2)) return v2.join("");
          else if (wasm.isPtr(v2)) v2 = wasm.cstrToJs(v2);
          return v2;
        };
        class WasmAllocError extends Error {
          constructor(...args) {
            if (2 === args.length && "object" === typeof args[1]) {
              super(...args);
            } else if (args.length) {
              super(args.join(" "));
            } else {
              super("Allocation failed.");
            }
            this.resultCode = capi.SQLITE_NOMEM;
            this.name = "WasmAllocError";
          }
        }
        WasmAllocError.toss = (...args) => {
          throw new WasmAllocError(...args);
        };
        Object.assign(capi, {
          sqlite3_bind_blob: void 0,
          sqlite3_bind_text: void 0,
          sqlite3_create_function_v2: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) => {
          },
          sqlite3_create_function: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) => {
          },
          sqlite3_create_window_function: (pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) => {
          },
          sqlite3_prepare_v3: (dbPtr, sql2, sqlByteLen, prepFlags, stmtPtrPtr, strPtrPtr) => {
          },
          sqlite3_prepare_v2: (dbPtr, sql2, sqlByteLen, stmtPtrPtr, strPtrPtr) => {
          },
          sqlite3_exec: (pDb2, sql2, callback, pVoid, pErrMsg) => {
          },
          sqlite3_randomness: (n, outPtr) => {
          }
        });
        const util = {
          affirmBindableTypedArray,
          flexibleString,
          bigIntFits32,
          bigIntFits64,
          bigIntFitsDouble,
          isBindableTypedArray,
          isInt32,
          isSQLableTypedArray,
          isTypedArray,
          typedArrayToString,
          isUIThread: () => globalThis.window === globalThis && !!globalThis.document,
          isSharedTypedArray,
          toss: function(...args) {
            throw new Error(args.join(" "));
          },
          toss3,
          typedArrayPart,
          affirmDbHeader: function(bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            const header = "SQLite format 3";
            if (header.length > bytes.byteLength) {
              toss3("Input does not contain an SQLite3 database header.");
            }
            for (let i = 0; i < header.length; ++i) {
              if (header.charCodeAt(i) !== bytes[i]) {
                toss3("Input does not contain an SQLite3 database header.");
              }
            }
          },
          affirmIsDb: function(bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            const n = bytes.byteLength;
            if (n < 512 || n % 512 !== 0) {
              toss3("Byte array size", n, "is invalid for an SQLite3 db.");
            }
            util.affirmDbHeader(bytes);
          }
        };
        Object.assign(wasm, {
          ptrSizeof: config.wasmPtrSizeof || 4,
          ptrIR: config.wasmPtrIR || "i32",
          bigIntEnabled: !!config.bigIntEnabled,
          exports: config.exports || toss3("Missing API config.exports (WASM module exports)."),
          memory: config.memory || config.exports["memory"] || toss3(
            "API config object requires a WebAssembly.Memory object",
            "in either config.exports.memory (exported)",
            "or config.memory (imported)."
          ),
          alloc: void 0,
          realloc: void 0,
          dealloc: void 0
        });
        wasm.allocFromTypedArray = function(srcTypedArray) {
          if (srcTypedArray instanceof ArrayBuffer) {
            srcTypedArray = new Uint8Array(srcTypedArray);
          }
          affirmBindableTypedArray(srcTypedArray);
          const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
          wasm.heapForSize(srcTypedArray.constructor).set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);
          return pRet;
        };
        {
          const keyAlloc = config.allocExportName, keyDealloc = config.deallocExportName, keyRealloc = config.reallocExportName;
          for (const key of [keyAlloc, keyDealloc, keyRealloc]) {
            const f = wasm.exports[key];
            if (!(f instanceof Function))
              toss3("Missing required exports[", key, "] function.");
          }
          wasm.alloc = function f(n) {
            return f.impl(n) || WasmAllocError.toss("Failed to allocate", n, " bytes.");
          };
          wasm.alloc.impl = wasm.exports[keyAlloc];
          wasm.realloc = function f(m, n) {
            const m2 = f.impl(m, n);
            return n ? m2 || WasmAllocError.toss("Failed to reallocate", n, " bytes.") : 0;
          };
          wasm.realloc.impl = wasm.exports[keyRealloc];
          wasm.dealloc = wasm.exports[keyDealloc];
        }
        wasm.compileOptionUsed = function f(optName) {
          if (!arguments.length) {
            if (f._result) return f._result;
            else if (!f._opt) {
              f._rx = /^([^=]+)=(.+)/;
              f._rxInt = /^-?\d+$/;
              f._opt = function(opt, rv) {
                const m = f._rx.exec(opt);
                rv[0] = m ? m[1] : opt;
                rv[1] = m ? f._rxInt.test(m[2]) ? +m[2] : m[2] : true;
              };
            }
            const rc = {}, ov = [0, 0];
            let i = 0, k;
            while (k = capi.sqlite3_compileoption_get(i++)) {
              f._opt(k, ov);
              rc[ov[0]] = ov[1];
            }
            return f._result = rc;
          } else if (Array.isArray(optName)) {
            const rc = {};
            optName.forEach((v2) => {
              rc[v2] = capi.sqlite3_compileoption_used(v2);
            });
            return rc;
          } else if ("object" === typeof optName) {
            Object.keys(optName).forEach((k) => {
              optName[k] = capi.sqlite3_compileoption_used(k);
            });
            return optName;
          }
          return "string" === typeof optName ? !!capi.sqlite3_compileoption_used(optName) : false;
        };
        wasm.pstack = Object.assign(/* @__PURE__ */ Object.create(null), {
          restore: wasm.exports.sqlite3__wasm_pstack_restore,
          alloc: function(n) {
            if ("string" === typeof n && !(n = wasm.sizeofIR(n))) {
              WasmAllocError.toss(
                "Invalid value for pstack.alloc(",
                arguments[0],
                ")"
              );
            }
            return wasm.exports.sqlite3__wasm_pstack_alloc(n) || WasmAllocError.toss(
              "Could not allocate",
              n,
              "bytes from the pstack."
            );
          },
          allocChunks: function(n, sz) {
            if ("string" === typeof sz && !(sz = wasm.sizeofIR(sz))) {
              WasmAllocError.toss(
                "Invalid size value for allocChunks(",
                arguments[1],
                ")"
              );
            }
            const mem = wasm.pstack.alloc(n * sz);
            const rc = [];
            let i = 0, offset = 0;
            for (; i < n; ++i, offset += sz) rc.push(mem + offset);
            return rc;
          },
          allocPtr: (n = 1, safePtrSize = true) => {
            return 1 === n ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof) : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);
          },
          call: function(f) {
            const stackPos = wasm.pstack.pointer;
            try {
              return f(sqlite32);
            } finally {
              wasm.pstack.restore(stackPos);
            }
          }
        });
        Object.defineProperties(wasm.pstack, {
          pointer: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_ptr
          },
          quota: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_quota
          },
          remaining: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_remaining
          }
        });
        capi.sqlite3_randomness = (...args) => {
          if (1 === args.length && util.isTypedArray(args[0]) && 1 === args[0].BYTES_PER_ELEMENT) {
            const ta = args[0];
            if (0 === ta.byteLength) {
              wasm.exports.sqlite3_randomness(0, 0);
              return ta;
            }
            const stack = wasm.pstack.pointer;
            try {
              let n = ta.byteLength, offset = 0;
              const r = wasm.exports.sqlite3_randomness;
              const heap = wasm.heap8u();
              const nAlloc = n < 512 ? n : 512;
              const ptr = wasm.pstack.alloc(nAlloc);
              do {
                const j = n > nAlloc ? nAlloc : n;
                r(j, ptr);
                ta.set(typedArrayPart(heap, ptr, ptr + j), offset);
                n -= j;
                offset += j;
              } while (n > 0);
            } catch (e) {
              console.error(
                "Highly unexpected (and ignored!) exception in sqlite3_randomness():",
                e
              );
            } finally {
              wasm.pstack.restore(stack);
            }
            return ta;
          }
          wasm.exports.sqlite3_randomness(...args);
        };
        let __wasmfsOpfsDir = void 0;
        capi.sqlite3_wasmfs_opfs_dir = function() {
          if (void 0 !== __wasmfsOpfsDir) return __wasmfsOpfsDir;
          const pdir = config.wasmfsOpfsDir;
          if (!pdir || !globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle) {
            return __wasmfsOpfsDir = "";
          }
          try {
            if (pdir && 0 === wasm.xCallWrapped(
              "sqlite3__wasm_init_wasmfs",
              "i32",
              ["string"],
              pdir
            )) {
              return __wasmfsOpfsDir = pdir;
            } else {
              return __wasmfsOpfsDir = "";
            }
          } catch (e) {
            return __wasmfsOpfsDir = "";
          }
        };
        capi.sqlite3_wasmfs_filename_is_persistent = function(name) {
          const p = capi.sqlite3_wasmfs_opfs_dir();
          return p && name ? name.startsWith(p + "/") : false;
        };
        capi.sqlite3_js_db_uses_vfs = function(pDb2, vfsName, dbName = 0) {
          try {
            const pK = capi.sqlite3_vfs_find(vfsName);
            if (!pK) return false;
            else if (!pDb2) {
              return pK === capi.sqlite3_vfs_find(0) ? pK : false;
            } else {
              return pK === capi.sqlite3_js_db_vfs(pDb2, dbName) ? pK : false;
            }
          } catch (e) {
            return false;
          }
        };
        capi.sqlite3_js_vfs_list = function() {
          const rc = [];
          let pVfs = capi.sqlite3_vfs_find(0);
          while (pVfs) {
            const oVfs = new capi.sqlite3_vfs(pVfs);
            rc.push(wasm.cstrToJs(oVfs.$zName));
            pVfs = oVfs.$pNext;
            oVfs.dispose();
          }
          return rc;
        };
        capi.sqlite3_js_db_export = function(pDb2, schema = 0) {
          pDb2 = wasm.xWrap.testConvertArg("sqlite3*", pDb2);
          if (!pDb2) toss3("Invalid sqlite3* argument.");
          if (!wasm.bigIntEnabled) toss3("BigInt64 support is not enabled.");
          const scope = wasm.scopedAllocPush();
          let pOut;
          try {
            const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
            const ppOut = pSize + 8;
            const zSchema = schema ? wasm.isPtr(schema) ? schema : wasm.scopedAllocCString("" + schema) : 0;
            let rc = wasm.exports.sqlite3__wasm_db_serialize(
              pDb2,
              zSchema,
              ppOut,
              pSize,
              0
            );
            if (rc) {
              toss3(
                "Database serialization failed with code",
                sqlite32.capi.sqlite3_js_rc_str(rc)
              );
            }
            pOut = wasm.peekPtr(ppOut);
            const nOut = wasm.peek(pSize, "i64");
            rc = nOut ? wasm.heap8u().slice(pOut, pOut + Number(nOut)) : new Uint8Array();
            return rc;
          } finally {
            if (pOut) wasm.exports.sqlite3_free(pOut);
            wasm.scopedAllocPop(scope);
          }
        };
        capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) => util.sqlite3__wasm_db_vfs(dbPointer, dbName);
        capi.sqlite3_js_aggregate_context = (pCtx, n) => {
          return capi.sqlite3_aggregate_context(pCtx, n) || (n ? WasmAllocError.toss(
            "Cannot allocate",
            n,
            "bytes for sqlite3_aggregate_context()"
          ) : 0);
        };
        capi.sqlite3_js_posix_create_file = function(filename, data, dataLen) {
          let pData;
          if (data && wasm.isPtr(data)) {
            pData = data;
          } else if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
            pData = wasm.allocFromTypedArray(data);
            if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {
              dataLen = data.byteLength;
            }
          } else {
            SQLite3Error.toss(
              "Invalid 2nd argument for sqlite3_js_posix_create_file()."
            );
          }
          try {
            if (!util.isInt32(dataLen) || dataLen < 0) {
              SQLite3Error.toss(
                "Invalid 3rd argument for sqlite3_js_posix_create_file()."
              );
            }
            const rc = util.sqlite3__wasm_posix_create_file(
              filename,
              pData,
              dataLen
            );
            if (rc)
              SQLite3Error.toss(
                "Creation of file failed with sqlite3 result code",
                capi.sqlite3_js_rc_str(rc)
              );
          } finally {
            wasm.dealloc(pData);
          }
        };
        capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen) {
          config.warn(
            "sqlite3_js_vfs_create_file() is deprecated and",
            "should be avoided because it can lead to C-level crashes.",
            "See its documentation for alternative options."
          );
          let pData;
          if (data) {
            if (wasm.isPtr(data)) {
              pData = data;
            } else if (data instanceof ArrayBuffer) {
              data = new Uint8Array(data);
            }
            if (data instanceof Uint8Array) {
              pData = wasm.allocFromTypedArray(data);
              if (arguments.length < 4 || !util.isInt32(dataLen) || dataLen < 0) {
                dataLen = data.byteLength;
              }
            } else {
              SQLite3Error.toss(
                "Invalid 3rd argument type for sqlite3_js_vfs_create_file()."
              );
            }
          } else {
            pData = 0;
          }
          if (!util.isInt32(dataLen) || dataLen < 0) {
            wasm.dealloc(pData);
            SQLite3Error.toss(
              "Invalid 4th argument for sqlite3_js_vfs_create_file()."
            );
          }
          try {
            const rc = util.sqlite3__wasm_vfs_create_file(
              vfs,
              filename,
              pData,
              dataLen
            );
            if (rc)
              SQLite3Error.toss(
                "Creation of file failed with sqlite3 result code",
                capi.sqlite3_js_rc_str(rc)
              );
          } finally {
            wasm.dealloc(pData);
          }
        };
        capi.sqlite3_js_sql_to_string = (sql2) => {
          if ("string" === typeof sql2) {
            return sql2;
          }
          const x = flexibleString(v);
          return x === v ? void 0 : x;
        };
        if (util.isUIThread()) {
          const __kvvfsInfo = function(which) {
            const rc = /* @__PURE__ */ Object.create(null);
            rc.prefix = "kvvfs-" + which;
            rc.stores = [];
            if ("session" === which || "" === which)
              rc.stores.push(globalThis.sessionStorage);
            if ("local" === which || "" === which)
              rc.stores.push(globalThis.localStorage);
            return rc;
          };
          capi.sqlite3_js_kvvfs_clear = function(which = "") {
            let rc = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s) => {
              const toRm = [];
              let i;
              for (i = 0; i < s.length; ++i) {
                const k = s.key(i);
                if (k.startsWith(kvinfo.prefix)) toRm.push(k);
              }
              toRm.forEach((kk) => s.removeItem(kk));
              rc += toRm.length;
            });
            return rc;
          };
          capi.sqlite3_js_kvvfs_size = function(which = "") {
            let sz = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s) => {
              let i;
              for (i = 0; i < s.length; ++i) {
                const k = s.key(i);
                if (k.startsWith(kvinfo.prefix)) {
                  sz += k.length;
                  sz += s.getItem(k).length;
                }
              }
            });
            return sz * 2;
          };
        }
        capi.sqlite3_db_config = function(pDb2, op, ...args) {
          if (!this.s) {
            this.s = wasm.xWrap("sqlite3__wasm_db_config_s", "int", [
              "sqlite3*",
              "int",
              "string:static"
            ]);
            this.pii = wasm.xWrap("sqlite3__wasm_db_config_pii", "int", [
              "sqlite3*",
              "int",
              "*",
              "int",
              "int"
            ]);
            this.ip = wasm.xWrap("sqlite3__wasm_db_config_ip", "int", [
              "sqlite3*",
              "int",
              "int",
              "*"
            ]);
          }
          switch (op) {
            case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
            case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
            case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
            case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
            case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
            case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
            case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
            case capi.SQLITE_DBCONFIG_RESET_DATABASE:
            case capi.SQLITE_DBCONFIG_DEFENSIVE:
            case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
            case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
            case capi.SQLITE_DBCONFIG_DQS_DML:
            case capi.SQLITE_DBCONFIG_DQS_DDL:
            case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
            case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
            case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
            case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
            case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
              return this.ip(pDb2, op, args[0], args[1] || 0);
            case capi.SQLITE_DBCONFIG_LOOKASIDE:
              return this.pii(pDb2, op, args[0], args[1], args[2]);
            case capi.SQLITE_DBCONFIG_MAINDBNAME:
              return this.s(pDb2, op, args[0]);
            default:
              return capi.SQLITE_MISUSE;
          }
        }.bind(/* @__PURE__ */ Object.create(null));
        capi.sqlite3_value_to_js = function(pVal, throwIfCannotConvert = true) {
          let arg;
          const valType = capi.sqlite3_value_type(pVal);
          switch (valType) {
            case capi.SQLITE_INTEGER:
              if (wasm.bigIntEnabled) {
                arg = capi.sqlite3_value_int64(pVal);
                if (util.bigIntFitsDouble(arg)) arg = Number(arg);
              } else arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_FLOAT:
              arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_TEXT:
              arg = capi.sqlite3_value_text(pVal);
              break;
            case capi.SQLITE_BLOB: {
              const n = capi.sqlite3_value_bytes(pVal);
              const pBlob = capi.sqlite3_value_blob(pVal);
              if (n && !pBlob)
                sqlite32.WasmAllocError.toss(
                  "Cannot allocate memory for blob argument of",
                  n,
                  "byte(s)"
                );
              arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;
              break;
            }
            case capi.SQLITE_NULL:
              arg = null;
              break;
            default:
              if (throwIfCannotConvert) {
                toss3(
                  capi.SQLITE_MISMATCH,
                  "Unhandled sqlite3_value_type():",
                  valType
                );
              }
              arg = void 0;
          }
          return arg;
        };
        capi.sqlite3_values_to_js = function(argc, pArgv, throwIfCannotConvert = true) {
          let i;
          const tgt = [];
          for (i = 0; i < argc; ++i) {
            tgt.push(
              capi.sqlite3_value_to_js(
                wasm.peekPtr(pArgv + wasm.ptrSizeof * i),
                throwIfCannotConvert
              )
            );
          }
          return tgt;
        };
        capi.sqlite3_result_error_js = function(pCtx, e) {
          if (e instanceof WasmAllocError) {
            capi.sqlite3_result_error_nomem(pCtx);
          } else {
            capi.sqlite3_result_error(pCtx, "" + e, -1);
          }
        };
        capi.sqlite3_result_js = function(pCtx, val) {
          if (val instanceof Error) {
            capi.sqlite3_result_error_js(pCtx, val);
            return;
          }
          try {
            switch (typeof val) {
              case "undefined":
                break;
              case "boolean":
                capi.sqlite3_result_int(pCtx, val ? 1 : 0);
                break;
              case "bigint":
                if (util.bigIntFits32(val)) {
                  capi.sqlite3_result_int(pCtx, Number(val));
                } else if (util.bigIntFitsDouble(val)) {
                  capi.sqlite3_result_double(pCtx, Number(val));
                } else if (wasm.bigIntEnabled) {
                  if (util.bigIntFits64(val))
                    capi.sqlite3_result_int64(pCtx, val);
                  else
                    toss3(
                      "BigInt value",
                      val.toString(),
                      "is too BigInt for int64."
                    );
                } else {
                  toss3("BigInt value", val.toString(), "is too BigInt.");
                }
                break;
              case "number": {
                let f;
                if (util.isInt32(val)) {
                  f = capi.sqlite3_result_int;
                } else if (wasm.bigIntEnabled && Number.isInteger(val) && util.bigIntFits64(BigInt(val))) {
                  f = capi.sqlite3_result_int64;
                } else {
                  f = capi.sqlite3_result_double;
                }
                f(pCtx, val);
                break;
              }
              case "string": {
                const [p, n] = wasm.allocCString(val, true);
                capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);
                break;
              }
              case "object":
                if (null === val) {
                  capi.sqlite3_result_null(pCtx);
                  break;
                } else if (util.isBindableTypedArray(val)) {
                  const pBlob = wasm.allocFromTypedArray(val);
                  capi.sqlite3_result_blob(
                    pCtx,
                    pBlob,
                    val.byteLength,
                    capi.SQLITE_WASM_DEALLOC
                  );
                  break;
                }
              default:
                toss3(
                  "Don't not how to handle this UDF result value:",
                  typeof val,
                  val
                );
            }
          } catch (e) {
            capi.sqlite3_result_error_js(pCtx, e);
          }
        };
        capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert = true) {
          const v2 = capi.sqlite3_column_value(pStmt, iCol);
          return 0 === v2 ? void 0 : capi.sqlite3_value_to_js(v2, throwIfCannotConvert);
        };
        const __newOldValue = function(pObj, iCol, impl) {
          impl = capi[impl];
          if (!this.ptr) this.ptr = wasm.allocPtr();
          else wasm.pokePtr(this.ptr, 0);
          const rc = impl(pObj, iCol, this.ptr);
          if (rc)
            return SQLite3Error.toss(
              rc,
              arguments[2] + "() failed with code " + rc
            );
          const pv = wasm.peekPtr(this.ptr);
          return pv ? capi.sqlite3_value_to_js(pv, true) : void 0;
        }.bind(/* @__PURE__ */ Object.create(null));
        capi.sqlite3_preupdate_new_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_new");
        capi.sqlite3_preupdate_old_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_old");
        capi.sqlite3changeset_new_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_new");
        capi.sqlite3changeset_old_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_old");
        const sqlite32 = {
          WasmAllocError,
          SQLite3Error,
          capi,
          util,
          wasm,
          config,
          version: /* @__PURE__ */ Object.create(null),
          client: void 0,
          asyncPostInit: async function ff() {
            if (ff.isReady instanceof Promise) return ff.isReady;
            let lia = sqlite3ApiBootstrap.initializersAsync;
            delete sqlite3ApiBootstrap.initializersAsync;
            const postInit = async () => {
              if (!sqlite32.__isUnderTest) {
                delete sqlite32.util;
                delete sqlite32.StructBinder;
              }
              return sqlite32;
            };
            const catcher = (e) => {
              config.error("an async sqlite3 initializer failed:", e);
              throw e;
            };
            if (!lia || !lia.length) {
              return ff.isReady = postInit().catch(catcher);
            }
            lia = lia.map((f) => {
              return f instanceof Function ? async (x) => f(sqlite32) : f;
            });
            lia.push(postInit);
            let p = Promise.resolve(sqlite32);
            while (lia.length) p = p.then(lia.shift());
            return ff.isReady = p.catch(catcher);
          },
          scriptInfo: void 0
        };
        try {
          sqlite3ApiBootstrap.initializers.forEach((f) => {
            f(sqlite32);
          });
        } catch (e) {
          console.error("sqlite3 bootstrap initializer threw:", e);
          throw e;
        }
        delete sqlite3ApiBootstrap.initializers;
        sqlite3ApiBootstrap.sqlite3 = sqlite32;
        return sqlite32;
      };
      globalThis.sqlite3ApiBootstrap.initializers = [];
      globalThis.sqlite3ApiBootstrap.initializersAsync = [];
      globalThis.sqlite3ApiBootstrap.defaultConfig = /* @__PURE__ */ Object.create(null);
      globalThis.sqlite3ApiBootstrap.sqlite3 = void 0;
      globalThis.WhWasmUtilInstaller = function(target) {
        if (void 0 === target.bigIntEnabled) {
          target.bigIntEnabled = !!globalThis["BigInt64Array"];
        }
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        if (!target.exports) {
          Object.defineProperty(target, "exports", {
            enumerable: true,
            configurable: true,
            get: () => target.instance && target.instance.exports
          });
        }
        const ptrIR = target.pointerIR || "i32";
        const ptrSizeof = target.ptrSizeof = "i32" === ptrIR ? 4 : "i64" === ptrIR ? 8 : toss("Unhandled ptrSizeof:", ptrIR);
        const cache = /* @__PURE__ */ Object.create(null);
        cache.heapSize = 0;
        cache.memory = null;
        cache.freeFuncIndexes = [];
        cache.scopedAlloc = [];
        cache.utf8Decoder = new TextDecoder();
        cache.utf8Encoder = new TextEncoder("utf-8");
        target.sizeofIR = (n) => {
          switch (n) {
            case "i8":
              return 1;
            case "i16":
              return 2;
            case "i32":
            case "f32":
            case "float":
              return 4;
            case "i64":
            case "f64":
            case "double":
              return 8;
            case "*":
              return ptrSizeof;
            default:
              return ("" + n).endsWith("*") ? ptrSizeof : void 0;
          }
        };
        const heapWrappers = function() {
          if (!cache.memory) {
            cache.memory = target.memory instanceof WebAssembly.Memory ? target.memory : target.exports.memory;
          } else if (cache.heapSize === cache.memory.buffer.byteLength) {
            return cache;
          }
          const b = cache.memory.buffer;
          cache.HEAP8 = new Int8Array(b);
          cache.HEAP8U = new Uint8Array(b);
          cache.HEAP16 = new Int16Array(b);
          cache.HEAP16U = new Uint16Array(b);
          cache.HEAP32 = new Int32Array(b);
          cache.HEAP32U = new Uint32Array(b);
          if (target.bigIntEnabled) {
            cache.HEAP64 = new BigInt64Array(b);
            cache.HEAP64U = new BigUint64Array(b);
          }
          cache.HEAP32F = new Float32Array(b);
          cache.HEAP64F = new Float64Array(b);
          cache.heapSize = b.byteLength;
          return cache;
        };
        target.heap8 = () => heapWrappers().HEAP8;
        target.heap8u = () => heapWrappers().HEAP8U;
        target.heap16 = () => heapWrappers().HEAP16;
        target.heap16u = () => heapWrappers().HEAP16U;
        target.heap32 = () => heapWrappers().HEAP32;
        target.heap32u = () => heapWrappers().HEAP32U;
        target.heapForSize = function(n, unsigned = true) {
          const c = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          switch (n) {
            case Int8Array:
              return c.HEAP8;
            case Uint8Array:
              return c.HEAP8U;
            case Int16Array:
              return c.HEAP16;
            case Uint16Array:
              return c.HEAP16U;
            case Int32Array:
              return c.HEAP32;
            case Uint32Array:
              return c.HEAP32U;
            case 8:
              return unsigned ? c.HEAP8U : c.HEAP8;
            case 16:
              return unsigned ? c.HEAP16U : c.HEAP16;
            case 32:
              return unsigned ? c.HEAP32U : c.HEAP32;
            case 64:
              if (c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;
              break;
            default:
              if (target.bigIntEnabled) {
                if (n === globalThis["BigUint64Array"]) return c.HEAP64U;
                else if (n === globalThis["BigInt64Array"]) return c.HEAP64;
                break;
              }
          }
          toss(
            "Invalid heapForSize() size: expecting 8, 16, 32,",
            "or (if BigInt is enabled) 64."
          );
        };
        target.functionTable = function() {
          return target.exports.__indirect_function_table;
        };
        target.functionEntry = function(fptr) {
          const ft = target.functionTable();
          return fptr < ft.length ? ft.get(fptr) : void 0;
        };
        target.jsFuncToWasm = function f(func, sig) {
          if (!f._) {
            f._ = {
              sigTypes: Object.assign(/* @__PURE__ */ Object.create(null), {
                i: "i32",
                p: "i32",
                P: "i32",
                s: "i32",
                j: "i64",
                f: "f32",
                d: "f64"
              }),
              typeCodes: Object.assign(/* @__PURE__ */ Object.create(null), {
                f64: 124,
                f32: 125,
                i64: 126,
                i32: 127
              }),
              uleb128Encode: function(tgt, method, n) {
                if (n < 128) tgt[method](n);
                else tgt[method](n % 128 | 128, n >> 7);
              },
              rxJSig: /^(\w)\((\w*)\)$/,
              sigParams: function(sig2) {
                const m = f._.rxJSig.exec(sig2);
                return m ? m[2] : sig2.substr(1);
              },
              letterType: (x) => f._.sigTypes[x] || toss("Invalid signature letter:", x),
              pushSigType: (dest, letter) => dest.push(f._.typeCodes[f._.letterType(letter)])
            };
          }
          if ("string" === typeof func) {
            const x = sig;
            sig = func;
            func = x;
          }
          const sigParams = f._.sigParams(sig);
          const wasmCode = [1, 96];
          f._.uleb128Encode(wasmCode, "push", sigParams.length);
          for (const x of sigParams) f._.pushSigType(wasmCode, x);
          if ("v" === sig[0]) wasmCode.push(0);
          else {
            wasmCode.push(1);
            f._.pushSigType(wasmCode, sig[0]);
          }
          f._.uleb128Encode(wasmCode, "unshift", wasmCode.length);
          wasmCode.unshift(
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1
          );
          wasmCode.push(
            2,
            7,
            1,
            1,
            101,
            1,
            102,
            0,
            0,
            7,
            5,
            1,
            1,
            102,
            0,
            0
          );
          return new WebAssembly.Instance(
            new WebAssembly.Module(new Uint8Array(wasmCode)),
            {
              e: { f: func }
            }
          ).exports["f"];
        };
        const __installFunction = function f(func, sig, scoped) {
          if (scoped && !cache.scopedAlloc.length) {
            toss("No scopedAllocPush() scope is active.");
          }
          if ("string" === typeof func) {
            const x = sig;
            sig = func;
            func = x;
          }
          if ("string" !== typeof sig || !(func instanceof Function)) {
            toss(
              "Invalid arguments: expecting (function,signature) or (signature,function)."
            );
          }
          const ft = target.functionTable();
          const oldLen = ft.length;
          let ptr;
          while (cache.freeFuncIndexes.length) {
            ptr = cache.freeFuncIndexes.pop();
            if (ft.get(ptr)) {
              ptr = null;
              continue;
            } else {
              break;
            }
          }
          if (!ptr) {
            ptr = oldLen;
            ft.grow(1);
          }
          try {
            ft.set(ptr, func);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
            return ptr;
          } catch (e) {
            if (!(e instanceof TypeError)) {
              if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
              throw e;
            }
          }
          try {
            const fptr = target.jsFuncToWasm(func, sig);
            ft.set(ptr, fptr);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
          } catch (e) {
            if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
            throw e;
          }
          return ptr;
        };
        target.installFunction = (func, sig) => __installFunction(func, sig, false);
        target.scopedInstallFunction = (func, sig) => __installFunction(func, sig, true);
        target.uninstallFunction = function(ptr) {
          if (!ptr && 0 !== ptr) return void 0;
          const fi = cache.freeFuncIndexes;
          const ft = target.functionTable();
          fi.push(ptr);
          const rc = ft.get(ptr);
          ft.set(ptr, null);
          return rc;
        };
        target.peek = function f(ptr, type = "i8") {
          if (type.endsWith("*")) type = ptrIR;
          const c = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          const list = Array.isArray(ptr) ? [] : void 0;
          let rc;
          do {
            if (list) ptr = arguments[0].shift();
            switch (type) {
              case "i1":
              case "i8":
                rc = c.HEAP8[ptr >> 0];
                break;
              case "i16":
                rc = c.HEAP16[ptr >> 1];
                break;
              case "i32":
                rc = c.HEAP32[ptr >> 2];
                break;
              case "float":
              case "f32":
                rc = c.HEAP32F[ptr >> 2];
                break;
              case "double":
              case "f64":
                rc = Number(c.HEAP64F[ptr >> 3]);
                break;
              case "i64":
                if (target.bigIntEnabled) {
                  rc = BigInt(c.HEAP64[ptr >> 3]);
                  break;
                }
              default:
                toss("Invalid type for peek():", type);
            }
            if (list) list.push(rc);
          } while (list && arguments[0].length);
          return list || rc;
        };
        target.poke = function(ptr, value, type = "i8") {
          if (type.endsWith("*")) type = ptrIR;
          const c = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          for (const p of Array.isArray(ptr) ? ptr : [ptr]) {
            switch (type) {
              case "i1":
              case "i8":
                c.HEAP8[p >> 0] = value;
                continue;
              case "i16":
                c.HEAP16[p >> 1] = value;
                continue;
              case "i32":
                c.HEAP32[p >> 2] = value;
                continue;
              case "float":
              case "f32":
                c.HEAP32F[p >> 2] = value;
                continue;
              case "double":
              case "f64":
                c.HEAP64F[p >> 3] = value;
                continue;
              case "i64":
                if (c.HEAP64) {
                  c.HEAP64[p >> 3] = BigInt(value);
                  continue;
                }
              default:
                toss("Invalid type for poke(): " + type);
            }
          }
          return this;
        };
        target.peekPtr = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);
        target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);
        target.peek8 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i8");
        target.poke8 = (ptr, value) => target.poke(ptr, value, "i8");
        target.peek16 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i16");
        target.poke16 = (ptr, value) => target.poke(ptr, value, "i16");
        target.peek32 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i32");
        target.poke32 = (ptr, value) => target.poke(ptr, value, "i32");
        target.peek64 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i64");
        target.poke64 = (ptr, value) => target.poke(ptr, value, "i64");
        target.peek32f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f32");
        target.poke32f = (ptr, value) => target.poke(ptr, value, "f32");
        target.peek64f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f64");
        target.poke64f = (ptr, value) => target.poke(ptr, value, "f64");
        target.getMemValue = target.peek;
        target.getPtrValue = target.peekPtr;
        target.setMemValue = target.poke;
        target.setPtrValue = target.pokePtr;
        target.isPtr32 = (ptr) => "number" === typeof ptr && ptr === (ptr | 0) && ptr >= 0;
        target.isPtr = target.isPtr32;
        target.cstrlen = function(ptr) {
          if (!ptr || !target.isPtr(ptr)) return null;
          const h = heapWrappers().HEAP8U;
          let pos = ptr;
          for (; h[pos] !== 0; ++pos) {
          }
          return pos - ptr;
        };
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const __utf8Decode = function(arrayBuffer, begin, end) {
          return cache.utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
          );
        };
        target.cstrToJs = function(ptr) {
          const n = target.cstrlen(ptr);
          return n ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n) : null === n ? n : "";
        };
        target.jstrlen = function(str) {
          if ("string" !== typeof str) return null;
          const n = str.length;
          let len = 0;
          for (let i = 0; i < n; ++i) {
            let u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            }
            if (u <= 127) ++len;
            else if (u <= 2047) len += 2;
            else if (u <= 65535) len += 3;
            else len += 4;
          }
          return len;
        };
        target.jstrcpy = function(jstr, tgt, offset = 0, maxBytes = -1, addNul = true) {
          if (!tgt || !(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array)) {
            toss("jstrcpy() target must be an Int8Array or Uint8Array.");
          }
          if (maxBytes < 0) maxBytes = tgt.length - offset;
          if (!(maxBytes > 0) || !(offset >= 0)) return 0;
          let i = 0, max = jstr.length;
          const begin = offset, end = offset + maxBytes - (addNul ? 1 : 0);
          for (; i < max && offset < end; ++i) {
            let u = jstr.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              u = 65536 + ((u & 1023) << 10) | jstr.charCodeAt(++i) & 1023;
            }
            if (u <= 127) {
              if (offset >= end) break;
              tgt[offset++] = u;
            } else if (u <= 2047) {
              if (offset + 1 >= end) break;
              tgt[offset++] = 192 | u >> 6;
              tgt[offset++] = 128 | u & 63;
            } else if (u <= 65535) {
              if (offset + 2 >= end) break;
              tgt[offset++] = 224 | u >> 12;
              tgt[offset++] = 128 | u >> 6 & 63;
              tgt[offset++] = 128 | u & 63;
            } else {
              if (offset + 3 >= end) break;
              tgt[offset++] = 240 | u >> 18;
              tgt[offset++] = 128 | u >> 12 & 63;
              tgt[offset++] = 128 | u >> 6 & 63;
              tgt[offset++] = 128 | u & 63;
            }
          }
          if (addNul) tgt[offset++] = 0;
          return offset - begin;
        };
        target.cstrncpy = function(tgtPtr, srcPtr, n) {
          if (!tgtPtr || !srcPtr)
            toss("cstrncpy() does not accept NULL strings.");
          if (n < 0) n = target.cstrlen(strPtr) + 1;
          else if (!(n > 0)) return 0;
          const heap = target.heap8u();
          let i = 0, ch;
          for (; i < n && (ch = heap[srcPtr + i]); ++i) {
            heap[tgtPtr + i] = ch;
          }
          if (i < n) heap[tgtPtr + i++] = 0;
          return i;
        };
        target.jstrToUintArray = (str, addNul = false) => {
          return cache.utf8Encoder.encode(addNul ? str + "\0" : str);
        };
        const __affirmAlloc = (obj, funcName) => {
          if (!(obj.alloc instanceof Function) || !(obj.dealloc instanceof Function)) {
            toss(
              "Object is missing alloc() and/or dealloc() function(s)",
              "required by",
              funcName + "()."
            );
          }
        };
        const __allocCStr = function(jstr, returnWithLength, allocator, funcName) {
          __affirmAlloc(target, funcName);
          if ("string" !== typeof jstr) return null;
          {
            const u = cache.utf8Encoder.encode(jstr), ptr = allocator(u.length + 1), heap = heapWrappers().HEAP8U;
            heap.set(u, ptr);
            heap[ptr + u.length] = 0;
            return returnWithLength ? [ptr, u.length] : ptr;
          }
        };
        target.allocCString = (jstr, returnWithLength = false) => __allocCStr(jstr, returnWithLength, target.alloc, "allocCString()");
        target.scopedAllocPush = function() {
          __affirmAlloc(target, "scopedAllocPush");
          const a = [];
          cache.scopedAlloc.push(a);
          return a;
        };
        target.scopedAllocPop = function(state) {
          __affirmAlloc(target, "scopedAllocPop");
          const n = arguments.length ? cache.scopedAlloc.indexOf(state) : cache.scopedAlloc.length - 1;
          if (n < 0) toss("Invalid state object for scopedAllocPop().");
          if (0 === arguments.length) state = cache.scopedAlloc[n];
          cache.scopedAlloc.splice(n, 1);
          for (let p; p = state.pop(); ) {
            if (target.functionEntry(p)) {
              target.uninstallFunction(p);
            } else target.dealloc(p);
          }
        };
        target.scopedAlloc = function(n) {
          if (!cache.scopedAlloc.length) {
            toss("No scopedAllocPush() scope is active.");
          }
          const p = target.alloc(n);
          cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p);
          return p;
        };
        Object.defineProperty(target.scopedAlloc, "level", {
          configurable: false,
          enumerable: false,
          get: () => cache.scopedAlloc.length,
          set: () => toss("The 'active' property is read-only.")
        });
        target.scopedAllocCString = (jstr, returnWithLength = false) => __allocCStr(
          jstr,
          returnWithLength,
          target.scopedAlloc,
          "scopedAllocCString()"
        );
        const __allocMainArgv = function(isScoped, list) {
          const pList = target[isScoped ? "scopedAlloc" : "alloc"](
            (list.length + 1) * target.ptrSizeof
          );
          let i = 0;
          list.forEach((e) => {
            target.pokePtr(
              pList + target.ptrSizeof * i++,
              target[isScoped ? "scopedAllocCString" : "allocCString"]("" + e)
            );
          });
          target.pokePtr(pList + target.ptrSizeof * i, 0);
          return pList;
        };
        target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);
        target.allocMainArgv = (list) => __allocMainArgv(false, list);
        target.cArgvToJs = (argc, pArgv) => {
          const list = [];
          for (let i = 0; i < argc; ++i) {
            const arg = target.peekPtr(pArgv + target.ptrSizeof * i);
            list.push(arg ? target.cstrToJs(arg) : null);
          }
          return list;
        };
        target.scopedAllocCall = function(func) {
          target.scopedAllocPush();
          try {
            return func();
          } finally {
            target.scopedAllocPop();
          }
        };
        const __allocPtr = function(howMany, safePtrSize, method) {
          __affirmAlloc(target, method);
          const pIr = safePtrSize ? "i64" : ptrIR;
          let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
          target.poke(m, 0, pIr);
          if (1 === howMany) {
            return m;
          }
          const a = [m];
          for (let i = 1; i < howMany; ++i) {
            m += safePtrSize ? 8 : ptrSizeof;
            a[i] = m;
            target.poke(m, 0, pIr);
          }
          return a;
        };
        target.allocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "alloc");
        target.scopedAllocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "scopedAlloc");
        target.xGet = function(name) {
          return target.exports[name] || toss("Cannot find exported symbol:", name);
        };
        const __argcMismatch = (f, n) => toss(f + "() requires", n, "argument(s).");
        target.xCall = function(fname, ...args) {
          const f = fname instanceof Function ? fname : target.xGet(fname);
          if (!(f instanceof Function))
            toss("Exported symbol", fname, "is not a function.");
          if (f.length !== args.length)
            __argcMismatch(f === fname ? f.name : fname, f.length);
          return 2 === arguments.length && Array.isArray(arguments[1]) ? f.apply(null, arguments[1]) : f.apply(null, args);
        };
        cache.xWrap = /* @__PURE__ */ Object.create(null);
        cache.xWrap.convert = /* @__PURE__ */ Object.create(null);
        cache.xWrap.convert.arg = /* @__PURE__ */ new Map();
        cache.xWrap.convert.result = /* @__PURE__ */ new Map();
        const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;
        if (target.bigIntEnabled) {
          xArg.set("i64", (i) => BigInt(i));
        }
        const __xArgPtr = "i32" === ptrIR ? (i) => i | 0 : (i) => BigInt(i) | BigInt(0);
        xArg.set("i32", __xArgPtr).set("i16", (i) => (i | 0) & 65535).set("i8", (i) => (i | 0) & 255).set("f32", (i) => Number(i).valueOf()).set("float", xArg.get("f32")).set("f64", xArg.get("f32")).set("double", xArg.get("f64")).set("int", xArg.get("i32")).set("null", (i) => i).set(null, xArg.get("null")).set("**", __xArgPtr).set("*", __xArgPtr);
        xResult.set("*", __xArgPtr).set("pointer", __xArgPtr).set("number", (v2) => Number(v2)).set("void", (v2) => void 0).set("null", (v2) => v2).set(null, xResult.get("null"));
        {
          const copyToResult = [
            "i8",
            "i16",
            "i32",
            "int",
            "f32",
            "float",
            "f64",
            "double"
          ];
          if (target.bigIntEnabled) copyToResult.push("i64");
          const adaptPtr = xArg.get(ptrIR);
          for (const t of copyToResult) {
            xArg.set(t + "*", adaptPtr);
            xResult.set(t + "*", adaptPtr);
            xResult.set(t, xArg.get(t) || toss("Missing arg converter:", t));
          }
        }
        const __xArgString = function(v2) {
          if ("string" === typeof v2) return target.scopedAllocCString(v2);
          return v2 ? __xArgPtr(v2) : null;
        };
        xArg.set("string", __xArgString).set("utf8", __xArgString).set("pointer", __xArgString);
        xResult.set("string", (i) => target.cstrToJs(i)).set("utf8", xResult.get("string")).set("string:dealloc", (i) => {
          try {
            return i ? target.cstrToJs(i) : null;
          } finally {
            target.dealloc(i);
          }
        }).set("utf8:dealloc", xResult.get("string:dealloc")).set("json", (i) => JSON.parse(target.cstrToJs(i))).set("json:dealloc", (i) => {
          try {
            return i ? JSON.parse(target.cstrToJs(i)) : null;
          } finally {
            target.dealloc(i);
          }
        });
        const AbstractArgAdapter = class {
          constructor(opt) {
            this.name = opt.name || "unnamed adapter";
          }
          convertArg(v2, argv, argIndex) {
            toss("AbstractArgAdapter must be subclassed.");
          }
        };
        xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
          constructor(opt) {
            super(opt);
            if (xArg.FuncPtrAdapter.warnOnUse) {
              console.warn(
                "xArg.FuncPtrAdapter is an internal-only API",
                "and is not intended to be invoked from",
                "client-level code. Invoked with:",
                opt
              );
            }
            this.name = opt.name || "unnamed";
            this.signature = opt.signature;
            if (opt.contextKey instanceof Function) {
              this.contextKey = opt.contextKey;
              if (!opt.bindScope) opt.bindScope = "context";
            }
            this.bindScope = opt.bindScope || toss(
              "FuncPtrAdapter options requires a bindScope (explicit or implied)."
            );
            if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {
              toss(
                "Invalid options.bindScope (" + opt.bindMod + ") for FuncPtrAdapter. Expecting one of: (" + FuncPtrAdapter.bindScopes.join(", ") + ")"
              );
            }
            this.isTransient = "transient" === this.bindScope;
            this.isContext = "context" === this.bindScope;
            this.isPermanent = "permanent" === this.bindScope;
            this.singleton = "singleton" === this.bindScope ? [] : void 0;
            this.callProxy = opt.callProxy instanceof Function ? opt.callProxy : void 0;
          }
          contextKey(argv, argIndex) {
            return this;
          }
          contextMap(key) {
            const cm = this.__cmap || (this.__cmap = /* @__PURE__ */ new Map());
            let rc = cm.get(key);
            if (void 0 === rc) cm.set(key, rc = []);
            return rc;
          }
          convertArg(v2, argv, argIndex) {
            let pair = this.singleton;
            if (!pair && this.isContext) {
              pair = this.contextMap(this.contextKey(argv, argIndex));
            }
            if (pair && pair[0] === v2) return pair[1];
            if (v2 instanceof Function) {
              if (this.callProxy) v2 = this.callProxy(v2);
              const fp = __installFunction(v2, this.signature, this.isTransient);
              if (FuncPtrAdapter.debugFuncInstall) {
                FuncPtrAdapter.debugOut(
                  "FuncPtrAdapter installed",
                  this,
                  this.contextKey(argv, argIndex),
                  "@" + fp,
                  v2
                );
              }
              if (pair) {
                if (pair[1]) {
                  if (FuncPtrAdapter.debugFuncInstall) {
                    FuncPtrAdapter.debugOut(
                      "FuncPtrAdapter uninstalling",
                      this,
                      this.contextKey(argv, argIndex),
                      "@" + pair[1],
                      v2
                    );
                  }
                  try {
                    cache.scopedAlloc[cache.scopedAlloc.length - 1].push(
                      pair[1]
                    );
                  } catch (e) {
                  }
                }
                pair[0] = v2;
                pair[1] = fp;
              }
              return fp;
            } else if (target.isPtr(v2) || null === v2 || void 0 === v2) {
              if (pair && pair[1] && pair[1] !== v2) {
                if (FuncPtrAdapter.debugFuncInstall) {
                  FuncPtrAdapter.debugOut(
                    "FuncPtrAdapter uninstalling",
                    this,
                    this.contextKey(argv, argIndex),
                    "@" + pair[1],
                    v2
                  );
                }
                try {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);
                } catch (e) {
                }
                pair[0] = pair[1] = v2 | 0;
              }
              return v2 || 0;
            } else {
              throw new TypeError(
                "Invalid FuncPtrAdapter argument type. Expecting a function pointer or a " + (this.name ? this.name + " " : "") + "function matching signature " + this.signature + "."
              );
            }
          }
        };
        xArg.FuncPtrAdapter.warnOnUse = false;
        xArg.FuncPtrAdapter.debugFuncInstall = false;
        xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);
        xArg.FuncPtrAdapter.bindScopes = [
          "transient",
          "context",
          "singleton",
          "permanent"
        ];
        const __xArgAdapterCheck = (t) => xArg.get(t) || toss("Argument adapter not found:", t);
        const __xResultAdapterCheck = (t) => xResult.get(t) || toss("Result adapter not found:", t);
        cache.xWrap.convertArg = (t, ...args) => __xArgAdapterCheck(t)(...args);
        cache.xWrap.convertArgNoCheck = (t, ...args) => xArg.get(t)(...args);
        cache.xWrap.convertResult = (t, v2) => null === t ? v2 : t ? __xResultAdapterCheck(t)(v2) : void 0;
        cache.xWrap.convertResultNoCheck = (t, v2) => null === t ? v2 : t ? xResult.get(t)(v2) : void 0;
        target.xWrap = function(fArg, resultType, ...argTypes) {
          if (3 === arguments.length && Array.isArray(arguments[2])) {
            argTypes = arguments[2];
          }
          if (target.isPtr(fArg)) {
            fArg = target.functionEntry(fArg) || toss("Function pointer not found in WASM function table.");
          }
          const fIsFunc = fArg instanceof Function;
          const xf = fIsFunc ? fArg : target.xGet(fArg);
          if (fIsFunc) fArg = xf.name || "unnamed function";
          if (argTypes.length !== xf.length) __argcMismatch(fArg, xf.length);
          if (null === resultType && 0 === xf.length) {
            return xf;
          }
          if (void 0 !== resultType && null !== resultType)
            __xResultAdapterCheck(resultType);
          for (const t of argTypes) {
            if (t instanceof AbstractArgAdapter)
              xArg.set(t, (...args) => t.convertArg(...args));
            else __xArgAdapterCheck(t);
          }
          const cxw = cache.xWrap;
          if (0 === xf.length) {
            return (...args) => args.length ? __argcMismatch(fArg, xf.length) : cxw.convertResult(resultType, xf.call(null));
          }
          return function(...args) {
            if (args.length !== xf.length) __argcMismatch(fArg, xf.length);
            const scope = target.scopedAllocPush();
            try {
              let i = 0;
              for (; i < args.length; ++i)
                args[i] = cxw.convertArgNoCheck(argTypes[i], args[i], args, i);
              return cxw.convertResultNoCheck(resultType, xf.apply(null, args));
            } finally {
              target.scopedAllocPop(scope);
            }
          };
        };
        const __xAdapter = function(func, argc, typeName, adapter, modeName, xcvPart) {
          if ("string" === typeof typeName) {
            if (1 === argc) return xcvPart.get(typeName);
            else if (2 === argc) {
              if (!adapter) {
                xcvPart.delete(typeName);
                return func;
              } else if (!(adapter instanceof Function)) {
                toss(modeName, "requires a function argument.");
              }
              xcvPart.set(typeName, adapter);
              return func;
            }
          }
          toss("Invalid arguments to", modeName);
        };
        target.xWrap.resultAdapter = function f(typeName, adapter) {
          return __xAdapter(
            f,
            arguments.length,
            typeName,
            adapter,
            "resultAdapter()",
            xResult
          );
        };
        target.xWrap.argAdapter = function f(typeName, adapter) {
          return __xAdapter(
            f,
            arguments.length,
            typeName,
            adapter,
            "argAdapter()",
            xArg
          );
        };
        target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;
        target.xCallWrapped = function(fArg, resultType, argTypes, ...args) {
          if (Array.isArray(arguments[3])) args = arguments[3];
          return target.xWrap(fArg, resultType, argTypes || []).apply(null, args || []);
        };
        target.xWrap.testConvertArg = cache.xWrap.convertArg;
        target.xWrap.testConvertResult = cache.xWrap.convertResult;
        return target;
      };
      globalThis.WhWasmUtilInstaller.yawl = function(config) {
        const wfetch = () => fetch(config.uri, { credentials: "same-origin" });
        const wui = this;
        const finalThen = function(arg) {
          if (config.wasmUtilTarget) {
            const toss = (...args) => {
              throw new Error(args.join(" "));
            };
            const tgt = config.wasmUtilTarget;
            tgt.module = arg.module;
            tgt.instance = arg.instance;
            if (!tgt.instance.exports.memory) {
              tgt.memory = config.imports && config.imports.env && config.imports.env.memory || toss("Missing 'memory' object!");
            }
            if (!tgt.alloc && arg.instance.exports.malloc) {
              const exports = arg.instance.exports;
              tgt.alloc = function(n) {
                return exports.malloc(n) || toss("Allocation of", n, "bytes failed.");
              };
              tgt.dealloc = function(m) {
                exports.free(m);
              };
            }
            wui(tgt);
          }
          if (config.onload) config.onload(arg, config);
          return arg;
        };
        const loadWasm = WebAssembly.instantiateStreaming ? function loadWasmStreaming() {
          return WebAssembly.instantiateStreaming(
            wfetch(),
            config.imports || {}
          ).then(finalThen);
        } : function loadWasmOldSchool() {
          return wfetch().then((response) => response.arrayBuffer()).then(
            (bytes) => WebAssembly.instantiate(bytes, config.imports || {})
          ).then(finalThen);
        };
        return loadWasm;
      }.bind(globalThis.WhWasmUtilInstaller);
      globalThis.Jaccwabyt = function StructBinderFactory(config) {
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        if (!(config.heap instanceof WebAssembly.Memory) && !(config.heap instanceof Function)) {
          toss(
            "config.heap must be WebAssembly.Memory instance or a function."
          );
        }
        ["alloc", "dealloc"].forEach(function(k) {
          config[k] instanceof Function || toss("Config option '" + k + "' must be a function.");
        });
        const SBF = StructBinderFactory;
        const heap = config.heap instanceof Function ? config.heap : () => new Uint8Array(config.heap.buffer), alloc = config.alloc, dealloc = config.dealloc, log = config.log || console.log.bind(console), memberPrefix = config.memberPrefix || "", memberSuffix = config.memberSuffix || "", bigIntEnabled = void 0 === config.bigIntEnabled ? !!globalThis["BigInt64Array"] : !!config.bigIntEnabled, BigInt3 = globalThis["BigInt"], BigInt64Array2 = globalThis["BigInt64Array"], ptrSizeof = config.ptrSizeof || 4, ptrIR = config.ptrIR || "i32";
        if (!SBF.debugFlags) {
          SBF.__makeDebugFlags = function(deriveFrom = null) {
            if (deriveFrom && deriveFrom.__flags)
              deriveFrom = deriveFrom.__flags;
            const f = function f2(flags) {
              if (0 === arguments.length) {
                return f2.__flags;
              }
              if (flags < 0) {
                delete f2.__flags.getter;
                delete f2.__flags.setter;
                delete f2.__flags.alloc;
                delete f2.__flags.dealloc;
              } else {
                f2.__flags.getter = 0 !== (1 & flags);
                f2.__flags.setter = 0 !== (2 & flags);
                f2.__flags.alloc = 0 !== (4 & flags);
                f2.__flags.dealloc = 0 !== (8 & flags);
              }
              return f2._flags;
            };
            Object.defineProperty(f, "__flags", {
              iterable: false,
              writable: false,
              value: Object.create(deriveFrom)
            });
            if (!deriveFrom) f(0);
            return f;
          };
          SBF.debugFlags = SBF.__makeDebugFlags();
        }
        const isLittleEndian = function() {
          const buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] === 256;
        }();
        const isFuncSig = (s) => "(" === s[1];
        const isAutoPtrSig = (s) => "P" === s;
        const sigLetter = (s) => isFuncSig(s) ? "p" : s[0];
        const sigIR = function(s) {
          switch (sigLetter(s)) {
            case "c":
            case "C":
              return "i8";
            case "i":
              return "i32";
            case "p":
            case "P":
            case "s":
              return ptrIR;
            case "j":
              return "i64";
            case "f":
              return "float";
            case "d":
              return "double";
          }
          toss("Unhandled signature IR:", s);
        };
        const affirmBigIntArray = BigInt64Array2 ? () => true : () => toss("BigInt64Array is not available.");
        const sigDVGetter = function(s) {
          switch (sigLetter(s)) {
            case "p":
            case "P":
            case "s": {
              switch (ptrSizeof) {
                case 4:
                  return "getInt32";
                case 8:
                  return affirmBigIntArray() && "getBigInt64";
              }
              break;
            }
            case "i":
              return "getInt32";
            case "c":
              return "getInt8";
            case "C":
              return "getUint8";
            case "j":
              return affirmBigIntArray() && "getBigInt64";
            case "f":
              return "getFloat32";
            case "d":
              return "getFloat64";
          }
          toss("Unhandled DataView getter for signature:", s);
        };
        const sigDVSetter = function(s) {
          switch (sigLetter(s)) {
            case "p":
            case "P":
            case "s": {
              switch (ptrSizeof) {
                case 4:
                  return "setInt32";
                case 8:
                  return affirmBigIntArray() && "setBigInt64";
              }
              break;
            }
            case "i":
              return "setInt32";
            case "c":
              return "setInt8";
            case "C":
              return "setUint8";
            case "j":
              return affirmBigIntArray() && "setBigInt64";
            case "f":
              return "setFloat32";
            case "d":
              return "setFloat64";
          }
          toss("Unhandled DataView setter for signature:", s);
        };
        const sigDVSetWrapper = function(s) {
          switch (sigLetter(s)) {
            case "i":
            case "f":
            case "c":
            case "C":
            case "d":
              return Number;
            case "j":
              return affirmBigIntArray() && BigInt3;
            case "p":
            case "P":
            case "s":
              switch (ptrSizeof) {
                case 4:
                  return Number;
                case 8:
                  return affirmBigIntArray() && BigInt3;
              }
              break;
          }
          toss("Unhandled DataView set wrapper for signature:", s);
        };
        const sPropName = (s, k) => s + "::" + k;
        const __propThrowOnSet = function(structName, propName) {
          return () => toss(sPropName(structName, propName), "is read-only.");
        };
        const __instancePointerMap = /* @__PURE__ */ new WeakMap();
        const xPtrPropName = "(pointer-is-external)";
        const __freeStruct = function(ctor, obj, m) {
          if (!m) m = __instancePointerMap.get(obj);
          if (m) {
            __instancePointerMap.delete(obj);
            if (Array.isArray(obj.ondispose)) {
              let x;
              while (x = obj.ondispose.shift()) {
                try {
                  if (x instanceof Function) x.call(obj);
                  else if (x instanceof StructType) x.dispose();
                  else if ("number" === typeof x) dealloc(x);
                } catch (e) {
                  console.warn(
                    "ondispose() for",
                    ctor.structName,
                    "@",
                    m,
                    "threw. NOT propagating it.",
                    e
                  );
                }
              }
            } else if (obj.ondispose instanceof Function) {
              try {
                obj.ondispose();
              } catch (e) {
                console.warn(
                  "ondispose() for",
                  ctor.structName,
                  "@",
                  m,
                  "threw. NOT propagating it.",
                  e
                );
              }
            }
            delete obj.ondispose;
            if (ctor.debugFlags.__flags.dealloc) {
              log(
                "debug.dealloc:",
                obj[xPtrPropName] ? "EXTERNAL" : "",
                ctor.structName,
                "instance:",
                ctor.structInfo.sizeof,
                "bytes @" + m
              );
            }
            if (!obj[xPtrPropName]) dealloc(m);
          }
        };
        const rop = (v2) => {
          return {
            configurable: false,
            writable: false,
            iterable: false,
            value: v2
          };
        };
        const __allocStruct = function(ctor, obj, m) {
          let fill = !m;
          if (m) Object.defineProperty(obj, xPtrPropName, rop(m));
          else {
            m = alloc(ctor.structInfo.sizeof);
            if (!m) toss("Allocation of", ctor.structName, "structure failed.");
          }
          try {
            if (ctor.debugFlags.__flags.alloc) {
              log(
                "debug.alloc:",
                fill ? "" : "EXTERNAL",
                ctor.structName,
                "instance:",
                ctor.structInfo.sizeof,
                "bytes @" + m
              );
            }
            if (fill) heap().fill(0, m, m + ctor.structInfo.sizeof);
            __instancePointerMap.set(obj, m);
          } catch (e) {
            __freeStruct(ctor, obj, m);
            throw e;
          }
        };
        const __memoryDump = function() {
          const p = this.pointer;
          return p ? new Uint8Array(heap().slice(p, p + this.structInfo.sizeof)) : null;
        };
        const __memberKey = (k) => memberPrefix + k + memberSuffix;
        const __memberKeyProp = rop(__memberKey);
        const __lookupMember = function(structInfo, memberName, tossIfNotFound = true) {
          let m = structInfo.members[memberName];
          if (!m && (memberPrefix || memberSuffix)) {
            for (const v2 of Object.values(structInfo.members)) {
              if (v2.key === memberName) {
                m = v2;
                break;
              }
            }
            if (!m && tossIfNotFound) {
              toss(
                sPropName(structInfo.name, memberName),
                "is not a mapped struct member."
              );
            }
          }
          return m;
        };
        const __memberSignature = function f(obj, memberName, emscriptenFormat = false) {
          if (!f._)
            f._ = (x) => x.replace(/[^vipPsjrdcC]/g, "").replace(/[pPscC]/g, "i");
          const m = __lookupMember(obj.structInfo, memberName, true);
          return emscriptenFormat ? f._(m.signature) : m.signature;
        };
        const __ptrPropDescriptor = {
          configurable: false,
          enumerable: false,
          get: function() {
            return __instancePointerMap.get(this);
          },
          set: () => toss("Cannot assign the 'pointer' property of a struct.")
        };
        const __structMemberKeys = rop(function() {
          const a = [];
          for (const k of Object.keys(this.structInfo.members)) {
            a.push(this.memberKey(k));
          }
          return a;
        });
        const __utf8Decoder = new TextDecoder("utf-8");
        const __utf8Encoder = new TextEncoder();
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const __utf8Decode = function(arrayBuffer, begin, end) {
          return __utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
          );
        };
        const __memberIsString = function(obj, memberName, tossIfNotFound = false) {
          const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
          return m && 1 === m.signature.length && "s" === m.signature[0] ? m : false;
        };
        const __affirmCStringSignature = function(member) {
          if ("s" === member.signature) return;
          toss(
            "Invalid member type signature for C-string value:",
            JSON.stringify(member)
          );
        };
        const __memberToJsString = function f(obj, memberName) {
          const m = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m);
          const addr = obj[m.key];
          if (!addr) return null;
          let pos = addr;
          const mem = heap();
          for (; mem[pos] !== 0; ++pos) {
          }
          return addr === pos ? "" : __utf8Decode(mem, addr, pos);
        };
        const __addOnDispose = function(obj, ...v2) {
          if (obj.ondispose) {
            if (!Array.isArray(obj.ondispose)) {
              obj.ondispose = [obj.ondispose];
            }
          } else {
            obj.ondispose = [];
          }
          obj.ondispose.push(...v2);
        };
        const __allocCString = function(str) {
          const u = __utf8Encoder.encode(str);
          const mem = alloc(u.length + 1);
          if (!mem) toss("Allocation error while duplicating string:", str);
          const h = heap();
          h.set(u, mem);
          h[mem + u.length] = 0;
          return mem;
        };
        const __setMemberCString = function(obj, memberName, str) {
          const m = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m);
          const mem = __allocCString(str);
          obj[m.key] = mem;
          __addOnDispose(obj, mem);
          return obj;
        };
        const StructType = function ctor(structName, structInfo) {
          if (arguments[2] !== rop) {
            toss(
              "Do not call the StructType constructor",
              "from client-level code."
            );
          }
          Object.defineProperties(this, {
            structName: rop(structName),
            structInfo: rop(structInfo)
          });
        };
        StructType.prototype = Object.create(null, {
          dispose: rop(function() {
            __freeStruct(this.constructor, this);
          }),
          lookupMember: rop(function(memberName, tossIfNotFound = true) {
            return __lookupMember(this.structInfo, memberName, tossIfNotFound);
          }),
          memberToJsString: rop(function(memberName) {
            return __memberToJsString(this, memberName);
          }),
          memberIsString: rop(function(memberName, tossIfNotFound = true) {
            return __memberIsString(this, memberName, tossIfNotFound);
          }),
          memberKey: __memberKeyProp,
          memberKeys: __structMemberKeys,
          memberSignature: rop(function(memberName, emscriptenFormat = false) {
            return __memberSignature(this, memberName, emscriptenFormat);
          }),
          memoryDump: rop(__memoryDump),
          pointer: __ptrPropDescriptor,
          setMemberCString: rop(function(memberName, str) {
            return __setMemberCString(this, memberName, str);
          })
        });
        Object.assign(StructType.prototype, {
          addOnDispose: function(...v2) {
            __addOnDispose(this, ...v2);
            return this;
          }
        });
        Object.defineProperties(StructType, {
          allocCString: rop(__allocCString),
          isA: rop((v2) => v2 instanceof StructType),
          hasExternalPointer: rop(
            (v2) => v2 instanceof StructType && !!v2[xPtrPropName]
          ),
          memberKey: __memberKeyProp
        });
        const isNumericValue = (v2) => Number.isFinite(v2) || v2 instanceof (BigInt3 || Number);
        const makeMemberWrapper = function f(ctor, name, descr) {
          if (!f._) {
            f._ = { getters: {}, setters: {}, sw: {} };
            const a = ["i", "c", "C", "p", "P", "s", "f", "d", "v()"];
            if (bigIntEnabled) a.push("j");
            a.forEach(function(v2) {
              f._.getters[v2] = sigDVGetter(v2);
              f._.setters[v2] = sigDVSetter(v2);
              f._.sw[v2] = sigDVSetWrapper(v2);
            });
            const rxSig1 = /^[ipPsjfdcC]$/, rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
            f.sigCheck = function(obj, name2, key2, sig) {
              if (Object.prototype.hasOwnProperty.call(obj, key2)) {
                toss(obj.structName, "already has a property named", key2 + ".");
              }
              rxSig1.test(sig) || rxSig2.test(sig) || toss(
                "Malformed signature for",
                sPropName(obj.structName, name2) + ":",
                sig
              );
            };
          }
          const key = ctor.memberKey(name);
          f.sigCheck(ctor.prototype, name, key, descr.signature);
          descr.key = key;
          descr.name = name;
          const sigGlyph = sigLetter(descr.signature);
          const xPropName = sPropName(ctor.prototype.structName, key);
          const dbg = ctor.prototype.debugFlags.__flags;
          const prop = /* @__PURE__ */ Object.create(null);
          prop.configurable = false;
          prop.enumerable = false;
          prop.get = function() {
            if (dbg.getter) {
              log(
                "debug.getter:",
                f._.getters[sigGlyph],
                "for",
                sigIR(sigGlyph),
                xPropName,
                "@",
                this.pointer,
                "+",
                descr.offset,
                "sz",
                descr.sizeof
              );
            }
            let rc = new DataView(
              heap().buffer,
              this.pointer + descr.offset,
              descr.sizeof
            )[f._.getters[sigGlyph]](0, isLittleEndian);
            if (dbg.getter) log("debug.getter:", xPropName, "result =", rc);
            return rc;
          };
          if (descr.readOnly) {
            prop.set = __propThrowOnSet(ctor.prototype.structName, key);
          } else {
            prop.set = function(v2) {
              if (dbg.setter) {
                log(
                  "debug.setter:",
                  f._.setters[sigGlyph],
                  "for",
                  sigIR(sigGlyph),
                  xPropName,
                  "@",
                  this.pointer,
                  "+",
                  descr.offset,
                  "sz",
                  descr.sizeof,
                  v2
                );
              }
              if (!this.pointer) {
                toss("Cannot set struct property on disposed instance.");
              }
              if (null === v2) v2 = 0;
              else
                while (!isNumericValue(v2)) {
                  if (isAutoPtrSig(descr.signature) && v2 instanceof StructType) {
                    v2 = v2.pointer || 0;
                    if (dbg.setter)
                      log("debug.setter:", xPropName, "resolved to", v2);
                    break;
                  }
                  toss("Invalid value for pointer-type", xPropName + ".");
                }
              new DataView(
                heap().buffer,
                this.pointer + descr.offset,
                descr.sizeof
              )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v2), isLittleEndian);
            };
          }
          Object.defineProperty(ctor.prototype, key, prop);
        };
        const StructBinder = function StructBinder2(structName, structInfo) {
          if (1 === arguments.length) {
            structInfo = structName;
            structName = structInfo.name;
          } else if (!structInfo.name) {
            structInfo.name = structName;
          }
          if (!structName) toss("Struct name is required.");
          let lastMember = false;
          Object.keys(structInfo.members).forEach((k) => {
            const m = structInfo.members[k];
            if (!m.sizeof) toss(structName, "member", k, "is missing sizeof.");
            else if (m.sizeof === 1) {
              m.signature === "c" || m.signature === "C" || toss(
                "Unexpected sizeof==1 member",
                sPropName(structInfo.name, k),
                "with signature",
                m.signature
              );
            } else {
              if (0 !== m.sizeof % 4) {
                console.warn(
                  "Invalid struct member description =",
                  m,
                  "from",
                  structInfo
                );
                toss(
                  structName,
                  "member",
                  k,
                  "sizeof is not aligned. sizeof=" + m.sizeof
                );
              }
              if (0 !== m.offset % 4) {
                console.warn(
                  "Invalid struct member description =",
                  m,
                  "from",
                  structInfo
                );
                toss(
                  structName,
                  "member",
                  k,
                  "offset is not aligned. offset=" + m.offset
                );
              }
            }
            if (!lastMember || lastMember.offset < m.offset) lastMember = m;
          });
          if (!lastMember) toss("No member property descriptions found.");
          else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {
            toss(
              "Invalid struct config:",
              structName,
              "max member offset (" + lastMember.offset + ") ",
              "extends past end of struct (sizeof=" + structInfo.sizeof + ")."
            );
          }
          const debugFlags = rop(SBF.__makeDebugFlags(StructBinder2.debugFlags));
          const StructCtor = function StructCtor2(externalMemory) {
            if (!(this instanceof StructCtor2)) {
              toss(
                "The",
                structName,
                "constructor may only be called via 'new'."
              );
            } else if (arguments.length) {
              if (externalMemory !== (externalMemory | 0) || externalMemory <= 0) {
                toss("Invalid pointer value for", structName, "constructor.");
              }
              __allocStruct(StructCtor2, this, externalMemory);
            } else {
              __allocStruct(StructCtor2, this);
            }
          };
          Object.defineProperties(StructCtor, {
            debugFlags,
            isA: rop((v2) => v2 instanceof StructCtor),
            memberKey: __memberKeyProp,
            memberKeys: __structMemberKeys,
            methodInfoForKey: rop(function(mKey) {
            }),
            structInfo: rop(structInfo),
            structName: rop(structName)
          });
          StructCtor.prototype = new StructType(structName, structInfo, rop);
          Object.defineProperties(StructCtor.prototype, {
            debugFlags,
            constructor: rop(StructCtor)
          });
          Object.keys(structInfo.members).forEach(
            (name) => makeMemberWrapper(StructCtor, name, structInfo.members[name])
          );
          return StructCtor;
        };
        StructBinder.StructType = StructType;
        StructBinder.config = config;
        StructBinder.allocCString = __allocCString;
        if (!StructBinder.debugFlags) {
          StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
        }
        return StructBinder;
      };
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        sqlite32.SQLite3Error.toss;
        const capi = sqlite32.capi, wasm = sqlite32.wasm, util = sqlite32.util;
        globalThis.WhWasmUtilInstaller(wasm);
        delete globalThis.WhWasmUtilInstaller;
        wasm.bindingSignatures = [
          ["sqlite3_aggregate_context", "void*", "sqlite3_context*", "int"],
          ["sqlite3_bind_double", "int", "sqlite3_stmt*", "int", "f64"],
          ["sqlite3_bind_int", "int", "sqlite3_stmt*", "int", "int"],
          ["sqlite3_bind_null", void 0, "sqlite3_stmt*", "int"],
          ["sqlite3_bind_parameter_count", "int", "sqlite3_stmt*"],
          ["sqlite3_bind_parameter_index", "int", "sqlite3_stmt*", "string"],
          ["sqlite3_bind_parameter_name", "string", "sqlite3_stmt*", "int"],
          [
            "sqlite3_bind_pointer",
            "int",
            "sqlite3_stmt*",
            "int",
            "*",
            "string:static",
            "*"
          ],
          [
            "sqlite3_busy_handler",
            "int",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                signature: "i(pi)",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_busy_timeout", "int", "sqlite3*", "int"],
          ["sqlite3_changes", "int", "sqlite3*"],
          ["sqlite3_clear_bindings", "int", "sqlite3_stmt*"],
          ["sqlite3_collation_needed", "int", "sqlite3*", "*", "*"],
          ["sqlite3_column_blob", "*", "sqlite3_stmt*", "int"],
          ["sqlite3_column_bytes", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_count", "int", "sqlite3_stmt*"],
          ["sqlite3_column_decltype", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_double", "f64", "sqlite3_stmt*", "int"],
          ["sqlite3_column_int", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_name", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_text", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_type", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_value", "sqlite3_value*", "sqlite3_stmt*", "int"],
          [
            "sqlite3_commit_hook",
            "void*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_commit_hook",
                signature: "i(p)",
                contextKey: (argv) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_compileoption_get", "string", "int"],
          ["sqlite3_compileoption_used", "int", "string"],
          ["sqlite3_complete", "int", "string:flexible"],
          ["sqlite3_context_db_handle", "sqlite3*", "sqlite3_context*"],
          ["sqlite3_data_count", "int", "sqlite3_stmt*"],
          ["sqlite3_db_filename", "string", "sqlite3*", "string"],
          ["sqlite3_db_handle", "sqlite3*", "sqlite3_stmt*"],
          ["sqlite3_db_name", "string", "sqlite3*", "int"],
          ["sqlite3_db_readonly", "int", "sqlite3*", "string"],
          ["sqlite3_db_status", "int", "sqlite3*", "int", "*", "*", "int"],
          ["sqlite3_errcode", "int", "sqlite3*"],
          ["sqlite3_errmsg", "string", "sqlite3*"],
          ["sqlite3_error_offset", "int", "sqlite3*"],
          ["sqlite3_errstr", "string", "int"],
          [
            "sqlite3_exec",
            "int",
            [
              "sqlite3*",
              "string:flexible",
              new wasm.xWrap.FuncPtrAdapter({
                signature: "i(pipp)",
                bindScope: "transient",
                callProxy: (callback) => {
                  let aNames;
                  return (pVoid, nCols, pColVals, pColNames) => {
                    try {
                      const aVals = wasm.cArgvToJs(nCols, pColVals);
                      if (!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);
                      return callback(aVals, aNames) | 0;
                    } catch (e) {
                      return e.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }
              }),
              "*",
              "**"
            ]
          ],
          ["sqlite3_expanded_sql", "string", "sqlite3_stmt*"],
          ["sqlite3_extended_errcode", "int", "sqlite3*"],
          ["sqlite3_extended_result_codes", "int", "sqlite3*", "int"],
          ["sqlite3_file_control", "int", "sqlite3*", "string", "int", "*"],
          ["sqlite3_finalize", "int", "sqlite3_stmt*"],
          ["sqlite3_free", void 0, "*"],
          ["sqlite3_get_autocommit", "int", "sqlite3*"],
          ["sqlite3_get_auxdata", "*", "sqlite3_context*", "int"],
          ["sqlite3_initialize", void 0],
          ["sqlite3_interrupt", void 0, "sqlite3*"],
          ["sqlite3_is_interrupted", "int", "sqlite3*"],
          ["sqlite3_keyword_count", "int"],
          ["sqlite3_keyword_name", "int", ["int", "**", "*"]],
          ["sqlite3_keyword_check", "int", ["string", "int"]],
          ["sqlite3_libversion", "string"],
          ["sqlite3_libversion_number", "int"],
          ["sqlite3_limit", "int", ["sqlite3*", "int", "int"]],
          ["sqlite3_malloc", "*", "int"],
          ["sqlite3_open", "int", "string", "*"],
          ["sqlite3_open_v2", "int", "string", "*", "int", "string"],
          ["sqlite3_realloc", "*", "*", "int"],
          ["sqlite3_reset", "int", "sqlite3_stmt*"],
          [
            "sqlite3_result_blob",
            void 0,
            "sqlite3_context*",
            "*",
            "int",
            "*"
          ],
          ["sqlite3_result_double", void 0, "sqlite3_context*", "f64"],
          [
            "sqlite3_result_error",
            void 0,
            "sqlite3_context*",
            "string",
            "int"
          ],
          ["sqlite3_result_error_code", void 0, "sqlite3_context*", "int"],
          ["sqlite3_result_error_nomem", void 0, "sqlite3_context*"],
          ["sqlite3_result_error_toobig", void 0, "sqlite3_context*"],
          ["sqlite3_result_int", void 0, "sqlite3_context*", "int"],
          ["sqlite3_result_null", void 0, "sqlite3_context*"],
          [
            "sqlite3_result_pointer",
            void 0,
            "sqlite3_context*",
            "*",
            "string:static",
            "*"
          ],
          ["sqlite3_result_subtype", void 0, "sqlite3_value*", "int"],
          [
            "sqlite3_result_text",
            void 0,
            "sqlite3_context*",
            "string",
            "int",
            "*"
          ],
          ["sqlite3_result_zeroblob", void 0, "sqlite3_context*", "int"],
          [
            "sqlite3_rollback_hook",
            "void*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_rollback_hook",
                signature: "v(p)",
                contextKey: (argv) => argv[0]
              }),
              "*"
            ]
          ],
          [
            "sqlite3_set_auxdata",
            void 0,
            [
              "sqlite3_context*",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroyAuxData",
                signature: "v(*)",
                contextKey: (argv, argIndex) => argv[0]
              })
            ]
          ],
          ["sqlite3_shutdown", void 0],
          ["sqlite3_sourceid", "string"],
          ["sqlite3_sql", "string", "sqlite3_stmt*"],
          ["sqlite3_status", "int", "int", "*", "*", "int"],
          ["sqlite3_step", "int", "sqlite3_stmt*"],
          ["sqlite3_stmt_busy", "int", "sqlite3_stmt*"],
          ["sqlite3_stmt_readonly", "int", "sqlite3_stmt*"],
          ["sqlite3_stmt_status", "int", "sqlite3_stmt*", "int", "int"],
          ["sqlite3_strglob", "int", "string", "string"],
          ["sqlite3_stricmp", "int", "string", "string"],
          ["sqlite3_strlike", "int", "string", "string", "int"],
          ["sqlite3_strnicmp", "int", "string", "string", "int"],
          [
            "sqlite3_table_column_metadata",
            "int",
            "sqlite3*",
            "string",
            "string",
            "string",
            "**",
            "**",
            "*",
            "*",
            "*"
          ],
          ["sqlite3_total_changes", "int", "sqlite3*"],
          [
            "sqlite3_trace_v2",
            "int",
            [
              "sqlite3*",
              "int",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_trace_v2::callback",
                signature: "i(ippp)",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_txn_state", "int", ["sqlite3*", "string"]],
          ["sqlite3_uri_boolean", "int", "sqlite3_filename", "string", "int"],
          ["sqlite3_uri_key", "string", "sqlite3_filename", "int"],
          ["sqlite3_uri_parameter", "string", "sqlite3_filename", "string"],
          ["sqlite3_user_data", "void*", "sqlite3_context*"],
          ["sqlite3_value_blob", "*", "sqlite3_value*"],
          ["sqlite3_value_bytes", "int", "sqlite3_value*"],
          ["sqlite3_value_double", "f64", "sqlite3_value*"],
          ["sqlite3_value_dup", "sqlite3_value*", "sqlite3_value*"],
          ["sqlite3_value_free", void 0, "sqlite3_value*"],
          ["sqlite3_value_frombind", "int", "sqlite3_value*"],
          ["sqlite3_value_int", "int", "sqlite3_value*"],
          ["sqlite3_value_nochange", "int", "sqlite3_value*"],
          ["sqlite3_value_numeric_type", "int", "sqlite3_value*"],
          ["sqlite3_value_pointer", "*", "sqlite3_value*", "string:static"],
          ["sqlite3_value_subtype", "int", "sqlite3_value*"],
          ["sqlite3_value_text", "string", "sqlite3_value*"],
          ["sqlite3_value_type", "int", "sqlite3_value*"],
          ["sqlite3_vfs_find", "*", "string"],
          ["sqlite3_vfs_register", "int", "sqlite3_vfs*", "int"],
          ["sqlite3_vfs_unregister", "int", "sqlite3_vfs*"]
        ];
        if (!!wasm.exports.sqlite3_progress_handler) {
          wasm.bindingSignatures.push([
            "sqlite3_progress_handler",
            void 0,
            [
              "sqlite3*",
              "int",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xProgressHandler",
                signature: "i(p)",
                bindScope: "context",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ]);
        }
        if (!!wasm.exports.sqlite3_stmt_explain) {
          wasm.bindingSignatures.push(
            ["sqlite3_stmt_explain", "int", "sqlite3_stmt*", "int"],
            ["sqlite3_stmt_isexplain", "int", "sqlite3_stmt*"]
          );
        }
        if (!!wasm.exports.sqlite3_set_authorizer) {
          wasm.bindingSignatures.push([
            "sqlite3_set_authorizer",
            "int",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_set_authorizer::xAuth",
                signature: "i(pissss)",
                contextKey: (argv, argIndex) => argv[0],
                callProxy: (callback) => {
                  return (pV, iCode, s0, s1, s2, s3) => {
                    try {
                      s0 = s0 && wasm.cstrToJs(s0);
                      s1 = s1 && wasm.cstrToJs(s1);
                      s2 = s2 && wasm.cstrToJs(s2);
                      s3 = s3 && wasm.cstrToJs(s3);
                      return callback(pV, iCode, s0, s1, s2, s3) || 0;
                    } catch (e) {
                      return e.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }
              }),
              "*"
            ]
          ]);
        }
        wasm.bindingSignatures.int64 = [
          ["sqlite3_bind_int64", "int", ["sqlite3_stmt*", "int", "i64"]],
          ["sqlite3_changes64", "i64", ["sqlite3*"]],
          ["sqlite3_column_int64", "i64", ["sqlite3_stmt*", "int"]],
          [
            "sqlite3_deserialize",
            "int",
            "sqlite3*",
            "string",
            "*",
            "i64",
            "i64",
            "int"
          ],
          ["sqlite3_last_insert_rowid", "i64", ["sqlite3*"]],
          ["sqlite3_malloc64", "*", "i64"],
          ["sqlite3_msize", "i64", "*"],
          ["sqlite3_overload_function", "int", ["sqlite3*", "string", "int"]],
          ["sqlite3_realloc64", "*", "*", "i64"],
          ["sqlite3_result_int64", void 0, "*", "i64"],
          ["sqlite3_result_zeroblob64", "int", "*", "i64"],
          ["sqlite3_serialize", "*", "sqlite3*", "string", "*", "int"],
          ["sqlite3_set_last_insert_rowid", void 0, ["sqlite3*", "i64"]],
          ["sqlite3_status64", "int", "int", "*", "*", "int"],
          ["sqlite3_total_changes64", "i64", ["sqlite3*"]],
          [
            "sqlite3_update_hook",
            "*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_update_hook",
                signature: "v(iippj)",
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p, op, z0, z1, rowid) => {
                    callback(
                      p,
                      op,
                      wasm.cstrToJs(z0),
                      wasm.cstrToJs(z1),
                      rowid
                    );
                  };
                }
              }),
              "*"
            ]
          ],
          ["sqlite3_uri_int64", "i64", ["sqlite3_filename", "string", "i64"]],
          ["sqlite3_value_int64", "i64", "sqlite3_value*"]
        ];
        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_declare_vtab) {
          wasm.bindingSignatures.int64.push(
            [
              "sqlite3_create_module",
              "int",
              ["sqlite3*", "string", "sqlite3_module*", "*"]
            ],
            [
              "sqlite3_create_module_v2",
              "int",
              ["sqlite3*", "string", "sqlite3_module*", "*", "*"]
            ],
            ["sqlite3_declare_vtab", "int", ["sqlite3*", "string:flexible"]],
            ["sqlite3_drop_modules", "int", ["sqlite3*", "**"]],
            ["sqlite3_vtab_collation", "string", "sqlite3_index_info*", "int"],
            ["sqlite3_vtab_distinct", "int", "sqlite3_index_info*"],
            ["sqlite3_vtab_in", "int", "sqlite3_index_info*", "int", "int"],
            ["sqlite3_vtab_in_first", "int", "sqlite3_value*", "**"],
            ["sqlite3_vtab_in_next", "int", "sqlite3_value*", "**"],
            ["sqlite3_vtab_nochange", "int", "sqlite3_context*"],
            ["sqlite3_vtab_on_conflict", "int", "sqlite3*"],
            [
              "sqlite3_vtab_rhs_value",
              "int",
              "sqlite3_index_info*",
              "int",
              "**"
            ]
          );
        }
        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3_preupdate_hook) {
          wasm.bindingSignatures.int64.push(
            ["sqlite3_preupdate_blobwrite", "int", "sqlite3*"],
            ["sqlite3_preupdate_count", "int", "sqlite3*"],
            ["sqlite3_preupdate_depth", "int", "sqlite3*"],
            [
              "sqlite3_preupdate_hook",
              "*",
              [
                "sqlite3*",
                new wasm.xWrap.FuncPtrAdapter({
                  name: "sqlite3_preupdate_hook",
                  signature: "v(ppippjj)",
                  contextKey: (argv) => argv[0],
                  callProxy: (callback) => {
                    return (p, db, op, zDb, zTbl, iKey1, iKey2) => {
                      callback(
                        p,
                        db,
                        op,
                        wasm.cstrToJs(zDb),
                        wasm.cstrToJs(zTbl),
                        iKey1,
                        iKey2
                      );
                    };
                  }
                }),
                "*"
              ]
            ],
            ["sqlite3_preupdate_new", "int", ["sqlite3*", "int", "**"]],
            ["sqlite3_preupdate_old", "int", ["sqlite3*", "int", "**"]]
          );
        }
        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add && !!wasm.exports.sqlite3session_create && !!wasm.exports.sqlite3_preupdate_hook) {
          const __ipsProxy = {
            signature: "i(ps)",
            callProxy: (callback) => {
              return (p, s) => {
                try {
                  return callback(p, wasm.cstrToJs(s)) | 0;
                } catch (e) {
                  return e.resultCode || capi.SQLITE_ERROR;
                }
              };
            }
          };
          wasm.bindingSignatures.int64.push(
            ...[
              [
                "sqlite3changegroup_add",
                "int",
                ["sqlite3_changegroup*", "int", "void*"]
              ],
              [
                "sqlite3changegroup_add_strm",
                "int",
                [
                  "sqlite3_changegroup*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changegroup_delete",
                void 0,
                ["sqlite3_changegroup*"]
              ],
              ["sqlite3changegroup_new", "int", ["**"]],
              [
                "sqlite3changegroup_output",
                "int",
                ["sqlite3_changegroup*", "int*", "**"]
              ],
              [
                "sqlite3changegroup_output_strm",
                "int",
                [
                  "sqlite3_changegroup*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply",
                "int",
                [
                  "sqlite3*",
                  "int",
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply_strm",
                "int",
                [
                  "sqlite3*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply_v2",
                "int",
                [
                  "sqlite3*",
                  "int",
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "**",
                  "int*",
                  "int"
                ]
              ],
              [
                "sqlite3changeset_apply_v2_strm",
                "int",
                [
                  "sqlite3*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "**",
                  "int*",
                  "int"
                ]
              ],
              [
                "sqlite3changeset_concat",
                "int",
                ["int", "void*", "int", "void*", "int*", "**"]
              ],
              [
                "sqlite3changeset_concat_strm",
                "int",
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInputA",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInputB",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_conflict",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              ["sqlite3changeset_finalize", "int", ["sqlite3_changeset_iter*"]],
              [
                "sqlite3changeset_fk_conflicts",
                "int",
                ["sqlite3_changeset_iter*", "int*"]
              ],
              [
                "sqlite3changeset_invert",
                "int",
                ["int", "void*", "int*", "**"]
              ],
              [
                "sqlite3changeset_invert_strm",
                "int",
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_new",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              ["sqlite3changeset_next", "int", ["sqlite3_changeset_iter*"]],
              [
                "sqlite3changeset_old",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              [
                "sqlite3changeset_op",
                "int",
                ["sqlite3_changeset_iter*", "**", "int*", "int*", "int*"]
              ],
              [
                "sqlite3changeset_pk",
                "int",
                ["sqlite3_changeset_iter*", "**", "int*"]
              ],
              ["sqlite3changeset_start", "int", ["**", "int", "*"]],
              [
                "sqlite3changeset_start_strm",
                "int",
                [
                  "**",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              ["sqlite3changeset_start_v2", "int", ["**", "int", "*", "int"]],
              [
                "sqlite3changeset_start_v2_strm",
                "int",
                [
                  "**",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "int"
                ]
              ],
              ["sqlite3session_attach", "int", ["sqlite3_session*", "string"]],
              [
                "sqlite3session_changeset",
                "int",
                ["sqlite3_session*", "int*", "**"]
              ],
              ["sqlite3session_changeset_size", "i64", ["sqlite3_session*"]],
              [
                "sqlite3session_changeset_strm",
                "int",
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              ["sqlite3session_config", "int", ["int", "void*"]],
              ["sqlite3session_create", "int", ["sqlite3*", "string", "**"]],
              [
                "sqlite3session_diff",
                "int",
                ["sqlite3_session*", "string", "string", "**"]
              ],
              ["sqlite3session_enable", "int", ["sqlite3_session*", "int"]],
              ["sqlite3session_indirect", "int", ["sqlite3_session*", "int"]],
              ["sqlite3session_isempty", "int", ["sqlite3_session*"]],
              ["sqlite3session_memory_used", "i64", ["sqlite3_session*"]],
              [
                "sqlite3session_object_config",
                "int",
                ["sqlite3_session*", "int", "void*"]
              ],
              [
                "sqlite3session_patchset",
                "int",
                ["sqlite3_session*", "*", "**"]
              ],
              [
                "sqlite3session_patchset_strm",
                "int",
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3session_table_filter",
                void 0,
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    ...__ipsProxy,
                    contextKey: (argv, argIndex) => argv[0]
                  }),
                  "*"
                ]
              ]
            ]
          );
        }
        wasm.bindingSignatures.wasmInternal = [
          ["sqlite3__wasm_db_reset", "int", "sqlite3*"],
          ["sqlite3__wasm_db_vfs", "sqlite3_vfs*", "sqlite3*", "string"],
          [
            "sqlite3__wasm_vfs_create_file",
            "int",
            "sqlite3_vfs*",
            "string",
            "*",
            "int"
          ],
          ["sqlite3__wasm_posix_create_file", "int", "string", "*", "int"],
          ["sqlite3__wasm_vfs_unlink", "int", "sqlite3_vfs*", "string"],
          ["sqlite3__wasm_qfmt_token", "string:dealloc", "string", "int"]
        ];
        sqlite32.StructBinder = globalThis.Jaccwabyt({
          heap: wasm.heap8u,
          alloc: wasm.alloc,
          dealloc: wasm.dealloc,
          bigIntEnabled: wasm.bigIntEnabled,
          memberPrefix: "$"
        });
        delete globalThis.Jaccwabyt;
        {
          const __xString = wasm.xWrap.argAdapter("string");
          wasm.xWrap.argAdapter(
            "string:flexible",
            (v2) => __xString(util.flexibleString(v2))
          );
          wasm.xWrap.argAdapter(
            "string:static",
            function(v2) {
              if (wasm.isPtr(v2)) return v2;
              v2 = "" + v2;
              let rc = this[v2];
              return rc || (this[v2] = wasm.allocCString(v2));
            }.bind(/* @__PURE__ */ Object.create(null))
          );
          const __xArgPtr = wasm.xWrap.argAdapter("*");
          const nilType = function() {
          };
          wasm.xWrap.argAdapter("sqlite3_filename", __xArgPtr)(
            "sqlite3_context*",
            __xArgPtr
          )("sqlite3_value*", __xArgPtr)("void*", __xArgPtr)(
            "sqlite3_changegroup*",
            __xArgPtr
          )("sqlite3_changeset_iter*", __xArgPtr)(
            "sqlite3_session*",
            __xArgPtr
          )(
            "sqlite3_stmt*",
            (v2) => {
              var _a;
              return __xArgPtr(
                v2 instanceof (((_a = sqlite32 == null ? void 0 : sqlite32.oo1) == null ? void 0 : _a.Stmt) || nilType) ? v2.pointer : v2
              );
            }
          )(
            "sqlite3*",
            (v2) => {
              var _a;
              return __xArgPtr(
                v2 instanceof (((_a = sqlite32 == null ? void 0 : sqlite32.oo1) == null ? void 0 : _a.DB) || nilType) ? v2.pointer : v2
              );
            }
          )("sqlite3_vfs*", (v2) => {
            if ("string" === typeof v2) {
              return capi.sqlite3_vfs_find(v2) || sqlite32.SQLite3Error.toss(
                capi.SQLITE_NOTFOUND,
                "Unknown sqlite3_vfs name:",
                v2
              );
            }
            return __xArgPtr(
              v2 instanceof (capi.sqlite3_vfs || nilType) ? v2.pointer : v2
            );
          });
          if (wasm.exports.sqlite3_declare_vtab) {
            wasm.xWrap.argAdapter(
              "sqlite3_index_info*",
              (v2) => __xArgPtr(
                v2 instanceof (capi.sqlite3_index_info || nilType) ? v2.pointer : v2
              )
            )(
              "sqlite3_module*",
              (v2) => __xArgPtr(
                v2 instanceof (capi.sqlite3_module || nilType) ? v2.pointer : v2
              )
            );
          }
          const __xRcPtr = wasm.xWrap.resultAdapter("*");
          wasm.xWrap.resultAdapter("sqlite3*", __xRcPtr)(
            "sqlite3_context*",
            __xRcPtr
          )("sqlite3_stmt*", __xRcPtr)("sqlite3_value*", __xRcPtr)(
            "sqlite3_vfs*",
            __xRcPtr
          )("void*", __xRcPtr);
          if (0 === wasm.exports.sqlite3_step.length) {
            wasm.xWrap.doArgcCheck = false;
            sqlite32.config.warn(
              "Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks."
            );
          }
          for (const e of wasm.bindingSignatures) {
            capi[e[0]] = wasm.xWrap.apply(null, e);
          }
          for (const e of wasm.bindingSignatures.wasmInternal) {
            util[e[0]] = wasm.xWrap.apply(null, e);
          }
          const fI64Disabled = function(fname) {
            return () => toss(
              fname + "() is unavailable due to lack",
              "of BigInt support in this build."
            );
          };
          for (const e of wasm.bindingSignatures.int64) {
            capi[e[0]] = wasm.bigIntEnabled ? wasm.xWrap.apply(null, e) : fI64Disabled(e[0]);
          }
          delete wasm.bindingSignatures;
          if (wasm.exports.sqlite3__wasm_db_error) {
            const __db_err = wasm.xWrap(
              "sqlite3__wasm_db_error",
              "int",
              "sqlite3*",
              "int",
              "string"
            );
            util.sqlite3__wasm_db_error = function(pDb2, resultCode, message) {
              if (resultCode instanceof sqlite32.WasmAllocError) {
                resultCode = capi.SQLITE_NOMEM;
                message = 0;
              } else if (resultCode instanceof Error) {
                message = message || "" + resultCode;
                resultCode = resultCode.resultCode || capi.SQLITE_ERROR;
              }
              return pDb2 ? __db_err(pDb2, resultCode, message) : resultCode;
            };
          } else {
            util.sqlite3__wasm_db_error = function(pDb2, errCode, msg) {
              console.warn(
                "sqlite3__wasm_db_error() is not exported.",
                arguments
              );
              return errCode;
            };
          }
        }
        {
          const cJson = wasm.xCall("sqlite3__wasm_enum_json");
          if (!cJson) {
            toss(
              "Maintenance required: increase sqlite3__wasm_enum_json()'s",
              "static buffer size!"
            );
          }
          wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));
          const defineGroups = [
            "access",
            "authorizer",
            "blobFinalizers",
            "changeset",
            "config",
            "dataTypes",
            "dbConfig",
            "dbStatus",
            "encodings",
            "fcntl",
            "flock",
            "ioCap",
            "limits",
            "openFlags",
            "prepareFlags",
            "resultCodes",
            "sqlite3Status",
            "stmtStatus",
            "syncFlags",
            "trace",
            "txnState",
            "udfFlags",
            "version"
          ];
          if (wasm.bigIntEnabled) {
            defineGroups.push("serialize", "session", "vtab");
          }
          for (const t of defineGroups) {
            for (const e of Object.entries(wasm.ctype[t])) {
              capi[e[0]] = e[1];
            }
          }
          if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              "Internal error: cannot resolve exported function",
              "entry SQLITE_WASM_DEALLOC (==" + capi.SQLITE_WASM_DEALLOC + ")."
            );
          }
          const __rcMap = /* @__PURE__ */ Object.create(null);
          for (const t of ["resultCodes"]) {
            for (const e of Object.entries(wasm.ctype[t])) {
              __rcMap[e[1]] = e[0];
            }
          }
          capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];
          const notThese = Object.assign(/* @__PURE__ */ Object.create(null), {
            WasmTestStruct: true,
            sqlite3_kvvfs_methods: !util.isUIThread(),
            sqlite3_index_info: !wasm.bigIntEnabled,
            sqlite3_index_constraint: !wasm.bigIntEnabled,
            sqlite3_index_orderby: !wasm.bigIntEnabled,
            sqlite3_index_constraint_usage: !wasm.bigIntEnabled
          });
          for (const s of wasm.ctype.structs) {
            if (!notThese[s.name]) {
              capi[s.name] = sqlite32.StructBinder(s);
            }
          }
          if (capi.sqlite3_index_info) {
            for (const k of [
              "sqlite3_index_constraint",
              "sqlite3_index_orderby",
              "sqlite3_index_constraint_usage"
            ]) {
              capi.sqlite3_index_info[k] = capi[k];
              delete capi[k];
            }
            capi.sqlite3_vtab_config = wasm.xWrap(
              "sqlite3__wasm_vtab_config",
              "int",
              ["sqlite3*", "int", "int"]
            );
          }
        }
        const __dbArgcMismatch = (pDb2, f, n) => {
          return util.sqlite3__wasm_db_error(
            pDb2,
            capi.SQLITE_MISUSE,
            f + "() requires " + n + " argument" + (1 === n ? "" : "s") + "."
          );
        };
        const __errEncoding = (pDb2) => {
          return util.sqlite3__wasm_db_error(
            pDb2,
            capi.SQLITE_FORMAT,
            "SQLITE_UTF8 is the only supported encoding."
          );
        };
        const __argPDb = (pDb2) => wasm.xWrap.argAdapter("sqlite3*")(pDb2);
        const __argStr = (str) => wasm.isPtr(str) ? wasm.cstrToJs(str) : str;
        const __dbCleanupMap = function(pDb2, mode) {
          pDb2 = __argPDb(pDb2);
          let m = this.dbMap.get(pDb2);
          if (!mode) {
            this.dbMap.delete(pDb2);
            return m;
          } else if (!m && mode > 0) {
            this.dbMap.set(pDb2, m = /* @__PURE__ */ Object.create(null));
          }
          return m;
        }.bind(
          Object.assign(/* @__PURE__ */ Object.create(null), {
            dbMap: /* @__PURE__ */ new Map()
          })
        );
        __dbCleanupMap.addCollation = function(pDb2, name) {
          const m = __dbCleanupMap(pDb2, 1);
          if (!m.collation) m.collation = /* @__PURE__ */ new Set();
          m.collation.add(__argStr(name).toLowerCase());
        };
        __dbCleanupMap._addUDF = function(pDb2, name, arity, map) {
          name = __argStr(name).toLowerCase();
          let u = map.get(name);
          if (!u) map.set(name, u = /* @__PURE__ */ new Set());
          u.add(arity < 0 ? -1 : arity);
        };
        __dbCleanupMap.addFunction = function(pDb2, name, arity) {
          const m = __dbCleanupMap(pDb2, 1);
          if (!m.udf) m.udf = /* @__PURE__ */ new Map();
          this._addUDF(pDb2, name, arity, m.udf);
        };
        if (wasm.exports.sqlite3_create_window_function) {
          __dbCleanupMap.addWindowFunc = function(pDb2, name, arity) {
            const m = __dbCleanupMap(pDb2, 1);
            if (!m.wudf) m.wudf = /* @__PURE__ */ new Map();
            this._addUDF(pDb2, name, arity, m.wudf);
          };
        }
        __dbCleanupMap.cleanup = function(pDb2) {
          pDb2 = __argPDb(pDb2);
          const closeArgs = [pDb2];
          for (const name of [
            "sqlite3_busy_handler",
            "sqlite3_commit_hook",
            "sqlite3_preupdate_hook",
            "sqlite3_progress_handler",
            "sqlite3_rollback_hook",
            "sqlite3_set_authorizer",
            "sqlite3_trace_v2",
            "sqlite3_update_hook"
          ]) {
            const x = wasm.exports[name];
            if (!x) {
              continue;
            }
            closeArgs.length = x.length;
            try {
              capi[name](...closeArgs);
            } catch (e) {
              sqlite32.config.warn(
                "close-time call of",
                name + "(",
                closeArgs,
                ") threw:",
                e
              );
            }
          }
          const m = __dbCleanupMap(pDb2, 0);
          if (!m) return;
          if (m.collation) {
            for (const name of m.collation) {
              try {
                capi.sqlite3_create_collation_v2(
                  pDb2,
                  name,
                  capi.SQLITE_UTF8,
                  0,
                  0,
                  0
                );
              } catch (e) {
              }
            }
            delete m.collation;
          }
          let i;
          for (i = 0; i < 2; ++i) {
            const fmap = i ? m.wudf : m.udf;
            if (!fmap) continue;
            const func = i ? capi.sqlite3_create_window_function : capi.sqlite3_create_function_v2;
            for (const e of fmap) {
              const name = e[0], arities = e[1];
              const fargs = [pDb2, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
              if (i) fargs.push(0);
              for (const arity of arities) {
                try {
                  fargs[2] = arity;
                  func.apply(null, fargs);
                } catch (e2) {
                }
              }
              arities.clear();
            }
            fmap.clear();
          }
          delete m.udf;
          delete m.wudf;
        };
        {
          const __sqlite3CloseV2 = wasm.xWrap(
            "sqlite3_close_v2",
            "int",
            "sqlite3*"
          );
          capi.sqlite3_close_v2 = function(pDb2) {
            if (1 !== arguments.length)
              return __dbArgcMismatch(pDb2, "sqlite3_close_v2", 1);
            if (pDb2) {
              try {
                __dbCleanupMap.cleanup(pDb2);
              } catch (e) {
              }
            }
            return __sqlite3CloseV2(pDb2);
          };
        }
        if (capi.sqlite3session_create) {
          const __sqlite3SessionDelete = wasm.xWrap(
            "sqlite3session_delete",
            void 0,
            ["sqlite3_session*"]
          );
          capi.sqlite3session_delete = function(pSession) {
            if (1 !== arguments.length) {
              return __dbArgcMismatch(pDb, "sqlite3session_delete", 1);
            } else if (pSession) {
              capi.sqlite3session_table_filter(pSession, 0, 0);
            }
            __sqlite3SessionDelete(pSession);
          };
        }
        {
          const contextKey = (argv, argIndex) => {
            return "argv[" + argIndex + "]:" + argv[0] + ":" + wasm.cstrToJs(argv[1]).toLowerCase();
          };
          const __sqlite3CreateCollationV2 = wasm.xWrap(
            "sqlite3_create_collation_v2",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xCompare",
                signature: "i(pipip)",
                contextKey
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                signature: "v(p)",
                contextKey
              })
            ]
          );
          capi.sqlite3_create_collation_v2 = function(pDb2, zName, eTextRep, pArg, xCompare, xDestroy) {
            if (6 !== arguments.length)
              return __dbArgcMismatch(pDb2, "sqlite3_create_collation_v2", 6);
            else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateCollationV2(
                pDb2,
                zName,
                eTextRep,
                pArg,
                xCompare,
                xDestroy
              );
              if (0 === rc && xCompare instanceof Function) {
                __dbCleanupMap.addCollation(pDb2, zName);
              }
              return rc;
            } catch (e) {
              return util.sqlite3__wasm_db_error(pDb2, e);
            }
          };
          capi.sqlite3_create_collation = (pDb2, zName, eTextRep, pArg, xCompare) => {
            return 5 === arguments.length ? capi.sqlite3_create_collation_v2(
              pDb2,
              zName,
              eTextRep,
              pArg,
              xCompare,
              0
            ) : __dbArgcMismatch(pDb2, "sqlite3_create_collation", 5);
          };
        }
        {
          const contextKey = function(argv, argIndex) {
            return argv[0] + ":" + (argv[2] < 0 ? -1 : argv[2]) + ":" + argIndex + ":" + wasm.cstrToJs(argv[1]).toLowerCase();
          };
          const __cfProxy = Object.assign(/* @__PURE__ */ Object.create(null), {
            xInverseAndStep: {
              signature: "v(pip)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              }
            },
            xFinalAndValue: {
              signature: "v(p)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx) => {
                  try {
                    capi.sqlite3_result_js(pCtx, callback(pCtx));
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              }
            },
            xFunc: {
              signature: "v(pip)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    capi.sqlite3_result_js(
                      pCtx,
                      callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))
                    );
                  } catch (e) {
                    capi.sqlite3_result_error_js(pCtx, e);
                  }
                };
              }
            },
            xDestroy: {
              signature: "v(p)",
              contextKey,
              callProxy: (callback) => {
                return (pVoid) => {
                  try {
                    callback(pVoid);
                  } catch (e) {
                    console.error("UDF xDestroy method threw:", e);
                  }
                };
              }
            }
          });
          const __sqlite3CreateFunction = wasm.xWrap(
            "sqlite3_create_function_v2",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFunc",
                ...__cfProxy.xFunc
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xStep",
                ...__cfProxy.xInverseAndStep
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFinal",
                ...__cfProxy.xFinalAndValue
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                ...__cfProxy.xDestroy
              })
            ]
          );
          const __sqlite3CreateWindowFunction = wasm.exports.sqlite3_create_window_function ? wasm.xWrap("sqlite3_create_window_function", "int", [
            "sqlite3*",
            "string",
            "int",
            "int",
            "*",
            new wasm.xWrap.FuncPtrAdapter({
              name: "xStep",
              ...__cfProxy.xInverseAndStep
            }),
            new wasm.xWrap.FuncPtrAdapter({
              name: "xFinal",
              ...__cfProxy.xFinalAndValue
            }),
            new wasm.xWrap.FuncPtrAdapter({
              name: "xValue",
              ...__cfProxy.xFinalAndValue
            }),
            new wasm.xWrap.FuncPtrAdapter({
              name: "xInverse",
              ...__cfProxy.xInverseAndStep
            }),
            new wasm.xWrap.FuncPtrAdapter({
              name: "xDestroy",
              ...__cfProxy.xDestroy
            })
          ]) : void 0;
          capi.sqlite3_create_function_v2 = function f(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb2,
                "sqlite3_create_function_v2",
                f.length
              );
            } else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateFunction(
                pDb2,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
                xDestroy
              );
              if (0 === rc && (xFunc instanceof Function || xStep instanceof Function || xFinal instanceof Function || xDestroy instanceof Function)) {
                __dbCleanupMap.addFunction(pDb2, funcName, nArg);
              }
              return rc;
            } catch (e) {
              console.error("sqlite3_create_function_v2() setup threw:", e);
              return util.sqlite3__wasm_db_error(
                pDb2,
                e,
                "Creation of UDF threw: " + e
              );
            }
          };
          capi.sqlite3_create_function = function f(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
            return f.length === arguments.length ? capi.sqlite3_create_function_v2(
              pDb2,
              funcName,
              nArg,
              eTextRep,
              pApp,
              xFunc,
              xStep,
              xFinal,
              0
            ) : __dbArgcMismatch(pDb2, "sqlite3_create_function", f.length);
          };
          if (__sqlite3CreateWindowFunction) {
            capi.sqlite3_create_window_function = function f(pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) {
              if (f.length !== arguments.length) {
                return __dbArgcMismatch(
                  pDb2,
                  "sqlite3_create_window_function",
                  f.length
                );
              } else if (0 === (eTextRep & 15)) {
                eTextRep |= capi.SQLITE_UTF8;
              } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
                return __errEncoding(pDb2);
              }
              try {
                const rc = __sqlite3CreateWindowFunction(
                  pDb2,
                  funcName,
                  nArg,
                  eTextRep,
                  pApp,
                  xStep,
                  xFinal,
                  xValue,
                  xInverse,
                  xDestroy
                );
                if (0 === rc && (xStep instanceof Function || xFinal instanceof Function || xValue instanceof Function || xInverse instanceof Function || xDestroy instanceof Function)) {
                  __dbCleanupMap.addWindowFunc(pDb2, funcName, nArg);
                }
                return rc;
              } catch (e) {
                console.error(
                  "sqlite3_create_window_function() setup threw:",
                  e
                );
                return util.sqlite3__wasm_db_error(
                  pDb2,
                  e,
                  "Creation of UDF threw: " + e
                );
              }
            };
          } else {
            delete capi.sqlite3_create_window_function;
          }
          capi.sqlite3_create_function_v2.udfSetResult = capi.sqlite3_create_function.udfSetResult = capi.sqlite3_result_js;
          if (capi.sqlite3_create_window_function) {
            capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;
          }
          capi.sqlite3_create_function_v2.udfConvertArgs = capi.sqlite3_create_function.udfConvertArgs = capi.sqlite3_values_to_js;
          if (capi.sqlite3_create_window_function) {
            capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;
          }
          capi.sqlite3_create_function_v2.udfSetError = capi.sqlite3_create_function.udfSetError = capi.sqlite3_result_error_js;
          if (capi.sqlite3_create_window_function) {
            capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;
          }
        }
        {
          const __flexiString = (v2, n) => {
            if ("string" === typeof v2) {
              n = -1;
            } else if (util.isSQLableTypedArray(v2)) {
              n = v2.byteLength;
              v2 = util.typedArrayToString(
                v2 instanceof ArrayBuffer ? new Uint8Array(v2) : v2
              );
            } else if (Array.isArray(v2)) {
              v2 = v2.join("");
              n = -1;
            }
            return [v2, n];
          };
          const __prepare = {
            basic: wasm.xWrap("sqlite3_prepare_v3", "int", [
              "sqlite3*",
              "string",
              "int",
              "int",
              "**",
              "**"
            ]),
            full: wasm.xWrap("sqlite3_prepare_v3", "int", [
              "sqlite3*",
              "*",
              "int",
              "int",
              "**",
              "**"
            ])
          };
          capi.sqlite3_prepare_v3 = function f(pDb2, sql2, sqlLen, prepFlags, ppStmt, pzTail) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(pDb2, "sqlite3_prepare_v3", f.length);
            }
            const [xSql, xSqlLen] = __flexiString(sql2, sqlLen);
            switch (typeof xSql) {
              case "string":
                return __prepare.basic(
                  pDb2,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  null
                );
              case "number":
                return __prepare.full(
                  pDb2,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  pzTail
                );
              default:
                return util.sqlite3__wasm_db_error(
                  pDb2,
                  capi.SQLITE_MISUSE,
                  "Invalid SQL argument type for sqlite3_prepare_v2/v3()."
                );
            }
          };
          capi.sqlite3_prepare_v2 = function f(pDb2, sql2, sqlLen, ppStmt, pzTail) {
            return f.length === arguments.length ? capi.sqlite3_prepare_v3(pDb2, sql2, sqlLen, 0, ppStmt, pzTail) : __dbArgcMismatch(pDb2, "sqlite3_prepare_v2", f.length);
          };
        }
        {
          const __bindText = wasm.xWrap("sqlite3_bind_text", "int", [
            "sqlite3_stmt*",
            "int",
            "string",
            "int",
            "*"
          ]);
          const __bindBlob = wasm.xWrap("sqlite3_bind_blob", "int", [
            "sqlite3_stmt*",
            "int",
            "*",
            "int",
            "*"
          ]);
          capi.sqlite3_bind_text = function f(pStmt, iCol, text, nText, xDestroy) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                "sqlite3_bind_text",
                f.length
              );
            } else if (wasm.isPtr(text) || null === text) {
              return __bindText(pStmt, iCol, text, nText, xDestroy);
            } else if (text instanceof ArrayBuffer) {
              text = new Uint8Array(text);
            } else if (Array.isArray(pMem)) {
              text = pMem.join("");
            }
            let p, n;
            try {
              if (util.isSQLableTypedArray(text)) {
                p = wasm.allocFromTypedArray(text);
                n = text.byteLength;
              } else if ("string" === typeof text) {
                [p, n] = wasm.allocCString(text);
              } else {
                return util.sqlite3__wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  "Invalid 3rd argument type for sqlite3_bind_text()."
                );
              }
              return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
            } catch (e) {
              wasm.dealloc(p);
              return util.sqlite3__wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e
              );
            }
          };
          capi.sqlite3_bind_blob = function f(pStmt, iCol, pMem2, nMem, xDestroy) {
            if (f.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                "sqlite3_bind_blob",
                f.length
              );
            } else if (wasm.isPtr(pMem2) || null === pMem2) {
              return __bindBlob(pStmt, iCol, pMem2, nMem, xDestroy);
            } else if (pMem2 instanceof ArrayBuffer) {
              pMem2 = new Uint8Array(pMem2);
            } else if (Array.isArray(pMem2)) {
              pMem2 = pMem2.join("");
            }
            let p, n;
            try {
              if (util.isBindableTypedArray(pMem2)) {
                p = wasm.allocFromTypedArray(pMem2);
                n = nMem >= 0 ? nMem : pMem2.byteLength;
              } else if ("string" === typeof pMem2) {
                [p, n] = wasm.allocCString(pMem2);
              } else {
                return util.sqlite3__wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  "Invalid 3rd argument type for sqlite3_bind_blob()."
                );
              }
              return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
            } catch (e) {
              wasm.dealloc(p);
              return util.sqlite3__wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e
              );
            }
          };
        }
        {
          capi.sqlite3_config = function(op, ...args) {
            if (arguments.length < 2) return capi.SQLITE_MISUSE;
            switch (op) {
              case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:
              case capi.SQLITE_CONFIG_MEMSTATUS:
              case capi.SQLITE_CONFIG_SMALL_MALLOC:
              case capi.SQLITE_CONFIG_SORTERREF_SIZE:
              case capi.SQLITE_CONFIG_STMTJRNL_SPILL:
              case capi.SQLITE_CONFIG_URI:
                return wasm.exports.sqlite3__wasm_config_i(op, args[0]);
              case capi.SQLITE_CONFIG_LOOKASIDE:
                return wasm.exports.sqlite3__wasm_config_ii(
                  op,
                  args[0],
                  args[1]
                );
              case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:
                return wasm.exports.sqlite3__wasm_config_j(op, args[0]);
              case capi.SQLITE_CONFIG_GETMALLOC:
              case capi.SQLITE_CONFIG_GETMUTEX:
              case capi.SQLITE_CONFIG_GETPCACHE2:
              case capi.SQLITE_CONFIG_GETPCACHE:
              case capi.SQLITE_CONFIG_HEAP:
              case capi.SQLITE_CONFIG_LOG:
              case capi.SQLITE_CONFIG_MALLOC:
              case capi.SQLITE_CONFIG_MMAP_SIZE:
              case capi.SQLITE_CONFIG_MULTITHREAD:
              case capi.SQLITE_CONFIG_MUTEX:
              case capi.SQLITE_CONFIG_PAGECACHE:
              case capi.SQLITE_CONFIG_PCACHE2:
              case capi.SQLITE_CONFIG_PCACHE:
              case capi.SQLITE_CONFIG_PCACHE_HDRSZ:
              case capi.SQLITE_CONFIG_PMASZ:
              case capi.SQLITE_CONFIG_SERIALIZED:
              case capi.SQLITE_CONFIG_SINGLETHREAD:
              case capi.SQLITE_CONFIG_SQLLOG:
              case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:
              default:
                return capi.SQLITE_NOTFOUND;
            }
          };
        }
        {
          const __autoExtFptr = /* @__PURE__ */ new Set();
          capi.sqlite3_auto_extension = function(fPtr) {
            if (fPtr instanceof Function) {
              fPtr = wasm.installFunction("i(ppp)", fPtr);
            } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {
              return capi.SQLITE_MISUSE;
            }
            const rc = wasm.exports.sqlite3_auto_extension(fPtr);
            if (fPtr !== arguments[0]) {
              if (0 === rc) __autoExtFptr.add(fPtr);
              else wasm.uninstallFunction(fPtr);
            }
            return rc;
          };
          capi.sqlite3_cancel_auto_extension = function(fPtr) {
            if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr)) return 0;
            return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
          };
          capi.sqlite3_reset_auto_extension = function() {
            wasm.exports.sqlite3_reset_auto_extension();
            for (const fp of __autoExtFptr) wasm.uninstallFunction(fp);
            __autoExtFptr.clear();
          };
        }
        const pKvvfs = capi.sqlite3_vfs_find("kvvfs");
        if (pKvvfs) {
          if (util.isUIThread()) {
            const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
              wasm.exports.sqlite3__wasm_kvvfs_methods()
            );
            delete capi.sqlite3_kvvfs_methods;
            const kvvfsMakeKey = wasm.exports.sqlite3__wasm_kvvfsMakeKeyOnPstack, pstack = wasm.pstack;
            const kvvfsStorage = (zClass) => 115 === wasm.peek(zClass) ? sessionStorage : localStorage;
            const kvvfsImpls = {
              xRead: (zClass, zKey, zBuf, nBuf) => {
                const stack = pstack.pointer, astack = wasm.scopedAllocPush();
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return -3;
                  const jKey = wasm.cstrToJs(zXKey);
                  const jV = kvvfsStorage(zClass).getItem(jKey);
                  if (!jV) return -1;
                  const nV = jV.length;
                  if (nBuf <= 0) return nV;
                  else if (1 === nBuf) {
                    wasm.poke(zBuf, 0);
                    return nV;
                  }
                  const zV = wasm.scopedAllocCString(jV);
                  if (nBuf > nV + 1) nBuf = nV + 1;
                  wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
                  wasm.poke(zBuf + nBuf - 1, 0);
                  return nBuf - 1;
                } catch (e) {
                  console.error("kvstorageRead()", e);
                  return -2;
                } finally {
                  pstack.restore(stack);
                  wasm.scopedAllocPop(astack);
                }
              },
              xWrite: (zClass, zKey, zData) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return 1;
                  const jKey = wasm.cstrToJs(zXKey);
                  kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
                  return 0;
                } catch (e) {
                  console.error("kvstorageWrite()", e);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              },
              xDelete: (zClass, zKey) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey) return 1;
                  kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
                  return 0;
                } catch (e) {
                  console.error("kvstorageDelete()", e);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              }
            };
            for (const k of Object.keys(kvvfsImpls)) {
              kvvfsMethods[kvvfsMethods.memberKey(k)] = wasm.installFunction(
                kvvfsMethods.memberSignature(k),
                kvvfsImpls[k]
              );
            }
          } else {
            capi.sqlite3_vfs_unregister(pKvvfs);
          }
        }
        wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
        const StructBinder = sqlite32.StructBinder;
        const installMethod = function callee2(tgt, name, func, applyArgcCheck = callee2.installMethodArgcCheck) {
          if (!(tgt instanceof StructBinder.StructType)) {
            toss("Usage error: target object is-not-a StructType.");
          } else if (!(func instanceof Function) && !wasm.isPtr(func)) {
            toss("Usage errror: expecting a Function or WASM pointer to one.");
          }
          if (1 === arguments.length) {
            return (n, f) => callee2(tgt, n, f, applyArgcCheck);
          }
          if (!callee2.argcProxy) {
            callee2.argcProxy = function(tgt2, funcName, func2, sig) {
              return function(...args) {
                if (func2.length !== arguments.length) {
                  toss(
                    "Argument mismatch for",
                    tgt2.structInfo.name + "::" + funcName + ": Native signature is:",
                    sig
                  );
                }
                return func2.apply(this, args);
              };
            };
            callee2.removeFuncList = function() {
              if (this.ondispose.__removeFuncList) {
                this.ondispose.__removeFuncList.forEach((v2, ndx) => {
                  if ("number" === typeof v2) {
                    try {
                      wasm.uninstallFunction(v2);
                    } catch (e) {
                    }
                  }
                });
                delete this.ondispose.__removeFuncList;
              }
            };
          }
          const sigN = tgt.memberSignature(name);
          if (sigN.length < 2) {
            toss(
              "Member",
              name,
              "does not have a function pointer signature:",
              sigN
            );
          }
          const memKey = tgt.memberKey(name);
          const fProxy = applyArgcCheck && !wasm.isPtr(func) ? callee2.argcProxy(tgt, memKey, func, sigN) : func;
          if (wasm.isPtr(fProxy)) {
            if (fProxy && !wasm.functionEntry(fProxy)) {
              toss("Pointer", fProxy, "is not a WASM function table entry.");
            }
            tgt[memKey] = fProxy;
          } else {
            const pFunc = wasm.installFunction(
              fProxy,
              tgt.memberSignature(name, true)
            );
            tgt[memKey] = pFunc;
            if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {
              tgt.addOnDispose(
                "ondispose.__removeFuncList handler",
                callee2.removeFuncList
              );
              tgt.ondispose.__removeFuncList = [];
            }
            tgt.ondispose.__removeFuncList.push(memKey, pFunc);
          }
          return (n, f) => callee2(tgt, n, f, applyArgcCheck);
        };
        installMethod.installMethodArgcCheck = false;
        const installMethods = function(structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
          const seen = /* @__PURE__ */ new Map();
          for (const k of Object.keys(methods)) {
            const m = methods[k];
            const prior = seen.get(m);
            if (prior) {
              const mkey = structInstance.memberKey(k);
              structInstance[mkey] = structInstance[structInstance.memberKey(prior)];
            } else {
              installMethod(structInstance, k, m, applyArgcCheck);
              seen.set(m, k);
            }
          }
          return structInstance;
        };
        StructBinder.StructType.prototype.installMethod = function callee2(name, func, applyArgcCheck = installMethod.installMethodArgcCheck) {
          return arguments.length < 3 && name && "object" === typeof name ? installMethods(this, ...arguments) : installMethod(this, ...arguments);
        };
        StructBinder.StructType.prototype.installMethods = function(methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
          return installMethods(this, methods, applyArgcCheck);
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        sqlite32.version = {
          libVersion: "3.48.0",
          libVersionNumber: 3048e3,
          sourceId: "2025-01-14 11:05:00 d2fe6b05f38d9d7cd78c5d252e99ac59f1aea071d669830c1ffe4e8966e84010",
          downloadVersion: 348e4
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const toss3 = (...args) => {
          throw new sqlite32.SQLite3Error(...args);
        };
        const capi = sqlite32.capi, wasm = sqlite32.wasm, util = sqlite32.util;
        const __ptrMap = /* @__PURE__ */ new WeakMap();
        const __stmtMap = /* @__PURE__ */ new WeakMap();
        const getOwnOption = (opts, p, dflt) => {
          const d = Object.getOwnPropertyDescriptor(opts, p);
          return d ? d.value : dflt;
        };
        const checkSqlite3Rc = function(dbPtr, sqliteResultCode) {
          if (sqliteResultCode) {
            if (dbPtr instanceof DB) dbPtr = dbPtr.pointer;
            toss3(
              sqliteResultCode,
              "sqlite3 result code",
              sqliteResultCode + ":",
              dbPtr ? capi.sqlite3_errmsg(dbPtr) : capi.sqlite3_errstr(sqliteResultCode)
            );
          }
          return arguments[0];
        };
        const __dbTraceToConsole = wasm.installFunction(
          "i(ippp)",
          function(t, c, p, x) {
            if (capi.SQLITE_TRACE_STMT === t) {
              console.log(
                "SQL TRACE #" + ++this.counter + " via sqlite3@" + c + ":",
                wasm.cstrToJs(x)
              );
            }
          }.bind({ counter: 0 })
        );
        const __vfsPostOpenCallback = /* @__PURE__ */ Object.create(null);
        const dbCtorHelper = function ctor(...args) {
          if (!ctor._name2vfs) {
            ctor._name2vfs = /* @__PURE__ */ Object.create(null);
            const isWorkerThread = "function" === typeof importScripts ? (n) => toss3(
              "The VFS for",
              n,
              "is only available in the main window thread."
            ) : false;
            ctor._name2vfs[":localStorage:"] = {
              vfs: "kvvfs",
              filename: isWorkerThread || (() => "local")
            };
            ctor._name2vfs[":sessionStorage:"] = {
              vfs: "kvvfs",
              filename: isWorkerThread || (() => "session")
            };
          }
          const opt = ctor.normalizeArgs(...args);
          let fn = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;
          if ("string" !== typeof fn && "number" !== typeof fn || "string" !== typeof flagsStr || vfsName && "string" !== typeof vfsName && "number" !== typeof vfsName) {
            sqlite32.config.error("Invalid DB ctor args", opt, arguments);
            toss3("Invalid arguments for DB constructor.");
          }
          let fnJs = "number" === typeof fn ? wasm.cstrToJs(fn) : fn;
          const vfsCheck = ctor._name2vfs[fnJs];
          if (vfsCheck) {
            vfsName = vfsCheck.vfs;
            fn = fnJs = vfsCheck.filename(fnJs);
          }
          let pDb2, oflags = 0;
          if (flagsStr.indexOf("c") >= 0) {
            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
          }
          if (flagsStr.indexOf("w") >= 0) oflags |= capi.SQLITE_OPEN_READWRITE;
          if (0 === oflags) oflags |= capi.SQLITE_OPEN_READONLY;
          oflags |= capi.SQLITE_OPEN_EXRESCODE;
          const stack = wasm.pstack.pointer;
          try {
            const pPtr = wasm.pstack.allocPtr();
            let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
            pDb2 = wasm.peekPtr(pPtr);
            checkSqlite3Rc(pDb2, rc);
            capi.sqlite3_extended_result_codes(pDb2, 1);
            if (flagsStr.indexOf("t") >= 0) {
              capi.sqlite3_trace_v2(
                pDb2,
                capi.SQLITE_TRACE_STMT,
                __dbTraceToConsole,
                pDb2
              );
            }
          } catch (e) {
            if (pDb2) capi.sqlite3_close_v2(pDb2);
            throw e;
          } finally {
            wasm.pstack.restore(stack);
          }
          this.filename = fnJs;
          __ptrMap.set(this, pDb2);
          __stmtMap.set(this, /* @__PURE__ */ Object.create(null));
          try {
            const pVfs = capi.sqlite3_js_db_vfs(pDb2) || toss3("Internal error: cannot get VFS for new db handle.");
            const postInitSql = __vfsPostOpenCallback[pVfs];
            if (postInitSql) {
              if (postInitSql instanceof Function) {
                postInitSql(this, sqlite32);
              } else {
                checkSqlite3Rc(
                  pDb2,
                  capi.sqlite3_exec(pDb2, postInitSql, 0, 0, 0)
                );
              }
            }
          } catch (e) {
            this.close();
            throw e;
          }
        };
        dbCtorHelper.setVfsPostOpenCallback = function(pVfs, callback) {
          if (!(callback instanceof Function)) {
            toss3(
              "dbCtorHelper.setVfsPostOpenCallback() should not be used with a non-function argument.",
              arguments
            );
          }
          __vfsPostOpenCallback[pVfs] = callback;
        };
        dbCtorHelper.normalizeArgs = function(filename = ":memory:", flags = "c", vfs = null) {
          const arg = {};
          if (1 === arguments.length && arguments[0] && "object" === typeof arguments[0]) {
            Object.assign(arg, arguments[0]);
            if (void 0 === arg.flags) arg.flags = "c";
            if (void 0 === arg.vfs) arg.vfs = null;
            if (void 0 === arg.filename) arg.filename = ":memory:";
          } else {
            arg.filename = filename;
            arg.flags = flags;
            arg.vfs = vfs;
          }
          return arg;
        };
        const DB = function(...args) {
          dbCtorHelper.apply(this, args);
        };
        DB.dbCtorHelper = dbCtorHelper;
        const BindTypes = {
          null: 1,
          number: 2,
          string: 3,
          boolean: 4,
          blob: 5
        };
        BindTypes["undefined"] == BindTypes.null;
        if (wasm.bigIntEnabled) {
          BindTypes.bigint = BindTypes.number;
        }
        const Stmt = function() {
          if (BindTypes !== arguments[2]) {
            toss3(
              capi.SQLITE_MISUSE,
              "Do not call the Stmt constructor directly. Use DB.prepare()."
            );
          }
          this.db = arguments[0];
          __ptrMap.set(this, arguments[1]);
          this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
        };
        const affirmDbOpen = function(db) {
          if (!db.pointer) toss3("DB has been closed.");
          return db;
        };
        const affirmColIndex = function(stmt, ndx) {
          if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {
            toss3("Column index", ndx, "is out of range.");
          }
          return stmt;
        };
        const parseExecArgs = function(db, args) {
          const out2 = /* @__PURE__ */ Object.create(null);
          out2.opt = /* @__PURE__ */ Object.create(null);
          switch (args.length) {
            case 1:
              if ("string" === typeof args[0] || util.isSQLableTypedArray(args[0])) {
                out2.sql = args[0];
              } else if (Array.isArray(args[0])) {
                out2.sql = args[0];
              } else if (args[0] && "object" === typeof args[0]) {
                out2.opt = args[0];
                out2.sql = out2.opt.sql;
              }
              break;
            case 2:
              out2.sql = args[0];
              out2.opt = args[1];
              break;
            default:
              toss3("Invalid argument count for exec().");
          }
          out2.sql = util.flexibleString(out2.sql);
          if ("string" !== typeof out2.sql) {
            toss3("Missing SQL argument or unsupported SQL value type.");
          }
          const opt = out2.opt;
          switch (opt.returnValue) {
            case "resultRows":
              if (!opt.resultRows) opt.resultRows = [];
              out2.returnVal = () => opt.resultRows;
              break;
            case "saveSql":
              if (!opt.saveSql) opt.saveSql = [];
              out2.returnVal = () => opt.saveSql;
              break;
            case void 0:
            case "this":
              out2.returnVal = () => db;
              break;
            default:
              toss3("Invalid returnValue value:", opt.returnValue);
          }
          if (!opt.callback && !opt.returnValue && void 0 !== opt.rowMode) {
            if (!opt.resultRows) opt.resultRows = [];
            out2.returnVal = () => opt.resultRows;
          }
          if (opt.callback || opt.resultRows) {
            switch (void 0 === opt.rowMode ? "array" : opt.rowMode) {
              case "object":
                out2.cbArg = (stmt, cache) => {
                  if (!cache.columnNames)
                    cache.columnNames = stmt.getColumnNames([]);
                  const row = stmt.get([]);
                  const rv = /* @__PURE__ */ Object.create(null);
                  for (const i in cache.columnNames)
                    rv[cache.columnNames[i]] = row[i];
                  return rv;
                };
                break;
              case "array":
                out2.cbArg = (stmt) => stmt.get([]);
                break;
              case "stmt":
                if (Array.isArray(opt.resultRows)) {
                  toss3(
                    "exec(): invalid rowMode for a resultRows array: must",
                    "be one of 'array', 'object',",
                    "a result column number, or column name reference."
                  );
                }
                out2.cbArg = (stmt) => stmt;
                break;
              default:
                if (util.isInt32(opt.rowMode)) {
                  out2.cbArg = (stmt) => stmt.get(opt.rowMode);
                  break;
                } else if ("string" === typeof opt.rowMode && opt.rowMode.length > 1 && "$" === opt.rowMode[0]) {
                  const $colName = opt.rowMode.substr(1);
                  out2.cbArg = (stmt) => {
                    const rc = stmt.get(/* @__PURE__ */ Object.create(null))[$colName];
                    return void 0 === rc ? toss3(
                      capi.SQLITE_NOTFOUND,
                      "exec(): unknown result column:",
                      $colName
                    ) : rc;
                  };
                  break;
                }
                toss3("Invalid rowMode:", opt.rowMode);
            }
          }
          return out2;
        };
        const __selectFirstRow = (db, sql2, bind, ...getArgs) => {
          const stmt = db.prepare(sql2);
          try {
            const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : void 0;
            stmt.reset();
            return rc;
          } finally {
            stmt.finalize();
          }
        };
        const __selectAll = (db, sql2, bind, rowMode) => db.exec({
          sql: sql2,
          bind,
          rowMode,
          returnValue: "resultRows"
        });
        DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);
        DB.prototype = {
          isOpen: function() {
            return !!this.pointer;
          },
          affirmOpen: function() {
            return affirmDbOpen(this);
          },
          close: function() {
            if (this.pointer) {
              if (this.onclose && this.onclose.before instanceof Function) {
                try {
                  this.onclose.before(this);
                } catch (e) {
                }
              }
              const pDb2 = this.pointer;
              Object.keys(__stmtMap.get(this)).forEach((k, s) => {
                if (s && s.pointer) {
                  try {
                    s.finalize();
                  } catch (e) {
                  }
                }
              });
              __ptrMap.delete(this);
              __stmtMap.delete(this);
              capi.sqlite3_close_v2(pDb2);
              if (this.onclose && this.onclose.after instanceof Function) {
                try {
                  this.onclose.after(this);
                } catch (e) {
                }
              }
              delete this.filename;
            }
          },
          changes: function(total = false, sixtyFour = false) {
            const p = affirmDbOpen(this).pointer;
            if (total) {
              return sixtyFour ? capi.sqlite3_total_changes64(p) : capi.sqlite3_total_changes(p);
            } else {
              return sixtyFour ? capi.sqlite3_changes64(p) : capi.sqlite3_changes(p);
            }
          },
          dbFilename: function(dbName = "main") {
            return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
          },
          dbName: function(dbNumber = 0) {
            return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
          },
          dbVfsName: function(dbName = 0) {
            let rc;
            const pVfs = capi.sqlite3_js_db_vfs(
              affirmDbOpen(this).pointer,
              dbName
            );
            if (pVfs) {
              const v2 = new capi.sqlite3_vfs(pVfs);
              try {
                rc = wasm.cstrToJs(v2.$zName);
              } finally {
                v2.dispose();
              }
            }
            return rc;
          },
          prepare: function(sql2) {
            affirmDbOpen(this);
            const stack = wasm.pstack.pointer;
            let ppStmt, pStmt;
            try {
              ppStmt = wasm.pstack.alloc(8);
              DB.checkRc(
                this,
                capi.sqlite3_prepare_v2(this.pointer, sql2, -1, ppStmt, null)
              );
              pStmt = wasm.peekPtr(ppStmt);
            } finally {
              wasm.pstack.restore(stack);
            }
            if (!pStmt) toss3("Cannot prepare empty SQL.");
            const stmt = new Stmt(this, pStmt, BindTypes);
            __stmtMap.get(this)[pStmt] = stmt;
            return stmt;
          },
          exec: function() {
            affirmDbOpen(this);
            const arg = parseExecArgs(this, arguments);
            if (!arg.sql) {
              return toss3("exec() requires an SQL string.");
            }
            const opt = arg.opt;
            const callback = opt.callback;
            const resultRows = Array.isArray(opt.resultRows) ? opt.resultRows : void 0;
            let stmt;
            let bind = opt.bind;
            let evalFirstResult = !!(arg.cbArg || opt.columnNames || resultRows);
            const stack = wasm.scopedAllocPush();
            const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : void 0;
            try {
              const isTA = util.isSQLableTypedArray(arg.sql);
              let sqlByteLen = isTA ? arg.sql.byteLength : wasm.jstrlen(arg.sql);
              const ppStmt = wasm.scopedAlloc(
                2 * wasm.ptrSizeof + (sqlByteLen + 1)
              );
              const pzTail = ppStmt + wasm.ptrSizeof;
              let pSql = pzTail + wasm.ptrSizeof;
              const pSqlEnd = pSql + sqlByteLen;
              if (isTA) wasm.heap8().set(arg.sql, pSql);
              else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
              wasm.poke(pSql + sqlByteLen, 0);
              while (pSql && wasm.peek(pSql, "i8")) {
                wasm.pokePtr([ppStmt, pzTail], 0);
                DB.checkRc(
                  this,
                  capi.sqlite3_prepare_v3(
                    this.pointer,
                    pSql,
                    sqlByteLen,
                    0,
                    ppStmt,
                    pzTail
                  )
                );
                const pStmt = wasm.peekPtr(ppStmt);
                pSql = wasm.peekPtr(pzTail);
                sqlByteLen = pSqlEnd - pSql;
                if (!pStmt) continue;
                if (saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());
                stmt = new Stmt(this, pStmt, BindTypes);
                if (bind && stmt.parameterCount) {
                  stmt.bind(bind);
                  bind = null;
                }
                if (evalFirstResult && stmt.columnCount) {
                  let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;
                  evalFirstResult = false;
                  if (arg.cbArg || resultRows) {
                    const cbArgCache = /* @__PURE__ */ Object.create(null);
                    for (; stmt.step(); stmt._lockedByExec = false) {
                      if (0 === gotColNames++) {
                        stmt.getColumnNames(
                          cbArgCache.columnNames = opt.columnNames || []
                        );
                      }
                      stmt._lockedByExec = true;
                      const row = arg.cbArg(stmt, cbArgCache);
                      if (resultRows) resultRows.push(row);
                      if (callback && false === callback.call(opt, row, stmt)) {
                        break;
                      }
                    }
                    stmt._lockedByExec = false;
                  }
                  if (0 === gotColNames) {
                    stmt.getColumnNames(opt.columnNames);
                  }
                } else {
                  stmt.step();
                }
                stmt.reset().finalize();
                stmt = null;
              }
            } finally {
              wasm.scopedAllocPop(stack);
              if (stmt) {
                delete stmt._lockedByExec;
                stmt.finalize();
              }
            }
            return arg.returnVal();
          },
          createFunction: function f(name, xFunc, opt) {
            const isFunc = (f2) => f2 instanceof Function;
            switch (arguments.length) {
              case 1:
                opt = name;
                name = opt.name;
                xFunc = opt.xFunc || 0;
                break;
              case 2:
                if (!isFunc(xFunc)) {
                  opt = xFunc;
                  xFunc = opt.xFunc || 0;
                }
                break;
            }
            if (!opt) opt = {};
            if ("string" !== typeof name) {
              toss3("Invalid arguments: missing function name.");
            }
            let xStep = opt.xStep || 0;
            let xFinal = opt.xFinal || 0;
            const xValue = opt.xValue || 0;
            const xInverse = opt.xInverse || 0;
            let isWindow = void 0;
            if (isFunc(xFunc)) {
              isWindow = false;
              if (isFunc(xStep) || isFunc(xFinal)) {
                toss3("Ambiguous arguments: scalar or aggregate?");
              }
              xStep = xFinal = null;
            } else if (isFunc(xStep)) {
              if (!isFunc(xFinal)) {
                toss3("Missing xFinal() callback for aggregate or window UDF.");
              }
              xFunc = null;
            } else if (isFunc(xFinal)) {
              toss3("Missing xStep() callback for aggregate or window UDF.");
            } else {
              toss3("Missing function-type properties.");
            }
            if (false === isWindow) {
              if (isFunc(xValue) || isFunc(xInverse)) {
                toss3(
                  "xValue and xInverse are not permitted for non-window UDFs."
                );
              }
            } else if (isFunc(xValue)) {
              if (!isFunc(xInverse)) {
                toss3("xInverse must be provided if xValue is.");
              }
              isWindow = true;
            } else if (isFunc(xInverse)) {
              toss3("xValue must be provided if xInverse is.");
            }
            const pApp = opt.pApp;
            if (void 0 !== pApp && null !== pApp && ("number" !== typeof pApp || !util.isInt32(pApp))) {
              toss3(
                "Invalid value for pApp property. Must be a legal WASM pointer value."
              );
            }
            const xDestroy = opt.xDestroy || 0;
            if (xDestroy && !isFunc(xDestroy)) {
              toss3("xDestroy property must be a function.");
            }
            let fFlags = 0;
            if (getOwnOption(opt, "deterministic"))
              fFlags |= capi.SQLITE_DETERMINISTIC;
            if (getOwnOption(opt, "directOnly"))
              fFlags |= capi.SQLITE_DIRECTONLY;
            if (getOwnOption(opt, "innocuous")) fFlags |= capi.SQLITE_INNOCUOUS;
            name = name.toLowerCase();
            const xArity = xFunc || xStep;
            const arity = getOwnOption(opt, "arity");
            const arityArg = "number" === typeof arity ? arity : xArity.length ? xArity.length - 1 : 0;
            let rc;
            if (isWindow) {
              rc = capi.sqlite3_create_window_function(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy
              );
            } else {
              rc = capi.sqlite3_create_function_v2(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xFunc,
                xStep,
                xFinal,
                xDestroy
              );
            }
            DB.checkRc(this, rc);
            return this;
          },
          selectValue: function(sql2, bind, asType) {
            return __selectFirstRow(this, sql2, bind, 0, asType);
          },
          selectValues: function(sql2, bind, asType) {
            const stmt = this.prepare(sql2), rc = [];
            try {
              stmt.bind(bind);
              while (stmt.step()) rc.push(stmt.get(0, asType));
              stmt.reset();
            } finally {
              stmt.finalize();
            }
            return rc;
          },
          selectArray: function(sql2, bind) {
            return __selectFirstRow(this, sql2, bind, []);
          },
          selectObject: function(sql2, bind) {
            return __selectFirstRow(this, sql2, bind, {});
          },
          selectArrays: function(sql2, bind) {
            return __selectAll(this, sql2, bind, "array");
          },
          selectObjects: function(sql2, bind) {
            return __selectAll(this, sql2, bind, "object");
          },
          openStatementCount: function() {
            return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
          },
          transaction: function(callback) {
            let opener = "BEGIN";
            if (arguments.length > 1) {
              if (/[^a-zA-Z]/.test(arguments[0])) {
                toss3(
                  capi.SQLITE_MISUSE,
                  "Invalid argument for BEGIN qualifier."
                );
              }
              opener += " " + arguments[0];
              callback = arguments[1];
            }
            affirmDbOpen(this).exec(opener);
            try {
              const rc = callback(this);
              this.exec("COMMIT");
              return rc;
            } catch (e) {
              this.exec("ROLLBACK");
              throw e;
            }
          },
          savepoint: function(callback) {
            affirmDbOpen(this).exec("SAVEPOINT oo1");
            try {
              const rc = callback(this);
              this.exec("RELEASE oo1");
              return rc;
            } catch (e) {
              this.exec("ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1");
              throw e;
            }
          },
          checkRc: function(resultCode) {
            return checkSqlite3Rc(this, resultCode);
          }
        };
        const affirmStmtOpen = function(stmt) {
          if (!stmt.pointer) toss3("Stmt has been closed.");
          return stmt;
        };
        const isSupportedBindType = function(v2) {
          let t = BindTypes[null === v2 || void 0 === v2 ? "null" : typeof v2];
          switch (t) {
            case BindTypes.boolean:
            case BindTypes.null:
            case BindTypes.number:
            case BindTypes.string:
              return t;
            case BindTypes.bigint:
              if (wasm.bigIntEnabled) return t;
            default:
              return util.isBindableTypedArray(v2) ? BindTypes.blob : void 0;
          }
        };
        const affirmSupportedBindType = function(v2) {
          return isSupportedBindType(v2) || toss3("Unsupported bind() argument type:", typeof v2);
        };
        const affirmParamIndex = function(stmt, key) {
          const n = "number" === typeof key ? key : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
          if (0 === n || !util.isInt32(n)) {
            toss3("Invalid bind() parameter name: " + key);
          } else if (n < 1 || n > stmt.parameterCount)
            toss3("Bind index", key, "is out of range.");
          return n;
        };
        const affirmNotLockedByExec = function(stmt, currentOpName) {
          if (stmt._lockedByExec) {
            toss3(
              "Operation is illegal when statement is locked:",
              currentOpName
            );
          }
          return stmt;
        };
        const bindOne = function f(stmt, ndx, bindType, val) {
          affirmNotLockedByExec(affirmStmtOpen(stmt), "bind()");
          if (!f._) {
            f._tooBigInt = (v2) => toss3(
              "BigInt value is too big to store without precision loss:",
              v2
            );
            f._ = {
              string: function(stmt2, ndx2, val2, asBlob) {
                const [pStr, n] = wasm.allocCString(val2, true);
                const f2 = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;
                return f2(stmt2.pointer, ndx2, pStr, n, capi.SQLITE_WASM_DEALLOC);
              }
            };
          }
          affirmSupportedBindType(val);
          ndx = affirmParamIndex(stmt, ndx);
          let rc = 0;
          switch (null === val || void 0 === val ? BindTypes.null : bindType) {
            case BindTypes.null:
              rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
              break;
            case BindTypes.string:
              rc = f._.string(stmt, ndx, val, false);
              break;
            case BindTypes.number: {
              let m;
              if (util.isInt32(val)) m = capi.sqlite3_bind_int;
              else if ("bigint" === typeof val) {
                if (!util.bigIntFits64(val)) {
                  f._tooBigInt(val);
                } else if (wasm.bigIntEnabled) {
                  m = capi.sqlite3_bind_int64;
                } else if (util.bigIntFitsDouble(val)) {
                  val = Number(val);
                  m = capi.sqlite3_bind_double;
                } else {
                  f._tooBigInt(val);
                }
              } else {
                val = Number(val);
                if (wasm.bigIntEnabled && Number.isInteger(val)) {
                  m = capi.sqlite3_bind_int64;
                } else {
                  m = capi.sqlite3_bind_double;
                }
              }
              rc = m(stmt.pointer, ndx, val);
              break;
            }
            case BindTypes.boolean:
              rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
              break;
            case BindTypes.blob: {
              if ("string" === typeof val) {
                rc = f._.string(stmt, ndx, val, true);
                break;
              } else if (val instanceof ArrayBuffer) {
                val = new Uint8Array(val);
              } else if (!util.isBindableTypedArray(val)) {
                toss3(
                  "Binding a value as a blob requires",
                  "that it be a string, Uint8Array, Int8Array, or ArrayBuffer."
                );
              }
              const pBlob = wasm.alloc(val.byteLength || 1);
              wasm.heap8().set(val.byteLength ? val : [0], pBlob);
              rc = capi.sqlite3_bind_blob(
                stmt.pointer,
                ndx,
                pBlob,
                val.byteLength,
                capi.SQLITE_WASM_DEALLOC
              );
              break;
            }
            default:
              sqlite32.config.warn("Unsupported bind() argument type:", val);
              toss3("Unsupported bind() argument type: " + typeof val);
          }
          if (rc) DB.checkRc(stmt.db.pointer, rc);
          stmt._mayGet = false;
          return stmt;
        };
        Stmt.prototype = {
          finalize: function() {
            if (this.pointer) {
              affirmNotLockedByExec(this, "finalize()");
              const rc = capi.sqlite3_finalize(this.pointer);
              delete __stmtMap.get(this.db)[this.pointer];
              __ptrMap.delete(this);
              delete this._mayGet;
              delete this.parameterCount;
              delete this._lockedByExec;
              delete this.db;
              return rc;
            }
          },
          clearBindings: function() {
            affirmNotLockedByExec(affirmStmtOpen(this), "clearBindings()");
            capi.sqlite3_clear_bindings(this.pointer);
            this._mayGet = false;
            return this;
          },
          reset: function(alsoClearBinds) {
            affirmNotLockedByExec(this, "reset()");
            if (alsoClearBinds) this.clearBindings();
            const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
            this._mayGet = false;
            checkSqlite3Rc(this.db, rc);
            return this;
          },
          bind: function() {
            affirmStmtOpen(this);
            let ndx, arg;
            switch (arguments.length) {
              case 1:
                ndx = 1;
                arg = arguments[0];
                break;
              case 2:
                ndx = arguments[0];
                arg = arguments[1];
                break;
              default:
                toss3("Invalid bind() arguments.");
            }
            if (void 0 === arg) {
              return this;
            } else if (!this.parameterCount) {
              toss3("This statement has no bindable parameters.");
            }
            this._mayGet = false;
            if (null === arg) {
              return bindOne(this, ndx, BindTypes.null, arg);
            } else if (Array.isArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  "When binding an array, an index argument is not permitted."
                );
              }
              arg.forEach(
                (v2, i) => bindOne(this, i + 1, affirmSupportedBindType(v2), v2)
              );
              return this;
            } else if (arg instanceof ArrayBuffer) {
              arg = new Uint8Array(arg);
            }
            if ("object" === typeof arg && !util.isBindableTypedArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  "When binding an object, an index argument is not permitted."
                );
              }
              Object.keys(arg).forEach(
                (k) => bindOne(this, k, affirmSupportedBindType(arg[k]), arg[k])
              );
              return this;
            } else {
              return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
            }
          },
          bindAsBlob: function(ndx, arg) {
            affirmStmtOpen(this);
            if (1 === arguments.length) {
              arg = ndx;
              ndx = 1;
            }
            const t = affirmSupportedBindType(arg);
            if (BindTypes.string !== t && BindTypes.blob !== t && BindTypes.null !== t) {
              toss3("Invalid value type for bindAsBlob()");
            }
            return bindOne(this, ndx, BindTypes.blob, arg);
          },
          step: function() {
            affirmNotLockedByExec(this, "step()");
            const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
            switch (rc) {
              case capi.SQLITE_DONE:
                return this._mayGet = false;
              case capi.SQLITE_ROW:
                return this._mayGet = true;
              default:
                this._mayGet = false;
                sqlite32.config.warn(
                  "sqlite3_step() rc=",
                  rc,
                  capi.sqlite3_js_rc_str(rc),
                  "SQL =",
                  capi.sqlite3_sql(this.pointer)
                );
                DB.checkRc(this.db.pointer, rc);
            }
          },
          stepReset: function() {
            this.step();
            return this.reset();
          },
          stepFinalize: function() {
            try {
              const rc = this.step();
              this.reset();
              return rc;
            } finally {
              try {
                this.finalize();
              } catch (e) {
              }
            }
          },
          get: function(ndx, asType) {
            if (!affirmStmtOpen(this)._mayGet) {
              toss3("Stmt.step() has not (recently) returned true.");
            }
            if (Array.isArray(ndx)) {
              let i = 0;
              const n = this.columnCount;
              while (i < n) {
                ndx[i] = this.get(i++);
              }
              return ndx;
            } else if (ndx && "object" === typeof ndx) {
              let i = 0;
              const n = this.columnCount;
              while (i < n) {
                ndx[capi.sqlite3_column_name(this.pointer, i)] = this.get(i++);
              }
              return ndx;
            }
            affirmColIndex(this, ndx);
            switch (void 0 === asType ? capi.sqlite3_column_type(this.pointer, ndx) : asType) {
              case capi.SQLITE_NULL:
                return null;
              case capi.SQLITE_INTEGER: {
                if (wasm.bigIntEnabled) {
                  const rc = capi.sqlite3_column_int64(this.pointer, ndx);
                  if (rc >= Number.MIN_SAFE_INTEGER && rc <= Number.MAX_SAFE_INTEGER) {
                    return Number(rc).valueOf();
                  }
                  return rc;
                } else {
                  const rc = capi.sqlite3_column_double(this.pointer, ndx);
                  if (rc > Number.MAX_SAFE_INTEGER || rc < Number.MIN_SAFE_INTEGER) {
                    toss3(
                      "Integer is out of range for JS integer range: " + rc
                    );
                  }
                  return util.isInt32(rc) ? rc | 0 : rc;
                }
              }
              case capi.SQLITE_FLOAT:
                return capi.sqlite3_column_double(this.pointer, ndx);
              case capi.SQLITE_TEXT:
                return capi.sqlite3_column_text(this.pointer, ndx);
              case capi.SQLITE_BLOB: {
                const n = capi.sqlite3_column_bytes(this.pointer, ndx), ptr = capi.sqlite3_column_blob(this.pointer, ndx), rc = new Uint8Array(n);
                if (n) rc.set(wasm.heap8u().slice(ptr, ptr + n), 0);
                if (n && this.db._blobXfer instanceof Array) {
                  this.db._blobXfer.push(rc.buffer);
                }
                return rc;
              }
              default:
                toss3(
                  "Don't know how to translate",
                  "type of result column #" + ndx + "."
                );
            }
            toss3("Not reached.");
          },
          getInt: function(ndx) {
            return this.get(ndx, capi.SQLITE_INTEGER);
          },
          getFloat: function(ndx) {
            return this.get(ndx, capi.SQLITE_FLOAT);
          },
          getString: function(ndx) {
            return this.get(ndx, capi.SQLITE_TEXT);
          },
          getBlob: function(ndx) {
            return this.get(ndx, capi.SQLITE_BLOB);
          },
          getJSON: function(ndx) {
            const s = this.get(ndx, capi.SQLITE_STRING);
            return null === s ? s : JSON.parse(s);
          },
          getColumnName: function(ndx) {
            return capi.sqlite3_column_name(
              affirmColIndex(affirmStmtOpen(this), ndx).pointer,
              ndx
            );
          },
          getColumnNames: function(tgt = []) {
            affirmColIndex(affirmStmtOpen(this), 0);
            const n = this.columnCount;
            for (let i = 0; i < n; ++i) {
              tgt.push(capi.sqlite3_column_name(this.pointer, i));
            }
            return tgt;
          },
          getParamIndex: function(name) {
            return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_index(this.pointer, name) : void 0;
          },
          getParamName: function(ndx) {
            return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_name(this.pointer, ndx) : void 0;
          },
          isBusy: function() {
            return 0 !== capi.sqlite3_stmt_busy(affirmStmtOpen(this));
          },
          isReadOnly: function() {
            return 0 !== capi.sqlite3_stmt_readonly(affirmStmtOpen(this));
          }
        };
        {
          const prop = {
            enumerable: true,
            get: function() {
              return __ptrMap.get(this);
            },
            set: () => toss3("The pointer property is read-only.")
          };
          Object.defineProperty(Stmt.prototype, "pointer", prop);
          Object.defineProperty(DB.prototype, "pointer", prop);
        }
        Object.defineProperty(Stmt.prototype, "columnCount", {
          enumerable: false,
          get: function() {
            return capi.sqlite3_column_count(this.pointer);
          },
          set: () => toss3("The columnCount property is read-only.")
        });
        sqlite32.oo1 = {
          DB,
          Stmt
        };
        if (util.isUIThread()) {
          sqlite32.oo1.JsStorageDb = function(storageName = "session") {
            const opt = dbCtorHelper.normalizeArgs(...arguments);
            storageName = opt.filename;
            if ("session" !== storageName && "local" !== storageName) {
              toss3("JsStorageDb db name must be one of 'session' or 'local'.");
            }
            opt.vfs = "kvvfs";
            dbCtorHelper.call(this, opt);
          };
          const jdb = sqlite32.oo1.JsStorageDb;
          jdb.prototype = Object.create(DB.prototype);
          jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;
          jdb.prototype.clearStorage = function() {
            return jdb.clearStorage(affirmDbOpen(this).filename);
          };
          jdb.storageSize = capi.sqlite3_js_kvvfs_size;
          jdb.prototype.storageSize = function() {
            return jdb.storageSize(affirmDbOpen(this).filename);
          };
        }
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const util = sqlite32.util;
        sqlite32.initWorker1API = function() {
          const toss = (...args) => {
            throw new Error(args.join(" "));
          };
          if (!(globalThis.WorkerGlobalScope instanceof Function)) {
            toss("initWorker1API() must be run from a Worker thread.");
          }
          const sqlite33 = this.sqlite3 || toss("Missing this.sqlite3 object.");
          const DB = sqlite33.oo1.DB;
          const getDbId = function(db) {
            let id = wState.idMap.get(db);
            if (id) return id;
            id = "db#" + ++wState.idSeq + "@" + db.pointer;
            wState.idMap.set(db, id);
            return id;
          };
          const wState = {
            dbList: [],
            idSeq: 0,
            idMap: /* @__PURE__ */ new WeakMap(),
            xfer: [],
            open: function(opt) {
              const db = new DB(opt);
              this.dbs[getDbId(db)] = db;
              if (this.dbList.indexOf(db) < 0) this.dbList.push(db);
              return db;
            },
            close: function(db, alsoUnlink) {
              if (db) {
                delete this.dbs[getDbId(db)];
                const filename = db.filename;
                const pVfs = util.sqlite3__wasm_db_vfs(db.pointer, 0);
                db.close();
                const ddNdx = this.dbList.indexOf(db);
                if (ddNdx >= 0) this.dbList.splice(ddNdx, 1);
                if (alsoUnlink && filename && pVfs) {
                  util.sqlite3__wasm_vfs_unlink(pVfs, filename);
                }
              }
            },
            post: function(msg, xferList) {
              if (xferList && xferList.length) {
                globalThis.postMessage(msg, Array.from(xferList));
                xferList.length = 0;
              } else {
                globalThis.postMessage(msg);
              }
            },
            dbs: /* @__PURE__ */ Object.create(null),
            getDb: function(id, require2 = true) {
              return this.dbs[id] || (require2 ? toss("Unknown (or closed) DB ID:", id) : void 0);
            }
          };
          const affirmDbOpen = function(db = wState.dbList[0]) {
            return db && db.pointer ? db : toss("DB is not opened.");
          };
          const getMsgDb = function(msgData, affirmExists = true) {
            const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];
            return affirmExists ? affirmDbOpen(db) : db;
          };
          const getDefaultDbId = function() {
            return wState.dbList[0] && getDbId(wState.dbList[0]);
          };
          const wMsgHandler = {
            open: function(ev) {
              const oargs = /* @__PURE__ */ Object.create(null), args = ev.args || /* @__PURE__ */ Object.create(null);
              if (args.simulateError) {
                toss("Throwing because of simulateError flag.");
              }
              const rc = /* @__PURE__ */ Object.create(null);
              oargs.vfs = args.vfs;
              oargs.filename = args.filename || "";
              const db = wState.open(oargs);
              rc.filename = db.filename;
              rc.persistent = !!sqlite33.capi.sqlite3_js_db_uses_vfs(
                db.pointer,
                "opfs"
              );
              rc.dbId = getDbId(db);
              rc.vfs = db.dbVfsName();
              return rc;
            },
            close: function(ev) {
              const db = getMsgDb(ev, false);
              const response = {
                filename: db && db.filename
              };
              if (db) {
                const doUnlink = ev.args && "object" === typeof ev.args ? !!ev.args.unlink : false;
                wState.close(db, doUnlink);
              }
              return response;
            },
            exec: function(ev) {
              const rc = "string" === typeof ev.args ? { sql: ev.args } : ev.args || /* @__PURE__ */ Object.create(null);
              if ("stmt" === rc.rowMode) {
                toss(
                  "Invalid rowMode for 'exec': stmt mode",
                  "does not work in the Worker API."
                );
              } else if (!rc.sql) {
                toss("'exec' requires input SQL.");
              }
              const db = getMsgDb(ev);
              if (rc.callback || Array.isArray(rc.resultRows)) {
                db._blobXfer = wState.xfer;
              }
              const theCallback = rc.callback;
              let rowNumber = 0;
              const hadColNames = !!rc.columnNames;
              if ("string" === typeof theCallback) {
                if (!hadColNames) rc.columnNames = [];
                rc.callback = function(row, stmt) {
                  wState.post(
                    {
                      type: theCallback,
                      columnNames: rc.columnNames,
                      rowNumber: ++rowNumber,
                      row
                    },
                    wState.xfer
                  );
                };
              }
              try {
                const changeCount = !!rc.countChanges ? db.changes(true, 64 === rc.countChanges) : void 0;
                db.exec(rc);
                if (void 0 !== changeCount) {
                  rc.changeCount = db.changes(true, 64 === rc.countChanges) - changeCount;
                }
                if (rc.callback instanceof Function) {
                  rc.callback = theCallback;
                  wState.post({
                    type: theCallback,
                    columnNames: rc.columnNames,
                    rowNumber: null,
                    row: void 0
                  });
                }
              } finally {
                delete db._blobXfer;
                if (rc.callback) rc.callback = theCallback;
              }
              return rc;
            },
            "config-get": function() {
              const rc = /* @__PURE__ */ Object.create(null), src = sqlite33.config;
              ["bigIntEnabled"].forEach(function(k) {
                if (Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];
              });
              rc.version = sqlite33.version;
              rc.vfsList = sqlite33.capi.sqlite3_js_vfs_list();
              return rc;
            },
            export: function(ev) {
              const db = getMsgDb(ev);
              const response = {
                byteArray: sqlite33.capi.sqlite3_js_db_export(db.pointer),
                filename: db.filename,
                mimetype: "application/x-sqlite3"
              };
              wState.xfer.push(response.byteArray.buffer);
              return response;
            },
            toss: function(ev) {
              toss("Testing worker exception");
            }
          };
          globalThis.onmessage = async function(ev) {
            ev = ev.data;
            let result, dbId = ev.dbId, evType = ev.type;
            const arrivalTime = performance.now();
            try {
              if (wMsgHandler.hasOwnProperty(evType) && wMsgHandler[evType] instanceof Function) {
                result = await wMsgHandler[evType](ev);
              } else {
                toss("Unknown db worker message type:", ev.type);
              }
            } catch (err2) {
              evType = "error";
              result = {
                operation: ev.type,
                message: err2.message,
                errorClass: err2.name,
                input: ev
              };
              if (err2.stack) {
                result.stack = "string" === typeof err2.stack ? err2.stack.split(/\n\s*/) : err2.stack;
              }
            }
            if (!dbId) {
              dbId = result.dbId || getDefaultDbId();
            }
            wState.post(
              {
                type: evType,
                dbId,
                messageId: ev.messageId,
                workerReceivedTime: arrivalTime,
                workerRespondTime: performance.now(),
                departureTime: ev.departureTime,
                result
              },
              wState.xfer
            );
          };
          globalThis.postMessage({
            type: "sqlite3-api",
            result: "worker1-ready"
          });
        }.bind({ sqlite3: sqlite32 });
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const wasm = sqlite32.wasm, capi = sqlite32.capi, toss = sqlite32.util.toss3;
        const vfs = /* @__PURE__ */ Object.create(null);
        sqlite32.vfs = vfs;
        capi.sqlite3_vfs.prototype.registerVfs = function(asDefault = false) {
          if (!(this instanceof sqlite32.capi.sqlite3_vfs)) {
            toss("Expecting a sqlite3_vfs-type argument.");
          }
          const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
          if (rc) {
            toss("sqlite3_vfs_register(", this, ") failed with rc", rc);
          }
          if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {
            toss(
              "BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS",
              this
            );
          }
          return this;
        };
        vfs.installVfs = function(opt) {
          let count = 0;
          const propList = ["io", "vfs"];
          for (const key of propList) {
            const o = opt[key];
            if (o) {
              ++count;
              o.struct.installMethods(o.methods, !!o.applyArgcCheck);
              if ("vfs" === key) {
                if (!o.struct.$zName && "string" === typeof o.name) {
                  o.struct.addOnDispose(
                    o.struct.$zName = wasm.allocCString(o.name)
                  );
                }
                o.struct.registerVfs(!!o.asDefault);
              }
            }
          }
          if (!count)
            toss(
              "Misuse: installVfs() options object requires at least",
              "one of:",
              propList
            );
          return this;
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        if (!sqlite32.wasm.exports.sqlite3_declare_vtab) {
          return;
        }
        const wasm = sqlite32.wasm, capi = sqlite32.capi, toss = sqlite32.util.toss3;
        const vtab = /* @__PURE__ */ Object.create(null);
        sqlite32.vtab = vtab;
        const sii = capi.sqlite3_index_info;
        sii.prototype.nthConstraint = function(n, asPtr = false) {
          if (n < 0 || n >= this.$nConstraint) return false;
          const ptr = this.$aConstraint + sii.sqlite3_index_constraint.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
        };
        sii.prototype.nthConstraintUsage = function(n, asPtr = false) {
          if (n < 0 || n >= this.$nConstraint) return false;
          const ptr = this.$aConstraintUsage + sii.sqlite3_index_constraint_usage.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
        };
        sii.prototype.nthOrderBy = function(n, asPtr = false) {
          if (n < 0 || n >= this.$nOrderBy) return false;
          const ptr = this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n;
          return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
        };
        const __xWrapFactory = function(methodName, StructType) {
          return function(ptr, removeMapping = false) {
            if (0 === arguments.length) ptr = new StructType();
            if (ptr instanceof StructType) {
              this.set(ptr.pointer, ptr);
              return ptr;
            } else if (!wasm.isPtr(ptr)) {
              sqlite32.SQLite3Error.toss(
                "Invalid argument to",
                methodName + "()"
              );
            }
            let rc = this.get(ptr);
            if (removeMapping) this.delete(ptr);
            return rc;
          }.bind(/* @__PURE__ */ new Map());
        };
        const StructPtrMapper = function(name, StructType) {
          const __xWrap = __xWrapFactory(name, StructType);
          return Object.assign(/* @__PURE__ */ Object.create(null), {
            StructType,
            create: (ppOut) => {
              const rc = __xWrap();
              wasm.pokePtr(ppOut, rc.pointer);
              return rc;
            },
            get: (pCObj) => __xWrap(pCObj),
            unget: (pCObj) => __xWrap(pCObj, true),
            dispose: (pCObj) => {
              const o = __xWrap(pCObj, true);
              if (o) o.dispose();
            }
          });
        };
        vtab.xVtab = StructPtrMapper("xVtab", capi.sqlite3_vtab);
        vtab.xCursor = StructPtrMapper("xCursor", capi.sqlite3_vtab_cursor);
        vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);
        vtab.xError = function f(methodName, err2, defaultRc) {
          if (f.errorReporter instanceof Function) {
            try {
              f.errorReporter(
                "sqlite3_module::" + methodName + "(): " + err2.message
              );
            } catch (e) {
            }
          }
          let rc;
          if (err2 instanceof sqlite32.WasmAllocError) rc = capi.SQLITE_NOMEM;
          else if (arguments.length > 2) rc = defaultRc;
          else if (err2 instanceof sqlite32.SQLite3Error) rc = err2.resultCode;
          return rc || capi.SQLITE_ERROR;
        };
        vtab.xError.errorReporter = console.error.bind(console) ;
        vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, "i64");
        vtab.setupModule = function(opt) {
          let createdMod = false;
          const mod = this instanceof capi.sqlite3_module ? this : opt.struct || (createdMod = new capi.sqlite3_module());
          try {
            const methods = opt.methods || toss("Missing 'methods' object.");
            for (const e of Object.entries({
              xConnect: "xCreate",
              xDisconnect: "xDestroy"
            })) {
              const k = e[0], v2 = e[1];
              if (true === methods[k]) methods[k] = methods[v2];
              else if (true === methods[v2]) methods[v2] = methods[k];
            }
            if (opt.catchExceptions) {
              const fwrap = function(methodName, func) {
                if (["xConnect", "xCreate"].indexOf(methodName) >= 0) {
                  return function(pDb2, pAux, argc, argv, ppVtab, pzErr) {
                    try {
                      return func(...arguments) || 0;
                    } catch (e) {
                      if (!(e instanceof sqlite32.WasmAllocError)) {
                        wasm.dealloc(wasm.peekPtr(pzErr));
                        wasm.pokePtr(pzErr, wasm.allocCString(e.message));
                      }
                      return vtab.xError(methodName, e);
                    }
                  };
                } else {
                  return function(...args) {
                    try {
                      return func(...args) || 0;
                    } catch (e) {
                      return vtab.xError(methodName, e);
                    }
                  };
                }
              };
              const mnames = [
                "xCreate",
                "xConnect",
                "xBestIndex",
                "xDisconnect",
                "xDestroy",
                "xOpen",
                "xClose",
                "xFilter",
                "xNext",
                "xEof",
                "xColumn",
                "xRowid",
                "xUpdate",
                "xBegin",
                "xSync",
                "xCommit",
                "xRollback",
                "xFindFunction",
                "xRename",
                "xSavepoint",
                "xRelease",
                "xRollbackTo",
                "xShadowName"
              ];
              const remethods = /* @__PURE__ */ Object.create(null);
              for (const k of mnames) {
                const m = methods[k];
                if (!(m instanceof Function)) continue;
                else if ("xConnect" === k && methods.xCreate === m) {
                  remethods[k] = methods.xCreate;
                } else if ("xCreate" === k && methods.xConnect === m) {
                  remethods[k] = methods.xConnect;
                } else {
                  remethods[k] = fwrap(k, m);
                }
              }
              mod.installMethods(remethods, false);
            } else {
              mod.installMethods(methods, !!opt.applyArgcCheck);
            }
            if (0 === mod.$iVersion) {
              let v2;
              if ("number" === typeof opt.iVersion) v2 = opt.iVersion;
              else if (mod.$xShadowName) v2 = 3;
              else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)
                v2 = 2;
              else v2 = 1;
              mod.$iVersion = v2;
            }
          } catch (e) {
            if (createdMod) createdMod.dispose();
            throw e;
          }
          return mod;
        };
        capi.sqlite3_module.prototype.setupModule = function(opt) {
          return vtab.setupModule.call(this, opt);
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        const installOpfsVfs = function callee2(options) {
          var _a;
          if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {
            return Promise.reject(
              new Error(
                "Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. The server must emit the COOP/COEP response headers to enable those. See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep"
              )
            );
          } else if ("undefined" === typeof WorkerGlobalScope) {
            return Promise.reject(
              new Error(
                "The OPFS sqlite3_vfs cannot run in the main thread because it requires Atomics.wait()."
              )
            );
          } else if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !((_a = navigator == null ? void 0 : navigator.storage) == null ? void 0 : _a.getDirectory)) {
            return Promise.reject(new Error("Missing required OPFS APIs."));
          }
          if (!options || "object" !== typeof options) {
            options = /* @__PURE__ */ Object.create(null);
          }
          const urlParams = new URL(globalThis.location.href).searchParams;
          if (urlParams.has("opfs-disable")) {
            return Promise.resolve(sqlite32);
          }
          if (void 0 === options.verbose) {
            options.verbose = urlParams.has("opfs-verbose") ? +urlParams.get("opfs-verbose") || 2 : 1;
          }
          if (void 0 === options.sanityChecks) {
            options.sanityChecks = urlParams.has("opfs-sanity-check");
          }
          if (void 0 === options.proxyUri) {
            options.proxyUri = callee2.defaultProxyUri;
          }
          if ("function" === typeof options.proxyUri) {
            options.proxyUri = options.proxyUri();
          }
          const thePromise = new Promise(function(promiseResolve_, promiseReject_) {
            const loggers = [
              sqlite32.config.error,
              sqlite32.config.warn,
              sqlite32.config.log
            ];
            const logImpl = (level, ...args) => {
              if (options.verbose > level)
                loggers[level]("OPFS syncer:", ...args);
            };
            const log = (...args) => logImpl(2, ...args);
            const warn = (...args) => logImpl(1, ...args);
            const error = (...args) => logImpl(0, ...args);
            const toss = sqlite32.util.toss;
            const capi = sqlite32.capi;
            const util = sqlite32.util;
            const wasm = sqlite32.wasm;
            const sqlite3_vfs = capi.sqlite3_vfs;
            const sqlite3_file = capi.sqlite3_file;
            const sqlite3_io_methods = capi.sqlite3_io_methods;
            const opfsUtil = /* @__PURE__ */ Object.create(null);
            const thisThreadHasOPFS = () => {
              var _a2;
              return globalThis.FileSystemHandle && globalThis.FileSystemDirectoryHandle && globalThis.FileSystemFileHandle && globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle && ((_a2 = navigator == null ? void 0 : navigator.storage) == null ? void 0 : _a2.getDirectory);
            };
            opfsUtil.metrics = {
              dump: function() {
                let k, n = 0, t = 0, w = 0;
                for (k in state.opIds) {
                  const m = metrics[k];
                  n += m.count;
                  t += m.time;
                  w += m.wait;
                  m.avgTime = m.count && m.time ? m.time / m.count : 0;
                  m.avgWait = m.count && m.wait ? m.wait / m.count : 0;
                }
                sqlite32.config.log(
                  globalThis.location.href,
                  "metrics for",
                  globalThis.location.href,
                  ":",
                  metrics,
                  "\nTotal of",
                  n,
                  "op(s) for",
                  t,
                  "ms (incl. " + w + " ms of waiting on the async side)"
                );
                sqlite32.config.log("Serialization metrics:", metrics.s11n);
                W.postMessage({ type: "opfs-async-metrics" });
              },
              reset: function() {
                let k;
                const r = (m) => m.count = m.time = m.wait = 0;
                for (k in state.opIds) {
                  r(metrics[k] = /* @__PURE__ */ Object.create(null));
                }
                let s = metrics.s11n = /* @__PURE__ */ Object.create(null);
                s = s.serialize = /* @__PURE__ */ Object.create(null);
                s.count = s.time = 0;
                s = metrics.s11n.deserialize = /* @__PURE__ */ Object.create(null);
                s.count = s.time = 0;
              }
            };
            const opfsIoMethods = new sqlite3_io_methods();
            const opfsVfs = new sqlite3_vfs().addOnDispose(
              () => opfsIoMethods.dispose()
            );
            let promiseWasRejected = void 0;
            const promiseReject = (err2) => {
              promiseWasRejected = true;
              opfsVfs.dispose();
              return promiseReject_(err2);
            };
            const promiseResolve = () => {
              promiseWasRejected = false;
              return promiseResolve_(sqlite32);
            };
            const W = new Worker(
              new URL("sqlite3-opfs-async-proxy.js", import_meta.url)
            );
            setTimeout(() => {
              if (void 0 === promiseWasRejected) {
                promiseReject(
                  new Error(
                    "Timeout while waiting for OPFS async proxy worker."
                  )
                );
              }
            }, 4e3);
            W._originalOnError = W.onerror;
            W.onerror = function(err2) {
              error("Error initializing OPFS asyncer:", err2);
              promiseReject(
                new Error(
                  "Loading OPFS async Worker failed for unknown reasons."
                )
              );
            };
            const pDVfs = capi.sqlite3_vfs_find(null);
            const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;
            opfsIoMethods.$iVersion = 1;
            opfsVfs.$iVersion = 2;
            opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
            opfsVfs.$mxPathname = 1024;
            opfsVfs.$zName = wasm.allocCString("opfs");
            opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;
            opfsVfs.addOnDispose(
              "$zName",
              opfsVfs.$zName,
              "cleanup default VFS wrapper",
              () => dVfs ? dVfs.dispose() : null
            );
            const state = /* @__PURE__ */ Object.create(null);
            state.verbose = options.verbose;
            state.littleEndian = (() => {
              const buffer = new ArrayBuffer(2);
              new DataView(buffer).setInt16(0, 256, true);
              return new Int16Array(buffer)[0] === 256;
            })();
            state.asyncIdleWaitTime = 150;
            state.asyncS11nExceptions = 1;
            state.fileBufferSize = 1024 * 64;
            state.sabS11nOffset = state.fileBufferSize;
            state.sabS11nSize = opfsVfs.$mxPathname * 2;
            state.sabIO = new SharedArrayBuffer(
              state.fileBufferSize + state.sabS11nSize
            );
            state.opIds = /* @__PURE__ */ Object.create(null);
            const metrics = /* @__PURE__ */ Object.create(null);
            {
              let i = 0;
              state.opIds.whichOp = i++;
              state.opIds.rc = i++;
              state.opIds.xAccess = i++;
              state.opIds.xClose = i++;
              state.opIds.xDelete = i++;
              state.opIds.xDeleteNoWait = i++;
              state.opIds.xFileSize = i++;
              state.opIds.xLock = i++;
              state.opIds.xOpen = i++;
              state.opIds.xRead = i++;
              state.opIds.xSleep = i++;
              state.opIds.xSync = i++;
              state.opIds.xTruncate = i++;
              state.opIds.xUnlock = i++;
              state.opIds.xWrite = i++;
              state.opIds.mkdir = i++;
              state.opIds["opfs-async-metrics"] = i++;
              state.opIds["opfs-async-shutdown"] = i++;
              state.opIds.retry = i++;
              state.sabOP = new SharedArrayBuffer(i * 4);
              opfsUtil.metrics.reset();
            }
            state.sq3Codes = /* @__PURE__ */ Object.create(null);
            [
              "SQLITE_ACCESS_EXISTS",
              "SQLITE_ACCESS_READWRITE",
              "SQLITE_BUSY",
              "SQLITE_CANTOPEN",
              "SQLITE_ERROR",
              "SQLITE_IOERR",
              "SQLITE_IOERR_ACCESS",
              "SQLITE_IOERR_CLOSE",
              "SQLITE_IOERR_DELETE",
              "SQLITE_IOERR_FSYNC",
              "SQLITE_IOERR_LOCK",
              "SQLITE_IOERR_READ",
              "SQLITE_IOERR_SHORT_READ",
              "SQLITE_IOERR_TRUNCATE",
              "SQLITE_IOERR_UNLOCK",
              "SQLITE_IOERR_WRITE",
              "SQLITE_LOCK_EXCLUSIVE",
              "SQLITE_LOCK_NONE",
              "SQLITE_LOCK_PENDING",
              "SQLITE_LOCK_RESERVED",
              "SQLITE_LOCK_SHARED",
              "SQLITE_LOCKED",
              "SQLITE_MISUSE",
              "SQLITE_NOTFOUND",
              "SQLITE_OPEN_CREATE",
              "SQLITE_OPEN_DELETEONCLOSE",
              "SQLITE_OPEN_MAIN_DB",
              "SQLITE_OPEN_READONLY"
            ].forEach((k) => {
              if (void 0 === (state.sq3Codes[k] = capi[k])) {
                toss("Maintenance required: not found:", k);
              }
            });
            state.opfsFlags = Object.assign(/* @__PURE__ */ Object.create(null), {
              OPFS_UNLOCK_ASAP: 1,
              OPFS_UNLINK_BEFORE_OPEN: 2,
              defaultUnlockAsap: false
            });
            const opRun = (op, ...args) => {
              const opNdx = state.opIds[op] || toss("Invalid op ID:", op);
              state.s11n.serialize(...args);
              Atomics.store(state.sabOPView, state.opIds.rc, -1);
              Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
              Atomics.notify(state.sabOPView, state.opIds.whichOp);
              const t = performance.now();
              while ("not-equal" !== Atomics.wait(state.sabOPView, state.opIds.rc, -1)) {
              }
              const rc = Atomics.load(state.sabOPView, state.opIds.rc);
              metrics[op].wait += performance.now() - t;
              if (rc && state.asyncS11nExceptions) {
                const err2 = state.s11n.deserialize();
                if (err2) error(op + "() async error:", ...err2);
              }
              return rc;
            };
            opfsUtil.debug = {
              asyncShutdown: () => {
                warn(
                  "Shutting down OPFS async listener. The OPFS VFS will no longer work."
                );
                opRun("opfs-async-shutdown");
              },
              asyncRestart: () => {
                warn(
                  "Attempting to restart OPFS VFS async listener. Might work, might not."
                );
                W.postMessage({ type: "opfs-async-restart" });
              }
            };
            const initS11n = () => {
              if (state.s11n) return state.s11n;
              const textDecoder = new TextDecoder(), textEncoder = new TextEncoder("utf-8"), viewU8 = new Uint8Array(
                state.sabIO,
                state.sabS11nOffset,
                state.sabS11nSize
              ), viewDV = new DataView(
                state.sabIO,
                state.sabS11nOffset,
                state.sabS11nSize
              );
              state.s11n = /* @__PURE__ */ Object.create(null);
              const TypeIds = /* @__PURE__ */ Object.create(null);
              TypeIds.number = {
                id: 1,
                size: 8,
                getter: "getFloat64",
                setter: "setFloat64"
              };
              TypeIds.bigint = {
                id: 2,
                size: 8,
                getter: "getBigInt64",
                setter: "setBigInt64"
              };
              TypeIds.boolean = {
                id: 3,
                size: 4,
                getter: "getInt32",
                setter: "setInt32"
              };
              TypeIds.string = { id: 4 };
              const getTypeId = (v2) => TypeIds[typeof v2] || toss(
                "Maintenance required: this value type cannot be serialized.",
                v2
              );
              const getTypeIdById = (tid) => {
                switch (tid) {
                  case TypeIds.number.id:
                    return TypeIds.number;
                  case TypeIds.bigint.id:
                    return TypeIds.bigint;
                  case TypeIds.boolean.id:
                    return TypeIds.boolean;
                  case TypeIds.string.id:
                    return TypeIds.string;
                  default:
                    toss("Invalid type ID:", tid);
                }
              };
              state.s11n.deserialize = function(clear = false) {
                ++metrics.s11n.deserialize.count;
                const t = performance.now();
                const argc = viewU8[0];
                const rc = argc ? [] : null;
                if (argc) {
                  const typeIds = [];
                  let offset = 1, i, n, v2;
                  for (i = 0; i < argc; ++i, ++offset) {
                    typeIds.push(getTypeIdById(viewU8[offset]));
                  }
                  for (i = 0; i < argc; ++i) {
                    const t2 = typeIds[i];
                    if (t2.getter) {
                      v2 = viewDV[t2.getter](offset, state.littleEndian);
                      offset += t2.size;
                    } else {
                      n = viewDV.getInt32(offset, state.littleEndian);
                      offset += 4;
                      v2 = textDecoder.decode(viewU8.slice(offset, offset + n));
                      offset += n;
                    }
                    rc.push(v2);
                  }
                }
                if (clear) viewU8[0] = 0;
                metrics.s11n.deserialize.time += performance.now() - t;
                return rc;
              };
              state.s11n.serialize = function(...args) {
                const t = performance.now();
                ++metrics.s11n.serialize.count;
                if (args.length) {
                  const typeIds = [];
                  let i = 0, offset = 1;
                  viewU8[0] = args.length & 255;
                  for (; i < args.length; ++i, ++offset) {
                    typeIds.push(getTypeId(args[i]));
                    viewU8[offset] = typeIds[i].id;
                  }
                  for (i = 0; i < args.length; ++i) {
                    const t2 = typeIds[i];
                    if (t2.setter) {
                      viewDV[t2.setter](offset, args[i], state.littleEndian);
                      offset += t2.size;
                    } else {
                      const s = textEncoder.encode(args[i]);
                      viewDV.setInt32(offset, s.byteLength, state.littleEndian);
                      offset += 4;
                      viewU8.set(s, offset);
                      offset += s.byteLength;
                    }
                  }
                } else {
                  viewU8[0] = 0;
                }
                metrics.s11n.serialize.time += performance.now() - t;
              };
              return state.s11n;
            };
            const randomFilename = function f(len = 16) {
              if (!f._chars) {
                f._chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012346789";
                f._n = f._chars.length;
              }
              const a = [];
              let i = 0;
              for (; i < len; ++i) {
                const ndx = Math.random() * (f._n * 64) % f._n | 0;
                a[i] = f._chars[ndx];
              }
              return a.join("");
            };
            const __openFiles = /* @__PURE__ */ Object.create(null);
            const opTimer = /* @__PURE__ */ Object.create(null);
            opTimer.op = void 0;
            opTimer.start = void 0;
            const mTimeStart = (op) => {
              opTimer.start = performance.now();
              opTimer.op = op;
              ++metrics[op].count;
            };
            const mTimeEnd = () => metrics[opTimer.op].time += performance.now() - opTimer.start;
            const ioSyncWrappers = {
              xCheckReservedLock: function(pFile, pOut) {
                wasm.poke(pOut, 0, "i32");
                return 0;
              },
              xClose: function(pFile) {
                mTimeStart("xClose");
                let rc = 0;
                const f = __openFiles[pFile];
                if (f) {
                  delete __openFiles[pFile];
                  rc = opRun("xClose", pFile);
                  if (f.sq3File) f.sq3File.dispose();
                }
                mTimeEnd();
                return rc;
              },
              xDeviceCharacteristics: function(pFile) {
                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
              },
              xFileControl: function(pFile, opId, pArg) {
                return capi.SQLITE_NOTFOUND;
              },
              xFileSize: function(pFile, pSz64) {
                mTimeStart("xFileSize");
                let rc = opRun("xFileSize", pFile);
                if (0 == rc) {
                  try {
                    const sz = state.s11n.deserialize()[0];
                    wasm.poke(pSz64, sz, "i64");
                  } catch (e) {
                    error("Unexpected error reading xFileSize() result:", e);
                    rc = state.sq3Codes.SQLITE_IOERR;
                  }
                }
                mTimeEnd();
                return rc;
              },
              xLock: function(pFile, lockType) {
                mTimeStart("xLock");
                const f = __openFiles[pFile];
                let rc = 0;
                if (!f.lockType) {
                  rc = opRun("xLock", pFile, lockType);
                  if (0 === rc) f.lockType = lockType;
                } else {
                  f.lockType = lockType;
                }
                mTimeEnd();
                return rc;
              },
              xRead: function(pFile, pDest, n, offset64) {
                mTimeStart("xRead");
                const f = __openFiles[pFile];
                let rc;
                try {
                  rc = opRun("xRead", pFile, n, Number(offset64));
                  if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {
                    wasm.heap8u().set(f.sabView.subarray(0, n), pDest);
                  }
                } catch (e) {
                  error("xRead(", arguments, ") failed:", e, f);
                  rc = capi.SQLITE_IOERR_READ;
                }
                mTimeEnd();
                return rc;
              },
              xSync: function(pFile, flags) {
                mTimeStart("xSync");
                ++metrics.xSync.count;
                const rc = opRun("xSync", pFile, flags);
                mTimeEnd();
                return rc;
              },
              xTruncate: function(pFile, sz64) {
                mTimeStart("xTruncate");
                const rc = opRun("xTruncate", pFile, Number(sz64));
                mTimeEnd();
                return rc;
              },
              xUnlock: function(pFile, lockType) {
                mTimeStart("xUnlock");
                const f = __openFiles[pFile];
                let rc = 0;
                if (capi.SQLITE_LOCK_NONE === lockType && f.lockType) {
                  rc = opRun("xUnlock", pFile, lockType);
                }
                if (0 === rc) f.lockType = lockType;
                mTimeEnd();
                return rc;
              },
              xWrite: function(pFile, pSrc, n, offset64) {
                mTimeStart("xWrite");
                const f = __openFiles[pFile];
                let rc;
                try {
                  f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n));
                  rc = opRun("xWrite", pFile, n, Number(offset64));
                } catch (e) {
                  error("xWrite(", arguments, ") failed:", e, f);
                  rc = capi.SQLITE_IOERR_WRITE;
                }
                mTimeEnd();
                return rc;
              }
            };
            const vfsSyncWrappers = {
              xAccess: function(pVfs, zName, flags, pOut) {
                mTimeStart("xAccess");
                const rc = opRun("xAccess", wasm.cstrToJs(zName));
                wasm.poke(pOut, rc ? 0 : 1, "i32");
                mTimeEnd();
                return 0;
              },
              xCurrentTime: function(pVfs, pOut) {
                wasm.poke(
                  pOut,
                  24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
                  "double"
                );
                return 0;
              },
              xCurrentTimeInt64: function(pVfs, pOut) {
                wasm.poke(
                  pOut,
                  24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(),
                  "i64"
                );
                return 0;
              },
              xDelete: function(pVfs, zName, doSyncDir) {
                mTimeStart("xDelete");
                const rc = opRun(
                  "xDelete",
                  wasm.cstrToJs(zName),
                  doSyncDir,
                  false
                );
                mTimeEnd();
                return rc;
              },
              xFullPathname: function(pVfs, zName, nOut, pOut) {
                const i = wasm.cstrncpy(pOut, zName, nOut);
                return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
              },
              xGetLastError: function(pVfs, nOut, pOut) {
                warn("OPFS xGetLastError() has nothing sensible to return.");
                return 0;
              },
              xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {
                mTimeStart("xOpen");
                let opfsFlags = 0;
                if (0 === zName) {
                  zName = randomFilename();
                } else if (wasm.isPtr(zName)) {
                  if (capi.sqlite3_uri_boolean(zName, "opfs-unlock-asap", 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
                  }
                  if (capi.sqlite3_uri_boolean(zName, "delete-before-open", 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLINK_BEFORE_OPEN;
                  }
                  zName = wasm.cstrToJs(zName);
                }
                const fh = /* @__PURE__ */ Object.create(null);
                fh.fid = pFile;
                fh.filename = zName;
                fh.sab = new SharedArrayBuffer(state.fileBufferSize);
                fh.flags = flags;
                fh.readOnly = !(sqlite32.SQLITE_OPEN_CREATE & flags) && !!(flags & capi.SQLITE_OPEN_READONLY);
                const rc = opRun("xOpen", pFile, zName, flags, opfsFlags);
                if (!rc) {
                  if (fh.readOnly) {
                    wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, "i32");
                  }
                  __openFiles[pFile] = fh;
                  fh.sabView = state.sabFileBufView;
                  fh.sq3File = new sqlite3_file(pFile);
                  fh.sq3File.$pMethods = opfsIoMethods.pointer;
                  fh.lockType = capi.SQLITE_LOCK_NONE;
                }
                mTimeEnd();
                return rc;
              }
            };
            if (dVfs) {
              opfsVfs.$xRandomness = dVfs.$xRandomness;
              opfsVfs.$xSleep = dVfs.$xSleep;
            }
            if (!opfsVfs.$xRandomness) {
              vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut) {
                const heap = wasm.heap8u();
                let i = 0;
                for (; i < nOut; ++i)
                  heap[pOut + i] = Math.random() * 255e3 & 255;
                return i;
              };
            }
            if (!opfsVfs.$xSleep) {
              vfsSyncWrappers.xSleep = function(pVfs, ms) {
                Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
                return 0;
              };
            }
            opfsUtil.getResolvedPath = function(filename, splitIt) {
              const p = new URL(filename, "file://irrelevant").pathname;
              return splitIt ? p.split("/").filter((v2) => !!v2) : p;
            };
            opfsUtil.getDirForFilename = async function f(absFilename, createDirs = false) {
              const path = opfsUtil.getResolvedPath(absFilename, true);
              const filename = path.pop();
              let dh = opfsUtil.rootDirectory;
              for (const dirName of path) {
                if (dirName) {
                  dh = await dh.getDirectoryHandle(dirName, {
                    create: !!createDirs
                  });
                }
              }
              return [dh, filename];
            };
            opfsUtil.mkdir = async function(absDirName) {
              try {
                await opfsUtil.getDirForFilename(
                  absDirName + "/filepart",
                  true
                );
                return true;
              } catch (e) {
                return false;
              }
            };
            opfsUtil.entryExists = async function(fsEntryName) {
              try {
                const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
                await dh.getFileHandle(fn);
                return true;
              } catch (e) {
                return false;
              }
            };
            opfsUtil.randomFilename = randomFilename;
            opfsUtil.treeList = async function() {
              const doDir = async function callee3(dirHandle, tgt) {
                tgt.name = dirHandle.name;
                tgt.dirs = [];
                tgt.files = [];
                for await (const handle of dirHandle.values()) {
                  if ("directory" === handle.kind) {
                    const subDir = /* @__PURE__ */ Object.create(null);
                    tgt.dirs.push(subDir);
                    await callee3(handle, subDir);
                  } else {
                    tgt.files.push(handle.name);
                  }
                }
              };
              const root = /* @__PURE__ */ Object.create(null);
              await doDir(opfsUtil.rootDirectory, root);
              return root;
            };
            opfsUtil.rmfr = async function() {
              const dir = opfsUtil.rootDirectory, opt = { recurse: true };
              for await (const handle of dir.values()) {
                dir.removeEntry(handle.name, opt);
              }
            };
            opfsUtil.unlink = async function(fsEntryName, recursive = false, throwOnError = false) {
              try {
                const [hDir, filenamePart] = await opfsUtil.getDirForFilename(
                  fsEntryName,
                  false
                );
                await hDir.removeEntry(filenamePart, { recursive });
                return true;
              } catch (e) {
                if (throwOnError) {
                  throw new Error(
                    "unlink(",
                    arguments[0],
                    ") failed: " + e.message,
                    {
                      cause: e
                    }
                  );
                }
                return false;
              }
            };
            opfsUtil.traverse = async function(opt) {
              const defaultOpt = {
                recursive: true,
                directory: opfsUtil.rootDirectory
              };
              if ("function" === typeof opt) {
                opt = { callback: opt };
              }
              opt = Object.assign(defaultOpt, opt || {});
              const doDir = async function callee3(dirHandle, depth) {
                for await (const handle of dirHandle.values()) {
                  if (false === opt.callback(handle, dirHandle, depth))
                    return false;
                  else if (opt.recursive && "directory" === handle.kind) {
                    if (false === await callee3(handle, depth + 1)) break;
                  }
                }
              };
              doDir(opt.directory, 0);
            };
            const importDbChunked = async function(filename, callback) {
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true
              );
              const hFile = await hDir.getFileHandle(fnamePart, {
                create: true
              });
              let sah = await hFile.createSyncAccessHandle();
              let nWrote = 0, chunk, checkedHeader = false;
              try {
                sah.truncate(0);
                while (void 0 !== (chunk = await callback())) {
                  if (chunk instanceof ArrayBuffer)
                    chunk = new Uint8Array(chunk);
                  if (0 === nWrote && chunk.byteLength >= 15) {
                    util.affirmDbHeader(chunk);
                    checkedHeader = true;
                  }
                  sah.write(chunk, { at: nWrote });
                  nWrote += chunk.byteLength;
                }
                if (nWrote < 512 || 0 !== nWrote % 512) {
                  toss(
                    "Input size",
                    nWrote,
                    "is not correct for an SQLite database."
                  );
                }
                if (!checkedHeader) {
                  const header = new Uint8Array(20);
                  sah.read(header, { at: 0 });
                  util.affirmDbHeader(header);
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e) {
                await sah.close();
                sah = void 0;
                await hDir.removeEntry(fnamePart).catch(() => {
                });
                throw e;
              } finally {
                if (sah) await sah.close();
              }
            };
            opfsUtil.importDb = async function(filename, bytes) {
              if (bytes instanceof Function) {
                return importDbChunked(filename, bytes);
              }
              if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
              util.affirmIsDb(bytes);
              const n = bytes.byteLength;
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true
              );
              let sah, nWrote = 0;
              try {
                const hFile = await hDir.getFileHandle(fnamePart, {
                  create: true
                });
                sah = await hFile.createSyncAccessHandle();
                sah.truncate(0);
                nWrote = sah.write(bytes, { at: 0 });
                if (nWrote != n) {
                  toss(
                    "Expected to write " + n + " bytes but wrote " + nWrote + "."
                  );
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e) {
                if (sah) {
                  await sah.close();
                  sah = void 0;
                }
                await hDir.removeEntry(fnamePart).catch(() => {
                });
                throw e;
              } finally {
                if (sah) await sah.close();
              }
            };
            if (sqlite32.oo1) {
              const OpfsDb = function(...args) {
                const opt = sqlite32.oo1.DB.dbCtorHelper.normalizeArgs(...args);
                opt.vfs = opfsVfs.$zName;
                sqlite32.oo1.DB.dbCtorHelper.call(this, opt);
              };
              OpfsDb.prototype = Object.create(sqlite32.oo1.DB.prototype);
              sqlite32.oo1.OpfsDb = OpfsDb;
              OpfsDb.importDb = opfsUtil.importDb;
              sqlite32.oo1.DB.dbCtorHelper.setVfsPostOpenCallback(
                opfsVfs.pointer,
                function(oo1Db, sqlite33) {
                  sqlite33.capi.sqlite3_busy_timeout(oo1Db, 1e4);
                }
              );
            }
            const sanityCheck = function() {
              const scope = wasm.scopedAllocPush();
              const sq3File = new sqlite3_file();
              try {
                const fid = sq3File.pointer;
                const openFlags = capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE | capi.SQLITE_OPEN_MAIN_DB;
                const pOut = wasm.scopedAlloc(8);
                const dbFile = "/sanity/check/file" + randomFilename(8);
                const zDbFile = wasm.scopedAllocCString(dbFile);
                let rc;
                state.s11n.serialize("This is \xE4 string.");
                rc = state.s11n.deserialize();
                log("deserialize() says:", rc);
                if ("This is \xE4 string." !== rc[0]) toss("String d13n error.");
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                log("xAccess(", dbFile, ") exists ?=", rc);
                rc = vfsSyncWrappers.xOpen(
                  opfsVfs.pointer,
                  zDbFile,
                  fid,
                  openFlags,
                  pOut
                );
                log(
                  "open rc =",
                  rc,
                  "state.sabOPView[xOpen] =",
                  state.sabOPView[state.opIds.xOpen]
                );
                if (0 !== rc) {
                  error("open failed with code", rc);
                  return;
                }
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                if (!rc) toss("xAccess() failed to detect file.");
                rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
                if (rc) toss("sync failed w/ rc", rc);
                rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
                if (rc) toss("truncate failed w/ rc", rc);
                wasm.poke(pOut, 0, "i64");
                rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
                if (rc) toss("xFileSize failed w/ rc", rc);
                log("xFileSize says:", wasm.peek(pOut, "i64"));
                rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
                if (rc) toss("xWrite() failed!");
                const readBuf = wasm.scopedAlloc(16);
                rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
                wasm.poke(readBuf + 6, 0);
                let jRead = wasm.cstrToJs(readBuf);
                log("xRead() got:", jRead);
                if ("sanity" !== jRead) toss("Unexpected xRead() value.");
                if (vfsSyncWrappers.xSleep) {
                  log("xSleep()ing before close()ing...");
                  vfsSyncWrappers.xSleep(opfsVfs.pointer, 2e3);
                  log("waking up from xSleep()");
                }
                rc = ioSyncWrappers.xClose(fid);
                log("xClose rc =", rc, "sabOPView =", state.sabOPView);
                log("Deleting file:", dbFile);
                vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 4660);
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                if (rc)
                  toss(
                    "Expecting 0 from xAccess(",
                    dbFile,
                    ") after xDelete()."
                  );
                warn("End of OPFS sanity checks.");
              } finally {
                sq3File.dispose();
                wasm.scopedAllocPop(scope);
              }
            };
            W.onmessage = function({ data }) {
              switch (data.type) {
                case "opfs-unavailable":
                  promiseReject(new Error(data.payload.join(" ")));
                  break;
                case "opfs-async-loaded":
                  W.postMessage({ type: "opfs-async-init", args: state });
                  break;
                case "opfs-async-inited": {
                  if (true === promiseWasRejected) {
                    break;
                  }
                  try {
                    sqlite32.vfs.installVfs({
                      io: { struct: opfsIoMethods, methods: ioSyncWrappers },
                      vfs: { struct: opfsVfs, methods: vfsSyncWrappers }
                    });
                    state.sabOPView = new Int32Array(state.sabOP);
                    state.sabFileBufView = new Uint8Array(
                      state.sabIO,
                      0,
                      state.fileBufferSize
                    );
                    state.sabS11nView = new Uint8Array(
                      state.sabIO,
                      state.sabS11nOffset,
                      state.sabS11nSize
                    );
                    initS11n();
                    if (options.sanityChecks) {
                      warn(
                        "Running sanity checks because of opfs-sanity-check URL arg..."
                      );
                      sanityCheck();
                    }
                    if (thisThreadHasOPFS()) {
                      navigator.storage.getDirectory().then((d) => {
                        W.onerror = W._originalOnError;
                        delete W._originalOnError;
                        sqlite32.opfs = opfsUtil;
                        opfsUtil.rootDirectory = d;
                        log("End of OPFS sqlite3_vfs setup.", opfsVfs);
                        promiseResolve();
                      }).catch(promiseReject);
                    } else {
                      promiseResolve();
                    }
                  } catch (e) {
                    error(e);
                    promiseReject(e);
                  }
                  break;
                }
                default: {
                  const errMsg = "Unexpected message from the OPFS async worker: " + JSON.stringify(data);
                  error(errMsg);
                  promiseReject(new Error(errMsg));
                  break;
                }
              }
            };
          });
          return thePromise;
        };
        installOpfsVfs.defaultProxyUri = "sqlite3-opfs-async-proxy.js";
        globalThis.sqlite3ApiBootstrap.initializersAsync.push(
          async (sqlite33) => {
            try {
              let proxyJs = installOpfsVfs.defaultProxyUri;
              if (sqlite33.scriptInfo.sqlite3Dir) {
                installOpfsVfs.defaultProxyUri = sqlite33.scriptInfo.sqlite3Dir + proxyJs;
              }
              return installOpfsVfs().catch((e) => {
                sqlite33.config.warn(
                  "Ignoring inability to install OPFS sqlite3_vfs:",
                  e.message
                );
              });
            } catch (e) {
              sqlite33.config.error("installOpfsVfs() exception:", e);
              return Promise.reject(e);
            }
          }
        );
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite32) {
        var _dhVfsRoot, _dhOpaque, _dhVfsParent, _mapSAHToName, _mapFilenameToSAH, _availableSAH, _mapS3FileToOFile_, _apBody, _dvBody, _cVfs, _verbosity, _OpfsSAHPool_instances, logImpl_fn, _p;
        const toss = sqlite32.util.toss;
        const toss3 = sqlite32.util.toss3;
        const initPromises = /* @__PURE__ */ Object.create(null);
        const capi = sqlite32.capi;
        const util = sqlite32.util;
        const wasm = sqlite32.wasm;
        const SECTOR_SIZE = 4096;
        const HEADER_MAX_PATH_SIZE = 512;
        const HEADER_FLAGS_SIZE = 4;
        const HEADER_DIGEST_SIZE = 8;
        const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
        const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
        const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
        const HEADER_OFFSET_DATA = SECTOR_SIZE;
        const PERSISTENT_FILE_TYPES = capi.SQLITE_OPEN_MAIN_DB | capi.SQLITE_OPEN_MAIN_JOURNAL | capi.SQLITE_OPEN_SUPER_JOURNAL | capi.SQLITE_OPEN_WAL;
        const OPAQUE_DIR_NAME = ".opaque";
        const getRandomName = () => Math.random().toString(36).slice(2);
        const textDecoder = new TextDecoder();
        const textEncoder = new TextEncoder();
        const optionDefaults = Object.assign(/* @__PURE__ */ Object.create(null), {
          name: "opfs-sahpool",
          directory: void 0,
          initialCapacity: 6,
          clearOnInit: false,
          verbosity: 2,
          forceReinitIfPreviouslyFailed: false
        });
        const loggers = [
          sqlite32.config.error,
          sqlite32.config.warn,
          sqlite32.config.log
        ];
        sqlite32.config.log;
        const warn = sqlite32.config.warn;
        sqlite32.config.error;
        const __mapVfsToPool = /* @__PURE__ */ new Map();
        const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);
        const setPoolForVfs = (pVfs, pool) => {
          if (pool) __mapVfsToPool.set(pVfs, pool);
          else __mapVfsToPool.delete(pVfs);
        };
        const __mapSqlite3File = /* @__PURE__ */ new Map();
        const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);
        const setPoolForPFile = (pFile, pool) => {
          if (pool) __mapSqlite3File.set(pFile, pool);
          else __mapSqlite3File.delete(pFile);
        };
        const ioMethods = {
          xCheckReservedLock: function(pFile, pOut) {
            const pool = getPoolForPFile(pFile);
            pool.log("xCheckReservedLock");
            pool.storeErr();
            wasm.poke32(pOut, 1);
            return 0;
          },
          xClose: function(pFile) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            if (file) {
              try {
                pool.log(`xClose ${file.path}`);
                pool.mapS3FileToOFile(pFile, false);
                file.sah.flush();
                if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {
                  pool.deletePath(file.path);
                }
              } catch (e) {
                return pool.storeErr(e, capi.SQLITE_IOERR);
              }
            }
            return 0;
          },
          xDeviceCharacteristics: function(pFile) {
            return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
          },
          xFileControl: function(pFile, opId, pArg) {
            return capi.SQLITE_NOTFOUND;
          },
          xFileSize: function(pFile, pSz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xFileSize`);
            const file = pool.getOFileForS3File(pFile);
            const size = file.sah.getSize() - HEADER_OFFSET_DATA;
            wasm.poke64(pSz64, BigInt(size));
            return 0;
          },
          xLock: function(pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xLock ${lockType}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xRead: function(pFile, pDest, n, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xRead ${file.path} ${n} @ ${offset64}`);
            try {
              const nRead = file.sah.read(
                wasm.heap8u().subarray(pDest, pDest + n),
                { at: HEADER_OFFSET_DATA + Number(offset64) }
              );
              if (nRead < n) {
                wasm.heap8u().fill(0, pDest + nRead, pDest + n);
                return capi.SQLITE_IOERR_SHORT_READ;
              }
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xSectorSize: function(pFile) {
            return SECTOR_SIZE;
          },
          xSync: function(pFile, flags) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xSync ${flags}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            try {
              file.sah.flush();
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xTruncate: function(pFile, sz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xTruncate ${sz64}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            try {
              file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
              return 0;
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          },
          xUnlock: function(pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log("xUnlock");
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xWrite: function(pFile, pSrc, n, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xWrite ${file.path} ${n} ${offset64}`);
            try {
              const nBytes = file.sah.write(
                wasm.heap8u().subarray(pSrc, pSrc + n),
                { at: HEADER_OFFSET_DATA + Number(offset64) }
              );
              return n === nBytes ? 0 : toss("Unknown write() failure.");
            } catch (e) {
              return pool.storeErr(e, capi.SQLITE_IOERR);
            }
          }
        };
        const opfsIoMethods = new capi.sqlite3_io_methods();
        opfsIoMethods.$iVersion = 1;
        sqlite32.vfs.installVfs({
          io: { struct: opfsIoMethods, methods: ioMethods }
        });
        const vfsMethods = {
          xAccess: function(pVfs, zName, flags, pOut) {
            const pool = getPoolForVfs(pVfs);
            pool.storeErr();
            try {
              const name = pool.getPath(zName);
              wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
            } catch (e) {
              wasm.poke32(pOut, 0);
            }
            return 0;
          },
          xCurrentTime: function(pVfs, pOut) {
            wasm.poke(
              pOut,
              24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
              "double"
            );
            return 0;
          },
          xCurrentTimeInt64: function(pVfs, pOut) {
            wasm.poke(pOut, 24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(), "i64");
            return 0;
          },
          xDelete: function(pVfs, zName, doSyncDir) {
            const pool = getPoolForVfs(pVfs);
            pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
            pool.storeErr();
            try {
              pool.deletePath(pool.getPath(zName));
              return 0;
            } catch (e) {
              pool.storeErr(e);
              return capi.SQLITE_IOERR_DELETE;
            }
          },
          xFullPathname: function(pVfs, zName, nOut, pOut) {
            const i = wasm.cstrncpy(pOut, zName, nOut);
            return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
          },
          xGetLastError: function(pVfs, nOut, pOut) {
            const pool = getPoolForVfs(pVfs);
            const e = pool.popErr();
            pool.log(`xGetLastError ${nOut} e =`, e);
            if (e) {
              const scope = wasm.scopedAllocPush();
              try {
                const [cMsg, n] = wasm.scopedAllocCString(e.message, true);
                wasm.cstrncpy(pOut, cMsg, nOut);
                if (n > nOut) wasm.poke8(pOut + nOut - 1, 0);
              } catch (e2) {
                return capi.SQLITE_NOMEM;
              } finally {
                wasm.scopedAllocPop(scope);
              }
            }
            return e ? e.sqlite3Rc || capi.SQLITE_IOERR : 0;
          },
          xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {
            const pool = getPoolForVfs(pVfs);
            try {
              pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);
              const path = zName && wasm.peek8(zName) ? pool.getPath(zName) : getRandomName();
              let sah = pool.getSAHForPath(path);
              if (!sah && flags & capi.SQLITE_OPEN_CREATE) {
                if (pool.getFileCount() < pool.getCapacity()) {
                  sah = pool.nextAvailableSAH();
                  pool.setAssociatedPath(sah, path, flags);
                } else {
                  toss("SAH pool is full. Cannot create file", path);
                }
              }
              if (!sah) {
                toss("file not found:", path);
              }
              const file = { path, flags, sah };
              pool.mapS3FileToOFile(pFile, file);
              file.lockType = capi.SQLITE_LOCK_NONE;
              const sq3File = new capi.sqlite3_file(pFile);
              sq3File.$pMethods = opfsIoMethods.pointer;
              sq3File.dispose();
              wasm.poke32(pOutFlags, flags);
              return 0;
            } catch (e) {
              pool.storeErr(e);
              return capi.SQLITE_CANTOPEN;
            }
          }
        };
        const createOpfsVfs = function(vfsName) {
          if (sqlite32.capi.sqlite3_vfs_find(vfsName)) {
            toss3("VFS name is already registered:", vfsName);
          }
          const opfsVfs = new capi.sqlite3_vfs();
          const pDVfs = capi.sqlite3_vfs_find(null);
          const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;
          opfsVfs.$iVersion = 2;
          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
          opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
          opfsVfs.addOnDispose(
            opfsVfs.$zName = wasm.allocCString(vfsName),
            () => setPoolForVfs(opfsVfs.pointer, 0)
          );
          if (dVfs) {
            opfsVfs.$xRandomness = dVfs.$xRandomness;
            opfsVfs.$xSleep = dVfs.$xSleep;
            dVfs.dispose();
          }
          if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {
            vfsMethods.xRandomness = function(pVfs, nOut, pOut) {
              const heap = wasm.heap8u();
              let i = 0;
              for (; i < nOut; ++i)
                heap[pOut + i] = Math.random() * 255e3 & 255;
              return i;
            };
          }
          if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {
            vfsMethods.xSleep = (pVfs, ms) => 0;
          }
          sqlite32.vfs.installVfs({
            vfs: { struct: opfsVfs, methods: vfsMethods }
          });
          return opfsVfs;
        };
        class OpfsSAHPool {
          constructor(options = /* @__PURE__ */ Object.create(null)) {
            __privateAdd(this, _OpfsSAHPool_instances);
            __publicField(this, "vfsDir");
            __privateAdd(this, _dhVfsRoot);
            __privateAdd(this, _dhOpaque);
            __privateAdd(this, _dhVfsParent);
            __privateAdd(this, _mapSAHToName, /* @__PURE__ */ new Map());
            __privateAdd(this, _mapFilenameToSAH, /* @__PURE__ */ new Map());
            __privateAdd(this, _availableSAH, /* @__PURE__ */ new Set());
            __privateAdd(this, _mapS3FileToOFile_, /* @__PURE__ */ new Map());
            __privateAdd(this, _apBody, new Uint8Array(HEADER_CORPUS_SIZE));
            __privateAdd(this, _dvBody);
            __privateAdd(this, _cVfs);
            __privateAdd(this, _verbosity);
            var _a, _b;
            __privateSet(this, _verbosity, (_a = options.verbosity) != null ? _a : optionDefaults.verbosity);
            this.vfsName = options.name || optionDefaults.name;
            __privateSet(this, _cVfs, createOpfsVfs(this.vfsName));
            setPoolForVfs(__privateGet(this, _cVfs).pointer, this);
            this.vfsDir = options.directory || "." + this.vfsName;
            __privateSet(this, _dvBody, new DataView(
              __privateGet(this, _apBody).buffer,
              __privateGet(this, _apBody).byteOffset
            ));
            this.isReady = this.reset(
              !!((_b = options.clearOnInit) != null ? _b : optionDefaults.clearOnInit)
            ).then(() => {
              if (this.$error) throw this.$error;
              return this.getCapacity() ? Promise.resolve(void 0) : this.addCapacity(
                options.initialCapacity || optionDefaults.initialCapacity
              );
            });
          }
          log(...args) {
            __privateMethod(this, _OpfsSAHPool_instances, logImpl_fn).call(this, 2, ...args);
          }
          warn(...args) {
            __privateMethod(this, _OpfsSAHPool_instances, logImpl_fn).call(this, 1, ...args);
          }
          error(...args) {
            __privateMethod(this, _OpfsSAHPool_instances, logImpl_fn).call(this, 0, ...args);
          }
          getVfs() {
            return __privateGet(this, _cVfs);
          }
          getCapacity() {
            return __privateGet(this, _mapSAHToName).size;
          }
          getFileCount() {
            return __privateGet(this, _mapFilenameToSAH).size;
          }
          getFileNames() {
            const rc = [];
            const iter = __privateGet(this, _mapFilenameToSAH).keys();
            for (const n of iter) rc.push(n);
            return rc;
          }
          async addCapacity(n) {
            for (let i = 0; i < n; ++i) {
              const name = getRandomName();
              const h = await __privateGet(this, _dhOpaque).getFileHandle(name, {
                create: true
              });
              const ah = await h.createSyncAccessHandle();
              __privateGet(this, _mapSAHToName).set(ah, name);
              this.setAssociatedPath(ah, "", 0);
            }
            return this.getCapacity();
          }
          async reduceCapacity(n) {
            let nRm = 0;
            for (const ah of Array.from(__privateGet(this, _availableSAH))) {
              if (nRm === n || this.getFileCount() === this.getCapacity()) {
                break;
              }
              const name = __privateGet(this, _mapSAHToName).get(ah);
              ah.close();
              await __privateGet(this, _dhOpaque).removeEntry(name);
              __privateGet(this, _mapSAHToName).delete(ah);
              __privateGet(this, _availableSAH).delete(ah);
              ++nRm;
            }
            return nRm;
          }
          releaseAccessHandles() {
            for (const ah of __privateGet(this, _mapSAHToName).keys()) ah.close();
            __privateGet(this, _mapSAHToName).clear();
            __privateGet(this, _mapFilenameToSAH).clear();
            __privateGet(this, _availableSAH).clear();
          }
          async acquireAccessHandles(clearFiles) {
            const files = [];
            for await (const [name, h] of __privateGet(this, _dhOpaque)) {
              if ("file" === h.kind) {
                files.push([name, h]);
              }
            }
            return Promise.all(
              files.map(async ([name, h]) => {
                try {
                  const ah = await h.createSyncAccessHandle();
                  __privateGet(this, _mapSAHToName).set(ah, name);
                  if (clearFiles) {
                    ah.truncate(HEADER_OFFSET_DATA);
                    this.setAssociatedPath(ah, "", 0);
                  } else {
                    const path = this.getAssociatedPath(ah);
                    if (path) {
                      __privateGet(this, _mapFilenameToSAH).set(path, ah);
                    } else {
                      __privateGet(this, _availableSAH).add(ah);
                    }
                  }
                } catch (e) {
                  this.storeErr(e);
                  this.releaseAccessHandles();
                  throw e;
                }
              })
            );
          }
          getAssociatedPath(sah) {
            sah.read(__privateGet(this, _apBody), { at: 0 });
            const flags = __privateGet(this, _dvBody).getUint32(HEADER_OFFSET_FLAGS);
            if (__privateGet(this, _apBody)[0] && (flags & capi.SQLITE_OPEN_DELETEONCLOSE || (flags & PERSISTENT_FILE_TYPES) === 0)) {
              warn(
                `Removing file with unexpected flags ${flags.toString(16)}`,
                __privateGet(this, _apBody)
              );
              this.setAssociatedPath(sah, "", 0);
              return "";
            }
            const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
            sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
            const compDigest = this.computeDigest(__privateGet(this, _apBody));
            if (fileDigest.every((v2, i) => v2 === compDigest[i])) {
              const pathBytes = __privateGet(this, _apBody).findIndex((v2) => 0 === v2);
              if (0 === pathBytes) {
                sah.truncate(HEADER_OFFSET_DATA);
              }
              return pathBytes ? textDecoder.decode(__privateGet(this, _apBody).subarray(0, pathBytes)) : "";
            } else {
              warn("Disassociating file with bad digest.");
              this.setAssociatedPath(sah, "", 0);
              return "";
            }
          }
          setAssociatedPath(sah, path, flags) {
            const enc = textEncoder.encodeInto(path, __privateGet(this, _apBody));
            if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {
              toss("Path too long:", path);
            }
            __privateGet(this, _apBody).fill(0, enc.written, HEADER_MAX_PATH_SIZE);
            __privateGet(this, _dvBody).setUint32(HEADER_OFFSET_FLAGS, flags);
            const digest = this.computeDigest(__privateGet(this, _apBody));
            sah.write(__privateGet(this, _apBody), { at: 0 });
            sah.write(digest, { at: HEADER_OFFSET_DIGEST });
            sah.flush();
            if (path) {
              __privateGet(this, _mapFilenameToSAH).set(path, sah);
              __privateGet(this, _availableSAH).delete(sah);
            } else {
              sah.truncate(HEADER_OFFSET_DATA);
              __privateGet(this, _availableSAH).add(sah);
            }
          }
          computeDigest(byteArray) {
            let h1 = 3735928559;
            let h2 = 1103547991;
            for (const v2 of byteArray) {
              h1 = 31 * h1 + v2 * 307;
              h2 = 31 * h2 + v2 * 307;
            }
            return new Uint32Array([h1 >>> 0, h2 >>> 0]);
          }
          async reset(clearFiles) {
            await this.isReady;
            let h = await navigator.storage.getDirectory();
            let prev;
            for (const d of this.vfsDir.split("/")) {
              if (d) {
                prev = h;
                h = await h.getDirectoryHandle(d, { create: true });
              }
            }
            __privateSet(this, _dhVfsRoot, h);
            __privateSet(this, _dhVfsParent, prev);
            __privateSet(this, _dhOpaque, await __privateGet(this, _dhVfsRoot).getDirectoryHandle(
              OPAQUE_DIR_NAME,
              { create: true }
            ));
            this.releaseAccessHandles();
            return this.acquireAccessHandles(clearFiles);
          }
          getPath(arg) {
            if (wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);
            return (arg instanceof URL ? arg : new URL(arg, "file://localhost/")).pathname;
          }
          deletePath(path) {
            const sah = __privateGet(this, _mapFilenameToSAH).get(path);
            if (sah) {
              __privateGet(this, _mapFilenameToSAH).delete(path);
              this.setAssociatedPath(sah, "", 0);
            }
            return !!sah;
          }
          storeErr(e, code) {
            if (e) {
              e.sqlite3Rc = code || capi.SQLITE_IOERR;
              this.error(e);
            }
            this.$error = e;
            return code;
          }
          popErr() {
            const rc = this.$error;
            this.$error = void 0;
            return rc;
          }
          nextAvailableSAH() {
            const [rc] = __privateGet(this, _availableSAH).keys();
            return rc;
          }
          getOFileForS3File(pFile) {
            return __privateGet(this, _mapS3FileToOFile_).get(pFile);
          }
          mapS3FileToOFile(pFile, file) {
            if (file) {
              __privateGet(this, _mapS3FileToOFile_).set(pFile, file);
              setPoolForPFile(pFile, this);
            } else {
              __privateGet(this, _mapS3FileToOFile_).delete(pFile);
              setPoolForPFile(pFile, false);
            }
          }
          hasFilename(name) {
            return __privateGet(this, _mapFilenameToSAH).has(name);
          }
          getSAHForPath(path) {
            return __privateGet(this, _mapFilenameToSAH).get(path);
          }
          async removeVfs() {
            if (!__privateGet(this, _cVfs).pointer || !__privateGet(this, _dhOpaque)) return false;
            capi.sqlite3_vfs_unregister(__privateGet(this, _cVfs).pointer);
            __privateGet(this, _cVfs).dispose();
            delete initPromises[this.vfsName];
            try {
              this.releaseAccessHandles();
              await __privateGet(this, _dhVfsRoot).removeEntry(OPAQUE_DIR_NAME, {
                recursive: true
              });
              __privateSet(this, _dhOpaque, void 0);
              await __privateGet(this, _dhVfsParent).removeEntry(__privateGet(this, _dhVfsRoot).name, {
                recursive: true
              });
              __privateSet(this, _dhVfsRoot, __privateSet(this, _dhVfsParent, void 0));
            } catch (e) {
              sqlite32.config.error(this.vfsName, "removeVfs() failed:", e);
            }
            return true;
          }
          exportFile(name) {
            const sah = __privateGet(this, _mapFilenameToSAH).get(name) || toss("File not found:", name);
            const n = sah.getSize() - HEADER_OFFSET_DATA;
            const b = new Uint8Array(n > 0 ? n : 0);
            if (n > 0) {
              const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });
              if (nRead != n) {
                toss(
                  "Expected to read " + n + " bytes but read " + nRead + "."
                );
              }
            }
            return b;
          }
          async importDbChunked(name, callback) {
            const sah = __privateGet(this, _mapFilenameToSAH).get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
            sah.truncate(0);
            let nWrote = 0, chunk, checkedHeader = false;
            try {
              while (void 0 !== (chunk = await callback())) {
                if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
                if (0 === nWrote && chunk.byteLength >= 15) {
                  util.affirmDbHeader(chunk);
                  checkedHeader = true;
                }
                sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });
                nWrote += chunk.byteLength;
              }
              if (nWrote < 512 || 0 !== nWrote % 512) {
                toss(
                  "Input size",
                  nWrote,
                  "is not correct for an SQLite database."
                );
              }
              if (!checkedHeader) {
                const header = new Uint8Array(20);
                sah.read(header, { at: 0 });
                util.affirmDbHeader(header);
              }
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18
              });
            } catch (e) {
              this.setAssociatedPath(sah, "", 0);
              throw e;
            }
            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            return nWrote;
          }
          importDb(name, bytes) {
            if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
            else if (bytes instanceof Function)
              return this.importDbChunked(name, bytes);
            const sah = __privateGet(this, _mapFilenameToSAH).get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
            const n = bytes.byteLength;
            if (n < 512 || n % 512 != 0) {
              toss("Byte array size is invalid for an SQLite db.");
            }
            const header = "SQLite format 3";
            for (let i = 0; i < header.length; ++i) {
              if (header.charCodeAt(i) !== bytes[i]) {
                toss("Input does not contain an SQLite database header.");
              }
            }
            const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });
            if (nWrote != n) {
              this.setAssociatedPath(sah, "", 0);
              toss(
                "Expected to write " + n + " bytes but wrote " + nWrote + "."
              );
            } else {
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18
              });
              this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            }
            return nWrote;
          }
        }
        _dhVfsRoot = new WeakMap();
        _dhOpaque = new WeakMap();
        _dhVfsParent = new WeakMap();
        _mapSAHToName = new WeakMap();
        _mapFilenameToSAH = new WeakMap();
        _availableSAH = new WeakMap();
        _mapS3FileToOFile_ = new WeakMap();
        _apBody = new WeakMap();
        _dvBody = new WeakMap();
        _cVfs = new WeakMap();
        _verbosity = new WeakMap();
        _OpfsSAHPool_instances = new WeakSet();
        logImpl_fn = function(level, ...args) {
          if (__privateGet(this, _verbosity) > level)
            loggers[level](this.vfsName + ":", ...args);
        };
        class OpfsSAHPoolUtil {
          constructor(sahPool) {
            __privateAdd(this, _p);
            __privateSet(this, _p, sahPool);
            this.vfsName = sahPool.vfsName;
          }
          async addCapacity(n) {
            return __privateGet(this, _p).addCapacity(n);
          }
          async reduceCapacity(n) {
            return __privateGet(this, _p).reduceCapacity(n);
          }
          getCapacity() {
            return __privateGet(this, _p).getCapacity(__privateGet(this, _p));
          }
          getFileCount() {
            return __privateGet(this, _p).getFileCount();
          }
          getFileNames() {
            return __privateGet(this, _p).getFileNames();
          }
          async reserveMinimumCapacity(min) {
            const c = __privateGet(this, _p).getCapacity();
            return c < min ? __privateGet(this, _p).addCapacity(min - c) : c;
          }
          exportFile(name) {
            return __privateGet(this, _p).exportFile(name);
          }
          importDb(name, bytes) {
            return __privateGet(this, _p).importDb(name, bytes);
          }
          async wipeFiles() {
            return __privateGet(this, _p).reset(true);
          }
          unlink(filename) {
            return __privateGet(this, _p).deletePath(filename);
          }
          async removeVfs() {
            return __privateGet(this, _p).removeVfs();
          }
        }
        _p = new WeakMap();
        const apiVersionCheck = async () => {
          const dh = await navigator.storage.getDirectory();
          const fn = ".opfs-sahpool-sync-check-" + getRandomName();
          const fh = await dh.getFileHandle(fn, { create: true });
          const ah = await fh.createSyncAccessHandle();
          const close = ah.close();
          await close;
          await dh.removeEntry(fn);
          if (close == null ? void 0 : close.then) {
            toss(
              "The local OPFS API is too old for opfs-sahpool:",
              "it has an async FileSystemSyncAccessHandle.close() method."
            );
          }
          return true;
        };
        sqlite32.installOpfsSAHPoolVfs = async function(options = /* @__PURE__ */ Object.create(null)) {
          var _a;
          options = Object.assign(
            /* @__PURE__ */ Object.create(null),
            optionDefaults,
            options || {}
          );
          const vfsName = options.name;
          if (options.$testThrowPhase1) {
            throw options.$testThrowPhase1;
          }
          if (initPromises[vfsName]) {
            try {
              const p = await initPromises[vfsName];
              return p;
            } catch (e) {
              if (options.forceReinitIfPreviouslyFailed) {
                delete initPromises[vfsName];
              } else {
                throw e;
              }
            }
          }
          if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !((_a = navigator == null ? void 0 : navigator.storage) == null ? void 0 : _a.getDirectory)) {
            return initPromises[vfsName] = Promise.reject(
              new Error("Missing required OPFS APIs.")
            );
          }
          return initPromises[vfsName] = apiVersionCheck().then(async function() {
            if (options.$testThrowPhase2) {
              throw options.$testThrowPhase2;
            }
            const thePool = new OpfsSAHPool(options);
            return thePool.isReady.then(async () => {
              const poolUtil = new OpfsSAHPoolUtil(thePool);
              if (sqlite32.oo1) {
                const oo1 = sqlite32.oo1;
                const theVfs = thePool.getVfs();
                const OpfsSAHPoolDb = function(...args) {
                  const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
                  opt.vfs = theVfs.$zName;
                  oo1.DB.dbCtorHelper.call(this, opt);
                };
                OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);
                poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
              }
              thePool.log("VFS initialized.");
              return poolUtil;
            }).catch(async (e) => {
              await thePool.removeVfs().catch(() => {
              });
              throw e;
            });
          }).catch((err2) => {
            return initPromises[vfsName] = Promise.reject(err2);
          });
        };
      });
      if ("undefined" !== typeof Module3) {
        const SABC = Object.assign(
          /* @__PURE__ */ Object.create(null),
          {
            exports: "undefined" === typeof wasmExports ? Module3["asm"] : wasmExports,
            memory: Module3.wasmMemory
          },
          globalThis.sqlite3ApiConfig || {}
        );
        globalThis.sqlite3ApiConfig = SABC;
        let sqlite32;
        try {
          sqlite32 = globalThis.sqlite3ApiBootstrap();
        } catch (e) {
          console.error("sqlite3ApiBootstrap() error:", e);
          throw e;
        } finally {
          delete globalThis.sqlite3ApiBootstrap;
          delete globalThis.sqlite3ApiConfig;
        }
        Module3.sqlite3 = sqlite32;
      } else {
        console.warn(
          "This is not running in an Emscripten module context, so",
          "globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack",
          "of config info for the WASM environment.",
          "It must be called manually."
        );
      }
    });
    moduleRtn = readyPromise;
    return moduleRtn;
  };
})();
var toExportForESM = function() {
  var _a, _b;
  const originalInit = sqlite3InitModule;
  if (!originalInit) {
    throw new Error(
      "Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build."
    );
  }
  const initModuleState = globalThis.sqlite3InitModuleState = Object.assign(
    /* @__PURE__ */ Object.create(null),
    {
      moduleScript: (_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.currentScript,
      isWorker: "undefined" !== typeof WorkerGlobalScope,
      location: globalThis.location,
      urlParams: ((_b = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _b.href) ? new URL(globalThis.location.href).searchParams : new URLSearchParams()
    }
  );
  initModuleState.debugModule = initModuleState.urlParams.has(
    "sqlite3.debugModule"
  ) ? (...args) => console.warn("sqlite3.debugModule:", ...args) : () => {
  };
  if (initModuleState.urlParams.has("sqlite3.dir")) {
    initModuleState.sqlite3Dir = initModuleState.urlParams.get("sqlite3.dir") + "/";
  } else if (initModuleState.moduleScript) {
    const li = initModuleState.moduleScript.src.split("/");
    li.pop();
    initModuleState.sqlite3Dir = li.join("/") + "/";
  }
  globalThis.sqlite3InitModule = function ff(...args) {
    return originalInit(...args).then((EmscriptenModule) => {
      const s = EmscriptenModule.sqlite3;
      s.scriptInfo = initModuleState;
      if (ff.__isUnderTest) s.__isUnderTest = true;
      const f = s.asyncPostInit;
      delete s.asyncPostInit;
      return f();
    }).catch((e) => {
      console.error("Exception loading sqlite3 module:", e);
      throw e;
    });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;
  if (globalThis.sqlite3InitModuleState.moduleScript) {
    const sim = globalThis.sqlite3InitModuleState;
    let src = sim.moduleScript.src.split("/");
    src.pop();
    sim.scriptDir = src.join("/") + "/";
  }
  initModuleState.debugModule("sqlite3InitModuleState =", initModuleState);
  return globalThis.sqlite3InitModule;
}();
sqlite3InitModule = toExportForESM;
var sqlite3_bundler_friendly_default = sqlite3InitModule;

// ../../node_modules/.pnpm/@sqlite.org+sqlite-wasm@3.48.0-build4/node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs
var import_meta2 = {};
globalThis.sqlite3Worker1Promiser = function callee(config = callee.defaultConfig) {
  if (1 === arguments.length && "function" === typeof arguments[0]) {
    const f = config;
    config = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig);
    config.onready = f;
  } else {
    config = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig, config);
  }
  const handlerMap = /* @__PURE__ */ Object.create(null);
  const noop2 = function() {
  };
  const err = config.onerror || noop2;
  const debug = config.debug || noop2;
  const idTypeMap = config.generateMessageId ? void 0 : /* @__PURE__ */ Object.create(null);
  const genMsgId = config.generateMessageId || function(msg) {
    return msg.type + "#" + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1);
  };
  const toss = (...args) => {
    throw new Error(args.join(" "));
  };
  if (!config.worker) config.worker = callee.defaultConfig.worker;
  if ("function" === typeof config.worker) config.worker = config.worker();
  let dbId;
  let promiserFunc;
  config.worker.onmessage = function(ev) {
    ev = ev.data;
    debug("worker1.onmessage", ev);
    let msgHandler = handlerMap[ev.messageId];
    if (!msgHandler) {
      if (ev && "sqlite3-api" === ev.type && "worker1-ready" === ev.result) {
        if (config.onready) config.onready(promiserFunc);
        return;
      }
      msgHandler = handlerMap[ev.type];
      if (msgHandler && msgHandler.onrow) {
        msgHandler.onrow(ev);
        return;
      }
      if (config.onunhandled) config.onunhandled(arguments[0]);
      else err("sqlite3Worker1Promiser() unhandled worker message:", ev);
      return;
    }
    delete handlerMap[ev.messageId];
    switch (ev.type) {
      case "error":
        msgHandler.reject(ev);
        return;
      case "open":
        if (!dbId) dbId = ev.dbId;
        break;
      case "close":
        if (ev.dbId === dbId) dbId = void 0;
        break;
    }
    try {
      msgHandler.resolve(ev);
    } catch (e) {
      msgHandler.reject(e);
    }
  };
  return promiserFunc = function() {
    let msg;
    if (1 === arguments.length) {
      msg = arguments[0];
    } else if (2 === arguments.length) {
      msg = /* @__PURE__ */ Object.create(null);
      msg.type = arguments[0];
      msg.args = arguments[1];
      msg.dbId = msg.args.dbId;
    } else {
      toss("Invalid arguments for sqlite3Worker1Promiser()-created factory.");
    }
    if (!msg.dbId && msg.type !== "open") msg.dbId = dbId;
    msg.messageId = genMsgId(msg);
    msg.departureTime = performance.now();
    const proxy = /* @__PURE__ */ Object.create(null);
    proxy.message = msg;
    let rowCallbackId;
    if ("exec" === msg.type && msg.args) {
      if ("function" === typeof msg.args.callback) {
        rowCallbackId = msg.messageId + ":row";
        proxy.onrow = msg.args.callback;
        msg.args.callback = rowCallbackId;
        handlerMap[rowCallbackId] = proxy;
      } else if ("string" === typeof msg.args.callback) {
        toss(
          "exec callback may not be a string when using the Promise interface."
        );
      }
    }
    let p = new Promise(function(resolve, reject) {
      proxy.resolve = resolve;
      proxy.reject = reject;
      handlerMap[msg.messageId] = proxy;
      debug(
        "Posting",
        msg.type,
        "message to Worker dbId=" + (dbId || "default") + ":",
        msg
      );
      config.worker.postMessage(msg);
    });
    if (rowCallbackId) p = p.finally(() => delete handlerMap[rowCallbackId]);
    return p;
  };
};
globalThis.sqlite3Worker1Promiser.defaultConfig = {
  worker: function() {
    return new Worker(
      new URL("sqlite3-worker1-bundler-friendly.mjs", import_meta2.url),
      {
        type: "module"
      }
    );
  },
  onerror: (...args) => console.error("worker1 promiser error", ...args)
};
sqlite3Worker1Promiser.v2 = function(config) {
  let oldFunc;
  if ("function" == typeof config) {
    oldFunc = config;
    config = {};
  } else if ("function" === typeof (config == null ? void 0 : config.onready)) {
    oldFunc = config.onready;
    delete config.onready;
  }
  const promiseProxy = /* @__PURE__ */ Object.create(null);
  config = Object.assign(config || /* @__PURE__ */ Object.create(null), {
    onready: async function(func) {
      try {
        if (oldFunc) await oldFunc(func);
        promiseProxy.resolve(func);
      } catch (e) {
        promiseProxy.reject(e);
      }
    }
  });
  const p = new Promise(function(resolve, reject) {
    promiseProxy.resolve = resolve;
    promiseProxy.reject = reject;
  });
  try {
    this.original(config);
  } catch (e) {
    promiseProxy.reject(e);
  }
  return p;
}.bind({
  original: sqlite3Worker1Promiser
});
sqlite3Worker1Promiser.v2;
var sqlite_wasm_default = sqlite3_bundler_friendly_default;

// ../sqlite-wasm-kysely/dist/util/sqliteWasmBinary.js
function base64ToArrayBuffer(base64) {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}
var sqliteWasmBase64 = "AGFzbQEAAAABqwVZYAJ/fwF/YAF/AX9gA39/fwF/YAF/AGADf39/AGACf38AYAR/f39/AX9gBX9/f39/AX9gBH9/f38AYAR/f39+AX9gBn9/f39/fwF/YAJ/fgF/YAV/f39/fwBgAABgAXwBfGAAAX9gAX8BfmAHf39/f39/fwF/YAZ/f39/f38AYAJ/fgBgCH9/f39/f39/AX9gBH9+f38Bf2ADf39+AX9gAn9/AX5gA39+fwF/YAl/f39/f39/f38Bf2ABfgF/YAR/fn9/AGACfHwBfGADf39+AGABfwF8YAd/f39/f39/AGAJf39/f39/f39/AGADf35+AX9gAXwBfmAGf39/f39+AX9gBX9/f39+AGACf3wAYAR/f39+AGABfABgAAF8YAF+AX5gBX9/fn9/AX9gBH9/fn8AYAJ/fwF8YAp/f39/f39/f39/AX9gA39/fwF+YAN/fn8BfmAHf39/f35/fwF/YAZ/f39+f38Bf2AHf39/f39+fgBgC39/f39/f39/f39/AX9gAXwBf2AAAX5gBX9+f39/AX9gC39/f39/f39/f39/AGAIf39/f39/f38AYAR/f35/AX9gA398fwF/YAN8fH8BfGACfH8BfGAGf3x/f39/AX9gAn5/AX9gBH9+fn8AYAJ+fwBgA398fABgBn9/f35+fwF/YAV/f35/fwBgA39/fAF/YAJ8fgF/YAh/f39/f35/fwBgA39/fgF+YAJ+fAF/YAd/f39+f39/AX9gDX9/f39/f39/f39/f38AYAh/fn5/f39/fwF/YAJ/fgF+YAZ/f39/fn4AYAN/fn4AYAZ+f39/f38BfmAHf35/f39/fwF/YAR/f35+AGACfH8Bf2ACf3wBfGADfH5+AXxgBH9/f34BfmADfn9/AX9gBX9+fn5+AGACfn4BfAKiByMDZW52E19fc3lzY2FsbF9mYWNjZXNzYXQABhZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAEDZW52E2Vtc2NyaXB0ZW5fZGF0ZV9ub3cAKANlbnYgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMADwNlbnYSZW1zY3JpcHRlbl9nZXRfbm93ACgDZW52EF9fc3lzY2FsbF9mY2htb2QAAANlbnYPX19zeXNjYWxsX2NobW9kAAADZW52El9fc3lzY2FsbF9mY2hvd24zMgACA2VudhFfX3N5c2NhbGxfZmNudGw2NAACA2VudhBfX3N5c2NhbGxfb3BlbmF0AAYDZW52D19fc3lzY2FsbF9pb2N0bAACFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUABhZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3JlYWQABgNlbnYRX19zeXNjYWxsX2ZzdGF0NjQAAANlbnYQX19zeXNjYWxsX3N0YXQ2NAAAA2VudhRfX3N5c2NhbGxfbmV3ZnN0YXRhdAAGA2VudhFfX3N5c2NhbGxfbHN0YXQ2NAAAFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfc3luYwABA2VudhVfX3N5c2NhbGxfZnRydW5jYXRlNjQACwNlbnYQX19zeXNjYWxsX2dldGN3ZAAAFndhc2lfc25hcHNob3RfcHJldmlldzERZW52aXJvbl9zaXplc19nZXQAABZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxC2Vudmlyb25fZ2V0AAAWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9zZWVrABUDZW52EV9fc3lzY2FsbF9ta2RpcmF0AAIDZW52CV90enNldF9qcwAIA2Vudg1fbG9jYWx0aW1lX2pzAEADZW52Cl9tdW5tYXBfanMAIwNlbnYIX21tYXBfanMAMANlbnYUX19zeXNjYWxsX3JlYWRsaW5rYXQABgNlbnYPX19zeXNjYWxsX3JtZGlyAAEDZW52El9fc3lzY2FsbF91bmxpbmthdAACA2VudhNfX3N5c2NhbGxfdXRpbWVuc2F0AAYWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQ1mZF9mZHN0YXRfZ2V0AAADZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAQNlbnYGbWVtb3J5AgGAAoCAAgOvFK0UDQYBAgYHAQAFBQMBAwEQBQUFBQUFBQUEAQ8NBQ0BAw8AAwEpKRoaAAsLBAQQCx4BBAsABQUEQQEEEAsFAQMWAQEBAQAABgYEBQAAAgcAAAYAAgEGAgMEAgYGBQIAAgACAAAGAAAHARcBBwADAQYRAQEAAwoEABMqAwEFAAEAAAMBAwUAAAABAQMBA0IIGgUBAgMMBQUBAwACBgYBAgMAAQIAAAACAQAD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c3FsaXRlM19tYWxsb2M2NABID3NxbGl0ZTNfcmVhbGxvYwBJEXNxbGl0ZTNfcmVhbGxvYzY0AEsSc3FsaXRlM192YWx1ZV90ZXh0AF4Sc3FsaXRlM19yYW5kb21uZXNzAGoPc3FsaXRlM19zdHJpY21wAGsQc3FsaXRlM19zdHJuaWNtcABtFXNxbGl0ZTNfdXJpX3BhcmFtZXRlcgByE3NxbGl0ZTNfdXJpX2Jvb2xlYW4AdhFzcWxpdGUzX3NlcmlhbGl6ZQCEARJzcWxpdGUzX3ByZXBhcmVfdjIAhwEMc3FsaXRlM19zdGVwAIgBFHNxbGl0ZTNfY29sdW1uX2ludDY0AIkBDXNxbGl0ZTNfcmVzZXQAigEMc3FsaXRlM19leGVjAIsBEnNxbGl0ZTNfY29sdW1uX2ludACMARBzcWxpdGUzX2ZpbmFsaXplAI4BFHNxbGl0ZTNfZmlsZV9jb250cm9sAI8BE3NxbGl0ZTNfY29sdW1uX25hbWUApQETc3FsaXRlM19jb2x1bW5fdGV4dACmARNzcWxpdGUzX2NvbHVtbl90eXBlAKcBDnNxbGl0ZTNfZXJybXNnAKkBE3NxbGl0ZTNfZGVzZXJpYWxpemUArQEWc3FsaXRlM19jbGVhcl9iaW5kaW5ncwD2ARJzcWxpdGUzX3ZhbHVlX2Jsb2IA+QETc3FsaXRlM192YWx1ZV9ieXRlcwD9ARRzcWxpdGUzX3ZhbHVlX2RvdWJsZQCBAhFzcWxpdGUzX3ZhbHVlX2ludACDAhNzcWxpdGUzX3ZhbHVlX2ludDY0AIUCFXNxbGl0ZTNfdmFsdWVfc3VidHlwZQCGAhVzcWxpdGUzX3ZhbHVlX3BvaW50ZXIAhwISc3FsaXRlM192YWx1ZV90eXBlAIkCFnNxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UAigIWc3FsaXRlM192YWx1ZV9mcm9tYmluZACLAhFzcWxpdGUzX3ZhbHVlX2R1cACMAhJzcWxpdGUzX3ZhbHVlX2ZyZWUAjwITc3FsaXRlM19yZXN1bHRfYmxvYgCQAhtzcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcAkwIac3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0AlAIVc3FsaXRlM19yZXN1bHRfZG91YmxlAJcCFHNxbGl0ZTNfcmVzdWx0X2Vycm9yAJkCEnNxbGl0ZTNfcmVzdWx0X2ludACcAhRzcWxpdGUzX3Jlc3VsdF9pbnQ2NACeAhNzcWxpdGUzX3Jlc3VsdF9udWxsAJ8CFnNxbGl0ZTNfcmVzdWx0X3BvaW50ZXIAoQIWc3FsaXRlM19yZXN1bHRfc3VidHlwZQCkAhNzcWxpdGUzX3Jlc3VsdF90ZXh0AKUCF3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iAKsCGXNxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQArAIZc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZQCuAhFzcWxpdGUzX3VzZXJfZGF0YQCyAhlzcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlALMCFXNxbGl0ZTNfdnRhYl9ub2NoYW5nZQC0AhVzcWxpdGUzX3Z0YWJfaW5fZmlyc3QAtQIUc3FsaXRlM192dGFiX2luX25leHQAvgIZc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dAC/AhNzcWxpdGUzX2dldF9hdXhkYXRhAMECE3NxbGl0ZTNfc2V0X2F1eGRhdGEAwgIUc3FsaXRlM19jb2x1bW5fY291bnQAxAISc3FsaXRlM19kYXRhX2NvdW50AMUCE3NxbGl0ZTNfY29sdW1uX2Jsb2IAxgIUc3FsaXRlM19jb2x1bW5fYnl0ZXMAxwIVc3FsaXRlM19jb2x1bW5fZG91YmxlAMgCFHNxbGl0ZTNfY29sdW1uX3ZhbHVlAMkCF3NxbGl0ZTNfY29sdW1uX2RlY2x0eXBlAMsCEXNxbGl0ZTNfYmluZF9ibG9iAMwCE3NxbGl0ZTNfYmluZF9kb3VibGUAzwIQc3FsaXRlM19iaW5kX2ludADQAhJzcWxpdGUzX2JpbmRfaW50NjQA0QIRc3FsaXRlM19iaW5kX251bGwA0gIUc3FsaXRlM19iaW5kX3BvaW50ZXIA0wIRc3FsaXRlM19iaW5kX3RleHQA1AIcc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudADXAhtzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX25hbWUA2AIcc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleADaAhFzcWxpdGUzX2RiX2hhbmRsZQDdAhVzcWxpdGUzX3N0bXRfcmVhZG9ubHkA3gIWc3FsaXRlM19zdG10X2lzZXhwbGFpbgDfAhRzcWxpdGUzX3N0bXRfZXhwbGFpbgDgAhFzcWxpdGUzX3N0bXRfYnVzeQDhAhNzcWxpdGUzX3N0bXRfc3RhdHVzAOMCC3NxbGl0ZTNfc3FsAOQCFHNxbGl0ZTNfZXhwYW5kZWRfc3FsAOUCFXNxbGl0ZTNfcHJldXBkYXRlX29sZADoAhdzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudAD0AhdzcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aAD1AhtzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUA9gIVc3FsaXRlM19wcmV1cGRhdGVfbmV3APcCGnNxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlAPgCFnNxbGl0ZTNfc2V0X2F1dGhvcml6ZXIAnwMPc3FsaXRlM19zdHJnbG9iAKEDD3NxbGl0ZTNfc3RybGlrZQCkAxZzcWxpdGUzX2F1dG9fZXh0ZW5zaW9uAKUDHXNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uAKYDHHNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24ApwMSc3FsaXRlM19wcmVwYXJlX3YzAKsDFXNxbGl0ZTNfY3JlYXRlX21vZHVsZQCsAxhzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIArgMUc3FsaXRlM19kcm9wX21vZHVsZXMArwMUc3FsaXRlM19kZWNsYXJlX3Z0YWIAsAMYc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ALsDFnNxbGl0ZTNfdnRhYl9jb2xsYXRpb24AvQMPc3FsaXRlM192dGFiX2luAMEDFnNxbGl0ZTNfdnRhYl9yaHNfdmFsdWUAwgMVc3FsaXRlM192dGFiX2Rpc3RpbmN0AMMDFHNxbGl0ZTNfa2V5d29yZF9uYW1lAMQDFXNxbGl0ZTNfa2V5d29yZF9jb3VudADFAxVzcWxpdGUzX2tleXdvcmRfY2hlY2sAxgMQc3FsaXRlM19jb21wbGV0ZQDIAxJzcWxpdGUzX2xpYnZlcnNpb24AyQMZc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlcgDKAxBzcWxpdGUzX3NodXRkb3duAMsDGXNxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQA0QMdc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQA0gMRc3FsaXRlM19jaGFuZ2VzNjQA0wMPc3FsaXRlM19jaGFuZ2VzANQDF3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ANUDFXNxbGl0ZTNfdG90YWxfY2hhbmdlcwDWAxFzcWxpdGUzX3R4bl9zdGF0ZQDXAxBzcWxpdGUzX2Nsb3NlX3YyANwDFHNxbGl0ZTNfYnVzeV9oYW5kbGVyAN0DGHNxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlcgDeAxRzcWxpdGUzX2J1c3lfdGltZW91dADfAxFzcWxpdGUzX2ludGVycnVwdADhAxZzcWxpdGUzX2lzX2ludGVycnVwdGVkAOIDF3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uAOMDGnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyAOYDHnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbgDnAxlzcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uAOgDEHNxbGl0ZTNfdHJhY2VfdjIA7gMTc3FsaXRlM19jb21taXRfaG9vawDvAxNzcWxpdGUzX3VwZGF0ZV9ob29rAPADFXNxbGl0ZTNfcm9sbGJhY2tfaG9vawDxAxZzcWxpdGUzX3ByZXVwZGF0ZV9ob29rAPIDFHNxbGl0ZTNfZXJyb3Jfb2Zmc2V0APoDD3NxbGl0ZTNfZXJyY29kZQD7AxhzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUA/AMOc3FsaXRlM19lcnJzdHIA/QMNc3FsaXRlM19saW1pdAD+AwxzcWxpdGUzX29wZW4A/wMPc3FsaXRlM19vcGVuX3YyAIoEGHNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbgCLBBtzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIAjAQYc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkAI4EFnNxbGl0ZTNfZ2V0X2F1dG9jb21taXQAjwQdc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGEAkAQdc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMAlgQPc3FsaXRlM191cmlfa2V5AKUEEXNxbGl0ZTNfdXJpX2ludDY0AKgED3NxbGl0ZTNfZGJfbmFtZQCqBBNzcWxpdGUzX2RiX2ZpbGVuYW1lAKsEE3NxbGl0ZTNfZGJfcmVhZG9ubHkArQQac3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQArgQZc3FsaXRlM19jb21waWxlb3B0aW9uX2dldACvBBNzcWxpdGUzc2Vzc2lvbl9kaWZmALAEFXNxbGl0ZTNzZXNzaW9uX2F0dGFjaAC/BBVzcWxpdGUzc2Vzc2lvbl9jcmVhdGUAwwQVc3FsaXRlM3Nlc3Npb25fZGVsZXRlAMUEG3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlcgDHBBhzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQAyAQdc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0A0wQcc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybQDUBBdzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldADVBBVzcWxpdGUzc2Vzc2lvbl9lbmFibGUA1gQXc3FsaXRlM3Nlc3Npb25faW5kaXJlY3QA1wQWc3FsaXRlM3Nlc3Npb25faXNlbXB0eQDYBBpzcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZADZBBxzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnANoEHXNxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplANsEFnNxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQA3AQZc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MgDeBBtzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0A3wQec3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtAOAEFXNxbGl0ZTNjaGFuZ2VzZXRfbmV4dADhBBNzcWxpdGUzY2hhbmdlc2V0X29wAOkEE3NxbGl0ZTNjaGFuZ2VzZXRfcGsA6gQUc3FsaXRlM2NoYW5nZXNldF9vbGQA6wQUc3FsaXRlM2NoYW5nZXNldF9uZXcA7AQZc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdADtBB1zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cwDuBBlzcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplAO8EF3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0APAEHHNxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0A8wQZc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MgD0BBZzcWxpdGUzY2hhbmdlc2V0X2FwcGx5AP4EHnNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybQD/BBtzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0AgAUWc3FsaXRlM2NoYW5nZWdyb3VwX25ldwCBBRZzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkAIIFGXNxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQAjwUbc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtAJEFHnNxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybQCSBRlzcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlAJMFF3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0AJQFHHNxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0AlQUVc3FsaXRlM3Nlc3Npb25fY29uZmlnAJYFEHNxbGl0ZTNfc291cmNlaWQAlwUYc3FsaXRlM19fd2FzbV9wc3RhY2tfcHRyAJgFHHNxbGl0ZTNfX3dhc21fcHN0YWNrX3Jlc3RvcmUAmQUac3FsaXRlM19fd2FzbV9wc3RhY2tfYWxsb2MAmgUec3FsaXRlM19fd2FzbV9wc3RhY2tfcmVtYWluaW5nAJsFGnNxbGl0ZTNfX3dhc21fcHN0YWNrX3F1b3RhAJwFFnNxbGl0ZTNfX3dhc21fZGJfZXJyb3IAnQUZc3FsaXRlM19fd2FzbV90ZXN0X3N0cnVjdACeBRdzcWxpdGUzX193YXNtX2VudW1fanNvbgCfBRhzcWxpdGUzX193YXNtX3Zmc191bmxpbmsAoAUUc3FsaXRlM19fd2FzbV9kYl92ZnMAoQUWc3FsaXRlM19fd2FzbV9kYl9yZXNldACiBR9zcWxpdGUzX193YXNtX2RiX2V4cG9ydF9jaHVua2VkAKMFGnNxbGl0ZTNfX3dhc21fZGJfc2VyaWFsaXplAKQFHXNxbGl0ZTNfX3dhc21fdmZzX2NyZWF0ZV9maWxlAKUFH3NxbGl0ZTNfX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUApwUic3FsaXRlM19fd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjawCoBRtzcWxpdGUzX193YXNtX2t2dmZzX21ldGhvZHMAqgUZc3FsaXRlM19fd2FzbV92dGFiX2NvbmZpZwCrBRpzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19pcACsBRtzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19waWkArQUZc3FsaXRlM19fd2FzbV9kYl9jb25maWdfcwCuBRZzcWxpdGUzX193YXNtX2NvbmZpZ19pAK8FF3NxbGl0ZTNfX3dhc21fY29uZmlnX2lpALAFFnNxbGl0ZTNfX3dhc21fY29uZmlnX2oAsQUYc3FsaXRlM19fd2FzbV9xZm10X3Rva2VuALIFGXNxbGl0ZTNfX3dhc21faW5pdF93YXNtZnMAswUZc3FsaXRlM19fd2FzbV90ZXN0X2ludHB0cgC0BRpzcWxpdGUzX193YXNtX3Rlc3Rfdm9pZHB0cgC1BRxzcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWF4ALYFHHNxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW4AtwUfc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X3RpbWVzMgC4BR9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfbWlubWF4ALkFG3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NHB0cgC6BSFzcWxpdGUzX193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cAuwUcc3FsaXRlM19fd2FzbV90ZXN0X3N0cl9oZWxsbwC8BR9zcWxpdGUzX193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iAL0FBm1hbGxvYwDAFARmcmVlAMIUB3JlYWxsb2MAwxQbZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduAMUUGV9lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUAzBQXX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MAzRQcZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudADOFAniCQEAQQEL8gRAswG3AscH1wejBqQGowKoApYDmAOuCa8JsAngA+oD9AOBBIMEhATOA6IGpQbJAbEEsgSzBLQEuwS8BL0EvgSHE4gTiROKE8QE7ATyBvMG9Ab1BvYG9wb4Bp8InQjuB4QIhQi9CL4IvwipC+AL4QvSC6ALlQrwCpoKmwqcCqEKogqjCjKsCrUKtwrFCtkK2wrcCuEKjAzTC9QLiwz/C4AMgQyCDL8MwAzXC5gMvgzCCuoL6wuODY8Nhg2HDdkLnAvCC+0L7gvvC/0LgwzFDMYMzAzwDO8M+wyYDd8N4A3rDewN8A3bDokPig+LD4wPjQ+OD48PkA+RD5IP+Q/2D/cP9Q+UD5UPlg/PD4sRvhHqD4cQqBCpEKoQqxCsEK0Q5hDnEOgQ6RDqEIIRjhGPEZAR8hDzEPQQ9RD2EPcQmRGbEZwRrBG4EZcRyhHPEdIR5BHDEsIS6wRueXp7fX5/gAGBAYIBgwHCBe0F7gWJBpUTlhPDBccFyAXKBcwFzQXOBcQF0QXSBdUF1wXYBdwF3gXfBeAF4QXiBawTnxPfE40U2BPbE8kThRS9FMMTohTjBe0ThxTEE+QT/BP9E+QFhhTrE+UF5gXnBegF6QXrBeoF7AXvBfAF8QXyBfMF9AX1BfYF9wX4BfkF+wX9Bf8FgAaCBoMGhAaFBoYGhwaIBooGiwaMBo0GjgaPBpAGkQaSBpMGlAaVBpYGlwaYBpkGmgbFBscGyAbJBsoGywbWCNcI2AjZCNoI2wjcCN0I3gjfCOAI5QjmCOcI6AjpCOsI7AjtCO4I7wiRDZMNlw2ZDZoNnA2dDZ4Nnw2hDaINow2lDaYNpw2oDakNqg2rDawNrQ2uDa8NsA2xDbINsw20DbYNtw24DbkNug27DbwNvQ2+Db8NwA3BDcINww3HDcgNyQ3KDcsNzA3NDc4Nzw3QDdEN0g3TDdQN1Q2hFNYNuxPXDZ0T2A3ME6AToxOmE6gTsROJFJ8UsxOKFKAUohOlE6oTjBTZDdoN2w3cDd0N6g3tDe4N7w3yDfMN9A31DfYN9w34DfkN+g37DfwN/Q3+Df8NgA6BDoIOgw6EDoUOhg6HDogOiQ6KDo0Ojg6QDpIOlA6WDpcOmA6ZDqEOpw6sDq4Osw66Dr0Ovw7BDsMOxA7FDsYOxw7IDsoOyw7MDs0Ozw7uDu8O8A7xDvIO8w70DvUO9g73DvoO/A79DoAPgg+DD/kOhQ+ID5MPlw+YD5kPmg+bD5wPnQ+fD6APoQ+jD6UPpw+pD7cPuw+8D8UPxw/kD+UP5g/nD+kP6w/uD+8P8A/xD/IPnRGeEZ8RoBGhEaMRpBGlEacRqBGpEaoRrRGuEa8RsBGyEbMRtBG1EbYRtxGiEcgR0BHREdMR1RHXEdgR3BHeEd8RixDgEeER4hHjEe0R7xHwEfER8hHzEfQR9hH4EfsR/BH9EYkSixKMEo0SjxKREpISlBKbEp0SnhKgEqESphKnEqgSqRKqEqsSrBLFEsYSxxLIEskSyhLLEswSzRLOEs8S0BLREtIS0xLUEtUS1hLXEtkS2hLfEuAS4RLiEuMS5BLlEuYS6BLpEuwS7RLvEvAS8RLyEvMS9BL1EvcS+BL5EvoS+xL8Ev0S/hL/EoATghODE4QThROGE88T0BPRE9ITshSzFLYUCtrcLa0UCAAQ4BMQuhQLXQIBfwF/IABBCk8EQEGHvQEQJA8LIAFBACACG0UEQEGKvQEQJA8LIAEgAEECdEHAiQZqIgAoAgAiBK03AwAgAiAAIgVBKGoiADUCADcDACADBEAgBSAENgIoC0EACw8AQRUgAEGAlgEQJRpBFQs8AQF/IwBBEGsiAyQAIAMgATYCBCADIAI2AgAgA0EAIgFBxbsCajYCCCAAQdDBASADEGkgA0EQaiQAIAALZQEBfyMAQRBrIgQkACAEQgA3AwggBEIANwMAAkAgAUEAIAIbRQRAQZu9ARAkIQMMAQsgACAEQQhqIAQgAxAjIgMNACABIAQpAwg+AgAgAiAEKQMAPgIAQQAhAwsgBEEQaiQAIAML/wgJAX8BfwF/AX8BfwF/AX4BfgF/IwBBEGsiByQAAkAgA0UgAkVyQQEgABAoIgUbBEBBzL0BECQhBQwBC0EBIQUCQAJAAkACQAJAAkACQAJAIAEODQACAwQBAQEGBgYHAgUICyACIAAgAxApNgIAQQAhBSAERQ0HIAAoAtACIgQEQCAEIQEDQCABIgYoAgAiAQ0ACyAGIAAoAswCNgIAIABBADYC0AIgACAENgLMAgsgACgC2AIiBkUNByAGIQUDQCAFIgEoAgAiBQ0ACyABIAAoAtQCNgIAQQAhBSAAQQA2AtgCIAAgBjYC1AIMBwtBACEFIAJBADYCACADIAFBAnQgAGoiCkGwAmoiACgCADYCACAERQ0GIApBADYCsAIMBgtBACEFA0AgBSAAKAIUTkUEQCAAKAIQIAVBBHRqKAIEIgEEQCABKAIEKAIAIgEzAZQBIQsgASkDqAEhDCABKALkASgCNEGIoAUiBCgCfBEBACALIAx8p0HEAGpsIAZqIAFBtKAFKAIAEQEAaiABKAKoAWohBgsgBUEBaiEFDAELCyACIAY2AgBBACEFIANBADYCAAwFCyAHQQA2AgwgACAAKALgAjYC5AIgACAHQQxqNgKQBANAIAYgACgCFE5FBEACQCAAKAIQIAZBBHRqKAIMIgFFDQAgB0EQQbigBSgCABEBACABKAI8IAEoAhwgASgCLCABKAIMampqbCAHKAIMaiIFNgIMQQAhBEEAIQggASgCFCIJBEAgCUG0oAUoAgARAQAhCCAHKAIMIQULIAcgBSAIaiIFNgIMIAEoAjQiCARAIAhBtKAFKAIAEQEAIQQgBygCDCEFCyAHIAQgBWoiBTYCDEEAIQRBACEIIAEoAiQiCQRAIAlBtKAFKAIAEQEAIQggBygCDCEFCyAHIAUgCGoiBTYCDCABKAJEIggEQCAIQbSgBSgCABEBACEEIAcoAgwhBQsgByAEIAVqNgIMIAFBMGohBQNAIAUoAgAiBQRAIAAgBSgCCBAqDAELCyABQRBqIQUDQCAFKAIAIgVFDQEgACAFKAIIECsMAAsACyAGQQFqIQYMAQsLQQAhBSAAQQA2ApAEIAAgACgC6AI2AuQCIANBADYCACACIAcoAgw2AgAMBAsgB0EANgIIIAAgACgC4AI2AuQCIAAgB0EIajYCkAQgAEEEaiEFA0AgBSgCACIFBEAgBRAsIAVBCGohBQwBCwtBACEFIABBADYCkAQgACAAKALoAjYC5AIgA0EANgIAIAIgBygCCDYCAAwDC0EKIQELIAFBB2tBAnQhCEEAIQUDQCAFIAAoAhRORQRAAkAgACgCECAFQQR0aigCBCIBRQ0AIAEoAgQoAgAgCGoiDUHIAWoiASgCACAGaiEGIARFDQAgDUEANgLIAQsgBUEBaiEFDAELC0EAIQUgA0EANgIAIAIgBkH/////B3E2AgAMAQtBACEFIANBADYCAEEBIQEgACkDiARCAFcEQCAAKQOABEIAVSEBCyACIAE2AgALIAdBEGokACAFCy8AAkAgAAR/IAAtAGFB9gBGBEBBAQ8LIAAQLUUNAUGQsgEFQd7vAQsiABAuC0EAC1UDAX8BfwF/IAAoAswCEC8hAiAAKALQAhAvIQMgACgC1AIQLyACaiECIAAoAtgCEC8hBCABBEAgASAAKAK8AiACazYCAAsgACgCvAIgAiADaiAEamsLRAACQCABRQ0AIAEtAAoNACAAIAEoAhwQMSAAIAEoAgAQMiAAIAEoAgQQMiAAIAEoAgwQMyAAIAEoAhAQNCAAIAEQNQsLLwEBfwJAIAFFDQAgACgCkARFBEAgASABKAIYQQFrIgI2AhggAg0BCyAAIAEQNgsL6AEDAX8BfwF/IAAoAgAhAiAAKAJ0IgEEQCABIAAvAZIBQQF0EDcgAiAAKAJ0EDgLIAAoAuABIQEDQCABBEAgASgCGCEDIAIgASgCACABKAIEEDkgAiABEDUgAyEBDAELCwJAIAAtAJcBRQ0AIAAoAmQgAC4BEBA3IAAoAoABIgEEQCACIAEQOAsgACgCzAEiAUUNACACIAEQOAsgAiAAKAJoIAAoAmwQOSAAKALIASIBBEAgAiABEDgLAkAgAigCkAQNACAAKAIEIAAoAggiATYCACABRQ0AIAEgACgCBDYCBAsgAiAAEDgLMQEBf0EBIQEgAC0AYSIAQe0ARiAAQfYARnIgAEG6AUZyRQRAQfGrARAuQQAhAQsgAQslAQF/IwBBEGsiASQAIAEgADYCAEEVQcnuACABEGkgAUEQaiQACx4BAX8DQCAABEAgAUEBaiEBIAAoAgAhAAwBCwsgAQsYACAARQRAQgAPCyAAQbSgBSgCABEBAKwLYgEBfwNAIAEEQCABKAIoIQIgACABKAIUEDMgACABKAIYELIDIAAgASgCCBClCCAAIAEoAhwQNCAAIAEoAiAQ8QggACABKAIQEKoIIAAgASgCJBAyIAAgARA1IAIhAQwBCwsLDQAgAQRAIAAgARA1CwsOACABBEAgACABEKYICws/AgF/AX8gAQRAIAFBCGohAwNAIAIgASgCAE5FBEAgACADIAJBA3RqKAIAEDIgAkEBaiECDAELCyAAIAEQOAsLbAACQCAARQ0AAkAgASAAKALkAk8NACAAKALcAiABTQRAIAEgACgC2AI2AgAgACABNgLYAg8LIAEgACgC4AJJDQAgASAAKALQAjYCACAAIAE2AtACDwsgACgCkARFDQAgACABEL8FDwsgARBAC4MDAwF/AX8BfyABKAIIIQIDQCACBEAgAigCFCEDAkAgACgCkAQNACABLQArQQFGDQAgAigCGEEYaiACKAIAQQAQ7QMaCyAAIAIQ1QcgAyECDAELCwJAAkACQAJAIAEtACsOAgABAgsgASgCMCECA0AgAkUNAwJAIAAoApAEDQAgAigCDCEDAkAgAigCECIEBEAgBCADNgIMDAELIAEoAjxBOGogAyACIAMbKAIIIAMQ7QMaIAIoAgwhAwsgA0UNACADIAIoAhA2AhALIAAgAigCHBDzByAAIAIoAiAQ8wcgAigCBCEDIAAgAhA1IAMhAgwACwALIAAoApAERQRAQQAgARDABxoLIAEoAjBFDQFBACECA0AgASgCLCACSgRAIAJBAUcEQCAAIAEoAjAgAkECdGooAgAQMgsgAkEBaiECDAELCyAAIAEoAjAQMgwBCyAAIAEoAiwQpQgLIAAgARDwCCAAIAEoAgAQMiAAIAEoAgwQMiAAIAEoAhAQsgMgACABEDULkwEBAX8CQCAARSABRXINACAAIAFBKGxqIQEgACgCFCICKAKQBEUEQANAAkACQCAALQARQZABcQRAIAAQ9wEMAQsgACgCGEUNASACIAAoAiAQOCAAQQA2AhgLIABBADsBEAsgAEEoaiIAIAFJDQAMAgsACwNAIAAoAhgEQCACIAAoAiAQMgsgAEEoaiIAIAFJDQALCwtkAAJAIAEgACgC5AJPDQAgACgC3AIgAU0EQCABIAAoAtgCNgIAIAAgATYC2AIPCyABIAAoAuACSQ0AIAEgACgC0AI2AgAgACABNgLQAg8LIAAoApAEBEAgACABEL8FDwsgARBAC0cBAX8gAQRAIAEgAkEUbGohAgNAIAJBE2ssAAAiA0F6TARAIAAgAyACQQRrKAIAEJgHCyACQRRrIgIgAUcNAAsgACABEDgLCzsBAX8CQBA7DQBBkIoGIQEDQCAARSABKAIAIgFFcg0BIAAgASgCEBCQFEUNASABQQxqIQEMAAsACyABC+gFBQF/AX8BfwF/AX8CQAJAQdihBSgCAA0AQYigBSIAQQE2AtgBQeShBSgCAEUEQEGooAUoAgBFBEAQPAtBACIAQZCsB2pBCDYCAAJAAkBBiKAFIgAoArgBRQ0AQcShBSgCAEGABEgNAEHIoQUoAgBBAEoNAQtBwKEFQgA3AwALQYigBSgCPEG8oAUoAgARAQAiAQ0CC0GIoAVBATYC3AFB8KEFKAIARQRAQfChBUEINgIAC0GIoAUiAUHsoQUoAgBBAWoiAjYC5AFBACEAQdihBSgCAEHcoQUoAgByRQRAQQBBiKAFaiIBQQE2AtQBQaiLBkEAQdwAEJkTGkGw5QVBBRA9QYDnBUEPED1B4OsFQQoQPUHw7gVBIhA9QbDCBUHvABA9AkBB6KEFKAIARQRAQfSgBSgCACIARQRAED5B9KAFKAIAIQALQfCgBSgCACAAEQEAIgANAQtBASEAQeihBUEBNgIAQQoQPyIBRQRAQQchAAwBCyABEEAQQRpBABA6IgFFDQAgASgCBCEAQZCxBSICIAE2AhRBlLEFQQwgACAAQQxNGzYCAEGQsQVBABBCIgANAEEAIgBBwKwHaigCNARAQQAhAkEAIgFBwKwHakGIoAUiAygCwAFBAEHAoQUoAgAiABsiATYCXEGErQcgATYCAEGArQdBxKEFKAIAQXhxQQAgARsiAzYCAEEKIQRBoK0HQQA2AgBBmK0HQQA2AgBBjK0HIAA2AgBBiK0HQQogAUEKbUEBaiABQdoAShsiBDYCAANAIAEEQCAAIAI2AgBBmK0HIAA2AgAgAUEBayEBIAAhAiAAIANqIQAMAQsLQZCtByAANgIAC0HYoQVBATYCAEEAIQALQYigBSIBQQA2AtQBQeyhBSgCACECC0HsoQUgAkEBazYCACACQQFKDQBB8KEFQQA2AgALIAAPC0GQrAciAEIANwMAQaisB0IANwMAQaCsB0IANwMAQZisB0IANwMAIAELJQEBfyMAQRBrIgAkACAAQdT6BTYCAEEEIAAQzAMaIABBEGokAAt9BAF/AX8BfwF/A0AgASAERkUEQAJAIAAgBEEobGoiAygCICICEFkgAiwAAGpBF28iBSACEOwDIgIEQCADIAIoAgw2AgwgAiADNgIMDAELIANBADYCDCADIAVBAnRBqIsGaiICKAIANgIkIAIgAzYCAAsgBEEBaiEEDAELCwslAQF/IwBBEGsiACQAIABB9PoFNgIAQRIgABDMAxogAEEQaiQACxkBAX8QOyAAQQBMckUEQCAArRBHIQELIAELTwEBfyAABEBBiKAFKAIABEAgAEG0oAUoAgARAQAhAUHAiQZBwIkGKAIAIAFrNgIAQeSJBkHkiQYoAgBBAWs2AgALIABBrKAFKAIAEQMACwtmAgF/AX8DQCAAQQRGRQRAIABB2ABsQYCdBWoiASABKAIQQa2bARCQFEUQQhogAEEBaiEADAELC0EAIgBBoKcFakEAEEIaQfClBSIBQZjfARDhEzYCAEH0pQVBn98BEOETNgIAQQALWgEBfxA7IgJFBEAgAEUEQEHC0AEQJA8LIAAQQwJAIAFBAUGQigYoAgAiAhsEQCAAIAI2AgxBkIoGIAA2AgAMAQsgACACKAIMNgIMIAIgADYCDAtBACECCyACC1YCAX8BfwJAIABFDQAgAEGQigYoAgAiAUYEQEGQigYgACgCDDYCAA8LIAFFDQADQCABIgIoAgwiAQRAIAAgAUcNAQsLIAAgAUcNACACIAAoAgw2AgwLCxIBAX8QOyIBRQRAIAAQQwsgAQtiAgF+AX5CfyECAkAQOw0AQZisBykDACECIABCAFMNAEGYrAdBoKwHKQMAIgEgACABIAAgAVMbIABQGyAAIAFCAFUbIgA3AwBBqKwHIABBwIkGNQIAVyAAQgBVcTYCAAsgAgtJAgF+AX5CfyEBAkAQOw0AQaCsBykDACEBIABCAFMNAEGgrAcgADcDAEGYrAcpAwAiAiAAVyACQgBScQ0AQZisByAANwMACyABC7ECBQF/AX8BfwF+AX4CQAJAIABCgP7//wd9QoGCgIB4VA0AQYigBSgCAARAIACnIgJBuKAFKAIAEQEAIQEgAkH8iQYoAgBLBEBB/IkGIAI2AgALAkBBmKwHKQMAIgBCAFcNACAAIAGsIgR9QcCJBjUCACIAVwRAQZCsByICQQE2AhhBoKwHKQMAIgVQIAUgBH0gAFVyDQEMAwtBqKwHQQA2AgALIAFBqKAFKAIAEQEAIgJFDQFBACIBQcCJBmoiAyACQbSgBSgCABEBAEHAiQYoAgBqIgE2AgBB6IkGKAIAIAFJBEBB6IkGIAE2AgALQcCJBiIDQeSJBigCAEEBaiIBNgIkIAFBjIoGKAIATQ0CQYyKBiABNgIADAILIACnQaigBSgCABEBACEDCyADDwsgAgsSAQF/EDtFBEAgABBHIQELIAELHQEBfxA7RQRAIAAgAUEAIAFBAEobrRBKIQILIAILpwIGAX8BfwF/AX8BfgF+IABFBEAgARBHDwsgAVAEQCAAEEBBAA8LAkACQCABQv/9//8HVg0AIABBiKAFIgIoAiwRAQAiBSABpyIEQbigBSgCABEBACICRgRAIAAPC0GIoAUoAgAEQCAEQfyJBigCAEsEQEH8iQYgBDYCAAsCQCACIAVrIgRBAEwNAEHAiQY1AgAiBkGYrAcpAwAgBK0iAX1TDQBBoKwHKQMAIgdCAFcNACAHIAF9IAZXDQILIAAgAkGwoAUoAgARAAAiAEUNASAAQQBBiKAFaigCLBEBACECQcCJBiIDQcCJBigCACACIAVraiICNgIAIAJB6IkGKAIATQ0CQeiJBiACNgIADAILIAAgAkGwoAUoAgARAAAhAwsgAw8LIAALFAEBfxA7RQRAIAAgARBKIQILIAILhS8eAX8BfwF/AX8BfwF/AX4BfwF/AX4BfAF/AX8BfwF+AX8BfwF/AX8BfwF+AX8BfwF/AX8BfAF/AX8BfwF/IwBBsAFrIgQkAAJ/IAAtABVBAnEiFEUEQCACDAELIAIoAgAhEyACQQRqCyEQIARBOGohGiAEQdAAakEBciEfA0ACQAJ/AkACfwJAAkACQCABLQAAIgpBJUYEQCABIQoMAQsgASECIApFDQEDQAJAIAJBAWohCiACLQABIgNBJUYNACAKIQIgAw0BCwsgACABIAogAWsQTSABIQYgCi0AAEUNAQsCQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQCAKLQABIgMEQCAKQQFqIQpBfyEFQQAhC0EAIRJBACEbQQAhD0EAIRhBACEZQQAhFUEAIQ4gECEIAkADQCADwCECQQEhBwJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIANB/wFxIgFBIGsOGgEDDgIODg4ODg4JAQUMCg4ECAgICAgICAgIAAsgAUHsAEcNDSAKLQABIgJB7ABGDQVBASELIApBAWoMBgsgFSEHIAMhGQwKC0EBIRgMCAtBASEPDAcLQQEhGwwGC0EsIRIMBQtBAiELIAotAAIhAiAKQQJqCyEKIALAIQIMBgsDQCAKQQFqIQEgAkEwayEDIAosAAEiAkEwa0H/AXFBCUtFBEAgA0EKbCACaiECIAEhCgwBCwsgA0H/////B3EhDiACQf8BcSIDQS5GDQIgFSEHIANB7ABGDQMgASEKDAULAkAgFARAIBMQTqchAgwBCyAIKAIAIQIgCEEEaiEIC0EAIAJrQQAgAkGAgICAeEcbIAIgAkEASCIDGyEOQQEgFSADGyEHIAotAAEiAkEuRiACQewARnINAiACwCECIApBAWohCiAHIRUMBAsCQAJAIAotAAEiA0EqRwRAIApBAWohAUEAIQoDQCADwCECIANBMGtB/wFxQQlLDQIgCkEKbCACakEwayEKIAEtAAEhAyABQQFqIQEMAAsACwJAIBQEQCATEE6nIQIMAQsgCCgCACECIAhBBGohCAtBf0EAIAJrIAJBgICAgHhGGyACIAJBAEgbIQUgCkECaiEBIAosAAIhAgwBCyAKQf////8HcSEFCyACQewARwRAIAEhCgwECyABQQFrIQoLIBUhBwsgCi0AASEDIAchFSAKQQFqIgEhCiADDQALQQAhAgtBACEDA0AgA0EXRg0PIANBBmwhASADQQFqIQMgAiABQZCBA2oiASwAAEcNAAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAyIWDhEBAwMDBAcHBQYICAkLAAgBAhoLQQAhEkEBIQsMAQtBACESCwJ/IAEtAAJBAXEEQAJ+IBQEQCAIIRAgExBODAELIAtBAkYEQCAIQQdqQXhxIgJBCGohECACKQMADAELIAhBBGohECAINAIACyIJQj+HIgwgCYUgDH0hF0EtIBkgCUIAUxsMAQsgFARAIBMQTiEXIAghEEEADAELAn4gC0ECRgRAIAhBB2pBeHEiAkEIaiEQIAIpAwAMAQsgCEEEaiEQIAg1AgALIRdBAAshDwJ/IBsEQCAFIA4gD0H/AXFBAEdrIgIgAiAFSBshBQsgBUElSARAQQAhCyAEQdAAaiECQcYADAELIAVBCmqtIQkgACAJIAVBA26tfCAJIBJB/wFxGyIJEE8iAkUNGCACIQsgCacLIQMgAiADakEBayIIIQYgFkEPRgRAIAhBAmsiBiAXIBdCCoAiCUIKfn0iDKdBACAJQgqCQgFSG0EAIAxCA1gbQQF0QeCoAWovAAA7AAALIAEtAARBoIIDaiEDIAExAAEhDCAXIQkDQCAGQQFrIgYgAyAJIAkgDIAiESAMfn2nai0AADoAACAJIAxaIQIgESEJIAINAAsgCCAGayECA0AgAiAFTkUEQCAGQQFrIgZBMDoAACACQQFqIQIMAQsLAkAgEkH/AXFFDQAgAkEBayICIAJBA20iA0EDbGtBAWohByAGIANrIQZBACECA0AgA0EATA0BIAIgBmoiBSADIAVqLQAAOgAAIAdBAWsiB0UEQCAGIAJBAWoiAmogEjoAAEEDIQcgA0EBayEDCyACQQFqIQIMAAsACyAPQf8BcQRAIAZBAWsiBiAPOgAACwJAIBhFIBdQcg0AIAEtAAUiAkUNACACQcGCA2ohAgNAIAItAAAiA0UNASAGQQFrIgYgAzoAACACQQFqIQIMAAsACyAIIAZrIQUMHAsgFARARAAAAAAAAAAAIQ0gEygCBCICIBMoAgBODRUgEyACQQFqNgIEIBMoAgggAkECdGooAgAQUCENDBULIAhBB2pBeHEiAkEIaiEQIAIrAwAhDQwVC0EAIQsgFARAQQAhDkEAIQUgCCEQDBsLIAgoAgAgACgCEDYCAAwFCyAEQSU6AFAgBEHQAGohBkEBIQVBACELIAghEAwZCwJAIBQEQCATEFEiAgRAIAQgAi0AACIBOgBQQQEhAyABQcABSQ0CA0AgAiwAASIBQb9/Sg0DIAJBAWohAiAEQdAAaiADaiABOgAAIANBAWoiA0EERw0AC0EEIQMMAgsgBEEAOgBQQQEhAwwBCyAIQQRqIQECfyAIKAIAIgJB/wBNBEAgBCACOgBQQQEMAQsgAkH/D00EQCAEIAJBP3FBgAFyOgBRIAQgAkEGdkHAAXI6AFBBAgwBCyACQf//A00EQCAEIAJBP3FBgAFyOgBSIAQgAkEMdkHgAXI6AFAgBCACQQZ2QT9xQYABcjoAUUEDDAELIAQgAkE/cUGAAXI6AFMgBCACQQZ2QT9xQYABcjoAUiAEIAJBDHZBP3FBgAFyOgBRIAQgAkESdkEHcUHwAXI6AFBBBAshAyABIQgLIARB0ABqIQFBASEPQQAhCyAFQQJIDQ8gFUH/AXEgDiAFQQFrIgJrIg5BAkhyRQRAIAAgDkEBa0EgEFJBACEOCyAAIARB0ABqIAMQTSADrSERQgEhCQNAIAJBAkgNECAANQIIIAkgAkEBa60iDCAJIAxTGyIMIBF+IgkgADUCEHxXBEAgACAJEFMaCyAALQAUDRAgACAAKAIEIAAoAhAgCaciB2tqIAcQTSAMQgGGIQkgAiAMp2shAgwACwALIBQEQEEAIQIgExBRIgNBgYEDIAMbIQFBACELDAsLIAhBBGohEEEAIQIgCCgCACIGQYGBAyAGGyEBQQAhCyAGRSAWQQZHcg0JIAAoAhANCCAAKAIMRSAOciAFQQBOcg0IIAAtABQEQCAQIQggBiIBIQsMDAsgACAGNgIEIAAgACgCACAGEFQ2AgggACAGEJUUQf////8HcTYCECAAIAAtABVBBHI6ABUMBgsgFkEORiECAkAgFARAIBMQUSEHDAELIAgoAgAhByAIQQRqIQgLQSJBJyACGyEDIAdB3u8BQdPUAiAWQQpGIgYbIAcbIQIgBawhDEIAIQlCACERA0ACQCAMUA0AIAIgCadqLQAAIgFFDQACQCAPQf8BcUEAIAFBvwFLG0UEQCAJQgF8IQkMAQsDQCACIAlCAXwiCadqLAAAQUBIDQALCyARIAEgA0atfCERIAxCAX0hDAwBCwsgBEHQAGohAUEAIQsgCSARfEIDfCIMQscAWQRAIAAgDBBPIgshASALRQ0SC0IAIQxCACERIAYgB0EAR3EiBgRAIAFBJzoAAEIBIRELIAlCACAJQgBVGyEXA0AgDCAXUUUEQCABIBGnaiACIAynai0AACIHOgAAIBFCAXwhCSADIAdHBH4gCQUgASAJp2ogAzoAACARQgJ8CyERIAxCAXwhDAwBCwsgBgRAIAEgEadqQSc6AAAgEUIBfCERCyABIBGnIgNqQQA6AAAMDQsgAC0AFUEBcUUNECAIKAIAIQIgGARAIAJFDQEgAi0ABUEIcQ0BIAAgAigCCBBVIAAoAgAgAhBWDAELIAJFDQAgAigCBCIDRQ0AIAAgAigCACADEE0gACgCACIDRQ0AIAMoAkRBfkcNACADKAKAAiIBRQ0AIAEoAvABIgFFDQAgAigCACICIAFJDQAgAiABEJUUIAFqTw0AIAMgAiABazYCRAsgCEEEaiEQDAMLIAAtABVBAXFFDQ4gCEEEaiEQQQAgCCgCACICKAIEIgMgD0H/AXEbDQEgAigCACIBBEACQCACLQAPQQFxDQAgAi0ADUEEcQ0AIAIoAiwiA0UNACAAIAMQVSAAQZvAAkEBEE0gAigCACEBCyAAIAEQVQwDCyADDQFBACILIAItAA1BBHFFDQMaIAIoAiwoAgAiAygCBCIBQYAQcQRAIAQgAygCEDYCICAAQZPEAiAEQSBqEFcMAwsgAUGACHEEQCAEIAIoAiA2AhAgAEHchAIgBEEQahBXDAMLIAQgAygCEDYCACAAQYXEAiAEEFcMAgsgAEHr8QJBARBNDA0LIAAgAxBVC0EACyELQQAhDkEAIQUMDwsgECEIIAYhCyAGIQEMAQsgECEICyAFQQBIDQAgD0H/AXFFDQIgASECA0AgBUEATA0CIAItAAAiA0UNAiAFQQFrIQUgAkEBaiECIANBwAFJDQADQCACIgNBAWohAiADLAAAQUBIDQALIAMhAgwACwALIAEQlRRB/////wdxIQMMAgsgAiABayEDQQEhDwwBCwNAIAIgBUYNAiABIAJqLQAABEAgAkEBaiECDAEFIAIhBQwDCwALAAsCQCAPQf8BcUUNACADIQIgDkEATA0AA0AgAkEATA0BIA4gASACQQFrIgJqLAAAQUBIaiEODAALAAsgAyEFCyABIQYgCCEQDAcLIAghEAtBBkGAwtcvIAUgBUGAwtcvThsgBUEASBshAwJAAkACQAJAIBZBAWsOAwACAQILQQAgA2shBQwCC0EBIAMgA0EBTRsiBSEDDAELIANBAWohBQsgBCAaNgI0IARBADoAKSAPQf8BcSEdAkACfwJAIA1EAAAAAAAAAABjBEAgBEEtOgAoIA2aIQ0MAQsgBEErOgAoIA1EAAAAAAAAAABiDQAgBEKBgICAEDcCLCAEQcy/AjYCNEEBDAELAkAgDb0iCUKAgICAgICA+P8Ag0KAgICAgICA+P8AUQRAIARCADcCLCAEQQFBAiAJQoCAgICAgID4/wBRGyICOgApIBohBwwBCyAEQgA3A6gBIAQgDTkDoAFBACECAkAgDUT////////fQ2QEQANAIA1EfMOUJa1JolhkBEAgBEGgAWpEMAWO5C7/KytExEYdeGgqtKcQWCACQeQAaiECIAQrA6ABIQ0MAQsLA0AgDUT///8fX6DyRWQEQCAEQaABakS7vdfZ33zbPUQsjd9lVApyuhBYIAJBCmohAiAEKwOgASENDAELCwNAIA1E////////30NkRQ0CIARBoAFqRJqZmZmZmbk/RJqZmZmZmVm8EFggAkEBaiECIAQrA6ABIQ0MAAsACwNAIA1EjGo+Hb9l5i5jBEAgBEGgAWpEfcOUJa1JslRE9DE7e9j0NNEQWCACQeQAayECIAQrA6ABIQ0MAQsLA0AgDUSVZHnhf/2VQWMEQCAEQaABakQAAAAgX6ACQkQAAAAAAAAAABBYIAJBCmshAiAEKwOgASENDAELCwNAIA1EmZmZmZmZqUNjRQ0BIARBoAFqRAAAAAAAACRARAAAAAAAAAAAEFggAkEBayECIAQrA6ABIQ0MAAsACyAEKwOoASIcRAAAAAAAAAAAYyEHAn4gDUQAAAAAAADwQ2MgDUQAAAAAAAAAAGZxBEAgDbEMAQtCAAshCQJ+IAcEQCAJAn4gHJoiDUQAAAAAAADwQ2MgDUQAAAAAAAAAAGZxBEAgDbEMAQtCAAsiDH0MAQsCfiAcRAAAAAAAAPBDYyAcRAAAAAAAAAAAZnEEQCAcsQwBC0IACyIMIAl8CyEJQRpBECAdGyEIQRchBwNAIAlQRQRAIAcgGmogCSAJQgqAIgxCCn59p0EwcjoAACAHQQFrIQcgDCEJDAELCyAEQRcgB2siBjYCLCAEIAIgBmoiAjYCMAJAAkAgBUEASg0AIAIgBWsiBUUEQCAHIBpqIgIsAAFBNUgNAiACQTA6AABBASEFIAQgBCgCLEEBaiIGNgIsIAQgBCgCMEEBajYCMCAHQQFrIQcMAQsgBUEATA0BCyAGIAhMIAUgBk5xDQAgBCAFIAggBSAISRsiBjYCLCAHIBpqQQFqIgggBmosAABBNUgNAAJAA0AgCCAGQQFrIgZqIgIgAi0AAEEBaiIFOgAAIAXAQTpIDQEgAkEwOgAAIAYNAAsgBCgCNCAHakExOgAAIAQgBCgCLEEBaiIGNgIsIAQgBCgCMEEBajYCMCAHQQFrIQcMAQsgBCgCLCEGCyAEIAcgGmoiAkEBaiIHNgI0A0ACQCAGQQBMDQAgAiAGai0AAEEwRw0AIAQgBkEBayIGNgIsDAELCyAELQApIQILAkACQCACQf8BcQ4DAQADAAsgGwRAIAdBOToAACAEQoGAgICA/QA3AixB6AcMAgsgBEGUjgEiAigAADYCUCAEQZiOAS0AADoAVCAEQdAAaiECIAQtAChBLUYNBiAfIgYgGUH/AXFFDQcaIAQgGToAUAwGCyAEKAIwCyECIAQtACghBQJ/IBZBA0YEQEF/QQAgAmsgAkF9SCACIANKciIeGyADaiEDIBhFDAELIBZBAkYhHiAdQQBHCyEgQQAgAkEBayAeGyIHQQAgB0EAShutIAOsIA6tfHxCD3whCQJAIAkgCSAHQQJqQQNurXwgEkH/AXEiFkUgB0EATHIbIglCxwBTBEAgBEHQAGohBkEAIQsMAQsgACAJEE8iCyEGIAtFDQILIBggA0EASnIhAiAGIRJBLSAZIAVBLUYbIgVB/wFxIhgEQCAGIAU6AAAgBkEBaiESCyACIA9yIRlBACEIAn8gB0EATgRAQQAhBQNAIBIiAiAHQQBIDQIaQTAhDyAEKAIsIAVKBEAgBCgCNCAFai0AACEPIAVBAWohBQsgAiAPOgAAIAJBAWohEgJAIBZFDQAgB0EDcCIPIAdBAklyDQAgAkEsOgABIAJBAmohEgsgB0EBayEHDAALAAsgEkEwOgAAIAdBAWohCEEAIQUgEkEBagshAiAZQf8BcSIPRQ0CIAJBLjoAAEEADAMLQaCEAUHQ6QEgGxsMBAsgBEGwAWokAA8LQQELIQcDQCAHRQRAIAJBAWohAkEBIQcMAQsCQCADQQBMIAhBAE5yRQRAIAJBMDoAACAIQQFqIQggA0EBayEDDAELA0AgA0EATEUEQEEwIQcgBCgCLCAFSgRAIAQoAjQgBWotAAAhByAFQQFqIQULIANBAWshAyACIAc6AAAgAkEBaiECDAELCwJAICAgD0EAR3FFDQADQAJAAkAgAkEBayIDLQAAQS5rDgMBAwADCyADQQA6AAAgAyECDAELCyAdBEAgAkEwOgAAIAJBAWohAgwBCyADQQA6AAAgAyECCyAeBEAgAkEtQSsgBCgCMCIDQQBMIgcbOgABIAIgAS0ABEGgggNqLQAAOgAAQQEgA2sgA0EBayAHGyIDQeQASQR/IAJBAmoFIAIgA0HkAG4iAUEwajoAAiADIAFB5ABsayEDIAJBA2oLIgIgA0H/AXFBCm4iAUEwcjoAACACIAMgAUEKbGtBMHI6AAEgAkECaiECCyACQQA6AAAgG0UgFUH/AXFyIA4gAiAGayIFTHINBCAOIAVrIQIgDiEDA0AgAiADSkUEQCADIAZqIAYgAyACa2otAAA6AAAgA0EBayEDDAELCyAYQQBHIQMDQCACBEAgAyAGakEwOgAAIANBAWohAyACQQFrIQIMAQUgDiEFDAYLAAsAC0EAIQcMAAsACyACCyEGQQAhCyAGEFkhBQsCQAJAIA4gBWsiAkEASgRAIBVB/wFxDQEgACACQSAQUgsgACAGIAUQTQwBCyAAIAYgBRBNIAAgAkEgEFILIAsEQCAAKAIAIAsQNQsgCkEBaiEBDAALAAtAAgF/AX8gACgCECIDIAJqIgQgACgCCE8EQCAAIAEgAhBaDwsgAgRAIAAgBDYCECAAKAIEIANqIAEgAhCXExoLCzQCAX4BfyAAKAIEIgIgACgCAEgEQCAAIAJBAWo2AgQgACgCCCACQQJ0aigCABBbIQELIAELRwEBfwJAIAAtABQNACAAAn8CQCABIAA1AghYDQAgASAANQIMWA0AQRIMAQsgACgCACABEFwiAg0BQQcLIgIQXUEAIQILIAILPgEBfyAALwEQIgFBCHEEQCAAKwMADwsgAUEkcQRAIAApAwC5DwsgAUEScUUEQEQAAAAAAAAAAA8LIAAQggILNAIBfwF/IAAoAgQiAiAAKAIASARAIAAgAkEBajYCBCAAKAIIIAJBAnRqKAIAEF4hAQsgAQtaAgF+AX8CQCAANQIIIAGsIgMgADUCEHxXBEAgACADEFMiAUEATA0BCwNAIAFBAEwNASAAIAAoAhAiBEEBajYCECAEIAAoAgRqIAI6AAAgAUEBayEBDAALAAsLigIEAX8BfgF/AX4CQCAALQAURQRAIAAoAgwiAkUEQCAAQRIQXSAAKAIIIAAoAhBBf3NqDwsgAC0AFUEEcQRAIAAoAgQhBAsgASAANQIQIgN8QgF8IgUgAyAFfCIDIAMgAq0iBVUbIgMgBVUEQCAAEF8gAEESEF1BAA8LIAAgAz4CCCADQv////8PgyEDAn8gACgCACICBEAgAiAEIAMQYAwBCyAEIAMQSgsiAkUNAQJAIAAtABVBBHENACAAKAIQIgRFDQAgAiAAKAIEIAQQlxMaCyAAIAI2AgQgACAAKAIAIAIQVDYCCCAAIAAtABVBBHI6ABUgAachAgsgAg8LIAAQXyAAQQcQXUEAC0UAAn8CQCAARQ0AIAEgACgC6AJPDQBBgAEgASAAKALcAk8NARogASAAKALgAkkNACAALwG2Ag8LIAFBtKAFKAIAEQEACwsMACAAIAEgARBZEE0LSQIBfwF/AkADQCABRQ0BAkAgASgCBCICQQNxRQRAIAEoAiQiA0EASg0BCyABKAIMIQEMAQsLIAJBgICAgARxDQAgACADNgJECwsjAQF/IwBBEGsiAyQAIAMgAjYCDCAAIAEgAhBMIANBEGokAAviAQMBfwF8AXwjACIDQTBrIgMgACsDACAAKQAAQoCAgGCDvyIEoTkDKCADIAEgAb1CgICAYIO/IgWhOQMgIAMgBSAEojkDGCADIAQgAysDIKIgAysDKCAFoqA5AxAgAyADKwMYIAMrAxCgOQMIIAMgAysDKCADKwMgoiADKwMQIAMrAxgiBCADKwMIIgWhoKA5AwAgAyADKwMAIAArAwAiBCACoiABIAArAwgiBaKgoDkDACAAIAMrAwggAysDAKA5AwAgACADKwMIIAArAwChOQMIIAAgAysDACAAKwMIoDkDCAsXACAARQRAQQAPCyAAEJUUQf////8DcQsxACAAIAKsEFMiAkEASgRAIAAoAgQgACgCEGogASACEJcTGiAAIAAoAhAgAmo2AhALC5oBAwF+AXwBfyAALwEQIgNBJHEEQCAAKQMADwsCQCADQQhxBEBCgICAgICAgICAfyEBIAArAwAiAkT////////fw2MNAUL///////////8AIQEgAkT////////fQ2QNASACmUQAAAAAAADgQ2MEQCACsA8LQoCAgICAgICAgH8PCyADQRJxRQ0AIAAoAghFDQAgABCEAiEBCyABCxMAIAAEQCAAIAEQ7wIPCyABEEcLKAAgACABOgAUIAAoAgwEQCAAEF8LIAFBEkYEQCAAKAIAQRIQmgIaCwsJACAAQQEQ/AELNQAgAC0AFUEEcQRAIAAoAgAgACgCBBAyIAAgAC0AFUH7AXE6ABULIABBADYCECAAQgA3AgQLWgAgAUUEQCAAIAIQ7wIPCwJAAkAgASAAKALkAk8NACAAKALcAiABTQRAIAJCgQFaDQEMAgsgASAAKALgAkkNACACIAAzAbYCWA0BCyAAIAEgAhDABSEBCyABCx8BAX8gAEUgAEGgogVGckUEQCAAEGIhASAAEEALIAELOgEBfwJAIAAoAgQiAUUNACABIAAoAhBqQQA6AAAgACgCDEUNACAALQAVQQRxDQAgABBjDwsgACgCBAtNAQF/AkAgACgCACAAKAIQQQFqrRBcIgEEQCABIAAoAgQgACgCEEEBahCXExogACAALQAVQQRyOgAVDAELIABBBxBdCyAAIAE2AgQgAQtLAQF/QhgQSCIBRQRAQaCiBQ8LIAAEfyAAKAJ4BUGAlOvcAwshACABQQA7ARQgAUEANgIQIAEgADYCDCABQQA2AgggAUIANwIAIAELdwIBfwF/IwBB8ABrIgIkAAJ/IABFBEBB6v4BECQaQQAMAQtBABA7DQAaIAJBADsBHCACQQA2AhggAkLGgICAgMCyzTs3AhAgAkEANgIIIAIgAkEgajYCDCACQQhqIAAgARBMIAJBCGoQYgshAyACQfAAaiQAIAMLLQIBfwF/IwBBEGsiAyQAEDtFBEAg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KALwAREkAAw7CyAFQgA3A+ACIAVBADYCyAMgACAEELMHIQwgACgCYCAEKAIEQQJ0aigCACIKLQAFQQJxRQRAIAooAiQgBUHIA2oQ7AciBg1AAkAgBSgCyAMEQCAFQgE3A+ACDAELIAUgCigCJBCZAyIJNwPgAiAJQv///////////wBRBEAgCiAKLQAFQQJyOgAFDAELIAUgCUIBfDcD4AILQQAhDQsgBCgCDCIDBEAgCyECICIoAgAiAQRAA0AgASICKAIEIgENAAsgAigCDCECCyACIANBKGxqIgEQtgdBDSEGIAEpAwAiCUL///////////8AUQ1AIAotAAVBAnENQCAJIAUpA+ACIg9ZBEAgBSAJQgF8Ig83A+ACCyABIA83AwALAkAgCi0ABUECcQRAQQAhAQNAAkBBCCAFQeACahBqIAUgBSkD4AJC//////////8/g0IBfCIJNwPgAiAKKAIkIAlBACAFQcgDahDwByECIAIgBSgCyAMiA3INACABQeMASSEHIAFBAWohASAHDQELCyACDQFBACENIANFDQELIApBADYCGCAKQQA6AAMgDCAFKQPgAjcDAAw7CyACQQ0gAhshBgw/CyAAIAQQswchASAAKAJgIAQoAgRBAnRqKAIAIgIgAikDECIJQgF8NwMQIAEgCTcDAAw5CyAEKAIMIQEMAQsgCyAEKAIMIgFBKGxqIgItABBBJHENACAFQeACaiACQSgQlxMaIAVB4AJqQcMAELcHIAUvAfACQQRxRQ00IAUpA+ACDAELIAsgAUEobGopAwALIQkgACgCYCAEKAIEQQJ0aigCACIBKAIkIQJBACENIAVBADYC0AIgAiAJQQAgBUHQAmoQ8AchBiABQQA2AhggASAJNwM4IAFBADsBAiABIAUoAtACIgI2AhwCQCACBEAgBCgCCEUNASAGIQ0MNAsgBkUNNgw7C0HlhAYQ4AEhBgw6CyAEKAIQIAAoAmAgBCgCBEECdGooAgAvAQZMDTQLIAAoAmAgBCgCBEECdGooAgAhASAFIAsgBCgCDEEobGoiAzYC5AIgBSAEKAIQIgI7AfQCAkAgAkH//wNxBEAgASgCKCECIAVBADoA9gIgBSACNgLgAiABKAIkIAVB4AJqIAFBHGoQ3wchBgwBCyADLQARQQRxBEAgAxD6AQ03CyABKAIoEPECIgJF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/wJxOwEQQQAhAQsgAQtfAQF/QQchASAAIAAoAgxBA2pBARD7AUUEQCAAKAIIIAAoAgxqQQA6AAAgACgCCCAAKAIMakEAOgABIAAoAgggACgCDGpBADoAAiAAIAAvARBBgARyOwEQQQAhAQsgAQsHACAAEPMBCycAIABBACACQQBOG0UEQCABIAMgABCRAg8LIAAgASACQQAgAxCSAgseACABQQFqQQJPBEAgACABEQMACyACBEAgAhCTAgsLUgEBfwJAAkAgACgCACIFIAEgAqwgAyAEEJkBIgIEQCACQRJGDQEgABCUAg8LIAUtABBBAnFFBEAgBSAALQAYOgASCyAFEJUCRQ0BCyAAEJMCCwshACAABEAgAEESNgIUIAAoAgBBl40BQn9BAUEAEJkBGgsLIQAgAARAIAAoAgAQmgEgAEEHNgIUIAAoAgAoAhQQlAELCzwCAX8BfyAALwEQIgJBEnFFBEBBAA8LIAAoAgwhASACQYAIcQRAIAAoAgAgAWohAQsgASAAKAIUKAJ4SgtBAAJAIABFBEAgA0EBakECSQ0BIAEgAxEDAA8LIAJCgICAgAhaBEAgASADIAAQkQIPCyAAIAEgAqdBACADEJICCwsRACAABEAgACgCACABEJgCCwsdACAAEJoBIAEgAWEEQCAAQQg7ARAgACABOQMACwsgACAABEAgAEEBNgIUIAAoAgAgASACrEEBQX8QmQEaCwsrAAJAIABFDQAgACgCgAIiAEUNACAAIAE2AgwgACAAKAIoQQFqNgIoCyABCzAAIAEgACgCGEoEQCAAIAFBABD7AQ8LIAAgACgCIDYCCCAAIAAvARBBLXE7ARBBAAsSACAABEAgACgCACABrBCYAQsLFQAgABCaASAAQQQ7ARAgACABNwMACxEAIAAEQCAAKAIAIAEQmAELCw8AIAAEQCAAKAIAEJoBCwtAAQF/IAAuARAiAUEASARAIAAgACgCABCwBxogAC8BECEBCyABQYAgcQRAIAAoAgggACgCJBEDAAsgAEEBOwEQCzkAAkAgAEUEQCADQQFqQQJJDQEgASADEQMADwsgACgCACIAEPcBIABBATsBECAAIAEgAiADEKICCws4ACAAEPgBIABB8AA6ABMgAEGBNDsBECAAIAE2AgggACADQQggAxs2AiQgACACQYGBAyACGzYCAAsDAAEL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CJoLIgg5AwALIAwgACACRiAKQQBKcXFFIAlBAExyRQRAIAkhBgwBCwJAIAlBAkgNAEF/IQYgDEF/cyAJQQNHcQ0AIApBAEoNAQtBACEGCyAHQRBqJAAgBgs8AAJ/QQEgAEQAAAAAAAAAAGENABpBACAAvSABub1SIAFCgICAgICAgHxTcg0AGiABQoCAgICAgIAEUwsL1AQHAX8BfwF/AX8BfgF/AX8CfyADQQFGBEAgACEEQQEMAQtBAyADayEFIAJBfnEhBANAAkAgBCAFTA0AIAAgBWotAAANACAFQQJqIQUMAQsLIAQgBUohBiAFQQFzIQIgACADQQFxaiEEQQILIQMgACACaiEAAkADQEEBIQcgACAETQ0BIAQtAAAiBUHghQNqLQAAQQFxBEAgAyAEaiEEDAELCwJAAkAgBUEraw4DAQIAAgsgAyAEaiEEQQAhBwwBCyADIARqIQQLIAQhBQNAAkAgACAFSwRAIAUtAABBMEYNAQtBACECA0ACQCACIAVqIgkgAE8iCg0AIAktAAAiCUEwa0H/AXFBCUsNACACIANqIQIgCEIKfiAJrUL/AYN8QjB9IQgMAQsLIAFC////////////AEKAgICAgICAgIB/IAcbIAhCACAIfSAHGyAIQgBTGzcDAAJAIAIgBCAFR3JFBEBBfyEGDAELIAYgCnINACACIQQDQEEBIQYgBCAFai0AAEHghQNqLQAAQQFxRQ0BIAUgAyAEaiIEaiAASQ0AC0EAIQYLAkAgAiADQRNsIgRJDQBBASEAIAIgBE0EQEEAIQRBACEAA0AgACAEQRFLckUEQCAFIAMgBGxqLAAAIARB6boCaiwAAGtBCmwhACAEQQFqIQQMAQsLIABFBEAgBSADQRJsaiwAAEE4ayEACyAAQQBIDQELIAFC////////////AEKAgICAgICAgIB/IAcbNwMAQQJBAyAGIAcbIAAbIQYLIAYPCyADIAVqIQUMAAsAC5wBAwF8AX4BfwJAIAAvARAiA0EgcUUEQAJ+AkAgACsDACIBRP///////9/DYw0AQv///////////wAgAUT////////fQ2QNARogAZlEAAAAAAAA4ENjRQ0AIAGwDAELQoCAgICAgICAgH8LIgJC////////////AHxCfVYgASACuWJyDQEgACACNwMACyAAIANBwOQDcUEE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AQQBfwF/AX8BfyMAQRBrIgMkACAAKAIAIQJBPCEEA0AgAiADQQxqEOYCIAJqIQIgAygCDCIBQbgBRg0ACyABQfYAa0ECSSABQaUBa0ECSXIgAUE8RnJFBEBBPCABIAFBAXRBgJ8Dai8BAEE8RhshBAsgACACNgIAIANBEGokACAEC6MBBgF/AX8BfgF/AX8BfyAAKAIAIAAoAgwiAWtBDG0hBEEBIQIgACgCCCABayIFQQxtIgZBGGxByAlqrSEDAkACQCAAQRBqIAFGBEBBACADEPUIIgFFDQIgASAAKAIMIAVBDGoQlxMaDAELIAEgAxD1CCIBRQ0BCyAAIAE2AgwgACABIARBDGxqNgIAIAAgBkEYbCABakG8CWo2AghBACECCyACC0sCAX8BfyAAKAIEIQIDQCAAKAIAIgEgACgCDE1FBEAgACABQQxrNgIAIAAgAS8BAiABQQRqELoDDAELCyACKAIAEJQBIAAgAjYCBAuvsQEYAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX8BfwF/AX8BfwF/IwBBgAZrIgYkACAAKAIAIQQCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEO2AIAAQIDBAUFBQYGBwgJCgsMDQ4MDxAREhMUFZICkQKQAo8CjgKNAowCiwKKAokCiAKHAoYChQKEAoMCggKBAoAC/wH+AQz9AfwB+wH6AfkB+AH3AfYB9QH0AfMB8gHxAfABDO8B7gGSAu0BjALsAesB6gHpAQzoAecB6AHwAeYB5QHkAe8BDOMB4gHhAeAB3wHeAd0B3AHbAdwB2gHZAdgB1wHWAdYB1QHUAQzTAdIB0QHQAc8BkgLOAc0BzAHOAcsBygHJAcgBxwHGAc8BxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQHGAbgBtwHTAbYBtQG0AbMBsgGxAbABrwGxAdMBtgGuAa0BrgGsAasBqgGpAa4BrQGuAa0BqAGnAaYBpQGkAaMBogGhAaABnwGeAZ0BnAGbAZoBmQHwAeUBmAGXAZYBlQGUAZMBkgGRAZABkAGPAY4BjQGMAYsBigGJAYgBhwGGAYUBhAGDAYIBggGCAYIBggGCAYIBgQGAAX9+fXx7enl4eHd2de8BdHXvAXNycXBvbm1srQGuAa4B0wFratMBaWhnZtMBaWVkDO8BY2JhrQGuAWBfXl1czwHPAVtaWVhXVlZVVFNSUVBPTk1MS0pJSEdnRkVEQ1RTQkFAPz49PDs6OTg3NjU1NTQ0MzIxMC8uLSwrKikoJyYlJCMFlQIilQIiISIgHx4eHRwblQIaGRgXFpUCCyADKALsAQ2UAiADQQE6ANcBDJQCCyADKALsAQ2TAiADQQI6ANcBDJMCCyADLQASDZICIAMoAgAhByADAn8gAygCKARAIActAFdFDZQCQQcMAQsCQAJAAkAgAygCCCIFDQAgBy0AsQENAiADEPYIIgUNACADQQE2AgxBACEFDAELAkAgAy0AmwFFDQAgAygCjAEiCCgCYEUNACAFQdMAEPcIGiAFQSQgCCgCXBD4CCEJIAgoAmQhCkEAIQIDQCACIAgoAmBORQRAIAVB3gAgCCgCXCACIAIgCmoQ4wgaIAJBAWohAgwBCwsgBUHUACAKIAIQjgMaIAVBJyAIKAJcIAlBAWoQjgMaQQAhAiAFKAJsIQggBSgCAC0AVwR/QcCtBwUgBSgCaCAJQRRsagsiAiAINgIICyAFQcYAEPcIGkEAIQggBSgCbCECIAUoAgAtAFcEf0HArQcFIAUoAmgLIgggAjYCCEEAIQIDQAJAQQEgAnQiCCADKAJgcUUNACAFIAUoApwBIAhyNgKcASAFQQIgAiADKAJcIAJ2QQFxIAcoAhAgAkEEdGooAgwiCCgCACAIKAIEEIMDGiAHLQCxAQ0AIAUoAmwiCEEATA0AIAUoAmggCEEUbGpBEmtBATsBAAsgAkEBaiICIAcoAhRIDQALQQAhAgNAIAIgAygC3AFORQRAIAVBqgFBAEEAQQAgByADKAKMAiACQQJ0aigCABDBB0F1EPkIGiACQQFqIQIMAQsLIANBADYC3AECQCADKAJ4IghFDQAgAygCCCEKIAMoAgAhCwNAIAhFDQEgCCgCDCEHIANBACAIKAIIIgIgCygCECACQQR0aigCDCgCSEHmABD6CCAKIAdBAWsiCSAIKAIEKAIAEPsIGiAKQQxBoIYEEIQDIgJFDQEgAiAHNgJIIAIgCTYCQCACIAc2AjQgAiAHNgIIIAIgBzYCfCACIAc2AnAgAkEQOwE+IAIgBzYC0AEgAiAHNgKQASACIAdBAmoiCTYCDCACIAk2ApQBIAIgB0EBajYCWCADKAIsRQRAIANBATYCLAsgCCgCACEIDAALAAsCQCADKAJIIghFDQBBACECIANBADoAFyAIQQhqIQoDQCACIAgoAgBODQEgAyAKIAJBBHRqIgcoAgAgBygCDBD8CCACQQFqIQIMAAsACwJAIAMtAJsBRQ0AIAMoAowBIgIoAmAiB0UNACAFQfUAIAIoAlwgBxCOAxoLIAVBARD9CBoLQQEgAygCKA0BGiAFIAMQhQMLQeUACyICNgIMDJICCyAEQQhrKAIAIQVBACECIAMoAgAhByADQRZBp+wBQQBBABD+CA2RAiADEPYIIgJFDZECAkAgBUEHRg0AQQJBASAFQQlGGyEKQQAhAwNAIAMgBygCFE4NASACQQIgAwJ/IAcoAhAgA0EEdGooAgQiCARAQQAiBSAIKAIELQAYQQFxDQEaCyAKCyIFEI4DGiACIAIoApwBQQEgA3RyNgKcASADQQFqIQMMAAsACyACQQEQ9wgaDJECCyAEQQc2AhAMkAILIAQgBC8BAjYCBAyPAgsgA0EWQQAiAkGa9gFqQZbTASAEQQprLwEAQQxGIgIbQQBBABD+CA2OAiADEPYIIgNFDY4CIANBAUEBIAIQjgMaDI4CCyADQQAgBEEEahD/CAyNAgsgA0EBIARBBGoQ/wgMjAILIANBAiAEQQRqEP8IDIsCCyADIARBCGsgBEEEaiAEQSxrKAIAQQBBACAEQRRrKAIAEIAJDIoCCyADEIEJDIkCCyAEQQA2AhAMiAILIARBFGtBATYCAAyHAgsgBCADKAIALQCxAUU2AgQMhgILIAMgBEEUayAEQQhrIAQoAgRBABCCCQyFAgsgA0EAQQBBACAEKAIEEIIJIAMoAgAgBCgCBBClCAyEAgsgBEEANgIQDIMCCyAEQRRrIgMgBCgCBCADKAIAcjYCAAyCAgsgBCgCBCECAkAgBCgCCCIFQQVHDQAgAkHHqwFBBRBtDQAgBEEIa0GABTYCAAyCAgsgBEEIa0EANgIAIAYgAjYCBCAGIAU2AgAgA0HW0gAgBhCwAgyBAgsgBCgCBCECIAQCfwJAIAQoAggiBUEGRw0AIAJBujtBBhBtDQBBgIAEDAELIAYgAjYCFCAGIAU2AhAgA0HW0gAgBkEQahCwAkEACyIDNgIEDIACCyAGIAQpAAQiETcDyAUgBiAEQQhrKQAANwPABSADKAL0ASINRQ3/ASADKAIAIg8oAoABIA0uASJMBEAgBiANKAIANgIwIANB/tcAIAZBMGoQsAIMgAILIAMtANgBQQFNBEAgBkHABWoQgwkLIBFCIIinIQUgEachDAJAAkAgEUKAgICAgAJUDQAgBSAMakEGa0G2PUEGEG0NASAMQQFrIQIgBUEGayEFQQEhEANAQcEAIQ4gBUUNgAIgAiAFai0AAEHghQNqLQAAQQFxBEAgBUEBayEFDAELCyAGIAU2AswFIAVBCUkNACAFIAxqQQlrQaevAUEJEG0NASAFQQlrIQUDQCAFRQ2AAiACIAVqLQAAQeCFA2otAABBAXEEQCAFQQFrIQUMAQsLIAYgBTYCzAULIAVBA08NAEHBACEOQQEhEAz/AQsgBkHIBWoQgwkgBigCyAUhDCAGKALMBSEFQQEhEEEAIQIDQCACQQZGBEBBwQAhDgyAAgsCQCAFIAJBpocEai0AAEcNACAMIAJBAnRB0LAFaigCACAFEG0NAEEFQQEgAkEDcUEBRhshECACQQR0QRBqIRMgAkGghwRqLQAAIQ5BACEFDIACCyACQQFqIQIMAAsACyAELwECIQIgBiAEKQIENwOwBSAEIhlBBGohCQJAIAMgAiAGQbAFahCECSIIRQ0AIAgoAggiBy0AAEEwRgRAIActAAFB3wFxQdgARiEKCyAIQZwBOgAAIAchAgNAAkACQCACLQAAIgVB3wBHBEAgByAFOgAAIAdBAWohByACLQAAIgVBLkYgBUHlAEZyRSAFQcUAR3ENAiAIQZoBOgAADAELIAJBAWstAAAhBQJAIApFBEAgBUE6a0F2SQ0BIAItAAFBOmtBdkkNAQwCCyAFQeCFA2otAABBCHFFDQAgAi0AAUHghQNqLQAAQQhxDQELIAYgCCgCCDYCoAUgA0GA+QIgBkGgBWoQsAILIAItAAAhBQsgAkEBaiECIAVB/wFxDQALAkAgCgRAIAhBnAE6AAAMAQsgCC0AAEGcAUcNAQsgCCgCCCAGQcgFahDnAkUNACAIIAYoAsgFNgIIIAggCCgCBEGAEHI2AgQLIBkgCDYCBAz+AQsgBEEsayAEQQhrKAIANgIADP0BCyAEQQhrIgUgAygCAELkABDDAiICNgIAIAJFDfwBIAMoAgAgBCgCBCAENQIIEM4IIQMgBSgCACADNgIADPwBCyAEQSBrIARBCGsoAgA2AgAM+wELAkAgAygCAELkABDDAiICBEAgAkGnAToAECACIAQoAgQ2AigMAQsgAygCACAEKAIEEDMLIAQgAjYCBAz6AQsCQCAEKAIEIgIEQCACIARBCGsoAgA2AigMAQsgAygCACAEQQhrKAIAEDMLIARBCGsgBCgCBDYCAAz5AQsgBEEIayAEKAIENgIADPgBCyAEIAQtAAI6AAQM9wELIARBCGsgBEEKay0AADoAAAz2AQsgBEEIayAELQAEOgAADPUBCyAEQQA6ABAM9AELIARBBGsgBEEIayIDKAIANgIAIAMgBC8BAjYCAAzzAQsgBEEEa0EANgIAIARBCGsgBEEKay8BADYCAAzyAQsgBEE4ayICIAMgAigCACAEQSBrKAIAIARBHGsoAgAgBEEIaygCACAEQQRrKAIAIAQtAAQQhQk2AgAM8QELIARBFGsiAiADIAIoAgAgBEEIaygCACAEQQRrKAIAQdYAQQAgBC0ABBCFCTYCAAzwAQsgBCADQQBB2wBBAEHWAEEAQQAQhQk2AhAM7wELIARBCGsiAiADIAQoAgRBAEEAIAIQhgk2AgAM7gELIARBLGsiAiADIAQoAgRBACAEQQhrKAIAIAIQhgk2AgAM7QELIARBIGsgAyAEKAIEQQAgBEEIaygCAEEAEIYJNgIADOwBCyAEQThrIgIgAyAEKAIEIARBFGsoAgAgBEEIaygCACACEIYJNgIADOsBCyAEQSxrIAMgBCgCBCAEQRRrKAIAIARBCGsoAgBBABCGCTYCAAzqAQsgBEEsayAEQQhrIgIoAgAEfyADKAIAIARBLGsoAgAgBEEoazUCABDOCCEDIAIoAgAgAzYCACACKAIABUEACyIDNgIADOkBCyADIAQoAgQgBEEUayICKAIAEIcJIAQoAgQgAigCADYCJCACIAQoAgQ2AgAM6AELIARBFGsiAiADIAIoAgAgBCgCBBCICTYCAAznAQsgBCADQQAgBCgCBBCICTYCBAzmAQsgA0EBOgAbDOUBCyAEQThrIQcgBEEgay0AACEJIARBCGsoAgAhCCAEQSxrKAIAIQogAygCACIFQhgQwwIhAgJAIAUtAFcEQCAFIAoQsgMgBSAIEKUIDAELIAIgCjYCBCACIAg2AgggAygCACAHEIkJIQMgAiAJOgAUIAIgAzYCAAsgByACNgIADOQBCyAEQRRrQQI6AAAM4wELIARBCGtBADoAAAziAQsgBEEBOgAEDOEBCyADIAQoAgRBARCKCRoM4AELIAQoAgQhAiADAn8gAygChAIiBUUEQCADIAI2AoQCIAQoAggMAQsgAiAEKAIIaiAFawsiAjYCiAIM3wELIAMQiwkgA0IANwKEAgzeAQsgAyAEQSBrIARBFGtBAEEAQQEgBEEsaygCABCACSADKAL0ASICRQ3dASACQQE6ACsgAyACIAMoAgAiBSAEQQRqEIkJEIwDIAMgAkEAEIwDIAMgAiAFIAIoAgAQnwEQjAMgAyAEKAIEIAQoAghqIAMoAsQBazYCyAEgAigCMCIHRQ3dASADQR0gAigCACAHKAIAIAMoAgAoAhAgBSACKAI8EIADQQR0aigCABD+CBoM3QELIAMgBEEEahCMCQzcAQsgA0EAEIwJDNsBCyADKAIAIQICfwJAIANBACAEQThrKAIAIgpBCGoQjQkiBUUNAEEAIAMgBRCOCQ0BGkEAIAMgBUEAEI8JDQEaIANBGiACKAIQIAIgBSgCPBCAAyINQQR0aigCACILIAUoAgBBABD+CA0AQQAgAiAEQRRrIg4QiQkiCUUNARogBEEEaiEPIAUuASIiDEEAIAxBAEobIQgDQAJAIAcgCEcEQCAFKAIEIAdBDGxqKAIAIAkQbA0BIAchCAsCQAJAAkAgCCAMRgRAIAYgDjYC0AQgA0HM+QIgBkHQBGoQsAIMAQsgAyALIA1BAUYiDEGBgQNBABCQCSADIAsgDBCRCSADKAJ8IgcgAyAHG0EBOgAVIAIgDxCJCSIHDQELQQAhBwwBCyAPKAIALQAAIQ8gBiAFKAIAIhA2ApwFIAYgDDYCmAUgBiAHNgKQBSAGIA9BACIOQeCFA2pqLQAAQYABcSIPNgKUBSAGIAg2AowFIAYgEDYCiAUgBiALNgKEBSAGIAs2AoAFIANB7dECIAZBgAVqEJIJIAUoAgAhBSAGIA82AvAEIAYgBzYC7AQgBiAINgLoBCAGIAU2AuQEIAYgCzYC4AQgA0H44QIgBkHgBGoQkgkgAyANQQEQkwkgAyALIAxBoZwBQQEQkAkLIAkMAwsgB0EBaiEHDAALAAtBAAshCCACIAoQqgggAiAIEDIgAiAHEDIM2gELIAMQgQkgBCgCBCECAkAgAygCACIFLQBXDQAgA0EAIAJBCGoQjQkiCEUNAAJAAkACQCAILQArQQFrDgIAAQILIANBrbABQQAQsAIMAgsgA0HLK0EAELACDAELIAMgCBCOCQ0AIAMoAnwiByADIAcbQQE6ABUgBSAIKAI8EIADIQsgBULAABDDAiIKRQ0AIAMgCjYC9AEgCkEBNgIYIAogCC4BIiIDOwEiIAogBSADQQFrQQhtQeAAbEHgAGqtEMMCNgIEIAYgCCgCADYCwAQgCiAFQYzTACAGQcAEahCBAyIDNgIAIAooAgQiB0UgA0VyDQAgByAIKAIEIAouASJBDGwQlxMaQQAhAwNAIAMgCi4BIk5FBEAgCigCBCADQQxsaiIHIAUgBygCABCfASIJNgIAIAcgCRCUCToAByADQQFqIQMMAQsLIAogBSAIKAI0QQAQlQk2AjQgCiAFKAIQIAtBBHRqKAIMNgI8IAogCCgCLDYCLAsgBSACEKoIDNkBCyAEQSBrKAIAIQcCQCADKAIAIgItAFcNACADQQAgB0EIahCNCSIIRQ0AIAMgCBCOCQ0AIAMgCEEBEI8JDQAgAiAEQQRqIgkQiQkiCkUNAAJAIAggChCWCSIFQQBIBEAgBiAJNgKABCADQcz5AiAGQYAEahCwAgwBCyAIKAIEIAVBDGxqLwEKIglBCXEEQCAGIAo2ArQEIAZBACIFQcrHAUGegQIgCUEBcRtqNgKwBCADQc/4AiAGQbAEahCwAgwBCyAILgEiQQFMBEAgBiAKNgKQBCADQcgvIAZBkARqELACDAELIANBGiACKAIQIAIgCCgCPBCAAyILQQR0aigCACIJIAgoAgAgChD+CA0AIAMgCSALQQFGIg1BAEGBgQNqQQAQkAkgAyAJIA0QkQkgBiAIKAIANgKsBCAGIAU2AqgEIAYgCzYCpAQgBiAJNgKgBCADQcLNAiAGQaAEahCSCSADIAtBAhCTCSADIAkgDUG//gBBARCQCSADKAIoDQAgCCgCBCAFQQxsai0ACkEgcQ0AIAMQ9gghDCADIAMoAiwiD0EBajYCLCADIA8gCyAIQfEAEPoIIAxBJCAPEPgIIRcgAyADKAIwIglBAWoiFjYCMCADAn8gCC0AHEGAAXFFBEAgDEGHASAPIBYQjgMaIAlBAmohDkEAIQ1BACELIAMoAjAgCC4BImoMAQsgAyAWIAgQswMiCy8BNGo2AjAgCUECaiEOQQAhCQNAIAkgCy8BMiINT0UEQCAMQd4AIA8gCSAJIA5qEOMIGiAJQQFqIQkMAQsLIAMoAjALIglBAWoiEjYCMEEAIQkDQCAJIAguASJORQRAAkAgBSAJRg0AIAlBDGwiEyAIKAIEaiIQLQAKQSBxDQACfyALBEAgCyAJwRDpAiEUIAsgBcEQ6QIhFSAUIAsvATJIDQIgDiAUaiAUIBVKawwBCyANIA5qCyEUAkAgCC4BICAJRgRAIAxBywBBACAUEI4DGgwBCyAQLQAFIhVBxQBGBEAgEEHDADoABQsgDCAIIA8gCSAUEJcJIAgoAgQgE2ogFToABQsgDUEBaiENCyAJQQFqIQkMAQsLIA1FBEAgAyADKAIwQQFqNgIwIAxBywBBACAOEI4DGkEBIQ0LIAxB4QAgDiANIBIQ4wgaAkAgCwRAIAxBigEgDyASIA4gCy8BMhCDAxoMAQsgDEGAASAPIBIgFhDjCBoLIAwoAmwiA0EASgRAIAwoAmggA0EUbGpBEmtBAjsBAAsgDEEnIA8gF0EBahCOAxpBACEFIAwoAmwhAyAMKAIALQBXBH9BwK0HBSAMKAJoIBdBFGxqCyIFIAM2AggLIAohBQsgAiAFEDIgAiAHEKoIDNgBCyAEQQRrIgUgAygC0AEgAygCzAEgBEEIayIKKAIAa2o2AgAgAygCKA3XASADKAIAIgcoAhAgByADKAL0ASICKAI8EIADIgtBBHRqKAIAIQggAiACKAIEIAIuASJBDGxqIglBDGsQmAkhDCADQRogCCAHIAIoAgBBEGoiDSAIEIgDIg4oAgBBABD+CA3XASAJQQJrIhAvAQAiD0EBcQRAIANBwP8AQQAQsAIM2AELIAIoAggEQCADQeD/AEEAELACDNgBCwJAIA9B4ABxRQRAIAwEfyAMQQAgDCgCDC0AAEH6AEcbBUEACyEMAkAgBy0AIUHAAHFFDQAgAigCMEUgDEVyDQAgAyAIIA1BqpMBEJkJCyAJQQhrLQAAQQ9xRSAMckUEQCADIAggDUGV7wEQmQkMAgsgDEUNASAGQQA2AsgFIAcgDEEBQcEAIAZByAVqEOwCDdkBIAYoAsgFIgxFBEAgAyAIIA1B3jcQmQkLIAwQ8wEMAQsgD0HAAHFFDQAgAyAIIA1B+/8AEJkJCyAHIAooAgAgBTUCABDOCCIMBEAgDCAFKAIAaiEFA0ACQCAFQQFrIgUgDE0NACAFLQAAIgpBO0cEQCAKQeCFA2otAABBAXFFDQELIAVBADoAAAwBCwsgAigCLCEFIAYgDTYC8AMgBiAFNgLsAyAGIAw2AugDIAYgBTYC5AMgBiAINgLgAyADQb3lASAGQeADahCSCSAHIAwQNQsgAxD2CCIFRQ3XASAFQeMAIAsgAxCaCSIHQQIQ4wgaIAUgBSgCnAFBASALdHI2ApwBIAVB1gAgB0F+EI4DGiAFQTIgByAFKAJsQQJqEI4DGiAFQeQAIAtBAkEDEOMIGiADIAcQmwkgAyALQQMQkwkCQCACKAIQDQAgCUEIay0AAEEPcQRAIBAtAABB4ABxDQELIA4tAB5BAXFFDdgBCyAGIAg2AtQDIAYgDTYC0AMgA0HY7AIgBkHQA2oQkgkM1wELIARBIGsoAgAhBwJAIAMoAgAiAi0AVw0AIANBACAHQQhqEI0JIgpFDQAgAigCECADKAIAIAooAjwQgAMiC0EEdGooAgAhCSACIARBBGoQiQkiCEUNAAJAAkACQCACIAggCRCIAw0AIAIgCCAJEJsIDQAgAiAKIAgQnAlFDQELIAYgCDYCwAMgA0GB5QAgBkHAA2oQsAIMAQsgAyAKEI4JDQAgAyAIQcajASAIEJ0JDQAgCigCACEFIAotACtBAkYEQCAGIAU2AsACIANBz7ABIAZBwAJqELACDAELIANBGiAJIAVBABD+CA0AIAMgChCeCQ0AIAotACtBAUYEQCACIAoQwQciBUEAIAUoAggoAgAoAkwbIQ0LIAMQ9ggiD0UNACADKAJ8IgUgAyAFG0EBOgAVIAooAgAiBRCfCSEQIAYgBTYCtAMgBiALQQFGIgw2ArADIAYgCDYCrAMgBiAFNgKoAyAGIAk2AqQDIAYgCTYCoAMgA0EAQaDrAmogBkGgA2oQkgkgBiAFNgKUAyAGIBA2ApADIAYgCDYCjAMgBiAINgKIAyAGIAg2AoQDIAYgCTYCgAMgA0HWpAIgBkGAA2oQkgkgAkHdpwEgCRCIAwRAIAYgCigCADYC+AIgBiAINgL0AiAGIAk2AvACIANBg+UBIAZB8AJqEJIJCyAMRQRAIAYgCDYC5AIgBiAJNgLgAiAGIAU2AtwCIAYgCDYC2AIgBiAFNgLUAiAGIAk2AtACIANB++ICIAZB0AJqEJIJCyANBEAgAyADKAIwQQFqIgU2AjAgDyAFIAgQ+wgaIA9BsQEgBUEAQQAgDUF1EPkIGgsgAyALQQEQkwkgAyAJIAxBoZwBQQAQkAkLIAghBQsgAiAHEKoIIAIgBRAyDNYBCyADIARBCGsgBEEEahCgCQzVAQsgA0EAQQAQoAkM1AELIAMgBEEIayAEQQRqEKEJDNMBCyADQQBBABChCQzSAQsgA0EZQfjABSAEKAIEIgJBAEEAIAIQogkM0QELIANBGEGAwAUgBEEgaygCACICIAIgBEEIaygCACAEKAIEEKIJDNABCyAEKAIEIQoCQCADKAIAIgUtAFcNACAEQQhrKAIAIQsgAxCHAw0AIApBCGohDSAKKAIIIQkgCigCNCEIQQAhAgJAA0AgBSgCFCACSgRAIAIgAkECSXMhBwJAIAgEQCAFIAcgCBDPCEUNAQsgBSgCECAHQQR0aigCDEEoaiAJEIkDIgcNAwsgAkEBaiECDAELCwJAIAtFBEAgBiANNgKwAiADQZndASAGQbACahCwAgwBCyADIAgQowkLIANBAToAEQwBCyADIAcQpAkLIAUgChCqCAzPAQsgBEEDNgIEDM4BCyAEQQE2AgQMzQELIARBOGsgA0HIACAEQQhrKAIAQQAQpQkiAzYCACADRQ3MASADIARBIGsoAgA6AAEMzAELIARBIGsgA0HIAEEAQQAQpQkiAzYCACADRQ3LASADQQQ6AAEMywELIARBFGsiBSgCACEIIARBCGsoAgAhByAEKAIEIQoCQCADKAIAIgJCMBDDAiIDRQRAIAIgBxClCAwBCyADIAc2AgggA0GLFzsBACADIAIgCCAKEKYJNgIkCyAFIAM2AgAMygELIARBCGsoAgAhBSADKAIAIQcgA0GBASAEQSBrIARBOGsiCCgCACAEKAIEEKcJIgIEQAJAIAMtANgBQQFLBEAgBSEDQQAhBQwBCyAHIAVBARCoCSEDCyACQQs6AAEgAiADNgIUCyAHIAUQMyAIIAI2AgAMyQELIARBCGsoAgAhByAEQcQAaygCACELIARBFGsoAgAhCCAEQSBrKAIAIQkgAygCACEFAkAgA0GAASAEQSxrIARB0ABrIgooAgAgBCgCBBCnCSICBEACQCADLQDYAUEBSwRAIAghDUEAIQgMAQsgBSAIQQEQqQkhDQsgAiAHNgIgIAIgCTYCHCACIA02AgggAiALOgABIAdFDQEgAyAHKAIAEKoJGgwBCyAFIAkQNCAFIAcQ8QgLIAUgCBClCCAKIAI2AgAMyAELIARB0ABrKAIAIQsgBEEIaygCACEHIARBIGsoAgAhCCAEQRRrKAIAIQogAygCACECIANBggEgBEHEAGsgBEHcAGsiCSgCACAEKAIEEKcJIgUEQAJAIAMtANgBQQJPBEAgBSAHNgIUIAUgCDYCGEEAIQcgCiEDQQAhCEEAIQoMAQsgBSACIAhBARCVCTYCGCAFIAIgB0EBEKgJNgIUIAIgCkEBEKsJIQMLIAUgCzoAASAFIAM2AhALIAIgCBCyAyACIAcQMyACIAoQqgggCSAFNgIADMcBCyADQYTFAEEAELACDMYBCyADQbDEAEEAELACDMUBCyAEQRRrIAQpAgQ3AgAgA0HZxQBBABCwAgzEAQsgBEEIaygCACIDIAM2AiwMwwELIARBFGsiAygCACgCLCAEQQhrKAIAIgI2AiggAygCACACNgIsDMIBCyAEQQhrIAQoAgQ2AgAMwQELIARBADYCEAzAAQsgBEEUa0GCATYCACAEQRBrIAQoAgQ2AgAMvwELIARBADYCCCAEIAQvAQI2AgQMvgELIARBITYCEAy9AQsgBEEIa0HCADYCAAy8AQsgBCAELwECNgIEDLsBCyAEQcQAayEJIARB0ABrIQ0gBEHcAGsoAgAhECAEQRRrKAIAIQUgBEEoaygCACEIIARBLGsoAgAhFCAEQThrKAIAIQ8gAygCACECIAQoAgQhCgJAAkACQAJAIARB9ABrIgsoAgAiEwRAIARBQGooAgAEQCADQeacAUEAELACDAQLIAYgDTYCwAVBASEOIAUNAQwCCyAFRSADIA0gCSAGQcAFahCsCSIOQQBIcg0CCyACLQBXDQECQCAOQQFGDQAgAi0AsQFFDQAgAiAFKAI0EDIgBUEANgI0CyADIAUQrQkhDAJAIAItALEBDQAgBEFAaigCACAMRXINAEEBIA4gDCgCPCACKAIQKAIcRhshDgsgAi0AVw0BIAMoAgAhByAGIAM2AsgFIAYgBygCECAOQQR0aiIHKAIANgLwBSAGIAcoAgw2AugFIAYgAzYCzAUgBkEBIgdBC2o2AtAFIAZBDTYC1AUgBkEONgLYBUEAIQcgBkEANgLcBSAGQQA7AeAFIAYgDkEBRjoA7AUgBkHf7wA2AvQFIAYgBigCwAUiFTYC+AUgBiAGQcgFajYC5AUgBkHIBWogBRCxCQ0BQQAhDAJAIAMgBRCtCSISRQ0AIBItACtBAUYEQCADQZvOAEEAELACDAELAkAgEi0AHUEQcUUNACACELIJRQ0AIANB880AQQAQsAIMAQsgAiAVEIkJIgdFDQEgAyAHQd/vACASKAIAEJ0JDQICQCADLQDYAUEBSw0AIAIoAhAgDkEEdGooAgxBKGogBxCJA0UNACAQRQRAIAYgFTYCoAIgA0HUPiAGQaACahCwAgwECyADIA4QswkMAwtBACEQIBIoAgAiFUGwwQFBBxBtRQRAIANB958BQQAQsAIMBAsgD0HCAEYgEi0AKyIQQQJHckUEQCAGIAVBCGo2AoQCIAZBACIOQcSGAkGk4AEgD0EhRhtqNgKAAiADQfTcASAGQYACahCwAgwBCyAQQf8BcUECRiAPQcIAR3JFBEAgBiAFQQhqNgKQAiADQa3dASAGQZACahCwAgwBCyADLQDYAUEBTQRAIAIoAhAiFiACIBIoAjwQgAMiEEEEdGooAgAiFyEMIBMEQCAWKAIQIQwLIANBBUEFQQcgEEEBRiIQGyATGyAHIBUgDBD+CA0DQQAhDCADQRJB/u0AQZHuACAQG0EAIBcQ/ggNBAsgAkIkEMMCIgxFDQIgDCAHNgIAIAwgAiAFKAIIEJ8BIhA2AgQgDCACKAIQIA5BBHRqKAIMNgIUIBIoAjwhByAMQQFBAUECIA9BIUYbIA9BwgBGGzoACSAMIBQ6AAggDCAHNgIYAkAgAy0A2AFBAk8EQCADIBAgBSgCCBC0CSAKIQdBACEKDAELIAIgCkEBEKgJIQcLIAwgCDYCECAMIAc2AgwgAyAMNgL8AUEAIQdBACEIDAMLIAItALABQQFHDQIgAiACLQCyAUEBcjoAsgEMAgtBACEHC0EAIQwLIAIgBxAyIAIgBRCqCCACIAgQNCACIAoQMyADKAL8AUUEQCACIAwQKgsgBEFAaigCAEUEQCALIA0pAgA3AgAMuwELIAsgCSkCADcCAAy6AQsgBEEIaygCACECIARBIGsoAgAhDiADKAIAIQkgAygC/AEhBSAEKAIIIQcgBCgCBCEIIANBADYC/AECQCADKAIoIAVFcg0AIAggDmsgB2ohECAFKAIAIQwgCSAFKAIUEIADIQ0gBSACNgIcIAVBHGohDwNAIAIEQCACIAU2AgQgAigCKCECDAELCyAGIAw2AsAFIAwQWSECIAYgAzYCyAUgBiACNgLEBSAGIAkoAhAgDUEEdGoiAigCADYC8AUgAigCDCECIAZB3+8ANgL0BSAGIAI2AugFIAYgDUEBRjoA7AUgBkEAOwHgBSAGQQA2AtwFIAZBASICQQ1qNgLYBSAGQQ02AtQFIAZBDDYC0AUgBiADNgLMBSAGIAZBwAVqNgL4BSAGIAZByAVqNgLkBSAGQcwFaiEIIA8hAgNAIAIoAgAiCwRAQQAhAiAIIAsoAggQtQkNAiAIIAsoAhQQtgkNAiAIIAsoAhgQtwkNAiAGQcgFaiALKAIQELEJDQIgC0EgaiEKA0AgCigCACIHBEAgCCAHKAIAELcJDQQgCCAHKAIEELYJDQQgCCAHKAIIELcJDQQgB0EQaiEKIAggBygCDBC2CUUNAQwECwsgC0EoaiECDAELC0EAIQIgCCAFKAIMELYJDQACQCADLQDYAUECTwRAIAMgBTYC/AFBACEFDAELIAktALEBDQACQCAJELIJRQ0AA0AgDygCACIHRQ0BAkAgBygCDCIIBEAgCSAIELgJDQELIAdBKGohDwwBCwsgBSgCACEIIAYgBygCDDYC9AEgBiAINgLwASADQen2AiAGQfABahCwAgwCCyADEPYIIghFDQEgA0EAIA0QuQkgCSAOIBCtEM4IIQcgCSgCECANQQR0aigCACEKIAUoAgQhCyAGIAc2AuwBIAYgCzYC6AEgBiAMNgLkASAGIAo2AuABIANBACIKQaHlAmogBkHgAWoQkgkgCSAHEDIgAyANELoJIAYgDDYC0AEgCCANIAlBiukCIAZB0AFqEIEDQQAQuwkLIAktALEBRQ0AIAkoAhAgDUEEdGooAgxBKGogDCAFEO0DIgMEQCAJEJQBIAMhBQwBCyAFKAIYIgMgBSgCFEYEQCAFIANBCGogBSgCBBCJAyIDKAI4NgIgIAMgBTYCOAtBACEFCyAJIAUQKiAJIAIQMQy5AQsgAyAEQSxrIARBIGsgBEEIa0EBELwJDLgBCyADIARBIGsgBEEUayAEQQRqQQEQvAkMtwELIAMgBEEsayAEQSBrIARBCGtBABC8CQy2AQsgAyAEQSBrIARBFGsgBEEEakEAELwJDLUBCyADIARBCGsgBEEEakEAQQAQvAkMtAELIAMgBEEIayAEKAIEEL0JDLMBCyADQQAgBCgCBBC9CQyyAQsgBCgCBCECAkAgAygCACIFLQBXDQAgBEEIaygCACEHIAMQhwMNACAFIAIoAgggAigCNBCbCCIIRQRAAkAgB0UEQCAGIAJBCGo2AqABIANB4twBIAZBoAFqELACDAELIAMgAigCNBCjCSADEL4JCyADQQE6ABEMAQsgCC0AN0EDcQRAIAZBADYCwAEgA0GNsQEgBkHAAWoQsAIMAQsgBSAIKAIYEIADIQcgCCgCDCEJIANBCUH+7QBBke4AIAdBAUYiCxtBACAFKAIQIAdBBHRqKAIAIgoQ/ggNACADQQxBCiALGyAIKAIAIAkoAgAgChD+CA0AIAMQ9ggiCkUNACADQQEgBxC5CSAFKAIQIAdBBHRqKAIAIQkgBiAIKAIANgK0ASAGIAk2ArABIANBACIJQcrmAmogBkGwAWoQkgkgAyAHQcspIAgoAgAQvwkgAyAHELoJIAMgCCgCLCAHEMAJIApBmAEgB0EAQQAgCCgCAEEAEPkIGgsgBSACEKoIDLEBCyAEQRRrIgIgA0EAIAIgBEEIaygCACAEKAIEEMEJNgIADLABCyAEQSxrIgIgAyACKAIAIARBFGsgBEEIaygCACAEKAIEEMEJNgIADK8BCyAEQQA2AhAMrgELIARBAjYCBAytAQsgAyAEQdAAayAEQcQAayADQQAgBEEsayICQQAQwgkgBEEUaygCACAEQfQAaygCACAEQYABayAEKAIEQQAgBEHcAGsoAgBBABDDCSADLQDYAUECSQ2sASADKAL4ASIFRQ2sASADIAUoAgAgAhDECRoMrAELIARBFGsgBEEIaygCADYCAAyrAQsgBCADKAIAIAQoAgQQxQk2AgQMqgELIARBFGsiAiADIAIoAgAgBCgCBBDGCTYCAAypAQsgBEEgayICIAMoAgAgBEEUaygCABDFCSIFNgIAIAIgAyAFIAQoAgQQxgk2AgAMqAELIARBLGsiAiADIAIoAgAgBEEUaygCABDGCSIFNgIAIAIgAyAFIAQoAgQQxgk2AgAMpwELIARBLGsiByADQZ4BIARBIGsoAgBBABClCSICNgIAIAIEQCAEQRRrKAIAIQUgBEEIaygCACIIBEAgAyAFIAgQxgkhBSAHKAIAIQILIAIgBTYCFCADIAcoAgAQxwkMpwELIAMoAgAgBEEUaygCABCyAyADKAIAIARBCGsoAgAQMwymAQsgBEEgayADQRRBAEEAEKUJIgI2AgAgAyACIARBCGsoAgAQyAkMpQELIANBACADQQAgBEEUayAEQQhrEMIJIgJBAEEAQQBBAEEAQQAQyQkhBSAEKAIEIgcEQCADIAJBACAFGyAHEMoJCyAEQSxrIgIgA0EyIAIoAgBBABClCSIHNgIAIAMgByAFEMgJIARBIGsoAgBFDaQBIAIgA0ETIAIoAgBBABClCTYCAAykAQsgBEEsayICIANBMiACKAIAQQAQpQkiBTYCACADIAUgBEEIaygCABDICSAEQSBrKAIARQ2jASACIANBEyACKAIAQQAQpQk2AgAMowELIARBFGsgA0GLAUEAQQAQpQkiAjYCACADIAIgBEEIaygCABDICQyiAQsgBEEIayICKAIAIgVFBEAgAyAEQSxrIgIoAgAQywkgAiADKAIAQfYAQYyTAUGFmAEgBEEgaygCACIFGxDMCSIDNgIAIANFDaIBIAMQzQkaDKIBCwJAAkAgBSgCAEEBRw0AAkAgAyAFKAIIIgcQzglFBEAgAigCACEFDAELIAIoAgAhBSAEQSxrIggoAgAtAABBsQFGDQAgBUEANgIIIAMoAgAgAigCABCyAyADQa0BIAdBABClCSECIAggA0E2IAgoAgAgAhClCTYCAAwCCyAFKAIAQQFHDQAgBy0AAEGLAUcNACAEQSxrIgUgA0EyIAUoAgBBABClCSIINgIAIAMgCCAHKAIUEMgJIAdBADYCFCADKAIAIAIoAgAQsgMMAQsgBEEsayINIANBMiANKAIAQQAQpQkiBTYCACAFRQRAIAMoAgAgAigCABCyAwwBCyAFKAIMIgctAABBsQFGBEAgAigCACIKQQhqIQsgBygCFCgCACEJQQAhCEEAIQIDQAJAAkAgCigCACACSgRAQQEhByALIAJBBHRqKAIAIgUtAABBsQFGBEAgBSgCFCgCACEHCyAHIAlGBEAgAyAFKAIUQQBBAEEAQQBBAEGABEEAEMkJIQcgBUEANgIUIAdFDQMgCEUNAiAHIAg2AjQgB0GIAToAAAwCCyAGIAk2ApgBIAYgBzYCkAEgBkEAIgJB3OsAQYGBAyAHQQFKG2o2ApQBIANB+bwBIAZBkAFqELACCyAIBEAgCCgCNARAIAggCCgCBEGACHI2AgQLIAMoAgAgChCTAyADIAgQzwkgAyANKAIAIAgQyAkMBQsgAygCACAKEJMDDAQLIAchCAsgAkEBaiECDAALAAsgBSACKAIANgIUIAMgDSgCABDHCQsgBEEgaygCAEUNoQEgBEEsayICIANBEyACKAIAQQAQpQk2AgAMoQELIAMgAygCACAEQRRrKAIAEMUJIAQoAgQQxgkhByAEQSxrIgIgA0ExIAIoAgBBABClCSIFNgIAAkAgBQRAIAUgBzYCFAwBCyADKAIAIAcQsgMLIARBIGsoAgBFDaABIAIgA0ETIAIoAgBBABClCTYCAAygAQsgBEEANgIEDJ8BCyAEQRRrIgIgAyADIAMoAgAgAigCABDFCSAEKAIEEMYJIARBCGtBABDQCTYCAAyeAQsgBEEKay0AAEHCAGohBQJAIAQoAgQiAkUNACACLQAAQa0BRw0AIAIgBToAACAEQQhrIAI2AgAMngELIARBCGsgAyAFQf8BcSACQQAQpQk2AgAMnQELIARBCGsgAyAEQQprLwEAIAQoAgRBABClCTYCAAycAQsgBEEsayICIANBLiACKAIAIAQoAgQQpQkiBTYCACADIAQoAgQgBUE0ENEJDJsBCyAEQThrIgIgA0EtIAIoAgAgBCgCBBClCSIFNgIAIAMgBCgCBCAFQTMQ0QkMmgELIARBIGsiAiADQS4gAigCACAEKAIEEKUJIgU2AgAgAyAEKAIEIAVBNBDRCQyZAQsgBEEUayICIANBLSACKAIAIAQoAgQQpQkiBTYCACADIAQoAgQgBUEzENEJDJgBCyAEQRRrIgIgA0E0IAIoAgBBABClCTYCAAyXAQsgBEEIayICIAMgBC8BAiACKAIAQQAQpQk2AgAMlgELIARBHGsiAiACKAIAIgdB/////wdxNgIAIARBLGsiBSADIAMgAyADKAIAIARBFGsoAgAQxQkgBSgCABDGCSAEKAIEEMYJIARBIGtBABDQCSICNgIAIAdBAEgEQCAFIANBEyACQQAQpQkiAjYCAAsgAkUNlQEgAiACKAIEQYACcjYCBAyVAQsgBEEEayICIAIoAgAiB0H/////B3E2AgAgBEEUayIFIAMgAyADKAIAIAQoAgQQxQkgBSgCABDGCSAEQQhrQQAQ0AkiAjYCACAHQQBIBEAgBSADQRMgAkEAEKUJIgI2AgALIAJFDZQBIAIgAigCBEGAAnI2AgQMlAELIARBCGsgBCkCBCIRNwIAIARBBGsgEUIgiKdBgICAgHhyNgIADJMBCyAEQRRrIgIgAyAEQQprLwEAIAIoAgAgBCgCBBClCTYCAAySAQsgBEEUayICIAMgAigCACAEKAIEENIJNgIADJEBCyADIARBIGsoAgAgBEEIaygCABDGCSECIARBLGsiByADQbEBQQBBABClCSIFNgIAIAUEQCAFIAI2AhQgAigCAEUNkQEgBygCACIDIAMoAgQgAigCCCgCBEGIhIACcXI2AgQMkQELIAMoAgAgAhCyAwyQAQsgBCADQQAgBEEEakEAENAJNgIEDI8BCyADIANBACAEQSxrIgJBABDQCSIFIAQoAgQQ0wkgAiAFNgIADI4BCyADIAMgBEE4aygCACAEQdwAayIFIARBxABrKAIAENAJIgIgBCgCBBDTCSADIAIgBEEUaygCABDUCSAFIAI2AgAMjQELIAMgAyAEQRRrKAIAIARBOGsiAiAEQSBrKAIAENAJIgUgBCgCBBDTCSACIAU2AgAMjAELIARBIGsiAiADQQAgAkEAENAJNgIADIsBCyADIAMgBEEsaygCACAEQdAAayICIARBOGsoAgAQ0AkiBSAEQQhrKAIAENQJIAIgBTYCAAyKAQsgBEEsayICIAMgBEEIaygCACACIARBFGsoAgAQ0Ak2AgAMiQELIARBOGsgAygCAEEkIARBCGtBARDVCSICNgIAIAMoAgAgAiAEQSBrKAIAQQAQ1gkMiAELIARBFGsiAiADIAIoAgAgBEEEakEBENcJNgIADIcBCyAEIhhBBGohAgJAAkAgBCgCBCIFLQAAQSNGBEAgBS0AAUE6a0F1Sw0BCyAEKAIIIQcgBiAYKQIENwOIASAEIANBnQEgBkGIAWoQhAkiAjYCBCACRQ2IASADKAIAIQgCQCACKAIIIgowAAEiEVAEQCADIAMvAdQBQQFqIgU7AdQBDAELAkACQCAKLQAAQT9GBEACfiAHQQJGBEAgEUIwfQwBCyAKQQFqIAZByAVqIAdBAWtBARD8AkEARyEJIAYpA8gFCyIRQgBXIAlyIBEgCCgCnAEiBaxVcg0FIBGnwSIFIAMuAdQBTA0BIAMgBTsB1AEgAygC6AEhCQwCCyADKALoASIJIAogBxDcAiIFQf//A3ENAiADIAMvAdQBQQFqIgU7AdQBDAELIAMoAugBIgkgBRDZAg0BCwJAAkAgCCAJIAdBBG1BA2oiDawgCQR+IAkoAgQiDCANaiIOIAkoAgAiC0wEQCAJIQsMAgsgC6xCAYYFQgoLIhF8IhFCAoYQYCILRQRAIAkhCwwCCwJ/IAkEQCALKAIEDAELIAtBAjYCBEECCyEMIAsgET4CACAMIA1qIQ4LIAsgDEECdGoiCSAFwTYCACAJIA02AgQgCyAONgIEIAlBCGogCiAHEJcTIAdqQQA6AAALIAMgCzYC6AELIAIgBTsBICAIKAKcASAFwU4NiAEgA0H+zwBBABCwAiADKAIAIAIQVgyIAQsgBiAYKQIEIhE3A8gFIAMtABJFBEAgAyAGQcgFahC5AyAYQQA2AgQMiAELIBggA0GwAUEAQQAQpQkiAzYCBCADRQ2HASARp0EBaiADQRxqEOcCGgyHAQsgBiAFNgKAASADQfW3ASAGQYABahCwAiADKAIAIAIQVgyGAQsgAygCAEGcASAEIhpBBGoiAkEBENUJIgUEQCAFIAQoAgQgAygC8AFrNgIkCyAaIAU2AgQMhQELIAQvAQIhAiAGIAQpAgQ3A3ggBCADIAIgBkH4AGoQhAk2AgQMhAELIAYgBEEsayIFKQIANwNwIANBPCAGQfAAahCECSECIAYgBEEUaykCADcDaCADQTwgBkHoAGoQhAkhByAGIAQpAgQ3A2AgA0GOASAHIANBPCAGQeAAahCECRClCSEHIAMtANgBQQJPBEAgA0EAIAIQtAkLIAUgA0GOASACIAcQpQk2AgAMgwELIAYgBEEUayICKQIANwNYIANBPCAGQdgAahCECSEFIAYgBCkCBDcDUCACIANBjgEgBSADQTwgBkHQAGoQhAkQpQk2AgAMggELIAYgBCkCBDcDSCAEIANBPCAGQcgAahCECTYCBAyBAQsgBEEUayAEQQhrKAIANgIADIABCyAEIANBACAEQQRqENgJNgIEDH8LIARBFGsiAiADIAIoAgAgBEEEahDYCTYCAAx+CyAEQRRrIARBCGsoAgA2AgAMfQsgBEEANgIQDHwLIAMgBCgCBBDZCQx7CyAEQdAAayADKAIAQQBBACAEQRRrKAIAIARBCGsoAgBBABDaCTYCAAx6CyAEQSxrIAMoAgBBAEEAQQBBAEEAENoJNgIADHkLIARB3ABrIAMoAgAgBEE4aygCACAEQSBrKAIAQQBBACAEKAIEENoJNgIADHgLIARBgAFrIAMoAgAgBEHcAGsoAgAgBEHEAGsoAgAgBEEUaygCACAEQQhrKAIAIAQoAgQQ2gk2AgAMdwsgBEEIa0EANgIAIAMgBCgCBBDZCQx2CyAEQQA2AhAMdQsgAyAEQSxrKAIAQQAgBEEgaygCACAEQcQAaygCAEEAENsJDHQLIAMgBEEgaygCACAEQQhrKAIAIARBFGsoAgAgBEE4aygCACAEKAIEENsJDHMLIARBLGsgA0EAIARBIGsoAgAgBCgCBBDcCTYCAAxyCyADIAMoAgAgBCgCBBDFCSICIARBFGsiBUEBEN0JIAUgAjYCAAxxCyAEQcQAayICIAMgAigCACAEQSBrKAIAIAQoAgQQ3Ak2AgAMcAsgBEEsayICIAMgAigCACAEKAIEEMYJIgU2AgAgAyAFIARBFGtBARDdCQxvCyADIARBOGsiBSgCACAEQSxrEN4JIAMgBEEUayIHKAIAQfEwEN8JAkAgBEEIaygCACICRQRAIAUoAgAhAgwBCyACKAIAQQJOBEAgA0EAIAJBAEEAQQBBAEGAEEEAEMkJIQIgBkIANwLIBSADQQBBAEEAIAZByAVqIAJBABDgCSECCyAFIAMgBSgCACACEOEJIgI2AgALIAMgAiAHKAIAIAQoAgQgBEHEAGsoAgBBABDiCQxuCyADIAQoAgQQ2QkgBEEgayAEQRRrKAIANgIADG0LIAMgBCgCBBDZCSAEQQhrQQA2AgAMbAsgAyAEQRRrIgIoAgAgBEEIaxDeCSADIAIoAgAgBCgCBBDjCQxrCyAEQSBrIANBlQEgBCgCBCAEQRRrKAIAEKUJNgIADGoLIARBIGsgA0GVASAEQRRrKAIAIAQoAgQQpQk2AgAMaQsgBEEIayADQZUBIAQoAgRBABClCTYCAAxoCyAEQQhrIAQoAgQ2AgAMZwsgBEEANgIQDGYLIARBCGtBATYCAAxlCyAEQQhrQQA2AgAMZAsgBEF/NgIQDGMLIARBATYCBAxiCyAEQQA2AgQMYQsgBEEUayICIAMoAgAgAigCABDFCSIDNgIAIAMgBEEIaygCACAEKAIEEOQJDGALIARBLGsiAiADIAIoAgAgBEEUaygCABDGCSIDNgIAIAMgBEEIaygCACAEKAIEEOQJDF8LIARBFGsgBCgCBDYCAAxeCyAEQQhrQoCAgIAQNwIADF0LIARBFGsgBCkCBDcCAAxcCyAEQgA3AhAMWwsgBEEga0EANgIAIARBHGsgBEEIaygCADYCAAxaCyAEQQRrQQA2AgAgBEEIayAEKAIENgIADFkLIARBIGsiAiADIAIgBEEUayAEQQhrEOUJNgIADFgLIARBFGsiAiADIAIgBEEIa0EAEOUJNgIADFcLIARBCGsiAiADIAJBAEEAEOUJNgIADFYLIARBATYCBAxVCyAEQRRrIgIgA0EAIAJBABDCCSIFNgIAIAVFDVQgAygCACAEQQRqEIkJIQMgAigCACADNgIMDFQLIARBLGsiAiADQQAgAiAEQRRrEMIJIgU2AgAgBUUNUyADKAIAIARBBGoQiQkhAyACKAIAIAM2AgwMUwsgBEEUayICIANBACACIARBBGoQwgk2AgAMUgsgBCADQQAgBEEEakEAEMIJNgIEDFELIANBACAEQRRrIgUgBEEEaiIHEMIJIgJFIAMtANgBQQJJckUEQCADIAIoAgggBxDECRoLIAUgAjYCAAxQCyADQQAgBEEEaiIFQQAQwgkiAkUgAy0A2AFBAklyRQRAIAMgAigCCCAFEMQJGgsgBSACNgIADE8LIARCADcCEAxOCwJAIARBOGsiAigCACIIDQAgBEEEaygCAA0AIAQoAgQNACAEKAIIDQAgAiAEQSBrKAIANgIADE4LAkAgBEEgayIHKAIAIgVFDQAgBSgCAEEBRw0AIAIgAyAIQQBBACAEQQhrQQAgBEEEahDgCSIFNgIAIAUEQCAFKAIAQTBsIAVqQShrIgUgBygCACICKAIINgIAAkAgAi0AFUEEcQRAIAUgBS8ADUEEcjsADSAFIAIoAjQ2AiwgAkEANgI0IAIgAi8AFUH7/wNxOwAVIAUoAiwoAgAtAAVBCHFFDQEgBSAFLwANQYCAAXI7AA0MAQsgBSACKAI0NgIsIAJBADYCNAsgAi0AFUEIcQRAIAUgAigCKDYCICACQQA2AiggAiACLwAVQff/A3E7ABUgBSAFLwANQQhyOwANCyACQQA2AggLIAMoAgAgBygCABCqCAxOCyAFEOYJIANBACAHKAIAQQBBAEEAQQBBgBBBABDJCSEFIAIgAyACKAIAQQBBACAEQQhrIAUgBEEEahDgCTYCAAxNCyAEQThrIgIgAyACKAIAQQBBACAEQQhrIARBIGsoAgAgBEEEahDgCTYCAAxMCyAEQdAAayICIAMgAigCACAEQcQAayAEQThrIARBCGtBACAEQQRqEOAJIgU2AgAgAyAFIARBIGsoAgAQygkMSwsgBEE4ayICIAMgAigCACAEQSxrIARBIGsgBEEUa0EAIARBBGoQ4AkiBTYCACADIAUgBEEIaxDeCQxKCyAEQSxrIgIgAyACKAIAIARBIGsgBEEUayAEQQhrQQAgBEEEahDgCTYCAAxJCyAEQQhrKAIAIgNFDUggAygCACICQQBMDUggAyACQTBsakEcayAEKAIEOgAADEgLIARBCGsgBCgCBCIDNgIAIAMQ5gkMRwsgBEEANgIQDEYLIARBCGsgBCkCBDcCAAxFCwJAIANBtAFBAEEAEKUJIgVFDQAgBS0ABEEDcQ0AIAUgBCgCBCADKALwAWs2AiQLIAYgBEEUaykCADcDQCADQY4BIANBPCAGQUBrEIQJIAUQpQkhBSAEQSxrIgIgAyACKAIAIAUQxgk2AgAMRAsCQCADKAIAQbQBQQAQzAkiBUUNACAFLQAEQQNxDQAgBSAEKAIEIAMoAvABazYCJAsgBEEUayICIAMgAigCACAFEMYJNgIADEMLIARBLGsiBSADIAUoAgAgBEEUaygCABDGCSICNgIAIAQoAggEQCADIAIgBEEEakEBEN0JIAUoAgAhAgsgAkUNQiACKAIAQQR0IAJqIgJBBGsoAgANQiACQQhrIgIgAygCACAEQSBrKAIAIARBCGsoAgAQ5wk2AgQgAiACLwAJQfz/A3FBAXI7AAkMQgsgBEEANgIQDEELIARBAjYCBAxACyAEQQE2AgQMPwsgBEEIaygCACEHIARBLGsiCCgCACECAkACQAJAIAMtABsNACADKAIALQCxAQ0AIAMgBxDoCUUNAAJAIAIoAiAoAgANACADIAIoAhwiCRDoCUUNASAJQQhqIQsDQCAFIAkoAgBODQEgBUEEdCEKIAVBAWohBSAKIAtqKAIAEOkJRQ0ACwwBCyADLQDYAUUNAQsgAyAHQQBBAEEAQQBBAAJ/IAIoAiAoAgAEQCADIAIQ6glBgAQMAQtBgAwgAigCNEUNABogAigCBEGADHELIgVBABDJCSEFIAIgAigCBEH/d3E2AgQgBUUEQCACIQUMAgsgBSACNgI0IAVBiAE6AAAMAQsCQAJAIAIoAiAiBSgCAEUEQEEAIQogAxD2CCELIANBAEEAQQBBAEEAQQBBAEEAEMkJIQUgAygCAC0AGEEQcUUEQCADEIcDGgsgBUUNASAFKAIgIglBATYCACAFIAIoAjQiCjYCNCAFIAItAAA6AAAgCgRAIAUgBSgCBEGABHI2AgQLIAJBiwE6AAAgAkEANgI0IAlBAjYCKCAJQX82AhggCSAJLwAVQcAAcjsAFSADIAlBCGoiCiACQQAQ6wlFDQIgCSgCNCIJIAsoAmxBAWoiDDYCBCADIAMoAjBBAWoiDTYCMCAJIA02AgggC0ELIA1BACAMEOMIGiAJKAIIIQsgBkHYBWoiDUIANwIAIAZCADcC0AUgBiALNgLMBSAGQQ06AMgFIAYgAygCMCILQQNqNgLUBSAGIAIoAhwoAgAiDDYC2AUgAyALIAxqQQJqNgIwIAIgAigCBEGACHI2AgQgAyACIAZByAVqEOwJGiAJIAYoAtQFNgIMDAILIAUgBSgCKEEBajYCKCAFQQhqIQoLIAIhBQsCQCADKAIoDQAgCigCLCICKAIAIgooAhwoAgAgBygCAEcEQCADIAoQ7QkMAQsgAyAHIAIoAgxBAEEAEO4JIAMoAghBDCACKAIIEPgIGgsgAygCACAHELIDCyAIIAU2AgAMPgsgAyAEKAIEEOoJDD0LIARBIGsgAyAEQQhrKAIAQQBBAEEAQQBBAEGABEEAEMkJNgIADDwLIARB6ABrIAMgBEHQAGsoAgAgBEHEAGsoAgAgBEE4aygCACAEQSxrKAIAIARBIGsoAgAgBEEIaygCACAEQdwAaygCACAEKAIEEMkJIgI2AgAgAgRAIAIgBEEUaygCADYCSAw8CyADKAIAIARBFGsoAgAQrAgMOwsgBEHcAGsgAyAEQcQAaygCACAEQThrKAIAIARBLGsoAgAgBEEgaygCACAEQRRrKAIAIARBCGsoAgAgBEHQAGsoAgAgBCgCBBDJCTYCAAw6CyAEQQhrQYgBNgIADDkLIAQgBC8BAjYCBAw4CyAEQRRrIgcoAgAhBQJAAkAgBCgCBCICRQ0AIAIoAjQEQCAGQQA2AswFIAMgAhDPCSADQQAgA0EAQQBBACAGQcgFaiACQQAQ4AlBAEEAQQBBAEEAQQAQyQkiAkUNAQsgBEEIayIIKAIAIQogAiAFNgI0IAIgCjoAACAFBEAgBSAFKAIEQf93cTYCBAsgAiACKAIEQf93cTYCBCAIKAIAQYgBRg0BIANBAToAFgwBCyADKAIAIAUQpQhBACECCyAHIAI2AgAMNwsgBCgCBCICRQ02IAMgAhDPCQw2CyAEQSBrIAMgBCgCBCAEQQhrKAIAEO8JNgIADDULIARBFGsgAyAEKAIEIARBCGsoAgAQ7wk2AgAMNAsgBkHA/wMiAigCGDYC4AUgBkHQ/wMpAgA3A9gFIAZByP8DKQIANwPQBSAGQcD/AykCADcDyAUCQCADKAIALQAYQcAAcUUEQCADEIcDDQELIAMgBCgCBCAGQcgFahDsCRoLIAMoAgAgBCgCBBClCAwzCyADIAQoAgRBASAEQQhrKAIAEPAJDDILIARBOGsoAgAhCCAEQdAAaygCACEKIARBFGsoAgAhBSAEKAIEIQcgBkEANgK8BSADKAIAIQICQCADLgHUAUEASgRAIANByz1BABCwAgwBCyADIARBLGsiCSAEQSBrIgsgCkEBQQAgCBCACSADKAL0ASIIRQ0AIAMoAigNACAIIAgoAhxBgARyNgIcIAMgCSALIAZBvAVqEKwJGiACIAgoAjwQgAMhCiADKAIAIQkgBiADNgLIBSAGIAkoAhAgCkEEdGoiCSgCADYC8AUgBiAJKAIMNgLoBSAGIAM2AswFIAZBASIJQQtqNgLQBSAGQQ02AtQFIAZBDjYC2AUgBkEANgLcBSAGQQA7AeAFIAYgCkEBRjoA7AUgBkH5KzYC9AUgBiAGKAK8BTYC+AUgBiAGQcgFajYC5AUgBkHMBWogBxC1CQ0AIAcgBygCBEGAgIABcjYCBAJAIAMtANgBQQFLBEAgByEKQQAhBwwBCyACIAdBARCpCSEKCyAIIAo2AiwgAiAFQQEQlQkhCiAIQQI6ACsgCCAKNgIQIAItAFcNACADKQLMASIRpyIIIAggEUIgiKdqIAgtAABBO0YbIARB3ABrKAIAIgprIQggCkEBayEJA0AgCCAJaiEKIAhBAWshCCAKLQAAQeCFA2otAABBAXENAAsgBkEBNgLEBSAGIAo2AsAFIANBACAGQcAFakEAQQAQggkLIAIgBxClCCADLQDYAUECTwRAIAMgBRDxCQsgAiAFELIDDDELIAMgBCgCBEEAIARBCGsoAgAQ8AkMMAsgBEEFNgIEDC8LIARBBDYCBAwuCyAEQRRrIAQoAgQ2AgAMLQsgBEELNgIQDCwLIAMgBEHEAGsoAgAgBEEgayAEQRRrKAIAIARBCGsoAgAQ8gkgAyAEKAIEEPMJDCsLIAMgBEEUaygCACAEQSBrKAIAIARBCGsoAgAQ9AkMKgsgA0EAQQBBACAEQRRrKAIAIAQoAgRBAEEAQQBBAEEBEMMJDCkLIAMgBEEgaygCACAEKAIEIARBFGsoAgBBABD1CQwoCyADQQA2AlgMJwsgBEEIa0EANgIADCYLIARBCGtBATYCAAwlCyAEQQhrIAQoAgQ2AgAMJAsgBEEUa0EANgIADCMLIARBCGtBADYCAAwiCyAEQQc2AgQMIQsgBEEKNgIEDCALIARBCGtBCTYCAAwfCyAEQQhrQQg2AgAMHgsgBEEQa0GA/gM2AgAgBEEUayAEKAIEQQh0NgIADB0LIARBEGtB/wE2AgAgBEEUayAEKAIENgIADBwLIARBFGtCADcCAAwbCyAEQQhrQgA3AgAMGgsgBEEIayIDIAQoAgQgAygCACAEKAIIQX9zcXI2AgAMGQsgBEEANgIQDBgLIARBATYCBAwXCyADIARBFGsoAgAgBEEEahD2CQwWCyADIARBCGsoAgBBABD2CQwVCyADKAL0ASIFRQ0UIAMtANgBQQFLDRQgBS4BIiECIAMoAgAiCiAEQQRqEIkJIghFDRQCQCADIAgQ9wlFDQAgCiACQQFrIgJBDGwiByAFKAIEaiAIEPgJIAVBCGohAwNAIAMoAgAiA0UNASADKAIELgEAIAJGBEAgAygCICAFKAIEIAdqEJQENgIACyADQRRqIQMMAAsACyAKIAgQNQwUCyADIAQoAgQQ8wkMEwsgA0EAIARBFGsgBEEIaygCACAEKAIEEPIJDBILIAMgBEEIaygCACAEQRRrKAIAIAQoAgQQ9AkMEQsgA0EAQQBBAEEAIAQoAgRBAEEAQQBBAEEBEMMJDBALIANBACAEQQhrKAIAIAQoAgQgBEEUaygCABD1CQwPCyADKAL0ASICRQ0OIAIuASIiA0EATA0OIAIoAgQgA0EMbGoiA0EIayIFIAUtAABB8AFxIAQoAgRBD3FyOgAAIAIgAigCHEGAEHI2AhwgA0ECay0AAEEIcUUNDiACQQhqIQMDQCADKAIAIgNFDQ8gAygCBC4BACACLgEiQQFrRgRAIAMgAy8AN0EIcjsANwsgA0EUaiEDDAALAAsgBiAEKQIENwM4IANB9gAgBkE4ahCECSICBEAgAhDNCRoLIAMgAiAEKAIEIgUgBSAEKAIIahD5CQwNCyADIANBrgEgBCgCBEEAEKUJIARBFGsoAgAgBEEIaygCACAEQQRrKAIAahD5CQwMCyADIAQoAgQgBEEUaygCACAEQQhrKAIAIARBBGsoAgBqEPkJDAsLIAMgBEEIaygCACAEQRRrKAIAQQFqIAQoAgQQ+QkMCgsgAyAEKAIEIARBCGsoAgAiAiACIARBBGsoAgBqEPkJDAkLIAMgBCkCBDcCVAwICyAEIAIpAgA3AhAMBwsgBCACKAIANgIQDAYLIARBBGsgBCgCCCAEKAIEaiAEQQhrKAIAazYCAAwFCyAEQTRrIAQoAgQgBCgCCGogBEE4aygCAGs2AgAMBAsgBEEcayAEKAIEIAQoAghqIARBIGsoAgBrNgIADAMLIARCADcCEAwCC0EAIQULIA8gBigCxAUiB60gBa0gBUEAR618fEIBfBBcIghFDQAgAy0A2AFBAk8EQCADIAggBkHABWoQxAkaC0EAIQIgCCAGKALABSAHEJcTIgsgB2pBADoAACALEPoJIAsQlAkhCSANLgEiIgdBACAHQQBKGyEIIA0oAgQhCiAHrCERAkACQANAIAIgCEcEQAJAIAogAkEMbGoiBy0AByAJRw0AIAsgBygCABBsDQAgBiALNgIgIANBvOUAIAZBIGoQsAIMAwsgAkEBaiECDAELCyAPIAogEUIMfkIMfBBgIgINAQsgDyALEDUMAQsgDSACNgIEIAIgDS4BIkEMbGoiAkIANwIEIAIgCzYCACACIAk6AAcCQCAFRQRAIAIgEDoABiACIBM6AAQMAQsgCxBZIAtqQQFqIAwgBRCXEyIHIAVqQQA6AAAgBxD6CSAHIAIQ4QghDiACIAIvAQpBBHI7AQoLIAIgDjoABSANIA0vASJBAWo7ASIgDSANLwEkQQFqOwEkIANBADYCWAsgBEEAIgNBgKIDaiABaiwAAEEMbGoiBC8BACECIAAgBCIbQQxqIgU2AgAgBCABQQF0QeD/A2ovAQAiBDsBDiAbIAQgAkEBdEGgigRqLgEAakEBdEHw0wNqLwEAIgQ7AQwgBkGABmokACAECyYBAX8jAEEQayICJAAgAiABNgIAIABB2uwAIAIQsAIgAkEQaiQAC70CACAAKAIEIQACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUHNAWsOcwALCwsLCwsLCwsLCwEBCwsLAgsLCwsLCwsLCwICCwsLCwsDAAAECwsCAwECAQILBQACAAILAwMLCwsCAwYLCwsBAgsGCwsHCwsLAgECAQsLAQsLCAsJCwEICwsLAQsLCwsLCwsLCwsLBQcHBwIBBwsKCgoLCyAAKAIAIAIoAgAQpQgPCyAAKAIAIAIoAgAQMw8LIAAoAgAgAigCABCyAw8LIAAoAgAgAigCABCqCA8LIAAoAgAgAigCABCrCA8LIAAoAgAgAigCABCsCA8LIAAoAgAgAigCABA0DwsgACgCACACKAIAEKgIDwsgACgCACACKAIAEDEPCyAAKAIAIAIoAgQQNA8LIAAoAgAgAigCBBAzCwseACAAEChFBEBBltAJECQPCyAALQBcQd+HA2otAAALvgECAX8BfyMAQRBrIgMkAAJAIAAQKEUEQEGp0AkQJCECDAELAn8gACgClAMiBEUEQEGu0AkQJAwBCyADIAI2AgwCQAJAAkACQAJAAkAgAUEBaw4EAAECAwULIAMgAygCDCIAQQRqNgIMIAQoAgAgACgCADoAEAwDCyAEKAIAQQA6ABIMAgsgBCgCAEECOgASDAELIAQoAgBBAToAEQtBACECDAILQcTQCRAkCyECIAAgAhCkAQsgA0EQaiQAIAILXQEBfwJAIAFBAEgNACABIAAoAgBODQAgACgCSCAAKAIEIAFBDGxqKAIIEL4DKAIAIgEoAgxFBEBBoJUDDwsgACgCTCABEL8DIgFFBEBBoJUDDwsgASgCACECCyACCzkBAX8DfyAARQRAQQAPCyAAKAIMIgIgAUoEfyAAKAIYIAFBMGxqBSABIAJrIQEgACgCBCEADAELCwssAQF/IAAgAUEQQQwgASgCBEGACHEiAhtqKAIAIAFBDEEQIAIbaigCABDAAws+AAJAAkAgAS0ABUECcQRAIAEhAgwBCyACBEAgAi0ABUECcQ0BCyAAIAEQ8wgiAQ0BCyAAIAIQ8wghAQsgAQtSAQF/AkBBASABdEEAIAFBIEgbIgEgACgCVHFFDQAgAkUEQCAAIAAoAlggAUF/c3E2AlhBAQ8LQQEhAyACQQBMDQAgACAAKAJYIAFyNgJYCyADC4wBAwF/AX8BfwJAAkAgAUEATgRAIAEgACgCAEgNAQtBt54KECQhBAwBCyAAIAFBAnRqQdwAaiIFKAIAIgMNACAAKAJMKAIAIgMgACgCSCAAKAIEIAFBDGxqKAIIEL4DKAIAKAIQIAMtAFRBwQAgBRDsAiEEIAUoAgAhAwsgAiADNgIAIARBDCADIARyGwsHACAAKAJQC0MBAX9BASEDIABBkgFNBEAgASAAQQFqIgBBAXRBkI0Dai8BAEEAIgNB8IcDamo2AgAgAiAAQcCPA2otAAA2AgALIAMLBQBBkwELDAAgACABEMcDQTxHCz8CAX8BfyMAQRBrIgIkAEE8IQMgAkE8NgIMIAFBAk4EQCAAIAEgAkEMahC0AxogAigCDCEDCyACQRBqJAAgAwu2BQUBfwF/AX8BfwF/AkAgAARAA0ACQAJAAkACQCAALQAAIgJBDUsNAEEBIAJ0QYDsAHENASACDQAgBEEBRg8LAkACQAJAAkACQAJAAkACQAJAIAJBIGsOAwkFAQALAkAgAkEtaw4DAwUCAAsgAkHgAEYNACACQTtGBEBBACEBDAsLIAJB2wBGDQMgAkEnRw0ECwNAAkAgAEEBaiEDIAAtAAEiAUUNACADIQAgASACRw0BCwsgAUUNDEECIQEgAyEADAkLIAAtAAFBKkcNByAAQQJqIQADQAJAIAAtAAAiAUEqRwRAIAENAQwOCyAALQABQS9GDQULIABBAWohAAwACwALQS0hASAALQABQS1HDQYDQCABQf8BcSIBBEAgAUEKRg0HIAAtAAEhASAAQQFqIQAMAQsLIARBAUYPCwNAIAAtAAEiA0UNCiAAQQFqIQBBAiEBIANB3QBHDQALDAYLQQEhASACQeCFA2otAABBxgBxRQ0EA0AgASIDQQFqIQEgACADaiIFLQAAQeCFA2otAABBxgBxDQALQQIhAQJAAkACQAJAAkACQCACQcMAaw4DAQgFAAsCQCACQeMAaw4DAQgFAAsgAkHUAEcgAkH0AEdxDQcgA0EEaw4GAgcHAQcDBwsgA0EGRw0GIABBg5UBQQYQbQ0GQQQhAQwGCyAAQd/vAEEHEG0NBUEGIQEMBQsgAEHk8wBBBBBtDQQMAwsgAEHuJUEJEG1FDQIMAwsCQAJAIANBA2sOBQAEBAQBBAsgAEGbqQFBAxBtDQNBByEBDAMLIABB+YABQQcQbQ0CQQMhAQwCC0EBIQEgAEEBaiEADAQLQQUhAQsgBUEBayEADAILQQEhAQwBC0ECIQELIARBA3RB4JADaiABai0AACEEIABBAWohAAwACwALQYKGCxAkGgtBAAsFAEGAIAsHAEHAhLoBC70BAQF/QdihBSgCAARAEKcDQdihBUEANgIAC0HooQUoAgAEQEH4oAUoAgAiAARAQfCgBSgCACAAEQMAC0HooQVBADYCAAtB5KEFKAIABEBBwKAFKAIAIgAEQEHEoAUoAgAgABEDAAtBpIsGQQA2AgBBoIsGQQA2AgBBkKwHIgBCADcDAEHkoQVBADYCAEGorAdCADcDAEGgrAdCADcDAEGYrAdCADcDAAtB4KEFKAIABEBB4KEFQQA2AgALQQAL+QYCAX8BfyMAQRBrIgIkAAJAQdihBSgCAEUgAEE/TUIBIACthkKAgIQIg0IAUnFyRQRAQa2LCxAkIQEMAQsgAiABNgIMQQAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQQRrDhsAAREEEQIREREIEhEJCgYHCxEMEQUNDgMRDxARCyACIAIoAgwiA0EEajYCDEGIoAUiACADKAIAIgMpAgA3AyBBwKAFIAMpAhg3AwBBuKAFIAMpAhA3AwBBsKAFIAMpAgg3AwAMEQtBqKAFKAIARQRAEDwLIAIgAigCDCIAQQRqNgIMIAAoAgAiAEGIoAUiAykDIDcCACAAQcCgBSkDADcCGCAAQbigBSkDADcCECAAQbCgBSkDADcCCAwQCyACIAIoAgwiAEEEajYCDEGIoAUgACgCADYCAAwPCyACIAIoAgwiAEEEajYCDEGQoAUgACgCADoAAAwOCyACIAIoAgwiAEEEajYCDEGIoAUiAyAAKAIANgK4AUHEoQUgACgCBDYCACACIABBDGo2AgxByKEFIAAoAgg2AgAMDQsgAiACKAIMIgBBBGo2AgwgACgCAEGoATYCAAwMCyACIAIoAgwiAEEEajYCDEHsoAUgACgCAEE0EJcTGgwLC0H0oAUoAgBFBEAQPgsgAiACKAIMIgBBBGo2AgwgACgCAEHsoAVBNBCXExoMCgsgAiACKAIMIgBBBGo2AgxBiKAFIgMgACgCADYCFCACIABBCGo2AgxBoKAFIAAoAgQ2AgAMCQsgAiACKAIMIgBBBGo2AgwgACgCACEDIAIgAEEIajYCDEH4oQUgACgCBDYCAEH0oQUgAzYCAAwICyACIAIoAgwiAEEEajYCDEGOoAUgACgCADoAAAwHCyACIAIoAgwiAEEEajYCDEGPoAUgACgCADoAAAwGC0GIoAUiAEIANwOoAUG4oQVCADcDACACIAIoAgxBB2pBeHFBEGo2AgwMBQsgAiACKAIMIgBBBGo2AgxB1KEFIAAoAgA2AgAMBAsgAiACKAIMIgBBBGo2AgxBpKAFIAAoAgA2AgAMAwsgAiACKAIMQQdqQXhxIgBBCGo2AgxBgKIFIAApAwA3AwAMAgsgAiACKAIMIgBBBGo2AgwgACgCAEEANgIADAELQQEhAQsgAkEQaiQAIAELXwMBfwF/AX8CQCAAECgEQANAIAEgACgCFE4NAiAAKAIQIAFBBHRqKAIEIgMEQCADKAIEKAIAKALkASgCNEGcoQUoAgARAwALIAFBAWohAQwACwALQfCOCxAkIQILIAILqQECAX8BfwJAIAAoAiwNACAALQAVIgMEQCADQQNxDQEgAS0AHEEIcQ0BCyAAIAAoAtQBQQFqNgLUASABQQA2AhACQAJ/IAAoAugBBEAgARDMASICDQIgACABQQBBABDSAQwBCwJAIAEtABxBCHFFBEAgAC0AEUEDRw0BCyAAQQEQ1wEiAg0CCyAAIAEQ2AELIgINACABELMGQQAhAgsgACACENsBIQILIAIL4wIFAX8BfwF+AX8BfiMAQRBrIgMkAAJAIAAQKEUEQEGmjwsQJCECDAELIAMgAjYCDEEAIQICQAJAAkAgAUHoB2sOAgABAgsgAyADKAIMIgJBBGo2AgwgACgCECACKAIANgIAQQAhAgwCCyADIAMoAgwiAkEEajYCDCACKAIEIQQgAigCACEBIAMgAkEMajYCDCAAIAEgBCACKAIIENADIQIMAQsDQCACQRJGBEBBASECDAILIAJBA3QhBCACQQFqIQIgBEGgkQNqIgQoAgAgAUcNAAsgAyADKAIMIgJBBGo2AgwgAigCACEGIAMgAkEIajYCDCAAKQMgIQUgAigCBCEBAkAgAAJ+IAZBAEoEQCAFIAQ1AgSEDAELIAYNASAFIAQ1AgRCf4WDCyIHNwMgIAUgB1ENACAAQQAQoAMLQQAhAiABRQ0AIAEgACkDICAENQIEg0IAUjYCAAsgA0EQaiQAIAILtwQGAX8BfwF/AX4BfwF/QQUhBCAAQQAQKUEATARAIAAtALgCBEAgACgC4AIQQAsCQCACQXhxIgVBBUgiBiADQQBMckUEQCADrCACrH4hBwJAIAEEQCABIQQMAQtBpK0HKAIAIgQEQCAEEQ0ACyAHEEchBEGorQcoAgAiAwRAIAMRDQALIARFBEBBACEEDAELIARBtKAFKAIAEQEArCEHC0EAIAUgBhshBiACQYADTwRAIAcgBSAHIAVBgANqrX+nIghsrH1CgAF/pyEJDAILIAJBgAJPBEAgByAFIAcgBUGAAWqtf6ciCGysfUKAAX+nIQkMAgsgByAFrX+nIQgMAQtBACEEQQAhBgsgAEIANwLMAiAAIAQ2AuACIAAgBjsBtgIgACAGOwG0AgJ/IAQEQEEAIQMgCEEAIAhBAEobIQVBACECA0AgAiAFRkUEQCAEIAM2AgAgACAENgLMAiACQQFqIQIgBCEDIAQgBmohBAwBCwsgACAENgLcAiAAQgA3AtQCQQAhAyAJQQAgCUEAShshBkEAIQIDQCACIAZGRQRAIAQgAzYCACAAIAQ2AtQCIAJBAWohAiAEIQMgBEGAAWohBAwBCwsgAEEANgKwAiAAIAQ2AuQCIAAgAUU6ALgCIAggCWoMAQsgAEIANwLUAiAAQQA6ALgCIABBADsBtAIgAEEBNgKwAiAAQQA2AuQCIABCADcC3AJBACEEQQALIQIgACAENgLoAiAAIAI2ArwCQQAhBAsgBAsZACAAEChFBEBBvJALECQaQgAPCyAAKQMoCxkAIAAQKEUEQEHJkAsQJBoPCyAAIAE3AygLGQAgABAoRQRAQdiQCxAkGkIADwsgACkDaAsIACAAENMDpwsZACAAEChFBEBB6JALECQaQgAPCyAAKQNwCwgAIAAQ1QOnC4gBAwF/AX8BfwJAIAAQKEUEQEGJkgsQJBpBfyECDAELAn8gAQRAIAAgARCGASIBQR91IAFqDAELQQAhASAAKAIUQQFrCyEEQX8hAgNAIAEgBEoNASAAKAIQIAFBBHRqKAIEIgMEfyADLQAIBUEACyIDIAIgAiADSBshAiABQQFqIQEMAAsACyACCwkAIABBABDZAwuuAgMBfwF/AX8gAARAIAAQLUUEQEHNkQsQJA8LIAAtAF5BCHEEQEEIIAAoAtgBIABBACAAKALUAREGABoLA0AgBCAAKAIUTkUEQAJAIAAoAhAgBEEEdGooAgwiAkUNACACQRBqIQIDQCACKAIAIgJFDQEgAigCCCIDLQArQQFHDQAgACADENoDDAALAAsgBEEBaiEEDAELCyAAQYwDaiECA0AgAigCACICBEAgAigCCCgCFCIDRQ0BIAAgAxDaAwwBCwsgABDKASAAENsDAkAgAQ0AIAAQ6wFFDQAgAEEFQdzGAEEAEK4BQQUPCwNAIAAoApQEIgIEQCAAIAIoAgA2ApQEIAIoAggiAwRAIAIoAgQgAxEDAAsgAhBADAELCyAAQacBOgBhIAAQrAELQQALPwIBfwF/IAFBNGohAgJAA0AgAiIDKAIAIgFFDQEgAUEYaiECIAEoAgAgAEcNAAsgAyABKAIYNgIAIAEQnQcLCwoAIABBxAAQrQcLCQAgAEEBENkDCzMAIAAQKEUEQEHclQsQJA8LIABBADYC9AMgAEEANgLIAyAAIAI2AsQDIAAgATYCwANBAAtDACAAEChFBEBB9ZULECQaDwsgAUEASgRAIAAgATYC/AIgACACNgL0AiAAIAM2AvgCDwsgAEEANgL8AiAAQgA3AvQCCzoAIAAQKEUEQEGOlgsQJA8LIAFBAEoEQCAAQQ8gABDdAxogACABNgL0A0EADwsgAEEAQQAQ3QMaQQALdwMBfwF/AX8CQCAAKAL0AyIEAn8gAUELTARAQQBBvJYEaiABai0AACEDIAFBsJYEai0AAAwBCyABQeQAbEHoBmshA0HkAAsiAiADak4NACAEIANrIgJBAEoNAEEADwsgACgCACIBIAJB6AdsIAEoAjwRAAAaQQELKwACQCAAECgNACAABEAgAC0AYUGnAUYNAQtBopYLECQaDwsgAEEBNgKoAgsuAAJAIAAQKA0AIAAEQCAALQBhQacBRg0BC0GylgsQJBpBAA8LIAAoAqgCQQBHCxsAIAAgASACIAMgBCAFIAYgB0EAQQBBABDkAwuLAQEBfyAAEChFBEBB2JcLECQPCwJAAkAgCkUEQAwBC0IMEEciC0UEQCAAEJQBIAQgChEDAEEBIQkMAgsgCyAENgIIIAsgCjYCBCALQQA2AgALIAAgASACIAMgBCAFIAYgByAIIAkgCxDlAyEJIAtFDQAgCygCAA0AIAQgChEDACALEEALIAAgCRCdAQunAgEBfwJAIAFFIAVBACAHG3IgB0UgBkEAR0YgAkHpB2tBlnhJciAIRSAJRXNyckUEQCABEFlBgAJJDQELQdiWCxAkDwsCQAJAAkAgACABIAJBAUEAEOkDIgtFDQAgCygCBEEDcUEBRw0AIAIgCy4BAEcNACAAKAK4AQRAIABBBUHfwABBABCuAUEFDwsgAEEAEKADDAELIAUgB3JFDQELIAAgASACQQFBARDpAyIBRQRAQQcPCyADQYCQ4BlxIQMgACABEO8BIAoEQCAKIAooAgBBAWo2AgALIAEgCjYCJCABIAk2AhwgASAINgIYIAEgBzYCFCABIAQ2AgggASACOwEAIAEgBSAGIAUbNgIQIAEgASgCBEEDcSADckGAgIABczYCBAtBAAsbACAAIAEgAiADIAQgBSAGIAdBAEEAIAgQ5AMLGwAgACABIAIgAyAEQQAgBSAGIAcgCCAJEOQDC3oCAX8BfyMAQRBrIgQkAAJ/IAFFIAJBfkhyQQEgABAoIgMbBEBB7ZgLECQMAQtBACIDIAAgASACQQFBABDpAw0AGiAEIAE2AgBBB0Hb6wAgBBBmIgNFDQAaIAAgASACQQEgA0EQQQBBAEEBEOYDCyEDIARBEGokACADC/oCBgF/AX8BfwF/AX8BfyABEFkhCSAAQaADaiIKIAEQiQMhBwNAIAcEQCAHIAggByACIAMQ6wMiBiAFSxshCCAHKAIMIQcgBiAFIAUgBkgbIQUMAQsLAkACQAJ/AkAgBA0AIAgEQEEAIgUgAC0AGEECcUUNAhoLQQAhBSAJIAEtAABB4IIDai0AAGpBF3AgARDsAyEHA0AgB0UNASAHIAggByACIAMQ6wMiBiAFSxshCCAHKAIMIQcgBiAFIAUgBkgbIQUMAAsACyAERSAFQQVLckUEQCAAIAlBKWqtEMMCIgZFDQIgBiADNgIEIAYgAjsBACAGIAZBKGoiBTYCICAFIAEgCUEBahCXExoDQCAFLQAAIgcEQCAFIAdB4IIDai0AADoAACAFQQFqIQUMAQsLIAYgCiAGKAIgIAYQ7QMiBUYEQCAAIAYQNSAAEJQBDAMLIAYgBTYCDCAGDwsgCEUNASAEQQBHCyIFDQEgCCgCEA0BC0EAIQgLIAgLQQIBfwF/IwBBEGsiAyQAIAMgAAR/IAAoAgQoAggFQQALIgQ2AgAgAEHCLiADEGYiBEF/EJkCIAQQQCADQRBqJAALYAEBfwJ/IAAuAQAiAyABRgR/QQQFIAFBfkYEQEEGQQAgACgCEBsPC0EAIgEgA0EATg0BGkEBCyEBIAIgACgCBCIAQQNxRgRAIAFBAnIPCyAAIAJxQQF2QQFxIAFqCyIBCzUAIABBAnRBqIsGaiEAA0ACQCAAKAIAIgBFDQAgACgCICABEGxFDQAgAEEkaiEADAELCyAAC44EBQF/AX8BfwF/AX8jAEEQayIFJAACQCAAIAEgBUEMahDLCCIDKAIIIgQEQCACRQRAIAMoAgAhAiAFKAIMIQYCQCADKAIEIgEEQCABIAI2AgAMAQsgACACNgIICyACBEAgAiABNgIECyAAKAIMIgEEQCADIAEgBkEDdGoiASgCBEYEQCABIAI2AgQLIAEgASgCAEEBazYCAAsgAxBAIAAgACgCBEEBayIDNgIEIAMNAiAAEPABDAILIAMgATYCDCADIAI2AggMAQsgAkUEQEEAIQQMAQtCEBBHIgZFBEAgAiEEDAELIAYgAjYCCCAGIAE2AgwgACAAKAIEQQFqIgM2AgQCQCADQQpJDQAgAyAAKAIAIgJBAXRNDQBBgAEgA0EBdCADQQR0QYAISxsiAyACRg0AQaStBygCACICBEAgAhENAAsgA0EDdK0QRyEDQaitBygCACICBEAgAhENAAsgA0UNACAAKAIMEEAgACADNgIMIAAgA0G0oAUoAgARAQAiAkEDdiIENgIAIANBACACQXhxEJkTIQcgACgCCCEDIABBADYCCANAIAMEQCADKAIAIQIgACAHIAMoAgwQzAggBHBBA3RqIAMQzQggAiEDDAELCyAFIAEQzAggACgCAHA2AgwLQQAhBCAAIAAoAgwiAyAFKAIMQQN0akEAIAMbIAYQzQgLIAVBEGokACAECzYAIAAQKEUEQEGhmQsQJA8LIAAgAzYC2AEgACACQQAgARsiAzYC1AEgACABQQAgAxs6AF5BAAsuACAAEChFBEBB3pkLECQaQQAPCyAAIAE2AuABIAAoAtwBIQEgACACNgLcASABCy4AIAAQKEUEQEH3mQsQJBpBAA8LIAAgATYC8AEgACgC7AEhASAAIAI2AuwBIAELLgAgABAoRQRAQZCaCxAkGkEADwsgACABNgLoASAAKALkASEBIAAgAjYC5AEgAQslACAARQRAQQAPCyAAIAE2AogCIAAoAoQCIQEgACACNgKEAiABCzIAIAAQKEUEQEH6mgsQJA8LIAFBAEoEQCAAQREgARD1AxpBAA8LIABBAEEAEPUDGkEACzgAAkAgACADSg0AQaStBygCACIABEAgABENAAsgASACEPYDGkGorQcoAgAiAEUNACAAEQ0AC0EACy4AIAAQKEUEQEGSmwsQJBpBAA8LIAAgATYCkAIgACgClAIhASAAIAI2ApQCIAELDwAgACABQQBBAEEAEPcDC8sBAgF/AX8jAEEQayIFJAACQCAAEChFBEBBspsLECQhBAwBCyADBEAgA0F/NgIACyAEBEAgBEF/NgIACyACQQRPBEBBwJsLECQhBAwBC0EMIQYCQAJAIAFF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qwdPDQAgAEEAIgJBzYADajYC0A8gAUGQrAcgAWtBviAgAEHQD2oQixQgAWoiAUGQqwdPDQAgAEEAQZHCAmo2AsAPIAFBkKwHIAFrQdvrACAAQcAPahCLFCABaiIBQZCrB08NACAAQeQANgKwDyABQQAgAWtBkKwHakGuvgEgAEGwD2oQixQgAWoiAUGQqwdPDQAgAEEAQbwhajYCoA8gAUGQrAcgAWtB2+sAIABBoA9qEIsUIAFqIgJBkKsHTw0AIABBkA9qQQAiAUHLiQFqNgIAIABCgICAgMAANwOIDyAAQY7+ADYChA8gAEGBgQM2AoAPIAJBkKwHIAJrQYogIABBgA9qEIsUIAJqIgJBkKsHTw0AIABB8A5qQQBB9coCajYCACAAQoSAgIDAADcD6A4gAEGKlQE2AuQOIABBzYADNgLgDiACQZCsByACa0GKICAAQeAOahCLFCACaiICQZCrB08NACAAQdAOakEAQfXKAmo2AgAgAEKIgICAwAA3A8gOIABB2Ds2AsQOIABBzYADNgLADiACQZCsByACa0GKICAAQcAOahCLFCACaiICQZCrB08NACAAQbAOakEAQZrLAmo2AgAgAEKMgICAwAA3A6gOIABBsSk2AqQOIABBzYADNgKgDiACQZCsByACa0GKICAAQaAOahCLFCACaiICQZCrB08NACAAQZAOakEAQeXLAmo2AgAgAEKQgICAwAA3A4gOIABBzDs2AoQOIABBzYADNgKADiACQZCsByACa0GKICAAQYAOahCLFCACaiICQZCrB08NACAAQfANakEAQeXLAmo2AgAgAEKUgICAwAA3A+gNIABBhiY2AuQNIABBzYADNgLgDSACQZCsByACa0GKICAAQeANahCLFCACaiICQZCrB08NACAAQdANakEAQZrLAmo2AgAgAEKYgICAwAA3A8gNIABBk4EBNgLEDSAAQc2AAzYCwA0gAkGQrAcgAmtBiiAgAEHADWoQixQgAmoiAkGQqwdPDQAgAEGwDWpBAEHlywJqNgIAIABCnICAgMAANwOoDSAAQfWXATYCpA0gAEHNgAM2AqANIAJBkKwHIAJrQYogIABBoA1qEIsUIAJqIgJBkKsHTw0AIABBkA1qQQBBp8sCajYCACAAQqCAgIDAADcDiA0gAEH27gA2AoQNIABBzYADNgKADSACQZCsByACa0GKICAAQYANahCLFCACaiICQZCrB08NACAAQfAMakEAQeXLAmo2AgAgAEKkgICAwAA3A+gMIABB9S42AuQMIABBzYADNgLgDCACQZCsByACa0GKICAAQeAMahCLFCACaiICQZCrB08NACAAQdAMakEAQeXLAmo2AgAgAEKogICAwAA3A8gMIABB8o0BNgLEDCAAQc2AAzYCwAwgAkGQrAcgAmtBiiAgAEHADGoQixQgAmoiAkGQqwdPDQAgAEGwDGpBAEGtzQJqNgIAIABCrICAgMAANwOoDCAAQZaAATYCpAwgAEHNgAM2AqAMIAJBkKwHIAJrQYogIABBoAxqEIsUIAJqIgJBkKsHTw0AIABBkAxqQQBBmssCajYCACAAQrCAgIDAADcDiAwgAEHPqwE2AoQMIABBzYADNgKADCACQZCsByACa0GKICAAQYAMahCLFCACaiICQZCrB08NACAAQfALakEAQYbLAmo2AgAgAEK0gICAwAA3A+gLIABBpJUBNgLkCyAAQc2AAzYC4AsgAkGQrAcgAmtBiiAgAEHgC2oQixQgAmoiAkGQqwdPDQAgAEHQC2pBAEHlywJqNgIAIABCuICAgMAANwPICyAAQeaAATYCxAsgAEHNgAM2AsALIAJBkKwHIAJrQYogIABBwAtqEIsUIAJqIgJBkKsHTw0AIABBsAtqQQBB5csCajYCACAAQryAgIDAADcDqAsgAEHovgE2AqQLIABBzYADNgKgCyACQZCsByACa0GKICAAQaALahCLFCACaiICQZCrB08NACAAQZALakEAQeXLAmo2AgAgAELAgICAwAA3A4gLIABBpTg2AoQLIABBzYADNgKACyACQZCsByACa0GKICAAQYALahCLFCACaiICQZCrB08NACAAQfAKakEAQeXLAmo2AgAgAELEgICAwAA3A+gKIABB3IgBNgLkCiAAQc2AAzYC4AogAkGQrAcgAmtBiiAgAEHgCmoQixQgAmoiAkGQqwdPDQAgAEHQCmpBAEHsygJqNgIAIABCyICAgMAANwPICiAAQd75ADYCxAogAEHNgAM2AsAKIAJBkKwHIAJrQYogIABBwApqEIsUIAJqIgJBkKsHTw0AIABBsApqQQBB48YCajYCACAAQsyAgIDAADcDqAogAEHAnAE2AqQKIABBzYADNgKgCiACQZCs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QZCsByABa0Hb6wAgAEGgBWoQixQgAWoiAkGQqwdPDQAgAEEAIgFBy4kBajYCkAUgAEKAgICAwAA3A4gFIABB3TQ2AoQFIABBgYEDNgKABSACQZCsByACa0GKICAAQYAFahCLFCACaiICQZCrB08NACAAQQBByfQAajYC8AQgAEKEgICAwAA3A+gEIABB6TQ2AuQEIABBzYADNgLgBCACQZCsByACa0GKICAAQeAEahCLFCACaiICQZCrB08NACAAQQBBy4kBajYC0AQgAEKIgICAwAA3A8gEIABBhig2AsQEIABBzYADNgLABCACQZCsByACa0GKICAAQcAEahCLFCACaiICQZCrB08NACAAQQBByfQAajYCsAQgAEKMgICAwAA3A6gEIABBjyg2AqQEIABBzYADNgKgBCACQZCsByACa0GKICAAQaAEahCLFCACaiICQZCrB08NACAAQQBByfQAajYCkAQgAEKQgICAwAA3A4gEIABB6KUBNgKEBCAAQc2AAzYCgAQgAkGQrAcgAmtBiiAgAEGABGoQixQgAmoiAkGQqwdPDQAgAEEAQcuJAWo2AvADIABClICAgMAANwPoAyAAQbeCATYC5AMgAEHNgAM2AuADIAJBkKwHIAJrQYogIABB4ANqEIsUIAJqIgJBkKsHTw0AIABBAEHJ9ABqNgLQAyAAQpiAgIDAADcDyAMgAEGA7AA2AsQDIABBzYADNgLAAyACQZCsByACa0GKICAAQcADahCLFCACaiICQZCrB08NACAAQQBBy4kBajYCsAMgAEKcgICAwAA3A6gDIABBh+wANgKkAyAAQc2AAzYCoAMgAkGQrAcgAmtBiiAgAEGgA2oQixQgAmoiAkGQqwdPDQAgAEEAQcuJAWo2ApADIABCoICAgMAANwOIAyAAQZmyATYChAMgAEHNgAM2AoADIAJBkKwHIAJrQYogIABBgANqEIsUIAJqIgJBkKsHTw0AIABBAEG5vgFqNgLwAiAAQqiAgICAATcD6AIgAEG6LzYC5AIgAEHNgAM2AuACIAJBkKwHIAJrQYogIABB4AJqEIsUIAJqIgJBkKsHTw0AIABBAEHyiAFqNgLQAiAAQrCAgICAATcDyAIgAEG9PTYCxAIgAEHNgAM2AsACIAJBkKwHIAJrQYogIABBwAJqEIsUIAJqIgJBkKsHTw0AIABB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GgsgByAIKAIEEQEAGiAFRQ0AIAQoAgQNACAAIAFBASAAKAIcEQIAGgsgBEEQaiQAIAULUgEBfwJAAkAgADQCBBCvASIFRQRAQQchAAwBCyAAIAEgBSADQf/+AXEgBCAAKAIYEQcAIgBFBEBBACEADAILIAUQQAtBACEFCyACIAU2AgAgAAtUAQF/QRUhAyABQQEgAhtFIABFIAJBAEhyckUEQCAAQfwrENQTIgBFBEBBCg8LIAIEf0EKQQAgASACQQEgABDeE0EBRxsFQQALIQMgABDIExoLIAMLHgEBf0GEoAUoAgAQmgUiAgRAIAAgASACEKkFCyACCy8BAX8jAEEQayIDJAAgAyABNgIEIAMgADYCAEEgIAJBvNYAIAMQaBogA0EQaiQACwYAQfifBQtPAgF/AX8jAEEQayIDJABBFSEEAkACQAJAIAFBAWsOAwEAAAILIAAgAUEAELwDIQQMAQsgAyACNgIAIABBASADELwDIQQLIANBEGokACAEC0ECAX8BfyMAQRBrIgQkAEEVIQUgAUHqB2tBEU0EQCAEIAM2AgQgBCACNgIAIAAgASAEEM8DIQULIARBEGokACAFC0YCAX8BfyMAQRBrIgUkAEEVIQYgAUHpB0YEQCAFIAQ2AgggBSADNgIEIAUgAjYCACAAQekHIAUQzwMhBgsgBUEQaiQAIAYLOAIBfwF/IwBBEGsiAyQAQRUhBCABQegHRgRAIAMgAjYCACAAQegHIAMQzwMhBAsgA0EQaiQAIAQLJgEBfyMAQRBrIgIkACACIAE2AgAgACACEMwDIQEgAkEQaiQAIAELLQEBfyMAQRBrIgMkACADIAI2AgQgAyABNgIAIAAgAxDMAyECIANBEGokACACCyYBAX8jAEEQayICJAAgAiABNwMAIAAgAhDMAyEAIAJBEGokACAACzYBAX8jAEEQayICJAAgAAR/IAIgADYCAEGA5wFBjvMAIAEbIAIQZgVBAAshACACQRBqJAAgAAsEAEEMCxUBAX8gACAAKAIAQQF0IgE2AgAgAQsEACAACw0AQv///////////wALDQBCgICAgICAgICAfwsHACAAQgGGCyIAIAFC////////////ADcDACAAQoCAgICAgICAgH83AwALFQEBfiAAIAApAwBCAYYiATcDACABCw0AIAAEQANADAALAAsLOwEB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AAJ/IABBIBCbAgRAIABBADoAEkEHDAELIAAoAgghBQJAIAAvARAiAkEEcQRAIAApAwAhBiADQQA6ACUgBiAGQj+HIgSFIAR9IQRBFCECA0AgA0EQaiACaiAEIARCCoAiB0IKfn2nQTByOgAAIARCClRFBEAgAkEBayECIAchBAwBCwsgBkIAUwRAIAJBAWsiAiADQRBqakEtOgAACyAFIANBEGogAmpBFiACaxCXExpBFSACayECDAELIANBADsBJCADQgA3AhwgA0EANgIQIAMgBTYCFCADQSA2AhggAwJ8IAJBIHEEQCAAKQMAuQwBCyAAKwMACzkDACADQRBqQdKNASADEFcgBSADKAIgIgJqQQA6AAALIAAgAjYCDCAAQQE6ABIgACAALwEQQYIEciICQdP/A3EgAiABGzsBEEEACyECIANBMGokACACCy4AIAAoAlggASgCCEEobGoiAS0AEUGQAXEEQCABEPgHGiABDwsgAUEEOwEQIAELVAAgAC0AEUGQAXEEQCAAIAEgAhD5Bw8LIAAgASkDADcDACAAIAEoAhA2AhAgACABKQMINwMIIAEtABFBIHFFBEAgACAALwEQQf+fAnEgAnI7ARALCxsBAX8gAC8BEEEtcSIBRQRAIAAQ+gchAQsgAQsdACAAIAAQWzcDACAAIAAvARBBwOQDcUEEcjsBEAt7AQF/AkAgAUHDAE4EQCAALwEQIgJBBHENASACQShxRQRAIAJBAnFFDQIgAEEBEPkCDwsgAUHFAEsNASAAEP0CDwsgAUHCAEcNACAALwEQIgFBAnEgAUEscUVyRQRAIABBARCyBxogAC8BECEBCyAAIAFB0/8DcTsBEAsL9QECAX8BfwJAIAAvARAiBEEBcQ0AAkACQAJAAkACQCABQcEAaw4FAAQBAgMECyAEQRBxRQRAIABBwgAQtwcgAC8BECIBQQJxRQ0FIAAgAUHA5ANxQRByOwEQQQAPCyAAIARB0OQDcTsBEEEADwsgABD7B0EADwsgABC2B0EADwsgABDtAkEADwsgACAEQQN2QQJxIARyOwEQIABBwgAQtwcgACAALwEQIgNBw/cDcTsBECACQQFHBEAgACAAKAIMQX5xNgIMCwJAIANBAnFFBEAgACACOgASDAELQQEhAyACIAAtABJHDQELIAAQpwJBACEDCyADC6YCBwF/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GCABQQA6ALABIAEgEDoAXiAIQX9BAEEBELsBGiABQQE6AFUgCgRAIAooAgQQ7gEgCkEANgIMIApBADYCBAsgARC/AQsgBUHQAWokACAEC8cCAgF/AX8gAC0ABSECAkACQCAALQAPRQ0AIAFBAmsOAwABAAELIAEgAkYNACAAIAE6AAUCQCABQQFxIAJBBXFBAUdyDQAgAC0ABA0AIAAoAkQiASgCACICBEAgASACKAIEEQEAGiABQQA2AgALIAAtABJBAk8EQCAAKAIAIgEoAhwiAkUNAiABIAAoArwBQQAgAhECABoMAgtBACECIAAtABEiASEDIAFFBEAgABD9BiECIAAtABEhAwsgA0H/AXFBAUYEQCAAQQIQ2wYhAgsCQCACDQAgACgCACICKAIcIgMEQCACIAAoArwBQQAgAxECABoLIAFBAUcNACAAQQEQ5gYaDAILIAENASAAEK0GDAELAkAgAUECaw4DAAEAAQsgACgCRCIBKAIAIgJFDQAgASACKAIEEQEAGiABQQA2AgALIAAtAAULYAEBfiAAKQMAIQICQAJAIAFCAFkEQCACQgBXIAJC////////////AIUgAVpyDQEMAgsgAkIAWQ0AIAFCAXxCgYCAgICAgICAfyACfVMNAQsgACABIAJ8NwMAQQAPC0EBCxwBAX8gACAAKAIAIgEoAtQBNgIEIAEgADYC1AELhwEDAX8BfwF/IAAoAhQhAiAAEPcBIAJCIBDvAiIBRQRAQQcPCyACIAEQVCEDIAFBADYCFCABQgA3AgggASACNgIEIAFBADYCACABQQA2AhwgAUEBOwEaIAEgAUEgajYCECABIANB4P8/akEEdjsBGCAAQS42AiQgAEGQIDsBECAAIAE2AghBAAvJAQUBfwF/AX8BfwF/IwBBoAFrIgEkACABQQBBoAEQmRMhAwNAIAAEQCAAKAIIIQRBACEBIABBADYCCANAIAMgAUECdGoiAigCACIFBEAgBSAAEMsHIQAgAkEANgIAIAFBAWohAQwBCwsgAiAANgIAIAQhAAwBCwsgAygCACEAQQEhAQNAIAFBKEZFBEACQCADIAFBAnRqKAIAIgJFDQAgAEUEQCACIQAMAQsgACACEMsHIQALIAFBAWohAQwBCwsgA0GgAWokACAAC14CAX8BfyMAQRBrIgQkAANAAkAgACIDKAIM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AhhBGGogCCgCACAIEO0DBEAgDRCUAUEAIQcMBwsgDSANKAIYQQFyNgIYDAELIANFBEAgAigCHEGAAXENAQsgACAAKAIwQQFqIgo2AjAgABD2CCIHRQ0DIABBASABELkJIAggB0G7ARD3CDYCLCAHQZMBIAEgCkECEOMIGiAGBH8gACgCzAEiCSAAKALQASIGakEBay0AACEPIAsgEygCACITNgJIIAtBACIOQZ2BAkGBgQMgBRtqNgJAIAsgBiAJIBNraiAPQTtGazYCRCANQYrSACALQUBrEIEDBUEACyEFIA0oAhAgAUEEdGooAgAhCSAIKAIAIQYgAigCACETIAsgBTYCMCALIAo2AiwgCyATNgIoIAsgBjYCJCALIAk2AiAgAEHFogIgC0EgahCSCSANIAUQMiADBEAgACAIIAoQkAogACABELoJIAsgCCgCADYCECAHIAEgDUGG5wIgC0EQahCBA0EAELsJIAdBpgFBAEEBEI4DGgtBACEBIAcoAmwhCiAHKAIALQBXBH9BwK0HBSAHKAJoIAgoAixBFGxqCyIHIAo2AggLAkAgAwRAIA0tALEBRQ0BCyAIIAIoAgg2AhQgAiAINgIIDAILIAAtANgBQQJJDQILIAAgCDYC+AELQQAhBwwEC0EAIQcLIAhFDQILIA0gCBDVBwwBC0EAIQwLIAJBCGohAgNAIAIiASgCACIARQ0BIABBFGohAiAALQA2QQVHDQALA0AgAigCACIKRQ0BIAotADZBBUYNASABIAo2AgAgACAKKAIUNgIUIAogADYCFCAKQRRqIQEMAAsACyANIAcQMyANIAQQsgMgDSADEKoIIA0gDBAyIAtB4AFqJAALRwEBfwJAIAAtANgBQQNGDQAgACgCAEIQEMMCIgNFDQAgAyABNgIAIAMgAikCADcCBCADIAAoApQCNgIMIAAgAzYClAILIAELPgEBfyAAQtgAEO8CIgJFBEAgACABEDMgAg8LIAJCADcCDCACQoGAgIDAADcCACACIAE2AgggAkEANgIUIAILWwEBfyABRQRAIAAoAgAgAhDFCQ8LIAEoAgAiAyABKAIETgRAIAAoAgAgASACEOIKDwsgASADQQFqNgIAIAEgA0EEdGoiAEEANgIUIABCADcCDCAAIAI2AgggAQuCAgYBfwF/AX8BfwF/AX8jAEEQayIEJAAg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CyADQTBqIQMgAkEBaiECDAALAAsgCSkDWCEaCyAMIAkoAhg2AhwgKkEBayEqICFCAXwhIQwACwALIAxFDQELIAAgDCgCJDsBmAEgGSAMELcMC0EAIQwLIBFBoAFqJAAgDAs7AQF/IAAoAgAiAi0AV0UEQCACIAAoAmggAUEUbGoiACwAASAAKAIQEJgHIABBADYCECAAQbsBOwEACwtUAgF/AX8jAEEQayICJAAgACgCACEAIAJBADYCDCAAIAEgAC0AVEHDACACQQxqEOwCGiACKAIMIgAEQCAAEFunQQBKIQMLIAAQ8wEgAkEQaiQAIAMLGgAgACABKAIUEDIgACABKAIgEDIgACABEDULPQIBfwF/AkAgAUUNACABQQhqIQIDQCADIAEoAgBODQEgACACKAIAELgKIAJBEGohAiADQQFqIQMMAAsACwu/AQQBfwF/AX8BfyMAQUBqIgQkAAJAIAEtAABBLEYNAEEBIQIgACgCACABIAAoAhgiBSgCKBCSDEUNACABKAIEQYGAgIACcUGAgICAAkYNACABKAIoDQAgACgCACgCAEGcAUHWtwIQzAkiA0UNACAFKAIkIQIgBEEMaiADQTQQlxMaIAMgAUE0EJcTIQMgASAEQQxqQTQQlxMaIAUgACgCACACIAMQ0gk2AiRBASECIABBATsBFAsgBEFAayQAIAILUAEBfyMAQSBrIgIkACACIAA2AhwgAkEANgIUIAJBADYCBCACQQEiAEFAazYCECACQcAANgIMIAJB2AA2AgggAkEEaiABELYJGiACQSBqJAALrAEDAX8BfwF/AkADQAJAAkAgAC0AACIBQa0Baw4EAAADAQMLIAAoAgwhAAwBCwsgAC0AAiEBCwJAIAFB/wFxIgFBmgFrQQNJIAFB9gBGcg0AIAFBqAFGBEBBASECIAAtAAZBIHENASAAKAIsIgFFDQFBACECIAAuASAiAEEASA0BIAEoAgQiA0UNASAAIAEuASJODQEgAyAAQQxsai0ABEEPcUUPC0EBIQILIAILgQEDAX8BfwF/IAEgASgCGEGAgAhyNgIYA0AgACgCJCACSgRAIAEgACgCICACQRhsaigCACIDKAIUELYKIAMoAgwiBARAIAEgBCgCFBC2CgsgAy0AB0EBcQRAIAEgAygCLCgCKBC4CgsgAkEBaiECDAELCyABIAEo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IAIrAxiZZCIDGysDACEBIAAgACsDCCACQRhqIAJBEGogAxsrAwAgASACKwMIoaCgOQMIIAAgAisDCDkDAAtAAQF+AkAgAUKAgICAgICACH1CgICAgICAgHBWBEAgASECDAELIAAgASABQoCAAYEiAn25EMUNCyAAIAK5EMUNC4MBAwF/AXwBfAJAIABBABC/AiIBRQ0AIAEpAxhCAFcNACABLQAgBEAgAS0AIQRAIABBxSpBfxCZAg8LIAErAwAhAiABKwMIIgO9Qv///////////wCDQv/////////3/wBYBEAgACADIAKgEJcCDwsgACACEJcCDwsgACABKQMQEJ4CCwunAQIBfgF/IABBKBC/AiIARSACKAIAEPgCIgRBBUZyRQRAIAAgACkDGEIBfTcDGCAALQAgRQRAIAIoAgAQWyEDIAAgACkDECADfTcDEA8LIAIoAgAhAiAEQQFGBEAgAhBbIgNCgICAgICAgICAf1IEQCAAQgAgA30Qxg0PCyAAQv///////////wAQxg0gAEQAAAAAAADwPxDFDQ8LIAAgAhBQmhDFDQsLZQMBfwF8AXwgAAJ8RAAAAAAAAAAAIABBABC/AiIBRQ0AGiABLQAgBEAgASsDACICIAErAwgiA6AgAiADvUL///////////8Ag0KAgICAgICA+P8AVBsMAQsgASkDELkLIgIQlwILcAQBfwF8AX4BfAJAIABBABC/AiIBRQ0AIAEpAxgiA0IAVw0AIAACfCABLQAgBEAgASsDACICIAErAwgiBKAgAiAEvUL///////////8Ag0KAgICAgICA+P8AVBsMAQsgASkDELkLIgIgA7qjEJcCCws/ACAAQQgQvwIhAAJAIAEEQEIBIAIoAgAzARCGQtWq1arVqtWq1QCDUA0BCyAARQ0AIAAgACkDAEIBfDcDAAsLHQEBfyAAIABBABC/AiIBBH4gASkDAAVCAAsQngILPwAgAEEIEL8CIQACQCABBEBCASACKAIAMwEQhkLVqtWq1arVqtUAg1ANAQsgAEUNACAAIAApAwBCAX03AwALC5wDBAF/AX8BfwF/AkBCASACKAIAMwEQhkKq1arVqtWq1ap/g0IAUg0AIABBJBC/AiIDRQ0AIAMoAgwhBCADIAAoAgAoAhQoAng2AgwCQCABQQFGBEAgBARAIANBAUEsEFIM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8ABqEFcMEQsgAyADKQOAA7lEAAAAAHCZlEGjOQOAASADQegCakHEjQEgA0GAAWoQVwwQCyADIAMoAowDNgKQASADQegCakHitgEgA0GQAWoQVwwPCyADIAMoApgDNgKgASADQegCakHitgEgA0GgAWoQVwwOCyADKAKUA0EMTgRAIANB6AJqQdrtAUHEggEgBEHwAEYbQQIQTQwOCyADQegCakGD7gFB0YMBIARB8ABGG0ECEE0MDQsgAyADKQKUAzcDsAEgA0HoAmpBzrYBIANBsAFqEFcMDAsgAykDgAMhCCADLQCsA0EEcQRAIAMgCEKAxMzyg/kvfblEAAAAAABAj0CjOQPQASADQegCakHxjgEgA0HQAWoQVwwMCyADIAhC6Ad/QsDSjcWRBn03A8ABIANB6AJqQbyqASADQcABahBXDAsLIAMCfyADKwOgAyIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsiBDYC4AEgA0HoAmpB4rYBIANB4AFqEFcMCgsgAyADKQKUAzcD8AEgAwJ/IAMrA6ADIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyIENgL4ASADQegCakHJtgEgA0HwAWoQVwwJCyADQegCakEBIAMpA4ADQoCU5j18QoC4mSl/p0EHbyIFQTBqIglBNyAFGyAJIARB9QBGG8AQUgwICyADIANBgANqEJUOIAMpA4ADQoCU5j18QoC4mSl/p0EHb2tBB2pBB202AoACIANB6AJqQeK2ASADQYACahBXDAcLIANBuAJqIANBgANqQTAQlxMaIANBADoA4QIgAyADKQO4AkEDIAMpA4ADQoDczBR8QoC4mSl/p0EHb2tBgLiZKWysfDcDuAIgA0G4AmoQjw4gAyADQbgCahCVDkEHbUEBajYCkAIgA0HoAmpB4rYBIANBkAJqEFcMBgsgAyADQYADahCVDiADKQOAA0KA3MwUfEKAuJkpf6dBB29rQQdqQQdtNgKgAiADQegCakHitgEgA0GgAmoQVwwFCyADIAMoAogDNgKwAiADQegCakG/tgEgA0GwAmoQVwwECyAEQSVGDQILIANB6AJqEF8MBAsgAyADKAKQAzYCACADQegCakHitgFB57YBIARB5ABGGyADEFcMAQsgA0HoAmpBAUElEFILIAFBAWohAQwACwALIANBsANq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AyQAAkAgAUEBcQRAIABB4D9BfxCZAgwBCyADIAA2AgAgA0EBOwEYIANCADcDECADQuQANwMIIAMgA0EaajYCBCADQfsAEKgOA0AgASAESgRAQgEgAiAEQQJ0aiIFKAIAMwEQhkKEgJCAgICAAoNQBEAgAEGozQFBfxCZAiADELcODAMFIAMQqQ4gAyAFKAIAEF4gBSgCABD9ARC+DiADQToQqA4gAyAFKAIEEKoOIARBAmohBAwCCwALCyADQf0AEKgOIANBAEEAEKsOIABBygAQpAILIANBgAFqJAAL+wQEAX8BfgF/AX8CQCABRQ0AIAApAwggACkDECIEIAKtfEICfFgEQCAAIAJBAmoQ6A4NASAAKQMQIQQLIAAgBEIBfDcDECAAKAIEIASnakEiOgAAA0BBACEFAkAgAAJ+AkACQANAAkAgAiAFQQNyIgZNBEAgBSEDA0AgAiADTQ0CIAEgA2otAABBgJIEai0AAEUNBCADQQFqIQMMAAsACyABIAVqLQAAQYCSBGotAABFBEAgBSEDDAMLIAEgBUEBciIDai0AAEGAkgRqLQAARQ0CIAEgBUECciIDai0AAEGAkgRqLQAARQ0CIAYiAyABai0AAEGAkgRqLQAARQ0CIAVBBGohBQwBCwsgACkDECIEIAIgBSACIAVLGyIDRQ0CGgwBCyACIANLDQIgACkDECEECyAAKAIEIASnaiABIAMQlxMaIAApAxAgA618CyIEQgF8NwMQIAAoAgQgBKdqQSI6AAAMAgsgAwRAIAAoAgQgACgCEGogASADEJcTGiAAIAApAxAgA618NwMQIAIgA2shAiABIANqIQELAkACQAJAIAEtAAAiBUHcAEcEQCAFQSdGDQEgBUEiRw0CCyAAKQMIIAApAxAiBCACrXxCA3xUBEAgACACQQNqEOgODQUgACkDECEECyAAIARCAXw3AxAgACgCBCAEp2pB3AA6AAAgACAAKQMQIgRCAXw3AxAgACgCBCAEp2ogBToAAAwCCyAAIAApAxAiBEIBfDcDECAAKAIEIASnakEnOgAADAELIAApAwggACkDECACrXxCB3xUBEAgACACQQdqEOgODQMLIAAgBRDpDgsgAkEBayECIAFBAWohAQwACwALC2kBAX8gACACKAIAQQEQog4iAwRAIAAgAigCBEEAEKIOIgIEQAJAAkAC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A0EASiEEDAUFIBIgAkECdGooAgAiBCkCBCEHIAUgAkEwbGoiA0IANwMQIANCADcDGCADIAc3AwAgA0IANwMIIAMQ1xAaIAMQ1xAaIARBADYCCCADIARBBGo2AiggAkEBaiECDAELAAsACyABQQE2AgQMAwtBACEEDAELIAooAgwiBUEANgIIIAVBFGohAwN/IAMEfwJAIAMoAhAiAi0AEA0AIAIpAwAgB1INACACKAIMQQBMDQBBASEEIAVBATYCCAsgAygCFCEDDAEFQQALCyECCyABIAIgBHJFNgIICyAGQfABaiQAIAILkgEGAX8BfwF/AX8BfwF/QQEgASgCJCICIAJBAUwbIQUgAUEoaiEGIAEoAighA0EBIQIDQCACIAVGRQRAAkAgACADIAYgAkECdGooAgAiBBDYECIHQQBMBEAgBw0BIAQoAggNAQsgBCEDCyACQQFqIQIMAQsLIAEgAykDGDcDGCABIAMoAgQ2AgQgASADKAIINgIIC+cBBwF+AX8BfwF/AX4BfwF/IAFBKGohByABKQMYIQICQANAIAFBADYCCEEBIQVBACEEAkADQCABKAIkIARKBEACQCAAIAIgByAEQQJ0aigCACIDKQMYELoPQQBMDQAgACADQQEgAiADKAIQEQkAIghFDQAgAUEANgIIIAgPCyADKAIEDQIgAykDGCEGIAMoAggEQCABQQE2AggLIAVBACACIAZRGyEFIARBAWohBCAGIQIMAQsLIAVFDQEMAgsLIAEQ2RALAkAgASgCCEUNACABIAAoAghGDQAgARDaEAsgASACNwMYQQALvAEEAX8BfwF/AX8gASgCLCEDIAEoAighAgJAA0ACQCAEDQAgAigCBCIFBEBBACEEDAMLAkAgACACIAMQ2BAiBUEATARAQQAhBAwBCyAAIANBASACKQMYIAMoAhARCQAhBCAAIAIgAxDYECEFCyAFDQAgAygCCA0AIAAgAkEAQgAgAigCEBEJACEEDAELCyACKAIEIQULIAEgBTYCBCABIAIoAgg2AgggASACKQMYNwMYIAUEQCADENoQCyAEC7EBBgF/AX8BfwF/AX8BfiAAKAIYIgZBKGohByAAKAIcIQQDQCAFIAYoAhhORQRAAkAgByAFQQJ0aigCACIDLQAQDQAgAykDACIIIAApAwBSIAFBAEcgAiAIVXFFcQ0AIAQgAyABIAIQuBAgAUUNAANAIAMtABANASADKQMAIAJZDQEgBCgCLA0BIAQgA0EAQgAQuBAMAAsACyAFQQFqIQUMAQsLIAQoAixFBEAgABC5EAsLXAMBfwF/AX4gAUGoAWohAwNAAkAgACABQQEgAhC4ECAAKAIsDQAgAS0AEA0AIAEoAjgiBEUgAyABKAJILwEEQegAbGopAwAiBSACWXENACAERSACIAVTcg0BCwsLvgUIAX8BfwF/AX8BfwF/AX4BfyMAQRBrIgYkACABQdAAaiEJIAJFIQIDQAJAAkAgACgCLA0AIAEoAkgvAQQhCCAGQQA2AgwgBiAJIAhB6ABsaiIENgIIAkACQAJ/An8CQAJAAkAgAkEBcQ0AIAQoAkQiAkUNAAJAAkAgBCgCBEECcSILBEBBACEFA0AgBQ0CIAIoAhANAiADIAIpAyBZDQIgACACQQAQuhAgACgCLCEFDAALAAsgBCgCCCEHQQAhBQNAAkAgBQ0AIAIoAhANACADIAIpAyBXDQAgAigCGCEHIAAgAhC7ECAAKAIsIQUMAQsLIAcgBCgCCEwNASAHIAQoAgAoAghKDQMgBCgCEBBAIAQgB0EBazYCCCAEQQA2AhADQCAAKAIsDQUgACAEELwQIAQoAgwiAkUNBSACKAIAIgcvAAAiBUEIdCAFQQh2ckH//wNxIgVFDQALIAVBBEkNAyACKAIIIAVMDQMgBCAFIAdqIARB2ABqEL0QIAVqrTcDGCAAIAQQvhAMBAsgAigCGCICIAQoAghODQAgBCACQQFqNgIIIAAgBBC/EAwDCyAFDQJBAAwDCyAAIAQgBkEMaiAEKAIkEQQAIAQoAgxFDAMLIABBiwI2AiwLQQELIQIDQCACRQRAIAAgBEEAIAQoAiQRBABBASECDAELIAQoAgxFDQIgBCkDWCEKAkACQCALRQRAIAMgClUNAQwCCyADIApZDQELIAAoAiwNAEEAIQIMAQsLQQALIgINACAGKAIMDQAgASAIIAZBCGoQwBBFDQELIAAgASAIQQEQwRAgARDCECAGIAkgASgCSC8BBEHoAGxqIgI2AgggAigCDEUNAQsgAS0APARAIAYoAggoAmBFDQILIAEQwxANASABIAYoAgggASgCMBEFAAsgBkEQaiQADwtBASECDAALAAvfBg0BfwF/AX8BfwF/AX8BfwF/AX4BfgF+AX8BfyMAQRBrIg0kACAAQgA3AwggACgCGCICKAIYIgdBACAHQQBKGyEEIAJBKGohBUKAgICAgICAgIB/IQoDQCABIARGRQRAAkAgBSABQQJ0aigCACIDLQAQDQAgCEEAIAMpAwAiCSAKWRtFBEAgACADKAIINgIIIAAgAygCDDYCDEEBIQggASEGIAkhCgwBCyAIIAkgClFqIQgLIAFBAWohAQwBCwsCQCAIRQRAIABBAToAEAwBCyAAKAIcIgEoAgAoAkQhDCAAQQA6ABAgACAKNwMAIAhBAUcgDHJFBEAgASACIAZBACAKQn8QxBAMAQsgDEEBRiAIQQJIcg0AIA1CADcDCCACKAIgRQRAIAIgAUEsaiAHQRxsrRDCDyIBNgIgIAFFDQEgAiABIAIoAhgiB0EYbGo2AiQLQQAhBEEAIQZBACEBA0AgASAHTkUEQCAFIAFBAnRqKAIAIgMpAwAgClEEQCACKAIkIARBAnRqIAE2AgAgAygCCCADKAIMIAIoAiAgBEEYbGoQxRAgAygCDCAGaiEGIAIoAhghByAEQQFqIQQLIAFBAWohAQwBCwsgAEEgaiEHIAAoAiQgBiAIQQpsamoiASAAKAIoSwRAIAAoAhxBLGogByABEIoQDQELAkAgDA0AIAIoAgAiASACKAIEIAZqTg0AIAIoAgggASAGaiIBQTBsEEkiA0UEQCAAKAIcQQc2AiwMAgsgAiADNgIIIAIgAUEBdDYCAAtBACEDIABBADYCJCAEQQAgBEEAShshBANAQv///////////wAhC0EAIQECQANAIAshCSADIQUgASAERwRAIAIoAiAgAUEYbGoiAy0ADQR/IAUFIAMpAxAiCyAJIAkgC1UiAxshCyABIAUgAxsLIQMgAUEBaiEBDAELIAlC////////////AFENASAHIA1BCGogCRDGECACKAIgIAVBGGxqEMcQGkEAIQNC////////////ACELQQAhASAMDQALIAIoAgggAigCBCIDQRhsaiIBIAk3AwggAigCJCAFQQJ0aigCACEFIAEgCjcDACABIAU2AhAgAiADQQFqNgIEQQAhAwwBCwsgACAAKQMgNwMICyANQRBqJAAL6QIIAX8BfwF/AX8BfwF/AX8BfiMAQRBrIgUkACABIAJBBXRqIgRBCGohAwJAAkAgBCgCDCIH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ACAMIAgpAxAiAVEEQCAIEMcQDQEgCCkDECEBCyABIAogASAKUxshCgsgAEEBaiEADAELCyAKQv///////////wBRIAVyRQRAIAIgCUEIaiAKENUQIQUgCiEMDAELCyAFDQAgAyACKAIANgIAIAQgAigCBDYCAAsgCUEQaiAGRwRAIAYQQAsgCUHwAGokACAFC1oDAX8BfwF/IwBBEGsiAyQAIANBADYCDAJAAkAgACgCBEEPaiIFIAAoAghNDQAgA0EMaiAAIAUQihBFDQAgAygCDCEEDAELIAAgASACEMYQCyADQRBqJAAgBAsUACABQQA2AgQgACABIAIgAxC+DwtHACAAIAApAxg3AxAgACgCACAAKAIEIABBCGogAEEYahDTEARAIABCgICAgICAgIDAADcDGAsgACkDEEKAgICAgICAgMAAUQsnACACKAIEBEBBfw8LIAEoAgQEQEEBDwsgACABKQMYIAIpAxgQug8LOgIBfwF/IABCATcCBCAAQShqIQIDQCABIAAoAiRORQRAIAIgAUECdGooAgAQ2RAgAUEBaiEBDAELCwuSAQIBfwF/AkAgACgCACIBQQRGIAFBCUZyRQRAIABBKGohAkEAIQEDQCABIAAoAiRODQIgAiABQQJ0aigCABDaECABQQFqIQEMAAsACyAAKAIgIgEoAggiAEEAIABBAEobIQAgAUEMaiECQQAhAQNAIAAgAUYNASACIAFBAnRqKAIAQQA2AgggAUEBaiEBDAALAAsLvQQLAX8BfwF/AX8BfwF/AX8BfwF/AX8BfyABQgA3AgQCQAJAIAEoAgAiAkEJRyACQQRHcUUEQCABKAIgIgZBDGohCgNAAkAgBigCCCAHTARAQQAhAgwBCyAKIAdBAnRqKAIAIgkoAhBFBEBBASECDAELIAlBFGohC0EAIQgDQAJAIAkoAhAgCEoEQEEAIQQgCyAIQRhsaiIMIQIDQCACRQ0CIAJBEGohAyACKAIQIgUEQCAFEJcQIANBADYCAAsgACgCACACKAIEIAIoAgggACgCDEEAR0EBdCAMLQAAQQBHciAGKAIEIAMQ3BAiAw0IIARBASACKAIQLQAQGyEEIAIoAhQhAgwACwALIAdBAWohBwwDC0EBIQIgCEEBaiEIIAQNAAsLCyABIAI2AgQMAQsCQAJAIAEoAhAEQCABQShqIQZB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fyMAQRBrIgQkAAJAIAEoAjgiA0EASgRAIAEoAgwoAgAhBSABIANBAWsiAzYCOCABIAEoAkAgA0ECdGo0AgA3AxggACABEL4QIAEoAhghAyAAKAIAKAJEQQFHBEAgASgCYCADaiEDCyADIAVqIARBCGoQvRAaIAEgASkDWCAEKQMIfTcDWAwBCyAAIAEQvxALIARBEGokAAvIAwYBfwF/AX8BfwF/AX8jAEEgayIDJAAgAUHYAGohBiAAQSxqIQggASgCGCEEAkADQAJAIAEoAgAiBUUNACAEIAEoAgwoAghIDQAgACABELwQIAAoAiwNAiABKAIMRQ0CIAZCADcDAEEEIQQMAQsLAkACQCABKAI0IARKBEAgASABKAIMKAIAIARqIANBGGoQvRAgBGqsNwMYIAEgASkDWCADKQMYfDcDWAwBCyABLQAEQQFxDQECQCAFBEBBACEFIANBADYCGCABKAIMEIQRIARHBEAgASgCDCgCACAEaiADQRhqEM8QIARqIQQgAygCGCEFCyABIASsNwMYIAAgASAFEOAQDAELIANBADYCGCADQQA2AhQgA0EANgIQIAAoAgwiBCAEKAIQKAIENgIQIAQgA0EUaiADQRBqIANBGGogA0EMahDvECADKAIYIgRFDQIgASgCDCIFIAQ2AgAgBSADKAIMIgc2AgggBSAHNgIEIAEgBzYCNCAIIAFByABqIAMoAhAgAygCFBDWECABIAQgBhC9EK03AxgLIAJFDQAgAkEBNgIACyAAIAEQvhAMAQsgASgCDBBAIAFBADYCDAsgA0EgaiQAC8EGCQF/AX8BfwF/AX4BfwF/AX8BfyMAQSBrIgQkACABKAIMIQUgBEEANgIcAkACQAJAIAEoAmAgASgCGGoiAyAFKAIISARAIAUoAgAhBgJAIAEoAjQgA0wEQEEBIQggBRCEESADRg0BIAMgBmogBEEcahDPECADaiEDDAELIAMgBmogBEEQahC9ECEFIAEgASkDWCAEKQMQfDcDWCADIAVqIQMLIAEgA6w3AxgMAQsCQCABKAIARQRAIARBADYCECAEQQA2AgwgBEEANgIIIARBADYCBCABLQAEQQFxRQRAIAAoAgwiAyADKAIQKAIENgIQIAMgBEEMaiAEQQhqIARBEGogBEEEahDvECAEKAIQIgMNAgsgASgCDBBAIAFBADYC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cUUNCyADKAIAIgZBAEoNAiADLQAEQQJHDQFBACEEA0AgAiAERg0PIAEoAhAgBEEDdGoiA0EAOgAEIANBADYCACAEQQFqIQQMAAsACyAGQf8BcUUNCgsgAygCACIGQQBMDQELIAYgAC0AFU0NAQsgAy0ABEHAAEYNAQwHC0EAIQhBwQAhBwJAIAMtAAQiA0ECaw4HBgcCBwcHAwALIANBEEYNAyADQSBGDQQgA0HAAEcNBgtBASEIQcYAIQcMBAtBxQAhBwwDC0EBIQhBwgAhBwwCC0HDACEHDAELQQEhCEHEACEHCyAFIAlqIgMgBzoAACADIAZBL2o6AAEgASgCECACQQN0aiIDIAg6AAQgAyAFQQJqIgVBAm02AgALIAJBAWohAgwBCwsgAUEBNgIcIAFBAjYCFCAFQQBKBEAgASAFQQFqIgQQPyICNgIYQQcgAkUNBRogAiAJIAQQlxMaCyABIAApAzAgBUECba2HIgs3AzAgASALuUQAAAAAAAAYQKI5AygMAwsFQQEgBCABKAIEIAJBDGxqLQAEQcAARhshBCACQQFqIQIMAQsLIAFBATYCFCABKAIQIAJBA3RqIgJBAToABCACQQE2AgAgAUEBNgI4IAFCATcDMCABQoCAgICAgICfwAA3AygLQQALIQIgCUEwaiQAIAILCQAgABCOEkEAC4EBAQF/IAAgACgCLEEBayIBNgIsIAFFBEAgAEEAOgAYIAAQkBIgACgCTBCOARogACgCUBCOARogACgCVBCOARogACgCWBCOARogACgCXBCOARogACgCYBCOARogACgCZBCOARogACgCaBCOARogACgCbBCOARogACgCQBBAIAAQQAsLjwEDAX8BfwF/IwBBIGsiASQAIAAoAiAhAiABIAAoAiQiAzYCFCABIAI2AhAgASADNgIMIAEgAjYCCCABIAM2AgQgASACNgIAAkBB/KcCIAEQZiIDRQRAQQchAgwBCyAAEJASIAAoAgwgA0EAQQBBABCLASECIAMQQCACDQAgABCOEkEAIQILIAFBIGokACACCxgBAX8gACgCSCEBIABBADYCSCABEJQDGgs8AgF/AX9C+AEQSCICBH8gAkEAQfgBEJkTIAA2AgAgACAAKAI4QQFqNgI4QQAFQQcLIQMgASACNgIAIAMLQQEBfyAAKAIAIQEgABCTEiAAKAIk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A0EQaiQAIAELogEDAX8BfwF/A0AgACACaiIEIAJB1r8Cai0AADoAACACQQ5HIQMgAkEBaiECIAMNAAsgAQRAQQ4hAiABIQMDQCACQQFqIQIgA0EJSyEEIANBCm4hAyAEDQALIAAgAmpBADoAAANAIAAgAkEBayICaiABIAFBCm4iA0EKbGtBMHI6AAAgAUEJSyEEIAMhASAEDQALDwsgBEEwOgAAIABBADoADwtFAQF/IwBBEGsiAyQAIAMgAjYCDCADIAE2AgggACADQQhqQQEgA0EEahAMELcUIQIgAygCBCEBIANBEGokAEF/IAEgAhsLSwEBfyMAQRBrIgMkAEGcfyAAIAEgA0EPaiACGyIBQQEgAiACQQFNGxAcIgJBH3UgAnEgAiABIANBD2pGGxCdFCECIANBEGokACACCwkAIAAQHRCdFAuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XTxtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaE0bQZIPaiEBCyAAIAFB/wdqrUI0hr+iC8wBAwF/AX8BfCMAQRBrIgEkAAJAIAC9QiCIp0H/////B3EiAkH7w6T/A00EQCACQYCAwPIDSQ0BIABEAAAAAAAAAABBABCwEyEADAELIAJBgIDA/wdPBEAgACAAoSEADAELIAAgARCvEyECIAErAwghACABKwMAIQMCQAJAAkACQCACQQNxQQFrDgMBAgMACyADIABBARCwEyEADAMLIAMgABCtEyEADAILIAMgAEEBELATmiEADAELIAMgABCtE5ohAAsgAUEQaiQAIAALlgEDAXwBfAF+RAAAAAAAAOA/IACmIQICQCAAmSIBvSIDQv////+fyIvDwABYBEAgARDAEyEBIANC//////////c/WARAIANCgICAgICAgKg+VA0CIAIgASABoCABIAGiIAFEAAAAAAAA8D+go6GiDwsgAiABIAEgAUQAAAAAAADwP6CjoKIPCyABIAIgAqAQshMhAAsgAAsqAQF/IwBBEGsiBCQAIAQgAzYCDCAAIAEgAiADELUUIQMgBEEQaiQAIAML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IjogewAlcyJhdXRob3JpemVyIjogewAlcyJpb0NhcCI6IHsAJXMic2Vzc2lvbiI6IHsAJXMidmVyc2lvbiI6IHsAJXMiZmNudGwiOiB7ACVzImZsb2NrIjogewAlcyJjb25maWciOiB7ACVzImRiQ29uZmlnIjogewAlcyJzZXJpYWxpemUiOiB7ACVzInR4blN0YXRlIjogewAlcyJ0cmFjZSI6IHsAJXMidnRhYiI6IHsAcGdzegAleiVzJXoAJXMuJXoASW4gUlRyZWUgJXMuJXM6CiV6AGpzb25fcHJldHR5AGluZmluaXR5AGFmZmluaXR5AFJlYWxBZmZpbml0eQBidXN5AHRlbXBfc3RvcmVfZGlyZWN0b3J5AG5vdCBhIHdyaXRhYmxlIGRpcmVjdG9yeQBvcGVuRGlyZWN0b3J5AHNocmlua19tZW1vcnkAb3V0IG9mIG1lbW9yeQBmYWlsZWQgdG8gYWxsb2NhdGUgJXUgYnl0ZXMgb2YgbWVtb3J5AEhBVklORyBjbGF1c2Ugb24gYSBub24tYWdncmVnYXRlIHF1ZXJ5AHRlbXBvcmFyeQBJbnRDb3B5AFNDb3B5AHhEZXN0cm95AFZEZXN0cm95AFNBVkVQT0lOVCBjaGFuZ2VzZXRfYXBwbHkAUk9MTEJBQ0sgVE8gY2hhbmdlc2V0X2FwcGx5AFJFTEVBU0UgY2hhbmdlc2V0X2FwcGx5AE11bHRpcGx5AHF1ZXJ5X29ubHkAcmVhZC1vbmx5AHVubGlrZWx5AHRhYmxlICIlcyIgaGFzIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBrZXkAZm9yZWlnbiBrZXkAanNvbl9ncm91cF9hcnJheQBqc29uYl9ncm91cF9hcnJheQBqc29uX2FycmF5AGpzb25iX2FycmF5AGp1bGlhbmRheQBuT3JkZXJCeQBhT3JkZXJCeQB2YWN1dW1fJTAxNmxseAB1bml4AHNxbGl0ZV9yZW5hbWVfcXVvdGVmaXgAcHJlZml4AExJS0Ugb3IgR0xPQiBwYXR0ZXJuIHRvbyBjb21wbGV4AHVuaGV4AE9wZW5BdXRvaW5kZXgAYXV0b21hdGljX2luZGV4AGF1dG8taW5kZXgAb3JwaGFuIGluZGV4AGFyZ3ZJbmRleAB4QmVzdEluZGV4AERyb3BJbmRleAB0YmwsIGlkeABSZW9wZW5JZHgAbWF4AE1lbU1heAAlcyUuM3grJS42eAAlMDJ4AC0rICAgMFgweAAtMFgrMFggMFgtMHgrMHggMHgAQ1JFQVRFIFRBQkxFIHgAcncAcHNvdwBpbXBsaWVzX25vbm51bGxfcm93AHBvdwBub3cAaW50ZWdlciBvdmVyZmxvdwBmdHM1OiBwYXJzZXIgc3RhY2sgb3ZlcmZsb3cAd2luZG93AHNoYWRvdwBSZXN1bHRSb3cASWZOdWxsUm93AG5ldwBubyBzdWNoIHZpZXcAY2Fubm90IG1vZGlmeSAlcyBiZWNhdXNlIGl0IGlzIGEgdmlldwBDYW5ub3QgYWRkIGEgY29sdW1uIHRvIGEgdmlldwBjYW5ub3QgVVBTRVJUIGEgdmlldwBQcmV2AGsgUFJJTUFSWSBLRVksIHYAICVsbHUAJWMldQBGYWlsZWQgdG8gcmVhZCBwdHJtYXAga2V5PSV1ACUuKno6JXUAT2Zmc2V0ICV1IG91dCBvZiByYW5nZSAldS4uJXUAaW52YWxpZCBwYWdlIG51bWJlciAldQBmYWlsZWQgdG8gZ2V0IHBhZ2UgJXUAMm5kIHJlZmVyZW5jZSB0byBwYWdlICV1AEZyYWdtZW50YXRpb24gb2YgJXUgYnl0ZXMgcmVwb3J0ZWQgYXMgJXUgb24gcGFnZSAldQBmcmVlbGlzdCBsZWFmIGNvdW50IHRvbyBiaWcgb24gcGFnZSAldQBNdWx0aXBsZSB1c2VzIGZvciBieXRlICV1IG9mIHBhZ2UgJXUAJXMgaXMgJXUgYnV0IHNob3VsZCBiZSAldQB1bmFibGUgdG8gdXNlIGZ1bmN0aW9uICVzIGluIHRoZSByZXF1ZXN0ZWQgY29udGV4dAB4TmV4dABTb3J0ZXJOZXh0AHBOZXh0AFZOZXh0AGluY29tcGxldGUgaW5wdXQAYnVzeV90aW1lb3V0AGxvY2FsaG9zdABlc3RpbWF0ZWRDb3N0AGNhbm5vdCBkcm9wIGNvbHVtbiAiJXMiOiBubyBvdGhlciBjb2x1bW5zIGV4aXN0AHBlcnNpc3QAZm9yZWlnbl9rZXlfbGlzdABpbmRleF9saXN0AGZ1bmN0aW9uX2xpc3QAY29sbGF0aW9uX2xpc3QAZGF0YWJhc2VfbGlzdABtb2R1bGVfbGlzdABQUkFHTUEgdGFibGVfbGlzdABwcmFnbWFfbGlzdABzZXQgbGlzdABWYWx1ZUxpc3QAc3FsaXRlX3JlbmFtZV90ZXN0AFJvd1NldFRlc3QAU2VxdWVuY2VUZXN0AEF1eGlsaWFyeSBydHJlZSBjb2x1bW5zIG11c3QgYmUgbGFzdABmYXN0AExhc3QAQ2FzdABzcXJ0AFNvcnRlclNvcnQAIlwvYmZucnQAanNvbl9pbnNlcnQAanNvbmJfaW5zZXJ0AGNhbm5vdCBpbnNlcnQASWR4SW5zZXJ0AFNvcnRlckluc2VydAByZXN0YXJ0AERpbWVuc2lvbiAlZCBvZiBjZWxsICVkIG9uIG5vZGUgJWxsZCBpcyBjb3JydXB0AEJpdE5vdABJZk5vdABQYWdlY291bnQAZnJlZWxpc3RfY291bnQAbWF4X3BhZ2VfY291bnQAUFJBR01BICIldyIucGFnZV9jb3VudABSZXNldENvdW50AHdhbF9hdXRvY2hlY2twb2ludAB3YWxfY2hlY2twb2ludABDaGVja3BvaW50AHhTYXZlcG9pbnQAYSBDSEVDSyBjb25zdHJhaW50ACVzT04gQ09ORkxJQ1QgY2xhdXNlIGRvZXMgbm90IG1hdGNoIGFueSBQUklNQVJZIEtFWSBvciBVTklRVUUgY29uc3RyYWludABuQ29uc3RyYWludABhQ29uc3RyYWludABDdXJzb3JIaW50AGNvbnRlbnQAJV9wYXJlbnQARGltZW5zaW9uICVkIG9mIGNlbGwgJWQgb24gbm9kZSAlbGxkIGlzIGNvcnJ1cHQgcmVsYXRpdmUgdG8gcGFyZW50AERJU1RJTkNUIGFnZ3JlZ2F0ZXMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFyZ3VtZW50AGNvbW1lbnQAQVBJIGNhbGxlZCB3aXRoIGZpbmFsaXplZCBwcmVwYXJlZCBzdGF0ZW1lbnQAQVBJIGNhbGxlZCB3aXRoIE5VTEwgcHJlcGFyZWQgc3RhdGVtZW50AGFyZ3VtZW50IHRvICVzKCkgaXMgbm90IGEgdmFsaWQgU1FMIHN0YXRlbWVudABNYXhQZ2NudABkZWZhdWx0IHZhbHVlIG9mIGNvbHVtbiBbJXNdIGlzIG5vdCBjb25zdGFudABNdXN0QmVJbnQAc3FsaXRlX3N0bXQAQ2Fubm90IGFkZCBhIGNvbHVtbiB3aXRoIG5vbi1jb25zdGFudCBkZWZhdWx0AEhhbHQAc3RhdF9pbml0AEluaXQAb21pdAB4Q29tbWl0AEF1dG9Db21taXQAYW5hbHlzaXNfbGltaXQAc29mdF9oZWFwX2xpbWl0AGhhcmRfaGVhcF9saW1pdABqb3VybmFsX3NpemVfbGltaXQAT2Zmc2V0TGltaXQAU2Vla0hpdABPTiBjbGF1c2UgcmVmZXJlbmNlcyB0YWJsZXMgdG8gaXRzIHJpZ2h0AGhpZ2hsaWdodABTaGlmdFJpZ2h0AGhnaHQAU2hpZnRMZWZ0AHNxbGl0ZV9vZmZzZXQAaVRlcm1PZmZzZXQAcmVzZXQAU0FWRVBPSU5UIGNoYW5nZXNldABSRUxFQVNFIGNoYW5nZXNldABqc29uX3NldABqc29uYl9zZXQAdG9vIG1hbnkgY29sdW1ucyBpbiByZXN1bHQgc2V0ACVyIE9SREVSIEJZIHRlcm0gZG9lcyBub3QgbWF0Y2ggYW55IGNvbHVtbiBpbiB0aGUgcmVzdWx0IHNldABzbmlwcGV0AHN0YXRfZ2V0AHNxbGl0ZV9jb21waWxlb3B0aW9uX2dldABzdHJpY3QATm9Db25mbGljdAB4RGlzY29ubmVjdAB4Q29ubmVjdABqc29uX2dyb3VwX29iamVjdABqc29uYl9ncm91cF9vYmplY3QAanNvbl9vYmplY3QAanNvbmJfb2JqZWN0AGpzb25fZXh0cmFjdABqc29uYl9leHRyYWN0AFN1YnRyYWN0AGxzdGF0AGZzdGF0AGRic3RhdAB0YmwsaWR4LHN0YXQAdGJsLCA/Miwgc3RhdAB1bnN1cHBvcnRlZCBmaWxlIGZvcm1hdABncm91cF9jb25jYXQAQ29uY2F0AEx0AEd0AGRlZmVyX2ZvcmVpZ25fa2V5cwBhbHdheXMAZXN0aW1hdGVkUm93cwBwYXJhbWV0ZXJzIGFyZSBub3QgYWxsb3dlZCBpbiB2aWV3cwBjb25jYXRfd3MAc3RhdHVzAHN5bmNocm9ub3VzAGluZGV4ICVzIGFscmVhZHkgZXhpc3RzAG91dHB1dCBmaWxlIGFscmVhZHkgZXhpc3RzACVzICVUIGFscmVhZHkgZXhpc3RzAHRyaWdnZXIgJVQgYWxyZWFkeSBleGlzdHMATm90RXhpc3RzAGlnbm9yZV9jaGVja19jb25zdHJhaW50cwBDSEVDSyBjb25zdHJhaW50cwBleHByZXNzaW9ucyBwcm9oaWJpdGVkIGluIFBSSU1BUlkgS0VZIGFuZCBVTklRVUUgY29uc3RyYWludHMAanNvbl9vYmplY3QoKSByZXF1aXJlcyBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMAanNvbl8lcygpIG5lZWRzIGFuIG9kZCBudW1iZXIgb2YgYXJndW1lbnRzAHdyb25nIG51bWJlciBvZiB2dGFibGUgYXJndW1lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IHVzZXItZnVuY3Rpb24gZHVlIHRvIGFjdGl2ZSBzdGF0ZW1lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IGNvbGxhdGlvbiBzZXF1ZW5jZSBkdWUgdG8gYWN0aXZlIHN0YXRlbWVudHMAcmV2ZXJzZV91bm9yZGVyZWRfc2VsZWN0cwBpaXNzc3NzcwBpc3MAY2Fubm90IG9wZW4gc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IHJlbGVhc2Ugc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IGNvbW1pdCB0cmFuc2FjdGlvbiAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGNhbm5vdCBWQUNVVU0gLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBvdXNuZXNzAHhSYW5kb21uZXNzAGZ1bG5lc3MAaXZlbmVzcwBhY2Nlc3MAeEFjY2VzcwBzZXBhcmF0b3JzAHBhcmFtZXRlcnMAcmVjdXJzaXZlX3RyaWdnZXJzAHRoZSBJTkRFWEVEIEJZIGNsYXVzZSBpcyBub3QgYWxsb3dlZCBvbiBVUERBVEUgb3IgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAHRoZSBOT1QgSU5ERVhFRCBjbGF1c2UgaXMgbm90IGFsbG93ZWQgb24gVVBEQVRFIG9yIERFTEVURSBzdGF0ZW1lbnRzIHdpdGhpbiB0cmlnZ2VycwBxdWFsaWZpZWQgdGFibGUgbmFtZXMgYXJlIG5vdCBhbGxvd2VkIG9uIElOU0VSVCwgVVBEQVRFLCBhbmQgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAENoaWxkIHBhZ2UgZGVwdGggZGlmZmVycwB0b2tlbmNoYXJzAHVuYWJsZSB0byBjbG9zZSBkdWUgdG8gdW5maW5hbGl6ZWQgc3RhdGVtZW50cyBvciB1bmZpbmlzaGVkIGJhY2t1cHMAYWNvcwBJZlBvcwBjb21waWxlX29wdGlvbnMARElTVElOQ1QgaXMgbm90IHN1cHBvcnRlZCBmb3Igd2luZG93IGZ1bmN0aW9ucwBGSUxURVIgY2xhdXNlIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBhZ2dyZWdhdGUgd2luZG93IGZ1bmN0aW9ucwBub24tZGV0ZXJtaW5pc3RpYyBmdW5jdGlvbnMAaW5kZXggZXhwcmVzc2lvbnMAU0VMRUNUcyB0byB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgJXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHJlc3VsdCBjb2x1bW5zAHZpcnR1YWwgdGFibGVzIGNhbm5vdCB1c2UgY29tcHV0ZWQgY29sdW1ucwBnZW5lcmF0ZWQgY29sdW1ucwB0YWJsZSAlcyBoYXMgJWQgdmFsdWVzIGZvciAlZCBjb2x1bW5zAHJhZGlhbnMAYWxsIFZBTFVFUyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHRlcm1zAGVtcHR5X3Jlc3VsdF9jYWxsYmFja3MATG9hZEFuYWx5c2lzAGZsZ3MAZmxhZ3MAaWR4RmxhZ3MAZmlsZTpzZXNzaW9uP3Zmcz1rdnZmcwBmaWxlOmxvY2FsP3Zmcz1rdnZmcwBtdWx0aXBsZSBjb250ZW50PS4uLiBkaXJlY3RpdmVzAG11bHRpcGxlIHRva2VuaXplPS4uLiBkaXJlY3RpdmVzAG11bHRpcGxlIGNvbnRlbnRfcm93aWQ9Li4uIGRpcmVjdGl2ZXMAJWQgY29sdW1ucyBhc3NpZ25lZCAlZCB2YWx1ZXMASlNPTiBjYW5ub3QgaG9sZCBCTE9CIHZhbHVlcwBmYWlsZWQgbWVtb3J5IHJlc2l6ZSAldSB0byAldSBieXRlcwBwYXJ0aWFsIGluZGV4IFdIRVJFIGNsYXVzZXMAc2hvcnRfY29sdW1uX25hbWVzAGZ1bGxfY29sdW1uX25hbWVzAHVuYWJsZSB0byBvcGVuIGEgdGVtcG9yYXJ5IGRhdGFiYXNlIGZpbGUgZm9yIHN0b3JpbmcgdGVtcG9yYXJ5IHRhYmxlcwBjYW5ub3QgY3JlYXRlIHRyaWdnZXJzIG9uIHNoYWRvdyB0YWJsZXMAY2Fubm90IGNyZWF0ZSB0cmlnZ2VycyBvbiB2aXJ0dWFsIHRhYmxlcwAlcyBSRVRVUk5JTkcgaXMgbm90IGF2YWlsYWJsZSBvbiB2aXJ0dWFsIHRhYmxlcwBjYW5ub3Qgam9pbiB1c2luZyBjb2x1bW4gJXMgLSBjb2x1bW4gbm90IHByZXNlbnQgaW4gYm90aCB0YWJsZXMAQVVUT0lOQ1JFTUVOVCBub3QgYWxsb3dlZCBvbiBXSVRIT1VUIFJPV0lEIHRhYmxlcwAlcyBjYW5ub3QgdXNlIHZhcmlhYmxlcwB0b28gbWFueSBTUUwgdmFyaWFibGVzAGNhdGVnb3JpZXMAc3VicXVlcmllcwBjYW5ub3QgdXNlIHdpbmRvdyBmdW5jdGlvbnMgaW4gcmVjdXJzaXZlIHF1ZXJpZXMAY291bnRfY2hhbmdlcwB0b3RhbF9jaGFuZ2VzAGRlZ3JlZXMAUkVUVVJOSU5HIG1heSBub3QgdXNlICJUQUJMRS4qIiB3aWxkY2FyZHMAcE1ldGhvZHMAdGhyZWFkcwB4RGV2aWNlQ2hhcmFjdGVyaXN0aWNzAHJlbW92ZV9kaWFjcml0aWNzAGFicwAleiUuKnMALiUuKnMALCUuKnMAQ1JFQVRFICVzICUuKnMAQ1JFQVRFJXMgSU5ERVggJS4qcwBpbnZhbGlkIHVyaSBhdXRob3JpdHk6ICUuKnMAdW5rbm93biBzcGVjaWFsIHF1ZXJ5OiAlLipzAHVua25vd24gdGFibGUgb3B0aW9uOiAlLipzACUuKnMlcwAsJXMlcyVzAFNDQU4gJXMlcyVzAHNxbGl0ZV9hbHRlcnRhYl8lcwBTQ0FOICVkIENPTlNUQU5UIFJPVyVzACVRJXMAMHgleDolcwAlZDolcwAlczogJXMuJXMuJXMAcmVjdXJzaXZlIGRlZmluaXRpb24gZm9yICVzLiVzAG1pc3NpbmcgZGF0YXR5cGUgZm9yICVzLiVzAGNhbm5vdCBzdG9yZSAlcyB2YWx1ZSBpbiAlcyBjb2x1bW4gJXMuJXMAbm9uLSVzIHZhbHVlIGluICVzLiVzAFRFWFQgdmFsdWUgaW4gJXMuJXMATlVMTCB2YWx1ZSBpbiAlcy4lcwBOVU1FUklDIHZhbHVlIGluICVzLiVzAG1hbGZvcm1lZCBpbnZlcnRlZCBpbmRleCBmb3IgRlRTNSB0YWJsZSAlcy4lcwAlczogJXMuJXMAbm8gc3VjaCB0YWJsZSBjb2x1bW46ICVzLiVzAG5vIHN1Y2ggZnRzNSB0YWJsZTogJXMuJXMAVU5JUVVFIGNvbnN0cmFpbnQgZmFpbGVkOiAlcy4lcwBERUxFVEUgRlJPTSAlUS4lcwAuLiVzACUuMThzLSVzAGt2dmZzLSVzLSVzAHN1YnJ0bnNpZzolZCwlcwBDUkVBVEUgVEFCTEUgJVEuJyVxXyVxJyglcyklcwAgVVNJTkcgSU5URUdFUiBQUklNQVJZIEtFWSAoJXMAdXNlIERST1AgVklFVyB0byBkZWxldGUgdmlldyAlcwByb3cgbm90IGluIFBSSU1BUlkgS0VZIG9yZGVyIGZvciAlcwBtaXN1c2Ugb2YgYWxpYXNlZCB3aW5kb3cgZnVuY3Rpb24gJXMAdG9vIG1hbnkgY29sdW1ucyBvbiAlcwB0b28gbWFueSBjb2x1bW5zIGluICVzACVzIHByb2hpYml0ZWQgaW4gJXMAQ0hFQ0sgY29uc3RyYWludCBmYWlsZWQgaW4gJXMAbm9uLWRldGVybWluaXN0aWMgdXNlIG9mICVzKCkgaW4gJXMAcmVjb3ZlcmVkICVkIHBhZ2VzIGZyb20gJXMAbWlzdXNlIG9mIGFsaWFzZWQgYWdncmVnYXRlICVzACVzICVUIGNhbm5vdCByZWZlcmVuY2Ugb2JqZWN0cyBpbiBkYXRhYmFzZSAlcwBjYW5ub3QgZGV0YWNoIGRhdGFiYXNlICVzAGEgSk9JTiBjbGF1c2UgaXMgcmVxdWlyZWQgYmVmb3JlICVzAGNhbm5vdCBvcGVuIHZhbHVlIG9mIHR5cGUgJXMAY2Fubm90IGZzdGF0IGRiIGZpbGUgJXMAcmVjb3ZlcmVkICVkIGZyYW1lcyBmcm9tIFdBTCBmaWxlICVzAGZ0czU6IG1pc3Npbmcgcm93ICVsbGQgZnJvbSBjb250ZW50IHRhYmxlICVzAHNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkoKTogcHJpbWFyeSBrZXkgbWlzbWF0Y2ggZm9yIHRhYmxlICVzAFBSSU1BUlkgS0VZIG1pc3Npbmcgb24gdGFibGUgJXMAdXNlIERST1AgVEFCTEUgdG8gZGVsZXRlIHRhYmxlICVzAHRoZXJlIGlzIGFscmVhZHkgYW4gaW5kZXggbmFtZWQgJXMAdGFibGUgJVMgaGFzIG5vIGNvbHVtbiBuYW1lZCAlcwB0aGVyZSBpcyBhbHJlYWR5IGEgdGFibGUgbmFtZWQgJXMAc3RhdGVtZW50IGFib3J0cyBhdCAlZDogWyVzXSAlcwBDT1ZFUklORyBJTkRFWCAlcwBTRUxFQ1QgJXMAdW5zdXBwb3J0ZWQgdXNlIG9mIE5VTExTICVzAEFUVEFDSCAlUSBBUyAlcwBVU0UgVEVNUCBCLVRSRUUgRk9SICVzAC0tIFRSSUdHRVIgJXMAUklHSFQtSk9JTiAlcwA+PyBBTkQgJXMAJXo6ICVzAHJlY3Vyc2l2ZSByZWZlcmVuY2UgaW4gYSBzdWJxdWVyeTogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGNhbGxlZCByZWN1cnNpdmVseTogJXMAbm8gc3VjaCBpbmRleDogJXMAbm8gc3VjaCB3aW5kb3c6ICVzAGNhbm5vdCBvdmVycmlkZSAlcyBvZiB3aW5kb3c6ICVzAGNhbm5vdCBvcGVuIHZpZXc6ICVzAG5vIHN1Y2ggc2F2ZXBvaW50OiAlcwBjYW5ub3Qgb3BlbiB0YWJsZSB3aXRoIGdlbmVyYXRlZCBjb2x1bW5zOiAlcwBubyBzdWNoIHZmczogJXMAbXVsdGlwbGUgcmVjdXJzaXZlIHJlZmVyZW5jZXM6ICVzAGVycm9yIGluICVzICVzJXMlczogJXMAZnRzNTogZXJyb3IgY3JlYXRpbmcgc2hhZG93IHRhYmxlICVxXyVzOiAlcwB1bmFibGUgdG8gdmFsaWRhdGUgdGhlIGludmVydGVkIGluZGV4IGZvciBGVFM1IHRhYmxlICVzLiVzOiAlcwBlcnJvciBpbiAlcyAlcyBhZnRlciAlczogJXMAbm8gc3VjaCB0b2tlbml6ZXI6ICVzAHVucmVjb2duaXplZCBjb2x1bW4gb3B0aW9uOiAlcwBwYXJzZSBlcnJvciBpbiByYW5rIGZ1bmN0aW9uOiAlcwBubyBzdWNoIGZ1bmN0aW9uOiAlcwBubyBzdWNoIGNvbHVtbjogJXMAZmlsZSByZW5hbWVkIHdoaWxlIG9wZW46ICVzAGZpbGUgdW5saW5rZWQgd2hpbGUgb3BlbjogJXMAY2Fubm90IGxpbWl0IFdBTCBzaXplOiAlcwBNSiBkZWxldGU6ICVzAHRhcmdldCBvYmplY3QvYWxpYXMgbWF5IG5vdCBhcHBlYXIgaW4gRlJPTSBjbGF1c2U6ICVzAG9iamVjdCBuYW1lIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2U6ICVzAHVua25vd24gZGF0YWJhc2U6ICVzAHVuYWJsZSB0byBvcGVuIGRhdGFiYXNlOiAlcwBubyBzdWNoIGRhdGFiYXNlOiAlcwB0aGVyZSBpcyBhbHJlYWR5IGFub3RoZXIgdGFibGUgb3IgaW5kZXggd2l0aCB0aGlzIG5hbWU6ICVzAGR1cGxpY2F0ZSBjb2x1bW4gbmFtZTogJXMAcmVzZXJ2ZWQgZnRzNSBjb2x1bW4gbmFtZTogJXMAZHVwbGljYXRlIFdJVEggdGFibGUgbmFtZTogJXMAcmVzZXJ2ZWQgZnRzNSB0YWJsZSBuYW1lOiAlcwBubyBzdWNoIG1vZHVsZTogJXMAbXVsdGlwbGUgbGlua3MgdG8gZmlsZTogJXMAY2Fubm90IG9wZW4gdmlydHVhbCB0YWJsZTogJXMAc3FsaXRlM2NoYW5nZXNldF9hcHBseSgpOiBubyBzdWNoIHRhYmxlOiAlcwBtdWx0aXBsZSByZWZlcmVuY2VzIHRvIHJlY3Vyc2l2ZSB0YWJsZTogJXMAJXMgYSBzdWJzZXQgb2YgY29sdW1ucyBvbiBmdHM1IGNvbnRlbnRsZXNzLWRlbGV0ZSB0YWJsZTogJXMAJXMgY29udGVudGxlc3MgZnRzNSB0YWJsZTogJXMAY2Fubm90IERFTEVURSBmcm9tIGNvbnRlbnRsZXNzIGZ0czUgdGFibGU6ICVzAG5vIHN1Y2ggJXMgbW9kZTogJXMATUogY29sbGlkZTogJXMAbm8gc3VjaCBjb2xsYXRpb24gc2VxdWVuY2U6ICVzAGNpcmN1bGFyIHJlZmVyZW5jZTogJXMAY2Fubm90IG9wZW4gdGFibGUgd2l0aG91dCByb3dpZDogJXMAJXMgbW9kZSBub3QgYWxsb3dlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGZhaWxlZDogJXMAYXV0b21hdGljIGV4dGVuc2lvbiBsb2FkaW5nIGZhaWxlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGRpZCBub3QgZGVjbGFyZSBzY2hlbWE6ICVzAGFib3J0IGF0ICVkIGluIFslc106ICVzAC0tICVzACV6IC0gJXMAb3NfdW5peC5jOiVkOiAoJWQpICVzKCVzKSAtICVzAFNFTEVDVCByb3dpZCwgcmFuayBGUk9NICVRLiVRIE9SREVSIEJZICVzKCIldyIlcyVzKSAlcwB3cgBpbnN0cgBjc3RyAHN1YnN0cgBmdHM1X2FwaV9wdHIAaWR4U3RyAG5lZWRUb0ZyZWVJZHhTdHIAZXhwcl9pbXBsaWVzX2V4cHIAZXJyb3IgaW4gdG9rZW5pemVyIGNvbnN0cnVjdG9yAHRoZSAiLiIgb3BlcmF0b3IAbmVhciAiJVQiOiBzeW50YXggZXJyb3IAaW50ZXJuYWwgcXVlcnkgcGxhbm5lciBlcnJvcgB1bmtub3duIGVycm9yAG5vdCBhbiBlcnJvcgBTUUwgbG9naWMgZXJyb3IAZGlzayBJL08gZXJyb3IAeEdldExhc3RFcnJvcgB4RGxFcnJvcgBmbG9vcgBybWRpcgBta2RpcgBwb3dlcgBsb3dlcgBzcWxpdGVfdGVtcF9tYXN0ZXIAc3FsaXRlX21hc3RlcgBwb3J0ZXIAUmVzZXRTb3J0ZXIARmtDb3VudGVyAHN0bXQtcG9pbnRlcgBBUEkgY2FsbCB3aXRoICVzIGRhdGFiYXNlIGNvbm5lY3Rpb24gcG9pbnRlcgB4RmlsdGVyAFZGaWx0ZXIARVNDQVBFIGV4cHJlc3Npb24gbXVzdCBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIAdXBwZXIAeFNobUJhcnJpZXIAY2Fubm90IHVzZSBSRVRVUk5JTkcgaW4gYSB0cmlnZ2VyAERyb3BUcmlnZ2VyAHNlY29uZCBhcmd1bWVudCB0byBudGhfdmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAYXJndW1lbnQgb2YgbnRpbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAZnJhbWUgc3RhcnRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBmcmFtZSBlbmRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBJbnRlZ2VyAFJvd2lkICVsbGQgb3V0IG9mIG9yZGVyAFJlbWFpbmRlcgBmcmFtZSBzdGFydGluZyBvZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIAZnJhbWUgZW5kaW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcgBiYWQgcGFnZSBudW1iZXIAYWRkcgBjaGFyAHllYXIAQ2xlYXIAQml0T3IAc2VxAENvbGxTZXEARWxzZUVxACVxAHJlZ2V4cABPcGVuRHVwAE5vb3AAU0FWRVBPSU5UIHJlcGxhY2Vfb3AAUkVMRUFTRSByZXBsYWNlX29wAEp1bXAAL3Vzci90bXAAL3Zhci90bXAAdGVtcABjdXJyZW50X3RpbWVzdGFtcABBZ2dTdGVwAHhTbGVlcABtdW5tYXAAeFNobVVubWFwAG1tYXAAbXJlbWFwAHhTaG1NYXAAc3FsaXRlX3JldHVybmluZ18lcAB2dGFiOiVwAGF1dG8AR290bwBpbnRvAGluY3JlbWVudGFsX3ZhY3V1bSBlbmFibGVkIHdpdGggYSBtYXggcm9vdHBhZ2Ugb2YgemVybwBJZk5vdFplcm8ARGVjckp1bXBaZXJvAEZrSWZaZXJvAHNlcW5vAElOU0VSVCBJTlRPIiV3Ii4iJXdfcm93aWQiKHJvd2lkLG5vZGVubylWQUxVRVMoPzEsPzIpT04gQ09ORkxJQ1Qocm93aWQpRE8gVVBEQVRFIFNFVCBub2Rlbm89ZXhjbHVkZWQubm9kZW5vAENSRUFURSBUQUJMRSAiJXciLiIld19yb3dpZCIocm93aWQgSU5URUdFUiBQUklNQVJZIEtFWSxub2Rlbm8AaGVsbG8AaW5kZXhfeGluZm8AdGFibGVfeGluZm8AaW5kZXhfaW5mbwB0YWJsZV9pbmZvAE9wZW5Qc2V1ZG8AeFJvbGxiYWNrVG8ATCogTiogQ28AdW5rbm93bgBmY2hvd24AQmVnaW5TdWJydG4AUmV0dXJuAGpzb24Abm8gcXVlcnkgc29sdXRpb24AaW5kZXggY29ycnVwdGlvbgBkYXRhYmFzZSBjb3JydXB0aW9uAGZyZWUgc3BhY2UgY29ycnVwdGlvbgBqc29uX2Vycm9yX3Bvc2l0aW9uAHVua25vd24gY29sdW1uICIlcyIgaW4gZm9yZWlnbiBrZXkgZGVmaW5pdGlvbgAlcy54QmVzdEluZGV4IG1hbGZ1bmN0aW9uAGF1dGhvcml6ZXIgbWFsZnVuY3Rpb24AJSNUKCkgbWF5IG5vdCBiZSB1c2VkIGFzIGEgd2luZG93IGZ1bmN0aW9uACclcycgaXMgbm90IGEgZnVuY3Rpb24AeEZpbmRGdW5jdGlvbgBmYWlsZWQgdG8gb3BlbiB0cmFuc2FjdGlvbgBjYW5ub3Qgc3RhcnQgYSB0cmFuc2FjdGlvbiB3aXRoaW4gYSB0cmFuc2FjdGlvbgBjYW5ub3QgY2hhbmdlICVzIHdhbCBtb2RlIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AdGVtcG9yYXJ5IHN0b3JhZ2UgY2Fubm90IGJlIGNoYW5nZWQgZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgBjYW5ub3QgVkFDVVVNIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AU2FmZXR5IGxldmVsIG1heSBub3QgYmUgY2hhbmdlZCBpbnNpZGUgYSB0cmFuc2FjdGlvbgBUcmFuc2FjdGlvbgBpemF0aW9uAFBlcm11dGF0aW9uAHVua25vd24gb3BlcmF0aW9uAHVuc3VwcG9ydGVkIGZyYW1lIHNwZWNpZmljYXRpb24Ac2Vzc2lvbgBSQU5HRSB3aXRoIG9mZnNldCBQUkVDRURJTkcvRk9MTE9XSU5HIHJlcXVpcmVzIG9uZSBPUkRFUiBCWSBleHByZXNzaW9uAHRvbyBtYW55IGxldmVscyBvZiB0cmlnZ2VyIHJlY3Vyc2lvbgB1c2VyX3ZlcnNpb24Ac3FsaXRlX3ZlcnNpb24AUFJBR01BICVRLmRhdGFfdmVyc2lvbgBzY2hlbWFfdmVyc2lvbgBpVmVyc2lvbgBzcWxpdGVfZHJvcF9jb2x1bW4Ac3FsaXRlX3JlbmFtZV9jb2x1bW4AYWZ0ZXIgZHJvcCBjb2x1bW4Abm8gc3VjaCBjb2x1bW4AbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub24tZ2VuZXJhdGVkIGNvbHVtbgBjYW5ub3QgdXNlIERFRkFVTFQgb24gYSBnZW5lcmF0ZWQgY29sdW1uAGFkZCBjb2x1bW4AQ2Fubm90IGFkZCBhIFBSSU1BUlkgS0VZIGNvbHVtbgBDYW5ub3QgYWRkIGEgVU5JUVVFIGNvbHVtbgBjYW5ub3QgYWRkIGEgU1RPUkVEIGNvbHVtbgB4Q29sdW1uAGlDb2x1bW4AVkNvbHVtbgBsbgBidWlsdGluAGFzaW4AYXQgbW9zdCAlZCB0YWJsZXMgaW4gYSBqb2luAG1pbgAsb3JpZ2luAHhCZWdpbgBWQmVnaW4AbWFpbgBleHBsYWluAEV4cGxhaW4Ac2lnbgBvcGVuAHhPcGVuAElmTm90T3BlbgBTb3J0ZXJPcGVuAHhEbE9wZW4AVk9wZW4AZnRzNV9pbnN0dG9rZW4ASWZTaXplQmV0d2VlbgBoaWRkZW4AYXRhbgBuYW4AU2Vla1NjYW4AVkluaXRJbgB4RGxTeW0AYXV0b192YWN1dW0AaW5jcmVtZW50YWxfdmFjdXVtAEluY3JWYWN1dW0Ac3VtAGZsZXhudW0AaWR4TnVtAGFsaXNtAHBtAGRyb3AgY29sdW1uIGZyb20AL2Rldi91cmFuZG9tAEFkZEltbQBydHJpbQBsdHJpbQByZWFkb25seV9zaG0AJXMtc2htAFJBSVNFKCkgbWF5IG9ubHkgYmUgdXNlZCB3aXRoaW4gYSB0cmlnZ2VyLXByb2dyYW0AUHJvZ3JhbQB0cmlncmFtAFBhcmFtAGZ1bABmY250bABpb2N0bAB4RmlsZUNvbnRyb2wAbG9ja2luZyBwcm90b2NvbABuY29sAGpybmwAbm90bnVsbABpZm51bGwAL2Rldi9udWxsAGRhdGFiYXNlIG9yIGRpc2sgaXMgZnVsbABOb3ROdWxsAFNvZnROdWxsAElzTnVsbABaZXJvT3JOdWxsAEhhbHRJZk51bGwAY29sbABjYWNoZV9zcGlsbABSb3dDZWxsAHhOZXh0U3lzdGVtQ2FsbAB4U2V0U3lzdGVtQ2FsbAB4R2V0U3lzdGVtQ2FsbABkZWxldGUtYWxsAGNlaWwAZGV0YWlsAHVuaXgtZXhjbAB0YmwAd2FsAHZpcnR1YWwAdG90YWwAaW5jcmVtZW50YWwAT3BlbkVwaGVtZXJhbABzZXNzaW9uLWpvdXJuYWwAbG9jYWwtam91cm5hbABpbnRlcm5hbABhdGlvbmFsAEFnZ0ZpbmFsAG5vcm1hbABwYXJ0aWFsAHJlYWwAUmVhbABsb2NhbABwawBvawB1bmxpbmsAcmVhZGxpbmsARmluaXNoU2VlawBEZWZlcnJlZFNlZWsAbm9sb2NrAHhVbmxvY2sAQ3Vyc29yVW5sb2NrAGJsb2NrACVzLmxvY2sAeExvY2sAQ3Vyc29yTG9jawB4U2htTG9jawBUYWJsZUxvY2sAeENoZWNrUmVzZXJ2ZWRMb2NrAHJ0cmVlY2hlY2sAaW50ZWdyaXR5X2NoZWNrAGZvcmVpZ25fa2V5X2NoZWNrAHF1aWNrX2NoZWNrAGNlbGxfc2l6ZV9jaGVjawBpbnRlZ3JpdHktY2hlY2sARmtDaGVjawBUeXBlQ2hlY2sAVkNoZWNrAHhSb2xsYmFjawBJbnRlZ3JpdHlDawBqAGl2aXRpAGJpbGl0aQBhbGl0aQBpY2l0aQBpc3Npc2kAaXNpc2kAcGkAZW50bGkAb3VzbGkAZWxpAGJsaQBzaXNzaWkAaXNzaXNpaQBzc3NpaWkAYXNjaWkAcnRyZWVkZXB0aABtb250aABqc29uX2FycmF5X2xlbmd0aABvY3RldF9sZW5ndGgAb3ZlcmZsb3cgbGlzdCBsZW5ndGgAd2R0aABzdGF0X3B1c2gAZmx1c2gAYWNvc2gAYXNpbmgAYXRhbmgAeFVuZmV0Y2gAeEZldGNoAGpzb25fcGF0Y2gAanNvbmJfcGF0Y2gAZGF0YXR5cGUgbWlzbWF0Y2gAdGFibGUgc2NoZW1hcyBkbyBub3QgbWF0Y2gAYWJicmV2aWF0ZWQgcXVlcnkgYWxnb3JpdGhtIHNlYXJjaAB1bml4ZXBvY2gAc3FsaXRlX2F0dGFjaABzcWxpdGVfZGV0YWNoAGpzb25fZWFjaABhdmcAekVyck1zZwBuYXJnAFJ0cmVlTWF0Y2hBcmcAc3FsaXRlX2xvZwBzdGF0ZW1lbnQgdG9vIGxvbmcAY2Fubm90IG9wZW4gJXMgY29sdW1uIGZvciB3cml0aW5nAHN1YnN0cmluZwB1bnRlcm1pbmF0ZWQgc3RyaW5nAFN0cmluZwAlczogdGFibGUgZG9lcyBub3Qgc3VwcG9ydCBzY2FubmluZwBjZWlsaW5nAGNvbmZpZwBzdHJpbmcgb3IgYmxvYiB0b28gYmlnAHN0cmluZ19hZ2cAUmVsZWFzZVJlZwAlLjE2ZwAlITAuMTVnACUhLjE1ZwAgJWcAcHJpbnRmAHR5cGVvZgBtb2Rlb2YAeEVvZgBvdXQgb2YAcmVuYW1lIGNvbHVtbnMgb2YAaW5mAC1JbmYAbnVsbGlmAGlpZgBvZmYAdGltZWRpZmYAMDEyMzQ1Njc4OWFiY2RlZgBuUmVmAGxlYWYASWYAJWMlMDRkLSUwMmQtJTAyZCAlMDJkOiUwMmQ6JTA2LjNmACUuM2YANTBmADQwZgAlIS4qZgBjb2x1bW5zaXplAGhhc2hzaXplAGdldHBhZ2VzaXplAGRvY3NpemUAbW1hcF9zaXplAGNhY2hlX3NpemUAUFJBR01BICVRLnBhZ2Vfc2l6ZQB0b2tlbml6ZQBvcHRpbWl6ZQBhbGl6ZQBuS2V5U2l6ZQB4U2VjdG9yU2l6ZQB4RmlsZVNpemUAanNvbl9yZW1vdmUAanNvbmJfcmVtb3ZlAE1vdmUAY2FzZV9zZW5zaXRpdmUAcGFyc2UgZXJyb3IgaW4gdG9rZW5pemUgZGlyZWN0aXZlAG1hbGZvcm1lZCBwcmVmaXg9Li4uIGRpcmVjdGl2ZQBtYWxmb3JtZWQgZGV0YWlsPS4uLiBkaXJlY3RpdmUAbWFsZm9ybWVkIGNvbHVtbnNpemU9Li4uIGRpcmVjdGl2ZQBtYWxmb3JtZWQgY29udGVudGxlc3NfZGVsZXRlPS4uLiBkaXJlY3RpdmUAbWFsZm9ybWVkIGxvY2FsZT0uLi4gZGlyZWN0aXZlAG1hbGZvcm1lZCB0b2tlbmRhdGE9Li4uIGRpcmVjdGl2ZQBjYW5ub3QgY29tbWl0IC0gbm8gdHJhbnNhY3Rpb24gaXMgYWN0aXZlAGNhbm5vdCByb2xsYmFjayAtIG5vIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZQBhdGl2ZQBleGNsdXNpdmUAdHJ1ZQBJc1RydWUAdW5pcXVlAGRmbHRfdmFsdWUAQ2Fubm90IGFkZCBhIFJFRkVSRU5DRVMgY29sdW1uIHdpdGggbm9uLU5VTEwgZGVmYXVsdCB2YWx1ZQBiYWQgcGFnZSB2YWx1ZQBBZ2dWYWx1ZQBqc29uX3F1b3RlAHB3cml0ZQB4V3JpdGUAT3BlbldyaXRlAGNvbnRlbnRsZXNzX2RlbGV0ZQBvbl9kZWxldGUAc2VjdXJlX2RlbGV0ZQBzZWN1cmUtZGVsZXRlAGNhbm5vdCBkZWxldGUASWR4RGVsZXRlAHByaXZhdGUAYWdncmVnYXRlAGNyZWF0ZQB4Q3JlYXRlAFZDcmVhdGUAb25fdXBkYXRlAHhVcGRhdGUAVlVwZGF0ZQBjdXJyZW50X2RhdGUAZmFsbG9jYXRlAGZ0cnVuY2F0ZQB4VHJ1bmNhdGUAaWNhdGUAYmFkIHBhcmFtZXRlciBvciBvdGhlciBBUEkgbWlzdXNlAHRvbyBtYW55IHRlcm1zIGluICVzIEJZIGNsYXVzZQB0b28gbWFueSB0ZXJtcyBpbiBPUkRFUiBCWSBjbGF1c2UAYWdncmVnYXRlIGZ1bmN0aW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gdGhlIEdST1VQIEJZIGNsYXVzZQBQQVJUSVRJT04gY2xhdXNlAGEgTkFUVVJBTCBqb2luIG1heSBub3QgaGF2ZSBhbiBPTiBvciBVU0lORyBjbGF1c2UAZGF0YWJhc2UgJXMgaXMgYWxyZWFkeSBpbiB1c2UAQWdnSW52ZXJzZQBjbG9zZQB4Q2xvc2UAeERsQ2xvc2UAZmFsc2UAcGhyYXNlAHhSZWxlYXNlAGF0dGVtcHQgdG8gd3JpdGUgYSByZWFkb25seSBkYXRhYmFzZQBjb3JydXB0IGRhdGFiYXNlAGF0dGFjaGVkIGRhdGFiYXNlcyBtdXN0IHVzZSB0aGUgc2FtZSB0ZXh0IGVuY29kaW5nIGFzIG1haW4gZGF0YWJhc2UATm9kZSAlbGxkIG1pc3NpbmcgZnJvbSBkYXRhYmFzZQBmaWxlIGlzIG5vdCBhIGRhdGFiYXNlAHRlbXBfc3RvcmUAc3FsaXRlM2NoYW5nZXNldF9hcHBseSgpOiB0YWJsZSAlcyBoYXMgJWQgY29sdW1ucywgZXhwZWN0ZWQgJWQgb3IgbW9yZQAlcyBjbGF1c2Ugc2hvdWxkIGNvbWUgYWZ0ZXIgJXMgbm90IGJlZm9yZQBFeHBpcmUAZXhwcl9jb21wYXJlAFNvcnRlckNvbXBhcmUAc3VidHlwZQBTZXRTdWJ0eXBlAEdldFN1YnR5cGUAQ2xyU3VidHlwZQBqc29uX3R5cGUASXNUeXBlAElmTm9Ib3BlAHVuaXgtbm9uZQBJbml0Q29yb3V0aW5lAEVuZENvcm91dGluZQBsb2NhbHRpbWUAc3RyZnRpbWUAZGF0ZXRpbWUAY3VycmVudF90aW1lAHhDdXJyZW50VGltZQBteFBhdGhuYW1lAHhGdWxsUGF0aG5hbWUAYWZ0ZXIgcmVuYW1lAG5vbi10ZXh0IGZpbGVuYW1lAHhSZW5hbWUAVlJlbmFtZQBhbWJpZ3VvdXMgY29sdW1uIG5hbWUAdGVtcG9yYXJ5IHRyaWdnZXIgbWF5IG5vdCBoYXZlIHF1YWxpZmllZCBuYW1lACBPUkRFUiBCWSBuYW1lAHpOYW1lAHhTaGFkb3dOYW1lAHBNb2R1bGUAdW5peC1kb3RmaWxlAGNhbm5vdCBvcGVuIGZpbGUAdW5hYmxlIHRvIG9wZW4gZGF0YWJhc2UgZmlsZQBzek9zRmlsZQBpbW11dGFibGUAQWJvcnRhYmxlAGxlZ2FjeV9hbHRlcl90YWJsZQBzcWxpdGVfcmVuYW1lX3RhYmxlAHJlY3Vyc2l2ZWx5IGRlZmluZWQgZnRzNSBjb250ZW50IHRhYmxlAGNvbnRlbnRsZXNzX2RlbGV0ZT0xIHJlcXVpcmVzIGEgY29udGVudGxlc3MgdGFibGUAY29udGVudGxlc3NfdW5pbmRleGVkPTEgcmVxdWlyZXMgYSBjb250ZW50bGVzcyB0YWJsZQBNYXBwaW5nICglbGxkIC0+ICVsbGQpIG1pc3NpbmcgZnJvbSAlcyB0YWJsZQBjYW5ub3QgY3JlYXRlIHRyaWdnZXIgb24gc3lzdGVtIHRhYmxlAHZpcnR1YWwgdGFibGUAbm8gc3VjaCB0YWJsZQBUb28gbWFueSBjb2x1bW5zIGZvciBhbiBydHJlZSB0YWJsZQBUb28gZmV3IGNvbHVtbnMgZm9yIGFuIHJ0cmVlIHRhYmxlAFdyb25nIG51bWJlciBvZiBjb2x1bW5zIGZvciBhbiBydHJlZSB0YWJsZQBudW1iZXIgb2YgY29sdW1ucyBpbiBmb3JlaWduIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHJlZmVyZW5jZWQgdGFibGUAJ2RlbGV0ZS1hbGwnIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBhIGNvbnRlbnRsZXNzIG9yIGV4dGVybmFsIGNvbnRlbnQgZnRzNSB0YWJsZQAncmVidWlsZCcgbWF5IG5vdCBiZSB1c2VkIHdpdGggYSBjb250ZW50bGVzcyBmdHM1IHRhYmxlACdkZWxldGUnIG1heSBub3QgYmUgdXNlZCB3aXRoIGEgY29udGVudGxlc3NfZGVsZXRlPTEgdGFibGUAdXNhYmxlAGxvY2FsIHRpbWUgdW5hdmFpbGFibGUAYW5vdGhlciByb3cgYXZhaWxhYmxlAG5vIG1vcmUgcm93cyBhdmFpbGFibGUAVmFyaWFibGUARHJvcFRhYmxlAGZ0czVfZ2V0X2xvY2FsZQBmdHM1X2xvY2FsZQB1dGYxNmxlAGNhc2Vfc2Vuc2l0aXZlX2xpa2UAU2V0Q29va2llAFJlYWRDb29raWUAY2FjaGUAY3Jpc2lzbWVyZ2UAdXNlcm1lcmdlAGF1dG9tZXJnZQBkZWxldGVtZXJnZQBjb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlAG5vdGlmaWNhdGlvbiBtZXNzYWdlAHdhcm5pbmcgbWVzc2FnZQBhQ29uc3RyYWludFVzYWdlAGludmFsaWQgcm9vdHBhZ2UAc3FsaXRlX2RicGFnZQBFeHRlbmRzIG9mZiBlbmQgb2YgcGFnZQBNQVhfUEFHRV9DT1VOVD0weGZmZmZmZmZlAFNjaGVtYSBjb3JydXB0IG9yIG5vdCBhbiBydHJlZQBqc29uX3RyZWUAQ3JlYXRlQnRyZWUAcnRyZWVub2RlAF9ub2RlAGpvdXJuYWxfbW9kZQBsb2NraW5nX21vZGUAb3Bjb2RlAHVuaWNvZGUAYnl0ZWNvZGUASm91cm5hbE1vZGUARGl2aWRlAGNvYWxlc2NlAHNxbGl0ZV9zZXF1ZW5jZQBTZXF1ZW5jZQBpbnN0YW5jZQBPbmNlAFRyYWNlAGpzb25fcmVwbGFjZQBqc29uYl9yZXBsYWNlAHV0ZjE2YmUATmUATGUAR2UAMjBjOjIwZQAyMGI6MjBlACUhMC4yMGUAZ2V0Y3dkAE1ha2VSZWNvcmQAdGhzdG5kcmQAbGlrZWxpaG9vZABmY2htb2QAcm91bmQATm90Rm91bmQAc3Vic2Vjb25kAFJld2luZABlbmQAU2Vla0VuZABCaXRBbmQAb2xkAHslbGxkAFdyb25nIG51bWJlciBvZiBlbnRyaWVzIGluICUlJXMgdGFibGUgLSBleHBlY3RlZCAlbGxkLCBhY3R1YWwgJWxsZABubyBzdWNoIGN1cnNvcjogJWxsZABubyBzdWNoIHJvd2lkOiAlbGxkACwiU1FMSVRFX1dBU01fREVBTExPQyI6ICVsbGQAcmVidWlsZABZaWVsZABsYXN0X2luc2VydF9yb3dpZABjb250ZW50X3Jvd2lkACVfcm93aWQAJXMucm93aWQAU0VMRUNUKkZST00iJXciLiVzIE9SREVSIEJZIHJvd2lkAFNFTEVDVCpGUk9NIiV3Ii4lcyBXSEVSRSAlcyBPUkRFUiBCWSByb3dpZABJZHhSb3dpZABOZXdSb3dpZABTZWVrUm93aWQAZ2V0ZXVpZABpbnZhbGlkAGpzb25fdmFsaWQAZmtpZABjaWQAYXBwbGljYXRpb25faWQAc3FsaXRlX3NvdXJjZV9pZABmdHM1X3NvdXJjZV9pZABub3QgYXV0aG9yaXplZABjb250ZW50bGVzc191bmluZGV4ZWQAdW5hYmxlIHRvIGlkZW50aWZ5IHRoZSBvYmplY3QgdG8gYmUgcmVpbmRleGVkAHZpZXdzIG1heSBub3QgYmUgaW5kZXhlZAB2aXJ0dWFsIHRhYmxlcyBtYXkgbm90IGJlIGluZGV4ZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBpbmRleGVkAHJlYWRfdW5jb21taXR0ZWQAcmVjdXJzaXZlIGFnZ3JlZ2F0ZSBxdWVyaWVzIG5vdCBzdXBwb3J0ZWQAcXVlcnkgYWJvcnRlZAByb3dzIGluc2VydGVkAGNvcnJ1cHRlZABpbnRlcnJ1cHRlZABjaGVja3BvaW50ZWQAYWNjZXNzIHRvICV6IGlzIHByb2hpYml0ZWQAYWNjZXNzIHRvIHZpZXcgIiVzIiBwcm9oaWJpdGVkAHJvd3MgZGVsZXRlZABnZW5lcmF0ZWQAcm93cyB1cGRhdGVkAG5vdHVzZWQAcm93IHZhbHVlIG1pc3VzZWQAdGFibGVzX3VzZWQAc3FsaXRlX2NvbXBpbGVvcHRpb25fdXNlZABQYWdlICV1OiBuZXZlciB1c2VkAENvbHVtbnNVc2VkAGNvbFVzZWQAc3RvcmVkAHZpcnR1YWwgdGFibGVzIG1heSBub3QgYmUgYWx0ZXJlZAB2aWV3ICVzIG1heSBub3QgYmUgYWx0ZXJlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGFsdGVyZWQAc2hhcmVkAGluZGV4IGFzc29jaWF0ZWQgd2l0aCBVTklRVUUgb3IgUFJJTUFSWSBLRVkgY29uc3RyYWludCBjYW5ub3QgYmUgZHJvcHBlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGRyb3BwZWQAdmlldyAlcyBpcyBjaXJjdWxhcmx5IGRlZmluZWQAdW5vcGVuZWQAb3JkZXJCeUNvbnN1bWVkAGRhdGFiYXNlIGRpc2sgaW1hZ2UgaXMgbWFsZm9ybWVkACVzIGNvbnN0cmFpbnQgZmFpbGVkAEZPUkVJR04gS0VZIGNvbnN0cmFpbnQgZmFpbGVkAGRhdGFiYXNlICVzIGlzIGxvY2tlZABkYXRhYmFzZSBpcyBsb2NrZWQAZGF0YWJhc2UgdGFibGUgaXMgbG9ja2VkAGF1dGhvcml6YXRpb24gZGVuaWVkAGFjY2VzcyBwZXJtaXNzaW9uIGRlbmllZAB0YWJsZSAlUyBoYXMgJWQgY29sdW1ucyBidXQgJWQgdmFsdWVzIHdlcmUgc3VwcGxpZWQAdGVtcG9yYXJ5IHRhYmxlIG5hbWUgbXVzdCBiZSB1bnF1YWxpZmllZAB0YWJsZSAlcyBtYXkgbm90IGJlIG1vZGlmaWVkAGNvbmZsaWN0aW5nIE9OIENPTkZMSUNUIGNsYXVzZXMgc3BlY2lmaWVkAG5vIHRhYmxlcyBzcGVjaWZpZWQAZGF0YWJhc2UgaXMgYWxyZWFkeSBhdHRhY2hlZABkYXRhYmFzZSBzY2hlbWEgaGFzIGNoYW5nZWQAZWVkAGV4Y2x1ZGVkAFBhZ2UgJXU6IHBvaW50ZXIgbWFwIHJlZmVyZW5jZWQAUm93U2V0QWRkAEZpbHRlckFkZABwcmVhZAB4UmVhZABSb3dTZXRSZWFkAE9wZW5SZWFkACUwNGQAJTAzZAAlMDJkOiUwMmQ6JTAyZAAlMDRkLSUwMmQtJTAyZAAlMmQANDBmLTIxYS0yMWQANTBmLTIwYS0yMGQANDBmLTIwYS0yMGQAc3FsaXRlX3N0YXQlZABjb2x1bW4lZAAsIFQubCVkACwgbCVkACwgVC5jJWQALCBjJWQALGElZABzcWxpdGVfYXV0b2luZGV4XyVzXyVkACV6JXM/JWQAYSVkPT8lZAAleiw/JWQAdmFyaWFibGUgbnVtYmVyIG11c3QgYmUgYmV0d2VlbiA/MSBhbmQgPyVkAHVuYWJsZSB0byBnZXQgdGhlIHBhZ2UuIGVycm9yIGNvZGU9JWQAayglZABVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgcm9vdHBhZ2U9JWQgV0hFUkUgIyVkIEFORCByb290cGFnZT0jJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHR5cGU9JyVzJywgbmFtZT0lUSwgdGJsX25hbWU9JVEsIHJvb3RwYWdlPSMlZCwgc3FsPSVRIFdIRVJFIHJvd2lkPSMlZABVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgdHlwZT0ndGFibGUnLCBuYW1lPSVRLCB0YmxfbmFtZT0lUSwgcm9vdHBhZ2U9MCwgc3FsPSVRIFdIRVJFIHJvd2lkPSMlZAB0b28gbWFueSBhdHRhY2hlZCBkYXRhYmFzZXMgLSBtYXggJWQAdG9vIG1hbnkgYXJndW1lbnRzIG9uICVzKCkgLSBtYXggJWQAZXhwZWN0ZWQgJWQgY29sdW1ucyBmb3IgJyVzJyBidXQgZ290ICVkAGF0dGVtcHQgdG8gb3BlbiAiJXMiIGFzIGZpbGUgZGVzY3JpcHRvciAlZABidHJlZUluaXRQYWdlKCkgcmV0dXJucyBlcnJvciBjb2RlICVkACVyICVzIEJZIHRlcm0gb3V0IG9mIHJhbmdlIC0gc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgJWQAc3ViLXNlbGVjdCByZXR1cm5zICVkIGNvbHVtbnMgLSBleHBlY3RlZCAlZABJTiguLi4pIGVsZW1lbnQgaGFzICVkIHRlcm0lcyAtIGV4cGVjdGVkICVkACVzTElTVCBTVUJRVUVSWSAlZABSRVVTRSBMSVNUIFNVQlFVRVJZICVkACVzU0NBTEFSIFNVQlFVRVJZICVkAFJFVVNFIFNVQlFVRVJZICVkAElOREVYICVkAHRvbyBtYW55IEZST00gY2xhdXNlIHRlcm1zLCBtYXg6ICVkACVzIiVzIjogJWQAInNpemVvZiI6ICVkAHJ3YwB1dGMAZGVzYwBjaGVja3BvaW50X2Z1bGxmc3luYwBmdWxsX2ZzeW5jAHhTeW5jAHRydW5jAHhGdW5jAFB1cmVGdW5jAGVuYwBudW1lcmljAFNxbEV4ZWMAc3Vic2VjACUuNGMlcyUuMTZjAGFwaS9zcWxpdGUzLXdhc20uYwAlcy9ldGlscXNfJWxseCVjAHdiAEdvc3ViAHJiAGdsb2IAemVyb2Jsb2IAcmFuZG9tYmxvYgBCbG9iAGpzb25iAG1lbWRiAHBWdGFiAGZ0czV2b2NhYgByd2EAdG9rZW5kYXRhACVzX2RhdGEAUm93RGF0YQBTb3J0ZXJEYXRhAHBBcHBEYXRhAHNxbGl0ZV90ZW1wX3NjaGVtYQBzcWxpdGVfc2NoZW1hAHdyaXRhYmxlX3NjaGVtYQB0cnVzdGVkX3NjaGVtYQBjb3JydXB0IHNjaGVtYQBubyBzdWNoIHNjaGVtYQBQYXJzZVNjaGVtYQBzcWxpdGVfAHByYWdtYV8AU1FMSVRFXwBfUk9XSURfACVzIGF0IGxpbmUgJWQgb2YgWyUuMTBzXQBiaW5kIG9uIGEgYnVzeSBwcmVwYXJlZCBzdGF0ZW1lbnQ6IFslc10AWyVsbGRdAFtdACwgInN0cnVjdHMiOiBbAFNRTElURV9DT05GSUdfUENBQ0hFX0hEUlNaAFNRTElURV9DT05GSUdfUE1BU1oAU1FMSVRFX0VNUFRZAFNRTElURV9CVVNZAFNRTElURV9GQ05UTF9XSU4zMl9BVl9SRVRSWQBTUUxJVEVfRVJST1JfUkVUUlkAU1FMSVRFX1JFQURPTkxZX0RJUkVDVE9SWQBTUUxJVEVfT1BFTl9NRU1PUlkAU1FMSVRFX0JVU1lfUkVDT1ZFUlkAU1FMSVRFX1JFQURPTkxZX1JFQ09WRVJZAExFRlQtTU9TVCBTVUJRVUVSWQBDT01QT1VORCBRVUVSWQBTUUxJVEVfU0VSSUFMSVpFX05PQ09QWQBTUUxJVEVfREVOWQBBTlkAU1FMSVRFX09LX0xPQURfUEVSTUFORU5UTFkAU1FMSVRFX0RJUkVDVE9OTFkAU1FMSVRFX1ZUQUJfRElSRUNUT05MWQBTUUxJVEVfT1BFTl9SRUFET05MWQBTUUxJVEVfREVTRVJJQUxJWkVfUkVBRE9OTFkAU1FMSVRFX1JFQURPTkxZAFNRTElURV9TWU5DX0RBVEFPTkxZAFNRTElURV9DSEFOR0VTRVRfRk9SRUlHTl9LRVkAU1FMSVRFX0NPTlNUUkFJTlRfUFJJTUFSWUtFWQBTUUxJVEVfQ09OU1RSQUlOVF9GT1JFSUdOS0VZAFNRTElURV9EQkNPTkZJR19FTkFCTEVfRktFWQBnZW5lcmF0ZWQgY29sdW1ucyBjYW5ub3QgYmUgcGFydCBvZiB0aGUgUFJJTUFSWSBLRVkAQVVUT0lOQ1JFTUVOVCBpcyBvbmx5IGFsbG93ZWQgb24gYW4gSU5URUdFUiBQUklNQVJZIEtFWQBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZAEZPUkVJR04gS0VZAFVTRSBURU1QIEItVFJFRSBGT1IgJXNPUkRFUiBCWQBVU0UgVEVNUCBCLVRSRUUgRk9SIExBU1QgJWQgVEVSTVMgT0YgT1JERVIgQlkAR1JPVVAgQlkAaWlzWABpc2lYAFNRTElURV9DT05GSUdfTVVURVgAU1FMSVRFX0NPTkZJR19HRVRNVVRFWABTUUxJVEVfT1BFTl9OT01VVEVYAFNRTElURV9PUEVOX0ZVTExNVVRFWABTUUxJVEVfQ09SUlVQVF9JTkRFWABTUUxJVEVfRFJPUF9JTkRFWABTUUxJVEVfRFJPUF9URU1QX0lOREVYAFNRTElURV9DUkVBVEVfVEVNUF9JTkRFWABTUUxJVEVfQ1JFQVRFX0lOREVYAFNRTElURV9TVE1UU1RBVFVTX0FVVE9JTkRFWABTUUxJVEVfV0FSTklOR19BVVRPSU5ERVgAU1FMSVRFX1JFSU5ERVgAQVVUT01BVElDIFBBUlRJQUwgQ09WRVJJTkcgSU5ERVgAQVVUT01BVElDIENPVkVSSU5HIElOREVYAFNRTElURV9EQlNUQVRVU19NQVgAU1FMSVRFX0RCQ09ORklHX01BWAAtbWolMDZYOSUwMlgAU1FMSVRFX1JPVwBTUUxJVEVfVFJBQ0VfUk9XAFNDQU4gQ09OU1RBTlQgUk9XAFNRTElURV9PUEVOX05PRk9MTE9XAFNRTElURV9TVEFUVVNfUEFHRUNBQ0hFX09WRVJGTE9XAFNRTElURV9EUk9QX1ZJRVcAU1FMSVRFX0RST1BfVEVNUF9WSUVXAFNRTElURV9DUkVBVEVfVEVNUF9WSUVXAFNRTElURV9DUkVBVEVfVklFVwBTUUxJVEVfREJDT05GSUdfRU5BQkxFX1ZJRVcAcHBWAFNRTElURV9GQ05UTF9SQlUAU1FMSVRFX1RFWFQAanNvbl9vYmplY3QoKSBsYWJlbHMgbXVzdCBiZSBURVhUAFNRTElURV9CVVNZX1RJTUVPVVQAU1FMSVRFX0ZDTlRMX0xPQ0tfVElNRU9VVABGSVJTVABMQVNUAFNRTElURV9TVE1UU1RBVFVTX1NPUlQAU1FMSVRFX1ZUQUJfQ09OU1RSQUlOVF9TVVBQT1JUAFNRTElURV9DSEFOR0VTRVRfQUJPUlQAU1FMSVRFX0FCT1JUAFNRTElURV9DSEFOR0VTRVRBUFBMWV9JTlZFUlQAU1FMSVRFX0NIQU5HRVNFVFNUQVJUX0lOVkVSVABTUUxJVEVfSU5TRVJUAFNRTElURV9GQ05UTF9DS1BUX1NUQVJUAFNRTElURV9DT1JSVVBUAFNRTElURV9JTlRFUlJVUFQARVhDRVBUAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0lTTk9UAFNRTElURV9CVVNZX1NOQVBTSE9UAFNRTElURV9FUlJPUl9TTkFQU0hPVABTUUxJVEVfU1RBVFVTX01BTExPQ19DT1VOVABTUUxJVEVfU0FWRVBPSU5UAFNRTElURV9DSEFOR0VTRVRBUFBMWV9OT1NBVkVQT0lOVABTUUxJVEVfRkNOVExfU0laRV9ISU5UAFNRTElURV9DSEFOR0VTRVRfQ09OU1RSQUlOVABTUUxJVEVfQ09OU1RSQUlOVAAsJS4qcyBJTlQAQ1JFQVRFIFRBQkxFIHgoJS4qcyBJTlQAU1FMSVRFX1BSRVBBUkVfUEVSU0lTVEVOVABTUUxJVEVfSU9FUlJfREVMRVRFX05PRU5UAFNRTElURV9UUkFDRV9TVE1UAElkeExUAFNlZWtMVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9MVABTRVQgREVGQVVMVABTUUxJVEVfUkVBRE9OTFlfQ0FOVElOSVQATVVURVhfT01JVABTUUxJVEVfQ0hBTkdFU0VUX09NSVQAQ09NTUlUAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0xJTUlUAFNRTElURV9GQ05UTF9TSVpFX0xJTUlUAFNRTElURV9TVE1UU1RBVFVTX0ZJTFRFUl9ISVQAU1FMSVRFX0RCU1RBVFVTX0NBQ0hFX0hJVABTUUxJVEVfREJTVEFUVVNfTE9PS0FTSURFX0hJVABSSUdIVABJZHhHVABTZWVrR1QAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfR1QATEVGVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9PRkZTRVQARElTVElOQ1QAUkVTVFJJQ1QAU1FMSVRFX0NIQU5HRVNFVF9DT05GTElDVABJTlRFUlNFQ1QAU1FMSVRFX1NFTEVDVABTUUxJVEVfTUFYX0NPTVBPVU5EX1NFTEVDVABTUUxJVEVfTElNSVRfQ09NUE9VTkRfU0VMRUNUAHRvbyBtYW55IHRlcm1zIGluIGNvbXBvdW5kIFNFTEVDVABTUUxJVEVfSU9FUlJfRlNUQVQAU1FMSVRFX0ZMT0FUAFNRTElURV9GT1JNQVQAU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9GSUxFX0ZPUk1BVAB1bmtub3duIGpvaW4gdHlwZTogJVQlcyVUJXMlVAAtJVQAdG9vIG1hbnkgYXJndW1lbnRzIG9uIGZ1bmN0aW9uICVUAHVua25vd24gZGF0YWJhc2UgJVQAZm9yZWlnbiBrZXkgb24gJXMgc2hvdWxkIHJlZmVyZW5jZSBvbmx5IG9uZSBjb2x1bW4gb2YgdGFibGUgJVQAQ1JFQVRFIFZJUlRVQUwgVEFCTEUgJVQAaGV4IGxpdGVyYWwgdG9vIGJpZzogJXMlI1QAbm8gc3VjaCBmdW5jdGlvbjogJSNUAG5vdCBhdXRob3JpemVkIHRvIHVzZSBmdW5jdGlvbjogJSNUAFNFTEVDVCAlcyBGUk9NICVzIEFTIFQAU1FMSVRFX0RCQ09ORklHX1NUTVRfU0NBTlNUQVRVUwBTUUxJVEVfQ09ORklHX01FTVNUQVRVUwBTUUxJVEVfSU5OT0NVT1VTAFNRTElURV9WVEFCX0lOTk9DVU9VUwBTUUxJVEVfQUNDRVNTX0VYSVNUUwBTUUxJVEVfU1RNVFNUQVRVU19GSUxURVJfTUlTUwBTUUxJVEVfREJTVEFUVVNfQ0FDSEVfTUlTUwBTUUxJVEVfSU9FUlJfQUNDRVNTAERFRkFVTFRfUkVDVVJTSVZFX1RSSUdHRVJTAEVOQUJMRV9NQVRIX0ZVTkNUSU9OUwBTUUxJVEVfREJTVEFUVVNfREVGRVJSRURfRktTAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0lTAFNRTElURV9GQ05UTF9aSVBWRlMAU1FMSVRFX0lPRVJSX0NPUlJVUFRGUwBTUUxJVEVfTk9MRlMAU1FMSVRFX0ZDTlRMX1JFU0VSVkVfQllURVMAU1FMSVRFX01BWF9XT1JLRVJfVEhSRUFEUwBTUUxJVEVfTElNSVRfV09SS0VSX1RIUkVBRFMAU1FMSVRFX1ZUQUJfVVNFU19BTExfU0NIRU1BUwAlcyAlUwBTQ0FOICVTAG5vIHN1Y2ggaW5kZXg6ICVTAGNhbm5vdCBjcmVhdGUgJXMgdHJpZ2dlciBvbiB2aWV3OiAlUwBubyBzdWNoIHRyaWdnZXI6ICVTAGNhbm5vdCBjcmVhdGUgSU5TVEVBRCBPRiB0cmlnZ2VyIG9uIHRhYmxlOiAlUwBNQVRFUklBTElaRSAlIVMAQ08tUk9VVElORSAlIVMAU1FMSVRFX0lPRVJSAFVTSU5HIElOREVYICVzIEZPUiBJTi1PUEVSQVRPUgBVU0lORyBST1dJRCBTRUFSQ0ggT04gVEFCTEUgJXMgRk9SIElOLU9QRVJBVE9SAFNRTElURV9FUlJPUgBFTkFCTEVfQVBJX0FSTU9SAE1VTFRJLUlOREVYIE9SAFNRTElURV9DQU5UT1BFTl9JU0RJUgBTUUxJVEVfVE1QRElSAFNRTElURV9DQU5UT1BFTl9OT1RFTVBESVIAU1FMSVRFX0ZDTlRMX1ZGU19QT0lOVEVSAFNRTElURV9GQ05UTF9KT1VSTkFMX1BPSU5URVIAU1FMSVRFX0ZDTlRMX0ZJTEVfUE9JTlRFUgBDUkVBVEUgQkxPT00gRklMVEVSAEFGVEVSAFNRTElURV9BVVRIX1VTRVIAU1FMSVRFX0ZDTlRMX0JVU1lIQU5ETEVSAFNRTElURV9DT05TVFJBSU5UX1RSSUdHRVIAU1FMSVRFX0RST1BfVFJJR0dFUgBTUUxJVEVfRFJPUF9URU1QX1RSSUdHRVIAU1FMSVRFX0NSRUFURV9URU1QX1RSSUdHRVIAU1FMSVRFX0NSRUFURV9UUklHR0VSAFNRTElURV9EQkNPTkZJR19FTkFCTEVfVFJJR0dFUgBTUUxJVEVfSU5URUdFUgBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBzeiBCTE9CLCBvcmlnaW4gSU5URUdFUgBTUUxJVEVfREJDT05GSUdfUkVWRVJTRV9TQ0FOT1JERVIAU1FMSVRFX0ZDTlRMX0VYVEVSTkFMX1JFQURFUgBTUUxJVEVfVkVSU0lPTl9OVU1CRVIAU1FMSVRFX01BWF9WQVJJQUJMRV9OVU1CRVIAU1FMSVRFX0xJTUlUX1ZBUklBQkxFX05VTUJFUgBORUFSAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0VRAFNRTElURV9FUlJPUl9NSVNTSU5HX0NPTExTRVEAJXolcyVRAERFTEVURSBGUk9NICVRLiVzIFdIRVJFICVzPSVRAG5hbWU9JVEgQU5EIHNxbD0lUQBERUxFVEUgRlJPTSAlUS5zcWxpdGVfc2VxdWVuY2UgV0hFUkUgbmFtZT0lUQAsIFQuJVEAU0VMRUNUICogRlJPTSAlUS4lUQBBVFRBQ0ggeCBBUyAlUQBVUERBVEUgIiV3Ii5zcWxpdGVfc2VxdWVuY2Ugc2V0IG5hbWUgPSAlUSBXSEVSRSBuYW1lID0gJVEAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gcHJpbnRmKCclJS4lZHMsICcsc3FsKSB8fCAlUSB8fCBzdWJzdHIoc3FsLDErbGVuZ3RoKHByaW50ZignJSUuJWRzJyxzcWwpKSkgV0hFUkUgdHlwZSA9ICd0YWJsZScgQU5EIG5hbWUgPSAlUQBiYWQgSlNPTiBwYXRoOiAlUQBmdHM1dm9jYWI6IHVua25vd24gdGFibGUgdHlwZTogJVEAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfUkVHRVhQAFNFVFVQAEdST1VQAFNRTElURV9EQkNPTkZJR19UUklHR0VSX0VRUABTUUxJVEVfTUFYX1ZEQkVfT1AAU1FMSVRFX0xJTUlUX1ZEQkVfT1AAU1FMSVRFX0NIQU5HRVNFVEFQUExZX0lHTk9SRU5PT1AAU1FMSVRFX1NUTVRTVEFUVVNfRlVMTFNDQU5fU1RFUABTUUxJVEVfU1RNVFNUQVRVU19WTV9TVEVQAFJFQ1VSU0lWRSBTVEVQAFNRTElURV9JT0VSUl9NTUFQAFNRTElURV9JT0VSUl9TSE1NQVAAU1FMSVRFX0NPTkZJR19IRUFQAFNRTElURV9GQ05UTF9DT01NSVRfUEhBU0VUV08AU1FMSVRFX0ZDTlRMX0xBU1RfRVJSTk8AU05hTgBRTmFOAFNRTElURV9TVE1UU1RBVFVTX1JVTgBtYWxmb3JtZWQgSlNPTgBTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9GVU5DVElPTgBTUUxJVEVfQ09OU1RSQUlOVF9GVU5DVElPTgBFTkFCTEVfVU5LTk9XTl9TUUxfRlVOQ1RJT04AU1FMSVRFX0ZVTkNUSU9OAFNRTElURV9UUkFOU0FDVElPTgBOTyBBQ1RJT04ARU5BQkxFX1NFU1NJT04AU1FMSVRFX1ZFUlNJT04AU1FMSVRFX0ZDTlRMX0RBVEFfVkVSU0lPTgBPTUlUX0xPQURfRVhURU5TSU9OAFNRTElURV9EQkNPTkZJR19FTkFCTEVfTE9BRF9FWFRFTlNJT04AVU5JT04AU1FMSVRFX01BWF9DT0xVTU4AU1FMSVRFX0xJTUlUX0NPTFVNTgAgTEVGVC1KT0lOAEJFR0lOAFNRTElURV9JT0NBUF9VTkRFTEVUQUJMRV9XSEVOX09QRU4AU1FMSVRFX0NBTlRPUEVOAFNRTElURV9JT0VSUl9TSE1PUEVOACxhcmcgSElEREVOACxzY2hlbWEgSElEREVOAE5BTgBTUUxJVEVfQ09ORklHX0NPVkVSSU5HX0lOREVYX1NDQU4AREVGQVVMVF9BVVRPVkFDVVVNACBOVU0AU1FMSVRFX1BFUk0AUE0AUlRSSU0AU1FMSVRFX0lPRVJSX05PTUVNAFNRTElURV9OT01FTQBBTQBTUUxJVEVfUFJPVE9DT0wAU1FMSVRFX0RCQ09ORklHX0RRU19ETUwAU1FMSVRFX05VTEwAU1FMSVRFX0NPTlNUUkFJTlRfTk9UTlVMTABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9JU05PVE5VTEwAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfSVNOVUxMAENhbm5vdCBhZGQgYSBOT1QgTlVMTCBjb2x1bW4gd2l0aCBkZWZhdWx0IHZhbHVlIE5VTEwATk9UIE5VTEwAU0VUIE5VTEwALCBOVUxMAFNRTElURV9EQlNUQVRVU19MT09LQVNJREVfTUlTU19GVUxMAFNRTElURV9GVUxMAFNRTElURV9TWU5DX0ZVTEwAU1FMSVRFX0NPTkZJR19TVE1USlJOTF9TUElMTABTUUxJVEVfREJTVEFUVVNfQ0FDSEVfU1BJTEwAVU5JT04gQUxMAFNRTElURV9GQUlMAFNRTElURV9EQkNPTkZJR19EUVNfRERMAFNRTElURV9GQ05UTF9QRVJTSVNUX1dBTABTUUxJVEVfTk9USUNFX1JFQ09WRVJfV0FMAFNRTElURV9PUEVOX1dBTABTUUxJVEVfT1BFTl9TVVBFUl9KT1VSTkFMAFNRTElURV9PUEVOX1RFTVBfSk9VUk5BTABTUUxJVEVfT1BFTl9NQUlOX0pPVVJOQUwAU1FMSVRFX09QRU5fU1VCSk9VUk5BTABTUUxJVEVfSU5URVJOQUwAU1FMSVRFX1NZTkNfTk9STUFMAFNRTElURV9JT0NBUF9TRVFVRU5USUFMACwlLipzIFJFQUwAU1FMSVRFX09LAEVOQUJMRV9QUkVVUERBVEVfSE9PSwBTUUxJVEVfQ09OU1RSQUlOVF9DT01NSVRIT09LAFNRTElURV9DQU5UT1BFTl9TWU1MSU5LAFNRTElURV9JT0VSUl9TRUVLAFNRTElURV9JT0VSUl9MT0NLAFNRTElURV9SRUFET05MWV9DQU5UTE9DSwBTUUxJVEVfSU9FUlJfVU5MT0NLAFNRTElURV9JT0VSUl9TSE1MT0NLAFNRTElURV9JT0VSUl9SRExPQ0sAU1FMSVRFX0lPRVJSX0NIRUNLUkVTRVJWRURMT0NLAFNRTElURV9GQ05UTF9XQUxfQkxPQ0sAU1FMSVRFX0NPTlNUUkFJTlRfQ0hFQ0sAU1FMSVRFX1NUQVRVU19QQVJTRVJfU1RBQ0sAU1FMSVRFX1JFQURPTkxZX1JPTExCQUNLAFNRTElURV9BQk9SVF9ST0xMQkFDSwBTUUxJVEVfTk9USUNFX1JFQ09WRVJfUk9MTEJBQ0sAU1FMSVRFX1JPTExCQUNLAGFib3J0IGR1ZSB0byBST0xMQkFDSwBTUUxJVEVfSU9DQVBfQVRPTUlDOEsAU1FMSVRFX0lPQ0FQX0FUT01JQzE2SwBTUUxJVEVfSU9DQVBfQVRPTUlDNEsAU1FMSVRFX0lPQ0FQX0FUT01JQzY0SwBTUUxJVEVfSU9DQVBfQVRPTUlDMksAU1FMSVRFX0lPQ0FQX0FUT01JQzMySwBTUUxJVEVfSU9DQVBfQVRPTUlDMUsAU1FMSVRFX09QRU5fVVJJAFNRTElURV9DT05GSUdfVVJJAFVTRV9VUkkAU1FMSVRFX0lPRVJSX0FVVEgAU1FMSVRFX0FVVEgAU1FMSVRFX01BWF9FWFBSX0RFUFRIAFNRTElURV9MSU1JVF9FWFBSX0RFUFRIAFNRTElURV9NQVhfVFJJR0dFUl9ERVBUSABTUUxJVEVfTElNSVRfVFJJR0dFUl9ERVBUSABTUUxJVEVfTUFYX0xFTkdUSABTUUxJVEVfTElNSVRfTEVOR1RIAFNRTElURV9NQVhfTElLRV9QQVRURVJOX0xFTkdUSABTUUxJVEVfTElNSVRfTElLRV9QQVRURVJOX0xFTkdUSABTUUxJVEVfTUFYX1NRTF9MRU5HVEgAU1FMSVRFX0xJTUlUX1NRTF9MRU5HVEgAU1FMSVRFX0lPRVJSX0NPTlZQQVRIAFNRTElURV9DQU5UT1BFTl9DT05WUEFUSABTUUxJVEVfSU9FUlJfR0VUVEVNUFBBVEgAU1FMSVRFX0NBTlRPUEVOX0ZVTExQQVRIAFNRTElURV9DT05GSUdfU0NSQVRDSABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9NQVRDSABTUUxJVEVfTUlTTUFUQ0gAU0VBUkNIAFNRTElURV9BVFRBQ0gAU1FMSVRFX0RFVEFDSABTUUxJVEVfREJDT05GSUdfRU5BQkxFX1FQU0cAU1FMSVRFX01BWF9GVU5DVElPTl9BUkcAU1FMSVRFX0xJTUlUX0ZVTkNUSU9OX0FSRwBTUUxJVEVfQ09ORklHX0xPRwBTUUxJVEVfQ09ORklHX1NRTExPRwBVU0lORwBTUUxJVEVfV0FSTklORwBTUUxJVEVfTE9DS19QRU5ESU5HAFNRTElURV9UT09CSUcASU5GADAxMjM0NTY3ODlBQkNERUYAU1FMSVRFX0FOQUxZWkUAU1FMSVRFX0RCU1RBVFVTX0xPT0tBU0lERV9NSVNTX1NJWkUAU1FMSVRFX0ZDTlRMX01NQVBfU0laRQBTUUxJVEVfQ09ORklHX01NQVBfU0laRQBTUUxJVEVfTUFYX0FMTE9DQVRJT05fU0laRQBTUUxJVEVfRkNOVExfQ0hVTktfU0laRQBTUUxJVEVfU0VTU0lPTl9PQkpDT05GSUdfU0laRQBTUUxJVEVfQ09ORklHX1NPUlRFUlJFRl9TSVpFAFNRTElURV9TVEFUVVNfUEFHRUNBQ0hFX1NJWkUAU1FMSVRFX1NUQVRVU19NQUxMT0NfU0laRQBTUUxJVEVfQ09ORklHX01FTURCX01BWFNJWkUAU1FMSVRFX0NPTkZJR19XSU4zMl9IRUFQU0laRQBTUUxJVEVfU0VTU0lPTl9DT05GSUdfU1RSTVNJWkUAU1FMSVRFX0lPRVJSX1NITVNJWkUAU1FMSVRFX1BSRVBBUkVfTk9STUFMSVpFAFNRTElURV9PUEVOX0VYQ0xVU0lWRQBTUUxJVEVfTE9DS19FWENMVVNJVkUAU1FMSVRFX1JFQ1VSU0lWRQBTUUxJVEVfREJDT05GSUdfREVGRU5TSVZFAFNRTElURV9DT05TVFJBSU5UX1VOSVFVRQBTUUxJVEVfSU5ERVhfU0NBTl9VTklRVUUAIFVOSVFVRQBTUUxJVEVfSU9FUlJfV1JJVEUAU1FMSVRFX1RYTl9XUklURQBTUUxJVEVfREJTVEFUVVNfQ0FDSEVfV1JJVEUAU1FMSVRFX0ZDTlRMX0NPTU1JVF9BVE9NSUNfV1JJVEUAU1FMSVRFX0ZDTlRMX0JFR0lOX0FUT01JQ19XUklURQBTUUxJVEVfRkNOVExfUk9MTEJBQ0tfQVRPTUlDX1dSSVRFAFNRTElURV9GQ05UTF9PVkVSV1JJVEUAU1FMSVRFX0lPQ0FQX1BPV0VSU0FGRV9PVkVSV1JJVEUAU1FMSVRFX0ZDTlRMX1BPV0VSU0FGRV9PVkVSV1JJVEUAU1FMSVRFX0FDQ0VTU19SRUFEV1JJVEUAU1FMSVRFX09QRU5fUkVBRFdSSVRFAFNRTElURV9JT0VSUl9ERUxFVEUAU1FMSVRFX0RFTEVURQBTUUxJVEVfRkNOVExfTE9DS1NUQVRFAFNRTElURV9PUEVOX0NSRUFURQBTUUxJVEVfVVBEQVRFAGNhbm5vdCBVUERBVEUAU1FMSVRFX0lPRVJSX1RSVU5DQVRFAFNRTElURV9NSVNVU0UAJXUtUk9XIFZBTFVFUyBDTEFVU0UAU1FMSVRFX0lPRVJSX0NMT1NFAFNRTElURV9JT0VSUl9ESVJfQ0xPU0UAU1FMSVRFX0RCQ09ORklHX05PX0NLUFRfT05fQ0xPU0UAU1FMSVRFX1RSQUNFX0NMT1NFAFNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UAU1FMSVRFX0RFU0VSSUFMSVpFX0ZSRUVPTkNMT1NFAFJFTEVBU0UATk9DQVNFAFNRTElURV9EQkNPTkZJR19SRVNFVF9EQVRBQkFTRQBTUUxJVEVfSUdOT1JFAEJFRk9SRQBTUUxJVEVfU1RNVFNUQVRVU19SRVBSRVBBUkUAU1FMSVRFX1JFU1VMVF9TVUJUWVBFAFNRTElURV9TVUJUWVBFAFNRTElURV9DT05TVFJBSU5UX0RBVEFUWVBFAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX05FAFNRTElURV9UWE5fTk9ORQBTUUxJVEVfTE9DS19OT05FAFNRTElURV9GQ05UTF9DS1BUX0RPTkUAU1FMSVRFX0RPTkUAU1FMSVRFX0ZDTlRMX1ZGU05BTUUAU1FMSVRFX0ZDTlRMX1RFTVBGSUxFTkFNRQBTUUxJVEVfREJDT05GSUdfTUFJTkRCTkFNRQBJZHhMRQBTZWVrTEUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfTEUAU1FMSVRFX0ZDTlRMX0NLU01fRklMRQBTUUxJVEVfRkNOVExfU0VUX0xPQ0tQUk9YWUZJTEUAU1FMSVRFX0ZDTlRMX0dFVF9MT0NLUFJPWFlGSUxFAFNRTElURV9UUkFDRV9QUk9GSUxFAFNRTElURV9GQ05UTF9XSU4zMl9TRVRfSEFORExFAFNRTElURV9GQ05UTF9XSU4zMl9HRVRfSEFORExFAFNRTElURV9EQkNPTkZJR19MRUdBQ1lfQUxURVJfVEFCTEUAU1FMSVRFX0FMVEVSX1RBQkxFAFNRTElURV9EUk9QX1RBQkxFAFNRTElURV9EUk9QX1RFTVBfVEFCTEUAU1FMSVRFX0NSRUFURV9URU1QX1RBQkxFAFNRTElURV9DUkVBVEVfVEFCTEUAU1FMSVRFX0RST1BfVlRBQkxFAFNRTElURV9DUkVBVEVfVlRBQkxFAFNRTElURV9JT0NBUF9JTU1VVEFCTEUAU1FMSVRFX0RFU0VSSUFMSVpFX1JFU0laRUFCTEUAU1FMSVRFX1VURjE2TEUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfTElLRQBTUUxJVEVfRkNOVExfUkVTRVRfQ0FDSEUAT01JVF9TSEFSRURfQ0FDSEUAU1FMSVRFX0NPTkZJR19QQ0FDSEUAU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEUAU1FMSVRFX09QRU5fUFJJVkFURUNBQ0hFAFNRTElURV9DT05GSUdfUEFHRUNBQ0hFAFNRTElURV9PUEVOX1NIQVJFRENBQ0hFAFNRTElURV9MT0NLRURfU0hBUkVEQ0FDSEUASWR4R0UAU2Vla0dFAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0dFAFNRTElURV9SQU5HRQBFTkFCTEVfUlRSRUUAJXMgVVNJTkcgVEVNUCBCLVRSRUUAU1FMSVRFX0lPRVJSX1ZOT0RFAFNRTElURV9PUEVOX0VYUkVTQ09ERQBTUUxJVEVfQ09ORklHX0xPT0tBU0lERQBTUUxJVEVfREJDT05GSUdfTE9PS0FTSURFAENBU0NBREUAU1FMSVRFX0NPUlJVUFRfU0VRVUVOQ0UAU1FMSVRFX05PVElDRQBTUUxJVEVfRkNOVExfVFJBQ0UAU1FMSVRFX0NIQU5HRVNFVF9SRVBMQUNFAFNRTElURV9SRVBMQUNFAFNRTElURV9VVEYxNkJFAFNRTElURV9DSEFOR0VTRVRfTk9URk9VTkQAU1FMSVRFX05PVEZPVU5EAFNRTElURV9JT0NBUF9TQUZFX0FQUEVORABBTkQAU1FMSVRFX1NPVVJDRV9JRABTUUxJVEVfQ09OU1RSQUlOVF9ST1dJRAAgV0lUSE9VVCBST1dJRABPSUQAU1FMSVRFX0NPTkZJR19TRVJJQUxJWkVEAFNRTElURV9MT0NLX1JFU0VSVkVEAFNRTElURV9GQ05UTF9IQVNfTU9WRUQAU1FMSVRFX1JFQURPTkxZX0RCTU9WRUQAU1FMSVRFX0ZDTlRMX1NZTkNfT01JVFRFRABPTUlUX0RFUFJFQ0FURUQAU1FMSVRFX1NUQVRVU19NRU1PUllfVVNFRABTUUxJVEVfREJTVEFUVVNfU1RNVF9VU0VEAFNRTElURV9EQlNUQVRVU19DQUNIRV9VU0VEAFNRTElURV9TVEFUVVNfUEFHRUNBQ0hFX1VTRUQAU1FMSVRFX0RCU1RBVFVTX0xPT0tBU0lERV9VU0VEAFNRTElURV9EQlNUQVRVU19TQ0hFTUFfVVNFRABTUUxJVEVfU1RNVFNUQVRVU19NRU1VU0VEAFNRTElURV9MT0NLX1NIQVJFRABTUUxJVEVfREJTVEFUVVNfQ0FDSEVfVVNFRF9TSEFSRUQAU1FMSVRFX0NPTlNUUkFJTlRfUElOTkVEAFNRTElURV9VVEYxNl9BTElHTkVEAFNRTElURV9MT0NLRUQAU1FMSVRFX0lPRVJSX0JMT0NLRUQAU1FMSVRFX01BWF9BVFRBQ0hFRABTUUxJVEVfTElNSVRfQVRUQUNIRUQARElSRUNUX09WRVJGTE9XX1JFQUQAU1FMSVRFX0lPRVJSX1NIT1JUX1JFQUQAU1FMSVRFX0FDQ0VTU19SRUFEAFNRTElURV9JT0VSUl9SRUFEAFNRTElURV9UWE5fUkVBRABTUUxJVEVfUkVBRABTUUxJVEVfQ09ORklHX01VTFRJVEhSRUFEAFNRTElURV9DT05GSUdfU0lOR0xFVEhSRUFEAFNFTEVDVCAlcyBGUk9NICVzIFQgV0hFUkUgVC4lUSA8PSA/IEFORCBULiVRID49ID8gT1JERVIgQlkgVC4lUSBERVNDAFNFTEVDVCAlcyBGUk9NICVzIFQgV0hFUkUgVC4lUSA+PSA/IEFORCBULiVRIDw9ID8gT1JERVIgQlkgVC4lUSBBU0MAU1lTVEVNX01BTExPQwBTUUxJVEVfQ09ORklHX1NNQUxMX01BTExPQwBTUUxJVEVfQ09ORklHX01BTExPQwBTUUxJVEVfQ09ORklHX0dFVE1BTExPQwBTUUxJVEVfRkNOVExfU1lOQwBTUUxJVEVfSU9FUlJfRlNZTkMAU1FMSVRFX0lPRVJSX0RJUl9GU1lOQwBFTkFCTEVfT0ZGU0VUX1NRTF9GVU5DAFNRTElURV9ERVRFUk1JTklTVElDAFNRTElURV9JT0VSUl9DT01NSVRfQVRPTUlDAFNRTElURV9JT0NBUF9BVE9NSUMAU1FMSVRFX0lPRVJSX0JFR0lOX0FUT01JQwBTUUxJVEVfSU9FUlJfUk9MTEJBQ0tfQVRPTUlDAFNRTElURV9JT0NBUF9CQVRDSF9BVE9NSUMAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfR0xPQgBTUUxJVEVfQkxPQgBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBzeiBCTE9CAGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIGJsb2NrIEJMT0IAU1FMSVRFX09QRU5fVFJBTlNJRU5UX0RCAFNRTElURV9PUEVOX1RFTVBfREIAU1FMSVRFX09QRU5fTUFJTl9EQgBTUUxJVEVfRkNOVExfUERCAFNRTElURV9OT1RBREIAQkJCAFNRTElURV9DT1JSVVBUX1ZUQUIAU1FMSVRFX0NPTlNUUkFJTlRfVlRBQgBFTkFCTEVfREJTVEFUX1ZUQUIAU1FMSVRFX1BSRVBBUkVfTk9fVlRBQgBFTkFCTEVfREJQQUdFX1ZUQUIARU5BQkxFX0JZVEVDT0RFX1ZUQUIAU1FMSVRFX0xPQ0tFRF9WVEFCAEVOQUJMRV9TVE1UVlRBQgBTUUxJVEVfQ0hBTkdFU0VUX0RBVEEAU1FMSVRFX0lPRVJSX0RBVEEAU1FMSVRFX0ZDTlRMX1BSQUdNQQBTUUxJVEVfUFJBR01BAFNRTElURV9TQ0hFTUEAU1FMSVRFX0RCQ09ORklHX1dSSVRBQkxFX1NDSEVNQQBTUUxJVEVfREJDT05GSUdfVFJVU1RFRF9TQ0hFTUEAQAAlczogIiVzIiAtIHNob3VsZCB0aGlzIGJlIGEgc3RyaW5nIGxpdGVyYWwgaW4gc2luZ2xlLXF1b3Rlcz8AJXM9PwBTRUxFQ1QgZGF0YSBGUk9NICVRLiclcV9ub2RlJyBXSEVSRSBub2Rlbm89PwByb3dpZD0/AERFTEVURSBGUk9NICclcScuJyVxX2lkeCcgV0hFUkUgc2VnaWQ9PwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcgV0hFUkUgaWQ9PwBTRUxFQ1Qgc3olcyBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBpZD0/AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBpZD0/AFNFTEVDVCAlcyBGUk9NICVzIFQgV0hFUkUgVC4lUT0/AERFTEVURSBGUk9NICclcScuJyVxX2RhdGEnIFdIRVJFIGlkPj0/IEFORCBpZDw9PwAsPwApIFZBTFVFUyg/ACBBTkQgKD8AIElTID8AID0gPwAsID8APGV4cHI+AC0+PgAtPgA8AEJFR0lOIElNTUVESUFURTsgQ09NTUlUOwBDUkVBVEUgVEFCTEUgIiV3Ii4iJXdfcGFyZW50Iihub2Rlbm8gSU5URUdFUiBQUklNQVJZIEtFWSxwYXJlbnRub2RlKTsAKTtDUkVBVEUgVEFCTEUgIiV3Ii4iJXdfbm9kZSIobm9kZW5vIElOVEVHRVIgUFJJTUFSWSBLRVksZGF0YSk7AElOU0VSVCBJTlRPICVRLnNxbGl0ZV9tYXN0ZXIgVkFMVUVTKCdpbmRleCcsJVEsJVEsIyVkLCVRKTsAQ1JFQVRFIFRBQkxFIHgodHlwZSBURVhULHNjaGVtYSBURVhULG5hbWUgVEVYVCx3ciBJTlQsc3VicHJvZyBURVhULHN0bXQgSElEREVOKTsAQ1JFQVRFIFRBQkxFIHgoYWRkciBJTlQsb3Bjb2RlIFRFWFQscDEgSU5ULHAyIElOVCxwMyBJTlQscDQgVEVYVCxwNSBJTlQsY29tbWVudCBURVhULHN1YnByb2cgVEVYVCxuZXhlYyBJTlQsbmN5Y2xlIElOVCxzdG10IEhJRERFTik7AFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCB0YmxfbmFtZSA9ICVRLCBuYW1lID0gQ0FTRSBXSEVOIHR5cGU9J3RhYmxlJyBUSEVOICVRIFdIRU4gbmFtZSBMSUtFICdzcWxpdGVYX2F1dG9pbmRleCUlJyBFU0NBUEUgJ1gnICAgICAgQU5EIHR5cGU9J2luZGV4JyBUSEVOICdzcWxpdGVfYXV0b2luZGV4XycgfHwgJVEgfHwgc3Vic3RyKG5hbWUsJWQrMTgpIEVMU0UgbmFtZSBFTkQgV0hFUkUgdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UgQU5EICh0eXBlPSd0YWJsZScgT1IgdHlwZT0naW5kZXgnIE9SIHR5cGU9J3RyaWdnZXInKTsAREVMRVRFIEZST00gJVEuJyVxX2RhdGEnO0RFTEVURSBGUk9NICVRLiclcV9pZHgnOwBEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfY29udGVudCc7AERFTEVURSBGUk9NICVRLiclcV9jb250ZW50JzsARFJPUCBUQUJMRSAnJXEnLiclcV9ub2RlJztEUk9QIFRBQkxFICclcScuJyVxX3Jvd2lkJztEUk9QIFRBQkxFICclcScuJyVxX3BhcmVudCc7AEFMVEVSIFRBQkxFICVRLiclcV8lcycgUkVOQU1FIFRPICclcV8lcyc7AERST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9kYXRhJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfaWR4JztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfY29uZmlnJzsARFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX2RvY3NpemUnOwBERUxFVEUgRlJPTSAlUS4nJXFfZG9jc2l6ZSc7AEFMVEVSIFRBQkxFICVRLiclcV9ub2RlJyAgIFJFTkFNRSBUTyAiJXdfbm9kZSI7QUxURVIgVEFCTEUgJVEuJyVxX3BhcmVudCcgUkVOQU1FIFRPICIld19wYXJlbnQiO0FMVEVSIFRBQkxFICVRLiclcV9yb3dpZCcgIFJFTkFNRSBUTyAiJXdfcm93aWQiOwA6bWVtb3J5OgBmaWxlOgA6c2Vzc2lvblN0b3JhZ2U6ADpsb2NhbFN0b3JhZ2U6AC05ZTk5OQA5LjBlOTk5ACstIAoJMDEyMzQ1Njc4OQBcdTAwMDkAdjgAU3RyaW5nOAB1dGY4AFNRTElURV9VVEY4AERFRkFVTFRfU0VDVE9SX1NJWkU9NDA5NgBNQVhfVkFSSUFCTEVfTlVNQkVSPTMyNzY2AE1BWF9QQUdFX1NJWkU9NjU1MzYAT01JVF9VVEYxNgBTUUxJVEVfVVRGMTYAZnRzNQBwNQBFTkFCTEVfRlRTNQB0b28gbWFueSByZWZlcmVuY2VzIHRvICIlcyI6IG1heCA2NTUzNQBibTI1AEZMQUdTIHBhcmFtZXRlciB0byBqc29uX3ZhbGlkKCkgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDE1AHY0AHNxbGl0ZV9zdGF0NABwNABERUZBVUxUX0ZJTEVfRk9STUFUPTQAREVGQVVMVF9DQUNIRV9TSVpFPS0xNjM4NAB4Q3VycmVudFRpbWVJbnQ2NABwd3JpdGU2NABwcmVhZDY0AE1BTExPQ19TT0ZUX0xJTUlUPTEwMjQAc3FsaXRlX3N0YXQzAHAzAHAyAGF0YW4yAGxvZzIAU1FMSVRFX0NPTkZJR19QQ0FDSEUyAFNRTElURV9DT05GSUdfR0VUUENBQ0hFMgBERUZBVUxUX1NZTkNIUk9OT1VTPTIAREVGQVVMVF9XQUxfU1lOQ0hST05PVVM9MgBURU1QX1NUT1JFPTIATUFYX0RFRkFVTFRfUEFHRV9TSVpFPTgxOTIAcnRyZWVfaTMyAFNRTElURV9JT0NBUF9BVE9NSUM1MTIAU0VMRUNUIHNlZ2lkLCB0ZXJtLCAocGdubz4+MSksIChwZ25vJjEpIEZST00gJVEuJyVxX2lkeCcgV0hFUkUgc2VnaWQ9JWQgT1JERVIgQlkgMSwgMgBTRUxFQ1QgdGJsLGlkeCxzdGF0IEZST00gJVEuc3FsaXRlX3N0YXQxAEFnZ1N0ZXAxAFNFTEVDVCBwYXJlbnRub2RlIEZST00gJVEuJyVxX3BhcmVudCcgV0hFUkUgbm9kZW5vPT8xAFNFTEVDVCBub2Rlbm8gRlJPTSAlUS4nJXFfcm93aWQnIFdIRVJFIHJvd2lkPT8xAFNFTEVDVCAqIEZST00gIiV3Ii4iJXdfcm93aWQiIFdIRVJFIHJvd2lkPT8xAFNFTEVDVCBwYXJlbnRub2RlIEZST00gJyVxJy4nJXFfcGFyZW50JyBXSEVSRSBub2Rlbm8gPSA/MQBERUxFVEUgRlJPTSAnJXEnLiclcV9wYXJlbnQnIFdIRVJFIG5vZGVubyA9ID8xAERFTEVURSBGUk9NICclcScuJyVxX25vZGUnIFdIRVJFIG5vZGVubyA9ID8xAFNFTEVDVCBub2Rlbm8gRlJPTSAnJXEnLiclcV9yb3dpZCcgV0hFUkUgcm93aWQgPSA/MQBERUxFVEUgRlJPTSAnJXEnLiclcV9yb3dpZCcgV0hFUkUgcm93aWQgPSA/MQBmdHM1X2xvY2FsZSgpIHJlcXVpcmVzIGxvY2FsZT0xAEFUT01JQ19JTlRSSU5TSUNTPTEAdW5pY29kZTYxAERFRkFVTFRfSk9VUk5BTF9TSVpFX0xJTUlUPS0xACJTUUxJVEVfU1RBVElDIjowLCAiU1FMSVRFX1RSQU5TSUVOVCI6LTEAU0VMRUNUIHBnbm8gRlJPTSAnJXEnLiclcV9pZHgnIFdIRVJFIHNlZ2lkPT8gQU5EIHRlcm08PT8gT1JERVIgQlkgdGVybSBERVNDIExJTUlUIDEAU0VMRUNUIHBnbm8gRlJPTSAnJXEnLiclcV9pZHgnIFdIRVJFIHNlZ2lkPT8gQU5EIHRlcm0+PyBPUkRFUiBCWSB0ZXJtIEFTQyBMSU1JVCAxAFBSQUdNQSBkZWZlcl9mb3JlaWduX2tleXMgPSAxAFNFTEVDVCBsZW5ndGgoZGF0YSkgRlJPTSAnJXEnLiclcV9ub2RlJyBXSEVSRSBub2Rlbm8gPSAxACwgMQBTRUxFQ1QnSU5TRVJUIElOVE8gJXMuJ3x8cXVvdGUobmFtZSl8fCcgU0VMRUNUKkZST00iJXciLid8fHF1b3RlKG5hbWUpRlJPTSAlcy5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGU9J3RhYmxlJ0FORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0ndGFibGUnQU5EIG5hbWU8PidzcWxpdGVfc2VxdWVuY2UnIEFORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAGNvbnRlbnRsZXNzX2RlbGV0ZT0xIGlzIGluY29tcGF0aWJsZSB3aXRoIGNvbHVtbnNpemU9MABEUVM9MABNQVhfV09SS0VSX1RIUkVBRFM9MABERUZBVUxUX1dPUktFUl9USFJFQURTPTAATUFYX01NQVBfU0laRT0wAERFRkFVTFRfTU1BUF9TSVpFPTAAVEhSRUFEU0FGRT0wADkyMjMzNzIwMzY4NTQ3NzU4MABERUZBVUxUX1BDQUNIRV9JTklUU1o9MjAAbG9nMTAATUFYX0FUVEFDSEVEPTEwAGZ0czU6IDIwMjUtMDEtMTQgMTE6MDU6MDAgZDJmZTZiMDVmMzhkOWQ3Y2Q3OGM1ZDI1MmU5OWFjNTlmMWFlYTA3MWQ2Njk4MzBjMWZmZTRlODk2NmU4NDAxMABcdTAwAE1BWF9DT01QT1VORF9TRUxFQ1Q9NTAwAE1BWF9DT0xVTU49MjAwMABERUZBVUxUX1dBTF9BVVRPQ0hFQ0tQT0lOVD0xMDAwAE1BWF9FWFBSX0RFUFRIPTEwMDAATUFYX1RSSUdHRVJfREVQVEg9MTAwMABNQVhfRlVOQ1RJT05fQVJHPTEwMDAAXHUwMDAwAE1BWF9MSUtFX1BBVFRFUk5fTEVOR1RIPTUwMDAwAE1BWF9WREJFX09QPTI1MDAwMDAwMABNQVhfTEVOR1RIPTEwMDAwMDAwMDAATUFYX1NRTF9MRU5HVEg9MTAwMDAwMDAwMABzZWNvbmQgYXJndW1lbnQgdG8gJSNUKCkgbXVzdCBiZSBhIGNvbnN0YW50IGJldHdlZW4gMC4wIGFuZCAxLjAAQ09NUElMRVI9Y2xhbmctMjAuMC4wAFNFTEVDVCAwLCAndGJsJywgICcnLCAwLCAnJywgMSAgICAgVU5JT04gQUxMIFNFTEVDVCAxLCAnaWR4JywgICcnLCAwLCAnJywgMiAgICAgVU5JT04gQUxMIFNFTEVDVCAyLCAnc3RhdCcsICcnLCAwLCAnJywgMAAlcyUuM3gvAC9wcm9jL3NlbGYvZmQvAElOU0VSVCBJTlRPIG1haW4uAERFTEVURSBGUk9NIG1haW4uAFVQREFURSBtYWluLgAlUS4ATi4ALQAibmFtZSI6ICJzcWxpdGUzX2luZGV4X29yZGVyYnkiLAAibmFtZSI6ICJzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQiLAAibmFtZSI6ICJXYXNtVGVzdFN0cnVjdCIsACJuYW1lIjogInNxbGl0ZTNfdmZzIiwAIm5hbWUiOiAic3FsaXRlM19rdnZmc19tZXRob2RzIiwAIm5hbWUiOiAic3FsaXRlM19pb19tZXRob2RzIiwAIm5hbWUiOiAic3FsaXRlM192dGFiX2N1cnNvciIsACJuYW1lIjogInNxbGl0ZTNfaW5kZXhfaW5mbyIsACJuYW1lIjogInNxbGl0ZTNfbW9kdWxlIiwAIm5hbWUiOiAic3FsaXRlM19maWxlIiwAIm5hbWUiOiAic3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlIiwAIm5hbWUiOiAic3FsaXRlM192dGFiIiwAbm9za2lwc2NhbioAdW5vcmRlcmVkKgBzej1bMC05XSoAX3Jvd2lkXywgKgBTRUxFQ1QgJXMsJXMgRlJPTSAiJXciLiIldyIsICIldyIuIiV3IiBXSEVSRSAlcyBBTkQgKCV6KQAgQU5EICg/JWQgT1IgPyVkIElTICV3LiV3KQAoc3VicXVlcnktJXUpAChqb2luLSV1KQBCYWQgcHRyIG1hcCBlbnRyeSBrZXk9JXUgZXhwZWN0ZWQ9KCV1LCV1KSBnb3Q9KCV1LCV1KQBtYXggcm9vdHBhZ2UgKCV1KSBkaXNhZ3JlZXMgd2l0aCBoZWFkZXIgKCV1KQBDUkVBVEUgVEFCTEUgeCh0eXBlIHRleHQsbmFtZSB0ZXh0LHRibF9uYW1lIHRleHQscm9vdHBhZ2UgaW50LHNxbCB0ZXh0KQBDUkVBVEUgVEFCbEUgdm9jYWIodGVybSwgZG9jLCBjbnQpAENSRUFURSBUQUJsRSB2b2NhYih0ZXJtLCBjb2wsIGRvYywgY250KQBDUkVBVEUgVEFCbEUgdm9jYWIodGVybSwgZG9jLCBjb2wsIG9mZnNldCkAIEFORCAoPzYgT1IgPzMgSVMgc3RhdCkAaShzc3MpAGkoc3MpAGkocHMpAE5vZGUgJWxsZCBpcyB0b28gc21hbGwgKCVkIGJ5dGVzKQBOb2RlICVsbGQgaXMgdG9vIHNtYWxsIGZvciBjZWxsIGNvdW50IG9mICVkICglZCBieXRlcykAaShzKQBSRVBMQUNFIElOVE8gJVEuJyVxX2RvY3NpemUnIFZBTFVFUyg/LD8lcykAcnRyZWUgY29uc3RyYWludCBmYWlsZWQ6ICVzLiglczw9JXMpAENSRUFURSBUQUJMRSAlUS4lcyglcykAYXV0b21hdGljIGluZGV4IG9uICVzKCVzKQBBTlkoJXMpAElOU0VSVCBJTlRPICVRLiclcV9jb250ZW50JyBWQUxVRVMoJXMpAFJFUExBQ0UgSU5UTyAlUS4nJXFfY29udGVudCcgVkFMVUVTKCVzKQBtYWxmb3JtZWQgZGF0YWJhc2Ugc2NoZW1hICglcykAU0VMRUNUICVzJXMgRlJPTSAlUS4lUSBXSEVSRSAoJXMpIElTICglcykATUVSR0UgKCVzKQBTRUxFQ1QgJXMgRlJPTSAiJXciLiIldyIgV0hFUkUgTk9UIEVYSVNUUyAoICBTRUxFQ1QgMSBGUk9NICIldyIuIiV3IiBXSEVSRSAlcykAQ1JFQVRFIFRBQkxFICVRLnNxbGl0ZV9zZXF1ZW5jZShuYW1lLHNlcSkAaShwaXNwcCkAaShwcGlwcHApAGkocHBwKQBpKHBpcHApAHYocHApAHAocHApAGkocHApAGkocGpwKQBpKHBpc2lwKQBpKHBwcGlwKQBpKHBwaXApAHAocGlwKQBpKHBpcCkAaShwamlwKQBpKHBpaWlwKQB2KHApAGkocCkAc2VnaWQsIHRlcm0sIHBnbm8sIFBSSU1BUlkgS0VZKHNlZ2lkLCB0ZXJtKQBDUkVBVEUgVEFCTEUgeChzcWwsbmNvbCxybyxidXN5LG5zY2FuLG5zb3J0LG5haWR4LG5zdGVwLHJlcHJlcCxydW4sbWVtKQAobnVsbCkAZnRzNTogJXMgcXVlcmllcyBhcmUgbm90IHN1cHBvcnRlZCAoZGV0YWlsIT1mdWxsKQBpKHBqKQBpKHBwaWopAGkoc3NwaSkAaShwcGkpAGkocGkpAGkocGlpaSkAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX2Ryb3BfY29sdW1uKCVkLCBzcWwsICVkKSBXSEVSRSAodHlwZT09J3RhYmxlJyBBTkQgdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UpAGZ0czU6IGNvbHVtbiBxdWVyaWVzIGFyZSBub3Qgc3VwcG9ydGVkIChkZXRhaWw9bm9uZSkAbWVtZGIoJXAsJWxsZCkARm91bmQgKCVsbGQgLT4gJWxsZCkgaW4gJXMgdGFibGUsIGV4cGVjdGVkICglbGxkIC0+ICVsbGQpACVzKCVkKQB6ZXJvYmxvYiglZCkAUnRyZWUgZGVwdGggb3V0IG9mIHJhbmdlICglZCkAdG9vIG1hbnkgcHJlZml4IGluZGV4ZXMgKG1heCAlZCkAZnRzNSBleHByZXNzaW9uIHRyZWUgaXMgdG9vIGxhcmdlIChtYXhpbXVtIGRlcHRoICVkKQBFeHByZXNzaW9uIHRyZWUgaXMgdG9vIGxhcmdlIChtYXhpbXVtIGRlcHRoICVkKQBSRVBMQUNFIElOVE8gJVEuJyVxX2NvbmZpZycgVkFMVUVTICgndmVyc2lvbicsICVkKQAoYmxvYikAVVNFIFRFTVAgQi1UUkVFIEZPUiAlcyhPUkRFUiBCWSkAVVNFIFRFTVAgQi1UUkVFIEZPUiAlcyhESVNUSU5DVCkAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9jb2x1bW4oc3FsLCB0eXBlLCBuYW1lLCAlUSwgJVEsICVkLCAlUSwgJWQsICVkKSBXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnICBBTkQgKHR5cGUgIT0gJ2luZGV4JyBPUiB0YmxfbmFtZSA9ICVRKQBDUkVBVEUgVEFCTEUgeChrZXksdmFsdWUsdHlwZSxhdG9tLGlkLHBhcmVudCxmdWxsa2V5LHBhdGgsanNvbiBISURERU4scm9vdCBISURERU4pACV6LCAlUSBISURERU4sICVzIEhJRERFTikAQ1JFQVRFIFRBQkxFIHgocGdubyBJTlRFR0VSIFBSSU1BUlkgS0VZLCBkYXRhIEJMT0IsIHNjaGVtYSBISURERU4pAChOVUxMKQAoRkspAD8xLCAoQ0FTRSBXSEVOID8yPVgnJyBUSEVOIE5VTEwgRUxTRSA/MiBFTkQpACVjPykASU5TRVJUIElOVE8gJyVxJy4nJXFfaWR4JyhzZWdpZCx0ZXJtLHBnbm8pIFZBTFVFUyg/LD8sPykAUkVQTEFDRSBJTlRPICclcScuJyVxX2RhdGEnKGlkLCBibG9jaykgVkFMVUVTKD8sPykAUkVQTEFDRSBJTlRPICVRLiclcV9jb25maWcnIFZBTFVFUyg/LD8pAHByZWZpeCBsZW5ndGggb3V0IG9mIHJhbmdlIChtYXggOTk5KQBERUxFVEUgRlJPTSBtYWluLnNxbGl0ZV9zdGF0MSBXSEVSRSB0Ymw9PzEgQU5EIGlkeCBJUyBDQVNFIFdIRU4gbGVuZ3RoKD8yKT0wIEFORCB0eXBlb2YoPzIpPSdibG9iJyBUSEVOIE5VTEwgRUxTRSA/MiBFTkQgQU5EICg/NCBPUiBzdGF0IElTID8zKQBJTlNFUlQgSU5UTyBtYWluLnNxbGl0ZV9zdGF0MSBWQUxVRVMoPzEsIENBU0UgV0hFTiBsZW5ndGgoPzIpPTAgQU5EIHR5cGVvZig/Mik9J2Jsb2InIFRIRU4gTlVMTCBFTFNFID8yIEVORCwgPzMpAElOU0VSVCBPUiBSRVBMQUNFIElOVE8gJyVxJy4nJXFfcGFyZW50JyBWQUxVRVMoPzEsID8yKQBJTlNFUlQgT1IgUkVQTEFDRSBJTlRPICclcScuJyVxX25vZGUnIFZBTFVFUyg/MSwgPzIpAElOU0VSVCBPUiBSRVBMQUNFIElOVE8gJyVxJy4nJXFfcm93aWQnIFZBTFVFUyg/MSwgPzIpAERFTEVURSBGUk9NICclcScuJyVxX2lkeCcgV0hFUkUgKHNlZ2lkLCAocGduby8yKSkgPSAoPzEsID8yKQBJTlNFUlQgSU5UTyAlcy5zcWxpdGVfc2NoZW1hIFNFTEVDVCpGUk9NICIldyIuc3FsaXRlX3NjaGVtYSBXSEVSRSB0eXBlIElOKCd2aWV3JywndHJpZ2dlcicpIE9SKHR5cGU9J3RhYmxlJ0FORCByb290cGFnZT0wKQBTRUxFQ1QgKiBGUk9NIChTRUxFQ1QgJ3NxbGl0ZV9zY2hlbWEnIEFTIG5hbWUsMSBBUyByb290cGFnZSwndGFibGUnIEFTIHR5cGUgVU5JT04gQUxMIFNFTEVDVCBuYW1lLHJvb3RwYWdlLHR5cGUgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgcm9vdHBhZ2UhPTApAElOU0VSVCBJTlRPICIldyIuIiV3X25vZGUiVkFMVUVTKDEsemVyb2Jsb2IoJWQpKQB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIGhpZ2hsaWdodCgpAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gc25pcHBldCgpAG1pc3VzZSBvZiBzcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlKCkgYnkgJXMoKQBtaXN1c2Ugb2YgYWdncmVnYXRlOiAlcygpAHAoKQB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIHJ0cmVlY2hlY2soKQBJbnZhbGlkIGFyZ3VtZW50IHRvIHJ0cmVlZGVwdGgoKQB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIGZ0czVfZ2V0X2xvY2FsZSgpAG5vbi1pbnRlZ2VyIGFyZ3VtZW50IHBhc3NlZCB0byBmdW5jdGlvbiBmdHM1X2dldF9sb2NhbGUoKQBtaXN1c2Ugb2YgJXMgZnVuY3Rpb24gJSNUKCkAd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAlI1QoKQB1bnNhZmUgdXNlIG9mICUjVCgpAE9SREVSIEJZIG1heSBub3QgYmUgdXNlZCB3aXRoIG5vbi1hZ2dyZWdhdGUgJSNUKCkARklMVEVSIG1heSBub3QgYmUgdXNlZCB3aXRoIG5vbi1hZ2dyZWdhdGUgJSNUKCkAdW5rbm93biBmdW5jdGlvbjogJSNUKCkAbWlzdXNlIG9mIGFnZ3JlZ2F0ZTogJSNUKCkAYW1iaWd1b3VzIHJlZmVyZW5jZSB0byAlcyBpbiBVU0lORygpAFVQREFURSB0ZW1wLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfY29sdW1uKHNxbCwgdHlwZSwgbmFtZSwgJVEsICVRLCAlZCwgJVEsICVkLCAxKSBXSEVSRSB0eXBlIElOICgndHJpZ2dlcicsICd2aWV3JykAVVBEQVRFIHNxbGl0ZV90ZW1wX3NjaGVtYSBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV90YWJsZSglUSwgdHlwZSwgbmFtZSwgc3FsLCAlUSwgJVEsIDEpLCB0YmxfbmFtZSA9IENBU0UgV0hFTiB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSBBTkQgICBzcWxpdGVfcmVuYW1lX3Rlc3QoJVEsIHNxbCwgdHlwZSwgbmFtZSwgMSwgJ2FmdGVyIHJlbmFtZScsIDApIFRIRU4gJVEgRUxTRSB0YmxfbmFtZSBFTkQgV0hFUkUgdHlwZSBJTiAoJ3ZpZXcnLCAndHJpZ2dlcicpAFBSQUdNQSAnJXEnLnRhYmxlX2luZm8oJyVxJykASU5TRVJUIElOVE8gJVEuc3FsaXRlX21hc3RlciBWQUxVRVMoJ3RyaWdnZXInLCVRLCVRLDAsJ0NSRUFURSBUUklHR0VSICVxJykACikAQ1JFQVRFIFRBQkxFIHgoAEJMT09NIEZJTFRFUiBPTiAlUyAoAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0naW5kZXgnAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0naW5kZXgnAG5hbWU9JyVxJyBBTkQgdHlwZT0naW5kZXgnAFNFTEVDVCBjb3VudCgqKSBGUk9NICVRLiclcSVzJwBTRUxFQ1QgY291bnQoKikgRlJPTSAlUS4nJXFfJXMnAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0ndHJpZ2dlcicAREVMRVRFIEZST00gJVEuc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0lUSBhbmQgdHlwZSE9J3RyaWdnZXInAHRibF9uYW1lPSclcScgQU5EIHR5cGUhPSd0cmlnZ2VyJwAnJS4qcScAdHlwZT0ndHJpZ2dlcicgQU5EIG5hbWU9JyVxJwBpbmRleCAnJXEnAFNFTEVDVCBrLCB2IEZST00gJVEuJyVxX2NvbmZpZycAaW52YWxpZCBmdHM1IGZpbGUgZm9ybWF0IChmb3VuZCAlZCwgZXhwZWN0ZWQgJWQgb3IgJWQpIC0gcnVuICdyZWJ1aWxkJwBTRUxFQ1QgKiBGUk9NICVRLiclcV9yb3dpZCcAU0VMRUNUIHN0YXQgRlJPTSAlUS5zcWxpdGVfc3RhdDEgV0hFUkUgdGJsID0gJyVxX3Jvd2lkJwBTRUxFQ1QgdC4lUSBGUk9NICVRLiVRIEFTIHQgV0hFUkUgdC4lUSBNQVRDSCAnKmlkJwBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3RhYmxlKCVRLCB0eXBlLCBuYW1lLCBzcWwsICVRLCAlUSwgJWQpIFdIRVJFICh0eXBlIT0naW5kZXgnIE9SIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlKUFORCAgIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcAU0VMRUNUIENBU0UgV0hFTiBxdWlja19jaGVjayBHTE9CICdDSEVDSyonIFRIRU4gcmFpc2UoQUJPUlQsJ0NIRUNLIGNvbnN0cmFpbnQgZmFpbGVkJykgV0hFTiBxdWlja19jaGVjayBHTE9CICdub24tKiB2YWx1ZSBpbionIFRIRU4gcmFpc2UoQUJPUlQsJ3R5cGUgbWlzbWF0Y2ggb24gREVGQVVMVCcpIEVMU0UgcmFpc2UoQUJPUlQsJ05PVCBOVUxMIGNvbnN0cmFpbnQgZmFpbGVkJykgRU5EICBGUk9NIHByYWdtYV9xdWlja19jaGVjayglUSwlUSkgV0hFUkUgcXVpY2tfY2hlY2sgR0xPQiAnQ0hFQ0sqJyBPUiBxdWlja19jaGVjayBHTE9CICdOVUxMKicgT1IgcXVpY2tfY2hlY2sgR0xPQiAnbm9uLSogdmFsdWUgaW4qJwBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3F1b3RlZml4KCVRLCBzcWwpV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyBBTkQgc3FsIE5PVCBMSUtFICdjcmVhdGUgdmlydHVhbCUlJwBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3F1b3RlZml4KCd0ZW1wJywgc3FsKVdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScAc3FsaXRlXF8lACQAIwBTRUxFQ1QqRlJPTSIldyIAU0VMRUNUKkZST00iJXciLiIldyIAJXolcyIldyIuIiV3Ii4iJXciACV6JXMiJXciLiIldyIuIiV3Ij0iJXciLiIldyIuIiV3IgAleiVzIiV3Ii4iJXciLiIldyIgSVMgTk9UICIldyIuIiV3Ii4iJXciAFNFTEVDVCByYWlzZShBQk9SVCwlUSkgRlJPTSAiJXciLiIldyIAQU5BTFlaRSAiJXciLiIldyIAZm9yZWlnbiBrZXkgbWlzbWF0Y2ggLSAiJXciIHJlZmVyZW5jaW5nICIldyIAZG91YmxlLXF1b3RlZCBzdHJpbmcgbGl0ZXJhbDogIiV3IgBmdHM1OiBzeW50YXggZXJyb3IgbmVhciAiJS4xcyIALiIlLipzIgBleHBlY3RlZCBpbnRlZ2VyLCBnb3QgIiUuKnMiAGZ0czU6IHN5bnRheCBlcnJvciBuZWFyICIlLipzIgBzeW50YXggZXJyb3IgYWZ0ZXIgY29sdW1uIG5hbWUgIiUuKnMiAHVucmVjb2duaXplZCBvcHRpb246ICIlLipzIgAlYyIlcyIAKCIlcyIAY2Fubm90ICVzICVzICIlcyIAZ2VuZXJhdGVkIGNvbHVtbiBsb29wIG9uICIlcyIAY2Fubm90IElOU0VSVCBpbnRvIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgBlcnJvciBpbiBnZW5lcmF0ZWQgY29sdW1uICIlcyIAY2Fubm90IFVQREFURSBnZW5lcmF0ZWQgY29sdW1uICIlcyIAJXMgaW4gIiVzIgBwYXJzZSBlcnJvciBpbiAiJXMiAHRyaWdnZXIgIiVzIiBtYXkgbm90IHdyaXRlIHRvIHNoYWRvdyB0YWJsZSAiJXMiAFVQU0VSVCBub3QgaW1wbGVtZW50ZWQgZm9yIHZpcnR1YWwgdGFibGUgIiVzIgB1bnNhZmUgdXNlIG9mIHZpcnR1YWwgdGFibGUgIiVzIgBjYW5ub3QgY3JlYXRlIGEgVEVNUCBpbmRleCBvbiBub24tVEVNUCB0YWJsZSAiJXMiAG5vIHN1Y2ggaW5kZXg6ICIlcyIAdW5rbm93biBkYXRhdHlwZSBmb3IgJXMuJXM6ICIlcyIAY2Fubm90IGRyb3AgJXMgY29sdW1uOiAiJXMiAG5vIHN1Y2ggY29sdW1uOiAiJXMiAHVucmVjb2duaXplZCB0b2tlbjogIiVzIgAlcyIlcyI6ICIlcyIAdW5kZXJzaXplIFJUcmVlIGJsb2JzIGluICIlcV9ub2RlIgBcIgBubyBzdWNoIGNvbHVtbjogIiVUIgB1bnJlY29nbml6ZWQgdG9rZW46ICIlVCIALiIAd2Vla2RheSAAbm9uLXVuaXF1ZSBlbnRyeSBpbiBpbmRleCAAd3JvbmcgIyBvZiBlbnRyaWVzIGluIGluZGV4IAAgdmFsdWVzIGRpZmZlciBmcm9tIGluZGV4IAAgbWlzc2luZyBmcm9tIGluZGV4IAAgb2YgaW5kZXggAHJvd2lkIG5vdCBh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RlNFVFJJR0dFUkFOR0VORVJBVEVERVRBQ0hBVklOR0xPQkVHSU5ORVJFRkVSRU5DRVNVTklRVUVSWVdJVEhPVVRFUkVMRUFTRUFUVEFDSEJFVFdFRU5PVEhJTkdST1VQU0NBU0NBREVGQVVMVENBU0VDT0xMQVRFQ1JFQVRFQ1VSUkVOVF9EQVRFSU1NRURJQVRFSk9JTlNFUlRNQVRDSFBMQU5BTFlaRVBSQUdNQVRFUklBTElaRURFRkVSUkVESVNUSU5DVFVQREFURVZBTFVFU1ZJUlRVQUxXQVlTV0hFTldIRVJFQ1VSU0lWRUFCT1JUQUZURVJFTkFNRUFORFJPUEFSVElUSU9OQVVUT0lOQ1JFTUVOVENBU1RDT0xVTU5DT01NSVRDT05GTElDVENST1NTQ1VSUkVOVF9USU1FU1RBTVBSRUNFRElOR0ZBSUxBU1RGSUxURVJFUExBQ0VGSVJTVEZPTExPV0lOR0ZST01GVUxMSU1JVElGT1JERVJFU1RSSUNUT1RIRVJTT1ZFUkVUVVJOSU5HUklHSFRST0xMQkFDS1JPV1NVTkJPVU5ERURVTklPTlVTSU5HVkFDVVVNVklFV0lORE9XQllJTklUSUFMTFlQUklNQVJZAEGUjQMLpAICAAIACAAJAA4AEAAUABcAGQAZAB0AIQAkACkALgAwADUANgA7AD4AQQBDAEUATgBRAFYAWgBaAF4AYwBlAGkAbwB3AHsAewB7AH4AgQCEAIkAjgCSAJMAmACcAKAAqACuALUAuAC4ALsAvQDDAMYAzgDTANgA2wDeAOIA7ADvAPQA9AD4APwAAwEJAQ8BFQEVARsBHAEgAScBKwEyATgBRAFNAU8BVQFaAVwBYwFnAXIBeQF6AYEBhwGNAZIBmAGcAZ8BqAGtAbEBtwG5AbwBxQHHAckB0gHWAdwB4gHqAe8B7wHvAf8BCAILAg8CFAIbAiACKQItAjACNQI3AjsCQwJJAkwCVQJaAmICYgJmAm8CdAJ5An8CggKFAogCigKPApMCAEHBjwMLkwEHBwUEBgQFAwYHAwYGBwcDCAIGBQQEAwoEBwYJBAIGBQkJBAcDAgQEBgsGAgcFBQkGCgQGAgMHBQkGBgQFBQoGBQcEBQcGBwcGBQcDBwQHBgwJBAYFBAcGDAgIAgYGBwYEBQkFBQYDBAkNAgIEBgYIBREMBwkEBAYHBQkEBAUCBQgGBAkFCAQDCQUFBgQGAgIJAwcAQeCQAwuIBAEAAgMEAgICAQECAwQCAgIBAgICAgICAgEDAwIEAgICAQQCAgIEBQIGBQUFBQUFBQYGBQUFBQUHAQcFBQUFBQXqAwAAAEAAAOsDAAAAAAQA9wMAAAAAAIDsAwAAAABAAO0DAAAAAAEA7gMAAAAIAADvAwAAAACAAPADAAAAAAAB8QMAAAAAAALyAwAAAAAAEPMDAAABAAAI9AMAAAAAAAT2AwAAAAAAIPUDAAAAAABA+AMAAAIAAAD5AwAAgAAAAPoDAAAABAAA+wMAAAAQAAAAypo7AMqaO9AHAADoAwAA9AEAAICy5g7oAwAACgAAAFDDAAD+fwAA6AMAAAAAAAD///////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0OD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2dUF+SChY9cAQZCVAwvZAVNRTGl0ZSBmb3JtYXQgMwBCSU5BUlkAAAAAAAECAAICAAECAQEBAgECEAEBAQEBAQIBARAQABAAAgIAAAAAAAAAAQIDBAYICAAAAAAAAAEBAgIDAwQEBQUGBgcHCAgJCQoKCwsMDA0NDg4PDxAQERESEhMTFBQVFRYWFxcYGBkZGhobGxwcHR0eHh8fICAhISIiIyMkJCUlJiYnJygoKSkqKisrLCwtLS4uLy8wMDExMjIzMzQ0NTU2Njc3ODg5ORBAAkAAAAECAwQGCAAAAAAhACAAHgAcABoAQfKWAwsJAQEDAAUABgAIAEGQlwMLAQEAQbSXAwudARAAQQCBAQGBg4MBAQMDARIBycnJyQFJSUlJyUnBAUFBwQFBQUFBQSYmQSMLgQEDAwMLCwsLCwsBAwMBQQEAAAICCAAQEBAAEAAQEAAAEBAA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cQBxAJ8InwhWA1YDVgPvAv0C/QL9Av0CSARIBNUCJAFyA4gDVgJWAlYCVgJWAlYCVgJWAlYCVgJWAlYCVgJWAlYCVgJWAlYCVgL5BAgECARWApMASgRKBFsCWwL8BPwEawGfCJ8InwifCJ8InwifCNUBaQJpAiEDUAHNASQDYANnAnsDkQNWAlYCVgJWAlYCVgJWAlYCVgJWAo0CVgJWAlYCVgJWAlYCVgJWAlYCVgJWAlYCUQRRBFEEVgJWAlYCqgRWAlYCVgK/BOEEVgJJBVYCVgJWAlYCVgJWAlYCVgKlAsEBhgM6BToFOgU6BeAEhgOGA0YBfwQXBPMC7QJbBcADWwXvA4oE7QLtAooE7QLAA+8D+gTiAtcAFAUUBRQFcwVzBXMFcwVYBVgFCQSGBWsFUQXfBt8GlQaVBgAHAAeVBpMGlgYWBwUHIQchByEHIQeVBiwHqwaWBpYGqwYWBwUHqwYFB6sGlQYsB64GDweVBiwHPgeVBiwHlQYsBz4H6QbpBukGHgdOB04HPgfpBuYG6QYeB+kG6QbBBlEH+Qb5Bj4HlQYfBx8HMAcwB/IG9gZ1B5UG8wbyBv0GCAerBn8HkweTB5wHnAecB58InwifCJ8InwifCJ8InwifCJ8InwifCJ8InwifCEUADQRPAEAEiwKsBIcF3QWfBVkFrAWPA7sE9AW9BQ8GHwYiBlgGaAZsBtsFoAUkBrgFPQYTAQ4DMgZwBo4GEQaSBpcGbAXeBaAGqgY0Bs4Fswe3B6UHHAe0B7UHrQevBzsHMQdFB7EHsQe2BzwHuAc/B70HzgdCB08HsQdQB5YHsAexB0AHoAehB6MHpAdZB2gHvAdSB94H3wfNB3EHRAeiB88HrAeeB8oHZgeBB+QH4gfqB3sHgwfsB8AH9Af4B/8H+QfTB9wHAgi7BwEICAjbB/wHCQgACI4HDwgQCBEIDQgSCBQIyQenBxUIFwi6Bw4IGwimBxkIFggYCBwIHgjaB+sH5gcaCO8H4wchCCIILggtCC8IMAglCL8Hwgc0CBkINQg4CDsIPQg8CD4IPwhCCEkIQwhECEUIRghKCEsITAjXB9QH1QfWB00IUAhZCFoIaAgAABQBFQEWAfAA8QDgAMIA4gDCAPAA8QDCANgA3ADCAOoA/QDCAP8AEwDgACkB/QDCAP8AzQDUANUAzQDZANoAHwDNAMIA2QDaAMIA2QDaACcA2QDaADgBKwAsAC0APAEvADAAMQAyADMANAA1ADYANwA4ADkAOgATAPAA8QDCAPAA8QDCAP4A8ADxABQBFQEWAekA/QD+AP8A/QD+AP8A2QD9AO8A/wArACwALQAHAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AA4BHgEWABcAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAUgAvADAAMQAyALoAuwC8AL0AvgC/AL0AVwC/AFkAxAATAMYAxAA9AcYAPwEZAMIAzQAqAQ4BzQBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgArACwALQALAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADwAiwCMAPAA8QDWAPAA8QA3ATgBZgBGAO8APAHCABMA/QBNAP8A/QB6AP8ANwA4ADkAOgA7AM8AWADCAFoADAHCAF0ADAFrAGwAbQBuAG8AcABxAHIALwBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgByAHUAdgB3ABQBFQEWASwBEwDCACwBFAEVARYBZwBoAGkAagBrAGwAbQBuAG8AcABxAHIANwA4ADkAOgCSAMIAKwAsAC0ALwAvADAAMQAyADMANAA1ADYANwA4ADkAOgBSAIEAggA8AIEAggDZANoAdABEABkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAFwCEACYBZwBoAGkAagBrAGwAbQBuAG8AcABxAHIA2QB5ADIBwgA0ARoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAdACLAIwA2QB1AHYAdwB4ABMAwgB7AHwAfQAYAG0AbgBvAHAAcQByAIUAPAA3ATgB+gDCAPwAPAETAMIApgCnACsALAAtAM0ALwAwADEAMgAzADQANQA2ADcAOAA5ADoA2QDaAD0BPgErACwALQAIAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AIsAjADwAPEAiwCMALwAvQC+AL8AdQB2AHcA5wDEAP0AxgD/AMIAwgACAQMBkgDNAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAG0A1ADVAOwA7QDZANoAwgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCAHgA8ADxAHsAfAB9AIgAwgATAEoAPACNABcAhQD9AMIA/wBSAMIANQE2Af4AHQA9AT4BwgAhABYAxwAMAQcB7wArACwALQCXAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ANkA2gDCADwAEwCSAB4B8gAXAGsAbABCAMwALAHOAIAASQA8AHQAdQB2AHcACQF5AKUAPACLAIwAKwAsAC0AgQAvADAAMQAyADMANAA1ADYANwA4ADkAOgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgCaAMIAnADCAHUAdgB3ABgBGwHNAGUA3AAfARMAFAAyARYANAF1AHYAdwDTANQA1QDZANoAdQB2AOwA7QAkAHoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIA8ADxAMIAPADCAMIAwgDCABMAwgA8AMIAFwD9AM4A/wBJAP4AEwCaAJsAnABIABQBFQEWAQcB2QDaANkA2gAPASsALAAtAA8BLwAwADEAMgAzADQANQA2ADcAOAA5ADoAtwDCAB0BZQATANYAPADyABcAawBsAG0AdQB2AHcAEAD+AHMA/gB1AHYAdwDCADwAegAHAc0ACAErACwALQAIAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AGcAaABpAGoAawBsAG0AbgBvAHAAcQByAJoAmwCcAJ0AngDwAPEAdQB2AHcAZQDNAHUAEwAUADIBFgA0Af0ASgD/AE4AzQBQAHUAdgB3AHYAJQG3ACQAegBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCACYB8ADxANMA1ADVAJAAEwAXADwAGQAXAPAA8QD9APUA/wAPAJoAmwCcAEgA2QDaAMIA/QAAAf8AgACBAIIAKwAsAC0AFgAvADAAMQAyADMANAA1ADYANwA4ADkAOgC3ABMATQBlABMAgACBAIIAFwBrAGwAPAD+AFgAFQBaAD0AcwBdAHUAdgB3AO8AFgB6ADwAwgDNACsALAAtAM0ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAmgCbAJwAnQCeADwA8ADxADwAdADwAPEAdQB2AHcAkgDCABMAUQD9ABMB/wAYAP0AYgD/AHUAdgB3ALcAFgDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAJcAwgAOAZgAFgAXAMIAGQATAMoA2QDaABcAbQDPADoBOwF8AHUAdgB3AHUAdgB3ADwA6AAWABcAEwAZAC8BMAErACwALQAWAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6AA4B4wBgADwAKwAsAC0AogAvADAAMQAyADMANAA1ADYANwA4ADkAOgByAHAAcQByAMIAPAB4AHkAegB7AHwAfQB+AHUAdgB3AGYAGQCEAGsAbADCAMIA4wBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCAMIAZgDCAHUAdgB3AOkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAwgDCABMAwgDZANoAdQB2AHcA8QCaAJAAnACHAPIAiQCKAIIAEwDoAMIA/QAXAP8A2QDaANkA2gDyABAABwAIAAkAGQAFAQYBCQHCABMA6ACZAOgAKwAsAC0AoAAvADAAMQAyADMANAA1ADYANwA4ADkAOgDCAOMA2QDaACsALAAtAMIALwAwADEAMgAzADQANQA2ADcAOAA5ADoAMgGPADQB2QDaACYBDABNABYAFwDZANoAwgBOADIBUAA0AcIA6AD+AFoAGwB1AF0AZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAKgDCACMAwgDZANoA1gDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAMIA7wBAAMIA2QDaANkA2gDRANIA2QDaAEoAzwBDABYAwgBNABMA6AD1AOgASwAYADgB6ADZANoAPAEZAFoAAAFmAF0AnwDlAKEA5wATANkA2gCiACsALAAtAKAALwAwADEAMgAzADQANQA2ADcAOAA5ADoAEwAXACABGQArACwALQAlAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AIMAFgATARgAKwAsAC0AwgAvADAAMQAyADMANAA1ADYANwA4ADkAOgDCAMIAawBsAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAMIAGQDCADwAwgA6ATsBwgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgATAMIAwgDZANoA2QDaABkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAlgB3AAkBOAFDANkA2gA8ARMA7wDCAMIAgACBAIIACQEJAdEA0gAfAP4AdgD+AFYAPADCAJAAJwATAIIAEwE4AV8ALAAtADwBLwAwADEAMgAzADQANQA2ADcAOAA5ADoA2QDaABgAwgCZAAwALQB3AC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ABsAOgE7ARYAOAEYANkA2gA8AXQAdQAWAJAAGQB2ACoAkwDCADwAEwAUAH8AFgDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByACQAQACRAMIA2QDaAMIANgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCABYANgEZADwAwgDZANoAwgDZANoAwgAEAcIALQEuAUgABgEGAcIAdgAKAQoB2QDaAMIAUgD1ANkA2gDCANkA2gDCANkA2gDZANoAAAE8ABgAwgDZANoAwgBlAMIA9QDZANoAwgBrAGwA2QDaABYA2QDaAAABcwD1AHUAdgB3ANkA2gB6ANkA2gDZANoAAAEWANkA2gB0AAIBAwGSABMAFADCABYAiwCMAJYAlwCIABcAwgAZAMIAjQDCAMIAPgAkAHYAmgCbAJwAnQCeAGQAkQDCAJoAwgCcADEAwgAXAMIAGQDZANoA2QDaAMIAAQE8AI8AwgA8AMIAeQB6ALcA2QDaANkA2gBIANkA2gDZANoAhgAXAMIAGQDZANoABwAIAEEBVgDZANoAwgB6AFsAEwAUABcAFgAZABcAjgAZAIQAZQDZANoAwgDCAMIAawBsACQAwgDCANkA2gDCAHMAwgB1AHYAdwDCAHYAegDCABcAwgAZANkA2gDZANoAwgCOADwA2QDaAMIA2QDaANkA2gBUAFUA2QDaAEgA2QDaANkA2gA8ABcAPAAZAJoAmwCcAJ0AngBWAJoAwgCcAMIAWwATABQAFwAWABkAwgAXAMIAGQBlABcAwgAZAMIAwgBrAGwAJAC3ANkA2gDZANoAcwDCAHUAdgB3ANkA2gB6AMIA7QDCANkA2gDZANoAwgDCABcAPAAZAHYAFwB2ABkA2QDaABcAwgAZAMIASADZANoA2QDaABcAwgAZAMIAmgCbAJwAnQCeAFYAFwDCABkAwgBbANkA2gDZANoAwgDCAMIAwgDCAGUAwgDZANoAIgHCAGsAbADCALcA2QDaAMIAwgBzAMIAdQB2AHcAwgDzAHoAwgAhAcIAwgDCAMIAAQEBAQEB9AABAcAAEQHXAA0B9gArAQ0BJwH3ABEB9wD2ACcB5gAFAeIABQEFAREBEQGaAJsAnACdAJ4AAAABAAIA3QDcAAUA3AD6ANwABQEKAAsADAANAA4A+gAaAREAxQA9ABMAFAD2ABYAtwD0AI4AyQDJACYAHgArASAAyQCYABYAlwAkACsBKwAoAOsAEgDuAB0B7gDuACgB7gDJACgBEgEQARIAyADrAJYA6wD3APcA9wA8APcAEgESARAByQDIAJ8APwAkAUcAyQBIAMgAFgDJAN4AyABPAMkA3gBSACMBdADbAEEAyADbANsA5AAWAH8A4QCmAN4AGADhAHIAYwAcAd0AZQAcAeQAMwE7AdsAawBsANsA2wDbAMkAXABAAXMAQAF1AHYAdwDeAFMAegALAQsBlQCSABMAFAAWABYAFwH6AIYAyQCUAJ8A+QCLAIwA+wCNABkAGQEkAJMA+wD4APcAywANAMMABgDDAJoAmwCcAJ0AngDBADEBwQCjAMEAMQEuAdYA0AA8ANYA0ADfAN8ABADWANYAAwAWANcA1gBIANAApAC3ANcADwAXABAAFwCMAIMAmAAZAI8AFAAQABgAAQCRAI8AgwCDAD4AJQA2ADYAmAA2ADYAZQCDAHUAIgABAI4AawBsABYABQB0AKIARQAZAHMATAB1AHYAdwABAAIAegBFAAUAKQCOAHQAFAAKAAsADAANAA4AGAATABEAhAAFAH4AFgCNAEQACgALAAwADQAOABYAHgARACAAFgAWAJoAmwCcAJ0AngAoABcARAA8AB4AGAAgAGEAHAAWAEQAFwAlACIAKACWABYAGQAXABcAFwAWAGIAFwC3ABcAdQAiABYAGQBZAEcAjgCQAEwAIgAXACIATABPAFcAIgBSACIAXgBHACIAFgAYACwAIgAZABkATwAXABcAUgCPABcAYwCPABcAFgALABkAFwAZABYAFgAWAAEAFwAXAGMAiAAWABYAjgCOAI4AGQAZABcADwABAEIBQgFCAUIBQgFCAUIBQgFCAYYAQgFCAUIBQgGLAIwAQgFCAUIBQgFCAUIBQgGGAEIBQgFCAUIBiwCMAEIBQgFCAUIBQgFCAUIBQgGjAEIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBowBCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAboAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugBB8NMDC9ErggB/AOoAGgEaATAFQAIbBcwBIQEhAUACVgZ9AUACMAU9AkACMgKdARQFBgY9AuEBMgIMAswBywEuAlIAUgDXAyYBdwEzADMA8gE9AD0A2ANSAFIAKQaJAIoAWwAHAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAJ0BIAEgAbYAIAEgAeEBGAIgASABggB/AOoAsAE9Ag0CMgI9Ai0CMgIKBT0CpQEyAokAigBbAC8CzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAKAHMAY4B4QSGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEsABoEGgQoBCsE5wQBAAEARgICAOsERQKWBOsElgRBAZ0BmwBBATAGmwB7AXAA8gE9BcgBKwE9BYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAYkAigBbAFEEzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAtARAATcCIAEgARsBIAEgAQsCCwLiBIsABQYHANYA9wE9ApEEMgI9Ah4EMgKIAIgAiACIAIEAkQEjAucBkQT1ACAGkQT1AIUAhQCEAIQAhACDAIAAwwEFAYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAcMBtAS1BLQEggB/AOoAxwGdAbYAxwGCAH8A6gCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGIAIgAiACIABoCQAKJAIoAWwAFAcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIACwA2AFaAbQE2AFaATMAMwCiAV0AnQCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGmAGsBKgGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwENBc0BIganAXkBEwGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGiAUABNwIMBbQEtQS0BAEBnQHjAf8B/AH7AV4AhACEAIQAgwCAAMMB+gG0BCQCJAKEAUACgAEHAJ0BJgLlAAoCiQCKAFsAEgLMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAzADMALgZ8AYkAigBbAEsBzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAQAE3AiABIAFAATcCQgZGAgIA6wS0BLUEtARcBkEBPQKbADICQALnBQgB5wAIAj0FhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBBwLnBekFNQU1BVIAUgDyAYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAZsFAQEgASAB/wH8AfsBsAMgBp0B+wO0BK8DaAH6AT0CPgYyAiwAPwInAicCLQJTBC4GIAJAAlMEKAChAfUAEwLhBYkAigBbANsAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAUQBRAAEFtASdASkC5wUwAAACwAG/Ae0BQgLHAUICWAEtALQE0QS0BLUEtASsAdMEngByA0ABNwKJAIoAWwDSBMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAdQEQALUBEkBtAS1BLQEgwHsAZMBEAR+AekBewA4AiEGBAB5AbQEtQS0BDoCOgI6AlIAUgByAwUEMwUzBTsCBASGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEgASABAQW0BEACpwFAAiAGnQGnAcQBegF2Az0C/wQyAi4ALQIUAgQEBAQGBDUCggB/AOoALAJSAFIAUgBSAN8BiQCKAFsAzgHMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACkBOcB4gUQBJ0BBgC0BDIAbwN5AHkAtAO0BLUEtARmAS0CegA8AcQBQQLEARcCtAQEBLcBLwHUAIkAigBbANUAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBBAQEBAYEBwQjACABIAG0BLUEtAQQBDsFFQJ7ADgCIQYEAHkBPQL7AzICYQH9BGQBtAS1BLQEBQToAaQEOwIEBIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAUACVwEgASABwQHBAcEBywOdAVsGxAGPA6MEIAEgAT0C0AEyAu4ABAQEBAYENQJSAFIA8gE9ApsBMgJYAdMBTAGJAIoAWwDFAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAKQEEAKRBBAEnQFWBFYE7wERBHkAeQC0BD0BHAJeA5EE3AR6AJEExAFBAsQBPAXGAAQEtAThAQ4CiQCKAFsAMALMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEEBAQEBgQHBCMAtAQgASABtATdASABIAG0BLUEtAQbAuEBtQHWAT0CqwUyAmwBPQKBBDICtAS1BLQEpAQFAEAChgCGAIYAhgCFAIUAhACEAIQAgwCAAMMB3QDWAC4BYAB9BHkG6AB5Bp0BiAETABMAAAS1A5YBdQE7Bj0EtAS1BLQEtAS1BLQEtASqAX0EegadAXoGewaPAYkAigBbAAMAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAMAEfBQICtASJAIoAWwDaBcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIALIBgwCAAMMBdwG0BBIBIwF0AQUCbwEEAgYBtAS1BLQEewTjAGsBwAG/AZsFIAYeBYYAhgCGAIYAhQCFAIQAhACEAIMAgADDASAGQAJ7BOcBtAS1BLQEugGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGCAUAC5QFAAhMAEwC0BLUEtARBBdQEygPUBD4CLwCoA6gD2QGdAa8BEAY9AmUEMgITABMAEwATADEAUAFSA1MDVANvAFgFOwGtAUACnQGxAVUBMgGJAIoAWwBzAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAEACHQVSAFIAiQCKAFsAEQLMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAhBt4AeQETABMAMQFmBJEEjgF8BBYAFgDyAU0BIQZPAXkBQAK2Ab0BkQRnBOYBkQSGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwFoBEAChgNAApEAkQAGAEAChgCGAIYAhgCFAIUAhACEAIQAgwCAAMMB1gA4BZoDQAITABMAEwATAAIFowETABMAmwOcAQMCjQBAApEEnQHOANEBzwCHA9cAJwYoApMAkwAHAOMAkQSbAeIEkQR4ADMBdQAzAZ0BQgBCAE4BiQCKAFsAdwDMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACdAR0B0QDJA4kAigBbANcBzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAswEKAKoFCwGJAH4AWwCbBcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAJsFmwWaAZkBhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBQALJA0ACyATyAXUBOwYSBoYAhgCGAIYAhQCFAIQAhACEAIMAgADDARQCyQFAAlIAUgBSAFIAbwCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwFtAOkArgEoBiICQwBDAAcAnQFfASYCDgYEAQMBAgHuAbsBOQKjAdcDvgHIBMIBIQK3BEACyQPYA50B2wGpBSYGnASKAFsABwDMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAVABUACwFAAiwBZgRbAOkAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAZwR1ATsGoQAlBhAANQA1AAcAbAAVAiYAyQN9ALcEaAScBEACyAR7ADgCfQMEAEQBhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBOwI0AhYCQAJEAEQAQAInAIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAUACoAAjBscExAFAAjYANgBAAkUARQBAAlYFQAKkAbgANQLPASkBQALIBM8BKQFGAEYAQAIsANoBRwBHAEACSABIAEACSQBJADcANwCbAWoD8gBAAjgAOABAAhAEQALeATkAOQBAAnkAeQA7ADsAFwA8ADwAmwF6AD8BxAFBAsQBSgBKAAQESwBLAEwATACbASIBFAAUAGwAHwHnACkCewA4AkUBBABAATcCYQDaALADeARIAZABQAKvA0ACZAWoATsCagMEBAQEBgQHBCMAJQEWAkACUARAAlAECQBAAlYBQAJvAE0ATQCPAI8AQALNAMQB3gBjBXkDQAKFA4QDpASQAJAATgBOADUCPgA+AE8ATwBDAf0DQAIKAT8APwCMA40DNQYeAlAAUABAAnMBHQJ7ADgC4AEEAAoB4gH0AAoBcgEQBEAAQABAAtIBQAJ5AHkAOwIVBkACqgCqAEACegBAAsQBQQLEAUACeQMEBEACpQBAAm8AqwCrAFcAVwBRAVAGxAFBAEEA+gVTAFMAkgCSANoD2wNUAFQANQKoAKgAlACUAEQEWwEIBG8ABAQEBAYEBwQjAB4CTwRAAk8EQAIfAnsAOAL4AQQABwFAAmkB+QVvABAEQARAAgcBQALqAXkAeQA7AqQEjgCOAKkAqQB6AEACxAFBAsQBogCiAAQEQAIzAkACmACYAJcAlwBcAWAFzgPEAQoBRASuAwgEfQCVAJUAqwNAAn0AQAI1ApYAlgBWAFYAaANgAZ8AQAIEBAQEBgQHBCMAHgKtA0ACfQBjAR0CWABYAFUAVQBlAWcBLAUcBW4BEAR4ATQANADzAW0FeQB5AJoFpAQ6ADoAUgVeBXoAnwXEAUECxAEJBacABAQABRgB9ATzBPUESQZPBTgBOQEMADoBjQGNBeAAiAUnAe0AgQVTAVQBkgUtAVkB5AHkAFsFGwVcBVoFkQWUAQQEBAQGBAcEIwBBBqgExgH9AXEBJAHeBdIA3QVZBYwBjAGLARUBiQHTADYCWwNMBtwEewA4AocBBACkBN8ADgENBgsG2QTvALoARwGmAWAAwwDcADsC6wC0AEYBvADUAb4A4wW/AMAAXADBANUBXwCOBQ0A9gH3AJYFbQDHAJIB3AGVAcQB2AWUBZMFDgDrAfsAZgDxAe4F8QAZATUC/QDLAGIB9AH+AK8A9gSXASsAXgEGAi8FtAH/AC4FLQUmBWgAfQNaBuUAmAG4AVkGuQHwADYBEAUQBDcBJQUPAjoGEQV5AHkAcAEPBVgGDAENASwGegArBsQBQQLEAXYBvAEEBHIFcQWMACkCWgA4AgsABADLBX8BngGBAW4AdADYAEABNwJGBSsCKgA+ATsCGQJFBYUBhgFDAq4EFAEXARYBBAQEBAYEBwQjAEQCnwHxBMoB7ASgAbkA/gWsAMQB/wWtAJwANAFOA/0F/AXFAdkA4QBZADUCrgBCAaQE4gDsAE4EmgBMBEoBsAC7AMcEvQCdA1IB8wBcBPYAwgCxALIAqQGrAWIAYwDEAGQAZQAQBLMAXwT4AFsE+QB5AHkAGACjAPoAXQFUBAoBegDWBMQBQQLEAagExgEEBMgAJAHwAfwAyQBdA4wBjAGLARUBiQEPAPUBWwNyASQBAAHKACoC+QGMAYwBiwEVAYkBZwDvAFsDRwEZABoABAQEBAYEBwQjAEYBagH+AXsD7wBtAUcBAQKIA2kANQGkALUAGwBGAWoACQJrAKEELQSDBBEAggQcAaQEHgHSAwkBzAB9AJME8QDmAMwDlwQcAIgEHQCbBK8AlQQeACsAHwCaBPEAIAApACUCCAAhANAAbwCvADsELgQrAHEALATwAHIAMAQiADEEMQJkBHYADwEkABIAqgQJBGkD8ACnA3wAJQAQAREBUQY8ArcAmQCKAakE6AToBOgE6AToBOgE6AToBOgEngHoBOgE6AToBEABNwLoBOgE6AToBOgE6AToBJ4B6AToBOgE6ARAATcC6AToBOgE6AToBOgE6AToBMoB6AToBOgE6AToBOgE6AToBOgE6AToBOgE6ATKAQAAfwZ/Bn8G0wXmBFcF5gTmBOYE5gTTBdMF0wXmBOYE5gTmBOYE5gR1BXUFCAYHBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBNIF5gTmBOYE5gQqBioG5gTmBOYE5gTmBBsGGgbmBOYE5gR+BeYEhQXmBOYE5gTmBOYE1AXVBeYE5gTmBOYEBwYJBuQFjAWLBYoFiQX2BWkFgwV8BYAFzwXQBc4FaQbVBdQF5gR/Ba8FvwWuBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gS3Bb4FvQW8BcUFuwW4BbEFsAWyBbMF/gTmBPsEMQXmBOYE5gTmBOYEtAUHBagFpwWmBeYEwgW1BcEFwAUPBk8GTgblBeYE5gTmBOYE5gTmBCoG5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gRrBSoGKgbmBAcFKgYqBmwFbAUDBQMFbwUWBk4FTgVOBU4FVwVOBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBAwGCgbmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gRTBeYE5gTmBOYE5gTmBOYE5gTmBOYESAbmBPEFPwVTBVMFUwVTBVUFQAU+BU0FCAXtBHcGjwWEBVQFhAV0BoIFjwWPBYIFjwVUBXQGGAVeBhMFdQV1BXUFawVrBWsFawVvBW8F0QVUBU0F5gR3BncGXQVdBXYGdgZdBeUFZgaYBTQFOgU6BToFOgVdBfgEggVmBmYGggWYBTQFggU0BYIFXQX4BPUFcQZdBfgE2wVdBfgEXQX4BNsFMgUyBTIFJwXmBOYE2wUyBRgFMgUnBTIFMgU8BuYE3wXfBdsFXQU0BjQGeAV4BX0FbwXWBV0F5gR9BXsFeQWCBSoFSwZLBkcGRwZHBnwGfAYWBlcGBwUHBQcFBwVXBhoFGgUIBQgFBwVXBuYE5gTmBOYE5gTmBFIG5gQRBuYFYQXmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBBwG5gTmBOYE5gTmBOYE5gTmBOYE5gTmBJ0F5gTpBBMG5gTmBOYE5gTmBOYE5gTmBIYFhwViBeYE5gTmBOYE5gTmBOYElQXmBOYE5gSQBeYE5gTmBOYE5gTmBOYE5gRzBuYE5gTmBOYE5gTmBPQF8wXmBOYEXwXmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBBYF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBHoF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBDkGcAXmBOYE5gTmBGoG5gTmBOYE5gRIBeYE5gTmBOYE5gTmBOYE5gTmBOYEYgZCBZ4F5gShBfwE5gTyBOYE5gQAAAkAQeD/AwuyBr4AvgC9AL8AwADAAMAAwAC/AL8AvwC/AL8AxADGAMgAyADHAMcAxQDFAMwAzADOAM4AzwDRANEA0QDSANYA1wDYANgA2ADYANgA2ADYANgA2ADYANgA2ADYAOEA4QDdAN0A3wDfAOIA4gDiAOIA4wDjAOMA4wDjAOAA4ADkAOQA5ADLAOYA5wDnAOcA5wDnAOoA2wDbAOsA6wDsAOwAvwDuAO4AvwC/AL8AzQDNAM0A8ADzAPMA8wDxAPEA/QDxAP8A/wD0APQA9AAAAfUA9QD1AAEBAQH2APYAAwEDAQIBAgECAQIBAgHJAMkA7wDvAAgBCAEIAQgBBAEEAQQBBAEFAQUBBQEKAQYBBgH6APoA6ADoANwA3ADcAAsBCwELAfgA+AD5APkA+wD7APsA+wC/APcA9wANAQ0BDQENAb8ADgEOAQ4BDgG/AL8AEQERAREBEQERAREBEgEPAQ8BEAEQAQkBCQHaANoA2gDaANkA2QDZANoA2gDaANoA2gDaANoA2gDaANkA2gDaANoA2gDaANoA2gDaANoAFAHaANoA2gDaANoA2gDaANoA2gDaANoA2gAVARUB2gAWARYB2gDaANoA2gDaANoAGQEZARoBGgEYAQcB/gD+ABcBFwG/ABsB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ADQAOQAiADoAOAA6ADkATwA4ACUAVQA4AC8AJwAzAG8ANQDpAjkA6QAFAzkABQEeByUAHgIlAP4F3gBFAEkAJQB+AH4ASQBFAIkAJQBJACUAaQBlAEkAJQBJACUAvgCeACUAfgB+AEkAJQB+AF4AJQAnAF4ARQCHACkAKAAlACkAKAAlACkAKAAlAB4CJQBeAiUAKQAoACUAfgBJACUAXgfFAEkAJQBJAEUAfgBpACUAHgGFCCcAZQNGApgAhgHYAaYA+AAmADgAJgA4AgwOngAmADgAXgAmAGUANQBYACkANQBpACkASQAlACkCKQFlBF4AJQBpAGUAHgOFAF4AOQB+AF4AJQBpBgUGXgQ6AKwASwD+Bt4BJQAeC8kEJgDVAOUENQAxADcArAUxACwANQBMADUATAA1ACwAZwNnAFUAogB5AFUANwBVAFoAbAE1AFUABwQmAEcBrAJNAZUARwAsAGcMNQAnAOwAIgA6AMwARgBMADoAjABHAE0BZwBaACcA1QEiACcALADHA2wDJwtsAScATQEnBCwBRgA6AHUAJgDHAowAJgAsASYAbAAmAKwA9QEnA2wANQAnAGcBbANsACoAxwYsACoALAAnAGoADAGKACwASgAnAOwARwFMAFUATQE1ACYAxwDnACwASgAHAUcAxwLnACcAhwAsACcAagCMAEoASgAsACcAKgBHAGcATABNAUcAVwDPADoANwBMACoAxwBHAMcC5wBHAEcARwAsAGoATABMAGwALACHACcATQFMAGcALABMACoAJwFnAMcC5wBHAKcALAAnAGoArABMACoASgAsACcARwBMAE0BNQA3ACwASgAHAUcAxwLnAEcApwAsACcAKgAsACoAjABKAEoALAAsACoARwBnAEwATQE6ACcAzwAsACcAxwBnAIcARwAnAEcARwBnAIcBSgAsAEoAagBqACwAJwAqAE0BbwDaADcAOgBqAAcBZwDnAkcBpwAnAGwAigBsAIwATABHAEcATABNAe8AOgBKAAcBZwDnAkcBpwAsACcAKgAsAKoALABKAEoATABKACcARwBMAE0BRwBKAAcBZwAnBScAagCMAGoAagAsACcAKgBHAEwATQHPADoAxwBKAEcCBwMnAScA5wAsAGoAbAAsAAoBSgA1AAcGLABHAOwANwDHACYADAE1AE0BVQBHACcARwAnACcAhwDnAGcAJwAnAEcAhwAsAEcAzABMACcApwAmAMwATQGHACcAegD1AToANQB6AEwA2gBNAU8BOgAsADoALAA6ACwANgAyADYAMgBKAAcBhwTMASoArAA1AEwApwBsAYwEGgEsANoAWgC1AJoAVQBnBUoAjAAqAMwAKgBMAEoATAAnAE0B1QDHAEoATACHAGwAJwBqAEcA6gBnAIwApwEsAEoATADKACwAJwAqAE0BagAsAFoAyQQpACkAZwU1ACYAhymHAOcAJwCHACcFhwAnBIcA5wAnAIcA5wEnB4cAZwhsADUBjwIHAloBpwoxAIdNVQAnAj0ARwM2ADIAZwl1AG4ApwGHAGwARwJsAFUARwJMAKcBZwBMAIcGTAAqAOwACgEsAEoAbAF1ACYAdQA3ACcALABNAU8B1QAxAJUAbAA9AE0BZwQmAIcGJwUsACcAxwinA2wAigBMAGoASgAsAMoAbAA6AFUATQHHA6cAhwUqAucASgBNAS8AWgTnAkwAagBVAKcGKgAsACoA7AAsACoALABKAAwBygBMASwATQFNAfUAJgDVAIwAKgDnBSwAKgCsACoALACqACwASgDnAE0B9QBaASwBOgFMACoAxwMqAIwASgBMACoALABKAEcATQGHBSwAKgBMAGoALAAqAGwASgCVAIcECgEMAUoATAC1AE0BZwBNAccDxgBVABUBbAA1AKwBKgDsAIcALACHAEoALABHAIUF5gelASYARQSmBOwEjADeEgUBXgwFAQkBxQDJAAUBCQEFAQkBxQDJAAUBKQApACkAXgDlAAkBxQEFAQgBBQEIAQUBCAGlAEUAiQAoADgAJQB4AGUARQCJACgAeACFAEUAiQB4AAUBqQB4AGUARQCJACgAWAB9AaIA0QBVADQAMwA2AFQAMwA2ADQAFQE7ADwAogA9ADUBNAAzAJUAUAB1ADkANgAyAHUBOQA1ADAAVQE9AKIAwgAvACYAzwB5ADYAMgAmAE8BeQA2ADIApgFXA6wBiwAsAGsAjAFaACkAmgApAFoAJQBpAEUAaQAlADoAKQBaADkAqQDaACkAOgApADoAKQA6AIkAOgAlAIkAJQCHACUAWgBFAEkAuQBeAGUAOgA5AFoAJQA6AA8CbgReAI4ALwC5ALoAWQCaADkAWgA5AFoAOQD6ADkA+gNZAFoAOQA6ADkA+gOZIRoBmQCaAlkA+gA2ADIAOgo5ANoDOQMaBdkAWgL6BHoBjwfaCc8C+hY5ADoBOQDaBhkB+g05ABoS+gw2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIAzwOaBbkANgAyAPkDNgAyADYAMgA2ADIANgAyADYAMgAZAhogeRA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyAPkHNgAyADYAMgAZBDYAMgBZIBoGuQJaANkAWgHpBeUFfgBJAEUA/gBpACUAXgAlAF4ApQBGAGkAJQBeDCUA2gCeAGwAXgCVAC8AVQDFBCUAJQAHByYANQAsAOcC5wDnAOcA5wDnAOcA5wDnAAwEVQA0ADMANAAzAHUANAAzADUANAAzADUBMQBVADEANQA0ADMAVQA0ADMANgAyADYAMgA2ADIANgAyALUAJgBVAVEAWgM6C9oamgE9AHUAOgAmACcALgA2ADIANgAyADYAMgA2ADIANgAyAFoANgAyADYAMgA2ADIANgAyADEANgBSADoALgGMAEoAMQCmAFoAbgAmACcANQBaAMcKTABYAEYAJwAxAEcLNQBmACcAJwXHC1oAjwBaAWcDmgQHAvoDTwHaAw8BOgDvARoETwH6BO8B+gcaICcAJwAaCCcAJwCnAiYA5476BgcFxgBVAIchJgB1AAcCTQFHAN4FJwAsAGsANQBMATUAJgAeAywAxwhOAUwA1QD4AiYBWADeAUUA3gcmAAUBvgBeASYAWACeAJ4AfgFGACUA5wAsAGcALACHACwA5wJKAEwAKgCaAM8AWgA3ADoAhwaVAEoARwYKAiwAVQBNAUwCxwB1ACcATQGHAwwBVQDnAmwBSgA1AKcDbAAqAOcFLABKAIwASgAsAIoAtQEmAE0BVQAnBcwASgBMAEoATABnACwABwEsACoATQGVAAcCJgDHAHoAJwAqAAcGLAAnAGwARwBMAKcATAAnACwAJwBHACYAVQBnASoATABKAFUAJwBGACoALADHAMcAxwDnAOcAZwRKACwASgAsAEoANQAqACwATQEnACcA5wInBiQARABEACQAPwA/AMctRw3lAKUAJwAsAEcBOQCnAacAJwBHAEcAhw0YAmctNgAyAAcIxwaHATcAOgAMAvUANgAyADUA7AA1AFEAUAA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyAFUANgAyAJUAcAB1AJUAMQA2ADIANgAyADYAMgB1ADkAMQB5ADUANwBVAKcA5xAiAHUANwB1ADYAMgA1ADkANQAxAFUATQFVAHkAVQBJAzYANQAyADgAMAA4AEUDNgA5ADIAOQA2ADIANQA2ADIAVQBHASYApwVGAOcDxwDHAMcAZwBXADkAOAA6AFcAOgCZAFoAYgBaAIcBRwNnAkcA5wHHAWcPdQCvBToBrgaPADoCLwCaAboFLACnAycG5wOPACcCLgAHAS4AxwM1AIcEBwE1AK4ACQUFBccJTQHHACcAhwVHACcA5wI1AA8BxwLPADUARwM1AAcHRwAnAGwATACMAIcAZwBnA2wALAAPATUBpwNPADUAxwb1AMcCDwFnAg8BJwnvAyoALAAqAKcG7AH1AI8CTQFMACoApwVqAIwASgBMAFUAIgCVACcDTQFsAIcErAAqAAwBTQGVAEwAKgAHBmoALAFKAIcAlQBNAWcFLAAqACwASgDMACoALABNAedtbgyVAOeFJ0enCCcAygWMAKYBRwDaHvoEmgdKAGwAegDKAAIBDAFaAOwA2gOMABoGWghsADoA+gpPAkkDRQNJA+UARQJJA0UDKQBJACkASQCJAAkBhQAlAOUAZQFJA0UDSQCJAAkB6QBFA0kAiQCpACkA6QBFA0kDRQNJA0UDSQNFA0kDRQNJA0UDSQOFAykDOQAlAzkAxQApAzkAJQM5AMUAKQM5ACUDOQDFACkDOQAlAzkAxQApAzkAJQM5AMUAXgBNBocAZwNHACcAJwBHAYcAJwAnACcAJwAnACcAZwBHACcAJwAnACcAJwAnAEcAJwCHAOcAhwCHACcARwEnAmcApwAnAlkAmgWaDPoB2gH6AfoBbwH6A5oHegW6A3oFOgFaADoE2gDaCJoCugS6ADoC+gc6ANoWmgDaB5oAGgPaCHoB2giaDicAJwAnACcAJwAnAMdDIgACDAwePwA/AEHStgQLIL8F2QbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbjBuUGAEGCtwQL/CQgACEAJAAlACgAKQAqACsALAAtAC4AMAA6ADwAPwBBAFsAXABdAF4AXwBgAGEAewB8AH0AfgB/AKAAoQCiAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAtAC1ALYAuAC5ALoAuwC8AL8AwADXANgA3wD3APgAAAE4ATkBSQFKAXkBfwGBAYMBhAGHAYoBjAGOAZIBkwGVAZYBmQGcAZ4BnwGhAaIBpwGrAawBrwGyAbQBtQG4AboBuwG8Ab4BwAHEAcUBxgHHAcgByQHKAcsBzAHNAd0B3gHwAfEB8gHzAfQB9wH5AfoBNAI6AjwCPQI/AkECRAJHAkgCUAKUApUCsALCAsYC0gLgAuUC7ALtAu4C7wIAA3ADdAN1A3YDegN7A34DhAOGA4cDiAOMA44DkAORA6MDrAPPA9ED0gPVA9gD8AP0A/YD9wP6A/wD/QMwBGAEggSDBIgEigTBBM8E0AQxBVkFWgVhBYkFigWPBZEFvgW/BcAFwQXDBcQFxgXHBdAF8AXzBQAGBgYJBgsGDAYOBhAGGwYeBiAGQAZBBksGYAZqBm4GcAZxBtQG1QbWBt0G3gbfBuUG5wbpBuoG7gbwBvoG/Qb/BgAHDwcQBxEHEgcwB00HpgexB8AHygfrB/QH9gf3B/oHAAgWCBoIGwgkCCUIKAgpCDAIQAhZCF4IoAiiCOQIAAkDCQQJOgk7CTwJPQk+CUEJSQlNCU4JUAlRCVgJYglkCWYJcAlxCXIJeQmBCYIJhQmPCZMJqgmyCbYJvAm9Cb4JwQnHCcsJzQnOCdcJ3AnfCeIJ5gnwCfIJ9An6CfsJAQoDCgUKDwoTCioKMgo1CjgKPAo+CkEKRwpLClEKWQpeCmYKcApyCnUKgQqDCoUKjwqTCqoKsgq1CrwKvQq+CsEKxwrJCssKzQrQCuAK4grmCvAK8QoBCwILBQsPCxMLKgsyCzULPAs9Cz4LPwtAC0ELRwtLC00LVgtXC1wLXwtiC2YLcAtxC3ILgguDC4ULjguSC5kLnAueC6MLqAuuC74LwAvBC8YLygvNC9AL1wvmC/AL8wv5C/oLAQwFDA4MEgwqDDUMPQw+DEEMRgxKDFUMWAxgDGIMZgx4DH8MggyFDI4MkgyqDLUMvAy9DL4MvwzADMYMxwzKDMwM1QzeDOAM4gzmDPEMAg0FDQ4NEg09DT4NQQ1GDUoNTQ1ODVcNYA1iDWYNcA15DXoNgg2FDZoNsw29DcANyg3PDdIN1g3YDfIN9A0BDjEOMg40Dj8OQA5GDkcOTw5QDloOgQ6EDocOig6NDpQOmQ6hDqUOpw6qDq0OsQ6yDrQOuw69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8okNCIdP7z+nBz2mhaN0PIek+9wYWO8/DyJAIJ6RgryYg8kW42DvP6ySwdVQWo48hTLbA+Zp7z9LawGsWTqEPGC0AfMhc+8/Hz60ByHVgrxfm3szl3zvP8kNRzu5Kom8KaH1FEaG7z/TiDpgBLZ0PPY/i+cukO8/cXKdUezFgzyDTMf7UZrvP/CR048S94+82pCkoq+k7z99dCPimK6NvPFnji1Ir+8/CCCqQbzDjjwnWmHuG7rvPzLrqcOUK4Q8l7prNyvF7z/uhdExqWSKPEBFblt20O8/7eM75Lo3jrwUvpyt/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/Tm8gZXJyb3IgaW5mb3JtYXRpb24ASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQg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";
var wasmBinary = base64ToArrayBuffer(sqliteWasmBase64);

// ../sqlite-wasm-kysely/dist/util/createInMemoryDatabase.js
globalThis.sqlite3ApiConfig = {
  warn: (message, details) => {
    if (message === "Ignoring inability to install OPFS sqlite3_vfs:") {
      return;
    }
    console.log(message + " " + details);
  }
};
var sqlite3;
var createInMemoryDatabase = async ({ readOnly = false }) => {
  if (sqlite3 === void 0) {
    sqlite3 = await sqlite_wasm_default({
      // @ts-expect-error
      wasmBinary,
      // https://github.com/opral/inlang-sdk/issues/170#issuecomment-2334768193
      locateFile: () => "sqlite3.wasm"
    });
  }
  const flags = [
    readOnly ? "r" : "cw",
    // read and write
    ""
    // non verbose
  ].join("");
  const db = new sqlite3.oo1.DB(":memory:", flags);
  db.sqlite3 = sqlite3;
  return db;
};

// ../sqlite-wasm-kysely/dist/util/importDatabase.js
var importDatabase = ({ db, content, schema = "main", readOnly = false }) => {
  const deserializeFlag = readOnly ? db.sqlite3.capi.SQLITE_DESERIALIZE_READONLY : db.sqlite3.capi.SQLITE_DESERIALIZE_FREEONCLOSE | db.sqlite3.capi.SQLITE_DESERIALIZE_RESIZEABLE;
  const contentPointer = db.sqlite3.wasm.allocFromTypedArray(content);
  const deserializeReturnCode = db.sqlite3.capi.sqlite3_deserialize(
    db.pointer,
    schema,
    contentPointer,
    content.byteLength,
    // db size
    content.byteLength,
    // content size
    deserializeFlag
  );
  db.checkRc(deserializeReturnCode);
  return db;
};

// ../sqlite-wasm-kysely/dist/kysely/ConnectionMutex.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
};
var _ConnectionMutex_promise;
var _ConnectionMutex_resolve;
var ConnectionMutex = class {
  constructor() {
    _ConnectionMutex_promise.set(this, void 0);
    _ConnectionMutex_resolve.set(this, void 0);
  }
  async lock() {
    while (__classPrivateFieldGet(this, _ConnectionMutex_promise)) {
      await __classPrivateFieldGet(this, _ConnectionMutex_promise);
    }
    __classPrivateFieldSet(this, _ConnectionMutex_promise, new Promise((resolve) => {
      __classPrivateFieldSet(this, _ConnectionMutex_resolve, resolve, "f");
    }));
  }
  unlock() {
    const resolve = __classPrivateFieldGet(this, _ConnectionMutex_resolve);
    __classPrivateFieldSet(this, _ConnectionMutex_promise, void 0);
    __classPrivateFieldSet(this, _ConnectionMutex_resolve, void 0);
    resolve == null ? void 0 : resolve();
  }
};
_ConnectionMutex_promise = /* @__PURE__ */ new WeakMap(), _ConnectionMutex_resolve = /* @__PURE__ */ new WeakMap();

// ../sqlite-wasm-kysely/dist/kysely/SqliteWasmConnection.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SqliteWasmConnection_db;
var SqliteWasmConnection = class {
  constructor(db) {
    _SqliteWasmConnection_db.set(this, void 0);
    __classPrivateFieldSet2(this, _SqliteWasmConnection_db, db);
  }
  executeQuery(compiledQuery) {
    const { sql: sql2, parameters } = compiledQuery;
    const statementData = {
      columns: []
    };
    const totalChangesBefore = __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").changes(true);
    const rows = __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").exec({
      sql: sql2,
      bind: parameters,
      returnValue: "resultRows",
      rowMode: "object",
      columnNames: statementData.columns
    });
    const lastInsertId = __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").sqlite3.capi.sqlite3_last_insert_rowid(__classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f"));
    const changes = totalChangesBefore === __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").changes(true) ? 0 : __classPrivateFieldGet2(this, _SqliteWasmConnection_db, "f").changes();
    return Promise.resolve({
      numAffectedRows: changes,
      insertId: lastInsertId,
      // queries with result
      rows
    });
  }
  // eslint-disable-next-line require-yield
  async *streamQuery() {
    throw new Error("not supported for wasm driver yet");
  }
};
_SqliteWasmConnection_db = /* @__PURE__ */ new WeakMap();

// ../sqlite-wasm-kysely/dist/kysely/SqliteWasmDriver.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SqliteWasmDriver_config;
var _SqliteWasmDriver_connectionMutex;
var _SqliteWasmDriver_db;
var _SqliteWasmDriver_connection;
var SqliteWasmDriver = class {
  constructor(config) {
    _SqliteWasmDriver_config.set(this, void 0);
    _SqliteWasmDriver_connectionMutex.set(this, new ConnectionMutex());
    _SqliteWasmDriver_db.set(this, void 0);
    _SqliteWasmDriver_connection.set(this, void 0);
    __classPrivateFieldSet3(this, _SqliteWasmDriver_config, { ...config });
  }
  async init() {
    __classPrivateFieldSet3(this, _SqliteWasmDriver_db, typeof __classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").database === "function" ? await __classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").database() : __classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").database);
    __classPrivateFieldSet3(this, _SqliteWasmDriver_connection, new SqliteWasmConnection(__classPrivateFieldGet3(this, _SqliteWasmDriver_db, "f")));
    if (__classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").onCreateConnection) {
      await __classPrivateFieldGet3(this, _SqliteWasmDriver_config, "f").onCreateConnection(__classPrivateFieldGet3(this, _SqliteWasmDriver_connection, "f"));
    }
  }
  async acquireConnection() {
    await __classPrivateFieldGet3(this, _SqliteWasmDriver_connectionMutex, "f").lock();
    return __classPrivateFieldGet3(this, _SqliteWasmDriver_connection, "f");
  }
  async beginTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async releaseConnection() {
    __classPrivateFieldGet3(this, _SqliteWasmDriver_connectionMutex, "f").unlock();
  }
  async destroy() {
    var _a;
    (_a = __classPrivateFieldGet3(this, _SqliteWasmDriver_db, "f")) == null ? void 0 : _a.close();
  }
};
_SqliteWasmDriver_config = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_connectionMutex = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_db = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_connection = /* @__PURE__ */ new WeakMap();

// ../sqlite-wasm-kysely/dist/dialect.js
var createDialect = (args) => {
  return {
    createAdapter: () => new SqliteAdapter(),
    createDriver: () => new SqliteWasmDriver({
      database: args.database
    }),
    createIntrospector: (db) => new SqliteIntrospector(db),
    createQueryCompiler: () => new SqliteQueryCompiler()
  };
};

// ../lix-sdk/src/database/init-db.ts
var import_human_id3 = __toESM(require_dist());

// ../lix-sdk/src/database/kysely-plugin/json-column-plugin.ts
function JSONColumnPlugin(jsonColumns) {
  const jsonColumnNames = Object.keys(jsonColumns).flatMap(
    (key) => jsonColumns[key]
  );
  return {
    transformResult: async (args) => {
      for (const row of args.result.rows) {
        for (const col of jsonColumnNames) {
          const text = row[col];
          try {
            row[col] = JSON.parse(text);
          } catch (e) {
            continue;
          }
        }
      }
      return args.result;
    },
    transformQuery(args) {
      if (args.node.kind === "InsertQueryNode") {
        const tableNode = args.node.into;
        const table = tableNode && tableNode.kind === "TableNode" ? tableNode.table.identifier.name : void 0;
        const columns = args.node.columns;
        const transformer = new SerializeJsonbTransformer(
          jsonColumns,
          table,
          columns
        );
        return transformer.transformNode(args.node);
      }
      if (args.node.kind === "UpdateQueryNode") {
        const tableNode = args.node.table;
        let table = void 0;
        if (tableNode && tableNode.kind === "TableNode") {
          table = tableNode.table.identifier.name;
        }
        const transformer = new SerializeJsonbTransformer(
          jsonColumns,
          table,
          void 0
        );
        return transformer.transformNode(args.node);
      }
      return args.node;
    }
  };
}
var SerializeJsonbTransformer = class extends OperationNodeTransformer {
  constructor(jsonbColumns, table, columns) {
    super();
    __publicField(this, "jsonbColumns");
    __publicField(this, "table");
    __publicField(this, "columns");
    this.jsonbColumns = jsonbColumns;
    this.table = table;
    this.columns = columns;
  }
  isJsonbColumn(columnName) {
    var _a, _b;
    if (!this.table || !columnName) return false;
    return (_b = (_a = this.jsonbColumns[this.table]) == null ? void 0 : _a.includes(columnName)) != null ? _b : false;
  }
  transformOnConflict(node) {
    if (!node.updates) {
      return node;
    }
    const newUpdates = node.updates.map((updateItem) => {
      if (updateItem.kind === "ColumnUpdateNode") {
        const columnName = updateItem.column.column.name;
        if (this.isJsonbColumn(columnName)) {
          const valueNode = updateItem.value;
          if (valueNode.kind === "ValueNode") {
            return {
              ...updateItem,
              // @ts-expect-error - kysely type narrowing
              value: this.serializeValue(valueNode)
            };
          }
        }
      }
      return updateItem;
    });
    return {
      ...node,
      updates: newUpdates
    };
  }
  transformNode(node) {
    if (!node) {
      return node;
    }
    return super.transformNode(node);
  }
  // Serialize JSONB values in updates for ColumnUpdateNodes
  transformColumnUpdate(node) {
    const columnName = node.column.column.name;
    if (this.isJsonbColumn(columnName)) {
      return {
        ...node,
        // @ts-expect-error - kysely type narrowing
        value: this.serializeValue(node.value)
      };
    }
    return super.transformColumnUpdate(node);
  }
  // Support .set("col", value) syntax (SetOperationNode)
  transformSetOperation(node) {
    var _a, _b;
    const columnName = (_b = (_a = node.column) == null ? void 0 : _a.column) == null ? void 0 : _b.name;
    if (columnName && this.isJsonbColumn(columnName)) {
      return {
        ...node,
        value: this.serializeValue(node.value)
      };
    }
    return super.transformSetOperation(node);
  }
  transformValues(node) {
    const newValues = node.values.map((row) => {
      if (row.kind === "PrimitiveValueListNode") {
        const newValueNodes = row.values.map((val, idx) => {
          var _a;
          const colNode = (_a = this.columns) == null ? void 0 : _a[idx];
          const valNode = { kind: "ValueNode", value: val };
          if ((colNode == null ? void 0 : colNode.kind) === "ColumnNode" && this.isJsonbColumn(colNode.column.name)) {
            return this.serializeValue(valNode);
          }
          return valNode;
        });
        return {
          kind: "ValueListNode",
          values: newValueNodes
        };
      }
      if (row.kind === "ValueListNode") {
        const newValuesList = row.values.map((valNode, idx) => {
          var _a;
          const colNode = (_a = this.columns) == null ? void 0 : _a[idx];
          if ((colNode == null ? void 0 : colNode.kind) === "ColumnNode" && this.isJsonbColumn(colNode.column.name)) {
            return this.serializeValue(valNode);
          }
          return valNode;
        });
        return { ...row, values: newValuesList };
      }
      return row;
    });
    return { ...node, values: newValues };
  }
  serializeValue(node) {
    const val = node.value;
    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || val === null) {
      return node;
    }
    const jsonText = JSON.stringify(val);
    return {
      kind: "FunctionNode",
      func: "json",
      arguments: [{ kind: "ValueNode", value: jsonText }]
    };
  }
};

// ../lix-sdk/src/database/kysely-plugin/view-insert-returning-error-plugin.ts
var ViewInsertReturningErrorPlugin = class {
  constructor(viewNames) {
    __publicField(this, "viewNames");
    this.viewNames = new Set(viewNames);
  }
  transformQuery(args) {
    var _a;
    const { node } = args;
    if (node.kind === "InsertQueryNode") {
      const tableName = (_a = node.into) == null ? void 0 : _a.table.identifier.name;
      if (tableName && this.viewNames.has(tableName) && node.returning) {
        throw new Error(
          `Cannot use returning() or returningAll() with INSERT operations on view '${tableName}'. Views do not support returning clauses in INSERT statements. Use a separate SELECT query after the INSERT to retrieve the data.`
        );
      }
    }
    return node;
  }
  async transformResult(args) {
    return args.result;
  }
};

// ../lix-sdk/src/state/validate-state-mutation.ts
var import_ajv = __toESM(require_ajv());

// ../lix-sdk/src/schema-definition/definition.ts
var LixSchemaDefinition = {
  $schema: "http://json-schema.org/draft-07/schema#",
  title: "Lix Change Schema",
  description: "A JSON schema document that also includes custom x-key and x-version properties for identification and versioning.",
  allOf: [
    {
      $ref: "http://json-schema.org/draft-07/schema#"
    },
    {
      type: "object",
      properties: {
        "x-lix-unique": {
          type: "array",
          items: {
            type: "array",
            items: {
              type: "string"
            }
          }
        },
        "x-primary-key": {
          type: "array",
          items: {
            type: "string"
          }
        },
        "x-lix-foreign-keys": {
          type: "object",
          additionalProperties: {
            type: "object",
            properties: {
              schemaKey: {
                type: "string",
                description: "The x-lix-key of the referenced schema"
              },
              property: {
                type: "string",
                description: "The property name in the referenced schema"
              },
              schemaVersion: {
                type: "string",
                pattern: "^\\d+\\.\\d+$",
                description: "Optional version of the referenced schema"
              }
            },
            required: ["schemaKey", "property"]
          }
        },
        "x-lix-key": {
          type: "string",
          description: "The key of the schema. The key is used to identify the schema. You must use a unique key for each schema.",
          examples: ["csv_plugin_cell"]
        },
        "x-lix-version": {
          type: "string",
          description: "The version of the schema. Use the major version to signal breaking changes. Use the minor version to signal non-breaking changes.",
          pattern: "^\\d+\\.\\d+$",
          examples: ["1.0"]
        },
        properties: {
          type: "object",
          additionalProperties: {
            allOf: [
              { $ref: "http://json-schema.org/draft-07/schema#" },
              {
                type: "object",
                properties: {
                  "x-lix-generated": {
                    type: "boolean",
                    description: "Whether this property is auto-generated by the database"
                  }
                }
              }
            ]
          }
        }
      },
      required: ["x-lix-key", "x-lix-version"]
    }
  ]
};

// ../lix-sdk/src/state/validate-state-mutation.ts
var ajv = new import_ajv.Ajv({
  strict: true,
  // allow 'x-*' properties in alignment with new json schema spec
  // https://json-schema.org/blog/posts/stable-json-schema
  strictSchema: false
});
var validateLixSchema = ajv.compile(LixSchemaDefinition);
function validateStateMutation(args) {
  var _a;
  if (!args.schema) {
    return;
  }
  if (!args.version_id) {
    throw new Error("version_id is required");
  }
  const existingVersion = executeSync({
    lix: args.lix,
    query: args.lix.db.selectFrom("version").select("id").where("id", "=", args.version_id)
    // .where("version.lixcol_version_id", "=", args.version_id),
  });
  if (existingVersion.length === 0) {
    throw new Error(`Version with id '${args.version_id}' does not exist`);
  }
  const isValidLixSchema = validateLixSchema(args.schema);
  if (!isValidLixSchema) {
    throw new Error(
      `The provided schema is not a valid lix schema: ${ajv.errorsText(validateLixSchema.errors)}`
    );
  }
  if (args.operation !== "delete") {
    const parsedSnapshotContent = parseJsonPropertiesInSnapshotContent(
      args.snapshot_content,
      args.schema
    );
    const isValidSnapshotContent = ajv.validate(
      args.schema,
      parsedSnapshotContent
    );
    if (!isValidSnapshotContent) {
      const errorDetails = (_a = ajv.errors) == null ? void 0 : _a.map((error) => {
        const receivedValue = error.instancePath ? getValueByPath(parsedSnapshotContent, error.instancePath) : parsedSnapshotContent;
        return `${error.instancePath} ${error.message}. Received value: ${JSON.stringify(receivedValue)}`;
      }).join("; ");
      throw new Error(
        `The provided snapshot content does not match the schema '${args.schema["x-lix-key"]}' (${args.schema["x-lix-version"]}).

 ${errorDetails || ajv.errorsText(ajv.errors)}`
      );
    }
  }
  if (args.operation === "delete") {
    validateDeletionConstraints({
      lix: args.lix,
      schema: args.schema,
      entity_id: args.entity_id,
      version_id: args.version_id
    });
  } else {
    if (args.schema["x-lix-primary-key"]) {
      validatePrimaryKeyConstraints({
        lix: args.lix,
        schema: args.schema,
        snapshot_content: args.snapshot_content,
        operation: args.operation,
        entity_id: args.entity_id,
        version_id: args.version_id
      });
    }
    if (args.schema["x-lix-unique"]) {
      validateUniqueConstraints({
        lix: args.lix,
        schema: args.schema,
        snapshot_content: args.snapshot_content,
        operation: args.operation,
        entity_id: args.entity_id,
        version_id: args.version_id
      });
    }
    if (args.schema["x-lix-foreign-keys"]) {
      validateForeignKeyConstraints({
        lix: args.lix,
        schema: args.schema,
        snapshot_content: args.snapshot_content,
        version_id: args.version_id,
        untracked: args.untracked
      });
    }
  }
  if (args.schema["x-lix-key"] === "lix_change_set_edge") {
    const content = args.snapshot_content;
    if (content.parent_id === content.child_id) {
      throw new Error(
        "Self-referencing edges are not allowed: parent_id cannot equal child_id"
      );
    }
    if (args.operation === "insert") {
      const debugEnabled = executeSync({
        lix: args.lix,
        query: args.lix.db.selectFrom("key_value_all").select("value").where("key", "=", "lix_debug").where("value", "=", "true")
      });
      if (debugEnabled.length > 0 && debugEnabled[0].value === "true") {
        validateChangeSetGraphAcyclic({
          lix: args.lix,
          newEdge: content,
          version_id: args.version_id
        });
      }
    }
  }
}
function validatePrimaryKeyConstraints(args) {
  const primaryKeyFields = args.schema["x-lix-primary-key"];
  if (!primaryKeyFields || primaryKeyFields.length === 0) {
    return;
  }
  const primaryKeyValues = [];
  for (const field of primaryKeyFields) {
    const value = args.snapshot_content[field];
    if (value === void 0 || value === null) {
      throw new Error(
        `Primary key field '${field}' cannot be null or undefined`
      );
    }
    primaryKeyValues.push(value);
  }
  let query = args.lix.db.selectFrom("state_all").select("snapshot_content").where("schema_key", "=", args.schema["x-lix-key"]).where("version_id", "=", args.version_id);
  if (args.operation === "update" && args.entity_id) {
    query = query.where("entity_id", "!=", args.entity_id);
  }
  for (let i = 0; i < primaryKeyFields.length; i++) {
    const field = primaryKeyFields[i];
    const value = primaryKeyValues[i];
    query = query.where(
      sql`json_extract(snapshot_content, '$.' || ${field})`,
      "=",
      value
    );
  }
  const existingStates = executeSync({ lix: args.lix, query });
  if (existingStates.length > 0) {
    const fieldNames = primaryKeyFields.join(", ");
    const fieldValues = primaryKeyValues.map((v2) => `'${v2}'`).join(", ");
    throw new Error(
      `Primary key constraint violation: The primary key constraint on (${fieldNames}) is violated by values (${fieldValues})`
    );
  }
}
function validateUniqueConstraints(args) {
  const uniqueConstraints = args.schema["x-lix-unique"];
  if (!uniqueConstraints || uniqueConstraints.length === 0) {
    return;
  }
  for (const uniqueFields of uniqueConstraints) {
    if (!uniqueFields || uniqueFields.length === 0) {
      continue;
    }
    const uniqueValues = [];
    for (const field of uniqueFields) {
      const value = args.snapshot_content[field];
      if (value === void 0 || value === null) {
        continue;
      }
      uniqueValues.push(value);
    }
    if (uniqueValues.length !== uniqueFields.length) {
      continue;
    }
    let query = args.lix.db.selectFrom("state_all").select("snapshot_content").where("schema_key", "=", args.schema["x-lix-key"]).where("version_id", "=", args.version_id);
    if (args.operation === "update" && args.entity_id) {
      query = query.where("entity_id", "!=", args.entity_id);
    }
    for (let i = 0; i < uniqueFields.length; i++) {
      const field = uniqueFields[i];
      const value = uniqueValues[i];
      query = query.where(
        sql`json_extract(snapshot_content, '$.' || ${field})`,
        "=",
        value
      );
    }
    const existingStates = executeSync({ lix: args.lix, query });
    if (existingStates.length > 0) {
      const fieldNames = uniqueFields.join(", ");
      const fieldValues = uniqueValues.map((v2) => `'${v2}'`).join(", ");
      throw new Error(
        `Unique constraint violation: The unique constraint on (${fieldNames}) is violated by values (${fieldValues})`
      );
    }
  }
}
function getValueByPath(obj, path) {
  if (!path) return obj;
  const parts = path.split("/").filter((part) => part);
  let current = obj;
  for (const part of parts) {
    if (current === void 0 || current === null) return void 0;
    current = current[part];
  }
  return current;
}
function validateForeignKeyConstraints(args) {
  const foreignKeys = args.schema["x-lix-foreign-keys"];
  if (!foreignKeys) {
    return;
  }
  for (const [localProperty, foreignKeyDef] of Object.entries(foreignKeys)) {
    const foreignKeyValue = args.snapshot_content[localProperty];
    if (foreignKeyValue === null || foreignKeyValue === void 0) {
      continue;
    }
    const isRealSqlTable = ["lix_change"].includes(foreignKeyDef.schemaKey);
    let query;
    if (isRealSqlTable) {
      const tableName = foreignKeyDef.schemaKey === "lix_change" ? "change" : foreignKeyDef.schemaKey;
      query = args.lix.db.selectFrom(tableName).select(foreignKeyDef.property).where(foreignKeyDef.property, "=", foreignKeyValue);
    } else {
      query = args.lix.db.selectFrom("state_all").select("snapshot_content").where("schema_key", "=", foreignKeyDef.schemaKey).where(
        sql`json_extract(snapshot_content, '$.' || ${foreignKeyDef.property})`,
        "=",
        foreignKeyValue
      );
    }
    if (foreignKeyDef.schemaVersion && !isRealSqlTable) {
      const referencedSchema = executeSync({
        lix: args.lix,
        query: args.lix.db.selectFrom("stored_schema").select("value").where(
          sql`json_extract(value, '$.["x-lix-key"]')`,
          "=",
          foreignKeyDef.schemaKey
        ).where(
          sql`json_extract(value, '$.["x-lix-version"]')`,
          "=",
          foreignKeyDef.schemaVersion
        )
      });
      if (referencedSchema.length === 0) {
        throw new Error(
          `Foreign key constraint violation. Referenced schema '${foreignKeyDef.schemaKey}' with version '${foreignKeyDef.schemaVersion}' does not exist.`
        );
      }
    }
    const referencedStates = executeSync({
      lix: args.lix,
      query: isRealSqlTable ? query : query.where("version_id", "=", args.version_id).where("inherited_from_version_id", "is", null)
    });
    if (referencedStates.length === 0) {
      const versionInfo = executeSync({
        lix: args.lix,
        query: args.lix.db.selectFrom("version").select("name").where("id", "=", args.version_id)
      });
      const versionName = versionInfo.length > 0 ? versionInfo[0].name : "unknown";
      let errorMessage = `Foreign key constraint violation. The schema '${args.schema["x-lix-key"]}' (${args.schema["x-lix-version"]}) has a foreign key constraint on '${localProperty}' referencing '${foreignKeyDef.schemaKey}.${foreignKeyDef.property}' but no matching record exists with value '${foreignKeyValue}' in version '${args.version_id}' (${versionName}).`;
      errorMessage += `

Foreign Key Relationship:
`;
      errorMessage += `  ${args.schema["x-lix-key"]}.${localProperty} \u2192 ${foreignKeyDef.schemaKey}.${foreignKeyDef.property}
`;
      const truncateValue = (value, maxLength = 40) => {
        const str = typeof value === "string" ? value : JSON.stringify(value);
        return str.length > maxLength ? str.substring(0, maxLength - 3) + "..." : str;
      };
      errorMessage += `
Entity Being Inserted (${args.schema["x-lix-key"]}):
`;
      errorMessage += `\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
      errorMessage += `\u2502 Property        \u2502 Value                                    \u2502
`;
      errorMessage += `\u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
`;
      const content = args.snapshot_content;
      for (const [prop, value] of Object.entries(content)) {
        const propDisplay = prop.substring(0, 15).padEnd(15);
        const valueDisplay = truncateValue(value, 40).padEnd(40);
        errorMessage += `\u2502 ${propDisplay} \u2502 ${valueDisplay} \u2502
`;
      }
      errorMessage += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518
`;
      errorMessage += `
Note: Foreign key constraints only validate entities that exist in the version context. Inherited entities from other versions cannot be referenced by foreign keys. If you reference global state, ensure that you are creating the entity in the global version.`;
      throw new Error(errorMessage);
    }
    if (!args.untracked && !isRealSqlTable) {
      const untrackedReferences = executeSync({
        lix: args.lix,
        query: args.lix.db.selectFrom("state_all").select("entity_id").where("schema_key", "=", foreignKeyDef.schemaKey).where("version_id", "=", args.version_id).where("untracked", "=", true).where(
          sql`json_extract(snapshot_content, '$.' || ${foreignKeyDef.property})`,
          "=",
          foreignKeyValue
        )
      });
      if (untrackedReferences.length > 0) {
        let errorMessage = `Foreign key constraint violation: tracked entities cannot reference untracked entities. This would create broken references during sync.
`;
        errorMessage += `
The tracked entity '${args.schema["x-lix-key"]}' is trying to reference an untracked entity '${foreignKeyDef.schemaKey}' with ${foreignKeyDef.property}='${foreignKeyValue}'.
`;
        errorMessage += `
Untracked entities are local-only and will not be synced to remote. If a tracked entity references an untracked entity, it would fail validation on the remote because the untracked entity doesn't exist there.
`;
        errorMessage += `
Solutions:
`;
        errorMessage += `1. Make the referenced entity tracked (remove untracked flag)
`;
        errorMessage += `2. Make the referencing entity untracked as well
`;
        errorMessage += `3. Remove the foreign key reference`;
        throw new Error(errorMessage);
      }
    }
  }
}
function validateDeletionConstraints(args) {
  if (!args.entity_id) {
    throw new Error("entity_id is required for delete operations");
  }
  const currentEntity = executeSync({
    lix: args.lix,
    query: args.lix.db.selectFrom("state_all").select(["snapshot_content", "inherited_from_version_id", "version_id"]).where("entity_id", "=", args.entity_id).where("schema_key", "=", args.schema["x-lix-key"]).where("version_id", "=", args.version_id)
  });
  if (currentEntity.length === 0) {
    let errorMessage = `Entity deletion failed. Cannot delete entity '${args.entity_id}' from schema '${args.schema["x-lix-key"]}' (${args.schema["x-lix-version"]}) in version '${args.version_id}' because the entity does not exist.`;
    errorMessage += `

Deletion Context:
`;
    errorMessage += `\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
    errorMessage += `\u2502 Property        \u2502 Value                                \u2502
`;
    errorMessage += `\u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
`;
    errorMessage += `\u2502 Entity ID       \u2502 ${(args.entity_id || "undefined").substring(0, 36).padEnd(36)} \u2502
`;
    errorMessage += `\u2502 Schema Key      \u2502 ${args.schema["x-lix-key"].substring(0, 36).padEnd(36)} \u2502
`;
    errorMessage += `\u2502 Schema Version  \u2502 ${(args.schema["x-lix-version"] || "undefined").substring(0, 36).padEnd(36)} \u2502
`;
    errorMessage += `\u2502 Version ID      \u2502 ${args.version_id.substring(0, 36).padEnd(36)} \u2502
`;
    errorMessage += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518
`;
    const entityInOtherVersions = executeSync({
      lix: args.lix,
      query: args.lix.db.selectFrom("state_all").select(["version_id", "snapshot_content", "inherited_from_version_id"]).where("entity_id", "=", args.entity_id).where("schema_key", "=", args.schema["x-lix-key"])
    });
    if (entityInOtherVersions.length > 0) {
      errorMessage += `
Entity Search Results (${args.schema["x-lix-key"]}):
`;
      errorMessage += `\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
      errorMessage += `\u2502 Version             \u2502 Entity Found   \u2502 Entity Content                           \u2502
`;
      errorMessage += `\u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
`;
      const truncateValue = (value, maxLength = 40) => {
        const str = typeof value === "string" ? value : JSON.stringify(value);
        return str.length > maxLength ? str.substring(0, maxLength - 3) + "..." : str;
      };
      errorMessage += `\u2502 ${args.version_id.substring(0, 19).padEnd(19)} \u2502 ${"No".padEnd(14)} \u2502 ${"-".padEnd(40)} \u2502
`;
      for (const state of entityInOtherVersions) {
        if (state.version_id && state.version_id !== args.version_id) {
          const versionDisplay = state.version_id.substring(0, 19).padEnd(19);
          const contentDisplay = truncateValue(
            state.snapshot_content,
            40
          ).padEnd(40);
          errorMessage += `\u2502 ${versionDisplay} \u2502 ${"Yes".padEnd(14)} \u2502 ${contentDisplay} \u2502
`;
        }
      }
      errorMessage += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518
`;
      errorMessage += `
The entity exists in other version(s) but is not accessible in '${args.version_id}'. Check version inheritance configuration.`;
    } else {
      errorMessage += `
The entity with ID '${args.entity_id}' does not exist in any version for schema '${args.schema["x-lix-key"]}'.`;
    }
    throw new Error(errorMessage);
  }
  const allSchemas = executeSync({
    lix: args.lix,
    query: args.lix.db.selectFrom("stored_schema").selectAll()
  });
  for (const storedSchema of allSchemas) {
    const schema = typeof storedSchema.value === "string" ? JSON.parse(storedSchema.value) : storedSchema.value;
    if (!schema["x-lix-foreign-keys"]) {
      continue;
    }
    for (const [localProperty, foreignKeyDef] of Object.entries(
      schema["x-lix-foreign-keys"]
    )) {
      if (foreignKeyDef.schemaKey !== args.schema["x-lix-key"]) {
        continue;
      }
      const rawContent = currentEntity[0].snapshot_content;
      const entityContent = typeof rawContent === "string" ? JSON.parse(rawContent) : rawContent;
      const referencedValue = entityContent[foreignKeyDef.property];
      if (referencedValue === null || referencedValue === void 0) {
        continue;
      }
      const referencingEntities = executeSync({
        lix: args.lix,
        query: args.lix.db.selectFrom("state_all").select("entity_id").where("schema_key", "=", schema["x-lix-key"]).where("version_id", "=", args.version_id).where(
          sql`json_extract(snapshot_content, '$.' || ${localProperty})`,
          "=",
          referencedValue
        )
      });
      if (referencingEntities.length > 0) {
        throw new Error(
          `Foreign key constraint violation: Cannot delete entity because it is referenced by ${referencingEntities.length} record(s) in schema '${schema["x-lix-key"]}' via foreign key '${localProperty}'`
        );
      }
    }
  }
}
function parseJsonPropertiesInSnapshotContent(snapshotContent, schema) {
  if (!schema.properties || typeof snapshotContent !== "object" || snapshotContent === null) {
    return snapshotContent;
  }
  const parsed = { ...snapshotContent };
  for (const [propertyName, propertySchema] of Object.entries(
    schema.properties
  )) {
    const value = parsed[propertyName];
    if (value === void 0 || value === null || typeof value === "object") {
      continue;
    }
    if (typeof propertySchema === "object" && propertySchema && propertySchema.type === "object") {
      if (typeof value === "string") {
        try {
          parsed[propertyName] = JSON.parse(value);
        } catch (error) {
          throw new Error(
            `Invalid JSON in property '${propertyName}': ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }
    }
    if (typeof propertySchema === "object" && propertySchema && propertySchema.type === "boolean") {
      if (typeof value === "number") {
        parsed[propertyName] = value === 1;
      }
    }
  }
  return parsed;
}
function validateChangeSetGraphAcyclic(args) {
  const existingEdges = executeSync({
    lix: args.lix,
    query: args.lix.db.selectFrom("change_set_edge_all").select(["parent_id", "child_id"]).where("lixcol_version_id", "=", args.version_id)
  });
  const adjacencyList = /* @__PURE__ */ new Map();
  for (const edge of existingEdges) {
    if (!adjacencyList.has(edge.parent_id)) {
      adjacencyList.set(edge.parent_id, []);
    }
    adjacencyList.get(edge.parent_id).push(edge.child_id);
  }
  if (!adjacencyList.has(args.newEdge.parent_id)) {
    adjacencyList.set(args.newEdge.parent_id, []);
  }
  adjacencyList.get(args.newEdge.parent_id).push(args.newEdge.child_id);
  const visited = /* @__PURE__ */ new Set();
  const recursionStack = /* @__PURE__ */ new Set();
  function hasCycle(node, path = []) {
    visited.add(node);
    recursionStack.add(node);
    path.push(node);
    const neighbors = adjacencyList.get(node) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        if (hasCycle(neighbor, [...path])) {
          return true;
        }
      } else if (recursionStack.has(neighbor)) {
        const cycleStart = path.indexOf(neighbor);
        const cyclePath = [...path.slice(cycleStart), neighbor];
        throw new Error(
          `Cycle detected in change set graph!
New edge: ${args.newEdge.parent_id} -> ${args.newEdge.child_id}
Cycle path: ${cyclePath.join(" -> ")}
Adding this edge would create a cycle in the graph.`
        );
      }
    }
    recursionStack.delete(node);
    return false;
  }
  for (const node of adjacencyList.keys()) {
    if (!visited.has(node)) {
      hasCycle(node);
    }
  }
}

// ../lix-sdk/src/state/handle-state-mutation.ts
function handleStateMutation(sqlite, db, entity_id, schema_key, file_id, plugin_key, snapshot_content, version_id, schema_version) {
  var _a;
  const currentTime = (/* @__PURE__ */ new Date()).toISOString();
  if (snapshot_content === null || snapshot_content === "null") {
    const entityInCurrentVersion = executeSync({
      lix: { sqlite },
      query: db.selectFrom("internal_state_cache").where("entity_id", "=", entity_id).where("schema_key", "=", schema_key).where("file_id", "=", file_id).where("version_id", "=", version_id).select(["inherited_from_version_id"])
    });
    if (entityInCurrentVersion.length === 0) {
      const versionInfo = executeSync({
        lix: { sqlite },
        query: db.selectFrom("internal_state_cache").where("schema_key", "=", "lix_version").where("entity_id", "=", version_id).select(["snapshot_content"])
      });
      if (versionInfo.length > 0) {
        const versionData = JSON.parse(versionInfo[0].snapshot_content);
        const parentVersionId = versionData.inherits_from_version_id;
        if (parentVersionId) {
          const parentEntity = executeSync({
            lix: { sqlite },
            query: db.selectFrom("internal_state_cache").where("entity_id", "=", entity_id).where("schema_key", "=", schema_key).where("file_id", "=", file_id).where("version_id", "=", parentVersionId).select(["snapshot_content"])
          });
          if (parentEntity.length > 0) {
            snapshot_content = null;
            executeSync({
              lix: { sqlite },
              query: db.insertInto("internal_state_cache").values({
                entity_id,
                schema_key,
                file_id,
                version_id,
                plugin_key,
                snapshot_content: null,
                // NULL indicates deletion
                schema_version,
                created_at: currentTime,
                updated_at: currentTime,
                inherited_from_version_id: null,
                // Local entity, not inherited
                inheritance_delete_marker: 1,
                // Flag as copy-on-write deletion marker
                // delete markers are never materialized, so we use a placeholder
                change_id: "delete-marker-no-change-id"
              }).onConflict(
                (oc) => oc.columns([
                  "entity_id",
                  "schema_key",
                  "file_id",
                  "version_id"
                ]).doUpdateSet({
                  plugin_key,
                  snapshot_content: null,
                  schema_version,
                  updated_at: currentTime,
                  inherited_from_version_id: null,
                  inheritance_delete_marker: 1,
                  // delete markers are never materialized, so we use a placeholder
                  change_id: "delete-marker-no-change-id"
                })
              )
            });
          }
        }
      }
    } else if (((_a = entityInCurrentVersion[0]) == null ? void 0 : _a.inherited_from_version_id) !== null) {
      executeSync({
        lix: { sqlite },
        query: db.insertInto("internal_state_cache").values({
          entity_id,
          schema_key,
          file_id,
          version_id,
          plugin_key,
          snapshot_content: null,
          // NULL indicates deletion
          schema_version,
          created_at: currentTime,
          updated_at: currentTime,
          inherited_from_version_id: null,
          // Local entity, not inherited
          inheritance_delete_marker: 1,
          // Flag as copy-on-write deletion marker
          // delete markers are never materialized, so we use a placeholder
          change_id: "delete-marker-no-change-id"
        }).onConflict(
          (oc) => oc.columns(["entity_id", "schema_key", "file_id", "version_id"]).doUpdateSet({
            plugin_key,
            snapshot_content: null,
            schema_version,
            updated_at: currentTime,
            inherited_from_version_id: null,
            inheritance_delete_marker: 1,
            // delete markers are never materialized, so we use a placeholder
            change_id: "delete-marker-no-change-id"
          })
        )
      });
    }
  }
  createChangeWithSnapshot({
    sqlite,
    db,
    data: {
      entity_id,
      schema_key,
      file_id,
      plugin_key,
      snapshot_content,
      schema_version
    },
    timestamp: currentTime,
    version_id
  });
  return 0;
}
function createChangeWithSnapshot(args) {
  const [change] = executeSync({
    lix: { sqlite: args.sqlite },
    query: args.db.insertInto("internal_change_in_transaction").values({
      id: args.id,
      entity_id: args.data.entity_id,
      schema_key: args.data.schema_key,
      snapshot_content: args.data.snapshot_content ? sql`jsonb(${args.data.snapshot_content})` : null,
      file_id: args.data.file_id,
      plugin_key: args.data.plugin_key,
      version_id: args.version_id,
      created_at: args.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
      schema_version: args.data.schema_version
    }).onConflict(
      (oc) => (
        // we assume that a conflic is always on the unique constraint of entity_id, file_id, schema_key, version_id
        oc.doUpdateSet({
          id: args.id,
          entity_id: args.data.entity_id,
          schema_key: args.data.schema_key,
          snapshot_content: args.data.snapshot_content ? sql`jsonb(${args.data.snapshot_content})` : null,
          file_id: args.data.file_id,
          plugin_key: args.data.plugin_key,
          version_id: args.version_id,
          created_at: args.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
          schema_version: args.data.schema_version
        })
      )
    ).returning(["id", "schema_key", "file_id", "entity_id"])
  });
  if (args.version_id) {
    updateStateCache({
      sqlite: args.sqlite,
      db: args.db,
      entity_id: args.data.entity_id,
      schema_key: args.data.schema_key,
      file_id: args.data.file_id,
      version_id: args.version_id,
      plugin_key: args.data.plugin_key,
      snapshot_content: args.data.snapshot_content,
      schema_version: args.data.schema_version,
      timestamp: args.timestamp || (/* @__PURE__ */ new Date()).toISOString(),
      change_id: change.id
    });
  }
  return change;
}
function updateStateCache(args) {
  var _a, _b;
  const resolvedChangeId = args.change_id || (() => {
    const transactionRecord = executeSync({
      lix: { sqlite: args.sqlite },
      query: args.db.selectFrom("internal_change_in_transaction").where("entity_id", "=", args.entity_id).where("schema_key", "=", args.schema_key).where("file_id", "=", args.file_id).where("version_id", "=", args.version_id).select(["id"]).limit(1)
    });
    return transactionRecord.length > 0 ? transactionRecord[0].id : "no-transaction-change-id";
  })();
  if (args.snapshot_content === null) {
    const existingEntity = executeSync({
      lix: { sqlite: args.sqlite },
      query: args.db.selectFrom("internal_state_cache").where("entity_id", "=", args.entity_id).where("schema_key", "=", args.schema_key).where("file_id", "=", args.file_id).where("version_id", "=", args.version_id).select(["inherited_from_version_id", "inheritance_delete_marker"])
    });
    const isAlreadyDeletionMarker = existingEntity.length > 0 && ((_a = existingEntity[0]) == null ? void 0 : _a.inheritance_delete_marker) === 1;
    if (existingEntity.length > 0 && (((_b = existingEntity[0]) == null ? void 0 : _b.inherited_from_version_id) !== null || isAlreadyDeletionMarker)) {
      executeSync({
        lix: { sqlite: args.sqlite },
        query: args.db.insertInto("internal_state_cache").values({
          entity_id: args.entity_id,
          schema_key: args.schema_key,
          file_id: args.file_id,
          version_id: args.version_id,
          plugin_key: args.plugin_key,
          snapshot_content: null,
          // NULL indicates deletion
          schema_version: args.schema_version,
          created_at: args.timestamp,
          updated_at: args.timestamp,
          inherited_from_version_id: null,
          // Local entity, not inherited
          inheritance_delete_marker: 1,
          // Flag as deletion marker
          change_id: resolvedChangeId
        }).onConflict(
          (oc) => oc.columns(["entity_id", "schema_key", "file_id", "version_id"]).doUpdateSet({
            plugin_key: args.plugin_key,
            snapshot_content: null,
            schema_version: args.schema_version,
            updated_at: args.timestamp,
            inherited_from_version_id: null,
            inheritance_delete_marker: 1,
            change_id: resolvedChangeId
          })
        )
      });
    } else {
      executeSync({
        lix: { sqlite: args.sqlite },
        query: args.db.deleteFrom("internal_state_cache").where("entity_id", "=", args.entity_id).where("schema_key", "=", args.schema_key).where("file_id", "=", args.file_id).where("version_id", "=", args.version_id)
      });
    }
    return;
  }
  executeSync({
    lix: { sqlite: args.sqlite },
    query: args.db.insertInto("internal_state_cache").values({
      entity_id: args.entity_id,
      schema_key: args.schema_key,
      file_id: args.file_id,
      version_id: args.version_id,
      plugin_key: args.plugin_key,
      snapshot_content: args.snapshot_content,
      schema_version: args.schema_version,
      created_at: args.timestamp,
      updated_at: args.timestamp,
      inherited_from_version_id: null,
      // Direct entities are not inherited
      inheritance_delete_marker: 0,
      // Not a deletion marker
      change_id: args.change_id || "no-change-id"
    }).onConflict(
      (oc) => oc.columns(["entity_id", "schema_key", "file_id", "version_id"]).doUpdateSet({
        plugin_key: args.plugin_key,
        snapshot_content: args.snapshot_content,
        schema_version: args.schema_version,
        updated_at: args.timestamp,
        inherited_from_version_id: null,
        // Direct entities are not inherited
        inheritance_delete_marker: 0,
        // Not a deletion marker
        change_id: resolvedChangeId
      })
    )
  });
}

// ../lix-sdk/src/query-filter/change-set-has-label.ts
function changeSetHasLabel(label) {
  return (eb) => eb(
    "change_set.id",
    "in",
    (subquery) => subquery.selectFrom("change_set_label").innerJoin("label", "label.id", "change_set_label.label_id").select("change_set_label.change_set_id").$if("name" in label, (eb2) => eb2.where("label.name", "=", label.name)).$if("id" in label, (eb2) => eb2.where("label.id", "=", label.id))
  );
}

// ../lix-sdk/src/query-filter/change-set-is-ancestor-of.ts
function changeSetIsAncestorOf(changeSet, options) {
  var _a;
  const depthLimit = options == null ? void 0 : options.depth;
  const includeSelf = (_a = options == null ? void 0 : options.includeSelf) != null ? _a : false;
  return () => sql`
			change_set.id IN (
				WITH RECURSIVE ap(id, depth) AS (
					SELECT id, 0 AS depth FROM change_set WHERE id = ${sql.lit(changeSet.id)}
					UNION ALL
					SELECT change_set_edge.parent_id, ap.depth + 1
					FROM change_set_edge
					JOIN ap ON change_set_edge.child_id = ap.id
					${depthLimit !== void 0 ? sql`WHERE ap.depth < ${sql.lit(depthLimit)}` : sql``}
				)
				-- Select based on the includeSelf flag
				SELECT id FROM ap ${includeSelf ? sql`` : sql`WHERE depth > 0`}
			)
		`;
}

// ../lix-sdk/src/state/get-version-record-by-id-or-throw.ts
function getVersionRecordByIdOrThrow(sqlite, db, version_id) {
  let [versionRecord] = executeSync({
    lix: { sqlite },
    query: db.selectFrom("internal_state_cache").where("schema_key", "=", "lix_version").where("entity_id", "=", version_id).select("snapshot_content as content")
  });
  if (!versionRecord) {
    [versionRecord] = executeSync({
      lix: { sqlite },
      // TODO @samuelstroschein wouldn't we need the view that quieries the union of the temp table and this one?
      query: db.selectFrom("internal_change").innerJoin(
        "internal_snapshot",
        "internal_change.snapshot_id",
        "internal_snapshot.id"
      ).where("internal_change.schema_key", "=", "lix_version").where("internal_change.entity_id", "=", version_id).where("internal_change.snapshot_id", "!=", "no-content").orderBy("internal_change.rowid", "desc").limit(1).select(sql`json(internal_snapshot.content)`.as("content"))
    });
  }
  if (!versionRecord) {
    throw new Error(`Version with id '${version_id}' not found.`);
  }
  return JSON.parse(versionRecord.content);
}

// ../lix-sdk/src/state/create-changeset-for-transaction.ts
function createChangesetForTransaction(sqlite, db, currentTime, version_id, changes) {
  const versionRecord = getVersionRecordByIdOrThrow(sqlite, db, version_id);
  if (!versionRecord) {
    throw new Error(`Version with id '${version_id}' not found.`);
  }
  const mutatedVersion = versionRecord;
  const nextChangeSetId = nanoid();
  const changeSetChange = createChangeWithSnapshot({
    sqlite,
    db,
    data: {
      entity_id: nextChangeSetId,
      schema_key: "lix_change_set",
      file_id: "lix",
      plugin_key: "lix_own_entity",
      snapshot_content: JSON.stringify({
        id: nextChangeSetId,
        metadata: null
      }),
      schema_version: LixChangeSetSchema["x-lix-version"]
    },
    timestamp: currentTime,
    version_id: "global"
    // Always use 'global' for change sets
  });
  const changeSetEdgeChange = createChangeWithSnapshot({
    sqlite,
    db,
    data: {
      entity_id: `${mutatedVersion.change_set_id}::${nextChangeSetId}`,
      schema_key: "lix_change_set_edge",
      file_id: "lix",
      plugin_key: "lix_own_entity",
      snapshot_content: JSON.stringify({
        parent_id: mutatedVersion.change_set_id,
        child_id: nextChangeSetId
      }),
      schema_version: LixChangeSetEdgeSchema["x-lix-version"]
    },
    timestamp: currentTime,
    version_id: "global"
    // Always use 'global' for change set edges
  });
  const changesToProcess = [...changes, changeSetChange, changeSetEdgeChange];
  const versionChange = createChangeWithSnapshot({
    sqlite,
    db,
    data: {
      entity_id: mutatedVersion.id,
      schema_key: "lix_version",
      file_id: "lix",
      plugin_key: "lix_own_entity",
      snapshot_content: JSON.stringify({
        ...mutatedVersion,
        change_set_id: nextChangeSetId
      }),
      schema_version: LixVersionSchema["x-lix-version"]
    },
    timestamp: currentTime,
    version_id: "global"
  });
  changesToProcess.push(versionChange);
  for (const change of changesToProcess) {
    createChangeWithSnapshot({
      sqlite,
      db,
      data: {
        entity_id: `${nextChangeSetId}::${change.id}`,
        schema_key: "lix_change_set_element",
        file_id: "lix",
        plugin_key: "lix_own_entity",
        snapshot_content: JSON.stringify({
          change_set_id: nextChangeSetId,
          change_id: change.id,
          schema_key: change.schema_key,
          file_id: change.file_id,
          entity_id: change.entity_id
        }),
        schema_version: LixChangeSetElementSchema["x-lix-version"]
      },
      timestamp: currentTime,
      version_id: "global"
    });
  }
  for (const change of changes) {
    if (change.schema_key !== "lix_change_set" && change.schema_key !== "lix_change_set_edge" && change.schema_key !== "lix_change_set_element" && change.schema_key !== "lix_version") {
      const parsedSnapshot = change.snapshot_content ? JSON.parse(change.snapshot_content) : null;
      const isDeletion = !parsedSnapshot || parsedSnapshot.snapshot_id === "no-content";
      if (isDeletion) {
        const entityAtCheckpoint = executeSync({
          lix: { sqlite },
          query: db.selectFrom("state_history").where("entity_id", "=", change.entity_id).where("schema_key", "=", change.schema_key).where("file_id", "=", change.file_id).where("depth", "=", 0).where(
            "change_set_id",
            "=",
            // get the previous checkpoint change set
            db.selectFrom("change_set").where(changeSetHasLabel({ name: "checkpoint" })).where(
              changeSetIsAncestorOf(
                { id: mutatedVersion.change_set_id },
                { includeSelf: true, depth: 1 }
              )
            ).select("id")
          ).select("entity_id")
        });
        const entityExistedAtCheckpoint = entityAtCheckpoint.length > 0;
        const toDelete = executeSync({
          lix: { sqlite },
          query: db.selectFrom("state_all").select("rowid").where(
            "entity_id",
            "like",
            `${mutatedVersion.working_change_set_id}::%`
          ).where("schema_key", "=", "lix_change_set_element").where("file_id", "=", "lix").where("version_id", "=", "global").where(
            sql`json_extract(snapshot_content, '$.entity_id')`,
            "=",
            change.entity_id
          ).where(
            sql`json_extract(snapshot_content, '$.schema_key')`,
            "=",
            change.schema_key
          ).where(
            sql`json_extract(snapshot_content, '$.file_id')`,
            "=",
            change.file_id
          )
        });
        if (toDelete.length > 0) {
          handleStateDelete(sqlite, toDelete[0].rowid, db);
        }
        if (entityExistedAtCheckpoint) {
          createChangeWithSnapshot({
            sqlite,
            db,
            data: {
              entity_id: `${mutatedVersion.working_change_set_id}::${change.id}`,
              schema_key: "lix_change_set_element",
              file_id: "lix",
              plugin_key: "lix_own_entity",
              snapshot_content: JSON.stringify({
                change_set_id: mutatedVersion.working_change_set_id,
                change_id: change.id,
                entity_id: change.entity_id,
                schema_key: change.schema_key,
                file_id: change.file_id
              }),
              schema_version: LixChangeSetElementSchema["x-lix-version"]
            },
            timestamp: currentTime,
            version_id: "global"
          });
        }
      } else {
        const toDelete = executeSync({
          lix: { sqlite },
          query: db.selectFrom("state_all").select("rowid").where(
            "entity_id",
            "like",
            `${mutatedVersion.working_change_set_id}::%`
          ).where("schema_key", "=", "lix_change_set_element").where("file_id", "=", "lix").where("version_id", "=", "global").where(
            sql`json_extract(snapshot_content, '$.entity_id')`,
            "=",
            change.entity_id
          ).where(
            sql`json_extract(snapshot_content, '$.schema_key')`,
            "=",
            change.schema_key
          ).where(
            sql`json_extract(snapshot_content, '$.file_id')`,
            "=",
            change.file_id
          )
        });
        if (toDelete.length > 0) {
          handleStateDelete(sqlite, toDelete[0].rowid, db);
        }
        createChangeWithSnapshot({
          sqlite,
          db,
          data: {
            entity_id: `${mutatedVersion.working_change_set_id}::${change.id}`,
            schema_key: "lix_change_set_element",
            file_id: "lix",
            plugin_key: "lix_own_entity",
            snapshot_content: JSON.stringify({
              change_set_id: mutatedVersion.working_change_set_id,
              change_id: change.id,
              entity_id: change.entity_id,
              schema_key: change.schema_key,
              file_id: change.file_id
            }),
            schema_version: LixChangeSetElementSchema["x-lix-version"]
          },
          timestamp: currentTime,
          version_id: "global"
        });
      }
    }
  }
}

// ../lix-sdk/src/state/schema.ts
var VTAB_CREATE_SQL = `CREATE TABLE x(
	entity_id TEXT,
	schema_key TEXT,
	file_id TEXT,
	version_id TEXT,
	plugin_key TEXT,
	snapshot_content TEXT,
	schema_version TEXT,
	created_at TEXT,
	updated_at TEXT,
	inherited_from_version_id TEXT,
	change_id TEXT,
	untracked INTEGER
)`;
function applyStateDatabaseSchema(sqlite, db, hooks) {
  sqlite.createFunction({
    name: "validate_snapshot_content",
    deterministic: true,
    arity: 5,
    // @ts-expect-error - type mismatch
    xFunc: (_ctxPtr, ...args) => {
      return validateStateMutation({
        lix: { sqlite, db },
        schema: args[0] ? JSON.parse(args[0]) : null,
        snapshot_content: JSON.parse(args[1]),
        operation: args[2] || void 0,
        entity_id: args[3] || void 0,
        version_id: args[4]
      });
    }
  });
  const capi = sqlite.sqlite3.capi;
  const module = new capi.sqlite3_module();
  const cursorStates = /* @__PURE__ */ new Map();
  let loggingInitialized = null;
  const canLog = () => {
    if (loggingInitialized === null) {
      try {
        const tableExists = sqlite.exec({
          sql: "SELECT 1 FROM sqlite_master WHERE type='table' AND name='key_value'",
          returnValue: "resultRows"
        });
        loggingInitialized = tableExists && tableExists.length > 0;
      } catch (e) {
        loggingInitialized = false;
      }
    }
    return loggingInitialized;
  };
  const create_temp_change_table_sql = `
  -- add a table we use within the transaction
  CREATE TEMP TABLE IF NOT EXISTS internal_change_in_transaction (
    id TEXT PRIMARY KEY DEFAULT (uuid_v7()),
    entity_id TEXT NOT NULL,
    schema_key TEXT NOT NULL,
    schema_version TEXT NOT NULL,
    file_id TEXT NOT NULL,
    plugin_key TEXT NOT NULL,
	  version_id TEXT NOT NULL,
    snapshot_content BLOB,
    created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')) NOT NULL CHECK (created_at LIKE '%Z'),
	--- NOTE schena_key must be unique per entity_id and file_id
	UNIQUE(entity_id, file_id, schema_key, version_id)
  ) STRICT;

`;
  sqlite.exec(create_temp_change_table_sql);
  module.installMethods(
    {
      xCreate: (db2, _pAux, _argc, _argv, pVTab) => {
        const result = capi.sqlite3_declare_vtab(db2, VTAB_CREATE_SQL);
        if (result !== capi.SQLITE_OK) {
          return result;
        }
        sqlite.sqlite3.vtab.xVtab.create(pVTab);
        return capi.SQLITE_OK;
      },
      xConnect: (db2, _pAux, _argc, _argv, pVTab) => {
        const result = capi.sqlite3_declare_vtab(db2, VTAB_CREATE_SQL);
        if (result !== capi.SQLITE_OK) {
          return result;
        }
        sqlite.sqlite3.vtab.xVtab.create(pVTab);
        return capi.SQLITE_OK;
      },
      xBegin: () => {
        if (sqlite.exec({
          sql: "SELECT * FROM internal_change_in_transaction",
          returnValue: "resultRows"
        }).length > 0) {
          const errorMessage = "Transaction already in progress";
          if (canLog()) {
            createLixOwnLogSync({
              lix: { sqlite, db },
              key: "lix_state_xbegin_error",
              level: "error",
              message: `xBegin error: ${errorMessage}`
            });
          }
          throw new Error(errorMessage);
        }
      },
      xCommit: () => {
        const currentTime = (/* @__PURE__ */ new Date()).toISOString();
        const changesWithoutChangeSets = sqlite.exec({
          sql: `
						SELECT 
							id, 
							entity_id, 
							schema_key, 
							schema_version, 
							file_id, 
							plugin_key, 
							version_id, 
							CASE 
								WHEN snapshot_content IS NOT NULL THEN json(snapshot_content) 
								ELSE NULL 
							END as snapshot_content, 
							created_at 
						FROM internal_change_in_transaction 
						ORDER BY version_id
					`,
          returnValue: "resultRows"
        });
        const changesByVersion = /* @__PURE__ */ new Map();
        for (const changeWithoutChangeset of changesWithoutChangeSets) {
          const version_id = changeWithoutChangeset[6];
          if (!changesByVersion.has(version_id)) {
            changesByVersion.set(version_id, []);
          }
          changesByVersion.get(version_id).push({
            id: changeWithoutChangeset[0],
            entity_id: changeWithoutChangeset[1],
            schema_key: changeWithoutChangeset[2],
            schema_version: changeWithoutChangeset[3],
            file_id: changeWithoutChangeset[4],
            plugin_key: changeWithoutChangeset[5],
            snapshot_content: changeWithoutChangeset[7],
            created_at: changeWithoutChangeset[8]
          });
        }
        for (const [version_id, versionChanges] of changesByVersion) {
          createChangesetForTransaction(
            sqlite,
            db,
            currentTime,
            version_id,
            versionChanges
          );
        }
        const changesToRealize = sqlite.exec({
          sql: "SELECT id, entity_id, schema_key, schema_version, file_id, plugin_key, version_id, snapshot_content, created_at FROM internal_change_in_transaction ORDER BY version_id",
          returnValue: "resultRows"
        });
        for (const changeToRealize of changesToRealize) {
          const [
            id,
            entity_id,
            schema_key,
            schema_version,
            file_id,
            plugin_key,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            version_id,
            snapshot_content,
            created_at
          ] = changeToRealize;
          let snapshot_id = "no-content";
          if (snapshot_content) {
            const result = sqlite.exec({
              sql: `INSERT OR IGNORE INTO internal_snapshot (content) VALUES (?) RETURNING id`,
              bind: [snapshot_content],
              returnValue: "resultRows"
            });
            if (result && result.length > 0) {
              snapshot_id = result[0][0];
            }
          }
          sqlite.exec({
            sql: `INSERT INTO internal_change (id, entity_id, schema_key, schema_version, file_id, plugin_key, snapshot_id, created_at)
							   VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
            bind: [
              id,
              entity_id,
              schema_key,
              schema_version,
              file_id,
              plugin_key,
              snapshot_id,
              created_at
            ],
            returnValue: "resultRows"
          });
        }
        sqlite.exec({
          sql: "DELETE FROM internal_change_in_transaction",
          returnValue: "resultRows"
        });
        hooks._emit("state_commit");
        return capi.SQLITE_OK;
      },
      xRollback: () => {
        sqlite.exec({
          sql: "DELETE FROM internal_change_in_transaction",
          returnValue: "resultRows"
        });
      },
      xBestIndex: (pVTab, pIdxInfo) => {
        const idxInfo = sqlite.sqlite3.vtab.xIndexInfo(pIdxInfo);
        const usableConstraints = [];
        let argIndex = 0;
        const columnMap = [
          "entity_id",
          // 0
          "schema_key",
          // 1
          "file_id",
          // 2
          "version_id",
          // 3
          "plugin_key",
          // 4
          "snapshot_content",
          // 5
          "schema_version",
          // 6
          "created_at",
          // 7
          "updated_at",
          // 8
          "inherited_from_version_id",
          // 9
          "change_id",
          // 10
          "untracked"
          // 11
        ];
        for (let i = 0; i < idxInfo.$nConstraint; i++) {
          const constraint = idxInfo.nthConstraint(i);
          if (constraint.$op === capi.SQLITE_INDEX_CONSTRAINT_EQ && constraint.$usable) {
            const columnName = columnMap[constraint.$iColumn];
            if (columnName) {
              usableConstraints.push(columnName);
              idxInfo.nthConstraintUsage(i).$argvIndex = ++argIndex;
            }
          }
        }
        const fullTableCost = 1e6;
        const fullTableRows = 1e7;
        if (usableConstraints.length > 0) {
          const idxStr = usableConstraints.join(",");
          idxInfo.$idxStr = sqlite.sqlite3.wasm.allocCString(idxStr, false);
          idxInfo.$needToFreeIdxStr = 1;
          idxInfo.$estimatedCost = fullTableCost / (usableConstraints.length + 1);
          idxInfo.$estimatedRows = Math.ceil(
            fullTableRows / (usableConstraints.length + 1)
          );
        } else {
          idxInfo.$needToFreeIdxStr = 0;
          idxInfo.$estimatedCost = fullTableCost;
          idxInfo.$estimatedRows = fullTableRows;
        }
        return capi.SQLITE_OK;
      },
      xDisconnect: () => {
        return capi.SQLITE_OK;
      },
      xDestroy: () => {
        return capi.SQLITE_OK;
      },
      xOpen: (_pVTab, pCursor) => {
        const cursor = sqlite.sqlite3.vtab.xCursor.create(pCursor);
        cursorStates.set(cursor.pointer, {
          results: [],
          rowIndex: 0
        });
        return capi.SQLITE_OK;
      },
      xClose: (pCursor) => {
        cursorStates.delete(pCursor);
        return capi.SQLITE_OK;
      },
      xFilter: (pCursor, idxNum, idxStrPtr, argc, argv) => {
        const cursorState = cursorStates.get(pCursor);
        const idxStr = sqlite.sqlite3.wasm.cstrToJs(idxStrPtr);
        const filters = {};
        if (argc > 0 && argv) {
          const args = sqlite.sqlite3.capi.sqlite3_values_to_js(argc, argv);
          if (idxStr) {
            const columns = idxStr.split(",").filter((c) => c.length > 0);
            for (let i = 0; i < Math.min(columns.length, args.length); i++) {
              if (args[i] !== null) {
                filters[columns[i]] = args[i];
              }
            }
          }
        }
        const cacheResults = queryCache(sqlite, filters);
        cursorState.results = cacheResults || [];
        cursorState.rowIndex = 0;
        const recordsInCache = sqlite.exec({
          sql: `SELECT COUNT(*) as count FROM internal_state_cache`,
          returnValue: "resultRows"
        })[0][0];
        if (cursorState.results.length === 0 && recordsInCache === 0) {
          if (canLog()) {
            createLixOwnLogSync({
              lix: { sqlite, db },
              key: "lix_state_cache_miss",
              level: "debug",
              message: `Cache miss detected - materializing state from CTE`
            });
          }
          const stateResults = selectStateViaCTE(sqlite, {}, true);
          if (stateResults && stateResults.length > 0) {
            let cachePopulated = false;
            for (const row of stateResults) {
              const entity_id = Array.isArray(row) ? row[0] : row.entity_id;
              const schema_key = Array.isArray(row) ? row[1] : row.schema_key;
              const file_id = Array.isArray(row) ? row[2] : row.file_id;
              const plugin_key = Array.isArray(row) ? row[3] : row.plugin_key;
              const snapshot_content = Array.isArray(row) ? row[4] : row.snapshot_content;
              const schema_version = Array.isArray(row) ? row[5] : row.schema_version;
              const version_id = Array.isArray(row) ? row[6] : row.version_id;
              const created_at = Array.isArray(row) ? row[7] : row.created_at;
              const updated_at = Array.isArray(row) ? row[8] : row.updated_at;
              const inherited_from_version_id = Array.isArray(row) ? row[9] : row.inherited_from_version_id;
              const change_id = Array.isArray(row) ? row[10] : row.change_id;
              if (!entity_id) {
                continue;
              }
              const isDeletion = snapshot_content === null;
              if (inherited_from_version_id !== null) {
                continue;
              }
              sqlite.exec({
                sql: `INSERT OR REPLACE INTO internal_state_cache 
									  (entity_id, schema_key, file_id, version_id, plugin_key, snapshot_content, schema_version, created_at, updated_at, inherited_from_version_id, inheritance_delete_marker, change_id)
									  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                bind: [
                  entity_id,
                  schema_key,
                  file_id,
                  version_id,
                  plugin_key,
                  isDeletion ? null : snapshot_content,
                  schema_version,
                  created_at,
                  updated_at,
                  inherited_from_version_id,
                  isDeletion ? 1 : 0,
                  change_id || "unknown-change-id"
                ]
              });
              cachePopulated = true;
            }
            if (cachePopulated && canLog()) {
              createLixOwnLogSync({
                lix: { sqlite, db },
                key: "lix_state_cache_populated",
                level: "debug",
                message: `Cache populated with ${(stateResults == null ? void 0 : stateResults.length) || 0} rows from CTE`
              });
            }
          }
          const newResults = queryCache(sqlite, filters);
          cursorState.results = newResults || [];
        } else {
          if (canLog()) {
            createLixOwnLogSync({
              lix: { sqlite, db },
              key: "lix_state_cache_hit",
              level: "debug",
              message: `Cache hit - returning ${cursorState.results.length} cached rows`
            });
          }
        }
        return capi.SQLITE_OK;
      },
      xNext: (pCursor) => {
        const cursorState = cursorStates.get(pCursor);
        cursorState.rowIndex++;
        return capi.SQLITE_OK;
      },
      xEof: (pCursor) => {
        const cursorState = cursorStates.get(pCursor);
        return cursorState.rowIndex >= cursorState.results.length ? 1 : 0;
      },
      xColumn: (pCursor, pContext, iCol) => {
        const cursorState = cursorStates.get(pCursor);
        const row = cursorState.results[cursorState.rowIndex];
        if (!row) {
          capi.sqlite3_result_null(pContext);
          return capi.SQLITE_OK;
        }
        let value;
        if (Array.isArray(row)) {
          value = row[iCol + 1];
        } else {
          const columnName = getColumnName(iCol);
          value = row[columnName];
        }
        if (value === "null" && getColumnName(iCol) === "inherited_from_version_id") {
          capi.sqlite3_result_null(pContext);
          return capi.SQLITE_OK;
        }
        if (value === null) {
          capi.sqlite3_result_null(pContext);
        } else {
          capi.sqlite3_result_js(pContext, value);
        }
        return capi.SQLITE_OK;
      },
      xRowid: (pCursor, pRowid) => {
        const cursorState = cursorStates.get(pCursor);
        const row = cursorState.results[cursorState.rowIndex];
        if (!row) {
          return capi.SQLITE_ERROR;
        }
        let rowid;
        if (Array.isArray(row)) {
          rowid = row[0];
        } else {
          rowid = row.rowid;
        }
        sqlite.sqlite3.vtab.xRowid(pRowid, rowid);
        return capi.SQLITE_OK;
      },
      xUpdate: (_pVTab, nArg, ppArgv) => {
        var _a;
        try {
          const args = sqlite.sqlite3.capi.sqlite3_values_to_js(nArg, ppArgv);
          if (nArg === 1) {
            handleStateDelete(sqlite, args[0], db);
            return capi.SQLITE_OK;
          }
          const isInsert = args[0] === null;
          const isUpdate = args[0] !== null;
          if (!isInsert && !isUpdate) {
            throw new Error("Invalid xUpdate operation");
          }
          const entity_id = args[2];
          const schema_key = args[3];
          const file_id = args[4];
          const version_id = args[5];
          const plugin_key = args[6];
          const snapshot_content = args[7];
          const schema_version = args[8];
          const untracked = (_a = args[13]) != null ? _a : false;
          if (!entity_id || !schema_key || !file_id || !plugin_key) {
            throw new Error("Missing required fields for state mutation");
          }
          if (!version_id) {
            throw new Error("version_id is required for state mutation");
          }
          const storedSchema = getStoredSchema(sqlite, schema_key);
          validateStateMutation({
            lix: { sqlite, db },
            schema: storedSchema ? JSON.parse(storedSchema) : null,
            snapshot_content: JSON.parse(snapshot_content),
            operation: isInsert ? "insert" : "update",
            entity_id: String(entity_id),
            version_id: String(version_id),
            untracked: Boolean(untracked)
          });
          if (untracked) {
            sqlite.exec({
              sql: `INSERT OR REPLACE INTO internal_state_all_untracked 
								  (entity_id, schema_key, file_id, version_id, plugin_key, snapshot_content, schema_version)
								  VALUES (?, ?, ?, ?, ?, ?, ?)`,
              bind: [
                String(entity_id),
                String(schema_key),
                String(file_id),
                String(version_id),
                String(plugin_key),
                snapshot_content,
                String(schema_version)
              ]
            });
          } else {
            sqlite.exec({
              sql: `DELETE FROM internal_state_all_untracked 
								  WHERE entity_id = ? AND schema_key = ? AND file_id = ? AND version_id = ?`,
              bind: [
                String(entity_id),
                String(schema_key),
                String(file_id),
                String(version_id)
              ]
            });
            handleStateMutation(
              sqlite,
              db,
              String(entity_id),
              String(schema_key),
              String(file_id),
              String(plugin_key),
              snapshot_content,
              String(version_id),
              String(schema_version)
            );
          }
          if (isInsert && String(schema_key) === "lix_version") {
            const versionData = JSON.parse(snapshot_content);
            const newVersionId = versionData.id;
            const changeSetId = versionData.change_set_id;
            if (newVersionId && changeSetId) {
              const existingVersionsWithSameChangeSet = sqlite.exec({
                sql: `
									SELECT json_extract(snapshot_content, '$.id') as version_id
									FROM internal_state_cache 
									WHERE schema_key = 'lix_version' 
									  AND json_extract(snapshot_content, '$.change_set_id') = ?
									  AND json_extract(snapshot_content, '$.id') != ?
								`,
                bind: [changeSetId, newVersionId],
                returnValue: "resultRows"
              });
              if (existingVersionsWithSameChangeSet && existingVersionsWithSameChangeSet.length > 0) {
                const sourceVersionId = existingVersionsWithSameChangeSet[0][0];
                sqlite.exec({
                  sql: `
										INSERT OR IGNORE INTO internal_state_cache 
										(entity_id, schema_key, file_id, version_id, plugin_key, snapshot_content, schema_version, created_at, updated_at, inherited_from_version_id, inheritance_delete_marker, change_id)
										SELECT 
											entity_id, schema_key, file_id, ?, plugin_key, snapshot_content, schema_version, created_at, updated_at, inherited_from_version_id, inheritance_delete_marker, change_id
										FROM internal_state_cache
										WHERE version_id = ? AND schema_key != 'lix_version'
									`,
                  bind: [newVersionId, sourceVersionId]
                });
              }
            }
          }
          return capi.SQLITE_OK;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (canLog()) {
            createLixOwnLogSync({
              lix: { sqlite, db },
              key: "lix_state_xupdate_error",
              level: "error",
              message: `xUpdate error: ${errorMessage}`
            });
          }
          throw error;
        }
      }
    },
    false
  );
  capi.sqlite3_create_module(sqlite.pointer, "state_vtab", module, 0);
  sqlite.exec(
    `CREATE VIRTUAL TABLE IF NOT EXISTS state_all USING state_vtab();`
  );
  sqlite.exec(`
		CREATE VIEW IF NOT EXISTS state AS
		SELECT 
			entity_id,
			schema_key,
			file_id,
			plugin_key,
			snapshot_content,
			schema_version,
			created_at,
			updated_at,
			inherited_from_version_id,
			change_id,
			untracked
		FROM state_all
		WHERE version_id IN (SELECT version_id FROM active_version);

		-- Add INSTEAD OF triggers for state that forward to state virtual table
		CREATE TRIGGER IF NOT EXISTS state_insert
		INSTEAD OF INSERT ON state
		BEGIN
			INSERT INTO state_all (
				entity_id,
				schema_key,
				file_id,
				version_id,
				plugin_key,
				snapshot_content,
				schema_version,
				created_at,
				updated_at,
				inherited_from_version_id,
				change_id,
				untracked
			) VALUES (
				NEW.entity_id,
				NEW.schema_key,
				NEW.file_id,
				(SELECT version_id FROM active_version),
				NEW.plugin_key,
				NEW.snapshot_content,
				NEW.schema_version,
				NEW.created_at,
				NEW.updated_at,
				NEW.inherited_from_version_id,
				NEW.change_id,
				NEW.untracked
			);
		END;

		CREATE TRIGGER IF NOT EXISTS state_update
		INSTEAD OF UPDATE ON state	
		BEGIN
			UPDATE state_all
			SET
				entity_id = NEW.entity_id,
				schema_key = NEW.schema_key,
				file_id = NEW.file_id,
				version_id = (SELECT version_id FROM active_version),
				plugin_key = NEW.plugin_key,
				snapshot_content = NEW.snapshot_content,
				schema_version = NEW.schema_version,
				created_at = NEW.created_at,
				updated_at = NEW.updated_at,
				inherited_from_version_id = NEW.inherited_from_version_id,
				change_id = NEW.change_id,
				untracked = NEW.untracked
			WHERE
				entity_id = OLD.entity_id
				AND schema_key = OLD.schema_key
				AND file_id = OLD.file_id
				AND version_id = (SELECT version_id FROM active_version);
		END;

		CREATE TRIGGER IF NOT EXISTS state_delete
		INSTEAD OF DELETE ON state
		BEGIN
			DELETE FROM state_all
			WHERE 
				entity_id = OLD.entity_id
				AND schema_key = OLD.schema_key
				AND file_id = OLD.file_id
				AND version_id = (SELECT version_id FROM active_version);
		END;
	`);
  const sql2 = `
  CREATE TABLE IF NOT EXISTS internal_state_cache (
    entity_id TEXT NOT NULL,
    schema_key TEXT NOT NULL,
    file_id TEXT NOT NULL,
    version_id TEXT NOT NULL,
    plugin_key TEXT NOT NULL,
    snapshot_content TEXT, -- Allow NULL for deletions
    schema_version TEXT NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    inherited_from_version_id TEXT,
    inheritance_delete_marker INTEGER DEFAULT 0, -- Flag for copy-on-write deletion markers
    change_id TEXT, -- Allow NULL during migration and for deletion markers 
    PRIMARY KEY (entity_id, schema_key, file_id, version_id)
  );

  -- Table for untracked state that bypasses change control
  CREATE TABLE IF NOT EXISTS internal_state_all_untracked (
    entity_id TEXT NOT NULL,
    schema_key TEXT NOT NULL,
    file_id TEXT NOT NULL,
    version_id TEXT NOT NULL,
    plugin_key TEXT NOT NULL,
    snapshot_content TEXT NOT NULL, -- JSON content
    schema_version TEXT NOT NULL,
    created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')) NOT NULL CHECK (created_at LIKE '%Z'),
    updated_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')) NOT NULL CHECK (updated_at LIKE '%Z'),
    PRIMARY KEY (entity_id, schema_key, file_id, version_id)
  ) STRICT;

  -- Trigger to update updated_at on untracked state changes
  CREATE TRIGGER IF NOT EXISTS internal_state_all_untracked_update_timestamp
  AFTER UPDATE ON internal_state_all_untracked
  BEGIN
    UPDATE internal_state_all_untracked 
    SET updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE entity_id = NEW.entity_id 
      AND schema_key = NEW.schema_key 
      AND file_id = NEW.file_id 
      AND version_id = NEW.version_id;
  END;
`;
  return sqlite.exec(sql2);
}
function handleStateDelete(sqlite, rowId, db) {
  const rowToDelete = sqlite.exec({
    sql: "SELECT * FROM state_all WHERE rowid = ?",
    bind: [rowId],
    returnValue: "resultRows"
  })[0];
  const entity_id = rowToDelete[0];
  const schema_key = rowToDelete[1];
  const file_id = rowToDelete[2];
  const version_id = rowToDelete[3];
  const plugin_key = rowToDelete[4];
  const snapshot_content = rowToDelete[5];
  const schema_version = rowToDelete[6];
  const untracked = rowToDelete[11];
  if (untracked) {
    sqlite.exec({
      sql: `DELETE FROM internal_state_all_untracked 
				  WHERE entity_id = ? AND schema_key = ? AND file_id = ? AND version_id = ?`,
      bind: [
        String(entity_id),
        String(schema_key),
        String(file_id),
        String(version_id)
      ]
    });
    return;
  }
  const storedSchema = getStoredSchema(sqlite, schema_key);
  validateStateMutation({
    lix: { sqlite, db },
    schema: storedSchema ? JSON.parse(storedSchema) : null,
    snapshot_content: JSON.parse(snapshot_content),
    operation: "delete",
    entity_id: String(entity_id),
    version_id: String(version_id)
  });
  handleStateMutation(
    sqlite,
    db,
    String(entity_id),
    String(schema_key),
    String(file_id),
    String(plugin_key),
    null,
    // No snapshot content for DELETE
    String(version_id),
    String(schema_version)
  );
}
function getStoredSchema(sqlite, schemaKey) {
  const result = sqlite.exec({
    sql: "SELECT value FROM stored_schema WHERE key = ?",
    bind: [String(schemaKey)],
    returnValue: "resultRows"
  });
  return result && result.length > 0 ? result[0][0] : null;
}
function getColumnName(columnIndex) {
  const columns = [
    "entity_id",
    "schema_key",
    "file_id",
    "version_id",
    "plugin_key",
    "snapshot_content",
    "schema_version",
    "created_at",
    "updated_at",
    "inherited_from_version_id",
    "change_id",
    "untracked"
  ];
  return columns[columnIndex] || "unknown";
}
function selectStateViaCTE(sqlite, filters, includeDeletions = false) {
  let sql2 = `
		WITH
			all_changes_with_snapshots AS (
				-- Include committed changes
				SELECT ic.id, ic.entity_id, ic.schema_key, ic.file_id, ic.plugin_key,
					   ic.schema_version, 
					   CASE 
					     WHEN ic.snapshot_id = 'no-content' THEN NULL
					     ELSE json(s.content)
					   END AS snapshot_content 
				FROM internal_change ic
				LEFT JOIN internal_snapshot s ON ic.snapshot_id = s.id
				
				UNION ALL
				
				-- Include changes from current transaction
				SELECT ict.id, ict.entity_id, ict.schema_key, ict.file_id, ict.plugin_key,
					   ict.schema_version, ict.snapshot_content
				FROM internal_change_in_transaction ict
				
				UNION ALL
				
				-- Include untracked state (pseudo-changes with special change_id)
				SELECT 'untracked-' || unt.entity_id || '-' || unt.schema_key AS id,
					   unt.entity_id, unt.schema_key, unt.file_id, unt.plugin_key,
					   unt.schema_version, json(unt.snapshot_content) AS snapshot_content
				FROM internal_state_all_untracked unt
			),
			root_cs_of_all_versions AS (
				SELECT json_extract(v.snapshot_content, '$.change_set_id') AS version_change_set_id, 
					   v.entity_id AS version_id
				FROM all_changes_with_snapshots v
				WHERE v.schema_key = 'lix_version'
			),
			reachable_cs_from_roots(id, version_id) AS (
				SELECT version_change_set_id, version_id FROM root_cs_of_all_versions
				UNION
				SELECT json_extract(e.snapshot_content, '$.parent_id'), r.version_id
				FROM all_changes_with_snapshots e 
				JOIN reachable_cs_from_roots r ON json_extract(e.snapshot_content, '$.child_id') = r.id
				WHERE e.schema_key = 'lix_change_set_edge'
			),
			cse_in_reachable_cs AS (
				SELECT json_extract(ias.snapshot_content, '$.entity_id') AS target_entity_id,
					   json_extract(ias.snapshot_content, '$.file_id') AS target_file_id,
					   json_extract(ias.snapshot_content, '$.schema_key') AS target_schema_key, 
					   json_extract(ias.snapshot_content, '$.change_id') AS target_change_id,
					   json_extract(ias.snapshot_content, '$.change_set_id') AS cse_origin_change_set_id,
					   rcs.version_id
				FROM all_changes_with_snapshots ias
				JOIN reachable_cs_from_roots rcs ON json_extract(ias.snapshot_content, '$.change_set_id') = rcs.id
				WHERE ias.schema_key = 'lix_change_set_element'
			),
			leaf_target_snapshots AS (
				SELECT target_change.entity_id, target_change.schema_key, target_change.file_id,
					   target_change.plugin_key, target_change.snapshot_content AS snapshot_content,
					   target_change.schema_version, r.version_id, target_change.id as change_id
				FROM cse_in_reachable_cs r 
				INNER JOIN all_changes_with_snapshots target_change ON r.target_change_id = target_change.id
				WHERE NOT EXISTS (
					WITH RECURSIVE descendants_of_current_cs(id) AS ( 
						SELECT r.cse_origin_change_set_id 
						UNION
						SELECT json_extract(edge.snapshot_content, '$.child_id')
						FROM all_changes_with_snapshots edge
						JOIN descendants_of_current_cs d ON json_extract(edge.snapshot_content, '$.parent_id') = d.id
						WHERE edge.schema_key = 'lix_change_set_edge'
						  AND json_extract(edge.snapshot_content, '$.child_id') IN (
						  	SELECT id FROM reachable_cs_from_roots WHERE version_id = r.version_id
						  )
					)
					SELECT 1 FROM cse_in_reachable_cs newer_r 
					WHERE newer_r.target_entity_id = r.target_entity_id 
					  AND newer_r.target_file_id = r.target_file_id       
					  AND newer_r.target_schema_key = r.target_schema_key 
					  AND newer_r.version_id = r.version_id
					  AND (newer_r.cse_origin_change_set_id != r.cse_origin_change_set_id OR newer_r.target_change_id != r.target_change_id) 
					  AND newer_r.cse_origin_change_set_id IN descendants_of_current_cs
				)
			),
			-- Get version inheritance relationships
			version_inheritance AS (
				SELECT DISTINCT
					v.entity_id AS version_id,
					json_extract(v.snapshot_content, '$.inherits_from_version_id') AS parent_version_id
				FROM all_changes_with_snapshots v
				WHERE v.schema_key = 'lix_version'
			),
			-- Combine direct entities with inherited entities
			all_entities AS (
				-- Direct entities from leaf_target_snapshots 
				SELECT 
					entity_id, schema_key, file_id, plugin_key, snapshot_content, schema_version,
					version_id, version_id as visible_in_version, NULL as inherited_from_version_id, change_id
				FROM leaf_target_snapshots
				
				UNION ALL
				
				-- Inherited entities from parent versions
				SELECT 
					ls.entity_id, ls.schema_key, ls.file_id, ls.plugin_key, ls.snapshot_content, ls.schema_version,
					vi.version_id, -- Use child version_id for testing
					vi.version_id as visible_in_version, -- Make visible in child version
					vi.parent_version_id as inherited_from_version_id, ls.change_id
				FROM version_inheritance vi
				JOIN leaf_target_snapshots ls ON ls.version_id = vi.parent_version_id
				WHERE vi.parent_version_id IS NOT NULL
				AND ls.snapshot_content IS NOT NULL -- Don't inherit deleted entities
				-- Don't inherit if child already has this entity (including deletion markers)
				-- Use a more comprehensive check that includes both leaf snapshots and direct inheritance blocking
				AND NOT EXISTS (
					-- Check if there's ANY change for this entity in the child version
					-- This includes creation, update, AND deletion changes
					SELECT 1 FROM leaf_target_snapshots child_ls
					WHERE child_ls.version_id = vi.version_id
					  AND child_ls.entity_id = ls.entity_id
					  AND child_ls.schema_key = ls.schema_key
					  AND child_ls.file_id = ls.file_id
				)
				-- Additional safeguard: check that no change set element exists for this entity in child
				AND NOT EXISTS (
					SELECT 1 FROM cse_in_reachable_cs cse
					JOIN all_changes_with_snapshots target_change ON cse.target_change_id = target_change.id
					WHERE cse.version_id = vi.version_id
					  AND target_change.entity_id = ls.entity_id
					  AND target_change.schema_key = ls.schema_key
					  AND target_change.file_id = ls.file_id
				)
			),
		-- Prioritize direct entities over inherited ones, then deduplicate
		prioritized_entities AS (
			SELECT *,
				   -- Priority: direct entities (inherited_from_version_id IS NULL) over inherited
				   CASE WHEN inherited_from_version_id IS NULL THEN 1 ELSE 2 END as priority,
				   -- Row number for deduplication within same priority
				   ROW_NUMBER() OVER (
					   PARTITION BY entity_id, schema_key, file_id, visible_in_version 
					   ORDER BY CASE WHEN inherited_from_version_id IS NULL THEN 1 ELSE 2 END,
					            -- Among inherited entities, prefer those with earlier timestamps
					            version_id
				   ) as rn
			FROM all_entities ae
			-- Don't filter out entities with null snapshot_content here
			-- We need deletion markers to be included for proper inheritance blocking
		)
		SELECT DISTINCT
			pe.entity_id,
			pe.schema_key,
			pe.file_id,
			pe.plugin_key,
			pe.snapshot_content,
			pe.schema_version,
			pe.version_id,
			COALESCE(
				(SELECT MIN(ic.created_at) FROM internal_change ic 
				 WHERE ic.entity_id = pe.entity_id AND ic.schema_key = pe.schema_key AND ic.file_id = pe.file_id),
				(SELECT MIN(ict.created_at) FROM internal_change_in_transaction ict 
				 WHERE ict.entity_id = pe.entity_id AND ict.schema_key = pe.schema_key AND ict.file_id = pe.file_id)
			) AS created_at,
			COALESCE(
				(SELECT MAX(ic.created_at) FROM internal_change ic 
				 WHERE ic.entity_id = pe.entity_id AND ic.schema_key = pe.schema_key AND ic.file_id = pe.file_id
				   AND ic.id IN (SELECT cse.target_change_id FROM cse_in_reachable_cs cse WHERE cse.version_id = pe.version_id)),
				(SELECT MIN(ic.created_at) FROM internal_change ic 
				 WHERE ic.entity_id = pe.entity_id AND ic.schema_key = pe.schema_key AND ic.file_id = pe.file_id),
				(SELECT MAX(ict.created_at) FROM internal_change_in_transaction ict 
				 WHERE ict.entity_id = pe.entity_id AND ict.schema_key = pe.schema_key AND ict.file_id = pe.file_id)
			) AS updated_at,
			pe.inherited_from_version_id,
			pe.change_id
		FROM prioritized_entities pe
		WHERE pe.rn = 1
		${includeDeletions ? "" : "-- Filter out deletion markers from final results\n		AND pe.snapshot_content IS NOT NULL"}
	`;
  const bindings = [];
  const conditions = [];
  Object.entries(filters).forEach(([key, value]) => {
    if (key === "version_id") {
      conditions.push(`ae.visible_in_version = ?`);
    } else {
      conditions.push(`ae.${key} = ?`);
    }
    bindings.push(value);
  });
  if (conditions.length > 0) {
    sql2 += " AND " + conditions.join(" AND ");
  }
  const result = sqlite.exec({
    sql: sql2,
    bind: bindings,
    returnValue: "resultRows"
  });
  return result || [];
}
function queryCache(sqlite, filters) {
  const filterBindings = Object.values(filters);
  const buildWhereClause = (tableAlias = "") => {
    const conditions = [];
    const prefix = tableAlias ? `${tableAlias}.` : "";
    Object.keys(filters).forEach((column) => {
      conditions.push(`${prefix}${column} = ?`);
    });
    return conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";
  };
  const statement = `SELECT * FROM (
		-- 1. Untracked state (highest priority)
		SELECT 
			rowid,
			entity_id, 
			schema_key, 
			file_id, 
			version_id, 
			plugin_key,
			snapshot_content, 
			schema_version, 
			created_at, 
			updated_at,
			NULL as inherited_from_version_id, 
			'untracked' as change_id, 
			1 as untracked
		FROM internal_state_all_untracked
		
		UNION ALL
		
		-- 2. Tracked state (second priority) - only if no untracked exists
		SELECT 
			rowid,
			entity_id, 
			schema_key, 
			file_id, 
			version_id, 
			plugin_key, 
			snapshot_content, 
			schema_version, 
			created_at, 
			updated_at,
			inherited_from_version_id, 
			change_id, 
			0 as untracked
		FROM internal_state_cache
		WHERE inheritance_delete_marker = 0  -- Hide copy-on-write deletions
		AND NOT EXISTS (
			SELECT 1 FROM internal_state_all_untracked unt
			WHERE unt.entity_id = internal_state_cache.entity_id
			  AND unt.schema_key = internal_state_cache.schema_key
			  AND unt.file_id = internal_state_cache.file_id
			  AND unt.version_id = internal_state_cache.version_id
		)
		
		UNION ALL
		
		-- 3. Inherited tracked state (lower priority) - only if no untracked or tracked exists
		SELECT 
			rowid,
			isc.entity_id, 
			isc.schema_key, 
			isc.file_id, 
			vi.version_id, -- Return child version_id
			isc.plugin_key, 
			isc.snapshot_content, 
			isc.schema_version, 
			isc.created_at, 
			isc.updated_at,
			vi.parent_version_id as inherited_from_version_id, 
			isc.change_id, 
			0 as untracked
		FROM (
			-- Get version inheritance relationships from cache
			SELECT 
				json_extract(isc_v.snapshot_content, '$.id') AS version_id,
				json_extract(isc_v.snapshot_content, '$.inherits_from_version_id') AS parent_version_id
			FROM internal_state_cache isc_v
			WHERE isc_v.schema_key = 'lix_version'
		) vi
		JOIN internal_state_cache isc ON isc.version_id = vi.parent_version_id
		WHERE vi.parent_version_id IS NOT NULL
		-- Only inherit entities that exist (not deleted) in parent
		AND isc.inheritance_delete_marker = 0
		-- Don't inherit if child has tracked state
		AND NOT EXISTS (
			SELECT 1 FROM internal_state_cache child_isc
			WHERE child_isc.version_id = vi.version_id
			  AND child_isc.entity_id = isc.entity_id
			  AND child_isc.schema_key = isc.schema_key
			  AND child_isc.file_id = isc.file_id
		)
		-- Don't inherit if child has untracked state
		AND NOT EXISTS (
			SELECT 1 FROM internal_state_all_untracked unt
			WHERE unt.version_id = vi.version_id
			  AND unt.entity_id = isc.entity_id
			  AND unt.schema_key = isc.schema_key
			  AND unt.file_id = isc.file_id
		)
		
		UNION ALL
		
		-- 4. Inherited untracked state (lowest priority) - only if no untracked or tracked exists
		SELECT 
			rowid,
			unt.entity_id, 
			unt.schema_key, 
			unt.file_id, 
			vi.version_id, -- Return child version_id
			unt.plugin_key, 
			unt.snapshot_content, 
			unt.schema_version, 
			unt.created_at, 
			unt.updated_at,
			vi.parent_version_id as inherited_from_version_id, 
			'untracked' as change_id, 
			1 as untracked
		FROM (
			-- Get version inheritance relationships from cache
			SELECT 
				json_extract(isc_v.snapshot_content, '$.id') AS version_id,
				json_extract(isc_v.snapshot_content, '$.inherits_from_version_id') AS parent_version_id
			FROM internal_state_cache isc_v
			WHERE isc_v.schema_key = 'lix_version'
		) vi
		JOIN internal_state_all_untracked unt ON unt.version_id = vi.parent_version_id
		WHERE vi.parent_version_id IS NOT NULL
		-- Don't inherit if child has tracked state
		AND NOT EXISTS (
			SELECT 1 FROM internal_state_cache child_isc
			WHERE child_isc.version_id = vi.version_id
			  AND child_isc.entity_id = unt.entity_id
			  AND child_isc.schema_key = unt.schema_key
			  AND child_isc.file_id = unt.file_id
		)
		-- Don't inherit if child has untracked state
		AND NOT EXISTS (
			SELECT 1 FROM internal_state_all_untracked child_unt
			WHERE child_unt.version_id = vi.version_id
			  AND child_unt.entity_id = unt.entity_id
			  AND child_unt.schema_key = unt.schema_key
			  AND child_unt.file_id = unt.file_id
		)
	) as combined_results`;
  const result = sqlite.exec({
    sql: `${statement} ${buildWhereClause("combined_results")}`,
    bind: [...filterBindings],
    returnValue: "resultRows"
  });
  return result;
}

// ../lix-sdk/src/state-history/schema.ts
function applyStateHistoryDatabaseSchema(sqlite) {
  sqlite.exec(STATE_HISTORY_VIEW_SQL);
  return sqlite;
}
var STATE_HISTORY_VIEW_SQL = `
CREATE VIEW IF NOT EXISTS state_history AS
WITH
	-- Get all changes with their snapshots
	all_changes_with_snapshots AS (
		SELECT ic.id, ic.entity_id, ic.schema_key, ic.file_id, ic.plugin_key,
			   ic.schema_version, ic.created_at,
			   CASE 
			     WHEN ic.snapshot_id = 'no-content' THEN NULL
			     ELSE json(s.content)
			   END AS snapshot_content 
		FROM internal_change ic
		LEFT JOIN internal_snapshot s ON ic.snapshot_id = s.id
	),
	-- For state_history, we work with any change_set_id, not just version heads
	requested_change_sets AS (
		SELECT DISTINCT cs.id as change_set_id
		FROM change_set_all cs
		-- This will be filtered by the WHERE clause in queries
	),
	-- Find all change sets reachable from requested ones (including ancestors)
	reachable_cs_from_requested(id, root_change_set_id, depth) AS (
		SELECT change_set_id, change_set_id as root_change_set_id, 0 as depth 
		FROM requested_change_sets
		UNION
		SELECT cse.parent_id, r.root_change_set_id, r.depth + 1
		FROM change_set_edge_all cse 
		JOIN reachable_cs_from_requested r ON cse.child_id = r.id
		WHERE cse.lixcol_version_id = 'global'
	),
	-- Find all change set elements in reachable change sets
	cse_in_reachable_cs AS (
		SELECT cse.entity_id AS target_entity_id,
			   cse.file_id AS target_file_id,
			   cse.schema_key AS target_schema_key, 
			   cse.change_id AS target_change_id,
			   cse.change_set_id AS cse_origin_change_set_id,
			   rcs.root_change_set_id,
			   rcs.depth as changeset_depth,
			   rcs.id as depth_change_set_id
		FROM change_set_element_all cse
		JOIN reachable_cs_from_requested rcs ON cse.change_set_id = rcs.id
		WHERE cse.lixcol_version_id = 'global'
	),
	-- For each entity at each depth, find the latest change within that depth's change set
	latest_change_per_entity_per_depth AS (
		SELECT 
			r.target_entity_id,
			r.target_file_id,
			r.target_schema_key,
			r.root_change_set_id,
			r.changeset_depth,
			r.depth_change_set_id,
			MAX(target_change.created_at) as latest_created_at
		FROM cse_in_reachable_cs r 
		INNER JOIN all_changes_with_snapshots target_change ON r.target_change_id = target_change.id
		GROUP BY r.target_entity_id, r.target_file_id, r.target_schema_key, r.root_change_set_id, r.changeset_depth
	),
	-- Get the actual changes for each entity at each depth
	entity_states_at_depths AS (
		SELECT 
			target_change.entity_id, 
			target_change.schema_key, 
			target_change.file_id,
			target_change.plugin_key, 
			target_change.snapshot_content,
			target_change.schema_version,
			r.target_change_id,
			r.cse_origin_change_set_id,
			r.root_change_set_id,
			latest.changeset_depth
		FROM latest_change_per_entity_per_depth latest
		INNER JOIN cse_in_reachable_cs r ON (
			latest.target_entity_id = r.target_entity_id 
			AND latest.target_file_id = r.target_file_id
			AND latest.target_schema_key = r.target_schema_key
			AND latest.root_change_set_id = r.root_change_set_id
			AND latest.changeset_depth = r.changeset_depth
		)
		INNER JOIN all_changes_with_snapshots target_change ON (
			r.target_change_id = target_change.id
			AND target_change.created_at = latest.latest_created_at
		)
	)
SELECT 
	esad.entity_id,
	esad.schema_key,
	esad.file_id,
	esad.plugin_key,
	esad.snapshot_content,
	esad.schema_version,
	esad.target_change_id as change_id,
	esad.cse_origin_change_set_id as change_set_id,
	esad.root_change_set_id as root_change_set_id,
	esad.changeset_depth as depth
FROM entity_states_at_depths esad
WHERE esad.snapshot_content IS NOT NULL  -- Exclude deletions for now
ORDER BY esad.entity_id, esad.changeset_depth;
`;

// ../lix-sdk/src/database/init-db.ts
var ViewsWithJsonColumns = {
  state: ["snapshot_content"],
  state_all: ["snapshot_content"],
  state_history: ["snapshot_content"],
  change: ["snapshot_content"],
  ...(() => {
    const result = {};
    for (const [viewName, schema] of Object.entries(LixSchemaViewMap)) {
      if (typeof schema === "boolean" || !schema.properties) continue;
      const jsonColumns = Object.entries(schema.properties).filter(([, def]) => isJsonType(def)).map(([key]) => key);
      if (jsonColumns.length) {
        result[viewName] = jsonColumns;
        result[viewName + "_all"] = jsonColumns;
      }
    }
    return result;
  })()
};
function initDb(args) {
  const db = new Kysely({
    // log: ["error", "query"],
    dialect: createDialect({
      database: args.sqlite
    }),
    plugins: [
      // needed for things like `jsonArrayFrom()`
      new ParseJSONResultsPlugin(),
      JSONColumnPlugin(ViewsWithJsonColumns),
      new ViewInsertReturningErrorPlugin(Object.keys(LixSchemaViewMap))
    ]
  });
  initFunctions({
    sqlite: args.sqlite});
  applyStateDatabaseSchema(
    args.sqlite,
    db,
    args.hooks
  );
  applySnapshotDatabaseSchema(args.sqlite);
  applyChangeDatabaseSchema(args.sqlite);
  applyChangeSetDatabaseSchema(args.sqlite);
  applyStoredSchemaDatabaseSchema(args.sqlite);
  applyAccountDatabaseSchema(args.sqlite);
  applyVersionDatabaseSchema(args.sqlite);
  applyKeyValueDatabaseSchema(args.sqlite);
  applyChangeAuthorDatabaseSchema(args.sqlite);
  applyLabelDatabaseSchema(args.sqlite);
  applyThreadDatabaseSchema(args.sqlite);
  applyStateHistoryDatabaseSchema(args.sqlite);
  applyLogDatabaseSchema(args.sqlite);
  return db;
}
function initFunctions(args) {
  args.sqlite.createFunction({
    name: "uuid_v7",
    arity: 0,
    xFunc: () => v7_default()
  });
  args.sqlite.createFunction({
    name: "uuid_v4",
    arity: 0,
    xFunc: () => v4_default()
  });
  args.sqlite.createFunction({
    name: "human_id",
    arity: 0,
    xFunc: () => (0, import_human_id3.humanId)({ separator: "-", capitalize: false })
  });
  args.sqlite.createFunction({
    name: "nano_id",
    arity: -1,
    // @ts-expect-error - not sure why this is not working
    xFunc: (_ctx, length) => {
      return nanoid(length);
    }
  });
}

// ../lix-sdk/src/services/env-variables/index.ts
var ENV_VARIABLES = {
  LIX_SDK_POSTHOG_TOKEN: void 0,
  LIX_SDK_VERSION: "0.5.0-preview.0"
};

// ../lix-sdk/src/services/telemetry/capture.ts
var capture = async (event, args) => {
  {
    return;
  }
};

// ../lix-sdk/src/lix/new-lix.ts
var import_human_id4 = __toESM(require_dist());
async function newLixFile(args) {
  var _a, _b, _c;
  const sqlite = await createInMemoryDatabase({
    readOnly: false
  });
  const hooks = createHooks();
  const db = initDb({ sqlite, hooks });
  const bootstrapChanges = createBootstrapChanges(args == null ? void 0 : args.keyValues);
  const lixId = (_a = bootstrapChanges.find(
    (c) => {
      var _a2;
      return c.schema_key === "lix_key_value" && ((_a2 = c.snapshot_content) == null ? void 0 : _a2.key) === "lix_id";
    }
  )) == null ? void 0 : _a.snapshot_content.value;
  const lixName = (_b = bootstrapChanges.find(
    (c) => {
      var _a2;
      return c.schema_key === "lix_key_value" && ((_a2 = c.snapshot_content) == null ? void 0 : _a2.key) === "lix_name";
    }
  )) == null ? void 0 : _b.snapshot_content.value;
  for (const change of bootstrapChanges) {
    let snapshotId = "no-content";
    if (change.snapshot_content) {
      const result = sqlite.exec({
        sql: `INSERT INTO internal_snapshot (content) VALUES (jsonb(?)) RETURNING id`,
        bind: [JSON.stringify(change.snapshot_content)],
        returnValue: "resultRows"
      });
      if (result && result.length > 0) {
        snapshotId = result[0][0];
      }
    }
    sqlite.exec({
      sql: `INSERT INTO internal_change (id, entity_id, schema_key, schema_version, file_id, plugin_key, snapshot_id, created_at)
				   VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      bind: [
        change.id,
        change.entity_id,
        change.schema_key,
        change.schema_version,
        change.file_id,
        change.plugin_key,
        snapshotId,
        change.created_at
      ]
    });
  }
  const initialVersionId = (_c = bootstrapChanges.find(
    (c) => {
      var _a2;
      return c.schema_key === "lix_version" && ((_a2 = c.snapshot_content) == null ? void 0 : _a2.name) === "main";
    }
  )) == null ? void 0 : _c.entity_id;
  sqlite.exec(`
		INSERT INTO active_version (version_id)
		SELECT '${initialVersionId}'
		WHERE NOT EXISTS (SELECT 1 FROM active_version);
`);
  try {
    const blob = new Blob([contentFromDatabase(sqlite)]);
    const lixBlob = Object.assign(blob, {
      _lix: {
        id: lixId,
        name: lixName
      }
    });
    return lixBlob;
  } catch (e) {
    throw new Error(`Failed to create new Lix file: ${e}`, { cause: e });
  } finally {
    await db.destroy();
  }
}
function createBootstrapChanges(providedKeyValues) {
  var _a, _b;
  const changes = [];
  const created_at = (/* @__PURE__ */ new Date()).toISOString();
  const initialVersionId = nanoid();
  const initialChangeSetId = nanoid();
  const initialWorkingChangeSetId = nanoid();
  const initialGlobalVersionChangeSetId = nanoid();
  const initialGlobalVersionWorkingChangeSetId = nanoid();
  const changeSets = [
    {
      id: initialGlobalVersionChangeSetId
    },
    {
      id: initialGlobalVersionWorkingChangeSetId
    },
    {
      id: initialChangeSetId
    },
    {
      id: initialWorkingChangeSetId
    }
  ];
  for (const changeSet of changeSets) {
    changes.push({
      id: v7_default(),
      entity_id: changeSet.id,
      schema_key: "lix_change_set",
      schema_version: LixChangeSetSchema["x-lix-version"],
      file_id: "lix",
      plugin_key: "lix_own_entity",
      snapshot_content: changeSet,
      created_at
    });
  }
  changes.push({
    id: v7_default(),
    entity_id: "global",
    schema_key: "lix_version",
    schema_version: LixVersionSchema["x-lix-version"],
    file_id: "lix",
    plugin_key: "lix_own_entity",
    snapshot_content: {
      id: "global",
      name: "global",
      change_set_id: initialGlobalVersionChangeSetId,
      working_change_set_id: initialGlobalVersionWorkingChangeSetId,
      hidden: true
    },
    created_at
  });
  changes.push({
    id: v7_default(),
    entity_id: initialVersionId,
    schema_key: "lix_version",
    schema_version: LixVersionSchema["x-lix-version"],
    file_id: "lix",
    plugin_key: "lix_own_entity",
    snapshot_content: {
      id: initialVersionId,
      name: "main",
      change_set_id: initialChangeSetId,
      working_change_set_id: initialWorkingChangeSetId,
      inherits_from_version_id: "global",
      hidden: false
    },
    created_at
  });
  const checkpointLabelId = nanoid();
  changes.push({
    id: v7_default(),
    entity_id: checkpointLabelId,
    schema_key: "lix_label",
    schema_version: LixLabelSchema["x-lix-version"],
    file_id: "lix",
    plugin_key: "lix_own_entity",
    snapshot_content: {
      id: checkpointLabelId,
      name: "checkpoint"
    },
    created_at
  });
  const lixId = (_a = providedKeyValues == null ? void 0 : providedKeyValues.find((kv) => kv.key === "lix_id")) == null ? void 0 : _a.value;
  changes.push({
    id: v7_default(),
    entity_id: "lix_id",
    schema_key: "lix_key_value",
    schema_version: LixKeyValueSchema["x-lix-version"],
    file_id: "lix",
    plugin_key: "lix_own_entity",
    snapshot_content: {
      key: "lix_id",
      value: lixId != null ? lixId : nanoid(10)
    },
    created_at
  });
  const lixName = (_b = providedKeyValues == null ? void 0 : providedKeyValues.find((kv) => kv.key === "lix_name")) == null ? void 0 : _b.value;
  changes.push({
    id: v7_default(),
    entity_id: "lix_name",
    schema_key: "lix_key_value",
    schema_version: LixKeyValueSchema["x-lix-version"],
    file_id: "lix",
    plugin_key: "lix_own_entity",
    snapshot_content: {
      key: "lix_name",
      value: lixName != null ? lixName : (0, import_human_id4.humanId)({ separator: "-", capitalize: false })
    },
    created_at
  });
  if (providedKeyValues) {
    for (const kv of providedKeyValues) {
      if (kv.key === "lix_id" || kv.key === "lix_name" || !kv.key || !kv.value)
        continue;
      changes.push({
        id: v7_default(),
        entity_id: kv.key,
        schema_key: "lix_key_value",
        schema_version: LixKeyValueSchema["x-lix-version"],
        file_id: "lix",
        plugin_key: "lix_own_entity",
        snapshot_content: {
          key: kv.key,
          value: kv.value
        },
        created_at
      });
    }
  }
  for (const schema of Object.values(LixSchemaViewMap)) {
    changes.push({
      id: v7_default(),
      entity_id: schema["x-lix-key"],
      schema_key: "lix_stored_schema",
      schema_version: "1.0",
      file_id: "lix",
      plugin_key: "lix_own_entity",
      snapshot_content: {
        key: schema["x-lix-key"],
        version: schema["x-lix-version"],
        value: JSON.stringify(schema)
      },
      created_at
    });
  }
  const originalChanges = [...changes];
  const changeSetElementChanges = [];
  for (const change of originalChanges) {
    const changeSetElementChange = {
      id: v7_default(),
      entity_id: `${initialGlobalVersionChangeSetId}::${change.id}`,
      schema_key: "lix_change_set_element",
      schema_version: LixChangeSetElementSchema["x-lix-version"],
      file_id: "lix",
      plugin_key: "lix_own_entity",
      snapshot_content: {
        change_set_id: initialGlobalVersionChangeSetId,
        change_id: change.id,
        entity_id: change.entity_id,
        schema_key: change.schema_key,
        file_id: change.file_id
      },
      created_at
    };
    changes.push(changeSetElementChange);
    changeSetElementChanges.push(changeSetElementChange);
  }
  for (const changeSetElementChange of changeSetElementChanges) {
    changes.push({
      id: v7_default(),
      entity_id: `${initialGlobalVersionChangeSetId}::${changeSetElementChange.id}`,
      schema_key: "lix_change_set_element",
      schema_version: LixChangeSetElementSchema["x-lix-version"],
      file_id: "lix",
      plugin_key: "lix_own_entity",
      snapshot_content: {
        change_set_id: initialGlobalVersionChangeSetId,
        change_id: changeSetElementChange.id,
        entity_id: changeSetElementChange.entity_id,
        schema_key: changeSetElementChange.schema_key,
        file_id: changeSetElementChange.file_id
      },
      created_at
    });
  }
  return changes;
}

// ../lix-sdk/src/lix/storage/in-memory.ts
var InMemoryStorage = class {
  constructor() {
    __publicField(this, "database");
  }
  /**
   * Opens an in-memory SQLite database.
   *
   * Creates a new empty lix if this is the first time opening.
   * Returns the same database instance on subsequent calls.
   */
  async open() {
    if (!this.database) {
      this.database = await createInMemoryDatabase({ readOnly: false });
      const blob = await newLixFile();
      importDatabase({
        db: this.database,
        content: new Uint8Array(await blob.arrayBuffer())
      });
    }
    return this.database;
  }
  /**
   * Closes the database connection.
   *
   * Note: For in-memory databases, this just clears the reference.
   * The data is lost when the database is no longer referenced.
   */
  async close() {
    this.database = void 0;
  }
  /**
   * Imports data from a blob, replacing the current database content.
   */
  async import(blob) {
    const database = await this.open();
    importDatabase({
      db: database,
      content: new Uint8Array(await blob.arrayBuffer())
    });
  }
  /**
   * Exports the current database state as a blob.
   */
  async export() {
    const database = await this.open();
    const content = contentFromDatabase(database);
    return new Blob([content]);
  }
};

// ../lix-sdk/src/observe/lix-observable.ts
if (typeof Symbol.observable === "undefined") {
  Symbol.observable = Symbol("observable");
}
var LixObservable = class {
  constructor(subscriber) {
    this.subscriber = subscriber;
  }
  subscribe(observer) {
    let closed = false;
    const safeObserver = {
      next: (value) => {
        var _a;
        return !closed && ((_a = observer.next) == null ? void 0 : _a.call(observer, value));
      },
      error: (err) => {
        var _a;
        if (!closed) {
          closed = true;
          (_a = observer.error) == null ? void 0 : _a.call(observer, err);
        }
      },
      complete: () => {
        var _a;
        if (!closed) {
          closed = true;
          (_a = observer.complete) == null ? void 0 : _a.call(observer);
        }
      }
    };
    const cleanup = this.subscriber(safeObserver);
    return {
      unsubscribe() {
        if (!closed) {
          closed = true;
          cleanup == null ? void 0 : cleanup();
        }
      }
    };
  }
  [Symbol.observable]() {
    return this;
  }
  subscribeTakeFirst(observer) {
    return this.subscribe({
      next: (rows) => {
        var _a;
        return (_a = observer.next) == null ? void 0 : _a.call(observer, rows[0]);
      },
      error: observer.error,
      complete: observer.complete
    });
  }
  subscribeTakeFirstOrThrow(observer) {
    return this.subscribe({
      next: (rows) => {
        var _a, _b;
        if (rows.length === 0) {
          (_a = observer.error) == null ? void 0 : _a.call(observer, new Error("Query returned no rows"));
        } else {
          (_b = observer.next) == null ? void 0 : _b.call(observer, rows[0]);
        }
      },
      error: observer.error,
      complete: observer.complete
    });
  }
};

// ../lix-sdk/src/observe/create-observe.ts
function areResultsEqual(a, b) {
  if (a.length !== b.length) return false;
  return JSON.stringify(a) === JSON.stringify(b);
}
function createObserve(lix) {
  const activeObservables = /* @__PURE__ */ new WeakMap();
  return function observe(query, options = { mode: "array" }) {
    const observable = new LixObservable((observer) => {
      let isActive = true;
      let previousResult;
      const executeQuery = async () => {
        var _a, _b, _c, _d;
        if (!isActive) return;
        try {
          let optimizedQuery = query;
          if (options.mode === "first" || options.mode === "firstOrThrow") {
            optimizedQuery = query.limit(1);
          }
          const result = await optimizedQuery.execute();
          if (!isActive) return;
          const hasChanged = !previousResult || !areResultsEqual(previousResult, result);
          if (hasChanged) {
            previousResult = result;
            if (options.mode === "first") {
              (_a = observer.next) == null ? void 0 : _a.call(observer, result);
            } else if (options.mode === "firstOrThrow") {
              (_b = observer.next) == null ? void 0 : _b.call(observer, result);
            } else {
              (_c = observer.next) == null ? void 0 : _c.call(observer, result);
            }
          }
        } catch (error) {
          if (!isActive) return;
          (_d = observer.error) == null ? void 0 : _d.call(observer, error);
        }
      };
      executeQuery();
      const unsubscribeFromStateCommit = lix.hooks.onStateCommit(() => {
        executeQuery();
      });
      activeObservables.set(observable, { unsubscribeFromStateCommit });
      return () => {
        isActive = false;
        unsubscribeFromStateCommit();
        activeObservables.delete(observable);
      };
    });
    if (options.mode === "first") {
      return observable;
    } else if (options.mode === "firstOrThrow") {
      return observable;
    }
    return observable;
  };
}

// ../lix-sdk/src/lix/open-lix.ts
async function openLix(args) {
  var _a;
  const storage = (_a = args.storage) != null ? _a : new InMemoryStorage();
  const database = await storage.open();
  if (args.blob) {
    await storage.import(args.blob);
  }
  const hooks = createHooks();
  const db = initDb({ sqlite: database, hooks });
  if ("onStateCommit" in storage && storage.onStateCommit) {
    hooks.onStateCommit(() => {
      storage.onStateCommit();
    });
  }
  if (args.keyValues && args.keyValues.length > 0) {
    for (const keyValue of args.keyValues) {
      const existing = await db.selectFrom("key_value").select("key").where("key", "=", keyValue.key).executeTakeFirst();
      if (existing) {
        await db.updateTable("key_value").set({ value: keyValue.value }).where("key", "=", keyValue.key).execute();
      } else {
        await db.insertInto("key_value").values(keyValue).execute();
      }
    }
  }
  if (args.account) {
    await db.transaction().execute(async (trx) => {
      await trx.deleteFrom("active_account").execute();
      await trx.insertInto("active_account").values(args.account).onConflict((oc) => oc.doUpdateSet(() => ({ ...args.account }))).execute();
    });
  }
  const plugins = [];
  if (args.providePlugins && args.providePlugins.length > 0) {
    plugins.push(...args.providePlugins);
  }
  const plugin = {
    getAll: async () => plugins,
    getAllSync: () => plugins
  };
  captureOpened({ db });
  const observe = createObserve({ hooks });
  const lix = {
    db,
    sqlite: database,
    plugin,
    hooks,
    observe,
    close: async () => {
      await storage.close();
    },
    toBlob: async () => {
      return storage.export();
    }
  };
  applyFileDatabaseSchema(lix);
  return lix;
}
async function captureOpened(args) {
  var _a;
  try {
    const telemetry = await args.db.selectFrom("key_value").select("value").where("key", "=", "lix_telemetry").executeTakeFirst();
    if ((telemetry == null ? void 0 : telemetry.value) === "off") {
      return;
    }
    const activeAccount = await args.db.selectFrom("active_account").select("id").executeTakeFirstOrThrow();
    const lixId = await args.db.selectFrom("key_value").select("value").where("key", "=", "lix_id").executeTakeFirstOrThrow();
    const fileExtensions = await usedFileExtensions(args.db);
    if (Math.random() > 0.1) {
      await capture("LIX-SDK lix opened", {
        accountId: activeAccount.id,
        lixId: lixId.value,
        telemetryKeyValue: (_a = telemetry == null ? void 0 : telemetry.value) != null ? _a : "on",
        properties: {
          lix_sdk_version: ENV_VARIABLES.LIX_SDK_VERSION,
          stored_file_extensions: fileExtensions
        }
      });
    }
  } catch (e) {
  }
}
async function usedFileExtensions(db) {
  const result = await sql`
	WITH RECURSIVE numbers(i) AS (
		SELECT 1
		UNION ALL
		SELECT i + 1 FROM numbers WHERE i < 1000 -- Limit to 1000 characters for path length
	),
	REVERSED AS (
		SELECT id,
					GROUP_CONCAT(SUBSTR(path, LENGTH(path) - i + 1, 1), '') AS reversed_path
		FROM file, numbers
		WHERE i <= LENGTH(path)
		GROUP BY id, path
	),
	EXTENSIONS AS (
		SELECT DISTINCT SUBSTR(path, LENGTH(path) - INSTR(reversed_path, '.') + 2) AS extension
		FROM file
		JOIN REVERSED ON file.id = REVERSED.id
		WHERE INSTR(reversed_path, '.') > 0
	)
	SELECT extension FROM EXTENSIONS;
	`.execute(db);
  return result.rows.map((row) => row.extension);
}

// ../lix-sdk/src/lix/storage/opfs.ts
var OpfsStorage = class {
  /**
   * Creates a new OpfsStorage instance.
   *
   * @param args.path - Path/name of the file to store in OPFS
   */
  constructor(args) {
    __publicField(this, "database");
    __publicField(this, "path");
    __publicField(this, "opfsRoot");
    __publicField(this, "savePromise");
    __publicField(this, "pendingSave", false);
    if (!("navigator" in globalThis) || !("storage" in navigator) || !("getDirectory" in navigator.storage)) {
      throw new Error("OPFS is not supported in this environment");
    }
    this.path = args.path;
  }
  /**
   * Opens a database with OPFS persistence.
   *
   * Loads existing data from OPFS if available, otherwise creates a new lix.
   * Returns the same database instance on subsequent calls.
   */
  async open() {
    if (!this.database) {
      this.database = await createInMemoryDatabase({ readOnly: false });
      this.opfsRoot = await navigator.storage.getDirectory();
      try {
        const fileHandle = await this.opfsRoot.getFileHandle(this.path);
        const file = await fileHandle.getFile();
        const content = new Uint8Array(await file.arrayBuffer());
        importDatabase({
          db: this.database,
          content
        });
      } catch (e) {
        const blob = await newLixFile();
        importDatabase({
          db: this.database,
          content: new Uint8Array(await blob.arrayBuffer())
        });
        await this.save();
      }
    }
    return this.database;
  }
  /**
   * Closes the database connection.
   *
   * Performs a final save to OPFS before closing.
   */
  async close() {
    if (this.database) {
      await this.save();
      this.database = void 0;
    }
  }
  /**
   * Imports data from a blob, replacing the current database content.
   *
   * Also saves the imported data to OPFS.
   */
  async import(blob) {
    const database = await this.open();
    importDatabase({
      db: database,
      content: new Uint8Array(await blob.arrayBuffer())
    });
    await this.save();
  }
  /**
   * Exports the current database state as a blob.
   */
  async export() {
    const database = await this.open();
    const content = contentFromDatabase(database);
    return new Blob([content]);
  }
  /**
   * Saves the current database state to OPFS.
   *
   * This method is called automatically during import/close,
   * and can be called manually or triggered by the hooks system.
   */
  async save() {
    if (!this.database || !this.opfsRoot) {
      return;
    }
    const content = contentFromDatabase(this.database);
    const fileHandle = await this.opfsRoot.getFileHandle(this.path, {
      create: true
    });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();
  }
  /**
   * Called when state commits happen.
   * Automatically saves the current state to OPFS.
   */
  onStateCommit() {
    this.batchedSave();
  }
  /**
   * Batches save operations to avoid multiple concurrent saves.
   * Only one save operation will run at a time, with the latest state.
   */
  batchedSave() {
    if (this.savePromise) {
      this.pendingSave = true;
      return;
    }
    this.savePromise = this.save().then(() => {
      if (this.pendingSave) {
        this.pendingSave = false;
        this.savePromise = void 0;
        this.batchedSave();
      } else {
        this.savePromise = void 0;
      }
    }).catch((error) => {
      console.error("Error saving to OPFS:", error);
      this.savePromise = void 0;
      this.pendingSave = false;
    });
  }
};

// ../lix-sdk/src/log/create-log.ts
async function createLog(args) {
  const id = nanoid();
  await args.lix.db.insertInto("log").values({
    id,
    key: args.key,
    message: args.message,
    level: args.level
  }).execute();
  return await args.lix.db.selectFrom("log").where("id", "=", id).selectAll().executeTakeFirstOrThrow();
}

// ../lix-sdk/src/plugin/mock-json-plugin.flatten.ts
function isBuffer(obj) {
  return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function keyIdentity(key) {
  return key;
}
function flatten(target, opts) {
  opts = opts || {};
  const delimiter = opts.delimiter || ".";
  const maxDepth = opts.maxDepth;
  const transformKey = opts.transformKey || keyIdentity;
  const output = {};
  function step(object, prev, currentDepth) {
    currentDepth = currentDepth || 1;
    Object.keys(object).forEach(function(key) {
      const value = object[key];
      const isarray = opts.safe && Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isbuffer = isBuffer(value);
      const isobject = type === "[object Object]" || type === "[object Array]";
      const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
        return step(value, newKey, currentDepth + 1);
      }
      output[newKey] = value;
    });
  }
  step(target);
  return output;
}
function unflatten(target, opts) {
  opts = opts || {};
  const delimiter = opts.delimiter || ".";
  const overwrite = opts.overwrite || false;
  const transformKey = opts.transformKey || keyIdentity;
  const result = {};
  const isbuffer = isBuffer(target);
  if (isbuffer || Object.prototype.toString.call(target) !== "[object Object]") {
    return target;
  }
  function getkey(key) {
    const parsedKey = Number(key);
    return isNaN(parsedKey) || key.indexOf(".") !== -1 || opts.object ? key : parsedKey;
  }
  function addKeys(keyPrefix, recipient, target2) {
    return Object.keys(target2).reduce(function(result2, key) {
      result2[keyPrefix + delimiter + key] = target2[key];
      return result2;
    }, recipient);
  }
  function isEmpty(val) {
    const type = Object.prototype.toString.call(val);
    const isArray = type === "[object Array]";
    const isObject2 = type === "[object Object]";
    if (!val) {
      return true;
    } else if (isArray) {
      return !val.length;
    } else if (isObject2) {
      return !Object.keys(val).length;
    }
  }
  target = Object.keys(target).reduce(function(result2, key) {
    const type = Object.prototype.toString.call(target[key]);
    const isObject2 = type === "[object Object]" || type === "[object Array]";
    if (!isObject2 || isEmpty(target[key])) {
      result2[key] = target[key];
      return result2;
    } else {
      return addKeys(key, result2, flatten(target[key], opts));
    }
  }, {});
  Object.keys(target).forEach(function(key) {
    const split = key.split(delimiter).map(transformKey);
    let key1 = getkey(split.shift());
    let key2 = getkey(split[0]);
    let recipient = result;
    while (key2 !== void 0) {
      if (key1 === "__proto__") {
        return;
      }
      const type = Object.prototype.toString.call(recipient[key1]);
      const isobject = type === "[object Object]" || type === "[object Array]";
      if (!overwrite && !isobject && typeof recipient[key1] !== "undefined") {
        return;
      }
      if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
        recipient[key1] = typeof key2 === "number" && !opts.object ? [] : {};
      }
      recipient = recipient[key1];
      if (split.length > 0) {
        key1 = getkey(split.shift());
        key2 = getkey(split[0]);
      }
    }
    recipient[key1] = unflatten(target[key], opts);
  });
  return result;
}

// ../lix-sdk/src/plugin/mock-json-plugin.ts
var MockJsonPropertySchema = {
  type: "object",
  properties: {
    value: JSONTypeSchema
  },
  required: ["value"],
  "x-lix-key": "mock_json_property",
  "x-lix-version": "1.0"
};
var mockJsonPlugin = {
  key: "mock_json_plugin",
  detectChangesGlob: "*.json",
  detectChanges: ({ before, after }) => {
    const detectedChanges = [];
    const beforeParsed = (before == null ? void 0 : before.data) ? JSON.parse(new TextDecoder().decode(before == null ? void 0 : before.data)) : {};
    const afterParsed = (after == null ? void 0 : after.data) ? JSON.parse(new TextDecoder().decode(after == null ? void 0 : after.data)) : {};
    const flattenedBefore = flatten(beforeParsed, {
      safe: true
    });
    const flattenedAfter = flatten(afterParsed, {
      safe: true
    });
    for (const key in flattenedBefore) {
      if (!(key in flattenedAfter)) {
        detectedChanges.push({
          schema: MockJsonPropertySchema,
          entity_id: key,
          snapshot_content: null
          // Indicates deletion of this property
        });
      } else if (JSON.stringify(flattenedBefore[key]) !== JSON.stringify(flattenedAfter[key])) {
        detectedChanges.push({
          schema: MockJsonPropertySchema,
          entity_id: key,
          snapshot_content: { value: flattenedAfter[key] }
        });
      }
    }
    for (const key in flattenedAfter) {
      if (!(key in flattenedBefore)) {
        detectedChanges.push({
          schema: MockJsonPropertySchema,
          entity_id: key,
          snapshot_content: { value: flattenedAfter[key] }
        });
      }
    }
    return detectedChanges;
  },
  applyChanges: ({ file, changes }) => {
    let flattened = {};
    if (file.data && file.data.length > 0) {
      try {
        flattened = flatten(JSON.parse(new TextDecoder().decode(file.data)), {
          delimiter: "."
        });
      } catch (error) {
        console.error("Failed to parse existing file data:", error);
      }
    }
    for (const change of changes) {
      if (change.snapshot_content === null) {
        delete flattened[change.entity_id];
      } else {
        flattened[change.entity_id] = change.snapshot_content.value;
      }
    }
    return {
      fileData: new TextEncoder().encode(
        JSON.stringify(unflatten(flattened, { delimiter: "." }))
      )
    };
  }
};

// ../lix-sdk/src/query-filter/change-has-label.ts
function changeHasLabel(label) {
  return (eb) => eb(
    "change.id",
    "in",
    (subquery) => subquery.selectFrom("change_set_element").innerJoin(
      "change_set_label",
      "change_set_label.change_set_id",
      "change_set_element.change_set_id"
    ).innerJoin("label", "label.id", "change_set_label.label_id").select("change_set_element.change_id").$if("name" in label, (eb2) => eb2.where("label.name", "=", label.name)).$if("id" in label, (eb2) => eb2.where("label.id", "=", label.id))
  );
}

// ../lix-sdk/src/query-filter/change-set-is-descendant-of.ts
function changeSetIsDescendantOf(changeSet, options) {
  var _a;
  const depthLimit = options == null ? void 0 : options.depth;
  const includeSelf = (_a = options == null ? void 0 : options.includeSelf) != null ? _a : false;
  return () => sql`
			change_set.id IN (
				WITH RECURSIVE dp(id, depth) AS (
					SELECT id, 0 AS depth FROM change_set WHERE id = ${sql.lit(changeSet.id)}
					UNION ALL
					SELECT change_set_edge.child_id, dp.depth + 1
					FROM change_set_edge
					JOIN dp ON change_set_edge.parent_id = dp.id
					${depthLimit !== void 0 ? sql`WHERE dp.depth < ${sql.lit(depthLimit)}` : sql``}
				)
				-- Select based on the includeSelf flag
				SELECT id FROM dp ${includeSelf ? sql`` : sql`WHERE depth > 0`}
			)
		`;
}

// ../lix-sdk/src/query-filter/change-set-element-in-symmetric-difference.ts
function changeSetElementInSymmetricDifference(a, b) {
  return (eb) => eb.or([
    eb(
      "change_set_element.change_id",
      "in",
      (subquery) => subquery.selectFrom("change_set_element as A").leftJoin(
        "change_set_element as B",
        (join) => join.onRef("A.change_id", "=", "B.change_id").on("B.change_set_id", "=", b.id)
      ).where("A.change_set_id", "=", a.id).where("B.change_id", "is", null).select("A.change_id")
    ),
    eb(
      "change_set_element.change_id",
      "in",
      (subquery) => subquery.selectFrom("change_set_element as B").leftJoin(
        "change_set_element as A",
        (join) => join.onRef("B.change_id", "=", "A.change_id").on("A.change_set_id", "=", a.id)
      ).where("B.change_set_id", "=", b.id).where("A.change_id", "is", null).select("B.change_id")
    )
  ]);
}

// ../lix-sdk/src/schema-definition/validate-lix-schema.ts
var import_ajv2 = __toESM(require_ajv());
var ajv2 = new import_ajv2.Ajv({
  strict: true,
  // allow 'x-*' properties in alignment with new json schema spec
  // https://json-schema.org/blog/posts/stable-json-schema
  strictSchema: false
});
var _validateLixSchemaDefinition = ajv2.compile(LixSchemaDefinition);
function validateLixSchema2(schema, data) {
  const schemaValid = _validateLixSchemaDefinition(schema);
  if (!schemaValid) {
    throw new Error(
      `Invalid Lix schema definition: ${JSON.stringify(_validateLixSchemaDefinition.errors, null, 2)}`
    );
  }
  const dataValidator = ajv2.compile(schema);
  const dataValid = dataValidator(data);
  if (!dataValid) {
    throw new Error(
      `Data validation failed: ${JSON.stringify(dataValidator.errors, null, 2)}`
    );
  }
  return true;
}
function validateLixSchemaDefinition(schema) {
  const valid = _validateLixSchemaDefinition(schema);
  if (!valid) {
    throw new Error(
      `Invalid Lix schema definition: ${JSON.stringify(_validateLixSchemaDefinition.errors, null, 2)}`
    );
  }
  return valid;
}

// ../lix-sdk/src/server-protocol-handler/routes/new-v1.ts
var route = async (context) => {
  const blob = await context.request.blob();
  let lix;
  try {
    lix = await openLix({
      blob,
      // turn off sync for server
      keyValues: [{ key: "lix_sync", value: "false" }]
    });
  } catch (e) {
    return new Response(null, {
      status: 400
    });
  }
  const lixId = await lix.db.selectFrom("key_value").where("key", "=", "lix_id").selectAll().executeTakeFirstOrThrow();
  const exists = await context.environment.hasLix({ id: lixId.value });
  if (exists) {
    return new Response(null, {
      status: 409
    });
  }
  await context.environment.setLix({ id: lixId.value, blob });
  return new Response(JSON.stringify({ id: lixId.value }), {
    status: 201,
    headers: {
      "Content-Type": "application/json"
    }
  });
};

// ../lix-sdk/src/sync/merge-state.ts
async function mergeTheirState(args) {
  const executeInTransaction = async (trx) => {
    var _a;
    const myVectorClock = await trx.selectFrom("mutation_log").select(({ fn }) => {
      return ["session", fn.max("session_time").as("time")];
    }).where("mutation_log.table_name", "<>", "mutation_log").groupBy("session").execute();
    const unrecognizedSesionTicks = aheadSessions(
      myVectorClock,
      args.sourceVectorClock
    );
    const moreRecentRowUpdatesUnknownBySource = unrecognizedSesionTicks.length === 0 ? [] : await trx.selectFrom("mutation_log").select(({ fn }) => {
      return [
        "table_name",
        "row_id",
        fn.max("wall_clock").as("last_updated_wall_time")
      ];
    }).where((eb) => {
      return eb.or(
        unrecognizedSesionTicks.map(({ session, time }) => {
          return eb("session", "=", session).and(
            "session_time",
            ">",
            time
          );
        })
      );
    }).where("mutation_log.table_name", "<>", "mutation_log").groupBy("row_id").execute();
    const rowsIUpdatedLast = moreRecentRowUpdatesUnknownBySource.reduce(
      (acc, { table_name, row_id, last_updated_wall_time }) => {
        if (!acc[table_name]) {
          acc[table_name] = {};
        }
        acc[table_name][rowIdToString(table_name, row_id)] = last_updated_wall_time;
        return acc;
      },
      {}
    );
    const sourceMutationLog = args.sourceData["mutation_log"];
    if (sourceMutationLog === void 0) {
      throw new Error("Missing mutation log in source data");
    }
    for (let i = 0; i < sourceMutationLog.length; i++) {
      const opertionInSource = sourceMutationLog[i];
      const tableName = opertionInSource["table_name"];
      const time = opertionInSource["wall_clock"];
      const row_id = rowIdToString(tableName, opertionInSource["row_id"]);
      if (rowsIUpdatedLast[tableName] && rowsIUpdatedLast[tableName][row_id] && rowsIUpdatedLast[tableName][row_id] < time) {
        delete rowsIUpdatedLast[tableName][row_id];
      }
    }
    if (args.sourceData["mutation_log"]) {
      for (const row of args.sourceData["mutation_log"]) {
        await trx.insertInto("mutation_log").values(row).execute();
      }
    }
    await trx.insertInto("mutation_log").values({
      session: "mock",
      wall_clock: 0,
      session_time: 0,
      row_id: { ignored: "ignored" },
      table_name: "mutation_log",
      operation: "INSERT"
    }).execute();
    for (const tableName of tablesByDepencies) {
      const tableRows = args.sourceData[tableName];
      if (tableRows === void 0) {
        continue;
      }
      for (const row of tableRows) {
        if (((_a = rowsIUpdatedLast[tableName]) == null ? void 0 : _a[rowIdToString(tableName, row)]) === void 0) {
          if (tableName === "snapshot") {
            delete row.id;
          }
          const statment = trx.insertInto(tableName).values(row).onConflict((oc) => {
            for (const idColumn of tableIdColumns[tableName]) {
              oc = oc.column(idColumn);
            }
            return oc.doUpdateSet(row);
          });
          await statment.execute();
        } else {
          console.log(
            "Row skiped - " + tableName + " - " + rowIdToString(tableName, row)
          );
        }
      }
    }
    await trx.deleteFrom("mutation_log").where("table_name", "=", "mutation_log").execute();
  };
  if (args.lix.db.isTransaction) {
    return await executeInTransaction(args.lix.db);
  } else {
    return await args.lix.db.transaction().execute(executeInTransaction);
  }
}
function aheadSessions(mine, theirs) {
  const mineSessionMap = new Map(
    mine.map(({ session, time }) => [session, time])
  );
  const theirSessionMap = new Map(
    theirs.map(({ session, time }) => [session, time])
  );
  const aheadSession = [];
  const allSessions = /* @__PURE__ */ new Set([
    ...mineSessionMap.keys(),
    ...theirSessionMap.keys()
  ]);
  allSessions.forEach((session) => {
    const myTime = mineSessionMap.get(session);
    const theirTime = theirSessionMap.get(session);
    if (myTime && (theirTime === void 0 || myTime > theirTime)) {
      aheadSession.push({ session, time: theirTime != null ? theirTime : 0 });
    }
  });
  return aheadSession;
}
function rowIdToString(tableName, rowId) {
  const idColumns = tableIdColumns[tableName];
  let rowIdString = tableName;
  for (const idColumn of idColumns) {
    if (!rowId[idColumn]) {
      throw new Error(`Missing id column ${idColumn} in row id`);
    }
    rowIdString += `_${rowId[idColumn]}`;
  }
  return rowIdString;
}

// ../lix-sdk/src/server-protocol-handler/routes/push-v1.ts
var route2 = async (context) => {
  const body = await context.request.json();
  const exists = await context.environment.hasLix({ id: body.lix_id });
  if (!exists) {
    return new Response(null, { status: 404 });
  }
  const open = await context.environment.openLix({ id: body.lix_id });
  try {
    await open.lix.db.transaction().execute(async (trx) => {
      var _a, _b;
      await trx.executeQuery(
        CompiledQuery.raw("PRAGMA defer_foreign_keys = ON;")
      );
      await mergeTheirState({
        lix: { ...open.lix, db: trx },
        sourceVectorClock: body.vector_clock,
        sourceData: body.data
      });
      const allIncomingChanges = (_a = body.data.change) != null ? _a : [];
      const incomingVersionChanges = {};
      for (const change of (_b = body.data.change) != null ? _b : []) {
        if (change.schema_key !== "lix_version_change_table") {
          continue;
        }
        const [versionId] = change.entity_id.split(",");
        if (versionId === void 0) {
          throw new Error("Expected versionId to be defined");
        }
        if (!incomingVersionChanges[versionId]) {
          incomingVersionChanges[versionId] = [];
        }
        incomingVersionChanges[versionId].push(change);
      }
      for (const [versionId, versionChanges] of Object.entries(
        incomingVersionChanges
      )) {
        const incomingChanges = await Promise.all(
          versionChanges.map(async (change) => {
            const [, changeId] = change.entity_id.split(",");
            const foundChange = allIncomingChanges.find(
              (c) => c.id === changeId
            );
            if (foundChange === void 0) {
              const fallback = await trx.selectFrom("change").where("id", "=", changeId).selectAll().executeTakeFirst();
              if (fallback) {
                return fallback;
              } else {
                throw new Error(
                  "Change not found. Expected to find a change for the version change in the incoming changes."
                );
              }
            }
            return foundChange;
          })
        );
        const existingChanges = [];
        await Promise.all(
          incomingChanges.map(async (change) => {
            const existingChange = await trx.selectFrom("version_change").innerJoin("change", "version_change.change_id", "change.id").where("version_change.version_id", "=", versionId).where("change.file_id", "=", change.file_id).where("change.schema_key", "=", change.schema_key).where("change.entity_id", "=", change.entity_id).where("change.id", "!=", change.id).selectAll("change").executeTakeFirst();
            if (existingChange) {
              existingChanges.push(existingChange);
            }
          })
        );
      }
    });
    await context.environment.closeLix(open);
    return new Response(null, {
      status: 201
    });
  } catch (error) {
    return new Response(
      JSON.stringify({
        code: "FAILED_TO_INSERT_DATA",
        message: error == null ? void 0 : error.message
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  }
};

// ../lix-sdk/src/sync/get-diffing-rows.ts
async function getDiffingRows(args) {
  const upsertedRows = {};
  let state = [];
  const executeInTransaction = async (trx) => {
    state = await trx.selectFrom("mutation_log").select(({ fn }) => {
      return ["session", fn.max("session_time").as("time")];
    }).groupBy("session").execute();
    let operationsToPush = trx.selectFrom("mutation_log").selectAll("mutation_log");
    if (args.targetVectorClock.length > 0) {
      operationsToPush = operationsToPush.where((eb) => {
        const knownSessions = args.targetVectorClock.map(
          (sessionTime) => sessionTime.session
        );
        const ors = [];
        ors.push(eb("session", "not in", knownSessions));
        for (const sessionTime of args.targetVectorClock) {
          ors.push(
            eb("session", "=", sessionTime.session).and(
              "session_time",
              ">",
              sessionTime.time
            )
          );
        }
        return eb.or(ors);
      });
    }
    upsertedRows["mutation_log"] = await operationsToPush.execute();
    for (const operation of upsertedRows["mutation_log"]) {
      const tableName = operation.table_name;
      if (upsertedRows[tableName] === void 0) {
        upsertedRows[tableName] = [];
      }
      if (tableName === "snapshot") {
        upsertedRows[tableName].push(
          await trx.selectFrom(tableName).selectAll().where("id", "=", operation.row_id["id"]).executeTakeFirstOrThrow()
        );
      } else {
        let diffRow = trx.selectFrom(tableName).selectAll();
        for (const [key, value] of Object.entries(operation.row_id)) {
          diffRow = diffRow.where(key, "=", value);
        }
        upsertedRows[tableName].push(await diffRow.executeTakeFirstOrThrow());
      }
    }
  };
  if (args.lix.db.isTransaction) {
    await executeInTransaction(args.lix.db);
  } else {
    await args.lix.db.transaction().execute(executeInTransaction);
  }
  return {
    state,
    upsertedRows
  };
}

// ../lix-sdk/src/server-protocol-handler/routes/pull-v1.ts
var route3 = async (context) => {
  const body = await context.request.json();
  const exists = await context.environment.hasLix({ id: body.lix_id });
  if (!exists) {
    return new Response(null, { status: 404 });
  }
  const open = await context.environment.openLix({ id: body.lix_id });
  try {
    const { upsertedRows: tableRowsToReturn, state: sessionStatesServer } = await getDiffingRows({
      lix: open.lix,
      targetVectorClock: body.vector_clock
    });
    return new Response(
      JSON.stringify({
        vector_clock: sessionStatesServer,
        data: tableRowsToReturn
      }),
      {
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({
        code: "FAILED_TO_FETCH_DATA",
        message: error == null ? void 0 : error.message
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  } finally {
    await context.environment.closeLix(open);
  }
};

// ../lix-sdk/src/server-protocol-handler/routes/get-v1.ts
var route4 = async (context) => {
  const { lix_id } = await context.request.json();
  if (!lix_id) {
    return new Response(
      JSON.stringify({ error: "Missing required field 'lix_id'" }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
  }
  const exists = await context.environment.hasLix({ id: lix_id });
  if (!exists) {
    return new Response(JSON.stringify({ error: "Lix not found" }), {
      status: 404,
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
  const blob = await context.environment.getLix({ id: lix_id });
  const sqlite = await createInMemoryDatabase({
    readOnly: false
  });
  importDatabase({
    db: sqlite,
    content: new Uint8Array(await blob.arrayBuffer())
  });
  sqlite.exec(
    "UPDATE key_value SET value = json('true') WHERE key = 'lix_sync'"
  );
  const blob2 = new Blob([contentFromDatabase(sqlite)]);
  return new Response(blob2, {
    status: 200,
    headers: {
      "Content-Type": "application/octet-stream",
      "Content-Disposition": `attachment; filename="${lix_id}.bin"`
    }
  });
};

// ../lix-sdk/src/server-protocol-handler/create-server-protocol-handler.ts
async function createServerProtocolHandler(args) {
  const context = { environment: args.environment };
  return async (request) => {
    try {
      const path = new URL(request.url).pathname;
      if (path === "/lsp/get-v1") {
        return await route4({ ...context, request });
      }
      if (path === "/lsp/new-v1") {
        return await route({ ...context, request });
      }
      if (path === "/lsp/push-v1") {
        return await route2({ ...context, request });
      }
      if (path === "/lsp/pull-v1") {
        return await route3({ ...context, request });
      }
      return new Response(null, { status: 404 });
    } catch (error) {
      console.error(error);
      return new Response(error, {
        status: 500
      });
    }
  };
}

// ../lix-sdk/src/server-protocol-handler/environment/create-in-memory-environment.ts
var createLspInMemoryEnvironment = () => {
  const store = /* @__PURE__ */ new Map();
  const openLixes = /* @__PURE__ */ new Map();
  const openConnections = /* @__PURE__ */ new Map();
  return {
    async hasLix(args) {
      return store.has(args.id);
    },
    async getLix(args) {
      return store.get(args.id);
    },
    async setLix(args) {
      store.set(args.id, args.blob);
    },
    async openLix(args) {
      const connectionId = Math.random().toString(36).slice(2);
      let lix;
      if (openLixes.has(args.id)) {
        lix = openLixes.get(args.id);
      } else {
        const blob = store.get(args.id);
        lix = await openLix({
          blob,
          // don't sync the server with itself
          keyValues: [{ key: "lix_sync", value: "false" }]
        });
        lix.sqlite.exec("PRAGMA foreign_keys = OFF;");
        openLixes.set(args.id, lix);
      }
      if (openConnections.has(args.id)) {
        openConnections.get(args.id).add(connectionId);
      } else {
        openConnections.set(args.id, /* @__PURE__ */ new Set([connectionId]));
      }
      return { lix, id: args.id, connectionId };
    },
    async closeLix(args) {
      const connections = openConnections.get(args.id);
      if (!connections) {
        throw new Error(`No open connections for lix ${args.id}`);
      }
      connections.delete(args.connectionId);
      if (connections.size === 0) {
        const lix = openLixes.get(args.id);
        const blob = await lix.toBlob();
        await lix.close();
        openConnections.delete(args.id);
        openLixes.delete(args.id);
        store.set(args.id, blob);
      }
    }
  };
};

// ../lix-sdk/src/thread/create-thread.ts
async function createThread(args) {
  const executeInTransaction = async (trx) => {
    var _a, _b, _c;
    const threadId = (_a = args.id) != null ? _a : nanoid();
    const versionId = (_b = args.versionId) != null ? _b : "global";
    await trx.insertInto("thread_all").values({ id: threadId, lixcol_version_id: versionId }).execute();
    const thread = await trx.selectFrom("thread_all").selectAll().where("id", "=", threadId).where("lixcol_version_id", "=", versionId).executeTakeFirstOrThrow();
    const insertedComments = [];
    for (const [index, comment] of ((_c = args.comments) != null ? _c : []).entries()) {
      const commentId = nanoid();
      await trx.insertInto("thread_comment_all").values({
        id: commentId,
        thread_id: thread.id,
        body: comment.body,
        parent_id: index > 0 ? insertedComments[index - 1].id : null,
        lixcol_version_id: versionId
      }).execute();
      const insertedComment = await trx.selectFrom("thread_comment_all").selectAll().where("id", "=", commentId).where("lixcol_version_id", "=", versionId).executeTakeFirstOrThrow();
      insertedComments.push(insertedComment);
    }
    return { ...thread, comments: insertedComments };
  };
  if (args.lix.db.isTransaction) {
    return await executeInTransaction(args.lix.db);
  } else {
    return await args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/thread/create-thread-comment.ts
async function createThreadComment(args) {
  const executeInTransaction = async (trx) => {
    var _a, _b;
    const commentId = (_a = args.id) != null ? _a : nanoid();
    const existingThread = await trx.selectFrom("thread_all").where("id", "=", args.thread_id).where("lixcol_inherited_from_version_id", "is", null).select("lixcol_version_id").executeTakeFirstOrThrow();
    let parentId = args.parent_id;
    if (parentId === void 0) {
      const leafComment = await trx.selectFrom("thread_comment_all as c1").where("c1.thread_id", "=", args.thread_id).where("c1.lixcol_version_id", "=", existingThread.lixcol_version_id).where(
        (eb) => eb.not(
          eb.exists(
            eb.selectFrom("thread_comment_all as c2").where("c2.thread_id", "=", args.thread_id).where(
              "c2.lixcol_version_id",
              "=",
              existingThread.lixcol_version_id
            ).whereRef("c2.parent_id", "=", "c1.id").select("c2.id")
          )
        )
      ).select("c1.id").executeTakeFirst();
      parentId = (_b = leafComment == null ? void 0 : leafComment.id) != null ? _b : null;
    }
    await trx.insertInto("thread_comment_all").values({
      id: commentId,
      thread_id: args.thread_id,
      body: args.body,
      parent_id: parentId,
      lixcol_version_id: existingThread.lixcol_version_id
    }).execute();
    return await trx.selectFrom("thread_comment_all").selectAll().where("id", "=", commentId).where("lixcol_version_id", "=", existingThread.lixcol_version_id).executeTakeFirstOrThrow();
  };
  if (args.lix.db.isTransaction) {
    return await executeInTransaction(args.lix.db);
  } else {
    return await args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/version/create-version.ts
async function createVersion(args) {
  const executeInTransaction = async (trx) => {
    var _a, _b, _c;
    const workingCs = await createChangeSet({
      lix: { ...args.lix, db: trx },
      lixcol_version_id: "global"
    });
    const cs = (_a = args.changeSet) != null ? _a : await createChangeSet({
      lix: { ...args.lix, db: trx },
      lixcol_version_id: "global"
    });
    const versionId = (_b = args.id) != null ? _b : nanoid();
    await trx.insertInto("version").values({
      id: versionId,
      name: args.name,
      change_set_id: cs.id,
      working_change_set_id: workingCs.id,
      inherits_from_version_id: (_c = args.inherits_from_version_id) != null ? _c : "global"
    }).execute();
    const newVersion = await trx.selectFrom("version").selectAll().where("id", "=", versionId).executeTakeFirstOrThrow();
    return newVersion;
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}

// ../lix-sdk/src/version/switch-version.ts
async function switchVersion(args) {
  const executeInTransaction = async (trx) => {
    await trx.updateTable("active_version").set({ version_id: args.to.id }).execute();
  };
  if (args.lix.db.isTransaction) {
    return executeInTransaction(args.lix.db);
  } else {
    return args.lix.db.transaction().execute(executeInTransaction);
  }
}
//! Deactivated change conflict detection.
//!
//! Led to foreign key bugs etc. Will be reactivated
//! with the "conflicts" milestone

export { InMemoryStorage, JSONTypeSchema, LixAccountSchema, LixChangeAuthorSchema, LixChangeSetEdgeSchema, LixChangeSetElementSchema, LixChangeSetLabelSchema, LixChangeSetSchema, LixChangeSetThreadSchema, LixFileDescriptorSchema, LixKeyValueSchema, LixLabelSchema, LixLogSchema, LixObservable, LixSchemaDefinition, LixStoredSchemaSchema, LixThreadCommentSchema, LixThreadSchema, LixVersionSchema, OpfsStorage, applyChangeSet, applyKeyValueDatabaseSchema, changeHasLabel, changeSetElementInAncestryOf, changeSetElementInSymmetricDifference, changeSetElementIsLeafOf, changeSetHasLabel, changeSetIsAncestorOf, changeSetIsDescendantOf, createAccount, createChangeSet, createCheckpoint, createHooks, createLabel, createLog, createLspInMemoryEnvironment, createMergeChangeSet, createServerProtocolHandler, createThread, createThreadComment, createTransitionChangeSet, createUndoChangeSet, createVersion, executeSync, jsonArrayFrom, jsonObjectFrom, mockJsonPlugin, nanoid, newLixFile, openLix, sql, switchAccount, switchVersion, v7_default as uuidV7, validateLixSchema2 as validateLixSchema, validateLixSchemaDefinition };
