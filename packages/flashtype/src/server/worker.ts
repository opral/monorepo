import { LLM_PROXY_PREFIX } from "../env-variables";
import { handleLlmProxyRequest, type WorkerEnv } from "./llm-proxy";

export type { WorkerEnv as Env } from "./llm-proxy";

/**
 * Handles all requests routed through the Flashtype Cloudflare Worker.
 *
 * Requests starting with `/proxy/llm` are proxied to the Gemini API with the
 * server-side API key injected into the request headers. Everything else is
 * delegated to the static asset binding generated by Wrangler.
 *
 * @example
 * import { handleFetch } from "./src/server/worker";
 * export default { fetch: (request, env) => handleFetch(request, env) };
 */
export async function handleFetch(
	request: Request,
	env: WorkerEnv,
): Promise<Response> {
	const url = new URL(request.url);

	if (url.pathname.startsWith(LLM_PROXY_PREFIX)) {
		return handleLlmProxyRequest({ request, env, url });
	}

	if (url.pathname === "/healthz") {
		return new Response("ok", {
			status: 200,
			headers: { "content-type": "text/plain" },
		});
	}

	try {
		const response = await env.ASSETS.fetch(request);

		// If asset not found and it's a navigation request (not an asset),
		// return index.html for client-side routing
		if (response.status === 404 && !url.pathname.match(/\.[a-zA-Z]+$/)) {
			const indexUrl = new URL(request.url);
			indexUrl.pathname = "/index.html";
			return await env.ASSETS.fetch(new Request(indexUrl, request));
		}

		return response;
	} catch (error) {
		console.error("Asset fetch failed", error);
		return new Response("Not Found", {
			status: 404,
			headers: { "content-type": "text/plain" },
		});
	}
}
