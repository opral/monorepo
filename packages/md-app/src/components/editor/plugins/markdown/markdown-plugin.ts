import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import remarkGfm from "remark-gfm";
import { sanatizeUnknownNodeStructuresInTree } from "./sanitizeUnsupported";
import {
	convertChildrenDeserialize,
	convertNodesSerialize,
	getPlateNodeType,
	MarkdownPlugin,
	MdParagraph,
} from "@udecode/plate-markdown";
import { TText } from "@udecode/plate";
import { AIChatPlugin } from "@udecode/plate-ai/react";
import { EMPTY_DOCUMENT_PROMPT_KEY } from "../empty-document-prompt-plugin";

export const ExtendedMarkdownPlugin = MarkdownPlugin.configure({
	options: {
		disallowedNodes: [SuggestionPlugin.key, EMPTY_DOCUMENT_PROMPT_KEY],
		remarkPlugins: [
			remarkGfm as any,
			// remarkMdx,
			sanatizeUnknownNodeStructuresInTree,
			// sanitizeHtml,
		],
		rules: {
			sanitized_block_html: {
				serialize: (node) => {
					return {
						type: "html",
						value: node.value,
					};
				},
				deserialize(mdastNode) {
					return mdastNode;
				},
			},
			sanitized_inline_html: {
				serialize: (node) => {
					return {
						type: "html",
						value: node.value,
					};
				},
				deserialize(mdastNode) {
					return mdastNode;
				},
			},
			sanitized_block: {
				serialize: (node) => {
					return {
						type: "html",
						value: node.value,
					};
				},
				deserialize(mdastNode) {
					return mdastNode;
				},
			},
			frontmatter: {
				serialize: (node) => {
					return {
						type: "html",
						value: node.value,
					};
				},
				deserialize(mdastNode) {
					return mdastNode;
				},
			},
			html: {
				deserialize: (
					mdastNode
					// deco,
					// options
				) => {
					if (mdastNode.value === "<p><br /></p>") {
						const paragraphType = getPlateNodeType("paragraph");
						return {
							children: [{ text: "\n" } as TText],
							type: paragraphType,
						};
					}
					return {
						text: (mdastNode.value || "").replaceAll("<br />", "\n"),
					};
				},
			},

			p: {
				deserialize: (node, deco, options) => {
					const isKeepLineBreak = options.splitLineBreaks;
					const children = convertChildrenDeserialize(
						node.children,
						deco,
						options
					);
					const paragraphType = getPlateNodeType("paragraph");
					const splitBlockTypes = new Set(["img"]);

					const elements: any[] = [];
					let inlineNodes: any[] = [];

					const flushInlineNodes = () => {
						if (inlineNodes.length > 0) {
							elements.push({
								children: inlineNodes,
								type: paragraphType,
							});
							inlineNodes = [];
						}
					};

					children.forEach(
						(
							child
							// index,
							// children
						) => {
							const { type } = child as { type?: string };

							if (type && splitBlockTypes.has(type)) {
								flushInlineNodes();
								elements.push(child);
							} else if (
								isKeepLineBreak &&
								"text" in child &&
								typeof child.text === "string"
							) {
								const textParts = child.text.split("\n");

								// Handle line break generated by <br>
								const isSingleLineBreak =
									child.text === "\n" && inlineNodes.length === 0;

								if (isSingleLineBreak) {
									inlineNodes.push({ ...child, text: "" });
									flushInlineNodes();

									return;
								}

								textParts.forEach((part, index, array) => {
									const isNotFirstPart = index > 0;
									const isNotLastPart = index < array.length - 1;

									// Create new paragraph for non-first parts
									if (isNotFirstPart) {
										flushInlineNodes();
									}
									// Only add non-empty text
									if (part) {
										inlineNodes.push({ ...child, text: part });
									}
									// Create paragraph break for non-last parts
									if (isNotLastPart) {
										flushInlineNodes();
									}
								});
							} else {
								inlineNodes.push(child);
							}
						}
					);

					flushInlineNodes();

					return elements.length === 1 ? elements[0] : elements;
				},
				serialize: (node, options) => {
					let enrichedChildren = node.children;

					enrichedChildren = enrichedChildren.map(
						(
							child
							// index,
							// childNodes
						) => {
							if (child.text === "\n") {
								return {
									type: "break",
								} as any;
							} else if (typeof child.text === "string") {
								// mask soft breaks breaks
								return {
									...child,
									text: child.text.replaceAll("\n", `\\n`),
								};
							}
							return child;
						}
					);

					const convertedNodes = convertNodesSerialize(
						enrichedChildren,
						options
					) as MdParagraph["children"];

					if (convertedNodes.length === 0) {
						// @ts-expect-error -- options not exposed by plate
						const streaming = options.editor.getOption(
							AIChatPlugin,
							"streaming"
						);
						if (!streaming) {
							return {
								type: "html",
								value: "<br />",
							} as any;
						}
					} else if (
						convertedNodes.length === 1 &&
						enrichedChildren.at(-1)!.type === "break"
					) {
						return {
							type: "html",
							value: "<p><br /></p>",
						} as any;
					} else if (enrichedChildren.at(-1)!.type === "break") {
						// if the last child of the paragraph is a line break add an additional one
						convertedNodes.at(-1)!.type = "html";
						// @ts-expect-error -- value is the right property here
						convertedNodes.at(-1)!.value = "\n<br />";
					} else if (
						convertedNodes.at(-1)!.type === "text" &&
						// @ts-expect-error -- value is the right property here
						(convertedNodes.at(-1)!.value as string).endsWith(`\\n`)
					) {
						// if the last child of the paragraph is a text node that ends with a line break replace it with a br tag

						(convertedNodes.at(-1) as any)!.value =
							// @ts-expect-error -- value is the right property here
							(convertedNodes.at(-1)!.value as string).slice(0, -2);

						convertedNodes.push({
							type: "html",
							value: "<br />",
						});
					}

					const lineBreaksExtracted: MdParagraph["children"] = [];

					convertedNodes.forEach((child) => {
						if (child.type === "text") {
							const textValue = child.value as string;
							textValue.split(`\\n`).forEach((part, partIndex, array) => {
								lineBreaksExtracted.push({
									...child,
									value: part,
								});
								if (partIndex !== array.length - 1) {
									lineBreaksExtracted.push({
										type: "break",
									});
								}
							});
						} else {
							lineBreaksExtracted.push(child);
						}
					});

					// if the last child of the paragraph is a text node that ends with a line break replace it with a br tag

					return {
						children: lineBreaksExtracted,
						type: "paragraph",
					};
				},
			},
		},
	},
});
