import { compileBundle } from "./compileBundle.js"
import { telemetry } from "../services/telemetry/implementation.js"
import { i } from "../services/codegen/identifier.js"
import { getStackInfo } from "../services/telemetry/stack-detection.js"
import { getPackageJson } from "../services/environment/package.js"
import { createRuntime } from "./runtime.js"
import { createRegistry } from "./registry.js"
import { lookup } from "@inlang/sdk"
import { type BundleNested, type ProjectSettings } from "@inlang/sdk2"
import fs from "node:fs/promises"
import * as prettier from "prettier"
import { escapeForSingleQuoteString } from "~/services/codegen/escape.js"

const ignoreDirectory = `# ignore everything because the directory is auto-generated by inlang paraglide-js
# for more info visit https://inlang.com/m/gerre34r/paraglide-js
*
`

export type CompileOptions = {
	bundles: Readonly<BundleNested[]>
	settings: Pick<ProjectSettings, "baseLocale" | "locales">
	projectId: string | undefined
}

const defaultCompileOptions = {
	projectId: undefined,
} satisfies Partial<CompileOptions>

/**
 * A compile function takes a list of messages and project settings and returns
 * a map of file names to file contents.
 *
 * @example
 *   const output = compile({ messages, settings })
 *   console.log(output)
 *   >> { "messages.js": "...", "runtime.js": "..." }
 */
export const compile = async (args: CompileOptions): Promise<Record<string, string>> => {
	const opts = {
		...defaultCompileOptions,
		...args,
	}

	//Maps each language to it's fallback
	//If there is no fallback, it will be undefined
	const fallbackMap = getFallbackMap(opts.settings.locales, opts.settings.baseLocale)

	const compiledBundles = opts.bundles.map((bundle) => compileBundle(bundle, fallbackMap))
	const indexFile = [
		"/* eslint-disable */",
		'import { languageTag } from "./runtime.js"',
		opts.settings.locales
			.map((locale) => `import * as ${i(locale)} from "./messages/${locale}.js"`)
			.join("\n"),
		"\n",
		compiledBundles.map(({ bundle }) => bundle.code).join("\n\n"),
	].join("\n")

	const output: Record<string, string> = {
		".prettierignore": ignoreDirectory,
		".gitignore": ignoreDirectory,
		"runtime.js": await fmt(createRuntime(opts.settings)),
		"registry.js": await fmt(createRegistry()),
		"messages.js": await fmt(indexFile),
	}

	for (const locale of opts.settings.locales) {
		const filename = `messages/${locale}.js`
		let file = ["/* eslint-disable */", "import * as registry from '../registry.js' "].join("\n")

		for (const bundle of compiledBundles) {
			const compiledMessage = bundle.messages[locale]
			if (!compiledMessage) continue
			file += `\n${compiledMessage.code}`
			file += `\nexport { ${i(compiledMessage.source.id)} as ${bundle.bundle.source.id} }`

			// Language Fallbacks
			const locales = bundle.bundle.source.messages.map((m) => m.locale)
			const missingLocales = opts.settings.locales.filter((l) => !locales.includes(l))

			for (const missingLocale of missingLocales) {
				const fallbackLocale = fallbackMap[missingLocale]
				if (fallbackLocale)
					file += `\nexport { ${i(bundle.bundle.source.id)} } from "./${fallbackLocale}.js"`
				else
					file += `\nexport const ${i(bundle.bundle.source.id)} = '${escapeForSingleQuoteString(
						bundle.bundle.source.id
					)}'`
			}

			// Bundle Aliases
			const alias = bundle.bundle.source.alias
				? Object.values(bundle.bundle.source.alias).at(0)
				: undefined

			if (alias) file += `\nexport { ${i(compiledMessage.source.id)} as ${i(alias)} }`
		}

		output[filename] = await fmt(file)
	}

	// telemetry
	const pkgJson = await getPackageJson(fs, process.cwd())
	const stack = getStackInfo(pkgJson)
	telemetry.capture(
		{
			event: "PARAGLIDE-JS compile executed",
			properties: { stack },
		},
		opts.projectId
	)

	telemetry.shutdown()
	return output
}

async function fmt(js: string): Promise<string> {
	return await prettier.format(js, {
		arrowParens: "always",
		singleQuote: true,
		parser: "babel",
		plugins: ["prettier-plugin-jsdoc"],
	})
}

export function getFallbackMap<T extends string>(
	languageTags: T[],
	sourceLanguageTag: NoInfer<T>
): Record<T, T | undefined> {
	return Object.fromEntries(
		languageTags.map((lang) => {
			const fallbackLanguage = lookup(lang, {
				languageTags: languageTags.filter((t) => t !== lang),
				defaultLanguageTag: sourceLanguageTag,
			})

			if (lang === fallbackLanguage) return [lang, undefined]
			else return [lang, fallbackLanguage]
		})
	) as Record<T, T | undefined>
}
