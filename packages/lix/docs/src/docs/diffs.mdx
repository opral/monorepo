import CodeSnippet from "./components/code-snippet";
import * as example from "./examples/diffs.ts";
import exampleSrcCode from "./examples/diffs.ts?raw";

# Entity-Level Diffs

Unlike traditional version control that treats files as opaque blobs of text, Lix understands the _structure_ of your data. Diffs are computed at the entity level, where an "entity" is a semantic unit defined by a plugin. For example:

- **JSON:** A property, array, or nested path.
- **Tables/CSV:** A row or an individual cell.
- **Prose/Markdown:** A paragraph, heading, or list item.

This fine-grained, semantic approach makes changes easier to review, merge, and build powerful user experiences around.

![Diff](/diff.svg)

## Why Entity-Level Diffs?

By operating on entities instead of raw text lines, Lix provides several key advantages over traditional diffing methods.

| Benefit                   | Description                                                                                                                     |
| :------------------------ | :------------------------------------------------------------------------------------------------------------------------------ |
| **Semantic Meaning**      | Diffs represent meaningful changes ("price changed from $10 to $12") not just arbitrary line edits.                             |
| **Precise Attribution**   | Pinpoint exactly who changed what and when, down to a single cell or property, avoiding whole-file noise.                       |
| **Fewer Conflicts**       | Merging changes to different entities (e.g., two different JSON properties) is trivial, even if they are on the same text line. |
| **Pluggable Granularity** | Your domain model drives the diff. Plugins can define what constitutes a "change," tailoring diffs to your specific needs.      |

## Quick Start: Diffing a JSON File

The most straightforward way to see a diff is to query two versions of a file and compare them. The following example gets the current version and the previous version of a JSON file to generate a simple textual diff.

<CodeSnippet
  module={example}
  srcCode={exampleSrcCode}
  sections={["json-file-diff"]}
/>

## How to Get Diff Data

Lix's primary role is to provide you with the "before" and "after" states of your data. Your application can then use this data to calculate and render a diff.

### Diffing an Entire File

As shown in the Quick Start, you can query a file at two different versions to get its complete state at both points in time. This is useful for showing a full before-and-after view of a resource.

### Diffing a Single Entity

For better performance and more granular control, you can query a single entity at two different versions. This is highly efficient as it avoids loading the entire file when you only care about a specific part of the data.

The same principle applies to any entity defined by a Lix plugin, such as a paragraph in a Markdown document or a cell in a CSV file.

<CodeSnippet
  module={example}
  srcCode={exampleSrcCode}
  sections={["entity-diff"]}
/>

## How to Render Diffs

Once you have the "before" and "after" data, you have complete control over how the changes are visualized. There are three common approaches.

| Approach               | Best For                                                   | Control Level |
| :--------------------- | :--------------------------------------------------------- | :------------ |
| **Use a Plugin's UI**  | Quick integration with standard, pre-built components.     | Low           |
| **Use a Diff Library** | Custom integration with powerful, pre-built diffing logic. | Medium        |
| **Build Your Own UI**  | Complete control for bespoke or complex visualizations.    | High          |

### Use a Plugin's UI

Lix plugins can provide ready-to-use diff components that can be rendered directly in your application. This is the fastest way to display changes, but it limits you to the UI and rendering logic provided by the plugin.

```ts
const plugin = await lix.plugin.get({ key: "lix_plugin_csv" });

if (plugin?.renderDiff) {
  const diffComponent = plugin.renderDiff({ before, after });
}
```

### Use a Diff Library

You can use a dedicated library to visualize the changes in your data. Popular options include general-purpose libraries like [diff](https://www.npmjs.com/package/diff) for text, or specialized solutions like the [@lix-js/html-diff](https://github.com/opral/monorepo/tree/main/packages/lix/html-diff) package.

The HTML diff is particularly powerful because it can compare the rendered HTML output of your components, making it a universal tool for visualizing UI changes in any web app.

### Build Your Own UI

For complete control, you can always implement your own diff rendering logic. Because Lix provides structured "before" and "after" states, you can build any kind of diff UI you can imagineâ€”from text-based diffs to visual comparisons of images, designs, or even 3D models.

![Diffs come in many different types](/diffs-many-types.svg)
