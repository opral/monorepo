# How Lix Works

Lix tracks changes at the entity level using SQLite and a commit graph. [Plugins](/docs/plugins) define what constitutes an entity for each file format.

### Step 1: Open a lix with plugins

Plugins (\`.json\`, \`.xlsx\`, etc.) make lix file-format aware. The environment can be swapped for persistence.

```ts
import { openLix, selectWorkingDiff, InMemoryEnvironment } from "@lix-js/sdk";
import { plugin as json } from "@lix-js/plugin-json";

// 1) Create an in-memory lix
const lix = await openLix({
    environment: new InMemoryEnvironment(),
    providePlugins: [json]
});
```

### Step 2: Write a file into the lix

Lix is powered by SQL under the hood. Writing a file, querying diffs, etc. happens all via SQL.

```ts
// 2) Write a file via SQL
await lix.db
  .insertInto("file")
  .values({
    path: "/config.json",
    data: new TextEncoder().encode(JSON.stringify({ theme: "light" })),
  })
  .execute();
```

### Step 3: Query changes, diffs, etc.

Lix tracks changes on the entity level. You can query the history of a specific entity, or the diff between two versions.

```ts
// 3) Log the changes
const diff = await selectWorkingDiff({ lix }).execute();
console.log(diff);
```

## 1. Filesystem

Lix provides a virtual filesystem that abstracts the underlying storage. This allows Lix to run in various environments:

-   **Browser**: Uses [OPFS (Origin Private File System)](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system) for persistent storage or memory for ephemeral sessions.
-   **Node.js**: Wraps the native `fs` module.
-   **Memory**: Fully in-memory implementation for testing or temporary data.

The filesystem handles reading and writing raw files, which are then processed by plugins.

## 2. Plugins

Plugins make Lix file-format aware. They define how to parse files into entities and how to serialize entities back into files.

### Key Functions

-   **`detectChanges({ before, after })`**: Compares the file content before and after a change. It returns a list of `DetectedChange` objects, which represent atomic changes to entities (e.g., a field update in a JSON file).
-   **`applyChanges({ file, changes })`**: Takes a file and a list of changes, and applies them to generate the new file content.

### Example: JSON Plugin

When you write to a `.json` file, the JSON plugin:
1.  Parses the old and new JSON content.
2.  Diffs the objects to find changed fields.
3.  Returns changes for each modified field (entity).

## 3. SQL Preprocessing (Virtual Table)

Lix uses a **SQLite Virtual Table** as a preprocessing layer for all state mutations. This virtual table intercepts SQL operations before they reach the actual storage tables.

### Architecture

```
     User SQL Operations
            │
            v
    ┌─────────────────────┐
    │ State Virtual Table │  <── Entry point for ALL mutations
    └───────┬─────────────┘
            │
            v
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│    MUTATION     │ --> │   TRANSACTION    │ --> │     COMMIT      │
└─────────────────┘     └──────────────────┘     └─────────────────┘
        │                        │                         │
        v                        v                         v
   Validate & Track        Group Changes           Persist to
      Changes              in Changesets          SQLite Tables
```

### The Lifecycle

1.  **Mutation**: The virtual table intercepts `INSERT`, `UPDATE`, or `DELETE` operations on entities. It validates the change and tracks it.
2.  **Transaction**: Multiple mutations are accumulated into a transaction. Changes are grouped into a changeset.
3.  **Commit**: When the transaction commits, the changesets are persisted to the underlying SQLite tables (`lix_internal_change`, `lix_internal_snapshot`).

This architecture ensures:
-   **Transparent Change Tracking**: Users work with standard SQL, and Lix handles the complexity of version control.
-   **ACID Guarantees**: Leveraging SQLite's transaction engine.
-   **Storage Agnostic**: The virtual table can target any SQL-compatible storage, though SQLite is the default.

## Next Steps

-   **[Architecture](/docs/architecture)** - Deep dive into state materialisation and the commit graph.
-   **[Plugins](/docs/plugins)** - Learn how to build custom plugins.
-   **[SQL Interface](/docs/sql-interface)** - Master the SQL API.
