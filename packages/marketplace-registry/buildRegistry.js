import fs from "node:fs/promises";

const repositoryRoot = import.meta.url.slice(
	0,
	import.meta.url.lastIndexOf("inlang/packages")
);
const manifestLinks = JSON.parse(await fs.readFile("./registry.json", "utf-8"));

/** @type {(import("@inlang/marketplace-manifest").MarketplaceManifest)[]} */
const manifests = [];

/**
 * Normalize malformed manifests so the registry build stays resilient.
 * @param {any} manifest
 * @param {string} link
 * @returns {any}
 */
function normalizeManifest(manifest, link) {
	const normalized = { ...manifest };
	const deprecated = normalized.deprecated;

	if (deprecated && typeof deprecated === "object") {
		const reason =
			typeof deprecated.reason === "string" ? deprecated.reason : undefined;
		const replacement =
			typeof deprecated.replacement === "string"
				? deprecated.replacement
				: undefined;
		normalized.deprecated = true;
		if (!normalized.deprecatedMessage && (reason || replacement)) {
			const message = [
				reason,
				replacement ? `Replacement: ${replacement}.` : undefined,
			]
				.filter(Boolean)
				.join(" ");
			normalized.deprecatedMessage = { en: message };
		}
		console.warn(
			`Normalized deprecated object for ${link}. Use boolean deprecated + deprecatedMessage.`
		);
	} else if (typeof deprecated === "string") {
		normalized.deprecated = true;
		if (!normalized.deprecatedMessage) {
			normalized.deprecatedMessage = { en: deprecated };
		}
		console.warn(
			`Normalized deprecated string for ${link}. Use boolean deprecated + deprecatedMessage.`
		);
	} else if (typeof deprecated !== "boolean" && deprecated !== undefined) {
		delete normalized.deprecated;
		console.warn(
			`Removed invalid deprecated value for ${link}. Expected boolean.`
		);
	}

	if (typeof normalized.deprecatedMessage === "string") {
		normalized.deprecatedMessage = { en: normalized.deprecatedMessage };
	}
	if (
		normalized.deprecatedMessage !== undefined &&
		typeof normalized.deprecatedMessage !== "object"
	) {
		delete normalized.deprecatedMessage;
		console.warn(
			`Removed invalid deprecatedMessage value for ${link}. Expected translatable.`
		);
	}

	return normalized;
}

/**
 * Convert relative paths to absolute paths based on the manifest link.
 * @param {string} baseUrl - The base URL of the manifest.
 * @param {string} relativePath - The relative path to convert.
 * @returns {string} - The absolute path.
 */
function toAbsolutePath(baseUrl, relativePath) {
	if (!relativePath.startsWith("./")) {
		return relativePath;
	}
	const base = new URL(baseUrl);
	const path = new URL(relativePath, base).href;
	return new URL(relativePath, base).href;
}

for (const type of Object.keys(manifestLinks)) {
	let manifest;
	// eslint-disable-next-line no-undef
	console.info(`Fetching ${type} manifests...`);

	for (const uniqueID of Object.keys(manifestLinks[type])) {
		const link = manifestLinks[type][uniqueID];

		try {
			if (link.includes("http")) {
				const response = await fetch(link);
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}`);
				}
				manifest = JSON.parse(await response.text());
			} else {
				manifest = JSON.parse(
					await fs.readFile(new URL(link, repositoryRoot), "utf-8")
				);
			}

			manifest = normalizeManifest(manifest, link);

			// Convert relative paths to absolute paths
			if (manifest.pages) {
				for (const page in manifest.pages) {
					const isNamespace = typeof manifest.pages[page] === "object";
					if (isNamespace) {
						for (const namespace in manifest.pages[page]) {
							manifest.pages[page][namespace] = toAbsolutePath(
								link,
								manifest.pages[page][namespace]
							);
						}
					} else {
						manifest.pages[page] = toAbsolutePath(link, manifest.pages[page]);
					}
				}
			}

			if (manifest.readme) {
				if (typeof manifest.readme === "object") {
					for (const lang in manifest.readme) {
						manifest.readme[lang] = toAbsolutePath(link, manifest.readme[lang]);
					}
				} else {
					manifest.readme = toAbsolutePath(link, manifest.readme);
				}
			}

			if (manifest.gallery) {
				manifest.gallery = manifest.gallery.map((path) =>
					toAbsolutePath(link, path)
				);
			}
			if (manifest.icon) {
				manifest.icon = toAbsolutePath(link, manifest.icon);
			}

			manifests.push({
				uniqueID,
				...manifest,
			});
		} catch (e) {
			console.warn(`Skipping manifest '${link}'. ${e}`);
			continue;
		}
	}
}

// checks if every manifest has a unique id
checkUniqueIDs(manifests);

// checks if the module links have the correct schema
checkModuleLinks(manifests);

// sort the manifests by id
manifests.sort((a, b) => {
	if (a.id.toUpperCase() < b.id.toUpperCase()) return -1;
	if (a.id.toUpperCase() > b.id.toUpperCase()) return 1;
	return 0;
});

await fs.writeFile(
	"./src/registry.ts",
	`
	//! Do not edit this file manually. It is automatically generated based on the contents of the registry.manifest file.
	
	import type { MarketplaceManifest } from "@inlang/marketplace-manifest"
	export type Registry = MarketplaceManifest & { uniqueID: string };

	export const registry: Registry[] = ${JSON.stringify(
		manifests.map((manifest) => ({ ...manifest, uniqueID: manifest.uniqueID })),
		undefined,
		"\t"
	)}`
);

// DISABLED BECAUSE TOO MUCH OVERHEAD. Need locally working search index. Screw the cloud.

// if (envVariables.DOPPLER_ENVIRONMENT === "production") {
// 	const client = algoliasearch(
// 		envVariables.ALGOLIA_APPLICATION,
// 		envVariables.ALGOLIA_ADMIN
// 	);
// 	const index = client.initIndex("registry");

// 	const objects = await Promise.all(
// 		[...manifests.values()].map(async (manifest) => {
// 			let readmeLink = undefined;
// 			if (manifest.pages) {
// 				if (manifest.pages["/"]) {
// 					readmeLink = manifest.pages["/"];
// 				} else {
// 					if (
// 						Object.values(manifest.pages).some(
// 							(namespace) => typeof namespace === "object" && namespace["/"]
// 						)
// 					) {
// 						readmeLink = Object.values(manifest.pages).find(
// 							(namespace) => typeof namespace === "object" && namespace["/"]
// 						)["/"];
// 					} else {
// 						throw new Error(`No page at "/" found for ${manifest.id}`);
// 					}
// 				}
// 			} else if (manifest.readme) {
// 				readmeLink =
// 					typeof manifest.readme === "object"
// 						? manifest.readme.en
// 						: manifest.readme;
// 			} else {
// 				throw new Error(`No readmeLink found for ${manifest.id}`);
// 			}

// 			const absolute = toAbsolutePath(readmeLink, repositoryRoot);

// 			const text = absolute.includes("http")
// 				? (await fetch(absolute)).text()
// 				: await fs.readFile(absolute, "utf-8");

// 			return { objectID: uniqueID, readme: text, ...manifest };
// 		})
// 	);

// 	await index.saveObjects(objects);
// 	console.info("Successfully uploaded registry on Algolia");
// }

/* This function checks for uniqueIDs to verify they are not duplicated */
function checkUniqueIDs(manifests) {
	const uniqueIDs = new Set();

	for (const manifest of manifests) {
		if (uniqueIDs.has(manifest.uniqueID)) {
			throw new Error(
				`Manifest with unique id '${manifest.uniqueID}' already exists.`
			);
		}
		uniqueIDs.add(manifest.uniqueID);
	}
}

/* This function checks for the module links to have the correct schema */
function checkModuleLinks(manifests) {
	for (const manifest of manifests) {
		if (manifest.module !== undefined) {
			// should be in this schema https://cdn.jsdelivr.net/npm/PUBLISHER/NAME@latest/PATH
			if (!manifest.module.startsWith("https://cdn.jsdelivr.net/npm/")) {
				throw new Error(
					`Module link '${manifest.module}' does not start with 'https://cdn.jsdelivr.net/npm/'.`
				);
			} else if (!manifest.module.includes("@latest")) {
				throw new Error(
					`Module link '${manifest.module}' does not include a package name.`
				);
			}
		}
	}
}
