var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a2, b2, str) {
      if (a2 instanceof RegExp)
        a2 = maybeMatch(a2, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r5 = range(a2, b2, str);
      return r5 && {
        start: r5[0],
        end: r5[1],
        pre: str.slice(0, r5[0]),
        body: str.slice(r5[0] + a2.length, r5[1]),
        post: str.slice(r5[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m3 = str.match(reg);
      return m3 ? m3[0] : null;
    }
    balanced.range = range;
    function range(a2, b2, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a2);
      var bi = str.indexOf(b2, ai + 1);
      var i3 = ai;
      if (ai >= 0 && bi > 0) {
        if (a2 === b2) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i3 >= 0 && !result) {
          if (i3 == ai) {
            begs.push(i3);
            ai = str.indexOf(a2, i3 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b2, i3 + 1);
          }
          i3 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return str.split(",");
      var pre = m3.pre;
      var body = m3.body;
      var post = m3.post;
      var p2 = pre.split(",");
      p2[p2.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p2[p2.length - 1] += postParts.shift();
        p2.push.apply(p2, postParts);
      }
      parts.push.apply(parts, p2);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i3, y2) {
      return i3 <= y2;
    }
    function gte(i3, y2) {
      return i3 >= y2;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return [str];
      var pre = m3.pre;
      var post = m3.post.length ? expand2(m3.post, false) : [""];
      if (/\$$/.test(m3.pre)) {
        for (var k2 = 0; k2 < post.length; k2++) {
          var expansion = pre + "{" + m3.body + "}" + post[k2];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m3.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m3.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m3.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m3.post.match(/,.*\}/)) {
            str = m3.pre + "{" + m3.body + escClose + m3.post;
            return expand2(str);
          }
          return [str];
        }
        var n5;
        if (isSequence) {
          n5 = m3.body.split(/\.\./);
        } else {
          n5 = parseCommaParts(m3.body);
          if (n5.length === 1) {
            n5 = expand2(n5[0], false).map(embrace);
            if (n5.length === 1) {
              return post.map(function(p2) {
                return m3.pre + n5[0] + p2;
              });
            }
          }
        }
        var N2;
        if (isSequence) {
          var x2 = numeric(n5[0]);
          var y2 = numeric(n5[1]);
          var width = Math.max(n5[0].length, n5[1].length);
          var incr = n5.length == 3 ? Math.abs(numeric(n5[2])) : 1;
          var test = lte;
          var reverse = y2 < x2;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n5.some(isPadded);
          N2 = [];
          for (var i3 = x2; test(i3, y2); i3 += incr) {
            var c4;
            if (isAlphaSequence) {
              c4 = String.fromCharCode(i3);
              if (c4 === "\\")
                c4 = "";
            } else {
              c4 = String(i3);
              if (pad) {
                var need = width - c4.length;
                if (need > 0) {
                  var z2 = new Array(need + 1).join("0");
                  if (i3 < 0)
                    c4 = "-" + z2 + c4.slice(1);
                  else
                    c4 = z2 + c4;
                }
              }
            }
            N2.push(c4);
          }
        } else {
          N2 = [];
          for (var j2 = 0; j2 < n5.length; j2++) {
            N2.push.apply(N2, expand2(n5[j2], false));
          }
        }
        for (var j2 = 0; j2 < N2.length; j2++) {
          for (var k2 = 0; k2 < post.length; k2++) {
            var expansion = pre + N2[j2] + post[k2];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/typebox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;
    exports.Transform = Symbol.for("TypeBox.Transform");
    exports.Readonly = Symbol.for("TypeBox.Readonly");
    exports.Optional = Symbol.for("TypeBox.Optional");
    exports.Hint = Symbol.for("TypeBox.Hint");
    exports.Kind = Symbol.for("TypeBox.Kind");
    exports.PatternBoolean = "(true|false)";
    exports.PatternNumber = "(0|[1-9][0-9]*)";
    exports.PatternString = "(.*)";
    exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
    exports.PatternNumberExact = `^${exports.PatternNumber}$`;
    exports.PatternStringExact = `^${exports.PatternString}$`;
    var TypeRegistry;
    (function(TypeRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      TypeRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      TypeRegistry2.Clear = Clear;
      function Delete(kind) {
        return map.delete(kind);
      }
      TypeRegistry2.Delete = Delete;
      function Has(kind) {
        return map.has(kind);
      }
      TypeRegistry2.Has = Has;
      function Set2(kind, func) {
        map.set(kind, func);
      }
      TypeRegistry2.Set = Set2;
      function Get(kind) {
        return map.get(kind);
      }
      TypeRegistry2.Get = Get;
    })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
    var TypeBoxError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TypeBoxError = TypeBoxError;
    var FormatRegistry;
    (function(FormatRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      FormatRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      FormatRegistry2.Clear = Clear;
      function Delete(format) {
        return map.delete(format);
      }
      FormatRegistry2.Delete = Delete;
      function Has(format) {
        return map.has(format);
      }
      FormatRegistry2.Has = Has;
      function Set2(format, func) {
        map.set(format, func);
      }
      FormatRegistry2.Set = Set2;
      function Get(format) {
        return map.get(format);
      }
      FormatRegistry2.Get = Get;
    })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
    var ValueGuard;
    (function(ValueGuard2) {
      function IsArray(value) {
        return Array.isArray(value);
      }
      ValueGuard2.IsArray = IsArray;
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      ValueGuard2.IsBigInt = IsBigInt;
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      ValueGuard2.IsBoolean = IsBoolean;
      function IsDate(value) {
        return value instanceof globalThis.Date;
      }
      ValueGuard2.IsDate = IsDate;
      function IsNull(value) {
        return value === null;
      }
      ValueGuard2.IsNull = IsNull;
      function IsNumber(value) {
        return typeof value === "number";
      }
      ValueGuard2.IsNumber = IsNumber;
      function IsObject(value) {
        return typeof value === "object" && value !== null;
      }
      ValueGuard2.IsObject = IsObject;
      function IsString(value) {
        return typeof value === "string";
      }
      ValueGuard2.IsString = IsString;
      function IsUint8Array(value) {
        return value instanceof globalThis.Uint8Array;
      }
      ValueGuard2.IsUint8Array = IsUint8Array;
      function IsUndefined(value) {
        return value === void 0;
      }
      ValueGuard2.IsUndefined = IsUndefined;
    })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
    var TypeGuardUnknownTypeError = class extends TypeBoxError {
    };
    exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var TypeGuard;
    (function(TypeGuard2) {
      function IsPattern(value) {
        try {
          new RegExp(value);
          return true;
        } catch {
          return false;
        }
      }
      function IsControlCharacterFree(value) {
        if (!ValueGuard.IsString(value))
          return false;
        for (let i3 = 0; i3 < value.length; i3++) {
          const code = value.charCodeAt(i3);
          if (code >= 7 && code <= 13 || code === 27 || code === 127) {
            return false;
          }
        }
        return true;
      }
      function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
      }
      function IsOptionalBigInt(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
      }
      function IsOptionalNumber(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
      }
      function IsOptionalBoolean(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
      }
      function IsOptionalString(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
      }
      function IsOptionalPattern(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
      }
      function IsOptionalFormat(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
      }
      function IsOptionalSchema(value) {
        return ValueGuard.IsUndefined(value) || TSchema(value);
      }
      function TAny(schema) {
        return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
      }
      TypeGuard2.TAny = TAny;
      function TArray(schema) {
        return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
      }
      TypeGuard2.TArray = TArray;
      function TAsyncIterator(schema) {
        return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
      }
      TypeGuard2.TAsyncIterator = TAsyncIterator;
      function TBigInt(schema) {
        return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
      }
      TypeGuard2.TBigInt = TBigInt;
      function TBoolean(schema) {
        return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TBoolean = TBoolean;
      function TConstructor(schema) {
        return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
      }
      TypeGuard2.TConstructor = TConstructor;
      function TDate(schema) {
        return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
      }
      TypeGuard2.TDate = TDate;
      function TFunction(schema) {
        return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
      }
      TypeGuard2.TFunction = TFunction;
      function TInteger(schema) {
        return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
      }
      TypeGuard2.TInteger = TInteger;
      function TIntersect(schema) {
        return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
      }
      TypeGuard2.TIntersect = TIntersect;
      function TIterator(schema) {
        return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
      }
      TypeGuard2.TIterator = TIterator;
      function TKindOf(schema, kind) {
        return TKind(schema) && schema[exports.Kind] === kind;
      }
      TypeGuard2.TKindOf = TKindOf;
      function TKind(schema) {
        return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);
      }
      TypeGuard2.TKind = TKind;
      function TLiteralString(schema) {
        return TLiteral(schema) && ValueGuard.IsString(schema.const);
      }
      TypeGuard2.TLiteralString = TLiteralString;
      function TLiteralNumber(schema) {
        return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
      }
      TypeGuard2.TLiteralNumber = TLiteralNumber;
      function TLiteralBoolean(schema) {
        return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
      }
      TypeGuard2.TLiteralBoolean = TLiteralBoolean;
      function TLiteral(schema) {
        return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
      }
      TypeGuard2.TLiteral = TLiteral;
      function TNever(schema) {
        return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
      }
      TypeGuard2.TNever = TNever;
      function TNot(schema) {
        return TKindOf(schema, "Not") && TSchema(schema.not);
      }
      TypeGuard2.TNot = TNot;
      function TNull(schema) {
        return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TNull = TNull;
      function TNumber(schema) {
        return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
      }
      TypeGuard2.TNumber = TNumber;
      function TObject(schema) {
        return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
      }
      TypeGuard2.TObject = TObject;
      function TPromise(schema) {
        return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
      }
      TypeGuard2.TPromise = TPromise;
      function TRecord(schema) {
        return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
          const keys = Object.getOwnPropertyNames(schema2.patternProperties);
          return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys[0]]);
        })(schema);
      }
      TypeGuard2.TRecord = TRecord;
      function TRecursive(schema) {
        return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === "Recursive";
      }
      TypeGuard2.TRecursive = TRecursive;
      function TRef(schema) {
        return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
      }
      TypeGuard2.TRef = TRef;
      function TString(schema) {
        return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
      }
      TypeGuard2.TString = TString;
      function TSymbol(schema) {
        return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TSymbol = TSymbol;
      function TTemplateLiteral(schema) {
        return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
      }
      TypeGuard2.TTemplateLiteral = TTemplateLiteral;
      function TThis(schema) {
        return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
      }
      TypeGuard2.TThis = TThis;
      function TTransform(schema) {
        return ValueGuard.IsObject(schema) && exports.Transform in schema;
      }
      TypeGuard2.TTransform = TTransform;
      function TTuple(schema) {
        return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && // empty
        (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
      }
      TypeGuard2.TTuple = TTuple;
      function TUndefined(schema) {
        return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUndefined = TUndefined;
      function TUnionLiteral(schema) {
        return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
      }
      TypeGuard2.TUnionLiteral = TUnionLiteral;
      function TUnion(schema) {
        return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
      }
      TypeGuard2.TUnion = TUnion;
      function TUint8Array(schema) {
        return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
      }
      TypeGuard2.TUint8Array = TUint8Array;
      function TUnknown(schema) {
        return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUnknown = TUnknown;
      function TUnsafe(schema) {
        return TKindOf(schema, "Unsafe");
      }
      TypeGuard2.TUnsafe = TUnsafe;
      function TVoid(schema) {
        return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TVoid = TVoid;
      function TReadonly(schema) {
        return ValueGuard.IsObject(schema) && schema[exports.Readonly] === "Readonly";
      }
      TypeGuard2.TReadonly = TReadonly;
      function TOptional(schema) {
        return ValueGuard.IsObject(schema) && schema[exports.Optional] === "Optional";
      }
      TypeGuard2.TOptional = TOptional;
      function TSchema(schema) {
        return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
      }
      TypeGuard2.TSchema = TSchema;
    })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
    var ExtendsUndefined;
    (function(ExtendsUndefined2) {
      function Check(schema) {
        return schema[exports.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check(schema2)) : schema[exports.Kind] === "Union" ? schema.anyOf.some((schema2) => Check(schema2)) : schema[exports.Kind] === "Undefined" ? true : schema[exports.Kind] === "Not" ? !Check(schema.not) : false;
      }
      ExtendsUndefined2.Check = Check;
    })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
    var TypeExtendsError = class extends TypeBoxError {
    };
    exports.TypeExtendsError = TypeExtendsError;
    var TypeExtendsResult;
    (function(TypeExtendsResult2) {
      TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
      TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
      TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
    })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
    var TypeExtends;
    (function(TypeExtends2) {
      function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
      }
      function Throw(message) {
        throw new TypeExtendsError(message);
      }
      function IsStructuralRight(right) {
        return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
      }
      function StructuralRight(left, right) {
        return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw("StructuralRight");
      }
      function TAnyRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TAny(left, right) {
        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
      }
      function TArrayRight(left, right) {
        return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TArray(left, right) {
        return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TAsyncIterator(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TBigInt(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TBooleanRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TBoolean(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TConstructor(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TDate(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TFunction(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TIntegerRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TInteger(left, right) {
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
      }
      function TIntersectRight(left, right) {
        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TIntersect(left, right) {
        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TIterator(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TLiteral(left, right) {
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;
      }
      function TNeverRight(left, right) {
        return TypeExtendsResult.False;
      }
      function TNever(left, right) {
        return TypeExtendsResult.True;
      }
      function UnwrapTNot(schema) {
        let [current, depth] = [schema, 0];
        while (true) {
          if (!TypeGuard.TNot(current))
            break;
          current = current.not;
          depth += 1;
        }
        return depth % 2 === 0 ? current : exports.Type.Unknown();
      }
      function TNot(left, right) {
        return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
      }
      function TNull(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TNumberRight(left, right) {
        return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TNumber(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsObjectPropertyCount(schema, count) {
        return Object.getOwnPropertyNames(schema.properties).length === count;
      }
      function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectSymbolLike(schema) {
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
      }
      function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectFunctionLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectArrayLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectPromiseLike(schema) {
        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
      }
      function Property(left, right) {
        return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
      }
      function TObjectRight(left, right) {
        return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
          return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
        })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
          return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        })() : TypeExtendsResult.False;
      }
      function TObject(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
          for (const key of Object.getOwnPropertyNames(right.properties)) {
            if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
              return TypeExtendsResult.False;
            }
            if (TypeGuard.TOptional(right.properties[key])) {
              return TypeExtendsResult.True;
            }
            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        })();
      }
      function TPromise(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
      }
      function RecordKey(schema) {
        return exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() : exports.PatternStringExact in schema.patternProperties ? exports.Type.String() : Throw("Unknown record key pattern");
      }
      function RecordValue(schema) {
        return exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] : exports.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
      }
      function TRecordRight(left, right) {
        const [Key, Value] = [RecordKey(right), RecordValue(right)];
        return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {
          for (const key of Object.getOwnPropertyNames(left.properties)) {
            if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        })() : TypeExtendsResult.False;
      }
      function TRecord(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
      }
      function TStringRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TString(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TSymbol(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TTemplateLiteral(left, right) {
        return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
      }
      function IsArrayOfTuple(left, right) {
        return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
      }
      function TTupleRight(left, right) {
        return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
      }
      function TTuple(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUint8Array(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUndefined(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnionRight(left, right) {
        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnion(left, right) {
        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnknownRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TUnknown(left, right) {
        return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function VoidRight(left, right) {
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TVoid(left, right) {
        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Visit(left, right) {
        return (
          // resolvable
          TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : (
            // standard
            TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`)
          )
        );
      }
      function Extends(left, right) {
        return Visit(left, right);
      }
      TypeExtends2.Extends = Extends;
    })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
    var TypeClone;
    (function(TypeClone2) {
      function ArrayType(value) {
        return value.map((value2) => Visit(value2));
      }
      function DateType(value) {
        return new Date(value.getTime());
      }
      function Uint8ArrayType(value) {
        return new Uint8Array(value);
      }
      function ObjectType(value) {
        const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        return { ...clonedProperties, ...clonedSymbols };
      }
      function Visit(value) {
        return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
      }
      function Rest(schemas) {
        return schemas.map((schema) => Type3(schema));
      }
      TypeClone2.Rest = Rest;
      function Type3(schema, options = {}) {
        return { ...Visit(schema), ...options };
      }
      TypeClone2.Type = Type3;
    })(TypeClone || (exports.TypeClone = TypeClone = {}));
    var IndexedAccessor;
    (function(IndexedAccessor2) {
      function OptionalUnwrap(schema) {
        return schema.map((schema2) => {
          const { [exports.Optional]: _2, ...clone } = TypeClone.Type(schema2);
          return clone;
        });
      }
      function IsIntersectOptional(schema) {
        return schema.every((schema2) => TypeGuard.TOptional(schema2));
      }
      function IsUnionOptional(schema) {
        return schema.some((schema2) => TypeGuard.TOptional(schema2));
      }
      function ResolveIntersect(schema) {
        return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
      }
      function ResolveUnion(schema) {
        return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
      }
      function ResolveOptional(schema) {
        return schema[exports.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports.Kind] === "Union" ? ResolveUnion(schema) : schema;
      }
      function TIntersect(schema, key) {
        const resolved = schema.allOf.reduce((acc, schema2) => {
          const indexed = Visit(schema2, key);
          return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports.Type.Intersect(resolved));
      }
      function TUnion(schema, key) {
        const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
        return ResolveOptional(exports.Type.Union(resolved));
      }
      function TObject(schema, key) {
        const property = schema.properties[key];
        return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
      }
      function TTuple(schema, key) {
        const items = schema.items;
        if (ValueGuard.IsUndefined(items))
          return exports.Type.Never();
        const element = items[key];
        if (ValueGuard.IsUndefined(element))
          return exports.Type.Never();
        return element;
      }
      function Visit(schema, key) {
        return schema[exports.Kind] === "Intersect" ? TIntersect(schema, key) : schema[exports.Kind] === "Union" ? TUnion(schema, key) : schema[exports.Kind] === "Object" ? TObject(schema, key) : schema[exports.Kind] === "Tuple" ? TTuple(schema, key) : exports.Type.Never();
      }
      function Resolve(schema, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema, key.toString()));
        return ResolveOptional(exports.Type.Union(resolved, options));
      }
      IndexedAccessor2.Resolve = Resolve;
    })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
    var Intrinsic;
    (function(Intrinsic2) {
      function Uncapitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toLowerCase()}${rest}`;
      }
      function Capitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toUpperCase()}${rest}`;
      }
      function Uppercase(value) {
        return value.toUpperCase();
      }
      function Lowercase(value) {
        return value.toLowerCase();
      }
      function IntrinsicTemplateLiteral(schema, mode) {
        const expression = TemplateLiteralParser.ParseExact(schema.pattern);
        const finite = TemplateLiteralFinite.Check(expression);
        if (!finite)
          return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
        const strings = [...TemplateLiteralGenerator.Generate(expression)];
        const literals = strings.map((value) => exports.Type.Literal(value));
        const mapped = IntrinsicRest(literals, mode);
        const union = exports.Type.Union(mapped);
        return exports.Type.TemplateLiteral([union]);
      }
      function IntrinsicLiteral(value, mode) {
        return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
      }
      function IntrinsicRest(schema, mode) {
        if (schema.length === 0)
          return [];
        const [L, ...R2] = schema;
        return [Map2(L, mode), ...IntrinsicRest(R2, mode)];
      }
      function Visit(schema, mode) {
        return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
      }
      function Map2(schema, mode) {
        return Visit(schema, mode);
      }
      Intrinsic2.Map = Map2;
    })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
    var ObjectMap;
    (function(ObjectMap2) {
      function TIntersect(schema, callback) {
        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function TUnion(schema, callback) {
        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function TObject(schema, callback) {
        return callback(schema);
      }
      function Visit(schema, callback) {
        return schema[exports.Kind] === "Intersect" ? TIntersect(schema, callback) : schema[exports.Kind] === "Union" ? TUnion(schema, callback) : schema[exports.Kind] === "Object" ? TObject(schema, callback) : schema;
      }
      function Map2(schema, callback, options) {
        return { ...Visit(TypeClone.Type(schema), callback), ...options };
      }
      ObjectMap2.Map = Map2;
    })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
    var KeyResolver;
    (function(KeyResolver2) {
      function UnwrapPattern(key) {
        return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
      }
      function TIntersect(schema, options) {
        return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
      }
      function TUnion(schema, options) {
        const sets = schema.anyOf.map((inner) => Visit(inner, options));
        return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
      }
      function TObject(schema, options) {
        return Object.getOwnPropertyNames(schema.properties);
      }
      function TRecord(schema, options) {
        return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
      }
      function Visit(schema, options) {
        return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema, options) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];
      }
      function ResolveKeys(schema, options) {
        return [...new Set(Visit(schema, options))];
      }
      KeyResolver2.ResolveKeys = ResolveKeys;
      function ResolvePattern(schema) {
        const keys = ResolveKeys(schema, { includePatterns: true });
        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern.join("|")})$`;
      }
      KeyResolver2.ResolvePattern = ResolvePattern;
    })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
    var KeyArrayResolverError = class extends TypeBoxError {
    };
    exports.KeyArrayResolverError = KeyArrayResolverError;
    var KeyArrayResolver;
    (function(KeyArrayResolver2) {
      function Resolve(schema) {
        return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
          const expression = TemplateLiteralParser.ParseExact(schema.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
          return [...TemplateLiteralGenerator.Generate(expression)];
        })() : [];
      }
      KeyArrayResolver2.Resolve = Resolve;
    })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
    var UnionResolver;
    (function(UnionResolver2) {
      function* TUnion(union) {
        for (const schema of union.anyOf) {
          if (schema[exports.Kind] === "Union") {
            yield* TUnion(schema);
          } else {
            yield schema;
          }
        }
      }
      function Resolve(union) {
        return exports.Type.Union([...TUnion(union)], { ...union });
      }
      UnionResolver2.Resolve = Resolve;
    })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
    var TemplateLiteralPatternError = class extends TypeBoxError {
    };
    exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
    var TemplateLiteralPattern;
    (function(TemplateLiteralPattern2) {
      function Throw(message) {
        throw new TemplateLiteralPatternError(message);
      }
      function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Visit(schema, acc) {
        return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports.Kind]}'`);
      }
      function Create(kinds) {
        return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
      }
      TemplateLiteralPattern2.Create = Create;
    })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
    var TemplateLiteralResolver;
    (function(TemplateLiteralResolver2) {
      function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
        return exports.Type.Union(literals);
      }
      TemplateLiteralResolver2.Resolve = Resolve;
    })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
    var TemplateLiteralParserError = class extends TypeBoxError {
    };
    exports.TemplateLiteralParserError = TemplateLiteralParserError;
    var TemplateLiteralParser;
    (function(TemplateLiteralParser2) {
      function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
      }
      function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, "(");
      }
      function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ")");
      }
      function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, "|");
      }
      function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
          return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (count === 0 && index !== pattern.length - 1)
            return false;
        }
        return true;
      }
      function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
      }
      function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0)
            return true;
        }
        return false;
      }
      function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            return true;
        }
        return false;
      }
      function Or(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0) {
            const range2 = pattern.slice(start, index);
            if (range2.length > 0)
              expressions.push(Parse(range2));
            start = index + 1;
          }
        }
        const range = pattern.slice(start);
        if (range.length > 0)
          expressions.push(Parse(range));
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "or", expr: expressions };
      }
      function And(pattern) {
        function Group(value, index) {
          if (!IsOpenParen(value, index))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
          let count = 0;
          for (let scan = index; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
              count += 1;
            if (IsCloseParen(value, scan))
              count -= 1;
            if (count === 0)
              return [index, scan];
          }
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range(pattern2, index) {
          for (let scan = index; scan < pattern2.length; scan++) {
            if (IsOpenParen(pattern2, scan))
              return [index, scan];
          }
          return [index, pattern2.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index)) {
            const [start, end] = Group(pattern, index);
            const range = pattern.slice(start, end + 1);
            expressions.push(Parse(range));
            index = end;
          } else {
            const [start, end] = Range(pattern, index);
            const range = pattern.slice(start, end);
            if (range.length > 0)
              expressions.push(Parse(range));
            index = end - 1;
          }
        }
        return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
      }
      function Parse(pattern) {
        return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
      }
      TemplateLiteralParser2.Parse = Parse;
      function ParseExact(pattern) {
        return Parse(pattern.slice(1, pattern.length - 1));
      }
      TemplateLiteralParser2.ParseExact = ParseExact;
    })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
    var TemplateLiteralFiniteError = class extends TypeBoxError {
    };
    exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
    var TemplateLiteralFinite;
    (function(TemplateLiteralFinite2) {
      function Throw(message) {
        throw new TemplateLiteralFiniteError(message);
      }
      function IsNumber(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
      }
      function IsBoolean(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
      }
      function IsString(expression) {
        return expression.type === "const" && expression.const === ".*";
      }
      function Check(expression) {
        return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
      }
      TemplateLiteralFinite2.Check = Check;
    })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
    var TemplateLiteralGeneratorError = class extends TypeBoxError {
    };
    exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
    var TemplateLiteralGenerator;
    (function(TemplateLiteralGenerator2) {
      function* Reduce(buffer) {
        if (buffer.length === 1)
          return yield* buffer[0];
        for (const left of buffer[0]) {
          for (const right of Reduce(buffer.slice(1))) {
            yield `${left}${right}`;
          }
        }
      }
      function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
      }
      function* Or(expression) {
        for (const expr of expression.expr)
          yield* Generate(expr);
      }
      function* Const(expression) {
        return yield expression.const;
      }
      function* Generate(expression) {
        return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
          throw new TemplateLiteralGeneratorError("Unknown expression");
        })();
      }
      TemplateLiteralGenerator2.Generate = Generate;
    })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
    var TemplateLiteralDslParser;
    (function(TemplateLiteralDslParser2) {
      function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, "");
        return trim === "boolean" ? yield exports.Type.Boolean() : trim === "number" ? yield exports.Type.Number() : trim === "bigint" ? yield exports.Type.BigInt() : trim === "string" ? yield exports.Type.String() : yield (() => {
          const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
          return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
        })();
      }
      function* ParseTerminal(template) {
        if (template[1] !== "{") {
          const L = exports.Type.Literal("$");
          const R2 = ParseLiteral(template.slice(1));
          return yield* [L, ...R2];
        }
        for (let i3 = 2; i3 < template.length; i3++) {
          if (template[i3] === "}") {
            const L = ParseUnion(template.slice(2, i3));
            const R2 = ParseLiteral(template.slice(i3 + 1));
            return yield* [...L, ...R2];
          }
        }
        yield exports.Type.Literal(template);
      }
      function* ParseLiteral(template) {
        for (let i3 = 0; i3 < template.length; i3++) {
          if (template[i3] === "$") {
            const L = exports.Type.Literal(template.slice(0, i3));
            const R2 = ParseTerminal(template.slice(i3));
            return yield* [L, ...R2];
          }
        }
        yield exports.Type.Literal(template);
      }
      function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
      }
      TemplateLiteralDslParser2.Parse = Parse;
    })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
    var TransformDecodeBuilder = class {
      constructor(schema) {
        this.schema = schema;
      }
      Decode(decode) {
        return new TransformEncodeBuilder(this.schema, decode);
      }
    };
    exports.TransformDecodeBuilder = TransformDecodeBuilder;
    var TransformEncodeBuilder = class {
      constructor(schema, decode) {
        this.schema = schema;
        this.decode = decode;
      }
      Encode(encode) {
        const schema = TypeClone.Type(this.schema);
        return TypeGuard.TTransform(schema) ? (() => {
          const Encode = (value) => schema[exports.Transform].Encode(encode(value));
          const Decode = (value) => this.decode(schema[exports.Transform].Decode(value));
          const Codec = { Encode, Decode };
          return { ...schema, [exports.Transform]: Codec };
        })() : (() => {
          const Codec = { Decode: this.decode, Encode: encode };
          return { ...schema, [exports.Transform]: Codec };
        })();
      }
    };
    exports.TransformEncodeBuilder = TransformEncodeBuilder;
    var TypeOrdinal = 0;
    var TypeBuilderError = class extends TypeBoxError {
    };
    exports.TypeBuilderError = TypeBuilderError;
    var TypeBuilder = class {
      /** `[Internal]` Creates a schema without `static` and `params` types */
      Create(schema) {
        return schema;
      }
      /** `[Internal]` Throws a TypeBuilder error with the given message */
      Throw(message) {
        throw new TypeBuilderError(message);
      }
      /** `[Internal]` Discards property keys from the given record type */
      Discard(record, keys) {
        return keys.reduce((acc, key) => {
          const { [key]: _2, ...rest } = acc;
          return rest;
        }, record);
      }
      /** `[Json]` Omits compositing symbols from this schema */
      Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
      }
    };
    exports.TypeBuilder = TypeBuilder;
    var JsonTypeBuilder = class extends TypeBuilder {
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Json]` Creates a Readonly and Optional property */
      ReadonlyOptional(schema) {
        return this.Readonly(this.Optional(schema));
      }
      /** `[Json]` Creates a Readonly property */
      Readonly(schema) {
        return { ...TypeClone.Type(schema), [exports.Readonly]: "Readonly" };
      }
      /** `[Json]` Creates an Optional property */
      Optional(schema) {
        return { ...TypeClone.Type(schema), [exports.Optional]: "Optional" };
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Json]` Creates an Any type */
      Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Any" });
      }
      /** `[Json]` Creates an Array type */
      Array(schema, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
      }
      /** `[Json]` Creates a Boolean type */
      Boolean(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
      }
      /** `[Json]` Intrinsic function to Capitalize LiteralString types */
      Capitalize(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
      }
      /** `[Json]` Creates a Composite object type */
      Composite(objects, options) {
        const intersect = exports.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
        return exports.Type.Object(properties, options);
      }
      /** `[Json]` Creates a Enum type */
      Enum(item, options = {}) {
        if (ValueGuard.IsUndefined(item))
          return this.Throw("Enum undefined or empty");
        const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const values2 = [...new Set(values1)];
        const anyOf = values2.map((value) => exports.Type.Literal(value));
        return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
      }
      /** `[Json]` Creates a Conditional type */
      Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
          case TypeExtendsResult.Union:
            return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
          case TypeExtendsResult.True:
            return TypeClone.Type(trueType, options);
          case TypeExtendsResult.False:
            return TypeClone.Type(falseType, options);
        }
      }
      /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
      Exclude(unionType, excludedMembers, options = {}) {
        return TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType) ? (() => {
          const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
        })() : TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType, options);
      }
      /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
      Extract(type, union, options = {}) {
        return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {
          const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
        })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
      }
      /** `[Json]` Returns an Indexed property type for the given keys */
      Index(schema, unresolved, options = {}) {
        return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
          return TypeClone.Type(schema.items, options);
        })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
          const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
          const cloned = items.map((schema2) => TypeClone.Type(schema2));
          return this.Union(cloned, options);
        })() : (() => {
          const keys = KeyArrayResolver.Resolve(unresolved);
          const clone = TypeClone.Type(schema);
          return IndexedAccessor.Resolve(clone, keys, options);
        })();
      }
      /** `[Json]` Creates an Integer type */
      Integer(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
      }
      /** `[Json]` Creates an Intersect type */
      Intersect(allOf, options = {}) {
        if (allOf.length === 0)
          return exports.Type.Never();
        if (allOf.length === 1)
          return TypeClone.Type(allOf[0], options);
        if (allOf.some((schema) => TypeGuard.TTransform(schema)))
          this.Throw("Cannot intersect transform types");
        const objects = allOf.every((schema) => TypeGuard.TObject(schema));
        const cloned = TypeClone.Rest(allOf);
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
        return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
      }
      /** `[Json]` Creates a KeyOf type */
      KeyOf(schema, options = {}) {
        return TypeGuard.TRecord(schema) ? (() => {
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          return pattern === exports.PatternNumberExact ? this.Number(options) : pattern === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
        })() : TypeGuard.TTuple(schema) ? (() => {
          const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
          const literals = items.map((_2, index) => exports.Type.Literal(index.toString()));
          return this.Union(literals, options);
        })() : TypeGuard.TArray(schema) ? (() => {
          return this.Number(options);
        })() : (() => {
          const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
          if (keys.length === 0)
            return this.Never(options);
          const literals = keys.map((key) => this.Literal(key));
          return this.Union(literals, options);
        })();
      }
      /** `[Json]` Creates a Literal type */
      Literal(value, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
      }
      /** `[Json]` Intrinsic function to Lowercase LiteralString types */
      Lowercase(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
      }
      /** `[Json]` Creates a Never type */
      Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
      }
      /** `[Json]` Creates a Not type */
      Not(schema, options) {
        return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema) });
      }
      /** `[Json]` Creates a Null type */
      Null(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
      }
      /** `[Json]` Creates a Number type */
      Number(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
      }
      /** `[Json]` Creates an Object type */
      Object(properties, options = {}) {
        const propertyKeys = Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
        return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
      }
      /** `[Json]` Constructs a type whose keys are omitted from the given type */
      Omit(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
          if (ValueGuard.IsArray(object.required)) {
            object.required = object.required.filter((key) => !keys.includes(key));
            if (object.required.length === 0)
              delete object.required;
          }
          for (const key of Object.getOwnPropertyNames(object.properties)) {
            if (keys.includes(key))
              delete object.properties[key];
          }
          return this.Create(object);
        }, options);
      }
      /** `[Json]` Constructs a type where all properties are optional */
      Partial(schema, options = {}) {
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
          const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
            return { ...acc, [key]: this.Optional(object.properties[key]) };
          }, {});
          return this.Object(
            properties,
            this.Discard(object, ["required"])
            /* object used as options to retain other constraints */
          );
        }, options);
      }
      /** `[Json]` Constructs a type whose keys are picked from the given type */
      Pick(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
          if (ValueGuard.IsArray(object.required)) {
            object.required = object.required.filter((key) => keys.includes(key));
            if (object.required.length === 0)
              delete object.required;
          }
          for (const key of Object.getOwnPropertyNames(object.properties)) {
            if (!keys.includes(key))
              delete object.properties[key];
          }
          return this.Create(object);
        }, options);
      }
      /** `[Json]` Creates a Record type */
      Record(key, schema, options = {}) {
        return TypeGuard.TTemplateLiteral(key) ? (() => {
          const expression = TemplateLiteralParser.ParseExact(key.pattern);
          return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
        })() : TypeGuard.TUnion(key) ? (() => {
          const union = UnionResolver.Resolve(key);
          if (TypeGuard.TUnionLiteral(union)) {
            const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
            return this.Object(properties, { ...options, [exports.Hint]: "Record" });
          } else
            this.Throw("Record key of type union contains non-literal types");
        })() : TypeGuard.TLiteral(key) ? (() => {
          return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
        })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });
        })() : TypeGuard.TString(key) ? (() => {
          const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Type(schema) } });
        })() : this.Never();
      }
      /** `[Json]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        if (ValueGuard.IsUndefined(options.$id))
          options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
      }
      /** `[Json]` Creates a Ref type. */
      Ref(unresolved, options = {}) {
        if (ValueGuard.IsString(unresolved))
          return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
        if (ValueGuard.IsUndefined(unresolved.$id))
          this.Throw("Reference target type must specify an $id");
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
      }
      /** `[Json]` Constructs a type where all properties are required */
      Required(schema, options = {}) {
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
          const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
            return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
          }, {});
          return this.Object(
            properties,
            object
            /* object used as options to retain other constraints  */
          );
        }, options);
      }
      /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
      Rest(schema) {
        return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
      }
      /** `[Json]` Creates a String type */
      String(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
      }
      /** `[Json]` Creates a TemplateLiteral type */
      TemplateLiteral(unresolved, options = {}) {
        const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
        return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
      }
      /** `[Json]` Creates a Transform type */
      Transform(schema) {
        return new TransformDecodeBuilder(schema);
      }
      /** `[Json]` Creates a Tuple type */
      Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = TypeClone.Rest(items);
        const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
        return this.Create(schema);
      }
      /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
      Uncapitalize(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
      }
      /** `[Json]` Creates a Union type */
      Union(union, options = {}) {
        return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
          const anyOf = union;
          if (anyOf.length === 0)
            return this.Never(options);
          if (anyOf.length === 1)
            return this.Create(TypeClone.Type(anyOf[0], options));
          const clonedAnyOf = TypeClone.Rest(anyOf);
          return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
        })();
      }
      /** `[Json]` Creates an Unknown type */
      Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Unknown" });
      }
      /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
      Unsafe(options = {}) {
        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
      }
      /** `[Json]` Intrinsic function to Uppercase LiteralString types */
      Uppercase(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
      }
    };
    exports.JsonTypeBuilder = JsonTypeBuilder;
    var JavaScriptTypeBuilder = class extends JsonTypeBuilder {
      /** `[JavaScript]` Creates a AsyncIterator type */
      AsyncIterator(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
      }
      /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
      Awaited(schema, options = {}) {
        const Unwrap = (rest) => rest.length > 0 ? (() => {
          const [L, ...R2] = rest;
          return [this.Awaited(L), ...Unwrap(R2)];
        })() : rest;
        return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
      }
      /** `[JavaScript]` Creates a BigInt type */
      BigInt(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
      }
      /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema, options = {}) {
        return this.Tuple([...schema.parameters], { ...options });
      }
      /** `[JavaScript]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
        return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[JavaScript]` Creates a Date type */
      Date(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
      }
      /** `[JavaScript]` Creates a Function type */
      Function(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
        return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
      InstanceType(schema, options = {}) {
        return TypeClone.Type(schema.returns, options);
      }
      /** `[JavaScript]` Creates an Iterator type */
      Iterator(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
      }
      /** `[JavaScript]` Extracts the Parameters from the given Function type */
      Parameters(schema, options = {}) {
        return this.Tuple(schema.parameters, { ...options });
      }
      /** `[JavaScript]` Creates a Promise type */
      Promise(item, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
      }
      /** `[Extended]` Creates a String type */
      RegExp(unresolved, options = {}) {
        const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
        return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern });
      }
      /**
       * @deprecated Use `Type.RegExp`
       */
      RegEx(regex, options = {}) {
        return this.RegExp(regex, options);
      }
      /** `[JavaScript]` Extracts the ReturnType from the given Function type */
      ReturnType(schema, options = {}) {
        return TypeClone.Type(schema.returns, options);
      }
      /** `[JavaScript]` Creates a Symbol type */
      Symbol(options) {
        return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
      }
      /** `[JavaScript]` Creates a Undefined type */
      Undefined(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
      }
      /** `[JavaScript]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
      }
      /** `[JavaScript]` Creates a Void type */
      Void(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
      }
    };
    exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
    exports.JsonType = new JsonTypeBuilder();
    exports.Type = new JavaScriptTypeBuilder();
  }
});

// ../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/lib/murmurHash3js.js"(exports, module) {
    (function(root, undefined2) {
      "use strict";
      var library2 = {
        "version": "3.0.1",
        "x86": {},
        "x64": {}
      };
      function _x86Multiply(m3, n5) {
        return (m3 & 65535) * n5 + (((m3 >>> 16) * n5 & 65535) << 16);
      }
      function _x86Rotl(m3, n5) {
        return m3 << n5 | m3 >>> 32 - n5;
      }
      function _x86Fmix(h4) {
        h4 ^= h4 >>> 16;
        h4 = _x86Multiply(h4, 2246822507);
        h4 ^= h4 >>> 13;
        h4 = _x86Multiply(h4, 3266489909);
        h4 ^= h4 >>> 16;
        return h4;
      }
      function _x64Add(m3, n5) {
        m3 = [m3[0] >>> 16, m3[0] & 65535, m3[1] >>> 16, m3[1] & 65535];
        n5 = [n5[0] >>> 16, n5[0] & 65535, n5[1] >>> 16, n5[1] & 65535];
        var o4 = [0, 0, 0, 0];
        o4[3] += m3[3] + n5[3];
        o4[2] += o4[3] >>> 16;
        o4[3] &= 65535;
        o4[2] += m3[2] + n5[2];
        o4[1] += o4[2] >>> 16;
        o4[2] &= 65535;
        o4[1] += m3[1] + n5[1];
        o4[0] += o4[1] >>> 16;
        o4[1] &= 65535;
        o4[0] += m3[0] + n5[0];
        o4[0] &= 65535;
        return [o4[0] << 16 | o4[1], o4[2] << 16 | o4[3]];
      }
      function _x64Multiply(m3, n5) {
        m3 = [m3[0] >>> 16, m3[0] & 65535, m3[1] >>> 16, m3[1] & 65535];
        n5 = [n5[0] >>> 16, n5[0] & 65535, n5[1] >>> 16, n5[1] & 65535];
        var o4 = [0, 0, 0, 0];
        o4[3] += m3[3] * n5[3];
        o4[2] += o4[3] >>> 16;
        o4[3] &= 65535;
        o4[2] += m3[2] * n5[3];
        o4[1] += o4[2] >>> 16;
        o4[2] &= 65535;
        o4[2] += m3[3] * n5[2];
        o4[1] += o4[2] >>> 16;
        o4[2] &= 65535;
        o4[1] += m3[1] * n5[3];
        o4[0] += o4[1] >>> 16;
        o4[1] &= 65535;
        o4[1] += m3[2] * n5[2];
        o4[0] += o4[1] >>> 16;
        o4[1] &= 65535;
        o4[1] += m3[3] * n5[1];
        o4[0] += o4[1] >>> 16;
        o4[1] &= 65535;
        o4[0] += m3[0] * n5[3] + m3[1] * n5[2] + m3[2] * n5[1] + m3[3] * n5[0];
        o4[0] &= 65535;
        return [o4[0] << 16 | o4[1], o4[2] << 16 | o4[3]];
      }
      function _x64Rotl(m3, n5) {
        n5 %= 64;
        if (n5 === 32) {
          return [m3[1], m3[0]];
        } else if (n5 < 32) {
          return [m3[0] << n5 | m3[1] >>> 32 - n5, m3[1] << n5 | m3[0] >>> 32 - n5];
        } else {
          n5 -= 32;
          return [m3[1] << n5 | m3[0] >>> 32 - n5, m3[0] << n5 | m3[1] >>> 32 - n5];
        }
      }
      function _x64LeftShift(m3, n5) {
        n5 %= 64;
        if (n5 === 0) {
          return m3;
        } else if (n5 < 32) {
          return [m3[0] << n5 | m3[1] >>> 32 - n5, m3[1] << n5];
        } else {
          return [m3[1] << n5 - 32, 0];
        }
      }
      function _x64Xor(m3, n5) {
        return [m3[0] ^ n5[0], m3[1] ^ n5[1]];
      }
      function _x64Fmix(h4) {
        h4 = _x64Xor(h4, [0, h4[0] >>> 1]);
        h4 = _x64Multiply(h4, [4283543511, 3981806797]);
        h4 = _x64Xor(h4, [0, h4[0] >>> 1]);
        h4 = _x64Multiply(h4, [3301882366, 444984403]);
        h4 = _x64Xor(h4, [0, h4[0] >>> 1]);
        return h4;
      }
      library2.x86.hash32 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 4;
        var bytes = key.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c22 = 461845907;
        for (var i3 = 0; i3 < bytes; i3 = i3 + 4) {
          k1 = key.charCodeAt(i3) & 255 | (key.charCodeAt(i3 + 1) & 255) << 8 | (key.charCodeAt(i3 + 2) & 255) << 16 | (key.charCodeAt(i3 + 3) & 255) << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c22);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(i3 + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(i3 + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(i3) & 255;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
        }
        h1 ^= key.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library2.x86.hash128 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 16;
        var bytes = key.length - remainder;
        var h1 = seed;
        var h22 = seed;
        var h32 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c22 = 2869860233;
        var c32 = 951274213;
        var c4 = 2716044179;
        for (var i3 = 0; i3 < bytes; i3 = i3 + 16) {
          k1 = key.charCodeAt(i3) & 255 | (key.charCodeAt(i3 + 1) & 255) << 8 | (key.charCodeAt(i3 + 2) & 255) << 16 | (key.charCodeAt(i3 + 3) & 255) << 24;
          k2 = key.charCodeAt(i3 + 4) & 255 | (key.charCodeAt(i3 + 5) & 255) << 8 | (key.charCodeAt(i3 + 6) & 255) << 16 | (key.charCodeAt(i3 + 7) & 255) << 24;
          k3 = key.charCodeAt(i3 + 8) & 255 | (key.charCodeAt(i3 + 9) & 255) << 8 | (key.charCodeAt(i3 + 10) & 255) << 16 | (key.charCodeAt(i3 + 11) & 255) << 24;
          k4 = key.charCodeAt(i3 + 12) & 255 | (key.charCodeAt(i3 + 13) & 255) << 8 | (key.charCodeAt(i3 + 14) & 255) << 16 | (key.charCodeAt(i3 + 15) & 255) << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c22);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h22;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c22);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c32);
          h22 ^= k2;
          h22 = _x86Rotl(h22, 17);
          h22 += h32;
          h22 = _x86Multiply(h22, 5) + 197830471;
          k3 = _x86Multiply(k3, c32);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h32 ^= k3;
          h32 = _x86Rotl(h32, 15);
          h32 += h4;
          h32 = _x86Multiply(h32, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= key.charCodeAt(i3 + 14) << 16;
          case 14:
            k4 ^= key.charCodeAt(i3 + 13) << 8;
          case 13:
            k4 ^= key.charCodeAt(i3 + 12);
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= key.charCodeAt(i3 + 11) << 24;
          case 11:
            k3 ^= key.charCodeAt(i3 + 10) << 16;
          case 10:
            k3 ^= key.charCodeAt(i3 + 9) << 8;
          case 9:
            k3 ^= key.charCodeAt(i3 + 8);
            k3 = _x86Multiply(k3, c32);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h32 ^= k3;
          case 8:
            k2 ^= key.charCodeAt(i3 + 7) << 24;
          case 7:
            k2 ^= key.charCodeAt(i3 + 6) << 16;
          case 6:
            k2 ^= key.charCodeAt(i3 + 5) << 8;
          case 5:
            k2 ^= key.charCodeAt(i3 + 4);
            k2 = _x86Multiply(k2, c22);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c32);
            h22 ^= k2;
          case 4:
            k1 ^= key.charCodeAt(i3 + 3) << 24;
          case 3:
            k1 ^= key.charCodeAt(i3 + 2) << 16;
          case 2:
            k1 ^= key.charCodeAt(i3 + 1) << 8;
          case 1:
            k1 ^= key.charCodeAt(i3);
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
        }
        h1 ^= key.length;
        h22 ^= key.length;
        h32 ^= key.length;
        h4 ^= key.length;
        h1 += h22;
        h1 += h32;
        h1 += h4;
        h22 += h1;
        h32 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h22 = _x86Fmix(h22);
        h32 = _x86Fmix(h32);
        h4 = _x86Fmix(h4);
        h1 += h22;
        h1 += h32;
        h1 += h4;
        h22 += h1;
        h32 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h22 >>> 0).toString(16)).slice(-8) + ("00000000" + (h32 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library2.x64.hash128 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 16;
        var bytes = key.length - remainder;
        var h1 = [0, seed];
        var h22 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c22 = [1291169091, 658871167];
        for (var i3 = 0; i3 < bytes; i3 = i3 + 16) {
          k1 = [key.charCodeAt(i3 + 4) & 255 | (key.charCodeAt(i3 + 5) & 255) << 8 | (key.charCodeAt(i3 + 6) & 255) << 16 | (key.charCodeAt(i3 + 7) & 255) << 24, key.charCodeAt(i3) & 255 | (key.charCodeAt(i3 + 1) & 255) << 8 | (key.charCodeAt(i3 + 2) & 255) << 16 | (key.charCodeAt(i3 + 3) & 255) << 24];
          k2 = [key.charCodeAt(i3 + 12) & 255 | (key.charCodeAt(i3 + 13) & 255) << 8 | (key.charCodeAt(i3 + 14) & 255) << 16 | (key.charCodeAt(i3 + 15) & 255) << 24, key.charCodeAt(i3 + 8) & 255 | (key.charCodeAt(i3 + 9) & 255) << 8 | (key.charCodeAt(i3 + 10) & 255) << 16 | (key.charCodeAt(i3 + 11) & 255) << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c22);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h22);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c22);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h22 = _x64Xor(h22, k2);
          h22 = _x64Rotl(h22, 31);
          h22 = _x64Add(h22, h1);
          h22 = _x64Add(_x64Multiply(h22, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i3 + 14)], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i3 + 13)], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i3 + 12)], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i3 + 11)], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i3 + 10)], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i3 + 9)], 8));
          case 9:
            k2 = _x64Xor(k2, [0, key.charCodeAt(i3 + 8)]);
            k2 = _x64Multiply(k2, c22);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h22 = _x64Xor(h22, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i3 + 7)], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i3 + 6)], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i3 + 5)], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i3 + 4)], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i3 + 3)], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i3 + 2)], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i3 + 1)], 8));
          case 1:
            k1 = _x64Xor(k1, [0, key.charCodeAt(i3)]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c22);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, key.length]);
        h22 = _x64Xor(h22, [0, key.length]);
        h1 = _x64Add(h1, h22);
        h22 = _x64Add(h22, h1);
        h1 = _x64Fmix(h1);
        h22 = _x64Fmix(h22);
        h1 = _x64Add(h1, h22);
        h22 = _x64Add(h22, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = library2;
        }
        exports.murmurHash3 = library2;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library2;
        });
      } else {
        library2._murmurHash3 = root.murmurHash3;
        library2.noConflict = function() {
          root.murmurHash3 = library2._murmurHash3;
          library2._murmurHash3 = undefined2;
          library2.noConflict = undefined2;
          return library2;
        };
        root.murmurHash3 = library2;
      }
    })(exports);
  }
});

// ../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/index.js
var require_murmurhash3js = __commonJS({
  "../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/index.js"(exports, module) {
    module.exports = require_murmurHash3js();
  }
});

// ../../../node_modules/.pnpm/@lit-labs+ssr-dom-shim@1.2.1/node_modules/@lit-labs/ssr-dom-shim/lib/element-internals.js
var ElementInternalsShim = class ElementInternals {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(_host) {
    this.ariaAtomic = "";
    this.ariaAutoComplete = "";
    this.ariaBrailleLabel = "";
    this.ariaBrailleRoleDescription = "";
    this.ariaBusy = "";
    this.ariaChecked = "";
    this.ariaColCount = "";
    this.ariaColIndex = "";
    this.ariaColSpan = "";
    this.ariaCurrent = "";
    this.ariaDescription = "";
    this.ariaDisabled = "";
    this.ariaExpanded = "";
    this.ariaHasPopup = "";
    this.ariaHidden = "";
    this.ariaInvalid = "";
    this.ariaKeyShortcuts = "";
    this.ariaLabel = "";
    this.ariaLevel = "";
    this.ariaLive = "";
    this.ariaModal = "";
    this.ariaMultiLine = "";
    this.ariaMultiSelectable = "";
    this.ariaOrientation = "";
    this.ariaPlaceholder = "";
    this.ariaPosInSet = "";
    this.ariaPressed = "";
    this.ariaReadOnly = "";
    this.ariaRequired = "";
    this.ariaRoleDescription = "";
    this.ariaRowCount = "";
    this.ariaRowIndex = "";
    this.ariaRowSpan = "";
    this.ariaSelected = "";
    this.ariaSetSize = "";
    this.ariaSort = "";
    this.ariaValueMax = "";
    this.ariaValueMin = "";
    this.ariaValueNow = "";
    this.ariaValueText = "";
    this.role = "";
    this.form = null;
    this.labels = [];
    this.states = /* @__PURE__ */ new Set();
    this.validationMessage = "";
    this.validity = {};
    this.willValidate = true;
    this.__host = _host;
  }
  checkValidity() {
    console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true.");
    return true;
  }
  reportValidity() {
    return true;
  }
  setFormValue() {
  }
  setValidity() {
  }
};

// ../../../node_modules/.pnpm/@lit-labs+ssr-dom-shim@1.2.1/node_modules/@lit-labs/ssr-dom-shim/index.js
var attributes = /* @__PURE__ */ new WeakMap();
var attributesForElement = (element) => {
  let attrs = attributes.get(element);
  if (attrs === void 0) {
    attributes.set(element, attrs = /* @__PURE__ */ new Map());
  }
  return attrs;
};
var ElementShim = class Element2 {
  constructor() {
    this.__shadowRootMode = null;
    this.__shadowRoot = null;
    this.__internals = null;
  }
  get attributes() {
    return Array.from(attributesForElement(this)).map(([name, value]) => ({
      name,
      value
    }));
  }
  get shadowRoot() {
    if (this.__shadowRootMode === "closed") {
      return null;
    }
    return this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    return this.localName?.toUpperCase();
  }
  setAttribute(name, value) {
    attributesForElement(this).set(name, String(value));
  }
  removeAttribute(name) {
    attributesForElement(this).delete(name);
  }
  toggleAttribute(name, force) {
    if (this.hasAttribute(name)) {
      if (force === void 0 || !force) {
        this.removeAttribute(name);
        return false;
      }
    } else {
      if (force === void 0 || force) {
        this.setAttribute(name, "");
        return true;
      } else {
        return false;
      }
    }
    return true;
  }
  hasAttribute(name) {
    return attributesForElement(this).has(name);
  }
  attachShadow(init) {
    const shadowRoot = { host: this };
    this.__shadowRootMode = init.mode;
    if (init && init.mode === "open") {
      this.__shadowRoot = shadowRoot;
    }
    return shadowRoot;
  }
  attachInternals() {
    if (this.__internals !== null) {
      throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);
    }
    const internals = new ElementInternalsShim(this);
    this.__internals = internals;
    return internals;
  }
  getAttribute(name) {
    const value = attributesForElement(this).get(name);
    return value ?? null;
  }
};
var HTMLElementShim = class HTMLElement2 extends ElementShim {
};
var HTMLElementShimWithRealType = HTMLElementShim;
var CustomElementRegistryShim = class CustomElementRegistry {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map();
  }
  define(name, ctor) {
    if (this.__definitions.has(name)) {
      if (process.env.NODE_ENV === "development") {
        console.warn(`'CustomElementRegistry' already has "${name}" defined. This may have been caused by live reload or hot module replacement in which case it can be safely ignored.
Make sure to test your application with a production build as repeat registrations will throw in production.`);
      } else {
        throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${name}" has already been used with this registry`);
      }
    }
    ctor.__localName = name;
    this.__definitions.set(name, {
      ctor,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: ctor.observedAttributes ?? []
    });
  }
  get(name) {
    const definition = this.__definitions.get(name);
    return definition?.ctor;
  }
};
var CustomElementRegistryShimWithRealType = CustomElementRegistryShim;
var customElements2 = new CustomElementRegistryShimWithRealType();

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/css-tag.js
var t = globalThis;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t4, e5, o4) {
    if (this._$cssResult$ = true, o4 !== s)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t4, this.t = e5;
  }
  get styleSheet() {
    let t4 = this.o;
    const s2 = this.t;
    if (e && void 0 === t4) {
      const e5 = void 0 !== s2 && 1 === s2.length;
      e5 && (t4 = o.get(s2)), void 0 === t4 && ((this.o = t4 = new CSSStyleSheet()).replaceSync(this.cssText), e5 && o.set(s2, t4));
    }
    return t4;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t4) => new n("string" == typeof t4 ? t4 : t4 + "", void 0, s);
var i = (t4, ...e5) => {
  const o4 = 1 === t4.length ? t4[0] : e5.reduce((e6, s2, o5) => e6 + ((t5) => {
    if (true === t5._$cssResult$)
      return t5.cssText;
    if ("number" == typeof t5)
      return t5;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t5 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s2) + t4[o5 + 1], t4[0]);
  return new n(o4, t4, s);
};
var S = (s2, o4) => {
  if (e)
    s2.adoptedStyleSheets = o4.map((t4) => t4 instanceof CSSStyleSheet ? t4 : t4.styleSheet);
  else
    for (const e5 of o4) {
      const o5 = document.createElement("style"), n5 = t.litNonce;
      void 0 !== n5 && o5.setAttribute("nonce", n5), o5.textContent = e5.cssText, s2.appendChild(o5);
    }
};
var c = e || void 0 === t.CSSStyleSheet ? (t4) => t4 : (t4) => t4 instanceof CSSStyleSheet ? ((t5) => {
  let e5 = "";
  for (const s2 of t5.cssRules)
    e5 += s2.cssText;
  return r(e5);
})(t4) : t4;

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/reactive-element.js
var { is: r2, defineProperty: h, getOwnPropertyDescriptor: o2, getOwnPropertyNames: n2, getOwnPropertySymbols: a, getPrototypeOf: c2 } = Object;
var l = globalThis;
l.customElements ??= customElements2;
var p = l.trustedTypes;
var d = p ? p.emptyScript : "";
var u = l.reactiveElementPolyfillSupport;
var f = (t4, s2) => t4;
var b = { toAttribute(t4, s2) {
  switch (s2) {
    case Boolean:
      t4 = t4 ? d : null;
      break;
    case Object:
    case Array:
      t4 = null == t4 ? t4 : JSON.stringify(t4);
  }
  return t4;
}, fromAttribute(t4, s2) {
  let i3 = t4;
  switch (s2) {
    case Boolean:
      i3 = null !== t4;
      break;
    case Number:
      i3 = null === t4 ? null : Number(t4);
      break;
    case Object:
    case Array:
      try {
        i3 = JSON.parse(t4);
      } catch (t5) {
        i3 = null;
      }
  }
  return i3;
} };
var y = (t4, s2) => !r2(t4, s2);
var m = { attribute: true, type: String, converter: b, reflect: false, hasChanged: y };
Symbol.metadata ??= Symbol("metadata"), l.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var g = class extends (globalThis.HTMLElement ?? HTMLElementShimWithRealType) {
  static addInitializer(t4) {
    this._$Ei(), (this.l ??= []).push(t4);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t4, s2 = m) {
    if (s2.state && (s2.attribute = false), this._$Ei(), this.elementProperties.set(t4, s2), !s2.noAccessor) {
      const i3 = Symbol(), e5 = this.getPropertyDescriptor(t4, i3, s2);
      void 0 !== e5 && h(this.prototype, t4, e5);
    }
  }
  static getPropertyDescriptor(t4, s2, i3) {
    const { get: e5, set: r5 } = o2(this.prototype, t4) ?? { get() {
      return this[s2];
    }, set(t5) {
      this[s2] = t5;
    } };
    return { get() {
      return e5?.call(this);
    }, set(s3) {
      const h4 = e5?.call(this);
      r5.call(this, s3), this.requestUpdate(t4, h4, i3);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t4) {
    return this.elementProperties.get(t4) ?? m;
  }
  static _$Ei() {
    if (this.hasOwnProperty(f("elementProperties")))
      return;
    const t4 = c2(this);
    t4.finalize(), void 0 !== t4.l && (this.l = [...t4.l]), this.elementProperties = new Map(t4.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(f("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(f("properties"))) {
      const t5 = this.properties, s2 = [...n2(t5), ...a(t5)];
      for (const i3 of s2)
        this.createProperty(i3, t5[i3]);
    }
    const t4 = this[Symbol.metadata];
    if (null !== t4) {
      const s2 = litPropertyMetadata.get(t4);
      if (void 0 !== s2)
        for (const [t5, i3] of s2)
          this.elementProperties.set(t5, i3);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t5, s2] of this.elementProperties) {
      const i3 = this._$Eu(t5, s2);
      void 0 !== i3 && this._$Eh.set(i3, t5);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t4) {
    const s2 = [];
    if (Array.isArray(t4)) {
      const e5 = new Set(t4.flat(1 / 0).reverse());
      for (const t5 of e5)
        s2.unshift(c(t5));
    } else
      void 0 !== t4 && s2.push(c(t4));
    return s2;
  }
  static _$Eu(t4, s2) {
    const i3 = s2.attribute;
    return false === i3 ? void 0 : "string" == typeof i3 ? i3 : "string" == typeof t4 ? t4.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t4) => this.enableUpdating = t4), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t4) => t4(this));
  }
  addController(t4) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t4), void 0 !== this.renderRoot && this.isConnected && t4.hostConnected?.();
  }
  removeController(t4) {
    this._$EO?.delete(t4);
  }
  _$E_() {
    const t4 = /* @__PURE__ */ new Map(), s2 = this.constructor.elementProperties;
    for (const i3 of s2.keys())
      this.hasOwnProperty(i3) && (t4.set(i3, this[i3]), delete this[i3]);
    t4.size > 0 && (this._$Ep = t4);
  }
  createRenderRoot() {
    const t4 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t4, this.constructor.elementStyles), t4;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t4) => t4.hostConnected?.());
  }
  enableUpdating(t4) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t4) => t4.hostDisconnected?.());
  }
  attributeChangedCallback(t4, s2, i3) {
    this._$AK(t4, i3);
  }
  _$EC(t4, s2) {
    const i3 = this.constructor.elementProperties.get(t4), e5 = this.constructor._$Eu(t4, i3);
    if (void 0 !== e5 && true === i3.reflect) {
      const r5 = (void 0 !== i3.converter?.toAttribute ? i3.converter : b).toAttribute(s2, i3.type);
      this._$Em = t4, null == r5 ? this.removeAttribute(e5) : this.setAttribute(e5, r5), this._$Em = null;
    }
  }
  _$AK(t4, s2) {
    const i3 = this.constructor, e5 = i3._$Eh.get(t4);
    if (void 0 !== e5 && this._$Em !== e5) {
      const t5 = i3.getPropertyOptions(e5), r5 = "function" == typeof t5.converter ? { fromAttribute: t5.converter } : void 0 !== t5.converter?.fromAttribute ? t5.converter : b;
      this._$Em = e5, this[e5] = r5.fromAttribute(s2, t5.type), this._$Em = null;
    }
  }
  requestUpdate(t4, s2, i3) {
    if (void 0 !== t4) {
      if (i3 ??= this.constructor.getPropertyOptions(t4), !(i3.hasChanged ?? y)(this[t4], s2))
        return;
      this.P(t4, s2, i3);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t4, s2, i3) {
    this._$AL.has(t4) || this._$AL.set(t4, s2), true === i3.reflect && this._$Em !== t4 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t4);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t5) {
      Promise.reject(t5);
    }
    const t4 = this.scheduleUpdate();
    return null != t4 && await t4, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t6, s3] of this._$Ep)
          this[t6] = s3;
        this._$Ep = void 0;
      }
      const t5 = this.constructor.elementProperties;
      if (t5.size > 0)
        for (const [s3, i3] of t5)
          true !== i3.wrapped || this._$AL.has(s3) || void 0 === this[s3] || this.P(s3, this[s3], i3);
    }
    let t4 = false;
    const s2 = this._$AL;
    try {
      t4 = this.shouldUpdate(s2), t4 ? (this.willUpdate(s2), this._$EO?.forEach((t5) => t5.hostUpdate?.()), this.update(s2)) : this._$EU();
    } catch (s3) {
      throw t4 = false, this._$EU(), s3;
    }
    t4 && this._$AE(s2);
  }
  willUpdate(t4) {
  }
  _$AE(t4) {
    this._$EO?.forEach((t5) => t5.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t4)), this.updated(t4);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t4) {
    return true;
  }
  update(t4) {
    this._$Ej &&= this._$Ej.forEach((t5) => this._$EC(t5, this[t5])), this._$EU();
  }
  updated(t4) {
  }
  firstUpdated(t4) {
  }
};
g.elementStyles = [], g.shadowRootOptions = { mode: "open" }, g[f("elementProperties")] = /* @__PURE__ */ new Map(), g[f("finalized")] = /* @__PURE__ */ new Map(), u?.({ ReactiveElement: g }), (l.reactiveElementVersions ??= []).push("2.0.4");

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/lit-html.js
var n3 = globalThis;
var c3 = n3.trustedTypes;
var h2 = c3 ? c3.createPolicy("lit-html", { createHTML: (t4) => t4 }) : void 0;
var f2 = "$lit$";
var v2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m2 = "?" + v2;
var _ = `<${m2}>`;
var w = void 0 === n3.document ? { createTreeWalker: () => ({}) } : document;
var lt = () => w.createComment("");
var st = (t4) => null === t4 || "object" != typeof t4 && "function" != typeof t4;
var g2 = Array.isArray;
var $ = (t4) => g2(t4) || "function" == typeof t4?.[Symbol.iterator];
var x = "[ 	\n\f\r]";
var T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E = /-->/g;
var k = />/g;
var O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S2 = /'/g;
var j = /"/g;
var M = /^(?:script|style|textarea|title)$/i;
var P = (t4) => (i3, ...s2) => ({ _$litType$: t4, strings: i3, values: s2 });
var ke = P(1);
var Oe = P(2);
var Se = P(3);
var R = Symbol.for("lit-noChange");
var D = Symbol.for("lit-nothing");
var V = /* @__PURE__ */ new WeakMap();
var I = w.createTreeWalker(w, 129);
function N(t4, i3) {
  if (!g2(t4) || !t4.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== h2 ? h2.createHTML(i3) : i3;
}
var U = (t4, i3) => {
  const s2 = t4.length - 1, e5 = [];
  let h4, o4 = 2 === i3 ? "<svg>" : 3 === i3 ? "<math>" : "", n5 = T;
  for (let i4 = 0; i4 < s2; i4++) {
    const s3 = t4[i4];
    let r5, l2, c4 = -1, a2 = 0;
    for (; a2 < s3.length && (n5.lastIndex = a2, l2 = n5.exec(s3), null !== l2); )
      a2 = n5.lastIndex, n5 === T ? "!--" === l2[1] ? n5 = E : void 0 !== l2[1] ? n5 = k : void 0 !== l2[2] ? (M.test(l2[2]) && (h4 = RegExp("</" + l2[2], "g")), n5 = O) : void 0 !== l2[3] && (n5 = O) : n5 === O ? ">" === l2[0] ? (n5 = h4 ?? T, c4 = -1) : void 0 === l2[1] ? c4 = -2 : (c4 = n5.lastIndex - l2[2].length, r5 = l2[1], n5 = void 0 === l2[3] ? O : '"' === l2[3] ? j : S2) : n5 === j || n5 === S2 ? n5 = O : n5 === E || n5 === k ? n5 = T : (n5 = O, h4 = void 0);
    const u2 = n5 === O && t4[i4 + 1].startsWith("/>") ? " " : "";
    o4 += n5 === T ? s3 + _ : c4 >= 0 ? (e5.push(r5), s3.slice(0, c4) + f2 + s3.slice(c4) + v2 + u2) : s3 + v2 + (-2 === c4 ? i4 : u2);
  }
  return [N(t4, o4 + (t4[s2] || "<?>") + (2 === i3 ? "</svg>" : 3 === i3 ? "</math>" : "")), e5];
};
var B = class _B {
  constructor({ strings: t4, _$litType$: i3 }, s2) {
    let e5;
    this.parts = [];
    let h4 = 0, o4 = 0;
    const n5 = t4.length - 1, r5 = this.parts, [l2, a2] = U(t4, i3);
    if (this.el = _B.createElement(l2, s2), I.currentNode = this.el.content, 2 === i3 || 3 === i3) {
      const t5 = this.el.content.firstChild;
      t5.replaceWith(...t5.childNodes);
    }
    for (; null !== (e5 = I.nextNode()) && r5.length < n5; ) {
      if (1 === e5.nodeType) {
        if (e5.hasAttributes())
          for (const t5 of e5.getAttributeNames())
            if (t5.endsWith(f2)) {
              const i4 = a2[o4++], s3 = e5.getAttribute(t5).split(v2), n6 = /([.?@])?(.*)/.exec(i4);
              r5.push({ type: 1, index: h4, name: n6[2], strings: s3, ctor: "." === n6[1] ? Y : "?" === n6[1] ? Z : "@" === n6[1] ? q : G }), e5.removeAttribute(t5);
            } else
              t5.startsWith(v2) && (r5.push({ type: 6, index: h4 }), e5.removeAttribute(t5));
        if (M.test(e5.tagName)) {
          const t5 = e5.textContent.split(v2), i4 = t5.length - 1;
          if (i4 > 0) {
            e5.textContent = c3 ? c3.emptyScript : "";
            for (let s3 = 0; s3 < i4; s3++)
              e5.append(t5[s3], lt()), I.nextNode(), r5.push({ type: 2, index: ++h4 });
            e5.append(t5[i4], lt());
          }
        }
      } else if (8 === e5.nodeType)
        if (e5.data === m2)
          r5.push({ type: 2, index: h4 });
        else {
          let t5 = -1;
          for (; -1 !== (t5 = e5.data.indexOf(v2, t5 + 1)); )
            r5.push({ type: 7, index: h4 }), t5 += v2.length - 1;
        }
      h4++;
    }
  }
  static createElement(t4, i3) {
    const s2 = w.createElement("template");
    return s2.innerHTML = t4, s2;
  }
};
function z(t4, i3, s2 = t4, e5) {
  if (i3 === R)
    return i3;
  let h4 = void 0 !== e5 ? s2.o?.[e5] : s2.l;
  const o4 = st(i3) ? void 0 : i3._$litDirective$;
  return h4?.constructor !== o4 && (h4?._$AO?.(false), void 0 === o4 ? h4 = void 0 : (h4 = new o4(t4), h4._$AT(t4, s2, e5)), void 0 !== e5 ? (s2.o ??= [])[e5] = h4 : s2.l = h4), void 0 !== h4 && (i3 = z(t4, h4._$AS(t4, i3.values), h4, e5)), i3;
}
var F = class {
  constructor(t4, i3) {
    this._$AV = [], this._$AN = void 0, this._$AD = t4, this._$AM = i3;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t4) {
    const { el: { content: i3 }, parts: s2 } = this._$AD, e5 = (t4?.creationScope ?? w).importNode(i3, true);
    I.currentNode = e5;
    let h4 = I.nextNode(), o4 = 0, n5 = 0, r5 = s2[0];
    for (; void 0 !== r5; ) {
      if (o4 === r5.index) {
        let i4;
        2 === r5.type ? i4 = new et(h4, h4.nextSibling, this, t4) : 1 === r5.type ? i4 = new r5.ctor(h4, r5.name, r5.strings, this, t4) : 6 === r5.type && (i4 = new K(h4, this, t4)), this._$AV.push(i4), r5 = s2[++n5];
      }
      o4 !== r5?.index && (h4 = I.nextNode(), o4++);
    }
    return I.currentNode = w, e5;
  }
  p(t4) {
    let i3 = 0;
    for (const s2 of this._$AV)
      void 0 !== s2 && (void 0 !== s2.strings ? (s2._$AI(t4, s2, i3), i3 += s2.strings.length - 2) : s2._$AI(t4[i3])), i3++;
  }
};
var et = class _et {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t4, i3, s2, e5) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t4, this._$AB = i3, this._$AM = s2, this.options = e5, this.v = e5?.isConnected ?? true;
  }
  get parentNode() {
    let t4 = this._$AA.parentNode;
    const i3 = this._$AM;
    return void 0 !== i3 && 11 === t4?.nodeType && (t4 = i3.parentNode), t4;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t4, i3 = this) {
    t4 = z(this, t4, i3), st(t4) ? t4 === D || null == t4 || "" === t4 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t4 !== this._$AH && t4 !== R && this._(t4) : void 0 !== t4._$litType$ ? this.$(t4) : void 0 !== t4.nodeType ? this.T(t4) : $(t4) ? this.k(t4) : this._(t4);
  }
  O(t4) {
    return this._$AA.parentNode.insertBefore(t4, this._$AB);
  }
  T(t4) {
    this._$AH !== t4 && (this._$AR(), this._$AH = this.O(t4));
  }
  _(t4) {
    this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = t4 : this.T(w.createTextNode(t4)), this._$AH = t4;
  }
  $(t4) {
    const { values: i3, _$litType$: s2 } = t4, e5 = "number" == typeof s2 ? this._$AC(t4) : (void 0 === s2.el && (s2.el = B.createElement(N(s2.h, s2.h[0]), this.options)), s2);
    if (this._$AH?._$AD === e5)
      this._$AH.p(i3);
    else {
      const t5 = new F(e5, this), s3 = t5.u(this.options);
      t5.p(i3), this.T(s3), this._$AH = t5;
    }
  }
  _$AC(t4) {
    let i3 = V.get(t4.strings);
    return void 0 === i3 && V.set(t4.strings, i3 = new B(t4)), i3;
  }
  k(t4) {
    g2(this._$AH) || (this._$AH = [], this._$AR());
    const i3 = this._$AH;
    let s2, e5 = 0;
    for (const h4 of t4)
      e5 === i3.length ? i3.push(s2 = new _et(this.O(lt()), this.O(lt()), this, this.options)) : s2 = i3[e5], s2._$AI(h4), e5++;
    e5 < i3.length && (this._$AR(s2 && s2._$AB.nextSibling, e5), i3.length = e5);
  }
  _$AR(t4 = this._$AA.nextSibling, i3) {
    for (this._$AP?.(false, true, i3); t4 && t4 !== this._$AB; ) {
      const i4 = t4.nextSibling;
      t4.remove(), t4 = i4;
    }
  }
  setConnected(t4) {
    void 0 === this._$AM && (this.v = t4, this._$AP?.(t4));
  }
};
var G = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t4, i3, s2, e5, h4) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t4, this.name = i3, this._$AM = e5, this.options = h4, s2.length > 2 || "" !== s2[0] || "" !== s2[1] ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = D;
  }
  _$AI(t4, i3 = this, s2, e5) {
    const h4 = this.strings;
    let o4 = false;
    if (void 0 === h4)
      t4 = z(this, t4, i3, 0), o4 = !st(t4) || t4 !== this._$AH && t4 !== R, o4 && (this._$AH = t4);
    else {
      const e6 = t4;
      let n5, r5;
      for (t4 = h4[0], n5 = 0; n5 < h4.length - 1; n5++)
        r5 = z(this, e6[s2 + n5], i3, n5), r5 === R && (r5 = this._$AH[n5]), o4 ||= !st(r5) || r5 !== this._$AH[n5], r5 === D ? t4 = D : t4 !== D && (t4 += (r5 ?? "") + h4[n5 + 1]), this._$AH[n5] = r5;
    }
    o4 && !e5 && this.j(t4);
  }
  j(t4) {
    t4 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t4 ?? "");
  }
};
var Y = class extends G {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t4) {
    this.element[this.name] = t4 === D ? void 0 : t4;
  }
};
var Z = class extends G {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t4) {
    this.element.toggleAttribute(this.name, !!t4 && t4 !== D);
  }
};
var q = class extends G {
  constructor(t4, i3, s2, e5, h4) {
    super(t4, i3, s2, e5, h4), this.type = 5;
  }
  _$AI(t4, i3 = this) {
    if ((t4 = z(this, t4, i3, 0) ?? D) === R)
      return;
    const s2 = this._$AH, e5 = t4 === D && s2 !== D || t4.capture !== s2.capture || t4.once !== s2.once || t4.passive !== s2.passive, h4 = t4 !== D && (s2 === D || e5);
    e5 && this.element.removeEventListener(this.name, this, s2), h4 && this.element.addEventListener(this.name, this, t4), this._$AH = t4;
  }
  handleEvent(t4) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t4) : this._$AH.handleEvent(t4);
  }
};
var K = class {
  constructor(t4, i3, s2) {
    this.element = t4, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t4) {
    z(this, t4);
  }
};
var si = { M: f2, P: v2, A: m2, C: 1, L: U, R: F, D: $, V: z, I: et, H: G, N: Z, U: q, B: Y, F: K };
var Re = n3.litHtmlPolyfillSupport;
Re?.(B, et), (n3.litHtmlVersions ??= []).push("3.2.0");
var Q = (t4, i3, s2) => {
  const e5 = s2?.renderBefore ?? i3;
  let h4 = e5._$litPart$;
  if (void 0 === h4) {
    const t5 = s2?.renderBefore ?? null;
    e5._$litPart$ = h4 = new et(i3.insertBefore(lt(), t5), t5, void 0, s2 ?? {});
  }
  return h4._$AI(t4), h4;
};

// ../../../node_modules/.pnpm/lit-element@4.1.0/node_modules/lit-element/lit-element.js
var h3 = class extends g {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t4 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t4.firstChild, t4;
  }
  update(t4) {
    const e5 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t4), this.o = Q(e5, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R;
  }
};
h3._$litElement$ = true, h3["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h3 });
var f3 = globalThis.litElementPolyfillSupport;
f3?.({ LitElement: h3 });
(globalThis.litElementVersions ??= []).push("4.1.0");

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/custom-element.js
var t2 = (t4) => (e5, o4) => {
  void 0 !== o4 ? o4.addInitializer(() => {
    customElements.define(t4, e5);
  }) : customElements.define(t4, e5);
};

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/property.js
var o3 = { attribute: true, type: String, converter: b, reflect: false, hasChanged: y };
var r3 = (t4 = o3, e5, r5) => {
  const { kind: n5, metadata: i3 } = r5;
  let s2 = globalThis.litPropertyMetadata.get(i3);
  if (void 0 === s2 && globalThis.litPropertyMetadata.set(i3, s2 = /* @__PURE__ */ new Map()), s2.set(r5.name, t4), "accessor" === n5) {
    const { name: o4 } = r5;
    return { set(r6) {
      const n6 = e5.get.call(this);
      e5.set.call(this, r6), this.requestUpdate(o4, n6, t4);
    }, init(e6) {
      return void 0 !== e6 && this.P(o4, void 0, t4), e6;
    } };
  }
  if ("setter" === n5) {
    const { name: o4 } = r5;
    return function(r6) {
      const n6 = this[o4];
      e5.call(this, r6), this.requestUpdate(o4, n6, t4);
    };
  }
  throw Error("Unsupported decorator location: " + n5);
};
function n4(t4) {
  return (e5, o4) => "object" == typeof o4 ? r3(t4, e5, o4) : ((t5, e6, o5) => {
    const r5 = e6.hasOwnProperty(o5);
    return e6.constructor.createProperty(o5, r5 ? { ...t5, wrapped: true } : t5), r5 ? Object.getOwnPropertyDescriptor(e6, o5) : void 0;
  })(t4, e5, o4);
}

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/state.js
function r4(r5) {
  return n4({ ...r5, state: true, attribute: false });
}

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/base.js
var e2 = (e5, t4, c4) => (c4.configurable = true, c4.enumerable = true, Reflect.decorate && "object" != typeof t4 && Object.defineProperty(e5, t4, c4), c4);

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/query.js
function e3(e5, r5) {
  return (n5, s2, i3) => {
    const o4 = (t4) => t4.renderRoot?.querySelector(e5) ?? null;
    if (r5) {
      const { get: e6, set: r6 } = "object" == typeof s2 ? n5 : i3 ?? (() => {
        const t4 = Symbol();
        return { get() {
          return this[t4];
        }, set(e7) {
          this[t4] = e7;
        } };
      })();
      return e2(n5, s2, { get() {
        let t4 = e6.call(this);
        return void 0 === t4 && (t4 = o4(this), (null !== t4 || this.hasUpdated) && r6.call(this, t4)), t4;
      } });
    }
    return e2(n5, s2, { get() {
      return o4(this);
    } });
  };
}

// ../settings-component2/dist/styling/base.js
var baseStyling = i`
	:host {
		font-family: "Inter", sans-serif;

		/*
		* Color Primitives
		*/

		/* Gray */
		--sl-color-gray-50: hsl(0 0% 97.5%);
		--sl-color-gray-100: hsl(240 4.8% 95.9%);
		--sl-color-gray-200: hsl(240 5.9% 90%);
		--sl-color-gray-300: hsl(240 4.9% 83.9%);
		--sl-color-gray-400: hsl(240 5% 64.9%);
		--sl-color-gray-500: hsl(240 3.8% 46.1%);
		--sl-color-gray-600: hsl(240 5.2% 33.9%);
		--sl-color-gray-700: hsl(240 5.3% 26.1%);
		--sl-color-gray-800: hsl(240 3.7% 15.9%);
		--sl-color-gray-900: hsl(240 5.9% 10%);
		--sl-color-gray-950: hsl(240 7.3% 8%);

		/* Red */
		--sl-color-red-50: hsl(0 85.7% 97.3%);
		--sl-color-red-100: hsl(0 93.3% 94.1%);
		--sl-color-red-200: hsl(0 96.3% 89.4%);
		--sl-color-red-300: hsl(0 93.5% 81.8%);
		--sl-color-red-400: hsl(0 90.6% 70.8%);
		--sl-color-red-500: hsl(0 84.2% 60.2%);
		--sl-color-red-600: hsl(0 72.2% 50.6%);
		--sl-color-red-700: hsl(0 73.7% 41.8%);
		--sl-color-red-800: hsl(0 70% 35.3%);
		--sl-color-red-900: hsl(0 62.8% 30.6%);
		--sl-color-red-950: hsl(0 60% 19.6%);

		/* Orange */
		--sl-color-orange-50: hsl(33.3 100% 96.5%);
		--sl-color-orange-100: hsl(34.3 100% 91.8%);
		--sl-color-orange-200: hsl(32.1 97.7% 83.1%);
		--sl-color-orange-300: hsl(30.7 97.2% 72.4%);
		--sl-color-orange-400: hsl(27 96% 61%);
		--sl-color-orange-500: hsl(24.6 95% 53.1%);
		--sl-color-orange-600: hsl(20.5 90.2% 48.2%);
		--sl-color-orange-700: hsl(17.5 88.3% 40.4%);
		--sl-color-orange-800: hsl(15 79.1% 33.7%);
		--sl-color-orange-900: hsl(15.3 74.6% 27.8%);
		--sl-color-orange-950: hsl(15.2 69.1% 19%);

		/* Amber */
		--sl-color-amber-50: hsl(48 100% 96.1%);
		--sl-color-amber-100: hsl(48 96.5% 88.8%);
		--sl-color-amber-200: hsl(48 96.6% 76.7%);
		--sl-color-amber-300: hsl(45.9 96.7% 64.5%);
		--sl-color-amber-400: hsl(43.3 96.4% 56.3%);
		--sl-color-amber-500: hsl(37.7 92.1% 50.2%);
		--sl-color-amber-600: hsl(32.1 94.6% 43.7%);
		--sl-color-amber-700: hsl(26 90.5% 37.1%);
		--sl-color-amber-800: hsl(22.7 82.5% 31.4%);
		--sl-color-amber-900: hsl(21.7 77.8% 26.5%);
		--sl-color-amber-950: hsl(22.9 74.1% 16.7%);

		/* Yellow */
		--sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
		--sl-color-yellow-100: hsl(54.9 96.7% 88%);
		--sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
		--sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
		--sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
		--sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
		--sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
		--sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
		--sl-color-yellow-800: hsl(31.8 81% 28.8%);
		--sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
		--sl-color-yellow-950: hsl(33.1 69% 13.9%);

		/* Lime */
		--sl-color-lime-50: hsl(78.3 92% 95.1%);
		--sl-color-lime-100: hsl(79.6 89.1% 89.2%);
		--sl-color-lime-200: hsl(80.9 88.5% 79.6%);
		--sl-color-lime-300: hsl(82 84.5% 67.1%);
		--sl-color-lime-400: hsl(82.7 78% 55.5%);
		--sl-color-lime-500: hsl(83.7 80.5% 44.3%);
		--sl-color-lime-600: hsl(84.8 85.2% 34.5%);
		--sl-color-lime-700: hsl(85.9 78.4% 27.3%);
		--sl-color-lime-800: hsl(86.3 69% 22.7%);
		--sl-color-lime-900: hsl(87.6 61.2% 20.2%);
		--sl-color-lime-950: hsl(86.5 60.6% 13.9%);

		/* Green */
		--sl-color-green-50: hsl(138.5 76.5% 96.7%);
		--sl-color-green-100: hsl(140.6 84.2% 92.5%);
		--sl-color-green-200: hsl(141 78.9% 85.1%);
		--sl-color-green-300: hsl(141.7 76.6% 73.1%);
		--sl-color-green-400: hsl(141.9 69.2% 58%);
		--sl-color-green-500: hsl(142.1 70.6% 45.3%);
		--sl-color-green-600: hsl(142.1 76.2% 36.3%);
		--sl-color-green-700: hsl(142.4 71.8% 29.2%);
		--sl-color-green-800: hsl(142.8 64.2% 24.1%);
		--sl-color-green-900: hsl(143.8 61.2% 20.2%);
		--sl-color-green-950: hsl(144.3 60.7% 12%);

		/* Emerald */
		--sl-color-emerald-50: hsl(151.8 81% 95.9%);
		--sl-color-emerald-100: hsl(149.3 80.4% 90%);
		--sl-color-emerald-200: hsl(152.4 76% 80.4%);
		--sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
		--sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
		--sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
		--sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
		--sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
		--sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
		--sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
		--sl-color-emerald-950: hsl(164.3 87.5% 9.4%);

		/* Teal */
		--sl-color-teal-50: hsl(166.2 76.5% 96.7%);
		--sl-color-teal-100: hsl(167.2 85.5% 89.2%);
		--sl-color-teal-200: hsl(168.4 83.8% 78.2%);
		--sl-color-teal-300: hsl(170.6 76.9% 64.3%);
		--sl-color-teal-400: hsl(172.5 66% 50.4%);
		--sl-color-teal-500: hsl(173.4 80.4% 40%);
		--sl-color-teal-600: hsl(174.7 83.9% 31.6%);
		--sl-color-teal-700: hsl(175.3 77.4% 26.1%);
		--sl-color-teal-800: hsl(176.1 69.4% 21.8%);
		--sl-color-teal-900: hsl(175.9 60.8% 19%);
		--sl-color-teal-950: hsl(176.5 58.6% 11.4%);

		/* Cyan */
		--sl-color-cyan-50: hsl(183.2 100% 96.3%);
		--sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
		--sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
		--sl-color-cyan-300: hsl(187 92.4% 69%);
		--sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
		--sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
		--sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
		--sl-color-cyan-700: hsl(192.9 82.3% 31%);
		--sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
		--sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
		--sl-color-cyan-950: hsl(196.8 61% 16.1%);

		/* Sky */
		--sl-color-sky-50: hsl(204 100% 97.1%);
		--sl-color-sky-100: hsl(204 93.8% 93.7%);
		--sl-color-sky-200: hsl(200.6 94.4% 86.1%);
		--sl-color-sky-300: hsl(199.4 95.5% 73.9%);
		--sl-color-sky-400: hsl(198.4 93.2% 59.6%);
		--sl-color-sky-500: hsl(198.6 88.7% 48.4%);
		--sl-color-sky-600: hsl(200.4 98% 39.4%);
		--sl-color-sky-700: hsl(201.3 96.3% 32.2%);
		--sl-color-sky-800: hsl(201 90% 27.5%);
		--sl-color-sky-900: hsl(202 80.3% 23.9%);
		--sl-color-sky-950: hsl(202.3 73.8% 16.5%);

		/* Blue */
		--sl-color-blue-50: hsl(213.8 100% 96.9%);
		--sl-color-blue-100: hsl(214.3 94.6% 92.7%);
		--sl-color-blue-200: hsl(213.3 96.9% 87.3%);
		--sl-color-blue-300: hsl(211.7 96.4% 78.4%);
		--sl-color-blue-400: hsl(213.1 93.9% 67.8%);
		--sl-color-blue-500: hsl(217.2 91.2% 59.8%);
		--sl-color-blue-600: hsl(221.2 83.2% 53.3%);
		--sl-color-blue-700: hsl(224.3 76.3% 48%);
		--sl-color-blue-800: hsl(225.9 70.7% 40.2%);
		--sl-color-blue-900: hsl(224.4 64.3% 32.9%);
		--sl-color-blue-950: hsl(226.2 55.3% 18.4%);

		/* Indigo */
		--sl-color-indigo-50: hsl(225.9 100% 96.7%);
		--sl-color-indigo-100: hsl(226.5 100% 93.9%);
		--sl-color-indigo-200: hsl(228 96.5% 88.8%);
		--sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
		--sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
		--sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
		--sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
		--sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
		--sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
		--sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
		--sl-color-indigo-950: hsl(243.5 43.6% 22.9%);

		/* Violet */
		--sl-color-violet-50: hsl(250 100% 97.6%);
		--sl-color-violet-100: hsl(251.4 91.3% 95.5%);
		--sl-color-violet-200: hsl(250.5 95.2% 91.8%);
		--sl-color-violet-300: hsl(252.5 94.7% 85.1%);
		--sl-color-violet-400: hsl(255.1 91.7% 76.3%);
		--sl-color-violet-500: hsl(258.3 89.5% 66.3%);
		--sl-color-violet-600: hsl(262.1 83.3% 57.8%);
		--sl-color-violet-700: hsl(263.4 70% 50.4%);
		--sl-color-violet-800: hsl(263.4 69.3% 42.2%);
		--sl-color-violet-900: hsl(263.5 67.4% 34.9%);
		--sl-color-violet-950: hsl(265.1 61.5% 21.4%);

		/* Purple */
		--sl-color-purple-50: hsl(270 100% 98%);
		--sl-color-purple-100: hsl(268.7 100% 95.5%);
		--sl-color-purple-200: hsl(268.6 100% 91.8%);
		--sl-color-purple-300: hsl(269.2 97.4% 85.1%);
		--sl-color-purple-400: hsl(270 95.2% 75.3%);
		--sl-color-purple-500: hsl(270.7 91% 65.1%);
		--sl-color-purple-600: hsl(271.5 81.3% 55.9%);
		--sl-color-purple-700: hsl(272.1 71.7% 47.1%);
		--sl-color-purple-800: hsl(272.9 67.2% 39.4%);
		--sl-color-purple-900: hsl(273.6 65.6% 32%);
		--sl-color-purple-950: hsl(276 59.5% 16.5%);

		/* Fuchsia */
		--sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
		--sl-color-fuchsia-100: hsl(287 100% 95.5%);
		--sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
		--sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
		--sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
		--sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
		--sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
		--sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
		--sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
		--sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
		--sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);

		/* Pink */
		--sl-color-pink-50: hsl(327.3 73.3% 97.1%);
		--sl-color-pink-100: hsl(325.7 77.8% 94.7%);
		--sl-color-pink-200: hsl(325.9 84.6% 89.8%);
		--sl-color-pink-300: hsl(327.4 87.1% 81.8%);
		--sl-color-pink-400: hsl(328.6 85.5% 70.2%);
		--sl-color-pink-500: hsl(330.4 81.2% 60.4%);
		--sl-color-pink-600: hsl(333.3 71.4% 50.6%);
		--sl-color-pink-700: hsl(335.1 77.6% 42%);
		--sl-color-pink-800: hsl(335.8 74.4% 35.3%);
		--sl-color-pink-900: hsl(335.9 69% 30.4%);
		--sl-color-pink-950: hsl(336.2 65.4% 15.9%);

		/* Rose */
		--sl-color-rose-50: hsl(355.7 100% 97.3%);
		--sl-color-rose-100: hsl(355.6 100% 94.7%);
		--sl-color-rose-200: hsl(352.7 96.1% 90%);
		--sl-color-rose-300: hsl(352.6 95.7% 81.8%);
		--sl-color-rose-400: hsl(351.3 94.5% 71.4%);
		--sl-color-rose-500: hsl(349.7 89.2% 60.2%);
		--sl-color-rose-600: hsl(346.8 77.2% 49.8%);
		--sl-color-rose-700: hsl(345.3 82.7% 40.8%);
		--sl-color-rose-800: hsl(343.4 79.7% 34.7%);
		--sl-color-rose-900: hsl(341.5 75.5% 30.4%);
		--sl-color-rose-950: hsl(341.3 70.1% 17.1%);

		/*
   * Theme Tokens
   */

		/* Primary */
		--sl-color-primary-50: var(--sl-color-sky-50);
		--sl-color-primary-100: var(--sl-color-sky-100);
		--sl-color-primary-200: var(--sl-color-sky-200);
		--sl-color-primary-300: var(--sl-color-sky-300);
		--sl-color-primary-400: var(--sl-color-sky-400);
		--sl-color-primary-500: var(--sl-color-sky-500);
		--sl-color-primary-600: var(--sl-color-sky-600);
		--sl-color-primary-700: var(--sl-color-sky-700);
		--sl-color-primary-800: var(--sl-color-sky-800);
		--sl-color-primary-900: var(--sl-color-sky-900);
		--sl-color-primary-950: var(--sl-color-sky-950);

		/* Success */
		--sl-color-success-50: var(--sl-color-green-50);
		--sl-color-success-100: var(--sl-color-green-100);
		--sl-color-success-200: var(--sl-color-green-200);
		--sl-color-success-300: var(--sl-color-green-300);
		--sl-color-success-400: var(--sl-color-green-400);
		--sl-color-success-500: var(--sl-color-green-500);
		--sl-color-success-600: var(--sl-color-green-600);
		--sl-color-success-700: var(--sl-color-green-700);
		--sl-color-success-800: var(--sl-color-green-800);
		--sl-color-success-900: var(--sl-color-green-900);
		--sl-color-success-950: var(--sl-color-green-950);

		/* Warning */
		--sl-color-warning-50: var(--sl-color-amber-50);
		--sl-color-warning-100: var(--sl-color-amber-100);
		--sl-color-warning-200: var(--sl-color-amber-200);
		--sl-color-warning-300: var(--sl-color-amber-300);
		--sl-color-warning-400: var(--sl-color-amber-400);
		--sl-color-warning-500: var(--sl-color-amber-500);
		--sl-color-warning-600: var(--sl-color-amber-600);
		--sl-color-warning-700: var(--sl-color-amber-700);
		--sl-color-warning-800: var(--sl-color-amber-800);
		--sl-color-warning-900: var(--sl-color-amber-900);
		--sl-color-warning-950: var(--sl-color-amber-950);

		/* Danger */
		--sl-color-danger-50: var(--sl-color-red-50);
		--sl-color-danger-100: var(--sl-color-red-100);
		--sl-color-danger-200: var(--sl-color-red-200);
		--sl-color-danger-300: var(--sl-color-red-300);
		--sl-color-danger-400: var(--sl-color-red-400);
		--sl-color-danger-500: var(--sl-color-red-500);
		--sl-color-danger-600: var(--sl-color-red-600);
		--sl-color-danger-700: var(--sl-color-red-700);
		--sl-color-danger-800: var(--sl-color-red-800);
		--sl-color-danger-900: var(--sl-color-red-900);
		--sl-color-danger-950: var(--sl-color-red-950);

		/* Neutral */
		--sl-color-neutral-50: var(--sl-color-gray-50);
		--sl-color-neutral-100: var(--sl-color-gray-100);
		--sl-color-neutral-200: var(--sl-color-gray-200);
		--sl-color-neutral-300: var(--sl-color-gray-300);
		--sl-color-neutral-400: var(--sl-color-gray-400);
		--sl-color-neutral-500: var(--sl-color-gray-500);
		--sl-color-neutral-600: var(--sl-color-gray-600);
		--sl-color-neutral-700: var(--sl-color-gray-700);
		--sl-color-neutral-800: var(--sl-color-gray-800);
		--sl-color-neutral-900: var(--sl-color-gray-900);
		--sl-color-neutral-950: var(--sl-color-gray-950);

		/* Neutral one-offs */
		--sl-color-neutral-0: hsl(0, 0%, 100%);
		--sl-color-neutral-1000: hsl(0, 0%, 0%);

		/*
   * Border radii
   */

		--sl-border-radius-small: 0.1875rem; /* 3px */
		--sl-border-radius-medium: 0.25rem; /* 4px */
		--sl-border-radius-large: 0.5rem; /* 8px */
		--sl-border-radius-x-large: 1rem; /* 16px */

		--sl-border-radius-circle: 50%;
		--sl-border-radius-pill: 9999px;

		/*
   * Elevations
   */

		--sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
		--sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);

		/*
   * Spacings
   */

		--sl-spacing-3x-small: 0.125rem; /* 2px */
		--sl-spacing-2x-small: 0.25rem; /* 4px */
		--sl-spacing-x-small: 0.5rem; /* 8px */
		--sl-spacing-small: 0.75rem; /* 12px */
		--sl-spacing-medium: 1rem; /* 16px */
		--sl-spacing-large: 1.25rem; /* 20px */
		--sl-spacing-x-large: 1.75rem; /* 28px */
		--sl-spacing-2x-large: 2.25rem; /* 36px */
		--sl-spacing-3x-large: 3rem; /* 48px */
		--sl-spacing-4x-large: 4.5rem; /* 72px */

		/*
   * Transitions
   */

		--sl-transition-x-slow: 1000ms;
		--sl-transition-slow: 500ms;
		--sl-transition-medium: 250ms;
		--sl-transition-fast: 150ms;
		--sl-transition-x-fast: 50ms;

		/*
   * Typography
   */

		/* Fonts */
		--sl-font-mono: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
		--sl-font-sans: Inter, sans-serif;
		--sl-font-serif: Inter, "Times New Roman", serif;

		/* Font sizes */
		--sl-font-size-2x-small: 0.625rem; /* 10px */
		--sl-font-size-x-small: 0.75rem; /* 12px */
		--sl-font-size-small: 0.875rem; /* 14px */
		--sl-font-size-medium: 1rem; /* 16px */
		--sl-font-size-large: 1.25rem; /* 20px */
		--sl-font-size-x-large: 1.5rem; /* 24px */
		--sl-font-size-2x-large: 2.25rem; /* 36px */
		--sl-font-size-3x-large: 3rem; /* 48px */
		--sl-font-size-4x-large: 4.5rem; /* 72px */

		/* Font weights */
		--sl-font-weight-light: 300;
		--sl-font-weight-normal: 400;
		--sl-font-weight-semibold: 500;
		--sl-font-weight-bold: 700;

		/* Letter spacings */
		--sl-letter-spacing-denser: -0.03em;
		--sl-letter-spacing-dense: -0.015em;
		--sl-letter-spacing-normal: normal;
		--sl-letter-spacing-loose: 0.075em;
		--sl-letter-spacing-looser: 0.15em;

		/* Line heights */
		--sl-line-height-denser: 1;
		--sl-line-height-dense: 1.4;
		--sl-line-height-normal: 1.8;
		--sl-line-height-loose: 2.2;
		--sl-line-height-looser: 2.6;

		/* Focus rings */
		--sl-focus-ring-color: var(--sl-color-primary-600);
		--sl-focus-ring-style: solid;
		--sl-focus-ring-width: 3px;
		--sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width)
			var(--sl-focus-ring-color);
		--sl-focus-ring-offset: 1px;

		/*
   * Forms
   */

		/* Buttons */
		--sl-button-font-size-small: var(--sl-font-size-x-small);
		--sl-button-font-size-medium: var(--sl-font-size-small);
		--sl-button-font-size-large: var(--sl-font-size-medium);

		/* Inputs */
		--sl-input-height-small: 1.875rem; /* 30px */
		--sl-input-height-medium: 2.5rem; /* 40px */
		--sl-input-height-large: 3.125rem; /* 50px */

		--sl-input-background-color: var(--sl-color-neutral-0);
		--sl-input-background-color-hover: var(--sl-input-background-color);
		--sl-input-background-color-focus: var(--sl-input-background-color);
		--sl-input-background-color-disabled: var(--sl-color-neutral-100);
		--sl-input-border-color: var(--sl-color-neutral-300);
		--sl-input-border-color-hover: var(--sl-color-neutral-400);
		--sl-input-border-color-focus: var(--sl-color-primary-500);
		--sl-input-border-color-disabled: var(--sl-color-neutral-300);
		--sl-input-border-width: 1px;
		--sl-input-required-content: "*";
		--sl-input-required-content-offset: -2px;
		--sl-input-required-content-color: var(--sl-input-label-color);

		--sl-input-border-radius-small: var(--sl-border-radius-medium);
		--sl-input-border-radius-medium: var(--sl-border-radius-medium);
		--sl-input-border-radius-large: var(--sl-border-radius-medium);

		--sl-input-font-family: var(--sl-font-sans);
		--sl-input-font-weight: var(--sl-font-weight-normal);
		--sl-input-font-size-small: var(--sl-font-size-small);
		--sl-input-font-size-medium: var(--sl-font-size-medium);
		--sl-input-font-size-large: var(--sl-font-size-large);
		--sl-input-letter-spacing: var(--sl-letter-spacing-normal);

		--sl-input-color: var(--sl-color-neutral-700);
		--sl-input-color-hover: var(--sl-color-neutral-700);
		--sl-input-color-focus: var(--sl-color-neutral-700);
		--sl-input-color-disabled: var(--sl-color-neutral-900);
		--sl-input-icon-color: var(--sl-color-neutral-500);
		--sl-input-icon-color-hover: var(--sl-color-neutral-600);
		--sl-input-icon-color-focus: var(--sl-color-neutral-600);
		--sl-input-placeholder-color: var(--sl-color-neutral-500);
		--sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
		--sl-input-spacing-small: var(--sl-spacing-small);
		--sl-input-spacing-medium: var(--sl-spacing-medium);
		--sl-input-spacing-large: var(--sl-spacing-large);

		--sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
		--sl-input-focus-ring-offset: 0;

		--sl-input-filled-background-color: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
		--sl-input-filled-color: var(--sl-color-neutral-800);
		--sl-input-filled-color-hover: var(--sl-color-neutral-800);
		--sl-input-filled-color-focus: var(--sl-color-neutral-700);
		--sl-input-filled-color-disabled: var(--sl-color-neutral-800);

		/* Labels */
		--sl-input-label-font-size-small: var(--sl-font-size-small);
		--sl-input-label-font-size-medium: var(--sl-font-size-medium);
		--sl-input-label-font-size-large: var(--sl-font-size-large);
		--sl-input-label-color: inherit;

		/* Help text */
		--sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
		--sl-input-help-text-font-size-medium: var(--sl-font-size-small);
		--sl-input-help-text-font-size-large: var(--sl-font-size-medium);
		--sl-input-help-text-color: var(--sl-color-neutral-500);

		/* Toggles (checkboxes, radios, switches) */
		--sl-toggle-size-small: 0.875rem; /* 14px */
		--sl-toggle-size-medium: 1.125rem; /* 18px */
		--sl-toggle-size-large: 1.375rem; /* 22px */

		/*
   * Overlays
   */

		--sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);

		/*
   * Panels
   */

		--sl-panel-background-color: var(--sl-color-neutral-0);
		--sl-panel-border-color: var(--sl-color-neutral-200);
		--sl-panel-border-width: 1px;

		/*
   * Tooltips
   */

		--sl-tooltip-border-radius: var(--sl-border-radius-medium);
		--sl-tooltip-background-color: var(--sl-color-neutral-800);
		--sl-tooltip-color: var(--sl-color-neutral-0);
		--sl-tooltip-font-family: var(--sl-font-sans);
		--sl-tooltip-font-weight: var(--sl-font-weight-normal);
		--sl-tooltip-font-size: var(--sl-font-size-small);
		--sl-tooltip-line-height: var(--sl-line-height-dense);
		--sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
		--sl-tooltip-arrow-size: 6px;

		/*
   * Z-indexes
   */

		--sl-z-index-drawer: 700;
		--sl-z-index-dialog: 800;
		--sl-z-index-dropdown: 900;
		--sl-z-index-toast: 950;
		--sl-z-index-tooltip: 1000;
	}
`;

// ../../../node_modules/.pnpm/@eliaspourquoi+sqlite-node-wasm@3.46.0-build2/node_modules/@eliaspourquoi/sqlite-node-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs
var sqlite3InitModule = (() => {
  var _scriptDir = import.meta.url;
  return function(config) {
    var sqlite3InitModule2 = config || {};
    var Module = typeof sqlite3InitModule2 != "undefined" ? sqlite3InitModule2 : {};
    var readyPromiseResolve, readyPromiseReject;
    Module["ready"] = new Promise(function(resolve, reject) {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    const sqlite3InitModuleState = globalThis.sqlite3InitModuleState || Object.assign(/* @__PURE__ */ Object.create(null), {
      debugModule: () => {
      }
    });
    delete globalThis.sqlite3InitModuleState;
    sqlite3InitModuleState.debugModule(
      "globalThis.location =",
      globalThis.location
    );
    const xNameOfInstantiateWasm = false ? "instantiateWasm" : "emscripten-bug-17951";
    Module[xNameOfInstantiateWasm] = function callee2(imports, onSuccess) {
      imports.env.foo = function() {
      };
      const uri = Module.locateFile(
        callee2.uri,
        "undefined" === typeof scriptDirectory ? "" : scriptDirectory
      );
      sqlite3InitModuleState.debugModule("instantiateWasm() uri =", uri);
      const wfetch = () => fetch(uri, { credentials: "same-origin" });
      const loadWasm = WebAssembly.instantiateStreaming ? async () => {
        return WebAssembly.instantiateStreaming(wfetch(), imports).then(
          (arg) => onSuccess(arg.instance, arg.module)
        );
      } : async () => {
        return wfetch().then((response) => response.arrayBuffer()).then((bytes) => WebAssembly.instantiate(bytes, imports)).then((arg) => onSuccess(arg.instance, arg.module));
      };
      loadWasm();
      return {};
    };
    Module[xNameOfInstantiateWasm].uri = "sqlite3.wasm";
    var moduleOverrides = Object.assign({}, Module);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
    var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
    var scriptDirectory = "";
    function locateFile(path2) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path2, scriptDirectory);
      }
      return scriptDirectory + path2;
    }
    var read_, readAsync, readBinary, setWindowTitle;
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }
      if (scriptDirectory.indexOf("blob:") !== 0) {
        scriptDirectory = scriptDirectory.substr(
          0,
          scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
        );
      } else {
        scriptDirectory = "";
      }
      {
        read_ = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.send(null);
          return xhr.responseText;
        };
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }
        readAsync = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = () => {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }
      setWindowTitle = (title) => document.title = title;
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.warn.bind(console);
    Object.assign(Module, moduleOverrides);
    moduleOverrides = null;
    if (Module["arguments"])
      arguments_ = Module["arguments"];
    if (Module["thisProgram"])
      thisProgram = Module["thisProgram"];
    if (Module["quit"])
      quit_ = Module["quit"];
    var STACK_ALIGN = 16;
    var POINTER_SIZE = 4;
    function getNativeTypeSize(type) {
      switch (type) {
        case "i1":
        case "i8":
        case "u8":
          return 1;
        case "i16":
        case "u16":
          return 2;
        case "i32":
        case "u32":
          return 4;
        case "i64":
        case "u64":
          return 8;
        case "float":
          return 4;
        case "double":
          return 8;
        default: {
          if (type[type.length - 1] === "*") {
            return POINTER_SIZE;
          }
          if (type[0] === "i") {
            const bits = Number(type.substr(1));
            assert(
              bits % 8 === 0,
              "getNativeTypeSize invalid bits " + bits + ", type " + type
            );
            return bits / 8;
          }
          return 0;
        }
      }
    }
    var wasmBinary2;
    if (Module["wasmBinary"])
      wasmBinary2 = Module["wasmBinary"];
    var noExitRuntime = Module["noExitRuntime"] || true;
    if (typeof WebAssembly != "object") {
      abort("no native wasm support detected");
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(
            55296 | ch >> 10,
            56320 | ch & 1023
          );
        }
      }
      return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }
    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i3 = 0; i3 < str.length; ++i3) {
        var u2 = str.charCodeAt(i3);
        if (u2 >= 55296 && u2 <= 57343) {
          var u1 = str.charCodeAt(++i3);
          u2 = 65536 + ((u2 & 1023) << 10) | u1 & 1023;
        }
        if (u2 <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u2;
        } else if (u2 <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u2 >> 6;
          heap[outIdx++] = 128 | u2 & 63;
        } else if (u2 <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u2 >> 12;
          heap[outIdx++] = 128 | u2 >> 6 & 63;
          heap[outIdx++] = 128 | u2 & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          heap[outIdx++] = 240 | u2 >> 18;
          heap[outIdx++] = 128 | u2 >> 12 & 63;
          heap[outIdx++] = 128 | u2 >> 6 & 63;
          heap[outIdx++] = 128 | u2 & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i3 = 0; i3 < str.length; ++i3) {
        var c4 = str.charCodeAt(i3);
        if (c4 <= 127) {
          len++;
        } else if (c4 <= 2047) {
          len += 2;
        } else if (c4 >= 55296 && c4 <= 57343) {
          len += 4;
          ++i3;
        } else {
          len += 3;
        }
      }
      return len;
    }
    var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    function updateMemoryViews() {
      var b2 = wasmMemory.buffer;
      Module["HEAP8"] = HEAP8 = new Int8Array(b2);
      Module["HEAP16"] = HEAP16 = new Int16Array(b2);
      Module["HEAP32"] = HEAP32 = new Int32Array(b2);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b2);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b2);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b2);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(b2);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(b2);
      Module["HEAP64"] = HEAP64 = new BigInt64Array(b2);
      Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b2);
    }
    var STACK_SIZE = 524288;
    var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
    if (Module["wasmMemory"]) {
      wasmMemory = Module["wasmMemory"];
    } else {
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_MEMORY / 65536,
        maximum: 2147483648 / 65536
      });
    }
    updateMemoryViews();
    INITIAL_MEMORY = wasmMemory.buffer.byteLength;
    var wasmTable;
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATEXIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function keepRuntimeAlive() {
      return noExitRuntime;
    }
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function")
          Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      if (!Module["noFSInit"] && !FS.init.initialized)
        FS.init();
      FS.ignorePermissions = false;
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function")
          Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnExit(cb) {
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    function addRunDependency(id) {
      runDependencies++;
      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
    }
    function removeRunDependency(id) {
      runDependencies--;
      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      if (Module["onAbort"]) {
        Module["onAbort"](what);
      }
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      what += ". Build with -sASSERTIONS for more info.";
      var e5 = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e5);
      throw e5;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }
    function isFileURI(filename) {
      return filename.startsWith("file://");
    }
    var wasmBinaryFile;
    if (Module["locateFile"]) {
      wasmBinaryFile = "sqlite3.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
    } else {
      wasmBinaryFile = new URL("sqlite3.wasm", import.meta.url).href;
    }
    function getBinary(file) {
      try {
        if (file == wasmBinaryFile && wasmBinary2) {
          return new Uint8Array(wasmBinary2);
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw "both async and sync fetching of the wasm failed";
      } catch (err2) {
        abort(err2);
      }
    }
    function getBinaryPromise() {
      if (!wasmBinary2 && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
        if (typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(function() {
            return getBinary(wasmBinaryFile);
          });
        }
      }
      return Promise.resolve().then(function() {
        return getBinary(wasmBinaryFile);
      });
    }
    function createWasm() {
      var info = {
        env: asmLibraryArg,
        wasi_snapshot_preview1: asmLibraryArg
      };
      function receiveInstance(instance, module) {
        var exports2 = instance.exports;
        Module["asm"] = exports2;
        wasmTable = Module["asm"]["__indirect_function_table"];
        addOnInit(Module["asm"]["__wasm_call_ctors"]);
        removeRunDependency("wasm-instantiate");
      }
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"]);
      }
      function instantiateArrayBuffer(receiver) {
        return getBinaryPromise().then(function(binary) {
          return WebAssembly.instantiate(binary, info);
        }).then(function(instance) {
          return instance;
        }).then(receiver, function(reason) {
          err("failed to asynchronously prepare wasm: " + reason);
          abort(reason);
        });
      }
      function instantiateAsync() {
        if (!wasmBinary2 && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(
            function(response) {
              var result = WebAssembly.instantiateStreaming(response, info);
              return result.then(receiveInstantiationResult, function(reason) {
                err("wasm streaming compile failed: " + reason);
                err("falling back to ArrayBuffer instantiation");
                return instantiateArrayBuffer(receiveInstantiationResult);
              });
            }
          );
        } else {
          return instantiateArrayBuffer(receiveInstantiationResult);
        }
      }
      if (Module["instantiateWasm"]) {
        try {
          var exports = Module["instantiateWasm"](info, receiveInstance);
          return exports;
        } catch (e5) {
          err("Module.instantiateWasm callback failed with error: " + e5);
          readyPromiseReject(e5);
        }
      }
      instantiateAsync().catch(readyPromiseReject);
      return {};
    }
    var tempDouble;
    var tempI64;
    var ASM_CONSTS = {};
    function ExitStatus(status) {
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    }
    function getValue(ptr, type = "i8") {
      if (type.endsWith("*"))
        type = "*";
      switch (type) {
        case "i1":
          return HEAP8[ptr >> 0];
        case "i8":
          return HEAP8[ptr >> 0];
        case "i16":
          return HEAP16[ptr >> 1];
        case "i32":
          return HEAP32[ptr >> 2];
        case "i64":
          return HEAP64[ptr >> 3];
        case "float":
          return HEAPF32[ptr >> 2];
        case "double":
          return HEAPF64[ptr >> 3];
        case "*":
          return HEAPU32[ptr >> 2];
        default:
          abort("invalid type for getValue: " + type);
      }
      return null;
    }
    function setValue(ptr, value, type = "i8") {
      if (type.endsWith("*"))
        type = "*";
      switch (type) {
        case "i1":
          HEAP8[ptr >> 0] = value;
          break;
        case "i8":
          HEAP8[ptr >> 0] = value;
          break;
        case "i16":
          HEAP16[ptr >> 1] = value;
          break;
        case "i32":
          HEAP32[ptr >> 2] = value;
          break;
        case "i64":
          tempI64 = [
            value >>> 0,
            (tempDouble = value, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
              +Math.floor(tempDouble / 4294967296),
              4294967295
            ) | 0) >>> 0 : ~~+Math.ceil(
              (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
            ) >>> 0 : 0)
          ], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
          break;
        case "float":
          HEAPF32[ptr >> 2] = value;
          break;
        case "double":
          HEAPF64[ptr >> 3] = value;
          break;
        case "*":
          HEAPU32[ptr >> 2] = value;
          break;
        default:
          abort("invalid type for setValue: " + type);
      }
    }
    var PATH = {
      isAbs: (path2) => path2.charAt(0) === "/",
      splitPath: (filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: (parts, allowAboveRoot) => {
        var up = 0;
        for (var i3 = parts.length - 1; i3 >= 0; i3--) {
          var last = parts[i3];
          if (last === ".") {
            parts.splice(i3, 1);
          } else if (last === "..") {
            parts.splice(i3, 1);
            up++;
          } else if (up) {
            parts.splice(i3, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      },
      normalize: (path2) => {
        var isAbsolute = PATH.isAbs(path2), trailingSlash = path2.substr(-1) === "/";
        path2 = PATH.normalizeArray(
          path2.split("/").filter((p2) => !!p2),
          !isAbsolute
        ).join("/");
        if (!path2 && !isAbsolute) {
          path2 = ".";
        }
        if (path2 && trailingSlash) {
          path2 += "/";
        }
        return (isAbsolute ? "/" : "") + path2;
      },
      dirname: (path2) => {
        var result = PATH.splitPath(path2), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: (path2) => {
        if (path2 === "/")
          return "/";
        path2 = PATH.normalize(path2);
        path2 = path2.replace(/\/$/, "");
        var lastSlash = path2.lastIndexOf("/");
        if (lastSlash === -1)
          return path2;
        return path2.substr(lastSlash + 1);
      },
      join: function() {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join("/"));
      },
      join2: (l2, r5) => {
        return PATH.normalize(l2 + "/" + r5);
      }
    };
    function getRandomDevice() {
      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
        var randomBuffer = new Uint8Array(1);
        return () => {
          crypto.getRandomValues(randomBuffer);
          return randomBuffer[0];
        };
      } else
        return () => abort("randomDevice");
    }
    var PATH_FS = {
      resolve: function() {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i3 = arguments.length - 1; i3 >= -1 && !resolvedAbsolute; i3--) {
          var path2 = i3 >= 0 ? arguments[i3] : FS.cwd();
          if (typeof path2 != "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path2) {
            return "";
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path2);
        }
        resolvedPath = PATH.normalizeArray(
          resolvedPath.split("/").filter((p2) => !!p2),
          !resolvedAbsolute
        ).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      },
      relative: (from, to2) => {
        from = PATH_FS.resolve(from).substr(1);
        to2 = PATH_FS.resolve(to2).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== "")
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "")
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split("/"));
        var toParts = trim(to2.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i3 = 0; i3 < length; i3++) {
          if (fromParts[i3] !== toParts[i3]) {
            samePartsLength = i3;
            break;
          }
        }
        var outputParts = [];
        for (var i3 = samePartsLength; i3 < fromParts.length; i3++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }
    };
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(
        stringy,
        u8array,
        0,
        u8array.length
      );
      if (dontAddNull)
        u8array.length = numBytesWritten;
      return u8array;
    }
    var TTY = {
      ttys: [],
      init: function() {
      },
      shutdown: function() {
      },
      register: function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
        close: function(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        fsync: function(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        read: function(stream, buffer, offset3, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i3 = 0; i3 < length; i3++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e5) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset3 + i3] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: function(stream, buffer, offset3, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i3 = 0; i3 < length; i3++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset3 + i3]);
            }
          } catch (e5) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i3;
        }
      },
      default_tty_ops: {
        get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },
        put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        },
        fsync: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      },
      default_tty1_ops: {
        put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        },
        fsync: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      }
    };
    function zeroMemory(address, size3) {
      HEAPU8.fill(0, address, address + size3);
      return address;
    }
    function alignMemory(size3, alignment) {
      return Math.ceil(size3 / alignment) * alignment;
    }
    function mmapAlloc(size3) {
      size3 = alignMemory(size3, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size3);
      if (!ptr)
        return 0;
      return zeroMemory(ptr, size3);
    }
    var MEMFS = {
      ops_table: null,
      mount: function(mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      },
      createNode: function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
      getFileDataAsTypedArray: function(node) {
        if (!node.contents)
          return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage: function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity)
          return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(
          newCapacity,
          prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
        );
        if (prevCapacity != 0)
          newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      },
      resizeFileStorage: function(node, newSize) {
        if (node.usedBytes == newSize)
          return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(
              oldContents.subarray(0, Math.min(newSize, node.usedBytes))
            );
          }
          node.usedBytes = newSize;
        }
      },
      node_ops: {
        getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup: function(parent, name) {
          throw FS.genericErrors[44];
        },
        mknod: function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e5) {
            }
            if (new_node) {
              for (var i3 in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },
        unlink: function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        rmdir: function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i3 in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        readdir: function(node) {
          var entries = [".", ".."];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },
        symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }
      },
      stream_ops: {
        read: function(stream, buffer, offset3, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size3 = Math.min(stream.node.usedBytes - position, length);
          if (size3 > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size3), offset3);
          } else {
            for (var i3 = 0; i3 < size3; i3++)
              buffer[offset3 + i3] = contents[position + i3];
          }
          return size3;
        },
        write: function(stream, buffer, offset3, length, position, canOwn) {
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset3, offset3 + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset3, offset3 + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(
                buffer.subarray(offset3, offset3 + length),
                position
              );
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(
              buffer.subarray(offset3, offset3 + length),
              position
            );
          } else {
            for (var i3 = 0; i3 < length; i3++) {
              node.contents[position + i3] = buffer[offset3 + i3];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek: function(stream, offset3, whence) {
          var position = offset3;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate: function(stream, offset3, length) {
          MEMFS.expandFileStorage(stream.node, offset3 + length);
          stream.node.usedBytes = Math.max(
            stream.node.usedBytes,
            offset3 + length
          );
        },
        mmap: function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr, allocated };
        },
        msync: function(stream, buffer, offset3, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset3, false);
          return 0;
        }
      }
    };
    function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
      readAsync(
        url,
        (arrayBuffer) => {
          assert(
            arrayBuffer,
            'Loading data file "' + url + '" failed (no arrayBuffer).'
          );
          onload(new Uint8Array(arrayBuffer));
          if (dep)
            removeRunDependency(dep);
        },
        (event) => {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        }
      );
      if (dep)
        addRunDependency(dep);
    }
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: "/",
      initialized: false,
      ignorePermissions: true,
      ErrnoError: null,
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      lookupPath: (path2, opts = {}) => {
        path2 = PATH_FS.resolve(path2);
        if (!path2)
          return { path: "", node: null };
        var defaults2 = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults2, opts);
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts = path2.split("/").filter((p2) => !!p2);
        var current = FS.root;
        var current_path = "/";
        for (var i3 = 0; i3 < parts.length; i3++) {
          var islast = i3 === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts[i3]);
          current_path = PATH.join2(current_path, parts[i3]);
          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count + 1
              });
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return { path: current_path, node: current };
      },
      getPath: (node) => {
        var path2;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path2)
              return mount;
            return mount[mount.length - 1] !== "/" ? mount + "/" + path2 : mount + path2;
          }
          path2 = path2 ? node.name + "/" + path2 : node.name;
          node = node.parent;
        }
      },
      hashName: (parentid, name) => {
        var hash = 0;
        for (var i3 = 0; i3 < name.length; i3++) {
          hash = (hash << 5) - hash + name.charCodeAt(i3) | 0;
        }
        return (parentid + hash >>> 0) % FS.nameTable.length;
      },
      hashAddNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode: (parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        return FS.lookup(parent, name);
      },
      createNode: (parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node;
      },
      destroyNode: (node) => {
        FS.hashRemoveNode(node);
      },
      isRoot: (node) => {
        return node === node.parent;
      },
      isMountpoint: (node) => {
        return !!node.mounted;
      },
      isFile: (mode) => {
        return (mode & 61440) === 32768;
      },
      isDir: (mode) => {
        return (mode & 61440) === 16384;
      },
      isLink: (mode) => {
        return (mode & 61440) === 40960;
      },
      isChrdev: (mode) => {
        return (mode & 61440) === 8192;
      },
      isBlkdev: (mode) => {
        return (mode & 61440) === 24576;
      },
      isFIFO: (mode) => {
        return (mode & 61440) === 4096;
      },
      isSocket: (mode) => {
        return (mode & 49152) === 49152;
      },
      flagModes: { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 },
      modeStringToFlags: (str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == "undefined") {
          throw new Error("Unknown file open mode: " + str);
        }
        return flags;
      },
      flagsToPermissionString: (flag) => {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
          perms += "w";
        }
        return perms;
      },
      nodePermissions: (node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.includes("r") && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes("w") && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes("x") && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup: (dir) => {
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode)
          return errCode;
        if (!dir.node_ops.lookup)
          return 2;
        return 0;
      },
      mayCreate: (dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e5) {
        }
        return FS.nodePermissions(dir, "wx");
      },
      mayDelete: (dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e5) {
          return e5.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen: (node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStream: (fd) => FS.streams[fd],
      createStream: (stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = function() {
            this.shared = {};
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() {
                return this.node;
              },
              set: function(val) {
                this.node = val;
              }
            },
            isRead: {
              get: function() {
                return (this.flags & 2097155) !== 1;
              }
            },
            isWrite: {
              get: function() {
                return (this.flags & 2097155) !== 0;
              }
            },
            isAppend: {
              get: function() {
                return this.flags & 1024;
              }
            },
            flags: {
              get: function() {
                return this.shared.flags;
              },
              set: function(val) {
                this.shared.flags = val;
              }
            },
            position: {
              get: function() {
                return this.shared.position;
              },
              set: function(val) {
                this.shared.position = val;
              }
            }
          });
        }
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream: (fd) => {
        FS.streams[fd] = null;
      },
      chrdev_stream_ops: {
        open: (stream) => {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },
        llseek: () => {
          throw new FS.ErrnoError(70);
        }
      },
      major: (dev) => dev >> 8,
      minor: (dev) => dev & 255,
      makedev: (ma, mi) => ma << 8 | mi,
      registerDevice: (dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: (dev) => FS.devices[dev],
      getMounts: (mount) => {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m3 = check.pop();
          mounts.push(m3);
          check.push.apply(check, m3.mounts);
        }
        return mounts;
      },
      syncfs: (populate, callback) => {
        if (typeof populate == "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err(
            "warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work"
          );
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount: (type, opts, mountpoint) => {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      },
      unmount: (mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup: (parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },
      mknod: (path2, mode, dev) => {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path2);
        if (!name || name === "." || name === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create: (path2, mode) => {
        mode = mode !== void 0 ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path2, mode, 0);
      },
      mkdir: (path2, mode) => {
        mode = mode !== void 0 ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path2, mode, 0);
      },
      mkdirTree: (path2, mode) => {
        var dirs = path2.split("/");
        var d2 = "";
        for (var i3 = 0; i3 < dirs.length; ++i3) {
          if (!dirs[i3])
            continue;
          d2 += "/" + dirs[i3];
          try {
            FS.mkdir(d2, mode);
          } catch (e5) {
            if (e5.errno != 20)
              throw e5;
          }
        }
      },
      mkdev: (path2, mode, dev) => {
        if (typeof dev == "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path2, mode, dev);
      },
      symlink: (oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename: (old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
        if (!old_dir || !new_dir)
          throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e5) {
        }
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e5) {
          throw e5;
        } finally {
          FS.hashAddNode(old_node);
        }
      },
      rmdir: (path2) => {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path2);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
      readdir: (path2) => {
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink: (path2) => {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path2);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
      readlink: (path2) => {
        var lookup = FS.lookupPath(path2);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(
          FS.getPath(link.parent),
          link.node_ops.readlink(link)
        );
      },
      stat: (path2, dontFollow) => {
        var lookup = FS.lookupPath(path2, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat: (path2) => {
        return FS.stat(path2, true);
      },
      chmod: (path2, mode, dontFollow) => {
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: mode & 4095 | node.mode & ~4095,
          timestamp: Date.now()
        });
      },
      lchmod: (path2, mode) => {
        FS.chmod(path2, mode, true);
      },
      fchmod: (fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },
      chown: (path2, uid, gid, dontFollow) => {
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
        });
      },
      lchown: (path2, uid, gid) => {
        FS.chown(path2, uid, gid, true);
      },
      fchown: (fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },
      truncate: (path2, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: true });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
      ftruncate: (fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
      utime: (path2, atime, mtime) => {
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },
      open: (path2, flags, mode) => {
        if (path2 === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == "string" ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == "undefined" ? 438 : mode;
        if (flags & 64) {
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path2 == "object") {
          node = path2;
        } else {
          path2 = PATH.normalize(path2);
          try {
            var lookup = FS.lookupPath(path2, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e5) {
          }
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path2, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags & 512 && !created) {
          FS.truncate(node, 0);
        }
        flags &= ~(128 | 512 | 131072);
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          ungotten: [],
          error: false
        });
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module["logReadFiles"] && !(flags & 1)) {
          if (!FS.readFiles)
            FS.readFiles = {};
          if (!(path2 in FS.readFiles)) {
            FS.readFiles[path2] = 1;
          }
        }
        return stream;
      },
      close: (stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents)
          stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e5) {
          throw e5;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed: (stream) => {
        return stream.fd === null;
      },
      llseek: (stream, offset3, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset3, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read: (stream, buffer, offset3, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(
          stream,
          buffer,
          offset3,
          length,
          position
        );
        if (!seeking)
          stream.position += bytesRead;
        return bytesRead;
      },
      write: (stream, buffer, offset3, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(
          stream,
          buffer,
          offset3,
          length,
          position,
          canOwn
        );
        if (!seeking)
          stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate: (stream, offset3, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset3 < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset3, length);
      },
      mmap: (stream, length, position, prot, flags) => {
        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
      msync: (stream, buffer, offset3, length, mmapFlags) => {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(
          stream,
          buffer,
          offset3,
          length,
          mmapFlags
        );
      },
      munmap: (stream) => 0,
      ioctl: (stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile: (path2, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path2, opts.flags);
        var stat = FS.stat(path2);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
      writeFile: (path2, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path2, opts.flags, opts.mode);
        if (typeof data == "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream);
      },
      cwd: () => FS.currentPath,
      chdir: (path2) => {
        var lookup = FS.lookupPath(path2, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories: () => {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      },
      createDefaultDevices: () => {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset3, length, pos) => length
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var random_device = getRandomDevice();
        FS.createDevice("/dev", "random", random_device);
        FS.createDevice("/dev", "urandom", random_device);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      },
      createSpecialDirectories: () => {
        FS.mkdir("/proc");
        var proc_self = FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount(
          {
            mount: () => {
              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
              node.node_ops = {
                lookup: (parent, name) => {
                  var fd = +name;
                  var stream = FS.getStream(fd);
                  if (!stream)
                    throw new FS.ErrnoError(8);
                  var ret = {
                    parent: null,
                    mount: { mountpoint: "fake" },
                    node_ops: { readlink: () => stream.path }
                  };
                  ret.parent = ret;
                  return ret;
                }
              };
              return node;
            }
          },
          {},
          "/proc/self/fd"
        );
      },
      createStandardStreams: () => {
        if (Module["stdin"]) {
          FS.createDevice("/dev", "stdin", Module["stdin"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (Module["stdout"]) {
          FS.createDevice("/dev", "stdout", null, Module["stdout"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (Module["stderr"]) {
          FS.createDevice("/dev", "stderr", null, Module["stderr"]);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        var stdin = FS.open("/dev/stdin", 0);
        var stdout = FS.open("/dev/stdout", 1);
        var stderr = FS.open("/dev/stderr", 1);
      },
      ensureErrnoError: () => {
        if (FS.ErrnoError)
          return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function(errno2) {
            this.errno = errno2;
          };
          this.setErrno(errno);
          this.message = "FS error";
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
      },
      staticInit: () => {
        FS.ensureErrnoError();
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {
          MEMFS
        };
      },
      init: (input, output, error) => {
        FS.init.initialized = true;
        FS.ensureErrnoError();
        Module["stdin"] = input || Module["stdin"];
        Module["stdout"] = output || Module["stdout"];
        Module["stderr"] = error || Module["stderr"];
        FS.createStandardStreams();
      },
      quit: () => {
        FS.init.initialized = false;
        for (var i3 = 0; i3 < FS.streams.length; i3++) {
          var stream = FS.streams[i3];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
      getMode: (canRead, canWrite) => {
        var mode = 0;
        if (canRead)
          mode |= 292 | 73;
        if (canWrite)
          mode |= 146;
        return mode;
      },
      findObject: (path2, dontResolveLastLink) => {
        var ret = FS.analyzePath(path2, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
      analyzePath: (path2, dontResolveLastLink) => {
        try {
          var lookup = FS.lookupPath(path2, { follow: !dontResolveLastLink });
          path2 = lookup.path;
        } catch (e5) {
        }
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path2, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path2);
          lookup = FS.lookupPath(path2, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e5) {
          ret.error = e5.errno;
        }
        return ret;
      },
      createPath: (parent, path2, canRead, canWrite) => {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        var parts = path2.split("/").reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part)
            continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e5) {
          }
          parent = current;
        }
        return current;
      },
      createFile: (parent, name, properties, canRead, canWrite) => {
        var path2 = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path2, mode);
      },
      createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
        var path2 = name;
        if (parent) {
          parent = typeof parent == "string" ? parent : FS.getPath(parent);
          path2 = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path2, mode);
        if (data) {
          if (typeof data == "string") {
            var arr = new Array(data.length);
            for (var i3 = 0, len = data.length; i3 < len; ++i3)
              arr[i3] = data.charCodeAt(i3);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },
      createDevice: (parent, name, input, output) => {
        var path2 = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major)
          FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset3, length, pos) => {
            var bytesRead = 0;
            for (var i3 = 0; i3 < length; i3++) {
              var result;
              try {
                result = input();
              } catch (e5) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer[offset3 + i3] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset3, length, pos) => {
            for (var i3 = 0; i3 < length; i3++) {
              try {
                output(buffer[offset3 + i3]);
              } catch (e5) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i3;
          }
        });
        return FS.mkdev(path2, mode, dev);
      },
      forceLoadFile: (obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest != "undefined") {
          throw new Error(
            "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
          );
        } else if (read_) {
          try {
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e5) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error("Cannot load without read() or XMLHttpRequest.");
        }
      },
      createLazyFile: (parent, name, url, canRead, canWrite) => {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to2) => {
            if (from > to2)
              throw new Error(
                "invalid range (" + from + ", " + to2 + ") or no bytes requested!"
              );
            if (to2 > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to2);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(xhr2.response || []);
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != "undefined") {
          if (!ENVIRONMENT_IS_WORKER)
            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url };
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {
          usedBytes: {
            get: function() {
              return this.contents.length;
            }
          }
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset3, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size3 = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i3 = 0; i3 < size3; i3++) {
              buffer[offset3 + i3] = contents[position + i3];
            }
          } else {
            for (var i3 = 0; i3 < size3; i3++) {
              buffer[offset3 + i3] = contents.get(position + i3);
            }
          }
          return size3;
        }
        stream_ops.read = (stream, buffer, offset3, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset3, length, position);
        };
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
      createPreloadedFile: (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency("cp " + fullname);
        function processData(byteArray) {
          function finish(byteArray2) {
            if (preFinish)
              preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(
                parent,
                name,
                byteArray2,
                canRead,
                canWrite,
                canOwn
              );
            }
            if (onload)
              onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror)
              onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == "string") {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },
      indexedDB: () => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },
      DB_NAME: () => {
        return "EM_FS_" + window.location.pathname;
      },
      DB_VERSION: 20,
      DB_STORE_NAME: "FILE_DATA",
      saveFilesToDB: (paths, onload, onerror) => {
        onload = onload || (() => {
        });
        onerror = onerror || (() => {
        });
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e5) {
          return onerror(e5);
        }
        openRequest.onupgradeneeded = () => {
          out("creating db");
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0)
              onload();
            else
              onerror();
          }
          paths.forEach((path2) => {
            var putRequest = files.put(
              FS.analyzePath(path2).object.contents,
              path2
            );
            putRequest.onsuccess = () => {
              ok++;
              if (ok + fail == total)
                finish();
            };
            putRequest.onerror = () => {
              fail++;
              if (ok + fail == total)
                finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
      loadFilesFromDB: (paths, onload, onerror) => {
        onload = onload || (() => {
        });
        onerror = onerror || (() => {
        });
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e5) {
          return onerror(e5);
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
          } catch (e5) {
            onerror(e5);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0)
              onload();
            else
              onerror();
          }
          paths.forEach((path2) => {
            var getRequest = files.get(path2);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path2).exists) {
                FS.unlink(path2);
              }
              FS.createDataFile(
                PATH.dirname(path2),
                PATH.basename(path2),
                getRequest.result,
                true,
                true,
                true
              );
              ok++;
              if (ok + fail == total)
                finish();
            };
            getRequest.onerror = () => {
              fail++;
              if (ok + fail == total)
                finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      calculateAt: function(dirfd, path2, allowEmpty) {
        if (PATH.isAbs(path2)) {
          return path2;
        }
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path2.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
          }
          return dir;
        }
        return PATH.join2(dir, path2);
      },
      doStat: function(func, path2, buf) {
        try {
          var stat = func(path2);
        } catch (e5) {
          if (e5 && e5.node && PATH.normalize(path2) !== PATH.normalize(FS.getPath(e5.node))) {
            return -54;
          }
          throw e5;
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 8 >> 2] = stat.ino;
        HEAP32[buf + 12 >> 2] = stat.mode;
        HEAPU32[buf + 16 >> 2] = stat.nlink;
        HEAP32[buf + 20 >> 2] = stat.uid;
        HEAP32[buf + 24 >> 2] = stat.gid;
        HEAP32[buf + 28 >> 2] = stat.rdev;
        tempI64 = [
          stat.size >>> 0,
          (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
        HEAP32[buf + 48 >> 2] = 4096;
        HEAP32[buf + 52 >> 2] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        tempI64 = [
          Math.floor(atime / 1e3) >>> 0,
          (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
        HEAPU32[buf + 64 >> 2] = atime % 1e3 * 1e3;
        tempI64 = [
          Math.floor(mtime / 1e3) >>> 0,
          (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
        HEAPU32[buf + 80 >> 2] = mtime % 1e3 * 1e3;
        tempI64 = [
          Math.floor(ctime / 1e3) >>> 0,
          (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
        HEAPU32[buf + 96 >> 2] = ctime % 1e3 * 1e3;
        tempI64 = [
          stat.ino >>> 0,
          (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 104 >> 2] = tempI64[0], HEAP32[buf + 108 >> 2] = tempI64[1];
        return 0;
      },
      doMsync: function(addr, stream, len, flags, offset3) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset3, len, flags);
      },
      varargs: void 0,
      get: function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret;
      },
      getStr: function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
      getStreamFromFD: function(fd) {
        var stream = FS.getStream(fd);
        if (!stream)
          throw new FS.ErrnoError(8);
        return stream;
      }
    };
    function ___syscall_chmod(path2, mode) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.chmod(path2, mode);
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_faccessat(dirfd, path2, amode, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (amode & ~7) {
          return -28;
        }
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = "";
        if (amode & 4)
          perms += "r";
        if (amode & 2)
          perms += "w";
        if (amode & 1)
          perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_fchmod(fd, mode) {
      try {
        FS.fchmod(fd, mode);
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_fchown32(fd, owner, group) {
      try {
        FS.fchown(fd, owner, group);
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function setErrNo(value) {
      HEAP32[___errno_location() >> 2] = value;
      return value;
    }
    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = SYSCALLS.get();
            if (arg < 0) {
              return -28;
            }
            var newStream;
            newStream = FS.createStream(stream, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream.flags;
          case 4: {
            var arg = SYSCALLS.get();
            stream.flags |= arg;
            return 0;
          }
          case 5: {
            var arg = SYSCALLS.get();
            var offset3 = 0;
            HEAP16[arg + offset3 >> 1] = 2;
            return 0;
          }
          case 6:
          case 7:
            return 0;
          case 16:
          case 8:
            return -28;
          case 9:
            setErrNo(28);
            return -1;
          default: {
            return -28;
          }
        }
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_fstat64(fd, buf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    var MAX_INT53 = 9007199254740992;
    var MIN_INT53 = -9007199254740992;
    function bigintToI53Checked(num2) {
      return num2 < MIN_INT53 || num2 > MAX_INT53 ? NaN : Number(num2);
    }
    function ___syscall_ftruncate64(fd, length) {
      try {
        length = bigintToI53Checked(length);
        if (isNaN(length))
          return -61;
        FS.ftruncate(fd, length);
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_getcwd(buf, size3) {
      try {
        if (size3 === 0)
          return -28;
        var cwd = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
        if (size3 < cwdLengthInBytes)
          return -68;
        stringToUTF8(cwd, buf, size3);
        return cwdLengthInBytes;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509:
          case 21505: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
          case 21506:
          case 21507:
          case 21508: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21519: {
            if (!stream.tty)
              return -59;
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream.tty)
              return -59;
            return -28;
          }
          case 21531: {
            var argp = SYSCALLS.get();
            return FS.ioctl(stream, op, argp);
          }
          case 21523: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21524: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          default:
            return -28;
        }
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_lstat64(path2, buf) {
      try {
        path2 = SYSCALLS.getStr(path2);
        return SYSCALLS.doStat(FS.lstat, path2, buf);
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_mkdirat(dirfd, path2, mode) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        path2 = PATH.normalize(path2);
        if (path2[path2.length - 1] === "/")
          path2 = path2.substr(0, path2.length - 1);
        FS.mkdir(path2, mode, 0);
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_newfstatat(dirfd, path2, buf, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        var nofollow = flags & 256;
        var allowEmpty = flags & 4096;
        flags = flags & ~6400;
        path2 = SYSCALLS.calculateAt(dirfd, path2, allowEmpty);
        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path2, buf);
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_openat(dirfd, path2, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        var mode = varargs ? SYSCALLS.get() : 0;
        return FS.open(path2, flags, mode).fd;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_readlinkat(dirfd, path2, buf, bufsize) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (bufsize <= 0)
          return -28;
        var ret = FS.readlink(path2);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_rmdir(path2) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.rmdir(path2);
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_stat64(path2, buf) {
      try {
        path2 = SYSCALLS.getStr(path2);
        return SYSCALLS.doStat(FS.stat, path2, buf);
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function ___syscall_unlinkat(dirfd, path2, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (flags === 0) {
          FS.unlink(path2);
        } else if (flags === 512) {
          FS.rmdir(path2);
        } else {
          abort("Invalid flags passed to unlinkat");
        }
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function readI53FromI64(ptr) {
      return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
    }
    function ___syscall_utimensat(dirfd, path2, times, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2, true);
        if (!times) {
          var atime = Date.now();
          var mtime = atime;
        } else {
          var seconds = readI53FromI64(times);
          var nanoseconds = HEAP32[times + 8 >> 2];
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
          times += 16;
          seconds = readI53FromI64(times);
          nanoseconds = HEAP32[times + 8 >> 2];
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        FS.utime(path2, atime, mtime);
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    var nowIsMonotonic = true;
    function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }
    function __isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var __MONTH_DAYS_LEAP_CUMULATIVE = [
      0,
      31,
      60,
      91,
      121,
      152,
      182,
      213,
      244,
      274,
      305,
      335
    ];
    var __MONTH_DAYS_REGULAR_CUMULATIVE = [
      0,
      31,
      59,
      90,
      120,
      151,
      181,
      212,
      243,
      273,
      304,
      334
    ];
    function __yday_from_date(date) {
      var isLeapYear = __isLeapYear(date.getFullYear());
      var monthDaysCumulative = isLeapYear ? __MONTH_DAYS_LEAP_CUMULATIVE : __MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
      return yday;
    }
    function __localtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time) * 1e3);
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = __yday_from_date(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[tmPtr + 32 >> 2] = dst;
    }
    function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var res = FS.mmap(stream, len, off, prot, flags);
        var ptr = res.ptr;
        HEAP32[allocated >> 2] = res.allocated;
        HEAPU32[addr >> 2] = ptr;
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function __munmap_js(addr, len, prot, flags, fd, offset3) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, flags, offset3);
        }
        FS.munmap(stream);
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return -e5.errno;
      }
    }
    function allocateUTF8(str) {
      var size3 = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size3);
      if (ret)
        stringToUTF8Array(str, HEAP8, ret, size3);
      return ret;
    }
    function __tzset_js(timezone, daylight, tzname) {
      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
      function extractZone(date) {
        var match2 = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match2 ? match2[1] : "GMT";
      }
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        HEAPU32[tzname >> 2] = winterNamePtr;
        HEAPU32[tzname + 4 >> 2] = summerNamePtr;
      } else {
        HEAPU32[tzname >> 2] = summerNamePtr;
        HEAPU32[tzname + 4 >> 2] = winterNamePtr;
      }
    }
    function _emscripten_date_now() {
      return Date.now();
    }
    var _emscripten_get_now;
    _emscripten_get_now = () => performance.now();
    function getHeapMax() {
      return 2147483648;
    }
    function emscripten_realloc_buffer(size3) {
      var b2 = wasmMemory.buffer;
      try {
        wasmMemory.grow(size3 - b2.byteLength + 65535 >>> 16);
        updateMemoryViews();
        return 1;
      } catch (e5) {
      }
    }
    function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      let alignUp = (x2, multiple) => x2 + (multiple - x2 % multiple) % multiple;
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(
          overGrownHeapSize,
          requestedSize + 100663296
        );
        var newSize = Math.min(
          maxHeapSize,
          alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)
        );
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }
    var ENV = {};
    function getExecutableName() {
      return thisProgram || "./this.program";
    }
    function getEnvStrings() {
      if (!getEnvStrings.strings) {
        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
        var env = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: lang,
          _: getExecutableName()
        };
        for (var x2 in ENV) {
          if (ENV[x2] === void 0)
            delete env[x2];
          else
            env[x2] = ENV[x2];
        }
        var strings = [];
        for (var x2 in env) {
          strings.push(x2 + "=" + env[x2]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
    function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i3 = 0; i3 < str.length; ++i3) {
        HEAP8[buffer++ >> 0] = str.charCodeAt(i3);
      }
      if (!dontAddNull)
        HEAP8[buffer >> 0] = 0;
    }
    function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i3) {
        var ptr = environ_buf + bufSize;
        HEAPU32[__environ + i3 * 4 >> 2] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }
    function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    }
    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return e5.errno;
      }
    }
    function _fd_fdstat_get(fd, pbuf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
        HEAP8[pbuf >> 0] = type;
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return e5.errno;
      }
    }
    function doReadv(stream, iov, iovcnt, offset3) {
      var ret = 0;
      for (var i3 = 0; i3 < iovcnt; i3++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset3);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len)
          break;
        if (typeof offset3 !== "undefined") {
          offset3 += curr;
        }
      }
      return ret;
    }
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return e5.errno;
      }
    }
    function _fd_seek(fd, offset3, whence, newOffset) {
      try {
        offset3 = bigintToI53Checked(offset3);
        if (isNaN(offset3))
          return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset3, whence);
        tempI64 = [
          stream.position >>> 0,
          (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
        if (stream.getdents && offset3 === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return e5.errno;
      }
    }
    function _fd_sync(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (stream.stream_ops && stream.stream_ops.fsync) {
          return stream.stream_ops.fsync(stream);
        }
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return e5.errno;
      }
    }
    function doWritev(stream, iov, iovcnt, offset3) {
      var ret = 0;
      for (var i3 = 0; i3 < iovcnt; i3++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset3);
        if (curr < 0)
          return -1;
        ret += curr;
        if (typeof offset3 !== "undefined") {
          offset3 += curr;
        }
      }
      return ret;
    }
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num2 = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e5) {
        if (typeof FS == "undefined" || !(e5 instanceof FS.ErrnoError))
          throw e5;
        return e5.errno;
      }
    }
    var FSNode = function(parent, name, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };
    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, {
      read: {
        get: function() {
          return (this.mode & readMode) === readMode;
        },
        set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        }
      },
      write: {
        get: function() {
          return (this.mode & writeMode) === writeMode;
        },
        set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        }
      },
      isFolder: {
        get: function() {
          return FS.isDir(this.mode);
        }
      },
      isDevice: {
        get: function() {
          return FS.isChrdev(this.mode);
        }
      }
    });
    FS.FSNode = FSNode;
    FS.staticInit();
    var ASSERTIONS = false;
    var asmLibraryArg = {
      __syscall_chmod: ___syscall_chmod,
      __syscall_faccessat: ___syscall_faccessat,
      __syscall_fchmod: ___syscall_fchmod,
      __syscall_fchown32: ___syscall_fchown32,
      __syscall_fcntl64: ___syscall_fcntl64,
      __syscall_fstat64: ___syscall_fstat64,
      __syscall_ftruncate64: ___syscall_ftruncate64,
      __syscall_getcwd: ___syscall_getcwd,
      __syscall_ioctl: ___syscall_ioctl,
      __syscall_lstat64: ___syscall_lstat64,
      __syscall_mkdirat: ___syscall_mkdirat,
      __syscall_newfstatat: ___syscall_newfstatat,
      __syscall_openat: ___syscall_openat,
      __syscall_readlinkat: ___syscall_readlinkat,
      __syscall_rmdir: ___syscall_rmdir,
      __syscall_stat64: ___syscall_stat64,
      __syscall_unlinkat: ___syscall_unlinkat,
      __syscall_utimensat: ___syscall_utimensat,
      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
      _localtime_js: __localtime_js,
      _mmap_js: __mmap_js,
      _munmap_js: __munmap_js,
      _tzset_js: __tzset_js,
      emscripten_date_now: _emscripten_date_now,
      emscripten_get_now: _emscripten_get_now,
      emscripten_resize_heap: _emscripten_resize_heap,
      environ_get: _environ_get,
      environ_sizes_get: _environ_sizes_get,
      fd_close: _fd_close,
      fd_fdstat_get: _fd_fdstat_get,
      fd_read: _fd_read,
      fd_seek: _fd_seek,
      fd_sync: _fd_sync,
      fd_write: _fd_write,
      memory: wasmMemory
    };
    var asm = createWasm();
    var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
      return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
    };
    var _sqlite3_status64 = Module["_sqlite3_status64"] = function() {
      return (_sqlite3_status64 = Module["_sqlite3_status64"] = Module["asm"]["sqlite3_status64"]).apply(null, arguments);
    };
    var _sqlite3_status = Module["_sqlite3_status"] = function() {
      return (_sqlite3_status = Module["_sqlite3_status"] = Module["asm"]["sqlite3_status"]).apply(null, arguments);
    };
    var _sqlite3_db_status = Module["_sqlite3_db_status"] = function() {
      return (_sqlite3_db_status = Module["_sqlite3_db_status"] = Module["asm"]["sqlite3_db_status"]).apply(null, arguments);
    };
    var _sqlite3_msize = Module["_sqlite3_msize"] = function() {
      return (_sqlite3_msize = Module["_sqlite3_msize"] = Module["asm"]["sqlite3_msize"]).apply(null, arguments);
    };
    var _sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = function() {
      return (_sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = Module["asm"]["sqlite3_vfs_find"]).apply(null, arguments);
    };
    var _sqlite3_initialize = Module["_sqlite3_initialize"] = function() {
      return (_sqlite3_initialize = Module["_sqlite3_initialize"] = Module["asm"]["sqlite3_initialize"]).apply(null, arguments);
    };
    var _sqlite3_malloc = Module["_sqlite3_malloc"] = function() {
      return (_sqlite3_malloc = Module["_sqlite3_malloc"] = Module["asm"]["sqlite3_malloc"]).apply(null, arguments);
    };
    var _sqlite3_free = Module["_sqlite3_free"] = function() {
      return (_sqlite3_free = Module["_sqlite3_free"] = Module["asm"]["sqlite3_free"]).apply(null, arguments);
    };
    var _sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = function() {
      return (_sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = Module["asm"]["sqlite3_vfs_register"]).apply(null, arguments);
    };
    var _sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = function() {
      return (_sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = Module["asm"]["sqlite3_vfs_unregister"]).apply(null, arguments);
    };
    var _sqlite3_malloc64 = Module["_sqlite3_malloc64"] = function() {
      return (_sqlite3_malloc64 = Module["_sqlite3_malloc64"] = Module["asm"]["sqlite3_malloc64"]).apply(null, arguments);
    };
    var _sqlite3_realloc = Module["_sqlite3_realloc"] = function() {
      return (_sqlite3_realloc = Module["_sqlite3_realloc"] = Module["asm"]["sqlite3_realloc"]).apply(null, arguments);
    };
    var _sqlite3_realloc64 = Module["_sqlite3_realloc64"] = function() {
      return (_sqlite3_realloc64 = Module["_sqlite3_realloc64"] = Module["asm"]["sqlite3_realloc64"]).apply(null, arguments);
    };
    var _sqlite3_value_text = Module["_sqlite3_value_text"] = function() {
      return (_sqlite3_value_text = Module["_sqlite3_value_text"] = Module["asm"]["sqlite3_value_text"]).apply(null, arguments);
    };
    var _sqlite3_randomness = Module["_sqlite3_randomness"] = function() {
      return (_sqlite3_randomness = Module["_sqlite3_randomness"] = Module["asm"]["sqlite3_randomness"]).apply(null, arguments);
    };
    var _sqlite3_stricmp = Module["_sqlite3_stricmp"] = function() {
      return (_sqlite3_stricmp = Module["_sqlite3_stricmp"] = Module["asm"]["sqlite3_stricmp"]).apply(null, arguments);
    };
    var _sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = function() {
      return (_sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = Module["asm"]["sqlite3_strnicmp"]).apply(null, arguments);
    };
    var _sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = function() {
      return (_sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = Module["asm"]["sqlite3_uri_parameter"]).apply(null, arguments);
    };
    var ___errno_location = Module["___errno_location"] = function() {
      return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
    };
    var _sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = function() {
      return (_sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = Module["asm"]["sqlite3_uri_boolean"]).apply(null, arguments);
    };
    var _sqlite3_serialize = Module["_sqlite3_serialize"] = function() {
      return (_sqlite3_serialize = Module["_sqlite3_serialize"] = Module["asm"]["sqlite3_serialize"]).apply(null, arguments);
    };
    var _sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = function() {
      return (_sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = Module["asm"]["sqlite3_prepare_v2"]).apply(null, arguments);
    };
    var _sqlite3_step = Module["_sqlite3_step"] = function() {
      return (_sqlite3_step = Module["_sqlite3_step"] = Module["asm"]["sqlite3_step"]).apply(null, arguments);
    };
    var _sqlite3_column_int64 = Module["_sqlite3_column_int64"] = function() {
      return (_sqlite3_column_int64 = Module["_sqlite3_column_int64"] = Module["asm"]["sqlite3_column_int64"]).apply(null, arguments);
    };
    var _sqlite3_reset = Module["_sqlite3_reset"] = function() {
      return (_sqlite3_reset = Module["_sqlite3_reset"] = Module["asm"]["sqlite3_reset"]).apply(null, arguments);
    };
    var _sqlite3_exec = Module["_sqlite3_exec"] = function() {
      return (_sqlite3_exec = Module["_sqlite3_exec"] = Module["asm"]["sqlite3_exec"]).apply(null, arguments);
    };
    var _sqlite3_column_int = Module["_sqlite3_column_int"] = function() {
      return (_sqlite3_column_int = Module["_sqlite3_column_int"] = Module["asm"]["sqlite3_column_int"]).apply(null, arguments);
    };
    var _sqlite3_finalize = Module["_sqlite3_finalize"] = function() {
      return (_sqlite3_finalize = Module["_sqlite3_finalize"] = Module["asm"]["sqlite3_finalize"]).apply(null, arguments);
    };
    var _sqlite3_file_control = Module["_sqlite3_file_control"] = function() {
      return (_sqlite3_file_control = Module["_sqlite3_file_control"] = Module["asm"]["sqlite3_file_control"]).apply(null, arguments);
    };
    var _sqlite3_column_name = Module["_sqlite3_column_name"] = function() {
      return (_sqlite3_column_name = Module["_sqlite3_column_name"] = Module["asm"]["sqlite3_column_name"]).apply(null, arguments);
    };
    var _sqlite3_column_text = Module["_sqlite3_column_text"] = function() {
      return (_sqlite3_column_text = Module["_sqlite3_column_text"] = Module["asm"]["sqlite3_column_text"]).apply(null, arguments);
    };
    var _sqlite3_column_type = Module["_sqlite3_column_type"] = function() {
      return (_sqlite3_column_type = Module["_sqlite3_column_type"] = Module["asm"]["sqlite3_column_type"]).apply(null, arguments);
    };
    var _sqlite3_errmsg = Module["_sqlite3_errmsg"] = function() {
      return (_sqlite3_errmsg = Module["_sqlite3_errmsg"] = Module["asm"]["sqlite3_errmsg"]).apply(null, arguments);
    };
    var _sqlite3_deserialize = Module["_sqlite3_deserialize"] = function() {
      return (_sqlite3_deserialize = Module["_sqlite3_deserialize"] = Module["asm"]["sqlite3_deserialize"]).apply(null, arguments);
    };
    var _sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = function() {
      return (_sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = Module["asm"]["sqlite3_clear_bindings"]).apply(null, arguments);
    };
    var _sqlite3_value_blob = Module["_sqlite3_value_blob"] = function() {
      return (_sqlite3_value_blob = Module["_sqlite3_value_blob"] = Module["asm"]["sqlite3_value_blob"]).apply(null, arguments);
    };
    var _sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = function() {
      return (_sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = Module["asm"]["sqlite3_value_bytes"]).apply(null, arguments);
    };
    var _sqlite3_value_double = Module["_sqlite3_value_double"] = function() {
      return (_sqlite3_value_double = Module["_sqlite3_value_double"] = Module["asm"]["sqlite3_value_double"]).apply(null, arguments);
    };
    var _sqlite3_value_int = Module["_sqlite3_value_int"] = function() {
      return (_sqlite3_value_int = Module["_sqlite3_value_int"] = Module["asm"]["sqlite3_value_int"]).apply(null, arguments);
    };
    var _sqlite3_value_int64 = Module["_sqlite3_value_int64"] = function() {
      return (_sqlite3_value_int64 = Module["_sqlite3_value_int64"] = Module["asm"]["sqlite3_value_int64"]).apply(null, arguments);
    };
    var _sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = function() {
      return (_sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = Module["asm"]["sqlite3_value_subtype"]).apply(null, arguments);
    };
    var _sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = function() {
      return (_sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = Module["asm"]["sqlite3_value_pointer"]).apply(null, arguments);
    };
    var _sqlite3_value_type = Module["_sqlite3_value_type"] = function() {
      return (_sqlite3_value_type = Module["_sqlite3_value_type"] = Module["asm"]["sqlite3_value_type"]).apply(null, arguments);
    };
    var _sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = function() {
      return (_sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = Module["asm"]["sqlite3_value_nochange"]).apply(null, arguments);
    };
    var _sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = function() {
      return (_sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = Module["asm"]["sqlite3_value_frombind"]).apply(null, arguments);
    };
    var _sqlite3_value_dup = Module["_sqlite3_value_dup"] = function() {
      return (_sqlite3_value_dup = Module["_sqlite3_value_dup"] = Module["asm"]["sqlite3_value_dup"]).apply(null, arguments);
    };
    var _sqlite3_value_free = Module["_sqlite3_value_free"] = function() {
      return (_sqlite3_value_free = Module["_sqlite3_value_free"] = Module["asm"]["sqlite3_value_free"]).apply(null, arguments);
    };
    var _sqlite3_result_blob = Module["_sqlite3_result_blob"] = function() {
      return (_sqlite3_result_blob = Module["_sqlite3_result_blob"] = Module["asm"]["sqlite3_result_blob"]).apply(null, arguments);
    };
    var _sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = function() {
      return (_sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = Module["asm"]["sqlite3_result_error_toobig"]).apply(null, arguments);
    };
    var _sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = function() {
      return (_sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = Module["asm"]["sqlite3_result_error_nomem"]).apply(null, arguments);
    };
    var _sqlite3_result_double = Module["_sqlite3_result_double"] = function() {
      return (_sqlite3_result_double = Module["_sqlite3_result_double"] = Module["asm"]["sqlite3_result_double"]).apply(null, arguments);
    };
    var _sqlite3_result_error = Module["_sqlite3_result_error"] = function() {
      return (_sqlite3_result_error = Module["_sqlite3_result_error"] = Module["asm"]["sqlite3_result_error"]).apply(null, arguments);
    };
    var _sqlite3_result_int = Module["_sqlite3_result_int"] = function() {
      return (_sqlite3_result_int = Module["_sqlite3_result_int"] = Module["asm"]["sqlite3_result_int"]).apply(null, arguments);
    };
    var _sqlite3_result_int64 = Module["_sqlite3_result_int64"] = function() {
      return (_sqlite3_result_int64 = Module["_sqlite3_result_int64"] = Module["asm"]["sqlite3_result_int64"]).apply(null, arguments);
    };
    var _sqlite3_result_null = Module["_sqlite3_result_null"] = function() {
      return (_sqlite3_result_null = Module["_sqlite3_result_null"] = Module["asm"]["sqlite3_result_null"]).apply(null, arguments);
    };
    var _sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = function() {
      return (_sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = Module["asm"]["sqlite3_result_pointer"]).apply(null, arguments);
    };
    var _sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = function() {
      return (_sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = Module["asm"]["sqlite3_result_subtype"]).apply(null, arguments);
    };
    var _sqlite3_result_text = Module["_sqlite3_result_text"] = function() {
      return (_sqlite3_result_text = Module["_sqlite3_result_text"] = Module["asm"]["sqlite3_result_text"]).apply(null, arguments);
    };
    var _sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = function() {
      return (_sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = Module["asm"]["sqlite3_result_zeroblob"]).apply(null, arguments);
    };
    var _sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = function() {
      return (_sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = Module["asm"]["sqlite3_result_zeroblob64"]).apply(null, arguments);
    };
    var _sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = function() {
      return (_sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = Module["asm"]["sqlite3_result_error_code"]).apply(null, arguments);
    };
    var _sqlite3_user_data = Module["_sqlite3_user_data"] = function() {
      return (_sqlite3_user_data = Module["_sqlite3_user_data"] = Module["asm"]["sqlite3_user_data"]).apply(null, arguments);
    };
    var _sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = function() {
      return (_sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = Module["asm"]["sqlite3_context_db_handle"]).apply(null, arguments);
    };
    var _sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = function() {
      return (_sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = Module["asm"]["sqlite3_vtab_nochange"]).apply(null, arguments);
    };
    var _sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = function() {
      return (_sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = Module["asm"]["sqlite3_vtab_in_first"]).apply(null, arguments);
    };
    var _sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = function() {
      return (_sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = Module["asm"]["sqlite3_vtab_in_next"]).apply(null, arguments);
    };
    var _sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = function() {
      return (_sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = Module["asm"]["sqlite3_aggregate_context"]).apply(null, arguments);
    };
    var _sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = function() {
      return (_sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = Module["asm"]["sqlite3_get_auxdata"]).apply(null, arguments);
    };
    var _sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = function() {
      return (_sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = Module["asm"]["sqlite3_set_auxdata"]).apply(null, arguments);
    };
    var _sqlite3_column_count = Module["_sqlite3_column_count"] = function() {
      return (_sqlite3_column_count = Module["_sqlite3_column_count"] = Module["asm"]["sqlite3_column_count"]).apply(null, arguments);
    };
    var _sqlite3_data_count = Module["_sqlite3_data_count"] = function() {
      return (_sqlite3_data_count = Module["_sqlite3_data_count"] = Module["asm"]["sqlite3_data_count"]).apply(null, arguments);
    };
    var _sqlite3_column_blob = Module["_sqlite3_column_blob"] = function() {
      return (_sqlite3_column_blob = Module["_sqlite3_column_blob"] = Module["asm"]["sqlite3_column_blob"]).apply(null, arguments);
    };
    var _sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = function() {
      return (_sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = Module["asm"]["sqlite3_column_bytes"]).apply(null, arguments);
    };
    var _sqlite3_column_double = Module["_sqlite3_column_double"] = function() {
      return (_sqlite3_column_double = Module["_sqlite3_column_double"] = Module["asm"]["sqlite3_column_double"]).apply(null, arguments);
    };
    var _sqlite3_column_value = Module["_sqlite3_column_value"] = function() {
      return (_sqlite3_column_value = Module["_sqlite3_column_value"] = Module["asm"]["sqlite3_column_value"]).apply(null, arguments);
    };
    var _sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = function() {
      return (_sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = Module["asm"]["sqlite3_bind_blob"]).apply(null, arguments);
    };
    var _sqlite3_bind_double = Module["_sqlite3_bind_double"] = function() {
      return (_sqlite3_bind_double = Module["_sqlite3_bind_double"] = Module["asm"]["sqlite3_bind_double"]).apply(null, arguments);
    };
    var _sqlite3_bind_int = Module["_sqlite3_bind_int"] = function() {
      return (_sqlite3_bind_int = Module["_sqlite3_bind_int"] = Module["asm"]["sqlite3_bind_int"]).apply(null, arguments);
    };
    var _sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = function() {
      return (_sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = Module["asm"]["sqlite3_bind_int64"]).apply(null, arguments);
    };
    var _sqlite3_bind_null = Module["_sqlite3_bind_null"] = function() {
      return (_sqlite3_bind_null = Module["_sqlite3_bind_null"] = Module["asm"]["sqlite3_bind_null"]).apply(null, arguments);
    };
    var _sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = function() {
      return (_sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = Module["asm"]["sqlite3_bind_pointer"]).apply(null, arguments);
    };
    var _sqlite3_bind_text = Module["_sqlite3_bind_text"] = function() {
      return (_sqlite3_bind_text = Module["_sqlite3_bind_text"] = Module["asm"]["sqlite3_bind_text"]).apply(null, arguments);
    };
    var _sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = function() {
      return (_sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = Module["asm"]["sqlite3_bind_parameter_count"]).apply(null, arguments);
    };
    var _sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = function() {
      return (_sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = Module["asm"]["sqlite3_bind_parameter_index"]).apply(null, arguments);
    };
    var _sqlite3_db_handle = Module["_sqlite3_db_handle"] = function() {
      return (_sqlite3_db_handle = Module["_sqlite3_db_handle"] = Module["asm"]["sqlite3_db_handle"]).apply(null, arguments);
    };
    var _sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = function() {
      return (_sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = Module["asm"]["sqlite3_stmt_readonly"]).apply(null, arguments);
    };
    var _sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = function() {
      return (_sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = Module["asm"]["sqlite3_stmt_isexplain"]).apply(null, arguments);
    };
    var _sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = function() {
      return (_sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = Module["asm"]["sqlite3_stmt_status"]).apply(null, arguments);
    };
    var _sqlite3_sql = Module["_sqlite3_sql"] = function() {
      return (_sqlite3_sql = Module["_sqlite3_sql"] = Module["asm"]["sqlite3_sql"]).apply(null, arguments);
    };
    var _sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = function() {
      return (_sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = Module["asm"]["sqlite3_expanded_sql"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = function() {
      return (_sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = Module["asm"]["sqlite3_preupdate_old"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = function() {
      return (_sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = Module["asm"]["sqlite3_preupdate_count"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = function() {
      return (_sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = Module["asm"]["sqlite3_preupdate_depth"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = function() {
      return (_sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = Module["asm"]["sqlite3_preupdate_blobwrite"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = function() {
      return (_sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = Module["asm"]["sqlite3_preupdate_new"]).apply(null, arguments);
    };
    var _sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = function() {
      return (_sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = Module["asm"]["sqlite3_value_numeric_type"]).apply(null, arguments);
    };
    var _sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = function() {
      return (_sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = Module["asm"]["sqlite3_set_authorizer"]).apply(null, arguments);
    };
    var _sqlite3_strglob = Module["_sqlite3_strglob"] = function() {
      return (_sqlite3_strglob = Module["_sqlite3_strglob"] = Module["asm"]["sqlite3_strglob"]).apply(null, arguments);
    };
    var _sqlite3_strlike = Module["_sqlite3_strlike"] = function() {
      return (_sqlite3_strlike = Module["_sqlite3_strlike"] = Module["asm"]["sqlite3_strlike"]).apply(null, arguments);
    };
    var _sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = function() {
      return (_sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = Module["asm"]["sqlite3_auto_extension"]).apply(null, arguments);
    };
    var _sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = function() {
      return (_sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = Module["asm"]["sqlite3_cancel_auto_extension"]).apply(null, arguments);
    };
    var _sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = function() {
      return (_sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = Module["asm"]["sqlite3_reset_auto_extension"]).apply(null, arguments);
    };
    var _sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = function() {
      return (_sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = Module["asm"]["sqlite3_prepare_v3"]).apply(null, arguments);
    };
    var _sqlite3_create_module = Module["_sqlite3_create_module"] = function() {
      return (_sqlite3_create_module = Module["_sqlite3_create_module"] = Module["asm"]["sqlite3_create_module"]).apply(null, arguments);
    };
    var _sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = function() {
      return (_sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = Module["asm"]["sqlite3_create_module_v2"]).apply(null, arguments);
    };
    var _sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = function() {
      return (_sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = Module["asm"]["sqlite3_drop_modules"]).apply(null, arguments);
    };
    var _sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = function() {
      return (_sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = Module["asm"]["sqlite3_declare_vtab"]).apply(null, arguments);
    };
    var _sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = function() {
      return (_sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = Module["asm"]["sqlite3_vtab_on_conflict"]).apply(null, arguments);
    };
    var _sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = function() {
      return (_sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = Module["asm"]["sqlite3_vtab_collation"]).apply(null, arguments);
    };
    var _sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = function() {
      return (_sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = Module["asm"]["sqlite3_vtab_in"]).apply(null, arguments);
    };
    var _sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = function() {
      return (_sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = Module["asm"]["sqlite3_vtab_rhs_value"]).apply(null, arguments);
    };
    var _sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = function() {
      return (_sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = Module["asm"]["sqlite3_vtab_distinct"]).apply(null, arguments);
    };
    var _sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = function() {
      return (_sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = Module["asm"]["sqlite3_keyword_name"]).apply(null, arguments);
    };
    var _sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = function() {
      return (_sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = Module["asm"]["sqlite3_keyword_count"]).apply(null, arguments);
    };
    var _sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = function() {
      return (_sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = Module["asm"]["sqlite3_keyword_check"]).apply(null, arguments);
    };
    var _sqlite3_complete = Module["_sqlite3_complete"] = function() {
      return (_sqlite3_complete = Module["_sqlite3_complete"] = Module["asm"]["sqlite3_complete"]).apply(null, arguments);
    };
    var _sqlite3_libversion = Module["_sqlite3_libversion"] = function() {
      return (_sqlite3_libversion = Module["_sqlite3_libversion"] = Module["asm"]["sqlite3_libversion"]).apply(null, arguments);
    };
    var _sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = function() {
      return (_sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = Module["asm"]["sqlite3_libversion_number"]).apply(null, arguments);
    };
    var _sqlite3_shutdown = Module["_sqlite3_shutdown"] = function() {
      return (_sqlite3_shutdown = Module["_sqlite3_shutdown"] = Module["asm"]["sqlite3_shutdown"]).apply(null, arguments);
    };
    var _sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = function() {
      return (_sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = Module["asm"]["sqlite3_last_insert_rowid"]).apply(null, arguments);
    };
    var _sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = function() {
      return (_sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = Module["asm"]["sqlite3_set_last_insert_rowid"]).apply(null, arguments);
    };
    var _sqlite3_changes64 = Module["_sqlite3_changes64"] = function() {
      return (_sqlite3_changes64 = Module["_sqlite3_changes64"] = Module["asm"]["sqlite3_changes64"]).apply(null, arguments);
    };
    var _sqlite3_changes = Module["_sqlite3_changes"] = function() {
      return (_sqlite3_changes = Module["_sqlite3_changes"] = Module["asm"]["sqlite3_changes"]).apply(null, arguments);
    };
    var _sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = function() {
      return (_sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = Module["asm"]["sqlite3_total_changes64"]).apply(null, arguments);
    };
    var _sqlite3_total_changes = Module["_sqlite3_total_changes"] = function() {
      return (_sqlite3_total_changes = Module["_sqlite3_total_changes"] = Module["asm"]["sqlite3_total_changes"]).apply(null, arguments);
    };
    var _sqlite3_txn_state = Module["_sqlite3_txn_state"] = function() {
      return (_sqlite3_txn_state = Module["_sqlite3_txn_state"] = Module["asm"]["sqlite3_txn_state"]).apply(null, arguments);
    };
    var _sqlite3_close_v2 = Module["_sqlite3_close_v2"] = function() {
      return (_sqlite3_close_v2 = Module["_sqlite3_close_v2"] = Module["asm"]["sqlite3_close_v2"]).apply(null, arguments);
    };
    var _sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = function() {
      return (_sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = Module["asm"]["sqlite3_busy_handler"]).apply(null, arguments);
    };
    var _sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = function() {
      return (_sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = Module["asm"]["sqlite3_progress_handler"]).apply(null, arguments);
    };
    var _sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = function() {
      return (_sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = Module["asm"]["sqlite3_busy_timeout"]).apply(null, arguments);
    };
    var _sqlite3_create_function = Module["_sqlite3_create_function"] = function() {
      return (_sqlite3_create_function = Module["_sqlite3_create_function"] = Module["asm"]["sqlite3_create_function"]).apply(null, arguments);
    };
    var _sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = function() {
      return (_sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = Module["asm"]["sqlite3_create_function_v2"]).apply(null, arguments);
    };
    var _sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = function() {
      return (_sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = Module["asm"]["sqlite3_create_window_function"]).apply(null, arguments);
    };
    var _sqlite3_overload_function = Module["_sqlite3_overload_function"] = function() {
      return (_sqlite3_overload_function = Module["_sqlite3_overload_function"] = Module["asm"]["sqlite3_overload_function"]).apply(null, arguments);
    };
    var _sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = function() {
      return (_sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = Module["asm"]["sqlite3_trace_v2"]).apply(null, arguments);
    };
    var _sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = function() {
      return (_sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = Module["asm"]["sqlite3_commit_hook"]).apply(null, arguments);
    };
    var _sqlite3_update_hook = Module["_sqlite3_update_hook"] = function() {
      return (_sqlite3_update_hook = Module["_sqlite3_update_hook"] = Module["asm"]["sqlite3_update_hook"]).apply(null, arguments);
    };
    var _sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = function() {
      return (_sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = Module["asm"]["sqlite3_rollback_hook"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = function() {
      return (_sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = Module["asm"]["sqlite3_preupdate_hook"]).apply(null, arguments);
    };
    var _sqlite3_error_offset = Module["_sqlite3_error_offset"] = function() {
      return (_sqlite3_error_offset = Module["_sqlite3_error_offset"] = Module["asm"]["sqlite3_error_offset"]).apply(null, arguments);
    };
    var _sqlite3_errcode = Module["_sqlite3_errcode"] = function() {
      return (_sqlite3_errcode = Module["_sqlite3_errcode"] = Module["asm"]["sqlite3_errcode"]).apply(null, arguments);
    };
    var _sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = function() {
      return (_sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = Module["asm"]["sqlite3_extended_errcode"]).apply(null, arguments);
    };
    var _sqlite3_errstr = Module["_sqlite3_errstr"] = function() {
      return (_sqlite3_errstr = Module["_sqlite3_errstr"] = Module["asm"]["sqlite3_errstr"]).apply(null, arguments);
    };
    var _sqlite3_limit = Module["_sqlite3_limit"] = function() {
      return (_sqlite3_limit = Module["_sqlite3_limit"] = Module["asm"]["sqlite3_limit"]).apply(null, arguments);
    };
    var _sqlite3_open = Module["_sqlite3_open"] = function() {
      return (_sqlite3_open = Module["_sqlite3_open"] = Module["asm"]["sqlite3_open"]).apply(null, arguments);
    };
    var _sqlite3_open_v2 = Module["_sqlite3_open_v2"] = function() {
      return (_sqlite3_open_v2 = Module["_sqlite3_open_v2"] = Module["asm"]["sqlite3_open_v2"]).apply(null, arguments);
    };
    var _sqlite3_create_collation = Module["_sqlite3_create_collation"] = function() {
      return (_sqlite3_create_collation = Module["_sqlite3_create_collation"] = Module["asm"]["sqlite3_create_collation"]).apply(null, arguments);
    };
    var _sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = function() {
      return (_sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = Module["asm"]["sqlite3_create_collation_v2"]).apply(null, arguments);
    };
    var _sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = function() {
      return (_sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = Module["asm"]["sqlite3_collation_needed"]).apply(null, arguments);
    };
    var _sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = function() {
      return (_sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = Module["asm"]["sqlite3_get_autocommit"]).apply(null, arguments);
    };
    var _sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = function() {
      return (_sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = Module["asm"]["sqlite3_table_column_metadata"]).apply(null, arguments);
    };
    var _sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = function() {
      return (_sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = Module["asm"]["sqlite3_extended_result_codes"]).apply(null, arguments);
    };
    var _sqlite3_uri_key = Module["_sqlite3_uri_key"] = function() {
      return (_sqlite3_uri_key = Module["_sqlite3_uri_key"] = Module["asm"]["sqlite3_uri_key"]).apply(null, arguments);
    };
    var _sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = function() {
      return (_sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = Module["asm"]["sqlite3_uri_int64"]).apply(null, arguments);
    };
    var _sqlite3_db_name = Module["_sqlite3_db_name"] = function() {
      return (_sqlite3_db_name = Module["_sqlite3_db_name"] = Module["asm"]["sqlite3_db_name"]).apply(null, arguments);
    };
    var _sqlite3_db_filename = Module["_sqlite3_db_filename"] = function() {
      return (_sqlite3_db_filename = Module["_sqlite3_db_filename"] = Module["asm"]["sqlite3_db_filename"]).apply(null, arguments);
    };
    var _sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = function() {
      return (_sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = Module["asm"]["sqlite3_compileoption_used"]).apply(null, arguments);
    };
    var _sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = function() {
      return (_sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = Module["asm"]["sqlite3_compileoption_get"]).apply(null, arguments);
    };
    var _sqlite3session_diff = Module["_sqlite3session_diff"] = function() {
      return (_sqlite3session_diff = Module["_sqlite3session_diff"] = Module["asm"]["sqlite3session_diff"]).apply(null, arguments);
    };
    var _sqlite3session_attach = Module["_sqlite3session_attach"] = function() {
      return (_sqlite3session_attach = Module["_sqlite3session_attach"] = Module["asm"]["sqlite3session_attach"]).apply(null, arguments);
    };
    var _sqlite3session_create = Module["_sqlite3session_create"] = function() {
      return (_sqlite3session_create = Module["_sqlite3session_create"] = Module["asm"]["sqlite3session_create"]).apply(null, arguments);
    };
    var _sqlite3session_delete = Module["_sqlite3session_delete"] = function() {
      return (_sqlite3session_delete = Module["_sqlite3session_delete"] = Module["asm"]["sqlite3session_delete"]).apply(null, arguments);
    };
    var _sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = function() {
      return (_sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = Module["asm"]["sqlite3session_table_filter"]).apply(null, arguments);
    };
    var _sqlite3session_changeset = Module["_sqlite3session_changeset"] = function() {
      return (_sqlite3session_changeset = Module["_sqlite3session_changeset"] = Module["asm"]["sqlite3session_changeset"]).apply(null, arguments);
    };
    var _sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = function() {
      return (_sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = Module["asm"]["sqlite3session_changeset_strm"]).apply(null, arguments);
    };
    var _sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = function() {
      return (_sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = Module["asm"]["sqlite3session_patchset_strm"]).apply(null, arguments);
    };
    var _sqlite3session_patchset = Module["_sqlite3session_patchset"] = function() {
      return (_sqlite3session_patchset = Module["_sqlite3session_patchset"] = Module["asm"]["sqlite3session_patchset"]).apply(null, arguments);
    };
    var _sqlite3session_enable = Module["_sqlite3session_enable"] = function() {
      return (_sqlite3session_enable = Module["_sqlite3session_enable"] = Module["asm"]["sqlite3session_enable"]).apply(null, arguments);
    };
    var _sqlite3session_indirect = Module["_sqlite3session_indirect"] = function() {
      return (_sqlite3session_indirect = Module["_sqlite3session_indirect"] = Module["asm"]["sqlite3session_indirect"]).apply(null, arguments);
    };
    var _sqlite3session_isempty = Module["_sqlite3session_isempty"] = function() {
      return (_sqlite3session_isempty = Module["_sqlite3session_isempty"] = Module["asm"]["sqlite3session_isempty"]).apply(null, arguments);
    };
    var _sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = function() {
      return (_sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = Module["asm"]["sqlite3session_memory_used"]).apply(null, arguments);
    };
    var _sqlite3session_object_config = Module["_sqlite3session_object_config"] = function() {
      return (_sqlite3session_object_config = Module["_sqlite3session_object_config"] = Module["asm"]["sqlite3session_object_config"]).apply(null, arguments);
    };
    var _sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = function() {
      return (_sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = Module["asm"]["sqlite3session_changeset_size"]).apply(null, arguments);
    };
    var _sqlite3changeset_start = Module["_sqlite3changeset_start"] = function() {
      return (_sqlite3changeset_start = Module["_sqlite3changeset_start"] = Module["asm"]["sqlite3changeset_start"]).apply(null, arguments);
    };
    var _sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = function() {
      return (_sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = Module["asm"]["sqlite3changeset_start_v2"]).apply(null, arguments);
    };
    var _sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = function() {
      return (_sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = Module["asm"]["sqlite3changeset_start_strm"]).apply(null, arguments);
    };
    var _sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = function() {
      return (_sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = Module["asm"]["sqlite3changeset_start_v2_strm"]).apply(null, arguments);
    };
    var _sqlite3changeset_next = Module["_sqlite3changeset_next"] = function() {
      return (_sqlite3changeset_next = Module["_sqlite3changeset_next"] = Module["asm"]["sqlite3changeset_next"]).apply(null, arguments);
    };
    var _sqlite3changeset_op = Module["_sqlite3changeset_op"] = function() {
      return (_sqlite3changeset_op = Module["_sqlite3changeset_op"] = Module["asm"]["sqlite3changeset_op"]).apply(null, arguments);
    };
    var _sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = function() {
      return (_sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = Module["asm"]["sqlite3changeset_pk"]).apply(null, arguments);
    };
    var _sqlite3changeset_old = Module["_sqlite3changeset_old"] = function() {
      return (_sqlite3changeset_old = Module["_sqlite3changeset_old"] = Module["asm"]["sqlite3changeset_old"]).apply(null, arguments);
    };
    var _sqlite3changeset_new = Module["_sqlite3changeset_new"] = function() {
      return (_sqlite3changeset_new = Module["_sqlite3changeset_new"] = Module["asm"]["sqlite3changeset_new"]).apply(null, arguments);
    };
    var _sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = function() {
      return (_sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = Module["asm"]["sqlite3changeset_conflict"]).apply(null, arguments);
    };
    var _sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = function() {
      return (_sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = Module["asm"]["sqlite3changeset_fk_conflicts"]).apply(null, arguments);
    };
    var _sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = function() {
      return (_sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = Module["asm"]["sqlite3changeset_finalize"]).apply(null, arguments);
    };
    var _sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = function() {
      return (_sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = Module["asm"]["sqlite3changeset_invert"]).apply(null, arguments);
    };
    var _sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = function() {
      return (_sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = Module["asm"]["sqlite3changeset_invert_strm"]).apply(null, arguments);
    };
    var _sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = function() {
      return (_sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = Module["asm"]["sqlite3changeset_apply_v2"]).apply(null, arguments);
    };
    var _sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = function() {
      return (_sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = Module["asm"]["sqlite3changeset_apply"]).apply(null, arguments);
    };
    var _sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = function() {
      return (_sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = Module["asm"]["sqlite3changeset_apply_v2_strm"]).apply(null, arguments);
    };
    var _sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = function() {
      return (_sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = Module["asm"]["sqlite3changeset_apply_strm"]).apply(null, arguments);
    };
    var _sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = function() {
      return (_sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = Module["asm"]["sqlite3changegroup_new"]).apply(null, arguments);
    };
    var _sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = function() {
      return (_sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = Module["asm"]["sqlite3changegroup_add"]).apply(null, arguments);
    };
    var _sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = function() {
      return (_sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = Module["asm"]["sqlite3changegroup_output"]).apply(null, arguments);
    };
    var _sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = function() {
      return (_sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = Module["asm"]["sqlite3changegroup_add_strm"]).apply(null, arguments);
    };
    var _sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = function() {
      return (_sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = Module["asm"]["sqlite3changegroup_output_strm"]).apply(null, arguments);
    };
    var _sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = function() {
      return (_sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = Module["asm"]["sqlite3changegroup_delete"]).apply(null, arguments);
    };
    var _sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = function() {
      return (_sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = Module["asm"]["sqlite3changeset_concat"]).apply(null, arguments);
    };
    var _sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = function() {
      return (_sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = Module["asm"]["sqlite3changeset_concat_strm"]).apply(null, arguments);
    };
    var _sqlite3session_config = Module["_sqlite3session_config"] = function() {
      return (_sqlite3session_config = Module["_sqlite3session_config"] = Module["asm"]["sqlite3session_config"]).apply(null, arguments);
    };
    var _sqlite3_sourceid = Module["_sqlite3_sourceid"] = function() {
      return (_sqlite3_sourceid = Module["_sqlite3_sourceid"] = Module["asm"]["sqlite3_sourceid"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_ptr = Module["_sqlite3__wasm_pstack_ptr"] = function() {
      return (_sqlite3__wasm_pstack_ptr = Module["_sqlite3__wasm_pstack_ptr"] = Module["asm"]["sqlite3__wasm_pstack_ptr"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_restore = Module["_sqlite3__wasm_pstack_restore"] = function() {
      return (_sqlite3__wasm_pstack_restore = Module["_sqlite3__wasm_pstack_restore"] = Module["asm"]["sqlite3__wasm_pstack_restore"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_alloc = Module["_sqlite3__wasm_pstack_alloc"] = function() {
      return (_sqlite3__wasm_pstack_alloc = Module["_sqlite3__wasm_pstack_alloc"] = Module["asm"]["sqlite3__wasm_pstack_alloc"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_remaining = Module["_sqlite3__wasm_pstack_remaining"] = function() {
      return (_sqlite3__wasm_pstack_remaining = Module["_sqlite3__wasm_pstack_remaining"] = Module["asm"]["sqlite3__wasm_pstack_remaining"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_quota = Module["_sqlite3__wasm_pstack_quota"] = function() {
      return (_sqlite3__wasm_pstack_quota = Module["_sqlite3__wasm_pstack_quota"] = Module["asm"]["sqlite3__wasm_pstack_quota"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_error = Module["_sqlite3__wasm_db_error"] = function() {
      return (_sqlite3__wasm_db_error = Module["_sqlite3__wasm_db_error"] = Module["asm"]["sqlite3__wasm_db_error"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_struct = Module["_sqlite3__wasm_test_struct"] = function() {
      return (_sqlite3__wasm_test_struct = Module["_sqlite3__wasm_test_struct"] = Module["asm"]["sqlite3__wasm_test_struct"]).apply(null, arguments);
    };
    var _sqlite3__wasm_enum_json = Module["_sqlite3__wasm_enum_json"] = function() {
      return (_sqlite3__wasm_enum_json = Module["_sqlite3__wasm_enum_json"] = Module["asm"]["sqlite3__wasm_enum_json"]).apply(null, arguments);
    };
    var _sqlite3__wasm_vfs_unlink = Module["_sqlite3__wasm_vfs_unlink"] = function() {
      return (_sqlite3__wasm_vfs_unlink = Module["_sqlite3__wasm_vfs_unlink"] = Module["asm"]["sqlite3__wasm_vfs_unlink"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_vfs = Module["_sqlite3__wasm_db_vfs"] = function() {
      return (_sqlite3__wasm_db_vfs = Module["_sqlite3__wasm_db_vfs"] = Module["asm"]["sqlite3__wasm_db_vfs"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_reset = Module["_sqlite3__wasm_db_reset"] = function() {
      return (_sqlite3__wasm_db_reset = Module["_sqlite3__wasm_db_reset"] = Module["asm"]["sqlite3__wasm_db_reset"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_export_chunked = Module["_sqlite3__wasm_db_export_chunked"] = function() {
      return (_sqlite3__wasm_db_export_chunked = Module["_sqlite3__wasm_db_export_chunked"] = Module["asm"]["sqlite3__wasm_db_export_chunked"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_db_serialize = Module["_sqlite3__wasm_db_serialize"] = function() {
      return (_sqlite3__wasm_db_serialize = Module["_sqlite3__wasm_db_serialize"] = Module["asm"]["sqlite3__wasm_db_serialize"]).apply(null, arguments);
    };
    var _sqlite3__wasm_vfs_create_file = Module["_sqlite3__wasm_vfs_create_file"] = function() {
      return (_sqlite3__wasm_vfs_create_file = Module["_sqlite3__wasm_vfs_create_file"] = Module["asm"]["sqlite3__wasm_vfs_create_file"]).apply(null, arguments);
    };
    var _sqlite3__wasm_posix_create_file = Module["_sqlite3__wasm_posix_create_file"] = function() {
      return (_sqlite3__wasm_posix_create_file = Module["_sqlite3__wasm_posix_create_file"] = Module["asm"]["sqlite3__wasm_posix_create_file"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = function() {
      return (_sqlite3__wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = Module["asm"]["sqlite3__wasm_kvvfsMakeKeyOnPstack"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_kvvfs_methods = Module["_sqlite3__wasm_kvvfs_methods"] = function() {
      return (_sqlite3__wasm_kvvfs_methods = Module["_sqlite3__wasm_kvvfs_methods"] = Module["asm"]["sqlite3__wasm_kvvfs_methods"]).apply(null, arguments);
    };
    var _sqlite3__wasm_vtab_config = Module["_sqlite3__wasm_vtab_config"] = function() {
      return (_sqlite3__wasm_vtab_config = Module["_sqlite3__wasm_vtab_config"] = Module["asm"]["sqlite3__wasm_vtab_config"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_config_ip = Module["_sqlite3__wasm_db_config_ip"] = function() {
      return (_sqlite3__wasm_db_config_ip = Module["_sqlite3__wasm_db_config_ip"] = Module["asm"]["sqlite3__wasm_db_config_ip"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_config_pii = Module["_sqlite3__wasm_db_config_pii"] = function() {
      return (_sqlite3__wasm_db_config_pii = Module["_sqlite3__wasm_db_config_pii"] = Module["asm"]["sqlite3__wasm_db_config_pii"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_config_s = Module["_sqlite3__wasm_db_config_s"] = function() {
      return (_sqlite3__wasm_db_config_s = Module["_sqlite3__wasm_db_config_s"] = Module["asm"]["sqlite3__wasm_db_config_s"]).apply(null, arguments);
    };
    var _sqlite3__wasm_config_i = Module["_sqlite3__wasm_config_i"] = function() {
      return (_sqlite3__wasm_config_i = Module["_sqlite3__wasm_config_i"] = Module["asm"]["sqlite3__wasm_config_i"]).apply(null, arguments);
    };
    var _sqlite3__wasm_config_ii = Module["_sqlite3__wasm_config_ii"] = function() {
      return (_sqlite3__wasm_config_ii = Module["_sqlite3__wasm_config_ii"] = Module["asm"]["sqlite3__wasm_config_ii"]).apply(null, arguments);
    };
    var _sqlite3__wasm_config_j = Module["_sqlite3__wasm_config_j"] = function() {
      return (_sqlite3__wasm_config_j = Module["_sqlite3__wasm_config_j"] = Module["asm"]["sqlite3__wasm_config_j"]).apply(null, arguments);
    };
    var _sqlite3__wasm_qfmt_token = Module["_sqlite3__wasm_qfmt_token"] = function() {
      return (_sqlite3__wasm_qfmt_token = Module["_sqlite3__wasm_qfmt_token"] = Module["asm"]["sqlite3__wasm_qfmt_token"]).apply(null, arguments);
    };
    var _sqlite3__wasm_init_wasmfs = Module["_sqlite3__wasm_init_wasmfs"] = function() {
      return (_sqlite3__wasm_init_wasmfs = Module["_sqlite3__wasm_init_wasmfs"] = Module["asm"]["sqlite3__wasm_init_wasmfs"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_intptr = Module["_sqlite3__wasm_test_intptr"] = function() {
      return (_sqlite3__wasm_test_intptr = Module["_sqlite3__wasm_test_intptr"] = Module["asm"]["sqlite3__wasm_test_intptr"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_voidptr = Module["_sqlite3__wasm_test_voidptr"] = function() {
      return (_sqlite3__wasm_test_voidptr = Module["_sqlite3__wasm_test_voidptr"] = Module["asm"]["sqlite3__wasm_test_voidptr"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_int64_max = Module["_sqlite3__wasm_test_int64_max"] = function() {
      return (_sqlite3__wasm_test_int64_max = Module["_sqlite3__wasm_test_int64_max"] = Module["asm"]["sqlite3__wasm_test_int64_max"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_int64_min = Module["_sqlite3__wasm_test_int64_min"] = function() {
      return (_sqlite3__wasm_test_int64_min = Module["_sqlite3__wasm_test_int64_min"] = Module["asm"]["sqlite3__wasm_test_int64_min"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_int64_times2 = Module["_sqlite3__wasm_test_int64_times2"] = function() {
      return (_sqlite3__wasm_test_int64_times2 = Module["_sqlite3__wasm_test_int64_times2"] = Module["asm"]["sqlite3__wasm_test_int64_times2"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_test_int64_minmax = Module["_sqlite3__wasm_test_int64_minmax"] = function() {
      return (_sqlite3__wasm_test_int64_minmax = Module["_sqlite3__wasm_test_int64_minmax"] = Module["asm"]["sqlite3__wasm_test_int64_minmax"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_test_int64ptr = Module["_sqlite3__wasm_test_int64ptr"] = function() {
      return (_sqlite3__wasm_test_int64ptr = Module["_sqlite3__wasm_test_int64ptr"] = Module["asm"]["sqlite3__wasm_test_int64ptr"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_stack_overflow = Module["_sqlite3__wasm_test_stack_overflow"] = function() {
      return (_sqlite3__wasm_test_stack_overflow = Module["_sqlite3__wasm_test_stack_overflow"] = Module["asm"]["sqlite3__wasm_test_stack_overflow"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_test_str_hello = Module["_sqlite3__wasm_test_str_hello"] = function() {
      return (_sqlite3__wasm_test_str_hello = Module["_sqlite3__wasm_test_str_hello"] = Module["asm"]["sqlite3__wasm_test_str_hello"]).apply(null, arguments);
    };
    var _sqlite3__wasm_SQLTester_strglob = Module["_sqlite3__wasm_SQLTester_strglob"] = function() {
      return (_sqlite3__wasm_SQLTester_strglob = Module["_sqlite3__wasm_SQLTester_strglob"] = Module["asm"]["sqlite3__wasm_SQLTester_strglob"]).apply(
        null,
        arguments
      );
    };
    var _malloc = Module["_malloc"] = function() {
      return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(
        null,
        arguments
      );
    };
    var _free = Module["_free"] = function() {
      return (_free = Module["_free"] = Module["asm"]["free"]).apply(
        null,
        arguments
      );
    };
    var _realloc = Module["_realloc"] = function() {
      return (_realloc = Module["_realloc"] = Module["asm"]["realloc"]).apply(
        null,
        arguments
      );
    };
    var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
      return (_emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = Module["asm"]["emscripten_builtin_memalign"]).apply(null, arguments);
    };
    var stackSave = Module["stackSave"] = function() {
      return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
    };
    var stackRestore = Module["stackRestore"] = function() {
      return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
    };
    var stackAlloc = Module["stackAlloc"] = function() {
      return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
    };
    Module["wasmMemory"] = wasmMemory;
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function run(args) {
      args = args || arguments_;
      if (runDependencies > 0) {
        return;
      }
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun)
          return;
        calledRun = true;
        Module["calledRun"] = true;
        if (ABORT)
          return;
        initRuntime();
        readyPromiseResolve(Module);
        if (Module["onRuntimeInitialized"])
          Module["onRuntimeInitialized"]();
        postRun();
      }
      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(function() {
          setTimeout(function() {
            Module["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function")
        Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }
    run();
    if (!Module.postRun)
      Module.postRun = [];
    Module.postRun.push(function(Module2) {
      "use strict";
      "use strict";
      globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(apiConfig = globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig) {
        if (sqlite3ApiBootstrap.sqlite3) {
          (sqlite3ApiBootstrap.sqlite3.config || console).warn(
            "sqlite3ApiBootstrap() called multiple times.",
            "Config and external initializers are ignored on calls after the first."
          );
          return sqlite3ApiBootstrap.sqlite3;
        }
        const config2 = Object.assign(
          /* @__PURE__ */ Object.create(null),
          {
            exports: void 0,
            memory: void 0,
            bigIntEnabled: (() => {
              if ("undefined" !== typeof Module2) {
                if (!!Module2.HEAPU64)
                  return true;
              }
              return !!globalThis.BigInt64Array;
            })(),
            debug: console.debug.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console),
            log: console.log.bind(console),
            wasmfsOpfsDir: "/opfs",
            useStdAlloc: false
          },
          apiConfig || {}
        );
        Object.assign(
          config2,
          {
            allocExportName: config2.useStdAlloc ? "malloc" : "sqlite3_malloc",
            deallocExportName: config2.useStdAlloc ? "free" : "sqlite3_free",
            reallocExportName: config2.useStdAlloc ? "realloc" : "sqlite3_realloc"
          },
          config2
        );
        ["exports", "memory", "wasmfsOpfsDir"].forEach((k2) => {
          if ("function" === typeof config2[k2]) {
            config2[k2] = config2[k2]();
          }
        });
        delete globalThis.sqlite3ApiConfig;
        delete sqlite3ApiBootstrap.defaultConfig;
        const capi = /* @__PURE__ */ Object.create(null);
        const wasm = /* @__PURE__ */ Object.create(null);
        const __rcStr = (rc) => {
          return capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc) || "Unknown result code #" + rc;
        };
        const __isInt = (n5) => "number" === typeof n5 && n5 === (n5 | 0);
        class SQLite3Error extends Error {
          constructor(...args) {
            let rc;
            if (args.length) {
              if (__isInt(args[0])) {
                rc = args[0];
                if (1 === args.length) {
                  super(__rcStr(args[0]));
                } else {
                  const rcStr = __rcStr(rc);
                  if ("object" === typeof args[1]) {
                    super(rcStr, args[1]);
                  } else {
                    args[0] = rcStr + ":";
                    super(args.join(" "));
                  }
                }
              } else {
                if (2 === args.length && "object" === typeof args[1]) {
                  super(...args);
                } else {
                  super(args.join(" "));
                }
              }
            }
            this.resultCode = rc || capi.SQLITE_ERROR;
            this.name = "SQLite3Error";
          }
        }
        SQLite3Error.toss = (...args) => {
          throw new SQLite3Error(...args);
        };
        const toss3 = SQLite3Error.toss;
        if (config2.wasmfsOpfsDir && !/^\/[^/]+$/.test(config2.wasmfsOpfsDir)) {
          toss3(
            "config.wasmfsOpfsDir must be falsy or in the form '/dir-name'."
          );
        }
        const isInt32 = (n5) => {
          return "bigint" !== typeof n5 && !!(n5 === (n5 | 0) && n5 <= 2147483647 && n5 >= -2147483648);
        };
        const bigIntFits64 = function f4(b2) {
          if (!f4._max) {
            f4._max = BigInt("0x7fffffffffffffff");
            f4._min = ~f4._max;
          }
          return b2 >= f4._min && b2 <= f4._max;
        };
        const bigIntFits32 = (b2) => b2 >= -0x7fffffffn - 1n && b2 <= 0x7fffffffn;
        const bigIntFitsDouble = function f4(b2) {
          if (!f4._min) {
            f4._min = Number.MIN_SAFE_INTEGER;
            f4._max = Number.MAX_SAFE_INTEGER;
          }
          return b2 >= f4._min && b2 <= f4._max;
        };
        const isTypedArray = (v3) => {
          return v3 && v3.constructor && isInt32(v3.constructor.BYTES_PER_ELEMENT) ? v3 : false;
        };
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const isSharedTypedArray = (aTypedArray) => aTypedArray.buffer instanceof __SAB;
        const typedArrayPart = (aTypedArray, begin, end) => {
          return isSharedTypedArray(aTypedArray) ? aTypedArray.slice(begin, end) : aTypedArray.subarray(begin, end);
        };
        const isBindableTypedArray = (v3) => {
          return v3 && (v3 instanceof Uint8Array || v3 instanceof Int8Array || v3 instanceof ArrayBuffer);
        };
        const isSQLableTypedArray = (v3) => {
          return v3 && (v3 instanceof Uint8Array || v3 instanceof Int8Array || v3 instanceof ArrayBuffer);
        };
        const affirmBindableTypedArray = (v3) => {
          return isBindableTypedArray(v3) || toss3("Value is not of a supported TypedArray type.");
        };
        const utf8Decoder = new TextDecoder("utf-8");
        const typedArrayToString = function(typedArray, begin, end) {
          return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));
        };
        const flexibleString = function(v3) {
          if (isSQLableTypedArray(v3)) {
            return typedArrayToString(
              v3 instanceof ArrayBuffer ? new Uint8Array(v3) : v3
            );
          } else if (Array.isArray(v3))
            return v3.join("");
          else if (wasm.isPtr(v3))
            v3 = wasm.cstrToJs(v3);
          return v3;
        };
        class WasmAllocError extends Error {
          constructor(...args) {
            if (2 === args.length && "object" === typeof args[1]) {
              super(...args);
            } else if (args.length) {
              super(args.join(" "));
            } else {
              super("Allocation failed.");
            }
            this.resultCode = capi.SQLITE_NOMEM;
            this.name = "WasmAllocError";
          }
        }
        WasmAllocError.toss = (...args) => {
          throw new WasmAllocError(...args);
        };
        Object.assign(capi, {
          sqlite3_bind_blob: void 0,
          sqlite3_bind_text: void 0,
          sqlite3_create_function_v2: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) => {
          },
          sqlite3_create_function: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) => {
          },
          sqlite3_create_window_function: (pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) => {
          },
          sqlite3_prepare_v3: (dbPtr, sql, sqlByteLen, prepFlags, stmtPtrPtr, strPtrPtr) => {
          },
          sqlite3_prepare_v2: (dbPtr, sql, sqlByteLen, stmtPtrPtr, strPtrPtr) => {
          },
          sqlite3_exec: (pDb2, sql, callback, pVoid, pErrMsg) => {
          },
          sqlite3_randomness: (n5, outPtr) => {
          }
        });
        const util = {
          affirmBindableTypedArray,
          flexibleString,
          bigIntFits32,
          bigIntFits64,
          bigIntFitsDouble,
          isBindableTypedArray,
          isInt32,
          isSQLableTypedArray,
          isTypedArray,
          typedArrayToString,
          isUIThread: () => globalThis.window === globalThis && !!globalThis.document,
          isSharedTypedArray,
          toss: function(...args) {
            throw new Error(args.join(" "));
          },
          toss3,
          typedArrayPart,
          affirmDbHeader: function(bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            const header = "SQLite format 3";
            if (header.length > bytes.byteLength) {
              toss3("Input does not contain an SQLite3 database header.");
            }
            for (let i3 = 0; i3 < header.length; ++i3) {
              if (header.charCodeAt(i3) !== bytes[i3]) {
                toss3("Input does not contain an SQLite3 database header.");
              }
            }
          },
          affirmIsDb: function(bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            const n5 = bytes.byteLength;
            if (n5 < 512 || n5 % 512 !== 0) {
              toss3("Byte array size", n5, "is invalid for an SQLite3 db.");
            }
            util.affirmDbHeader(bytes);
          }
        };
        Object.assign(wasm, {
          ptrSizeof: config2.wasmPtrSizeof || 4,
          ptrIR: config2.wasmPtrIR || "i32",
          bigIntEnabled: !!config2.bigIntEnabled,
          exports: config2.exports || toss3("Missing API config.exports (WASM module exports)."),
          memory: config2.memory || config2.exports["memory"] || toss3(
            "API config object requires a WebAssembly.Memory object",
            "in either config.exports.memory (exported)",
            "or config.memory (imported)."
          ),
          alloc: void 0,
          realloc: void 0,
          dealloc: void 0
        });
        wasm.allocFromTypedArray = function(srcTypedArray) {
          if (srcTypedArray instanceof ArrayBuffer) {
            srcTypedArray = new Uint8Array(srcTypedArray);
          }
          affirmBindableTypedArray(srcTypedArray);
          const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
          wasm.heapForSize(srcTypedArray.constructor).set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);
          return pRet;
        };
        {
          const keyAlloc = config2.allocExportName, keyDealloc = config2.deallocExportName, keyRealloc = config2.reallocExportName;
          for (const key of [keyAlloc, keyDealloc, keyRealloc]) {
            const f4 = wasm.exports[key];
            if (!(f4 instanceof Function))
              toss3("Missing required exports[", key, "] function.");
          }
          wasm.alloc = function f4(n5) {
            return f4.impl(n5) || WasmAllocError.toss("Failed to allocate", n5, " bytes.");
          };
          wasm.alloc.impl = wasm.exports[keyAlloc];
          wasm.realloc = function f4(m3, n5) {
            const m22 = f4.impl(m3, n5);
            return n5 ? m22 || WasmAllocError.toss("Failed to reallocate", n5, " bytes.") : 0;
          };
          wasm.realloc.impl = wasm.exports[keyRealloc];
          wasm.dealloc = wasm.exports[keyDealloc];
        }
        wasm.compileOptionUsed = function f4(optName) {
          if (!arguments.length) {
            if (f4._result)
              return f4._result;
            else if (!f4._opt) {
              f4._rx = /^([^=]+)=(.+)/;
              f4._rxInt = /^-?\d+$/;
              f4._opt = function(opt, rv) {
                const m3 = f4._rx.exec(opt);
                rv[0] = m3 ? m3[1] : opt;
                rv[1] = m3 ? f4._rxInt.test(m3[2]) ? +m3[2] : m3[2] : true;
              };
            }
            const rc = {}, ov = [0, 0];
            let i3 = 0, k2;
            while (k2 = capi.sqlite3_compileoption_get(i3++)) {
              f4._opt(k2, ov);
              rc[ov[0]] = ov[1];
            }
            return f4._result = rc;
          } else if (Array.isArray(optName)) {
            const rc = {};
            optName.forEach((v3) => {
              rc[v3] = capi.sqlite3_compileoption_used(v3);
            });
            return rc;
          } else if ("object" === typeof optName) {
            Object.keys(optName).forEach((k2) => {
              optName[k2] = capi.sqlite3_compileoption_used(k2);
            });
            return optName;
          }
          return "string" === typeof optName ? !!capi.sqlite3_compileoption_used(optName) : false;
        };
        wasm.pstack = Object.assign(/* @__PURE__ */ Object.create(null), {
          restore: wasm.exports.sqlite3__wasm_pstack_restore,
          alloc: function(n5) {
            if ("string" === typeof n5 && !(n5 = wasm.sizeofIR(n5))) {
              WasmAllocError.toss(
                "Invalid value for pstack.alloc(",
                arguments[0],
                ")"
              );
            }
            return wasm.exports.sqlite3__wasm_pstack_alloc(n5) || WasmAllocError.toss(
              "Could not allocate",
              n5,
              "bytes from the pstack."
            );
          },
          allocChunks: function(n5, sz) {
            if ("string" === typeof sz && !(sz = wasm.sizeofIR(sz))) {
              WasmAllocError.toss(
                "Invalid size value for allocChunks(",
                arguments[1],
                ")"
              );
            }
            const mem = wasm.pstack.alloc(n5 * sz);
            const rc = [];
            let i3 = 0, offset3 = 0;
            for (; i3 < n5; ++i3, offset3 += sz)
              rc.push(mem + offset3);
            return rc;
          },
          allocPtr: (n5 = 1, safePtrSize = true) => {
            return 1 === n5 ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof) : wasm.pstack.allocChunks(n5, safePtrSize ? 8 : wasm.ptrSizeof);
          },
          call: function(f4) {
            const stackPos = wasm.pstack.pointer;
            try {
              return f4(sqlite3);
            } finally {
              wasm.pstack.restore(stackPos);
            }
          }
        });
        Object.defineProperties(wasm.pstack, {
          pointer: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_ptr
          },
          quota: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_quota
          },
          remaining: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_remaining
          }
        });
        capi.sqlite3_randomness = (...args) => {
          if (1 === args.length && util.isTypedArray(args[0]) && 1 === args[0].BYTES_PER_ELEMENT) {
            const ta = args[0];
            if (0 === ta.byteLength) {
              wasm.exports.sqlite3_randomness(0, 0);
              return ta;
            }
            const stack = wasm.pstack.pointer;
            try {
              let n5 = ta.byteLength, offset3 = 0;
              const r5 = wasm.exports.sqlite3_randomness;
              const heap = wasm.heap8u();
              const nAlloc = n5 < 512 ? n5 : 512;
              const ptr = wasm.pstack.alloc(nAlloc);
              do {
                const j2 = n5 > nAlloc ? nAlloc : n5;
                r5(j2, ptr);
                ta.set(typedArrayPart(heap, ptr, ptr + j2), offset3);
                n5 -= j2;
                offset3 += j2;
              } while (n5 > 0);
            } catch (e5) {
              console.error(
                "Highly unexpected (and ignored!) exception in sqlite3_randomness():",
                e5
              );
            } finally {
              wasm.pstack.restore(stack);
            }
            return ta;
          }
          wasm.exports.sqlite3_randomness(...args);
        };
        let __wasmfsOpfsDir = void 0;
        capi.sqlite3_wasmfs_opfs_dir = function() {
          if (void 0 !== __wasmfsOpfsDir)
            return __wasmfsOpfsDir;
          const pdir = config2.wasmfsOpfsDir;
          if (!pdir || !globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle) {
            return __wasmfsOpfsDir = "";
          }
          try {
            if (pdir && 0 === wasm.xCallWrapped(
              "sqlite3__wasm_init_wasmfs",
              "i32",
              ["string"],
              pdir
            )) {
              return __wasmfsOpfsDir = pdir;
            } else {
              return __wasmfsOpfsDir = "";
            }
          } catch (e5) {
            return __wasmfsOpfsDir = "";
          }
        };
        capi.sqlite3_wasmfs_filename_is_persistent = function(name) {
          const p2 = capi.sqlite3_wasmfs_opfs_dir();
          return p2 && name ? name.startsWith(p2 + "/") : false;
        };
        capi.sqlite3_js_db_uses_vfs = function(pDb2, vfsName, dbName = 0) {
          try {
            const pK = capi.sqlite3_vfs_find(vfsName);
            if (!pK)
              return false;
            else if (!pDb2) {
              return pK === capi.sqlite3_vfs_find(0) ? pK : false;
            } else {
              return pK === capi.sqlite3_js_db_vfs(pDb2, dbName) ? pK : false;
            }
          } catch (e5) {
            return false;
          }
        };
        capi.sqlite3_js_vfs_list = function() {
          const rc = [];
          let pVfs = capi.sqlite3_vfs_find(0);
          while (pVfs) {
            const oVfs = new capi.sqlite3_vfs(pVfs);
            rc.push(wasm.cstrToJs(oVfs.$zName));
            pVfs = oVfs.$pNext;
            oVfs.dispose();
          }
          return rc;
        };
        capi.sqlite3_js_db_export = function(pDb2, schema = 0) {
          pDb2 = wasm.xWrap.testConvertArg("sqlite3*", pDb2);
          if (!pDb2)
            toss3("Invalid sqlite3* argument.");
          if (!wasm.bigIntEnabled)
            toss3("BigInt64 support is not enabled.");
          const scope = wasm.scopedAllocPush();
          let pOut;
          try {
            const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
            const ppOut = pSize + 8;
            const zSchema = schema ? wasm.isPtr(schema) ? schema : wasm.scopedAllocCString("" + schema) : 0;
            let rc = wasm.exports.sqlite3__wasm_db_serialize(
              pDb2,
              zSchema,
              ppOut,
              pSize,
              0
            );
            if (rc) {
              toss3(
                "Database serialization failed with code",
                sqlite3.capi.sqlite3_js_rc_str(rc)
              );
            }
            pOut = wasm.peekPtr(ppOut);
            const nOut = wasm.peek(pSize, "i64");
            rc = nOut ? wasm.heap8u().slice(pOut, pOut + Number(nOut)) : new Uint8Array();
            return rc;
          } finally {
            if (pOut)
              wasm.exports.sqlite3_free(pOut);
            wasm.scopedAllocPop(scope);
          }
        };
        capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) => util.sqlite3__wasm_db_vfs(dbPointer, dbName);
        capi.sqlite3_js_aggregate_context = (pCtx, n5) => {
          return capi.sqlite3_aggregate_context(pCtx, n5) || (n5 ? WasmAllocError.toss(
            "Cannot allocate",
            n5,
            "bytes for sqlite3_aggregate_context()"
          ) : 0);
        };
        capi.sqlite3_js_posix_create_file = function(filename, data, dataLen) {
          let pData;
          if (data && wasm.isPtr(data)) {
            pData = data;
          } else if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
            pData = wasm.allocFromTypedArray(data);
            if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {
              dataLen = data.byteLength;
            }
          } else {
            SQLite3Error.toss(
              "Invalid 2nd argument for sqlite3_js_posix_create_file()."
            );
          }
          try {
            if (!util.isInt32(dataLen) || dataLen < 0) {
              SQLite3Error.toss(
                "Invalid 3rd argument for sqlite3_js_posix_create_file()."
              );
            }
            const rc = util.sqlite3__wasm_posix_create_file(
              filename,
              pData,
              dataLen
            );
            if (rc)
              SQLite3Error.toss(
                "Creation of file failed with sqlite3 result code",
                capi.sqlite3_js_rc_str(rc)
              );
          } finally {
            wasm.dealloc(pData);
          }
        };
        capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen) {
          config2.warn(
            "sqlite3_js_vfs_create_file() is deprecated and",
            "should be avoided because it can lead to C-level crashes.",
            "See its documentation for alternative options."
          );
          let pData;
          if (data) {
            if (wasm.isPtr(data)) {
              pData = data;
            } else if (data instanceof ArrayBuffer) {
              data = new Uint8Array(data);
            }
            if (data instanceof Uint8Array) {
              pData = wasm.allocFromTypedArray(data);
              if (arguments.length < 4 || !util.isInt32(dataLen) || dataLen < 0) {
                dataLen = data.byteLength;
              }
            } else {
              SQLite3Error.toss(
                "Invalid 3rd argument type for sqlite3_js_vfs_create_file()."
              );
            }
          } else {
            pData = 0;
          }
          if (!util.isInt32(dataLen) || dataLen < 0) {
            wasm.dealloc(pData);
            SQLite3Error.toss(
              "Invalid 4th argument for sqlite3_js_vfs_create_file()."
            );
          }
          try {
            const rc = util.sqlite3__wasm_vfs_create_file(
              vfs,
              filename,
              pData,
              dataLen
            );
            if (rc)
              SQLite3Error.toss(
                "Creation of file failed with sqlite3 result code",
                capi.sqlite3_js_rc_str(rc)
              );
          } finally {
            wasm.dealloc(pData);
          }
        };
        capi.sqlite3_js_sql_to_string = (sql) => {
          if ("string" === typeof sql) {
            return sql;
          }
          const x2 = flexibleString(v);
          return x2 === v ? void 0 : x2;
        };
        if (util.isUIThread()) {
          const __kvvfsInfo = function(which) {
            const rc = /* @__PURE__ */ Object.create(null);
            rc.prefix = "kvvfs-" + which;
            rc.stores = [];
            if ("session" === which || "" === which)
              rc.stores.push(globalThis.sessionStorage);
            if ("local" === which || "" === which)
              rc.stores.push(globalThis.localStorage);
            return rc;
          };
          capi.sqlite3_js_kvvfs_clear = function(which = "") {
            let rc = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s2) => {
              const toRm = [];
              let i3;
              for (i3 = 0; i3 < s2.length; ++i3) {
                const k2 = s2.key(i3);
                if (k2.startsWith(kvinfo.prefix))
                  toRm.push(k2);
              }
              toRm.forEach((kk) => s2.removeItem(kk));
              rc += toRm.length;
            });
            return rc;
          };
          capi.sqlite3_js_kvvfs_size = function(which = "") {
            let sz = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s2) => {
              let i3;
              for (i3 = 0; i3 < s2.length; ++i3) {
                const k2 = s2.key(i3);
                if (k2.startsWith(kvinfo.prefix)) {
                  sz += k2.length;
                  sz += s2.getItem(k2).length;
                }
              }
            });
            return sz * 2;
          };
        }
        capi.sqlite3_db_config = function(pDb2, op, ...args) {
          if (!this.s) {
            this.s = wasm.xWrap("sqlite3__wasm_db_config_s", "int", [
              "sqlite3*",
              "int",
              "string:static"
            ]);
            this.pii = wasm.xWrap("sqlite3__wasm_db_config_pii", "int", [
              "sqlite3*",
              "int",
              "*",
              "int",
              "int"
            ]);
            this.ip = wasm.xWrap("sqlite3__wasm_db_config_ip", "int", [
              "sqlite3*",
              "int",
              "int",
              "*"
            ]);
          }
          switch (op) {
            case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
            case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
            case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
            case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
            case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
            case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
            case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
            case capi.SQLITE_DBCONFIG_RESET_DATABASE:
            case capi.SQLITE_DBCONFIG_DEFENSIVE:
            case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
            case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
            case capi.SQLITE_DBCONFIG_DQS_DML:
            case capi.SQLITE_DBCONFIG_DQS_DDL:
            case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
            case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
            case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
            case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
            case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
              return this.ip(pDb2, op, args[0], args[1] || 0);
            case capi.SQLITE_DBCONFIG_LOOKASIDE:
              return this.pii(pDb2, op, args[0], args[1], args[2]);
            case capi.SQLITE_DBCONFIG_MAINDBNAME:
              return this.s(pDb2, op, args[0]);
            default:
              return capi.SQLITE_MISUSE;
          }
        }.bind(/* @__PURE__ */ Object.create(null));
        capi.sqlite3_value_to_js = function(pVal, throwIfCannotConvert = true) {
          let arg;
          const valType = capi.sqlite3_value_type(pVal);
          switch (valType) {
            case capi.SQLITE_INTEGER:
              if (wasm.bigIntEnabled) {
                arg = capi.sqlite3_value_int64(pVal);
                if (util.bigIntFitsDouble(arg))
                  arg = Number(arg);
              } else
                arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_FLOAT:
              arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_TEXT:
              arg = capi.sqlite3_value_text(pVal);
              break;
            case capi.SQLITE_BLOB: {
              const n5 = capi.sqlite3_value_bytes(pVal);
              const pBlob = capi.sqlite3_value_blob(pVal);
              if (n5 && !pBlob)
                sqlite3.WasmAllocError.toss(
                  "Cannot allocate memory for blob argument of",
                  n5,
                  "byte(s)"
                );
              arg = n5 ? wasm.heap8u().slice(pBlob, pBlob + Number(n5)) : null;
              break;
            }
            case capi.SQLITE_NULL:
              arg = null;
              break;
            default:
              if (throwIfCannotConvert) {
                toss3(
                  capi.SQLITE_MISMATCH,
                  "Unhandled sqlite3_value_type():",
                  valType
                );
              }
              arg = void 0;
          }
          return arg;
        };
        capi.sqlite3_values_to_js = function(argc, pArgv, throwIfCannotConvert = true) {
          let i3;
          const tgt = [];
          for (i3 = 0; i3 < argc; ++i3) {
            tgt.push(
              capi.sqlite3_value_to_js(
                wasm.peekPtr(pArgv + wasm.ptrSizeof * i3),
                throwIfCannotConvert
              )
            );
          }
          return tgt;
        };
        capi.sqlite3_result_error_js = function(pCtx, e5) {
          if (e5 instanceof WasmAllocError) {
            capi.sqlite3_result_error_nomem(pCtx);
          } else {
            capi.sqlite3_result_error(pCtx, "" + e5, -1);
          }
        };
        capi.sqlite3_result_js = function(pCtx, val) {
          if (val instanceof Error) {
            capi.sqlite3_result_error_js(pCtx, val);
            return;
          }
          try {
            switch (typeof val) {
              case "undefined":
                break;
              case "boolean":
                capi.sqlite3_result_int(pCtx, val ? 1 : 0);
                break;
              case "bigint":
                if (util.bigIntFits32(val)) {
                  capi.sqlite3_result_int(pCtx, Number(val));
                } else if (util.bigIntFitsDouble(val)) {
                  capi.sqlite3_result_double(pCtx, Number(val));
                } else if (wasm.bigIntEnabled) {
                  if (util.bigIntFits64(val))
                    capi.sqlite3_result_int64(pCtx, val);
                  else
                    toss3(
                      "BigInt value",
                      val.toString(),
                      "is too BigInt for int64."
                    );
                } else {
                  toss3("BigInt value", val.toString(), "is too BigInt.");
                }
                break;
              case "number": {
                let f4;
                if (util.isInt32(val)) {
                  f4 = capi.sqlite3_result_int;
                } else if (wasm.bigIntEnabled && Number.isInteger(val) && util.bigIntFits64(BigInt(val))) {
                  f4 = capi.sqlite3_result_int64;
                } else {
                  f4 = capi.sqlite3_result_double;
                }
                f4(pCtx, val);
                break;
              }
              case "string": {
                const [p2, n5] = wasm.allocCString(val, true);
                capi.sqlite3_result_text(pCtx, p2, n5, capi.SQLITE_WASM_DEALLOC);
                break;
              }
              case "object":
                if (null === val) {
                  capi.sqlite3_result_null(pCtx);
                  break;
                } else if (util.isBindableTypedArray(val)) {
                  const pBlob = wasm.allocFromTypedArray(val);
                  capi.sqlite3_result_blob(
                    pCtx,
                    pBlob,
                    val.byteLength,
                    capi.SQLITE_WASM_DEALLOC
                  );
                  break;
                }
              default:
                toss3(
                  "Don't not how to handle this UDF result value:",
                  typeof val,
                  val
                );
            }
          } catch (e5) {
            capi.sqlite3_result_error_js(pCtx, e5);
          }
        };
        capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert = true) {
          const v3 = capi.sqlite3_column_value(pStmt, iCol);
          return 0 === v3 ? void 0 : capi.sqlite3_value_to_js(v3, throwIfCannotConvert);
        };
        const __newOldValue = function(pObj, iCol, impl) {
          impl = capi[impl];
          if (!this.ptr)
            this.ptr = wasm.allocPtr();
          else
            wasm.pokePtr(this.ptr, 0);
          const rc = impl(pObj, iCol, this.ptr);
          if (rc)
            return SQLite3Error.toss(
              rc,
              arguments[2] + "() failed with code " + rc
            );
          const pv = wasm.peekPtr(this.ptr);
          return pv ? capi.sqlite3_value_to_js(pv, true) : void 0;
        }.bind(/* @__PURE__ */ Object.create(null));
        capi.sqlite3_preupdate_new_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_new");
        capi.sqlite3_preupdate_old_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_old");
        capi.sqlite3changeset_new_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_new");
        capi.sqlite3changeset_old_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_old");
        const sqlite3 = {
          WasmAllocError,
          SQLite3Error,
          capi,
          util,
          wasm,
          config: config2,
          version: /* @__PURE__ */ Object.create(null),
          client: void 0,
          asyncPostInit: async function ff() {
            if (ff.isReady instanceof Promise)
              return ff.isReady;
            let lia = sqlite3ApiBootstrap.initializersAsync;
            delete sqlite3ApiBootstrap.initializersAsync;
            const postInit = async () => {
              if (!sqlite3.__isUnderTest) {
                delete sqlite3.util;
                delete sqlite3.StructBinder;
              }
              return sqlite3;
            };
            const catcher = (e5) => {
              config2.error("an async sqlite3 initializer failed:", e5);
              throw e5;
            };
            if (!lia || !lia.length) {
              return ff.isReady = postInit().catch(catcher);
            }
            lia = lia.map((f4) => {
              return f4 instanceof Function ? async (x2) => f4(sqlite3) : f4;
            });
            lia.push(postInit);
            let p2 = Promise.resolve(sqlite3);
            while (lia.length)
              p2 = p2.then(lia.shift());
            return ff.isReady = p2.catch(catcher);
          },
          scriptInfo: void 0
        };
        try {
          sqlite3ApiBootstrap.initializers.forEach((f4) => {
            f4(sqlite3);
          });
        } catch (e5) {
          console.error("sqlite3 bootstrap initializer threw:", e5);
          throw e5;
        }
        delete sqlite3ApiBootstrap.initializers;
        sqlite3ApiBootstrap.sqlite3 = sqlite3;
        return sqlite3;
      };
      globalThis.sqlite3ApiBootstrap.initializers = [];
      globalThis.sqlite3ApiBootstrap.initializersAsync = [];
      globalThis.sqlite3ApiBootstrap.defaultConfig = /* @__PURE__ */ Object.create(null);
      globalThis.sqlite3ApiBootstrap.sqlite3 = void 0;
      globalThis.WhWasmUtilInstaller = function(target) {
        "use strict";
        if (void 0 === target.bigIntEnabled) {
          target.bigIntEnabled = !!globalThis["BigInt64Array"];
        }
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        if (!target.exports) {
          Object.defineProperty(target, "exports", {
            enumerable: true,
            configurable: true,
            get: () => target.instance && target.instance.exports
          });
        }
        const ptrIR = target.pointerIR || "i32";
        const ptrSizeof = target.ptrSizeof = "i32" === ptrIR ? 4 : "i64" === ptrIR ? 8 : toss("Unhandled ptrSizeof:", ptrIR);
        const cache = /* @__PURE__ */ Object.create(null);
        cache.heapSize = 0;
        cache.memory = null;
        cache.freeFuncIndexes = [];
        cache.scopedAlloc = [];
        cache.utf8Decoder = new TextDecoder();
        cache.utf8Encoder = new TextEncoder("utf-8");
        target.sizeofIR = (n5) => {
          switch (n5) {
            case "i8":
              return 1;
            case "i16":
              return 2;
            case "i32":
            case "f32":
            case "float":
              return 4;
            case "i64":
            case "f64":
            case "double":
              return 8;
            case "*":
              return ptrSizeof;
            default:
              return ("" + n5).endsWith("*") ? ptrSizeof : void 0;
          }
        };
        const heapWrappers = function() {
          if (!cache.memory) {
            cache.memory = target.memory instanceof WebAssembly.Memory ? target.memory : target.exports.memory;
          } else if (cache.heapSize === cache.memory.buffer.byteLength) {
            return cache;
          }
          const b2 = cache.memory.buffer;
          cache.HEAP8 = new Int8Array(b2);
          cache.HEAP8U = new Uint8Array(b2);
          cache.HEAP16 = new Int16Array(b2);
          cache.HEAP16U = new Uint16Array(b2);
          cache.HEAP32 = new Int32Array(b2);
          cache.HEAP32U = new Uint32Array(b2);
          if (target.bigIntEnabled) {
            cache.HEAP64 = new BigInt64Array(b2);
            cache.HEAP64U = new BigUint64Array(b2);
          }
          cache.HEAP32F = new Float32Array(b2);
          cache.HEAP64F = new Float64Array(b2);
          cache.heapSize = b2.byteLength;
          return cache;
        };
        target.heap8 = () => heapWrappers().HEAP8;
        target.heap8u = () => heapWrappers().HEAP8U;
        target.heap16 = () => heapWrappers().HEAP16;
        target.heap16u = () => heapWrappers().HEAP16U;
        target.heap32 = () => heapWrappers().HEAP32;
        target.heap32u = () => heapWrappers().HEAP32U;
        target.heapForSize = function(n5, unsigned = true) {
          let ctor;
          const c4 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          switch (n5) {
            case Int8Array:
              return c4.HEAP8;
            case Uint8Array:
              return c4.HEAP8U;
            case Int16Array:
              return c4.HEAP16;
            case Uint16Array:
              return c4.HEAP16U;
            case Int32Array:
              return c4.HEAP32;
            case Uint32Array:
              return c4.HEAP32U;
            case 8:
              return unsigned ? c4.HEAP8U : c4.HEAP8;
            case 16:
              return unsigned ? c4.HEAP16U : c4.HEAP16;
            case 32:
              return unsigned ? c4.HEAP32U : c4.HEAP32;
            case 64:
              if (c4.HEAP64)
                return unsigned ? c4.HEAP64U : c4.HEAP64;
              break;
            default:
              if (target.bigIntEnabled) {
                if (n5 === globalThis["BigUint64Array"])
                  return c4.HEAP64U;
                else if (n5 === globalThis["BigInt64Array"])
                  return c4.HEAP64;
                break;
              }
          }
          toss(
            "Invalid heapForSize() size: expecting 8, 16, 32,",
            "or (if BigInt is enabled) 64."
          );
        };
        target.functionTable = function() {
          return target.exports.__indirect_function_table;
        };
        target.functionEntry = function(fptr) {
          const ft = target.functionTable();
          return fptr < ft.length ? ft.get(fptr) : void 0;
        };
        target.jsFuncToWasm = function f4(func, sig) {
          if (!f4._) {
            f4._ = {
              sigTypes: Object.assign(/* @__PURE__ */ Object.create(null), {
                i: "i32",
                p: "i32",
                P: "i32",
                s: "i32",
                j: "i64",
                f: "f32",
                d: "f64"
              }),
              typeCodes: Object.assign(/* @__PURE__ */ Object.create(null), {
                f64: 124,
                f32: 125,
                i64: 126,
                i32: 127
              }),
              uleb128Encode: function(tgt, method, n5) {
                if (n5 < 128)
                  tgt[method](n5);
                else
                  tgt[method](n5 % 128 | 128, n5 >> 7);
              },
              rxJSig: /^(\w)\((\w*)\)$/,
              sigParams: function(sig2) {
                const m3 = f4._.rxJSig.exec(sig2);
                return m3 ? m3[2] : sig2.substr(1);
              },
              letterType: (x2) => f4._.sigTypes[x2] || toss("Invalid signature letter:", x2),
              pushSigType: (dest, letter) => dest.push(f4._.typeCodes[f4._.letterType(letter)])
            };
          }
          if ("string" === typeof func) {
            const x2 = sig;
            sig = func;
            func = x2;
          }
          const sigParams = f4._.sigParams(sig);
          const wasmCode = [1, 96];
          f4._.uleb128Encode(wasmCode, "push", sigParams.length);
          for (const x2 of sigParams)
            f4._.pushSigType(wasmCode, x2);
          if ("v" === sig[0])
            wasmCode.push(0);
          else {
            wasmCode.push(1);
            f4._.pushSigType(wasmCode, sig[0]);
          }
          f4._.uleb128Encode(wasmCode, "unshift", wasmCode.length);
          wasmCode.unshift(
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1
          );
          wasmCode.push(
            2,
            7,
            1,
            1,
            101,
            1,
            102,
            0,
            0,
            7,
            5,
            1,
            1,
            102,
            0,
            0
          );
          return new WebAssembly.Instance(
            new WebAssembly.Module(new Uint8Array(wasmCode)),
            {
              e: { f: func }
            }
          ).exports["f"];
        };
        const __installFunction = function f4(func, sig, scoped) {
          if (scoped && !cache.scopedAlloc.length) {
            toss("No scopedAllocPush() scope is active.");
          }
          if ("string" === typeof func) {
            const x2 = sig;
            sig = func;
            func = x2;
          }
          if ("string" !== typeof sig || !(func instanceof Function)) {
            toss(
              "Invalid arguments: expecting (function,signature) or (signature,function)."
            );
          }
          const ft = target.functionTable();
          const oldLen = ft.length;
          let ptr;
          while (cache.freeFuncIndexes.length) {
            ptr = cache.freeFuncIndexes.pop();
            if (ft.get(ptr)) {
              ptr = null;
              continue;
            } else {
              break;
            }
          }
          if (!ptr) {
            ptr = oldLen;
            ft.grow(1);
          }
          try {
            ft.set(ptr, func);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
            return ptr;
          } catch (e5) {
            if (!(e5 instanceof TypeError)) {
              if (ptr === oldLen)
                cache.freeFuncIndexes.push(oldLen);
              throw e5;
            }
          }
          try {
            const fptr = target.jsFuncToWasm(func, sig);
            ft.set(ptr, fptr);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
          } catch (e5) {
            if (ptr === oldLen)
              cache.freeFuncIndexes.push(oldLen);
            throw e5;
          }
          return ptr;
        };
        target.installFunction = (func, sig) => __installFunction(func, sig, false);
        target.scopedInstallFunction = (func, sig) => __installFunction(func, sig, true);
        target.uninstallFunction = function(ptr) {
          if (!ptr && 0 !== ptr)
            return void 0;
          const fi = cache.freeFuncIndexes;
          const ft = target.functionTable();
          fi.push(ptr);
          const rc = ft.get(ptr);
          ft.set(ptr, null);
          return rc;
        };
        target.peek = function f4(ptr, type = "i8") {
          if (type.endsWith("*"))
            type = ptrIR;
          const c4 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          const list = Array.isArray(ptr) ? [] : void 0;
          let rc;
          do {
            if (list)
              ptr = arguments[0].shift();
            switch (type) {
              case "i1":
              case "i8":
                rc = c4.HEAP8[ptr >> 0];
                break;
              case "i16":
                rc = c4.HEAP16[ptr >> 1];
                break;
              case "i32":
                rc = c4.HEAP32[ptr >> 2];
                break;
              case "float":
              case "f32":
                rc = c4.HEAP32F[ptr >> 2];
                break;
              case "double":
              case "f64":
                rc = Number(c4.HEAP64F[ptr >> 3]);
                break;
              case "i64":
                if (target.bigIntEnabled) {
                  rc = BigInt(c4.HEAP64[ptr >> 3]);
                  break;
                }
              default:
                toss("Invalid type for peek():", type);
            }
            if (list)
              list.push(rc);
          } while (list && arguments[0].length);
          return list || rc;
        };
        target.poke = function(ptr, value, type = "i8") {
          if (type.endsWith("*"))
            type = ptrIR;
          const c4 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          for (const p2 of Array.isArray(ptr) ? ptr : [ptr]) {
            switch (type) {
              case "i1":
              case "i8":
                c4.HEAP8[p2 >> 0] = value;
                continue;
              case "i16":
                c4.HEAP16[p2 >> 1] = value;
                continue;
              case "i32":
                c4.HEAP32[p2 >> 2] = value;
                continue;
              case "float":
              case "f32":
                c4.HEAP32F[p2 >> 2] = value;
                continue;
              case "double":
              case "f64":
                c4.HEAP64F[p2 >> 3] = value;
                continue;
              case "i64":
                if (c4.HEAP64) {
                  c4.HEAP64[p2 >> 3] = BigInt(value);
                  continue;
                }
              default:
                toss("Invalid type for poke(): " + type);
            }
          }
          return this;
        };
        target.peekPtr = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);
        target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);
        target.peek8 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i8");
        target.poke8 = (ptr, value) => target.poke(ptr, value, "i8");
        target.peek16 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i16");
        target.poke16 = (ptr, value) => target.poke(ptr, value, "i16");
        target.peek32 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i32");
        target.poke32 = (ptr, value) => target.poke(ptr, value, "i32");
        target.peek64 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i64");
        target.poke64 = (ptr, value) => target.poke(ptr, value, "i64");
        target.peek32f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f32");
        target.poke32f = (ptr, value) => target.poke(ptr, value, "f32");
        target.peek64f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f64");
        target.poke64f = (ptr, value) => target.poke(ptr, value, "f64");
        target.getMemValue = target.peek;
        target.getPtrValue = target.peekPtr;
        target.setMemValue = target.poke;
        target.setPtrValue = target.pokePtr;
        target.isPtr32 = (ptr) => "number" === typeof ptr && ptr === (ptr | 0) && ptr >= 0;
        target.isPtr = target.isPtr32;
        target.cstrlen = function(ptr) {
          if (!ptr || !target.isPtr(ptr))
            return null;
          const h4 = heapWrappers().HEAP8U;
          let pos = ptr;
          for (; h4[pos] !== 0; ++pos) {
          }
          return pos - ptr;
        };
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const __utf8Decode = function(arrayBuffer, begin, end) {
          return cache.utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
          );
        };
        target.cstrToJs = function(ptr) {
          const n5 = target.cstrlen(ptr);
          return n5 ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n5) : null === n5 ? n5 : "";
        };
        target.jstrlen = function(str) {
          if ("string" !== typeof str)
            return null;
          const n5 = str.length;
          let len = 0;
          for (let i3 = 0; i3 < n5; ++i3) {
            let u2 = str.charCodeAt(i3);
            if (u2 >= 55296 && u2 <= 57343) {
              u2 = 65536 + ((u2 & 1023) << 10) | str.charCodeAt(++i3) & 1023;
            }
            if (u2 <= 127)
              ++len;
            else if (u2 <= 2047)
              len += 2;
            else if (u2 <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        };
        target.jstrcpy = function(jstr, tgt, offset3 = 0, maxBytes = -1, addNul = true) {
          if (!tgt || !(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array)) {
            toss("jstrcpy() target must be an Int8Array or Uint8Array.");
          }
          if (maxBytes < 0)
            maxBytes = tgt.length - offset3;
          if (!(maxBytes > 0) || !(offset3 >= 0))
            return 0;
          let i3 = 0, max6 = jstr.length;
          const begin = offset3, end = offset3 + maxBytes - (addNul ? 1 : 0);
          for (; i3 < max6 && offset3 < end; ++i3) {
            let u2 = jstr.charCodeAt(i3);
            if (u2 >= 55296 && u2 <= 57343) {
              u2 = 65536 + ((u2 & 1023) << 10) | jstr.charCodeAt(++i3) & 1023;
            }
            if (u2 <= 127) {
              if (offset3 >= end)
                break;
              tgt[offset3++] = u2;
            } else if (u2 <= 2047) {
              if (offset3 + 1 >= end)
                break;
              tgt[offset3++] = 192 | u2 >> 6;
              tgt[offset3++] = 128 | u2 & 63;
            } else if (u2 <= 65535) {
              if (offset3 + 2 >= end)
                break;
              tgt[offset3++] = 224 | u2 >> 12;
              tgt[offset3++] = 128 | u2 >> 6 & 63;
              tgt[offset3++] = 128 | u2 & 63;
            } else {
              if (offset3 + 3 >= end)
                break;
              tgt[offset3++] = 240 | u2 >> 18;
              tgt[offset3++] = 128 | u2 >> 12 & 63;
              tgt[offset3++] = 128 | u2 >> 6 & 63;
              tgt[offset3++] = 128 | u2 & 63;
            }
          }
          if (addNul)
            tgt[offset3++] = 0;
          return offset3 - begin;
        };
        target.cstrncpy = function(tgtPtr, srcPtr, n5) {
          if (!tgtPtr || !srcPtr)
            toss("cstrncpy() does not accept NULL strings.");
          if (n5 < 0)
            n5 = target.cstrlen(strPtr) + 1;
          else if (!(n5 > 0))
            return 0;
          const heap = target.heap8u();
          let i3 = 0, ch;
          for (; i3 < n5 && (ch = heap[srcPtr + i3]); ++i3) {
            heap[tgtPtr + i3] = ch;
          }
          if (i3 < n5)
            heap[tgtPtr + i3++] = 0;
          return i3;
        };
        target.jstrToUintArray = (str, addNul = false) => {
          return cache.utf8Encoder.encode(addNul ? str + "\0" : str);
        };
        const __affirmAlloc = (obj, funcName) => {
          if (!(obj.alloc instanceof Function) || !(obj.dealloc instanceof Function)) {
            toss(
              "Object is missing alloc() and/or dealloc() function(s)",
              "required by",
              funcName + "()."
            );
          }
        };
        const __allocCStr = function(jstr, returnWithLength, allocator, funcName) {
          __affirmAlloc(target, funcName);
          if ("string" !== typeof jstr)
            return null;
          if (0) {
            const n5 = target.jstrlen(jstr), ptr = allocator(n5 + 1);
            target.jstrcpy(jstr, target.heap8u(), ptr, n5 + 1, true);
            return returnWithLength ? [ptr, n5] : ptr;
          } else {
            const u2 = cache.utf8Encoder.encode(jstr), ptr = allocator(u2.length + 1), heap = heapWrappers().HEAP8U;
            heap.set(u2, ptr);
            heap[ptr + u2.length] = 0;
            return returnWithLength ? [ptr, u2.length] : ptr;
          }
        };
        target.allocCString = (jstr, returnWithLength = false) => __allocCStr(jstr, returnWithLength, target.alloc, "allocCString()");
        target.scopedAllocPush = function() {
          __affirmAlloc(target, "scopedAllocPush");
          const a2 = [];
          cache.scopedAlloc.push(a2);
          return a2;
        };
        target.scopedAllocPop = function(state) {
          __affirmAlloc(target, "scopedAllocPop");
          const n5 = arguments.length ? cache.scopedAlloc.indexOf(state) : cache.scopedAlloc.length - 1;
          if (n5 < 0)
            toss("Invalid state object for scopedAllocPop().");
          if (0 === arguments.length)
            state = cache.scopedAlloc[n5];
          cache.scopedAlloc.splice(n5, 1);
          for (let p2; p2 = state.pop(); ) {
            if (target.functionEntry(p2)) {
              target.uninstallFunction(p2);
            } else
              target.dealloc(p2);
          }
        };
        target.scopedAlloc = function(n5) {
          if (!cache.scopedAlloc.length) {
            toss("No scopedAllocPush() scope is active.");
          }
          const p2 = target.alloc(n5);
          cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p2);
          return p2;
        };
        Object.defineProperty(target.scopedAlloc, "level", {
          configurable: false,
          enumerable: false,
          get: () => cache.scopedAlloc.length,
          set: () => toss("The 'active' property is read-only.")
        });
        target.scopedAllocCString = (jstr, returnWithLength = false) => __allocCStr(
          jstr,
          returnWithLength,
          target.scopedAlloc,
          "scopedAllocCString()"
        );
        const __allocMainArgv = function(isScoped, list) {
          const pList = target[isScoped ? "scopedAlloc" : "alloc"](
            (list.length + 1) * target.ptrSizeof
          );
          let i3 = 0;
          list.forEach((e5) => {
            target.pokePtr(
              pList + target.ptrSizeof * i3++,
              target[isScoped ? "scopedAllocCString" : "allocCString"]("" + e5)
            );
          });
          target.pokePtr(pList + target.ptrSizeof * i3, 0);
          return pList;
        };
        target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);
        target.allocMainArgv = (list) => __allocMainArgv(false, list);
        target.cArgvToJs = (argc, pArgv) => {
          const list = [];
          for (let i3 = 0; i3 < argc; ++i3) {
            const arg = target.peekPtr(pArgv + target.ptrSizeof * i3);
            list.push(arg ? target.cstrToJs(arg) : null);
          }
          return list;
        };
        target.scopedAllocCall = function(func) {
          target.scopedAllocPush();
          try {
            return func();
          } finally {
            target.scopedAllocPop();
          }
        };
        const __allocPtr = function(howMany, safePtrSize, method) {
          __affirmAlloc(target, method);
          const pIr = safePtrSize ? "i64" : ptrIR;
          let m3 = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
          target.poke(m3, 0, pIr);
          if (1 === howMany) {
            return m3;
          }
          const a2 = [m3];
          for (let i3 = 1; i3 < howMany; ++i3) {
            m3 += safePtrSize ? 8 : ptrSizeof;
            a2[i3] = m3;
            target.poke(m3, 0, pIr);
          }
          return a2;
        };
        target.allocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "alloc");
        target.scopedAllocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "scopedAlloc");
        target.xGet = function(name) {
          return target.exports[name] || toss("Cannot find exported symbol:", name);
        };
        const __argcMismatch = (f4, n5) => toss(f4 + "() requires", n5, "argument(s).");
        target.xCall = function(fname, ...args) {
          const f4 = fname instanceof Function ? fname : target.xGet(fname);
          if (!(f4 instanceof Function))
            toss("Exported symbol", fname, "is not a function.");
          if (f4.length !== args.length)
            __argcMismatch(f4 === fname ? f4.name : fname, f4.length);
          return 2 === arguments.length && Array.isArray(arguments[1]) ? f4.apply(null, arguments[1]) : f4.apply(null, args);
        };
        cache.xWrap = /* @__PURE__ */ Object.create(null);
        cache.xWrap.convert = /* @__PURE__ */ Object.create(null);
        cache.xWrap.convert.arg = /* @__PURE__ */ new Map();
        cache.xWrap.convert.result = /* @__PURE__ */ new Map();
        const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;
        if (target.bigIntEnabled) {
          xArg.set("i64", (i3) => BigInt(i3));
        }
        const __xArgPtr = "i32" === ptrIR ? (i3) => i3 | 0 : (i3) => BigInt(i3) | BigInt(0);
        xArg.set("i32", __xArgPtr).set("i16", (i3) => (i3 | 0) & 65535).set("i8", (i3) => (i3 | 0) & 255).set("f32", (i3) => Number(i3).valueOf()).set("float", xArg.get("f32")).set("f64", xArg.get("f32")).set("double", xArg.get("f64")).set("int", xArg.get("i32")).set("null", (i3) => i3).set(null, xArg.get("null")).set("**", __xArgPtr).set("*", __xArgPtr);
        xResult.set("*", __xArgPtr).set("pointer", __xArgPtr).set("number", (v3) => Number(v3)).set("void", (v3) => void 0).set("null", (v3) => v3).set(null, xResult.get("null"));
        {
          const copyToResult = [
            "i8",
            "i16",
            "i32",
            "int",
            "f32",
            "float",
            "f64",
            "double"
          ];
          if (target.bigIntEnabled)
            copyToResult.push("i64");
          const adaptPtr = xArg.get(ptrIR);
          for (const t4 of copyToResult) {
            xArg.set(t4 + "*", adaptPtr);
            xResult.set(t4 + "*", adaptPtr);
            xResult.set(t4, xArg.get(t4) || toss("Missing arg converter:", t4));
          }
        }
        const __xArgString = function(v3) {
          if ("string" === typeof v3)
            return target.scopedAllocCString(v3);
          return v3 ? __xArgPtr(v3) : null;
        };
        xArg.set("string", __xArgString).set("utf8", __xArgString).set("pointer", __xArgString);
        xResult.set("string", (i3) => target.cstrToJs(i3)).set("utf8", xResult.get("string")).set("string:dealloc", (i3) => {
          try {
            return i3 ? target.cstrToJs(i3) : null;
          } finally {
            target.dealloc(i3);
          }
        }).set("utf8:dealloc", xResult.get("string:dealloc")).set("json", (i3) => JSON.parse(target.cstrToJs(i3))).set("json:dealloc", (i3) => {
          try {
            return i3 ? JSON.parse(target.cstrToJs(i3)) : null;
          } finally {
            target.dealloc(i3);
          }
        });
        const AbstractArgAdapter = class {
          constructor(opt) {
            this.name = opt.name || "unnamed adapter";
          }
          convertArg(v3, argv, argIndex) {
            toss("AbstractArgAdapter must be subclassed.");
          }
        };
        xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
          constructor(opt) {
            super(opt);
            if (xArg.FuncPtrAdapter.warnOnUse) {
              console.warn(
                "xArg.FuncPtrAdapter is an internal-only API",
                "and is not intended to be invoked from",
                "client-level code. Invoked with:",
                opt
              );
            }
            this.name = opt.name || "unnamed";
            this.signature = opt.signature;
            if (opt.contextKey instanceof Function) {
              this.contextKey = opt.contextKey;
              if (!opt.bindScope)
                opt.bindScope = "context";
            }
            this.bindScope = opt.bindScope || toss(
              "FuncPtrAdapter options requires a bindScope (explicit or implied)."
            );
            if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {
              toss(
                "Invalid options.bindScope (" + opt.bindMod + ") for FuncPtrAdapter. Expecting one of: (" + FuncPtrAdapter.bindScopes.join(", ") + ")"
              );
            }
            this.isTransient = "transient" === this.bindScope;
            this.isContext = "context" === this.bindScope;
            this.isPermanent = "permanent" === this.bindScope;
            this.singleton = "singleton" === this.bindScope ? [] : void 0;
            this.callProxy = opt.callProxy instanceof Function ? opt.callProxy : void 0;
          }
          contextKey(argv, argIndex) {
            return this;
          }
          contextMap(key) {
            const cm = this.__cmap || (this.__cmap = /* @__PURE__ */ new Map());
            let rc = cm.get(key);
            if (void 0 === rc)
              cm.set(key, rc = []);
            return rc;
          }
          convertArg(v3, argv, argIndex) {
            let pair = this.singleton;
            if (!pair && this.isContext) {
              pair = this.contextMap(this.contextKey(argv, argIndex));
            }
            if (pair && pair[0] === v3)
              return pair[1];
            if (v3 instanceof Function) {
              if (this.callProxy)
                v3 = this.callProxy(v3);
              const fp = __installFunction(v3, this.signature, this.isTransient);
              if (FuncPtrAdapter.debugFuncInstall) {
                FuncPtrAdapter.debugOut(
                  "FuncPtrAdapter installed",
                  this,
                  this.contextKey(argv, argIndex),
                  "@" + fp,
                  v3
                );
              }
              if (pair) {
                if (pair[1]) {
                  if (FuncPtrAdapter.debugFuncInstall) {
                    FuncPtrAdapter.debugOut(
                      "FuncPtrAdapter uninstalling",
                      this,
                      this.contextKey(argv, argIndex),
                      "@" + pair[1],
                      v3
                    );
                  }
                  try {
                    cache.scopedAlloc[cache.scopedAlloc.length - 1].push(
                      pair[1]
                    );
                  } catch (e5) {
                  }
                }
                pair[0] = v3;
                pair[1] = fp;
              }
              return fp;
            } else if (target.isPtr(v3) || null === v3 || void 0 === v3) {
              if (pair && pair[1] && pair[1] !== v3) {
                if (FuncPtrAdapter.debugFuncInstall) {
                  FuncPtrAdapter.debugOut(
                    "FuncPtrAdapter uninstalling",
                    this,
                    this.contextKey(argv, argIndex),
                    "@" + pair[1],
                    v3
                  );
                }
                try {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);
                } catch (e5) {
                }
                pair[0] = pair[1] = v3 | 0;
              }
              return v3 || 0;
            } else {
              throw new TypeError(
                "Invalid FuncPtrAdapter argument type. Expecting a function pointer or a " + (this.name ? this.name + " " : "") + "function matching signature " + this.signature + "."
              );
            }
          }
        };
        xArg.FuncPtrAdapter.warnOnUse = false;
        xArg.FuncPtrAdapter.debugFuncInstall = false;
        xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);
        xArg.FuncPtrAdapter.bindScopes = [
          "transient",
          "context",
          "singleton",
          "permanent"
        ];
        const __xArgAdapterCheck = (t4) => xArg.get(t4) || toss("Argument adapter not found:", t4);
        const __xResultAdapterCheck = (t4) => xResult.get(t4) || toss("Result adapter not found:", t4);
        cache.xWrap.convertArg = (t4, ...args) => __xArgAdapterCheck(t4)(...args);
        cache.xWrap.convertArgNoCheck = (t4, ...args) => xArg.get(t4)(...args);
        cache.xWrap.convertResult = (t4, v3) => null === t4 ? v3 : t4 ? __xResultAdapterCheck(t4)(v3) : void 0;
        cache.xWrap.convertResultNoCheck = (t4, v3) => null === t4 ? v3 : t4 ? xResult.get(t4)(v3) : void 0;
        target.xWrap = function(fArg, resultType, ...argTypes) {
          if (3 === arguments.length && Array.isArray(arguments[2])) {
            argTypes = arguments[2];
          }
          if (target.isPtr(fArg)) {
            fArg = target.functionEntry(fArg) || toss("Function pointer not found in WASM function table.");
          }
          const fIsFunc = fArg instanceof Function;
          const xf = fIsFunc ? fArg : target.xGet(fArg);
          if (fIsFunc)
            fArg = xf.name || "unnamed function";
          if (argTypes.length !== xf.length)
            __argcMismatch(fArg, xf.length);
          if (null === resultType && 0 === xf.length) {
            return xf;
          }
          if (void 0 !== resultType && null !== resultType)
            __xResultAdapterCheck(resultType);
          for (const t4 of argTypes) {
            if (t4 instanceof AbstractArgAdapter)
              xArg.set(t4, (...args) => t4.convertArg(...args));
            else
              __xArgAdapterCheck(t4);
          }
          const cxw = cache.xWrap;
          if (0 === xf.length) {
            return (...args) => args.length ? __argcMismatch(fArg, xf.length) : cxw.convertResult(resultType, xf.call(null));
          }
          return function(...args) {
            if (args.length !== xf.length)
              __argcMismatch(fArg, xf.length);
            const scope = target.scopedAllocPush();
            try {
              let i3 = 0;
              for (; i3 < args.length; ++i3)
                args[i3] = cxw.convertArgNoCheck(argTypes[i3], args[i3], args, i3);
              return cxw.convertResultNoCheck(resultType, xf.apply(null, args));
            } finally {
              target.scopedAllocPop(scope);
            }
          };
        };
        const __xAdapter = function(func, argc, typeName, adapter, modeName, xcvPart) {
          if ("string" === typeof typeName) {
            if (1 === argc)
              return xcvPart.get(typeName);
            else if (2 === argc) {
              if (!adapter) {
                delete xcvPart.get(typeName);
                return func;
              } else if (!(adapter instanceof Function)) {
                toss(modeName, "requires a function argument.");
              }
              xcvPart.set(typeName, adapter);
              return func;
            }
          }
          toss("Invalid arguments to", modeName);
        };
        target.xWrap.resultAdapter = function f4(typeName, adapter) {
          return __xAdapter(
            f4,
            arguments.length,
            typeName,
            adapter,
            "resultAdapter()",
            xResult
          );
        };
        target.xWrap.argAdapter = function f4(typeName, adapter) {
          return __xAdapter(
            f4,
            arguments.length,
            typeName,
            adapter,
            "argAdapter()",
            xArg
          );
        };
        target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;
        target.xCallWrapped = function(fArg, resultType, argTypes, ...args) {
          if (Array.isArray(arguments[3]))
            args = arguments[3];
          return target.xWrap(fArg, resultType, argTypes || []).apply(null, args || []);
        };
        target.xWrap.testConvertArg = cache.xWrap.convertArg;
        target.xWrap.testConvertResult = cache.xWrap.convertResult;
        return target;
      };
      globalThis.WhWasmUtilInstaller.yawl = function(config2) {
        const wfetch = () => fetch(config2.uri, { credentials: "same-origin" });
        const wui = this;
        const finalThen = function(arg) {
          if (config2.wasmUtilTarget) {
            const toss = (...args) => {
              throw new Error(args.join(" "));
            };
            const tgt = config2.wasmUtilTarget;
            tgt.module = arg.module;
            tgt.instance = arg.instance;
            if (!tgt.instance.exports.memory) {
              tgt.memory = config2.imports && config2.imports.env && config2.imports.env.memory || toss("Missing 'memory' object!");
            }
            if (!tgt.alloc && arg.instance.exports.malloc) {
              const exports = arg.instance.exports;
              tgt.alloc = function(n5) {
                return exports.malloc(n5) || toss("Allocation of", n5, "bytes failed.");
              };
              tgt.dealloc = function(m3) {
                exports.free(m3);
              };
            }
            wui(tgt);
          }
          if (config2.onload)
            config2.onload(arg, config2);
          return arg;
        };
        const loadWasm = WebAssembly.instantiateStreaming ? function loadWasmStreaming() {
          return WebAssembly.instantiateStreaming(
            wfetch(),
            config2.imports || {}
          ).then(finalThen);
        } : function loadWasmOldSchool() {
          return wfetch().then((response) => response.arrayBuffer()).then(
            (bytes) => WebAssembly.instantiate(bytes, config2.imports || {})
          ).then(finalThen);
        };
        return loadWasm;
      }.bind(globalThis.WhWasmUtilInstaller);
      "use strict";
      globalThis.Jaccwabyt = function StructBinderFactory(config2) {
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        if (!(config2.heap instanceof WebAssembly.Memory) && !(config2.heap instanceof Function)) {
          toss(
            "config.heap must be WebAssembly.Memory instance or a function."
          );
        }
        ["alloc", "dealloc"].forEach(function(k2) {
          config2[k2] instanceof Function || toss("Config option '" + k2 + "' must be a function.");
        });
        const SBF = StructBinderFactory;
        const heap = config2.heap instanceof Function ? config2.heap : () => new Uint8Array(config2.heap.buffer), alloc = config2.alloc, dealloc = config2.dealloc, log3 = config2.log || console.log.bind(console), memberPrefix = config2.memberPrefix || "", memberSuffix = config2.memberSuffix || "", bigIntEnabled = void 0 === config2.bigIntEnabled ? !!globalThis["BigInt64Array"] : !!config2.bigIntEnabled, BigInt2 = globalThis["BigInt"], BigInt64Array2 = globalThis["BigInt64Array"], ptrSizeof = config2.ptrSizeof || 4, ptrIR = config2.ptrIR || "i32";
        if (!SBF.debugFlags) {
          SBF.__makeDebugFlags = function(deriveFrom = null) {
            if (deriveFrom && deriveFrom.__flags)
              deriveFrom = deriveFrom.__flags;
            const f4 = function f5(flags) {
              if (0 === arguments.length) {
                return f5.__flags;
              }
              if (flags < 0) {
                delete f5.__flags.getter;
                delete f5.__flags.setter;
                delete f5.__flags.alloc;
                delete f5.__flags.dealloc;
              } else {
                f5.__flags.getter = 0 !== (1 & flags);
                f5.__flags.setter = 0 !== (2 & flags);
                f5.__flags.alloc = 0 !== (4 & flags);
                f5.__flags.dealloc = 0 !== (8 & flags);
              }
              return f5._flags;
            };
            Object.defineProperty(f4, "__flags", {
              iterable: false,
              writable: false,
              value: Object.create(deriveFrom)
            });
            if (!deriveFrom)
              f4(0);
            return f4;
          };
          SBF.debugFlags = SBF.__makeDebugFlags();
        }
        const isLittleEndian = function() {
          const buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] === 256;
        }();
        const isFuncSig = (s2) => "(" === s2[1];
        const isPtrSig = (s2) => "p" === s2 || "P" === s2;
        const isAutoPtrSig = (s2) => "P" === s2;
        const sigLetter = (s2) => isFuncSig(s2) ? "p" : s2[0];
        const sigIR = function(s2) {
          switch (sigLetter(s2)) {
            case "c":
            case "C":
              return "i8";
            case "i":
              return "i32";
            case "p":
            case "P":
            case "s":
              return ptrIR;
            case "j":
              return "i64";
            case "f":
              return "float";
            case "d":
              return "double";
          }
          toss("Unhandled signature IR:", s2);
        };
        const affirmBigIntArray = BigInt64Array2 ? () => true : () => toss("BigInt64Array is not available.");
        const sigDVGetter = function(s2) {
          switch (sigLetter(s2)) {
            case "p":
            case "P":
            case "s": {
              switch (ptrSizeof) {
                case 4:
                  return "getInt32";
                case 8:
                  return affirmBigIntArray() && "getBigInt64";
              }
              break;
            }
            case "i":
              return "getInt32";
            case "c":
              return "getInt8";
            case "C":
              return "getUint8";
            case "j":
              return affirmBigIntArray() && "getBigInt64";
            case "f":
              return "getFloat32";
            case "d":
              return "getFloat64";
          }
          toss("Unhandled DataView getter for signature:", s2);
        };
        const sigDVSetter = function(s2) {
          switch (sigLetter(s2)) {
            case "p":
            case "P":
            case "s": {
              switch (ptrSizeof) {
                case 4:
                  return "setInt32";
                case 8:
                  return affirmBigIntArray() && "setBigInt64";
              }
              break;
            }
            case "i":
              return "setInt32";
            case "c":
              return "setInt8";
            case "C":
              return "setUint8";
            case "j":
              return affirmBigIntArray() && "setBigInt64";
            case "f":
              return "setFloat32";
            case "d":
              return "setFloat64";
          }
          toss("Unhandled DataView setter for signature:", s2);
        };
        const sigDVSetWrapper = function(s2) {
          switch (sigLetter(s2)) {
            case "i":
            case "f":
            case "c":
            case "C":
            case "d":
              return Number;
            case "j":
              return affirmBigIntArray() && BigInt2;
            case "p":
            case "P":
            case "s":
              switch (ptrSizeof) {
                case 4:
                  return Number;
                case 8:
                  return affirmBigIntArray() && BigInt2;
              }
              break;
          }
          toss("Unhandled DataView set wrapper for signature:", s2);
        };
        const sPropName = (s2, k2) => s2 + "::" + k2;
        const __propThrowOnSet = function(structName, propName) {
          return () => toss(sPropName(structName, propName), "is read-only.");
        };
        const __instancePointerMap = /* @__PURE__ */ new WeakMap();
        const xPtrPropName = "(pointer-is-external)";
        const __freeStruct = function(ctor, obj, m3) {
          if (!m3)
            m3 = __instancePointerMap.get(obj);
          if (m3) {
            __instancePointerMap.delete(obj);
            if (Array.isArray(obj.ondispose)) {
              let x2;
              while (x2 = obj.ondispose.shift()) {
                try {
                  if (x2 instanceof Function)
                    x2.call(obj);
                  else if (x2 instanceof StructType)
                    x2.dispose();
                  else if ("number" === typeof x2)
                    dealloc(x2);
                } catch (e5) {
                  console.warn(
                    "ondispose() for",
                    ctor.structName,
                    "@",
                    m3,
                    "threw. NOT propagating it.",
                    e5
                  );
                }
              }
            } else if (obj.ondispose instanceof Function) {
              try {
                obj.ondispose();
              } catch (e5) {
                console.warn(
                  "ondispose() for",
                  ctor.structName,
                  "@",
                  m3,
                  "threw. NOT propagating it.",
                  e5
                );
              }
            }
            delete obj.ondispose;
            if (ctor.debugFlags.__flags.dealloc) {
              log3(
                "debug.dealloc:",
                obj[xPtrPropName] ? "EXTERNAL" : "",
                ctor.structName,
                "instance:",
                ctor.structInfo.sizeof,
                "bytes @" + m3
              );
            }
            if (!obj[xPtrPropName])
              dealloc(m3);
          }
        };
        const rop = (v3) => {
          return {
            configurable: false,
            writable: false,
            iterable: false,
            value: v3
          };
        };
        const __allocStruct = function(ctor, obj, m3) {
          let fill = !m3;
          if (m3)
            Object.defineProperty(obj, xPtrPropName, rop(m3));
          else {
            m3 = alloc(ctor.structInfo.sizeof);
            if (!m3)
              toss("Allocation of", ctor.structName, "structure failed.");
          }
          try {
            if (ctor.debugFlags.__flags.alloc) {
              log3(
                "debug.alloc:",
                fill ? "" : "EXTERNAL",
                ctor.structName,
                "instance:",
                ctor.structInfo.sizeof,
                "bytes @" + m3
              );
            }
            if (fill)
              heap().fill(0, m3, m3 + ctor.structInfo.sizeof);
            __instancePointerMap.set(obj, m3);
          } catch (e5) {
            __freeStruct(ctor, obj, m3);
            throw e5;
          }
        };
        const __memoryDump = function() {
          const p2 = this.pointer;
          return p2 ? new Uint8Array(heap().slice(p2, p2 + this.structInfo.sizeof)) : null;
        };
        const __memberKey = (k2) => memberPrefix + k2 + memberSuffix;
        const __memberKeyProp = rop(__memberKey);
        const __lookupMember = function(structInfo, memberName, tossIfNotFound = true) {
          let m3 = structInfo.members[memberName];
          if (!m3 && (memberPrefix || memberSuffix)) {
            for (const v3 of Object.values(structInfo.members)) {
              if (v3.key === memberName) {
                m3 = v3;
                break;
              }
            }
            if (!m3 && tossIfNotFound) {
              toss(
                sPropName(structInfo.name, memberName),
                "is not a mapped struct member."
              );
            }
          }
          return m3;
        };
        const __memberSignature = function f4(obj, memberName, emscriptenFormat = false) {
          if (!f4._)
            f4._ = (x2) => x2.replace(/[^vipPsjrdcC]/g, "").replace(/[pPscC]/g, "i");
          const m3 = __lookupMember(obj.structInfo, memberName, true);
          return emscriptenFormat ? f4._(m3.signature) : m3.signature;
        };
        const __ptrPropDescriptor = {
          configurable: false,
          enumerable: false,
          get: function() {
            return __instancePointerMap.get(this);
          },
          set: () => toss("Cannot assign the 'pointer' property of a struct.")
        };
        const __structMemberKeys = rop(function() {
          const a2 = [];
          for (const k2 of Object.keys(this.structInfo.members)) {
            a2.push(this.memberKey(k2));
          }
          return a2;
        });
        const __utf8Decoder = new TextDecoder("utf-8");
        const __utf8Encoder = new TextEncoder();
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const __utf8Decode = function(arrayBuffer, begin, end) {
          return __utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
          );
        };
        const __memberIsString = function(obj, memberName, tossIfNotFound = false) {
          const m3 = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
          return m3 && 1 === m3.signature.length && "s" === m3.signature[0] ? m3 : false;
        };
        const __affirmCStringSignature = function(member) {
          if ("s" === member.signature)
            return;
          toss(
            "Invalid member type signature for C-string value:",
            JSON.stringify(member)
          );
        };
        const __memberToJsString = function f4(obj, memberName) {
          const m3 = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m3);
          const addr = obj[m3.key];
          if (!addr)
            return null;
          let pos = addr;
          const mem = heap();
          for (; mem[pos] !== 0; ++pos) {
          }
          return addr === pos ? "" : __utf8Decode(mem, addr, pos);
        };
        const __addOnDispose = function(obj, ...v3) {
          if (obj.ondispose) {
            if (!Array.isArray(obj.ondispose)) {
              obj.ondispose = [obj.ondispose];
            }
          } else {
            obj.ondispose = [];
          }
          obj.ondispose.push(...v3);
        };
        const __allocCString = function(str) {
          const u2 = __utf8Encoder.encode(str);
          const mem = alloc(u2.length + 1);
          if (!mem)
            toss("Allocation error while duplicating string:", str);
          const h4 = heap();
          h4.set(u2, mem);
          h4[mem + u2.length] = 0;
          return mem;
        };
        const __setMemberCString = function(obj, memberName, str) {
          const m3 = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m3);
          const mem = __allocCString(str);
          obj[m3.key] = mem;
          __addOnDispose(obj, mem);
          return obj;
        };
        const StructType = function ctor(structName, structInfo) {
          if (arguments[2] !== rop) {
            toss(
              "Do not call the StructType constructor",
              "from client-level code."
            );
          }
          Object.defineProperties(this, {
            structName: rop(structName),
            structInfo: rop(structInfo)
          });
        };
        StructType.prototype = Object.create(null, {
          dispose: rop(function() {
            __freeStruct(this.constructor, this);
          }),
          lookupMember: rop(function(memberName, tossIfNotFound = true) {
            return __lookupMember(this.structInfo, memberName, tossIfNotFound);
          }),
          memberToJsString: rop(function(memberName) {
            return __memberToJsString(this, memberName);
          }),
          memberIsString: rop(function(memberName, tossIfNotFound = true) {
            return __memberIsString(this, memberName, tossIfNotFound);
          }),
          memberKey: __memberKeyProp,
          memberKeys: __structMemberKeys,
          memberSignature: rop(function(memberName, emscriptenFormat = false) {
            return __memberSignature(this, memberName, emscriptenFormat);
          }),
          memoryDump: rop(__memoryDump),
          pointer: __ptrPropDescriptor,
          setMemberCString: rop(function(memberName, str) {
            return __setMemberCString(this, memberName, str);
          })
        });
        Object.assign(StructType.prototype, {
          addOnDispose: function(...v3) {
            __addOnDispose(this, ...v3);
            return this;
          }
        });
        Object.defineProperties(StructType, {
          allocCString: rop(__allocCString),
          isA: rop((v3) => v3 instanceof StructType),
          hasExternalPointer: rop(
            (v3) => v3 instanceof StructType && !!v3[xPtrPropName]
          ),
          memberKey: __memberKeyProp
        });
        const isNumericValue = (v3) => Number.isFinite(v3) || v3 instanceof (BigInt2 || Number);
        const makeMemberWrapper = function f4(ctor, name, descr) {
          if (!f4._) {
            f4._ = { getters: {}, setters: {}, sw: {} };
            const a2 = ["i", "c", "C", "p", "P", "s", "f", "d", "v()"];
            if (bigIntEnabled)
              a2.push("j");
            a2.forEach(function(v3) {
              f4._.getters[v3] = sigDVGetter(v3);
              f4._.setters[v3] = sigDVSetter(v3);
              f4._.sw[v3] = sigDVSetWrapper(v3);
            });
            const rxSig1 = /^[ipPsjfdcC]$/, rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
            f4.sigCheck = function(obj, name2, key2, sig) {
              if (Object.prototype.hasOwnProperty.call(obj, key2)) {
                toss(obj.structName, "already has a property named", key2 + ".");
              }
              rxSig1.test(sig) || rxSig2.test(sig) || toss(
                "Malformed signature for",
                sPropName(obj.structName, name2) + ":",
                sig
              );
            };
          }
          const key = ctor.memberKey(name);
          f4.sigCheck(ctor.prototype, name, key, descr.signature);
          descr.key = key;
          descr.name = name;
          const sigGlyph = sigLetter(descr.signature);
          const xPropName = sPropName(ctor.prototype.structName, key);
          const dbg = ctor.prototype.debugFlags.__flags;
          const prop = /* @__PURE__ */ Object.create(null);
          prop.configurable = false;
          prop.enumerable = false;
          prop.get = function() {
            if (dbg.getter) {
              log3(
                "debug.getter:",
                f4._.getters[sigGlyph],
                "for",
                sigIR(sigGlyph),
                xPropName,
                "@",
                this.pointer,
                "+",
                descr.offset,
                "sz",
                descr.sizeof
              );
            }
            let rc = new DataView(
              heap().buffer,
              this.pointer + descr.offset,
              descr.sizeof
            )[f4._.getters[sigGlyph]](0, isLittleEndian);
            if (dbg.getter)
              log3("debug.getter:", xPropName, "result =", rc);
            return rc;
          };
          if (descr.readOnly) {
            prop.set = __propThrowOnSet(ctor.prototype.structName, key);
          } else {
            prop.set = function(v3) {
              if (dbg.setter) {
                log3(
                  "debug.setter:",
                  f4._.setters[sigGlyph],
                  "for",
                  sigIR(sigGlyph),
                  xPropName,
                  "@",
                  this.pointer,
                  "+",
                  descr.offset,
                  "sz",
                  descr.sizeof,
                  v3
                );
              }
              if (!this.pointer) {
                toss("Cannot set struct property on disposed instance.");
              }
              if (null === v3)
                v3 = 0;
              else
                while (!isNumericValue(v3)) {
                  if (isAutoPtrSig(descr.signature) && v3 instanceof StructType) {
                    v3 = v3.pointer || 0;
                    if (dbg.setter)
                      log3("debug.setter:", xPropName, "resolved to", v3);
                    break;
                  }
                  toss("Invalid value for pointer-type", xPropName + ".");
                }
              new DataView(
                heap().buffer,
                this.pointer + descr.offset,
                descr.sizeof
              )[f4._.setters[sigGlyph]](0, f4._.sw[sigGlyph](v3), isLittleEndian);
            };
          }
          Object.defineProperty(ctor.prototype, key, prop);
        };
        const StructBinder = function StructBinder2(structName, structInfo) {
          if (1 === arguments.length) {
            structInfo = structName;
            structName = structInfo.name;
          } else if (!structInfo.name) {
            structInfo.name = structName;
          }
          if (!structName)
            toss("Struct name is required.");
          let lastMember = false;
          Object.keys(structInfo.members).forEach((k2) => {
            const m3 = structInfo.members[k2];
            if (!m3.sizeof)
              toss(structName, "member", k2, "is missing sizeof.");
            else if (m3.sizeof === 1) {
              m3.signature === "c" || m3.signature === "C" || toss(
                "Unexpected sizeof==1 member",
                sPropName(structInfo.name, k2),
                "with signature",
                m3.signature
              );
            } else {
              if (0 !== m3.sizeof % 4) {
                console.warn(
                  "Invalid struct member description =",
                  m3,
                  "from",
                  structInfo
                );
                toss(
                  structName,
                  "member",
                  k2,
                  "sizeof is not aligned. sizeof=" + m3.sizeof
                );
              }
              if (0 !== m3.offset % 4) {
                console.warn(
                  "Invalid struct member description =",
                  m3,
                  "from",
                  structInfo
                );
                toss(
                  structName,
                  "member",
                  k2,
                  "offset is not aligned. offset=" + m3.offset
                );
              }
            }
            if (!lastMember || lastMember.offset < m3.offset)
              lastMember = m3;
          });
          if (!lastMember)
            toss("No member property descriptions found.");
          else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {
            toss(
              "Invalid struct config:",
              structName,
              "max member offset (" + lastMember.offset + ") ",
              "extends past end of struct (sizeof=" + structInfo.sizeof + ")."
            );
          }
          const debugFlags = rop(SBF.__makeDebugFlags(StructBinder2.debugFlags));
          const StructCtor = function StructCtor2(externalMemory) {
            if (!(this instanceof StructCtor2)) {
              toss(
                "The",
                structName,
                "constructor may only be called via 'new'."
              );
            } else if (arguments.length) {
              if (externalMemory !== (externalMemory | 0) || externalMemory <= 0) {
                toss("Invalid pointer value for", structName, "constructor.");
              }
              __allocStruct(StructCtor2, this, externalMemory);
            } else {
              __allocStruct(StructCtor2, this);
            }
          };
          Object.defineProperties(StructCtor, {
            debugFlags,
            isA: rop((v3) => v3 instanceof StructCtor),
            memberKey: __memberKeyProp,
            memberKeys: __structMemberKeys,
            methodInfoForKey: rop(function(mKey) {
            }),
            structInfo: rop(structInfo),
            structName: rop(structName)
          });
          StructCtor.prototype = new StructType(structName, structInfo, rop);
          Object.defineProperties(StructCtor.prototype, {
            debugFlags,
            constructor: rop(StructCtor)
          });
          Object.keys(structInfo.members).forEach(
            (name) => makeMemberWrapper(StructCtor, name, structInfo.members[name])
          );
          return StructCtor;
        };
        StructBinder.StructType = StructType;
        StructBinder.config = config2;
        StructBinder.allocCString = __allocCString;
        if (!StructBinder.debugFlags) {
          StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
        }
        return StructBinder;
      };
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        "use strict";
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        const toss3 = sqlite3.SQLite3Error.toss;
        const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
        globalThis.WhWasmUtilInstaller(wasm);
        delete globalThis.WhWasmUtilInstaller;
        if (0) {
          const dealloc = wasm.exports[sqlite3.config.deallocExportName];
          const nFunc = wasm.functionTable().length;
          let i3;
          for (i3 = 0; i3 < nFunc; ++i3) {
            const e5 = wasm.functionEntry(i3);
            if (dealloc === e5) {
              capi.SQLITE_WASM_DEALLOC = i3;
              break;
            }
          }
          if (dealloc !== wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              "Internal error: cannot find function pointer for SQLITE_WASM_DEALLOC."
            );
          }
        }
        wasm.bindingSignatures = [
          ["sqlite3_aggregate_context", "void*", "sqlite3_context*", "int"],
          ["sqlite3_bind_double", "int", "sqlite3_stmt*", "int", "f64"],
          ["sqlite3_bind_int", "int", "sqlite3_stmt*", "int", "int"],
          ["sqlite3_bind_null", void 0, "sqlite3_stmt*", "int"],
          ["sqlite3_bind_parameter_count", "int", "sqlite3_stmt*"],
          ["sqlite3_bind_parameter_index", "int", "sqlite3_stmt*", "string"],
          [
            "sqlite3_bind_pointer",
            "int",
            "sqlite3_stmt*",
            "int",
            "*",
            "string:static",
            "*"
          ],
          [
            "sqlite3_busy_handler",
            "int",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                signature: "i(pi)",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_busy_timeout", "int", "sqlite3*", "int"],
          ["sqlite3_changes", "int", "sqlite3*"],
          ["sqlite3_clear_bindings", "int", "sqlite3_stmt*"],
          ["sqlite3_collation_needed", "int", "sqlite3*", "*", "*"],
          ["sqlite3_column_blob", "*", "sqlite3_stmt*", "int"],
          ["sqlite3_column_bytes", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_count", "int", "sqlite3_stmt*"],
          ["sqlite3_column_double", "f64", "sqlite3_stmt*", "int"],
          ["sqlite3_column_int", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_name", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_text", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_type", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_value", "sqlite3_value*", "sqlite3_stmt*", "int"],
          [
            "sqlite3_commit_hook",
            "void*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_commit_hook",
                signature: "i(p)",
                contextKey: (argv) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_compileoption_get", "string", "int"],
          ["sqlite3_compileoption_used", "int", "string"],
          ["sqlite3_complete", "int", "string:flexible"],
          ["sqlite3_context_db_handle", "sqlite3*", "sqlite3_context*"],
          ["sqlite3_data_count", "int", "sqlite3_stmt*"],
          ["sqlite3_db_filename", "string", "sqlite3*", "string"],
          ["sqlite3_db_handle", "sqlite3*", "sqlite3_stmt*"],
          ["sqlite3_db_name", "string", "sqlite3*", "int"],
          ["sqlite3_db_status", "int", "sqlite3*", "int", "*", "*", "int"],
          ["sqlite3_errcode", "int", "sqlite3*"],
          ["sqlite3_errmsg", "string", "sqlite3*"],
          ["sqlite3_error_offset", "int", "sqlite3*"],
          ["sqlite3_errstr", "string", "int"],
          [
            "sqlite3_exec",
            "int",
            [
              "sqlite3*",
              "string:flexible",
              new wasm.xWrap.FuncPtrAdapter({
                signature: "i(pipp)",
                bindScope: "transient",
                callProxy: (callback) => {
                  let aNames;
                  return (pVoid, nCols, pColVals, pColNames) => {
                    try {
                      const aVals = wasm.cArgvToJs(nCols, pColVals);
                      if (!aNames)
                        aNames = wasm.cArgvToJs(nCols, pColNames);
                      return callback(aVals, aNames) | 0;
                    } catch (e5) {
                      return e5.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }
              }),
              "*",
              "**"
            ]
          ],
          ["sqlite3_expanded_sql", "string", "sqlite3_stmt*"],
          ["sqlite3_extended_errcode", "int", "sqlite3*"],
          ["sqlite3_extended_result_codes", "int", "sqlite3*", "int"],
          ["sqlite3_file_control", "int", "sqlite3*", "string", "int", "*"],
          ["sqlite3_finalize", "int", "sqlite3_stmt*"],
          ["sqlite3_free", void 0, "*"],
          ["sqlite3_get_autocommit", "int", "sqlite3*"],
          ["sqlite3_get_auxdata", "*", "sqlite3_context*", "int"],
          ["sqlite3_initialize", void 0],
          ["sqlite3_keyword_count", "int"],
          ["sqlite3_keyword_name", "int", ["int", "**", "*"]],
          ["sqlite3_keyword_check", "int", ["string", "int"]],
          ["sqlite3_libversion", "string"],
          ["sqlite3_libversion_number", "int"],
          ["sqlite3_limit", "int", ["sqlite3*", "int", "int"]],
          ["sqlite3_malloc", "*", "int"],
          ["sqlite3_open", "int", "string", "*"],
          ["sqlite3_open_v2", "int", "string", "*", "int", "string"],
          [
            "sqlite3_progress_handler",
            void 0,
            [
              "sqlite3*",
              "int",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xProgressHandler",
                signature: "i(p)",
                bindScope: "context",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_realloc", "*", "*", "int"],
          ["sqlite3_reset", "int", "sqlite3_stmt*"],
          [
            "sqlite3_result_blob",
            void 0,
            "sqlite3_context*",
            "*",
            "int",
            "*"
          ],
          ["sqlite3_result_double", void 0, "sqlite3_context*", "f64"],
          [
            "sqlite3_result_error",
            void 0,
            "sqlite3_context*",
            "string",
            "int"
          ],
          ["sqlite3_result_error_code", void 0, "sqlite3_context*", "int"],
          ["sqlite3_result_error_nomem", void 0, "sqlite3_context*"],
          ["sqlite3_result_error_toobig", void 0, "sqlite3_context*"],
          ["sqlite3_result_int", void 0, "sqlite3_context*", "int"],
          ["sqlite3_result_null", void 0, "sqlite3_context*"],
          [
            "sqlite3_result_pointer",
            void 0,
            "sqlite3_context*",
            "*",
            "string:static",
            "*"
          ],
          ["sqlite3_result_subtype", void 0, "sqlite3_value*", "int"],
          [
            "sqlite3_result_text",
            void 0,
            "sqlite3_context*",
            "string",
            "int",
            "*"
          ],
          ["sqlite3_result_zeroblob", void 0, "sqlite3_context*", "int"],
          [
            "sqlite3_rollback_hook",
            "void*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_rollback_hook",
                signature: "v(p)",
                contextKey: (argv) => argv[0]
              }),
              "*"
            ]
          ],
          [
            "sqlite3_set_authorizer",
            "int",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_set_authorizer::xAuth",
                signature: "i(pissss)",
                contextKey: (argv, argIndex) => argv[0],
                callProxy: (callback) => {
                  return (pV, iCode, s0, s1, s2, s3) => {
                    try {
                      s0 = s0 && wasm.cstrToJs(s0);
                      s1 = s1 && wasm.cstrToJs(s1);
                      s2 = s2 && wasm.cstrToJs(s2);
                      s3 = s3 && wasm.cstrToJs(s3);
                      return callback(pV, iCode, s0, s1, s2, s3) || 0;
                    } catch (e5) {
                      return e5.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }
              }),
              "*"
            ]
          ],
          [
            "sqlite3_set_auxdata",
            void 0,
            [
              "sqlite3_context*",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroyAuxData",
                signature: "v(*)",
                contextKey: (argv, argIndex) => argv[0]
              })
            ]
          ],
          ["sqlite3_shutdown", void 0],
          ["sqlite3_sourceid", "string"],
          ["sqlite3_sql", "string", "sqlite3_stmt*"],
          ["sqlite3_status", "int", "int", "*", "*", "int"],
          ["sqlite3_step", "int", "sqlite3_stmt*"],
          ["sqlite3_stmt_isexplain", "int", ["sqlite3_stmt*"]],
          ["sqlite3_stmt_readonly", "int", ["sqlite3_stmt*"]],
          ["sqlite3_stmt_status", "int", "sqlite3_stmt*", "int", "int"],
          ["sqlite3_strglob", "int", "string", "string"],
          ["sqlite3_stricmp", "int", "string", "string"],
          ["sqlite3_strlike", "int", "string", "string", "int"],
          ["sqlite3_strnicmp", "int", "string", "string", "int"],
          [
            "sqlite3_table_column_metadata",
            "int",
            "sqlite3*",
            "string",
            "string",
            "string",
            "**",
            "**",
            "*",
            "*",
            "*"
          ],
          ["sqlite3_total_changes", "int", "sqlite3*"],
          [
            "sqlite3_trace_v2",
            "int",
            [
              "sqlite3*",
              "int",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_trace_v2::callback",
                signature: "i(ippp)",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_txn_state", "int", ["sqlite3*", "string"]],
          ["sqlite3_uri_boolean", "int", "sqlite3_filename", "string", "int"],
          ["sqlite3_uri_key", "string", "sqlite3_filename", "int"],
          ["sqlite3_uri_parameter", "string", "sqlite3_filename", "string"],
          ["sqlite3_user_data", "void*", "sqlite3_context*"],
          ["sqlite3_value_blob", "*", "sqlite3_value*"],
          ["sqlite3_value_bytes", "int", "sqlite3_value*"],
          ["sqlite3_value_double", "f64", "sqlite3_value*"],
          ["sqlite3_value_dup", "sqlite3_value*", "sqlite3_value*"],
          ["sqlite3_value_free", void 0, "sqlite3_value*"],
          ["sqlite3_value_frombind", "int", "sqlite3_value*"],
          ["sqlite3_value_int", "int", "sqlite3_value*"],
          ["sqlite3_value_nochange", "int", "sqlite3_value*"],
          ["sqlite3_value_numeric_type", "int", "sqlite3_value*"],
          ["sqlite3_value_pointer", "*", "sqlite3_value*", "string:static"],
          ["sqlite3_value_subtype", "int", "sqlite3_value*"],
          ["sqlite3_value_text", "string", "sqlite3_value*"],
          ["sqlite3_value_type", "int", "sqlite3_value*"],
          ["sqlite3_vfs_find", "*", "string"],
          ["sqlite3_vfs_register", "int", "sqlite3_vfs*", "int"],
          ["sqlite3_vfs_unregister", "int", "sqlite3_vfs*"]
        ];
        if (false) {
          wasm.bindingSignatures.push([
            "sqlite3_normalized_sql",
            "string",
            "sqlite3_stmt*"
          ]);
        }
        wasm.bindingSignatures.int64 = [
          ["sqlite3_bind_int64", "int", ["sqlite3_stmt*", "int", "i64"]],
          ["sqlite3_changes64", "i64", ["sqlite3*"]],
          ["sqlite3_column_int64", "i64", ["sqlite3_stmt*", "int"]],
          [
            "sqlite3_create_module",
            "int",
            ["sqlite3*", "string", "sqlite3_module*", "*"]
          ],
          [
            "sqlite3_create_module_v2",
            "int",
            ["sqlite3*", "string", "sqlite3_module*", "*", "*"]
          ],
          ["sqlite3_declare_vtab", "int", ["sqlite3*", "string:flexible"]],
          [
            "sqlite3_deserialize",
            "int",
            "sqlite3*",
            "string",
            "*",
            "i64",
            "i64",
            "int"
          ],
          ["sqlite3_drop_modules", "int", ["sqlite3*", "**"]],
          ["sqlite3_last_insert_rowid", "i64", ["sqlite3*"]],
          ["sqlite3_malloc64", "*", "i64"],
          ["sqlite3_msize", "i64", "*"],
          ["sqlite3_overload_function", "int", ["sqlite3*", "string", "int"]],
          ["sqlite3_preupdate_blobwrite", "int", "sqlite3*"],
          ["sqlite3_preupdate_count", "int", "sqlite3*"],
          ["sqlite3_preupdate_depth", "int", "sqlite3*"],
          [
            "sqlite3_preupdate_hook",
            "*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_preupdate_hook",
                signature: "v(ppippjj)",
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p2, db, op, zDb, zTbl, iKey1, iKey2) => {
                    callback(
                      p2,
                      db,
                      op,
                      wasm.cstrToJs(zDb),
                      wasm.cstrToJs(zTbl),
                      iKey1,
                      iKey2
                    );
                  };
                }
              }),
              "*"
            ]
          ],
          ["sqlite3_preupdate_new", "int", ["sqlite3*", "int", "**"]],
          ["sqlite3_preupdate_old", "int", ["sqlite3*", "int", "**"]],
          ["sqlite3_realloc64", "*", "*", "i64"],
          ["sqlite3_result_int64", void 0, "*", "i64"],
          ["sqlite3_result_zeroblob64", "int", "*", "i64"],
          ["sqlite3_serialize", "*", "sqlite3*", "string", "*", "int"],
          ["sqlite3_set_last_insert_rowid", void 0, ["sqlite3*", "i64"]],
          ["sqlite3_status64", "int", "int", "*", "*", "int"],
          ["sqlite3_total_changes64", "i64", ["sqlite3*"]],
          [
            "sqlite3_update_hook",
            "*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_update_hook",
                signature: "v(iippj)",
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p2, op, z0, z1, rowid) => {
                    callback(
                      p2,
                      op,
                      wasm.cstrToJs(z0),
                      wasm.cstrToJs(z1),
                      rowid
                    );
                  };
                }
              }),
              "*"
            ]
          ],
          ["sqlite3_uri_int64", "i64", ["sqlite3_filename", "string", "i64"]],
          ["sqlite3_value_int64", "i64", "sqlite3_value*"],
          ["sqlite3_vtab_collation", "string", "sqlite3_index_info*", "int"],
          ["sqlite3_vtab_distinct", "int", "sqlite3_index_info*"],
          ["sqlite3_vtab_in", "int", "sqlite3_index_info*", "int", "int"],
          ["sqlite3_vtab_in_first", "int", "sqlite3_value*", "**"],
          ["sqlite3_vtab_in_next", "int", "sqlite3_value*", "**"],
          ["sqlite3_vtab_nochange", "int", "sqlite3_context*"],
          ["sqlite3_vtab_on_conflict", "int", "sqlite3*"],
          ["sqlite3_vtab_rhs_value", "int", "sqlite3_index_info*", "int", "**"]
        ];
        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add) {
          const __ipsProxy = {
            signature: "i(ps)",
            callProxy: (callback) => {
              return (p2, s2) => {
                try {
                  return callback(p2, wasm.cstrToJs(s2)) | 0;
                } catch (e5) {
                  return e5.resultCode || capi.SQLITE_ERROR;
                }
              };
            }
          };
          wasm.bindingSignatures.int64.push(
            ...[
              [
                "sqlite3changegroup_add",
                "int",
                ["sqlite3_changegroup*", "int", "void*"]
              ],
              [
                "sqlite3changegroup_add_strm",
                "int",
                [
                  "sqlite3_changegroup*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changegroup_delete",
                void 0,
                ["sqlite3_changegroup*"]
              ],
              ["sqlite3changegroup_new", "int", ["**"]],
              [
                "sqlite3changegroup_output",
                "int",
                ["sqlite3_changegroup*", "int*", "**"]
              ],
              [
                "sqlite3changegroup_output_strm",
                "int",
                [
                  "sqlite3_changegroup*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply",
                "int",
                [
                  "sqlite3*",
                  "int",
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply_strm",
                "int",
                [
                  "sqlite3*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply_v2",
                "int",
                [
                  "sqlite3*",
                  "int",
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "**",
                  "int*",
                  "int"
                ]
              ],
              [
                "sqlite3changeset_apply_v2_strm",
                "int",
                [
                  "sqlite3*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "**",
                  "int*",
                  "int"
                ]
              ],
              [
                "sqlite3changeset_concat",
                "int",
                ["int", "void*", "int", "void*", "int*", "**"]
              ],
              [
                "sqlite3changeset_concat_strm",
                "int",
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInputA",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInputB",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_conflict",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              ["sqlite3changeset_finalize", "int", ["sqlite3_changeset_iter*"]],
              [
                "sqlite3changeset_fk_conflicts",
                "int",
                ["sqlite3_changeset_iter*", "int*"]
              ],
              [
                "sqlite3changeset_invert",
                "int",
                ["int", "void*", "int*", "**"]
              ],
              [
                "sqlite3changeset_invert_strm",
                "int",
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_new",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              ["sqlite3changeset_next", "int", ["sqlite3_changeset_iter*"]],
              [
                "sqlite3changeset_old",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              [
                "sqlite3changeset_op",
                "int",
                ["sqlite3_changeset_iter*", "**", "int*", "int*", "int*"]
              ],
              [
                "sqlite3changeset_pk",
                "int",
                ["sqlite3_changeset_iter*", "**", "int*"]
              ],
              ["sqlite3changeset_start", "int", ["**", "int", "*"]],
              [
                "sqlite3changeset_start_strm",
                "int",
                [
                  "**",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              ["sqlite3changeset_start_v2", "int", ["**", "int", "*", "int"]],
              [
                "sqlite3changeset_start_v2_strm",
                "int",
                [
                  "**",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "int"
                ]
              ],
              ["sqlite3session_attach", "int", ["sqlite3_session*", "string"]],
              [
                "sqlite3session_changeset",
                "int",
                ["sqlite3_session*", "int*", "**"]
              ],
              ["sqlite3session_changeset_size", "i64", ["sqlite3_session*"]],
              [
                "sqlite3session_changeset_strm",
                "int",
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              ["sqlite3session_config", "int", ["int", "void*"]],
              ["sqlite3session_create", "int", ["sqlite3*", "string", "**"]],
              [
                "sqlite3session_diff",
                "int",
                ["sqlite3_session*", "string", "string", "**"]
              ],
              ["sqlite3session_enable", "int", ["sqlite3_session*", "int"]],
              ["sqlite3session_indirect", "int", ["sqlite3_session*", "int"]],
              ["sqlite3session_isempty", "int", ["sqlite3_session*"]],
              ["sqlite3session_memory_used", "i64", ["sqlite3_session*"]],
              [
                "sqlite3session_object_config",
                "int",
                ["sqlite3_session*", "int", "void*"]
              ],
              [
                "sqlite3session_patchset",
                "int",
                ["sqlite3_session*", "*", "**"]
              ],
              [
                "sqlite3session_patchset_strm",
                "int",
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3session_table_filter",
                void 0,
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    ...__ipsProxy,
                    contextKey: (argv, argIndex) => argv[0]
                  }),
                  "*"
                ]
              ]
            ]
          );
        }
        wasm.bindingSignatures.wasmInternal = [
          ["sqlite3__wasm_db_reset", "int", "sqlite3*"],
          ["sqlite3__wasm_db_vfs", "sqlite3_vfs*", "sqlite3*", "string"],
          [
            "sqlite3__wasm_vfs_create_file",
            "int",
            "sqlite3_vfs*",
            "string",
            "*",
            "int"
          ],
          ["sqlite3__wasm_posix_create_file", "int", "string", "*", "int"],
          ["sqlite3__wasm_vfs_unlink", "int", "sqlite3_vfs*", "string"],
          ["sqlite3__wasm_qfmt_token", "string:dealloc", "string", "int"]
        ];
        sqlite3.StructBinder = globalThis.Jaccwabyt({
          heap: 0 ? wasm.memory : wasm.heap8u,
          alloc: wasm.alloc,
          dealloc: wasm.dealloc,
          bigIntEnabled: wasm.bigIntEnabled,
          memberPrefix: "$"
        });
        delete globalThis.Jaccwabyt;
        {
          const __xString = wasm.xWrap.argAdapter("string");
          wasm.xWrap.argAdapter(
            "string:flexible",
            (v3) => __xString(util.flexibleString(v3))
          );
          wasm.xWrap.argAdapter(
            "string:static",
            function(v3) {
              if (wasm.isPtr(v3))
                return v3;
              v3 = "" + v3;
              let rc = this[v3];
              return rc || (this[v3] = wasm.allocCString(v3));
            }.bind(/* @__PURE__ */ Object.create(null))
          );
          const __xArgPtr = wasm.xWrap.argAdapter("*");
          const nilType = function() {
          };
          wasm.xWrap.argAdapter("sqlite3_filename", __xArgPtr)(
            "sqlite3_context*",
            __xArgPtr
          )("sqlite3_value*", __xArgPtr)("void*", __xArgPtr)(
            "sqlite3_changegroup*",
            __xArgPtr
          )("sqlite3_changeset_iter*", __xArgPtr)(
            "sqlite3_session*",
            __xArgPtr
          )(
            "sqlite3_stmt*",
            (v3) => __xArgPtr(
              v3 instanceof (sqlite3?.oo1?.Stmt || nilType) ? v3.pointer : v3
            )
          )(
            "sqlite3*",
            (v3) => __xArgPtr(
              v3 instanceof (sqlite3?.oo1?.DB || nilType) ? v3.pointer : v3
            )
          )(
            "sqlite3_index_info*",
            (v3) => __xArgPtr(
              v3 instanceof (capi.sqlite3_index_info || nilType) ? v3.pointer : v3
            )
          )(
            "sqlite3_module*",
            (v3) => __xArgPtr(
              v3 instanceof (capi.sqlite3_module || nilType) ? v3.pointer : v3
            )
          )("sqlite3_vfs*", (v3) => {
            if ("string" === typeof v3) {
              return capi.sqlite3_vfs_find(v3) || sqlite3.SQLite3Error.toss(
                capi.SQLITE_NOTFOUND,
                "Unknown sqlite3_vfs name:",
                v3
              );
            }
            return __xArgPtr(
              v3 instanceof (capi.sqlite3_vfs || nilType) ? v3.pointer : v3
            );
          });
          const __xRcPtr = wasm.xWrap.resultAdapter("*");
          wasm.xWrap.resultAdapter("sqlite3*", __xRcPtr)(
            "sqlite3_context*",
            __xRcPtr
          )("sqlite3_stmt*", __xRcPtr)("sqlite3_value*", __xRcPtr)(
            "sqlite3_vfs*",
            __xRcPtr
          )("void*", __xRcPtr);
          if (0 === wasm.exports.sqlite3_step.length) {
            wasm.xWrap.doArgcCheck = false;
            sqlite3.config.warn(
              "Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks."
            );
          }
          for (const e5 of wasm.bindingSignatures) {
            capi[e5[0]] = wasm.xWrap.apply(null, e5);
          }
          for (const e5 of wasm.bindingSignatures.wasmInternal) {
            util[e5[0]] = wasm.xWrap.apply(null, e5);
          }
          const fI64Disabled = function(fname) {
            return () => toss(
              fname + "() is unavailable due to lack",
              "of BigInt support in this build."
            );
          };
          for (const e5 of wasm.bindingSignatures.int64) {
            capi[e5[0]] = wasm.bigIntEnabled ? wasm.xWrap.apply(null, e5) : fI64Disabled(e5[0]);
          }
          delete wasm.bindingSignatures;
          if (wasm.exports.sqlite3__wasm_db_error) {
            const __db_err = wasm.xWrap(
              "sqlite3__wasm_db_error",
              "int",
              "sqlite3*",
              "int",
              "string"
            );
            util.sqlite3__wasm_db_error = function(pDb2, resultCode, message) {
              if (resultCode instanceof sqlite3.WasmAllocError) {
                resultCode = capi.SQLITE_NOMEM;
                message = 0;
              } else if (resultCode instanceof Error) {
                message = message || "" + resultCode;
                resultCode = resultCode.resultCode || capi.SQLITE_ERROR;
              }
              return pDb2 ? __db_err(pDb2, resultCode, message) : resultCode;
            };
          } else {
            util.sqlite3__wasm_db_error = function(pDb2, errCode, msg) {
              console.warn(
                "sqlite3__wasm_db_error() is not exported.",
                arguments
              );
              return errCode;
            };
          }
        }
        {
          const cJson = wasm.xCall("sqlite3__wasm_enum_json");
          if (!cJson) {
            toss(
              "Maintenance required: increase sqlite3__wasm_enum_json()'s",
              "static buffer size!"
            );
          }
          wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));
          const defineGroups = [
            "access",
            "authorizer",
            "blobFinalizers",
            "changeset",
            "config",
            "dataTypes",
            "dbConfig",
            "dbStatus",
            "encodings",
            "fcntl",
            "flock",
            "ioCap",
            "limits",
            "openFlags",
            "prepareFlags",
            "resultCodes",
            "sqlite3Status",
            "stmtStatus",
            "syncFlags",
            "trace",
            "txnState",
            "udfFlags",
            "version"
          ];
          if (wasm.bigIntEnabled) {
            defineGroups.push("serialize", "session", "vtab");
          }
          for (const t4 of defineGroups) {
            for (const e5 of Object.entries(wasm.ctype[t4])) {
              capi[e5[0]] = e5[1];
            }
          }
          if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              "Internal error: cannot resolve exported function",
              "entry SQLITE_WASM_DEALLOC (==" + capi.SQLITE_WASM_DEALLOC + ")."
            );
          }
          const __rcMap = /* @__PURE__ */ Object.create(null);
          for (const t4 of ["resultCodes"]) {
            for (const e5 of Object.entries(wasm.ctype[t4])) {
              __rcMap[e5[1]] = e5[0];
            }
          }
          capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];
          const notThese = Object.assign(/* @__PURE__ */ Object.create(null), {
            WasmTestStruct: true,
            sqlite3_kvvfs_methods: !util.isUIThread(),
            sqlite3_index_info: !wasm.bigIntEnabled,
            sqlite3_index_constraint: !wasm.bigIntEnabled,
            sqlite3_index_orderby: !wasm.bigIntEnabled,
            sqlite3_index_constraint_usage: !wasm.bigIntEnabled
          });
          for (const s2 of wasm.ctype.structs) {
            if (!notThese[s2.name]) {
              capi[s2.name] = sqlite3.StructBinder(s2);
            }
          }
          if (capi.sqlite3_index_info) {
            for (const k2 of [
              "sqlite3_index_constraint",
              "sqlite3_index_orderby",
              "sqlite3_index_constraint_usage"
            ]) {
              capi.sqlite3_index_info[k2] = capi[k2];
              delete capi[k2];
            }
            capi.sqlite3_vtab_config = wasm.xWrap(
              "sqlite3__wasm_vtab_config",
              "int",
              ["sqlite3*", "int", "int"]
            );
          }
        }
        const __dbArgcMismatch = (pDb2, f4, n5) => {
          return util.sqlite3__wasm_db_error(
            pDb2,
            capi.SQLITE_MISUSE,
            f4 + "() requires " + n5 + " argument" + (1 === n5 ? "" : "s") + "."
          );
        };
        const __errEncoding = (pDb2) => {
          return util.sqlite3__wasm_db_error(
            pDb2,
            capi.SQLITE_FORMAT,
            "SQLITE_UTF8 is the only supported encoding."
          );
        };
        const __argPDb = (pDb2) => wasm.xWrap.argAdapter("sqlite3*")(pDb2);
        const __argStr = (str) => wasm.isPtr(str) ? wasm.cstrToJs(str) : str;
        const __dbCleanupMap = function(pDb2, mode) {
          pDb2 = __argPDb(pDb2);
          let m3 = this.dbMap.get(pDb2);
          if (!mode) {
            this.dbMap.delete(pDb2);
            return m3;
          } else if (!m3 && mode > 0) {
            this.dbMap.set(pDb2, m3 = /* @__PURE__ */ Object.create(null));
          }
          return m3;
        }.bind(
          Object.assign(/* @__PURE__ */ Object.create(null), {
            dbMap: /* @__PURE__ */ new Map()
          })
        );
        __dbCleanupMap.addCollation = function(pDb2, name) {
          const m3 = __dbCleanupMap(pDb2, 1);
          if (!m3.collation)
            m3.collation = /* @__PURE__ */ new Set();
          m3.collation.add(__argStr(name).toLowerCase());
        };
        __dbCleanupMap._addUDF = function(pDb2, name, arity, map) {
          name = __argStr(name).toLowerCase();
          let u2 = map.get(name);
          if (!u2)
            map.set(name, u2 = /* @__PURE__ */ new Set());
          u2.add(arity < 0 ? -1 : arity);
        };
        __dbCleanupMap.addFunction = function(pDb2, name, arity) {
          const m3 = __dbCleanupMap(pDb2, 1);
          if (!m3.udf)
            m3.udf = /* @__PURE__ */ new Map();
          this._addUDF(pDb2, name, arity, m3.udf);
        };
        __dbCleanupMap.addWindowFunc = function(pDb2, name, arity) {
          const m3 = __dbCleanupMap(pDb2, 1);
          if (!m3.wudf)
            m3.wudf = /* @__PURE__ */ new Map();
          this._addUDF(pDb2, name, arity, m3.wudf);
        };
        __dbCleanupMap.cleanup = function(pDb2) {
          pDb2 = __argPDb(pDb2);
          const closeArgs = [pDb2];
          for (const name of [
            "sqlite3_busy_handler",
            "sqlite3_commit_hook",
            "sqlite3_preupdate_hook",
            "sqlite3_progress_handler",
            "sqlite3_rollback_hook",
            "sqlite3_set_authorizer",
            "sqlite3_trace_v2",
            "sqlite3_update_hook"
          ]) {
            const x2 = wasm.exports[name];
            closeArgs.length = x2.length;
            try {
              capi[name](...closeArgs);
            } catch (e5) {
              console.warn(
                "close-time call of",
                name + "(",
                closeArgs,
                ") threw:",
                e5
              );
            }
          }
          const m3 = __dbCleanupMap(pDb2, 0);
          if (!m3)
            return;
          if (m3.collation) {
            for (const name of m3.collation) {
              try {
                capi.sqlite3_create_collation_v2(
                  pDb2,
                  name,
                  capi.SQLITE_UTF8,
                  0,
                  0,
                  0
                );
              } catch (e5) {
              }
            }
            delete m3.collation;
          }
          let i3;
          for (i3 = 0; i3 < 2; ++i3) {
            const fmap = i3 ? m3.wudf : m3.udf;
            if (!fmap)
              continue;
            const func = i3 ? capi.sqlite3_create_window_function : capi.sqlite3_create_function_v2;
            for (const e5 of fmap) {
              const name = e5[0], arities = e5[1];
              const fargs = [pDb2, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
              if (i3)
                fargs.push(0);
              for (const arity of arities) {
                try {
                  fargs[2] = arity;
                  func.apply(null, fargs);
                } catch (e6) {
                }
              }
              arities.clear();
            }
            fmap.clear();
          }
          delete m3.udf;
          delete m3.wudf;
        };
        {
          const __sqlite3CloseV2 = wasm.xWrap(
            "sqlite3_close_v2",
            "int",
            "sqlite3*"
          );
          capi.sqlite3_close_v2 = function(pDb2) {
            if (1 !== arguments.length)
              return __dbArgcMismatch(pDb2, "sqlite3_close_v2", 1);
            if (pDb2) {
              try {
                __dbCleanupMap.cleanup(pDb2);
              } catch (e5) {
              }
            }
            return __sqlite3CloseV2(pDb2);
          };
        }
        if (capi.sqlite3session_table_filter) {
          const __sqlite3SessionDelete = wasm.xWrap(
            "sqlite3session_delete",
            void 0,
            ["sqlite3_session*"]
          );
          capi.sqlite3session_delete = function(pSession) {
            if (1 !== arguments.length) {
              return __dbArgcMismatch(pDb, "sqlite3session_delete", 1);
            } else if (pSession) {
              capi.sqlite3session_table_filter(pSession, 0, 0);
            }
            __sqlite3SessionDelete(pSession);
          };
        }
        {
          const contextKey = (argv, argIndex) => {
            return "argv[" + argIndex + "]:" + argv[0] + ":" + wasm.cstrToJs(argv[1]).toLowerCase();
          };
          const __sqlite3CreateCollationV2 = wasm.xWrap(
            "sqlite3_create_collation_v2",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xCompare",
                signature: "i(pipip)",
                contextKey
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                signature: "v(p)",
                contextKey
              })
            ]
          );
          capi.sqlite3_create_collation_v2 = function(pDb2, zName, eTextRep, pArg, xCompare, xDestroy) {
            if (6 !== arguments.length)
              return __dbArgcMismatch(pDb2, "sqlite3_create_collation_v2", 6);
            else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateCollationV2(
                pDb2,
                zName,
                eTextRep,
                pArg,
                xCompare,
                xDestroy
              );
              if (0 === rc && xCompare instanceof Function) {
                __dbCleanupMap.addCollation(pDb2, zName);
              }
              return rc;
            } catch (e5) {
              return util.sqlite3__wasm_db_error(pDb2, e5);
            }
          };
          capi.sqlite3_create_collation = (pDb2, zName, eTextRep, pArg, xCompare) => {
            return 5 === arguments.length ? capi.sqlite3_create_collation_v2(
              pDb2,
              zName,
              eTextRep,
              pArg,
              xCompare,
              0
            ) : __dbArgcMismatch(pDb2, "sqlite3_create_collation", 5);
          };
        }
        {
          const contextKey = function(argv, argIndex) {
            return argv[0] + ":" + (argv[2] < 0 ? -1 : argv[2]) + ":" + argIndex + ":" + wasm.cstrToJs(argv[1]).toLowerCase();
          };
          const __cfProxy = Object.assign(/* @__PURE__ */ Object.create(null), {
            xInverseAndStep: {
              signature: "v(pip)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));
                  } catch (e5) {
                    capi.sqlite3_result_error_js(pCtx, e5);
                  }
                };
              }
            },
            xFinalAndValue: {
              signature: "v(p)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx) => {
                  try {
                    capi.sqlite3_result_js(pCtx, callback(pCtx));
                  } catch (e5) {
                    capi.sqlite3_result_error_js(pCtx, e5);
                  }
                };
              }
            },
            xFunc: {
              signature: "v(pip)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    capi.sqlite3_result_js(
                      pCtx,
                      callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))
                    );
                  } catch (e5) {
                    capi.sqlite3_result_error_js(pCtx, e5);
                  }
                };
              }
            },
            xDestroy: {
              signature: "v(p)",
              contextKey,
              callProxy: (callback) => {
                return (pVoid) => {
                  try {
                    callback(pVoid);
                  } catch (e5) {
                    console.error("UDF xDestroy method threw:", e5);
                  }
                };
              }
            }
          });
          const __sqlite3CreateFunction = wasm.xWrap(
            "sqlite3_create_function_v2",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFunc",
                ...__cfProxy.xFunc
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xStep",
                ...__cfProxy.xInverseAndStep
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFinal",
                ...__cfProxy.xFinalAndValue
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                ...__cfProxy.xDestroy
              })
            ]
          );
          const __sqlite3CreateWindowFunction = wasm.xWrap(
            "sqlite3_create_window_function",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xStep",
                ...__cfProxy.xInverseAndStep
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFinal",
                ...__cfProxy.xFinalAndValue
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xValue",
                ...__cfProxy.xFinalAndValue
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xInverse",
                ...__cfProxy.xInverseAndStep
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                ...__cfProxy.xDestroy
              })
            ]
          );
          capi.sqlite3_create_function_v2 = function f4(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) {
            if (f4.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb2,
                "sqlite3_create_function_v2",
                f4.length
              );
            } else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateFunction(
                pDb2,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
                xDestroy
              );
              if (0 === rc && (xFunc instanceof Function || xStep instanceof Function || xFinal instanceof Function || xDestroy instanceof Function)) {
                __dbCleanupMap.addFunction(pDb2, funcName, nArg);
              }
              return rc;
            } catch (e5) {
              console.error("sqlite3_create_function_v2() setup threw:", e5);
              return util.sqlite3__wasm_db_error(
                pDb2,
                e5,
                "Creation of UDF threw: " + e5
              );
            }
          };
          capi.sqlite3_create_function = function f4(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
            return f4.length === arguments.length ? capi.sqlite3_create_function_v2(
              pDb2,
              funcName,
              nArg,
              eTextRep,
              pApp,
              xFunc,
              xStep,
              xFinal,
              0
            ) : __dbArgcMismatch(pDb2, "sqlite3_create_function", f4.length);
          };
          capi.sqlite3_create_window_function = function f4(pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) {
            if (f4.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb2,
                "sqlite3_create_window_function",
                f4.length
              );
            } else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateWindowFunction(
                pDb2,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy
              );
              if (0 === rc && (xStep instanceof Function || xFinal instanceof Function || xValue instanceof Function || xInverse instanceof Function || xDestroy instanceof Function)) {
                __dbCleanupMap.addWindowFunc(pDb2, funcName, nArg);
              }
              return rc;
            } catch (e5) {
              console.error("sqlite3_create_window_function() setup threw:", e5);
              return util.sqlite3__wasm_db_error(
                pDb2,
                e5,
                "Creation of UDF threw: " + e5
              );
            }
          };
          capi.sqlite3_create_function_v2.udfSetResult = capi.sqlite3_create_function.udfSetResult = capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;
          capi.sqlite3_create_function_v2.udfConvertArgs = capi.sqlite3_create_function.udfConvertArgs = capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;
          capi.sqlite3_create_function_v2.udfSetError = capi.sqlite3_create_function.udfSetError = capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;
        }
        {
          const __flexiString = (v3, n5) => {
            if ("string" === typeof v3) {
              n5 = -1;
            } else if (util.isSQLableTypedArray(v3)) {
              n5 = v3.byteLength;
              v3 = util.typedArrayToString(
                v3 instanceof ArrayBuffer ? new Uint8Array(v3) : v3
              );
            } else if (Array.isArray(v3)) {
              v3 = v3.join("");
              n5 = -1;
            }
            return [v3, n5];
          };
          const __prepare = {
            basic: wasm.xWrap("sqlite3_prepare_v3", "int", [
              "sqlite3*",
              "string",
              "int",
              "int",
              "**",
              "**"
            ]),
            full: wasm.xWrap("sqlite3_prepare_v3", "int", [
              "sqlite3*",
              "*",
              "int",
              "int",
              "**",
              "**"
            ])
          };
          capi.sqlite3_prepare_v3 = function f4(pDb2, sql, sqlLen, prepFlags, ppStmt, pzTail) {
            if (f4.length !== arguments.length) {
              return __dbArgcMismatch(pDb2, "sqlite3_prepare_v3", f4.length);
            }
            const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
            switch (typeof xSql) {
              case "string":
                return __prepare.basic(
                  pDb2,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  null
                );
              case "number":
                return __prepare.full(
                  pDb2,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  pzTail
                );
              default:
                return util.sqlite3__wasm_db_error(
                  pDb2,
                  capi.SQLITE_MISUSE,
                  "Invalid SQL argument type for sqlite3_prepare_v2/v3()."
                );
            }
          };
          capi.sqlite3_prepare_v2 = function f4(pDb2, sql, sqlLen, ppStmt, pzTail) {
            return f4.length === arguments.length ? capi.sqlite3_prepare_v3(pDb2, sql, sqlLen, 0, ppStmt, pzTail) : __dbArgcMismatch(pDb2, "sqlite3_prepare_v2", f4.length);
          };
        }
        {
          const __bindText = wasm.xWrap("sqlite3_bind_text", "int", [
            "sqlite3_stmt*",
            "int",
            "string",
            "int",
            "*"
          ]);
          const __bindBlob = wasm.xWrap("sqlite3_bind_blob", "int", [
            "sqlite3_stmt*",
            "int",
            "*",
            "int",
            "*"
          ]);
          capi.sqlite3_bind_text = function f4(pStmt, iCol, text, nText, xDestroy) {
            if (f4.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                "sqlite3_bind_text",
                f4.length
              );
            } else if (wasm.isPtr(text) || null === text) {
              return __bindText(pStmt, iCol, text, nText, xDestroy);
            } else if (text instanceof ArrayBuffer) {
              text = new Uint8Array(text);
            } else if (Array.isArray(pMem)) {
              text = pMem.join("");
            }
            let p2, n5;
            try {
              if (util.isSQLableTypedArray(text)) {
                p2 = wasm.allocFromTypedArray(text);
                n5 = text.byteLength;
              } else if ("string" === typeof text) {
                [p2, n5] = wasm.allocCString(text);
              } else {
                return util.sqlite3__wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  "Invalid 3rd argument type for sqlite3_bind_text()."
                );
              }
              return __bindText(pStmt, iCol, p2, n5, capi.SQLITE_WASM_DEALLOC);
            } catch (e5) {
              wasm.dealloc(p2);
              return util.sqlite3__wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e5
              );
            }
          };
          capi.sqlite3_bind_blob = function f4(pStmt, iCol, pMem2, nMem, xDestroy) {
            if (f4.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                "sqlite3_bind_blob",
                f4.length
              );
            } else if (wasm.isPtr(pMem2) || null === pMem2) {
              return __bindBlob(pStmt, iCol, pMem2, nMem, xDestroy);
            } else if (pMem2 instanceof ArrayBuffer) {
              pMem2 = new Uint8Array(pMem2);
            } else if (Array.isArray(pMem2)) {
              pMem2 = pMem2.join("");
            }
            let p2, n5;
            try {
              if (util.isBindableTypedArray(pMem2)) {
                p2 = wasm.allocFromTypedArray(pMem2);
                n5 = nMem >= 0 ? nMem : pMem2.byteLength;
              } else if ("string" === typeof pMem2) {
                [p2, n5] = wasm.allocCString(pMem2);
              } else {
                return util.sqlite3__wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  "Invalid 3rd argument type for sqlite3_bind_blob()."
                );
              }
              return __bindBlob(pStmt, iCol, p2, n5, capi.SQLITE_WASM_DEALLOC);
            } catch (e5) {
              wasm.dealloc(p2);
              return util.sqlite3__wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e5
              );
            }
          };
        }
        {
          capi.sqlite3_config = function(op, ...args) {
            if (arguments.length < 2)
              return capi.SQLITE_MISUSE;
            switch (op) {
              case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:
              case capi.SQLITE_CONFIG_MEMSTATUS:
              case capi.SQLITE_CONFIG_SMALL_MALLOC:
              case capi.SQLITE_CONFIG_SORTERREF_SIZE:
              case capi.SQLITE_CONFIG_STMTJRNL_SPILL:
              case capi.SQLITE_CONFIG_URI:
                return wasm.exports.sqlite3__wasm_config_i(op, args[0]);
              case capi.SQLITE_CONFIG_LOOKASIDE:
                return wasm.exports.sqlite3__wasm_config_ii(
                  op,
                  args[0],
                  args[1]
                );
              case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:
                return wasm.exports.sqlite3__wasm_config_j(op, args[0]);
              case capi.SQLITE_CONFIG_GETMALLOC:
              case capi.SQLITE_CONFIG_GETMUTEX:
              case capi.SQLITE_CONFIG_GETPCACHE2:
              case capi.SQLITE_CONFIG_GETPCACHE:
              case capi.SQLITE_CONFIG_HEAP:
              case capi.SQLITE_CONFIG_LOG:
              case capi.SQLITE_CONFIG_MALLOC:
              case capi.SQLITE_CONFIG_MMAP_SIZE:
              case capi.SQLITE_CONFIG_MULTITHREAD:
              case capi.SQLITE_CONFIG_MUTEX:
              case capi.SQLITE_CONFIG_PAGECACHE:
              case capi.SQLITE_CONFIG_PCACHE2:
              case capi.SQLITE_CONFIG_PCACHE:
              case capi.SQLITE_CONFIG_PCACHE_HDRSZ:
              case capi.SQLITE_CONFIG_PMASZ:
              case capi.SQLITE_CONFIG_SERIALIZED:
              case capi.SQLITE_CONFIG_SINGLETHREAD:
              case capi.SQLITE_CONFIG_SQLLOG:
              case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:
              default:
                return capi.SQLITE_NOTFOUND;
            }
          };
        }
        {
          const __autoExtFptr = /* @__PURE__ */ new Set();
          capi.sqlite3_auto_extension = function(fPtr) {
            if (fPtr instanceof Function) {
              fPtr = wasm.installFunction("i(ppp)", fPtr);
            } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {
              return capi.SQLITE_MISUSE;
            }
            const rc = wasm.exports.sqlite3_auto_extension(fPtr);
            if (fPtr !== arguments[0]) {
              if (0 === rc)
                __autoExtFptr.add(fPtr);
              else
                wasm.uninstallFunction(fPtr);
            }
            return rc;
          };
          capi.sqlite3_cancel_auto_extension = function(fPtr) {
            if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr))
              return 0;
            return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
          };
          capi.sqlite3_reset_auto_extension = function() {
            wasm.exports.sqlite3_reset_auto_extension();
            for (const fp of __autoExtFptr)
              wasm.uninstallFunction(fp);
            __autoExtFptr.clear();
          };
        }
        const pKvvfs = capi.sqlite3_vfs_find("kvvfs");
        if (pKvvfs) {
          if (util.isUIThread()) {
            const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
              wasm.exports.sqlite3__wasm_kvvfs_methods()
            );
            delete capi.sqlite3_kvvfs_methods;
            const kvvfsMakeKey = wasm.exports.sqlite3__wasm_kvvfsMakeKeyOnPstack, pstack = wasm.pstack;
            const kvvfsStorage = (zClass) => 115 === wasm.peek(zClass) ? sessionStorage : localStorage;
            const kvvfsImpls = {
              xRead: (zClass, zKey, zBuf, nBuf) => {
                const stack = pstack.pointer, astack = wasm.scopedAllocPush();
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return -3;
                  const jKey = wasm.cstrToJs(zXKey);
                  const jV = kvvfsStorage(zClass).getItem(jKey);
                  if (!jV)
                    return -1;
                  const nV = jV.length;
                  if (nBuf <= 0)
                    return nV;
                  else if (1 === nBuf) {
                    wasm.poke(zBuf, 0);
                    return nV;
                  }
                  const zV = wasm.scopedAllocCString(jV);
                  if (nBuf > nV + 1)
                    nBuf = nV + 1;
                  wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
                  wasm.poke(zBuf + nBuf - 1, 0);
                  return nBuf - 1;
                } catch (e5) {
                  console.error("kvstorageRead()", e5);
                  return -2;
                } finally {
                  pstack.restore(stack);
                  wasm.scopedAllocPop(astack);
                }
              },
              xWrite: (zClass, zKey, zData) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return 1;
                  const jKey = wasm.cstrToJs(zXKey);
                  kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
                  return 0;
                } catch (e5) {
                  console.error("kvstorageWrite()", e5);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              },
              xDelete: (zClass, zKey) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return 1;
                  kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
                  return 0;
                } catch (e5) {
                  console.error("kvstorageDelete()", e5);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              }
            };
            for (const k2 of Object.keys(kvvfsImpls)) {
              kvvfsMethods[kvvfsMethods.memberKey(k2)] = wasm.installFunction(
                kvvfsMethods.memberSignature(k2),
                kvvfsImpls[k2]
              );
            }
          } else {
            capi.sqlite3_vfs_unregister(pKvvfs);
          }
        }
        wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
        const StructBinder = sqlite3.StructBinder;
        const installMethod = function callee2(tgt, name, func, applyArgcCheck = callee2.installMethodArgcCheck) {
          if (!(tgt instanceof StructBinder.StructType)) {
            toss("Usage error: target object is-not-a StructType.");
          } else if (!(func instanceof Function) && !wasm.isPtr(func)) {
            toss("Usage errror: expecting a Function or WASM pointer to one.");
          }
          if (1 === arguments.length) {
            return (n5, f4) => callee2(tgt, n5, f4, applyArgcCheck);
          }
          if (!callee2.argcProxy) {
            callee2.argcProxy = function(tgt2, funcName, func2, sig) {
              return function(...args) {
                if (func2.length !== arguments.length) {
                  toss(
                    "Argument mismatch for",
                    tgt2.structInfo.name + "::" + funcName + ": Native signature is:",
                    sig
                  );
                }
                return func2.apply(this, args);
              };
            };
            callee2.removeFuncList = function() {
              if (this.ondispose.__removeFuncList) {
                this.ondispose.__removeFuncList.forEach((v3, ndx) => {
                  if ("number" === typeof v3) {
                    try {
                      wasm.uninstallFunction(v3);
                    } catch (e5) {
                    }
                  }
                });
                delete this.ondispose.__removeFuncList;
              }
            };
          }
          const sigN = tgt.memberSignature(name);
          if (sigN.length < 2) {
            toss(
              "Member",
              name,
              "does not have a function pointer signature:",
              sigN
            );
          }
          const memKey = tgt.memberKey(name);
          const fProxy = applyArgcCheck && !wasm.isPtr(func) ? callee2.argcProxy(tgt, memKey, func, sigN) : func;
          if (wasm.isPtr(fProxy)) {
            if (fProxy && !wasm.functionEntry(fProxy)) {
              toss("Pointer", fProxy, "is not a WASM function table entry.");
            }
            tgt[memKey] = fProxy;
          } else {
            const pFunc = wasm.installFunction(
              fProxy,
              tgt.memberSignature(name, true)
            );
            tgt[memKey] = pFunc;
            if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {
              tgt.addOnDispose(
                "ondispose.__removeFuncList handler",
                callee2.removeFuncList
              );
              tgt.ondispose.__removeFuncList = [];
            }
            tgt.ondispose.__removeFuncList.push(memKey, pFunc);
          }
          return (n5, f4) => callee2(tgt, n5, f4, applyArgcCheck);
        };
        installMethod.installMethodArgcCheck = false;
        const installMethods = function(structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
          const seen = /* @__PURE__ */ new Map();
          for (const k2 of Object.keys(methods)) {
            const m3 = methods[k2];
            const prior = seen.get(m3);
            if (prior) {
              const mkey = structInstance.memberKey(k2);
              structInstance[mkey] = structInstance[structInstance.memberKey(prior)];
            } else {
              installMethod(structInstance, k2, m3, applyArgcCheck);
              seen.set(m3, k2);
            }
          }
          return structInstance;
        };
        StructBinder.StructType.prototype.installMethod = function callee2(name, func, applyArgcCheck = installMethod.installMethodArgcCheck) {
          return arguments.length < 3 && name && "object" === typeof name ? installMethods(this, ...arguments) : installMethod(this, ...arguments);
        };
        StructBinder.StructType.prototype.installMethods = function(methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
          return installMethods(this, methods, applyArgcCheck);
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        sqlite3.version = {
          libVersion: "3.46.0",
          libVersionNumber: 3046e3,
          sourceId: "2024-05-23 13:25:27 96c92aba00c8375bc32fafcdf12429c58bd8aabfcadab6683e35bbb9cdebf19e",
          downloadVersion: 346e4
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        const toss3 = (...args) => {
          throw new sqlite3.SQLite3Error(...args);
        };
        const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
        const __ptrMap = /* @__PURE__ */ new WeakMap();
        const __stmtMap = /* @__PURE__ */ new WeakMap();
        const getOwnOption = (opts, p2, dflt) => {
          const d2 = Object.getOwnPropertyDescriptor(opts, p2);
          return d2 ? d2.value : dflt;
        };
        const checkSqlite3Rc = function(dbPtr, sqliteResultCode) {
          if (sqliteResultCode) {
            if (dbPtr instanceof DB)
              dbPtr = dbPtr.pointer;
            toss3(
              sqliteResultCode,
              "sqlite3 result code",
              sqliteResultCode + ":",
              dbPtr ? capi.sqlite3_errmsg(dbPtr) : capi.sqlite3_errstr(sqliteResultCode)
            );
          }
          return arguments[0];
        };
        const __dbTraceToConsole = wasm.installFunction(
          "i(ippp)",
          function(t4, c4, p2, x2) {
            if (capi.SQLITE_TRACE_STMT === t4) {
              console.log(
                "SQL TRACE #" + ++this.counter + " via sqlite3@" + c4 + ":",
                wasm.cstrToJs(x2)
              );
            }
          }.bind({ counter: 0 })
        );
        const __vfsPostOpenSql = /* @__PURE__ */ Object.create(null);
        const dbCtorHelper = function ctor(...args) {
          if (!ctor._name2vfs) {
            ctor._name2vfs = /* @__PURE__ */ Object.create(null);
            const isWorkerThread = "function" === typeof importScripts ? (n5) => toss3(
              "The VFS for",
              n5,
              "is only available in the main window thread."
            ) : false;
            ctor._name2vfs[":localStorage:"] = {
              vfs: "kvvfs",
              filename: isWorkerThread || (() => "local")
            };
            ctor._name2vfs[":sessionStorage:"] = {
              vfs: "kvvfs",
              filename: isWorkerThread || (() => "session")
            };
          }
          const opt = ctor.normalizeArgs(...args);
          let fn = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;
          if ("string" !== typeof fn && "number" !== typeof fn || "string" !== typeof flagsStr || vfsName && "string" !== typeof vfsName && "number" !== typeof vfsName) {
            sqlite3.config.error("Invalid DB ctor args", opt, arguments);
            toss3("Invalid arguments for DB constructor.");
          }
          let fnJs = "number" === typeof fn ? wasm.cstrToJs(fn) : fn;
          const vfsCheck = ctor._name2vfs[fnJs];
          if (vfsCheck) {
            vfsName = vfsCheck.vfs;
            fn = fnJs = vfsCheck.filename(fnJs);
          }
          let pDb2, oflags = 0;
          if (flagsStr.indexOf("c") >= 0) {
            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
          }
          if (flagsStr.indexOf("w") >= 0)
            oflags |= capi.SQLITE_OPEN_READWRITE;
          if (0 === oflags)
            oflags |= capi.SQLITE_OPEN_READONLY;
          oflags |= capi.SQLITE_OPEN_EXRESCODE;
          const stack = wasm.pstack.pointer;
          try {
            const pPtr = wasm.pstack.allocPtr();
            let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
            pDb2 = wasm.peekPtr(pPtr);
            checkSqlite3Rc(pDb2, rc);
            capi.sqlite3_extended_result_codes(pDb2, 1);
            if (flagsStr.indexOf("t") >= 0) {
              capi.sqlite3_trace_v2(
                pDb2,
                capi.SQLITE_TRACE_STMT,
                __dbTraceToConsole,
                pDb2
              );
            }
          } catch (e5) {
            if (pDb2)
              capi.sqlite3_close_v2(pDb2);
            throw e5;
          } finally {
            wasm.pstack.restore(stack);
          }
          this.filename = fnJs;
          __ptrMap.set(this, pDb2);
          __stmtMap.set(this, /* @__PURE__ */ Object.create(null));
          try {
            const pVfs = capi.sqlite3_js_db_vfs(pDb2) || toss3("Internal error: cannot get VFS for new db handle.");
            const postInitSql = __vfsPostOpenSql[pVfs];
            if (postInitSql) {
              if (postInitSql instanceof Function) {
                postInitSql(this, sqlite3);
              } else {
                checkSqlite3Rc(
                  pDb2,
                  capi.sqlite3_exec(pDb2, postInitSql, 0, 0, 0)
                );
              }
            }
          } catch (e5) {
            this.close();
            throw e5;
          }
        };
        dbCtorHelper.setVfsPostOpenSql = function(pVfs, sql) {
          __vfsPostOpenSql[pVfs] = sql;
        };
        dbCtorHelper.normalizeArgs = function(filename = ":memory:", flags = "c", vfs = null) {
          const arg = {};
          if (1 === arguments.length && arguments[0] && "object" === typeof arguments[0]) {
            Object.assign(arg, arguments[0]);
            if (void 0 === arg.flags)
              arg.flags = "c";
            if (void 0 === arg.vfs)
              arg.vfs = null;
            if (void 0 === arg.filename)
              arg.filename = ":memory:";
          } else {
            arg.filename = filename;
            arg.flags = flags;
            arg.vfs = vfs;
          }
          return arg;
        };
        const DB = function(...args) {
          dbCtorHelper.apply(this, args);
        };
        DB.dbCtorHelper = dbCtorHelper;
        const BindTypes = {
          null: 1,
          number: 2,
          string: 3,
          boolean: 4,
          blob: 5
        };
        BindTypes["undefined"] == BindTypes.null;
        if (wasm.bigIntEnabled) {
          BindTypes.bigint = BindTypes.number;
        }
        const Stmt = function() {
          if (BindTypes !== arguments[2]) {
            toss3(
              capi.SQLITE_MISUSE,
              "Do not call the Stmt constructor directly. Use DB.prepare()."
            );
          }
          this.db = arguments[0];
          __ptrMap.set(this, arguments[1]);
          this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
        };
        const affirmDbOpen = function(db) {
          if (!db.pointer)
            toss3("DB has been closed.");
          return db;
        };
        const affirmColIndex = function(stmt, ndx) {
          if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {
            toss3("Column index", ndx, "is out of range.");
          }
          return stmt;
        };
        const parseExecArgs = function(db, args) {
          const out2 = /* @__PURE__ */ Object.create(null);
          out2.opt = /* @__PURE__ */ Object.create(null);
          switch (args.length) {
            case 1:
              if ("string" === typeof args[0] || util.isSQLableTypedArray(args[0])) {
                out2.sql = args[0];
              } else if (Array.isArray(args[0])) {
                out2.sql = args[0];
              } else if (args[0] && "object" === typeof args[0]) {
                out2.opt = args[0];
                out2.sql = out2.opt.sql;
              }
              break;
            case 2:
              out2.sql = args[0];
              out2.opt = args[1];
              break;
            default:
              toss3("Invalid argument count for exec().");
          }
          out2.sql = util.flexibleString(out2.sql);
          if ("string" !== typeof out2.sql) {
            toss3("Missing SQL argument or unsupported SQL value type.");
          }
          const opt = out2.opt;
          switch (opt.returnValue) {
            case "resultRows":
              if (!opt.resultRows)
                opt.resultRows = [];
              out2.returnVal = () => opt.resultRows;
              break;
            case "saveSql":
              if (!opt.saveSql)
                opt.saveSql = [];
              out2.returnVal = () => opt.saveSql;
              break;
            case void 0:
            case "this":
              out2.returnVal = () => db;
              break;
            default:
              toss3("Invalid returnValue value:", opt.returnValue);
          }
          if (!opt.callback && !opt.returnValue && void 0 !== opt.rowMode) {
            if (!opt.resultRows)
              opt.resultRows = [];
            out2.returnVal = () => opt.resultRows;
          }
          if (opt.callback || opt.resultRows) {
            switch (void 0 === opt.rowMode ? "array" : opt.rowMode) {
              case "object":
                out2.cbArg = (stmt, cache) => {
                  if (!cache.columnNames)
                    cache.columnNames = stmt.getColumnNames([]);
                  const row = stmt.get([]);
                  const rv = /* @__PURE__ */ Object.create(null);
                  for (const i3 in cache.columnNames)
                    rv[cache.columnNames[i3]] = row[i3];
                  return rv;
                };
                break;
              case "array":
                out2.cbArg = (stmt) => stmt.get([]);
                break;
              case "stmt":
                if (Array.isArray(opt.resultRows)) {
                  toss3(
                    "exec(): invalid rowMode for a resultRows array: must",
                    "be one of 'array', 'object',",
                    "a result column number, or column name reference."
                  );
                }
                out2.cbArg = (stmt) => stmt;
                break;
              default:
                if (util.isInt32(opt.rowMode)) {
                  out2.cbArg = (stmt) => stmt.get(opt.rowMode);
                  break;
                } else if ("string" === typeof opt.rowMode && opt.rowMode.length > 1 && "$" === opt.rowMode[0]) {
                  const $colName = opt.rowMode.substr(1);
                  out2.cbArg = (stmt) => {
                    const rc = stmt.get(/* @__PURE__ */ Object.create(null))[$colName];
                    return void 0 === rc ? toss3(
                      capi.SQLITE_NOTFOUND,
                      "exec(): unknown result column:",
                      $colName
                    ) : rc;
                  };
                  break;
                }
                toss3("Invalid rowMode:", opt.rowMode);
            }
          }
          return out2;
        };
        const __selectFirstRow = (db, sql, bind, ...getArgs) => {
          const stmt = db.prepare(sql);
          try {
            const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : void 0;
            stmt.reset();
            return rc;
          } finally {
            stmt.finalize();
          }
        };
        const __selectAll = (db, sql, bind, rowMode) => db.exec({
          sql,
          bind,
          rowMode,
          returnValue: "resultRows"
        });
        DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);
        DB.prototype = {
          isOpen: function() {
            return !!this.pointer;
          },
          affirmOpen: function() {
            return affirmDbOpen(this);
          },
          close: function() {
            if (this.pointer) {
              if (this.onclose && this.onclose.before instanceof Function) {
                try {
                  this.onclose.before(this);
                } catch (e5) {
                }
              }
              const pDb2 = this.pointer;
              Object.keys(__stmtMap.get(this)).forEach((k2, s2) => {
                if (s2 && s2.pointer) {
                  try {
                    s2.finalize();
                  } catch (e5) {
                  }
                }
              });
              __ptrMap.delete(this);
              __stmtMap.delete(this);
              capi.sqlite3_close_v2(pDb2);
              if (this.onclose && this.onclose.after instanceof Function) {
                try {
                  this.onclose.after(this);
                } catch (e5) {
                }
              }
              delete this.filename;
            }
          },
          changes: function(total = false, sixtyFour = false) {
            const p2 = affirmDbOpen(this).pointer;
            if (total) {
              return sixtyFour ? capi.sqlite3_total_changes64(p2) : capi.sqlite3_total_changes(p2);
            } else {
              return sixtyFour ? capi.sqlite3_changes64(p2) : capi.sqlite3_changes(p2);
            }
          },
          dbFilename: function(dbName = "main") {
            return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
          },
          dbName: function(dbNumber = 0) {
            return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
          },
          dbVfsName: function(dbName = 0) {
            let rc;
            const pVfs = capi.sqlite3_js_db_vfs(
              affirmDbOpen(this).pointer,
              dbName
            );
            if (pVfs) {
              const v3 = new capi.sqlite3_vfs(pVfs);
              try {
                rc = wasm.cstrToJs(v3.$zName);
              } finally {
                v3.dispose();
              }
            }
            return rc;
          },
          prepare: function(sql) {
            affirmDbOpen(this);
            const stack = wasm.pstack.pointer;
            let ppStmt, pStmt;
            try {
              ppStmt = wasm.pstack.alloc(8);
              DB.checkRc(
                this,
                capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null)
              );
              pStmt = wasm.peekPtr(ppStmt);
            } finally {
              wasm.pstack.restore(stack);
            }
            if (!pStmt)
              toss3("Cannot prepare empty SQL.");
            const stmt = new Stmt(this, pStmt, BindTypes);
            __stmtMap.get(this)[pStmt] = stmt;
            return stmt;
          },
          exec: function() {
            affirmDbOpen(this);
            const arg = parseExecArgs(this, arguments);
            if (!arg.sql) {
              return toss3("exec() requires an SQL string.");
            }
            const opt = arg.opt;
            const callback = opt.callback;
            const resultRows = Array.isArray(opt.resultRows) ? opt.resultRows : void 0;
            let stmt;
            let bind = opt.bind;
            let evalFirstResult = !!(arg.cbArg || opt.columnNames || resultRows);
            const stack = wasm.scopedAllocPush();
            const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : void 0;
            try {
              const isTA = util.isSQLableTypedArray(arg.sql);
              let sqlByteLen = isTA ? arg.sql.byteLength : wasm.jstrlen(arg.sql);
              const ppStmt = wasm.scopedAlloc(
                2 * wasm.ptrSizeof + (sqlByteLen + 1)
              );
              const pzTail = ppStmt + wasm.ptrSizeof;
              let pSql = pzTail + wasm.ptrSizeof;
              const pSqlEnd = pSql + sqlByteLen;
              if (isTA)
                wasm.heap8().set(arg.sql, pSql);
              else
                wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
              wasm.poke(pSql + sqlByteLen, 0);
              while (pSql && wasm.peek(pSql, "i8")) {
                wasm.pokePtr([ppStmt, pzTail], 0);
                DB.checkRc(
                  this,
                  capi.sqlite3_prepare_v3(
                    this.pointer,
                    pSql,
                    sqlByteLen,
                    0,
                    ppStmt,
                    pzTail
                  )
                );
                const pStmt = wasm.peekPtr(ppStmt);
                pSql = wasm.peekPtr(pzTail);
                sqlByteLen = pSqlEnd - pSql;
                if (!pStmt)
                  continue;
                if (saveSql)
                  saveSql.push(capi.sqlite3_sql(pStmt).trim());
                stmt = new Stmt(this, pStmt, BindTypes);
                if (bind && stmt.parameterCount) {
                  stmt.bind(bind);
                  bind = null;
                }
                if (evalFirstResult && stmt.columnCount) {
                  let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;
                  evalFirstResult = false;
                  if (arg.cbArg || resultRows) {
                    const cbArgCache = /* @__PURE__ */ Object.create(null);
                    for (; stmt.step(); stmt._lockedByExec = false) {
                      if (0 === gotColNames++) {
                        stmt.getColumnNames(
                          cbArgCache.columnNames = opt.columnNames || []
                        );
                      }
                      stmt._lockedByExec = true;
                      const row = arg.cbArg(stmt, cbArgCache);
                      if (resultRows)
                        resultRows.push(row);
                      if (callback && false === callback.call(opt, row, stmt)) {
                        break;
                      }
                    }
                    stmt._lockedByExec = false;
                  }
                  if (0 === gotColNames) {
                    stmt.getColumnNames(opt.columnNames);
                  }
                } else {
                  stmt.step();
                }
                stmt.reset().finalize();
                stmt = null;
              }
            } finally {
              wasm.scopedAllocPop(stack);
              if (stmt) {
                delete stmt._lockedByExec;
                stmt.finalize();
              }
            }
            return arg.returnVal();
          },
          createFunction: function f4(name, xFunc, opt) {
            const isFunc = (f5) => f5 instanceof Function;
            switch (arguments.length) {
              case 1:
                opt = name;
                name = opt.name;
                xFunc = opt.xFunc || 0;
                break;
              case 2:
                if (!isFunc(xFunc)) {
                  opt = xFunc;
                  xFunc = opt.xFunc || 0;
                }
                break;
              case 3:
                break;
              default:
                break;
            }
            if (!opt)
              opt = {};
            if ("string" !== typeof name) {
              toss3("Invalid arguments: missing function name.");
            }
            let xStep = opt.xStep || 0;
            let xFinal = opt.xFinal || 0;
            const xValue = opt.xValue || 0;
            const xInverse = opt.xInverse || 0;
            let isWindow = void 0;
            if (isFunc(xFunc)) {
              isWindow = false;
              if (isFunc(xStep) || isFunc(xFinal)) {
                toss3("Ambiguous arguments: scalar or aggregate?");
              }
              xStep = xFinal = null;
            } else if (isFunc(xStep)) {
              if (!isFunc(xFinal)) {
                toss3("Missing xFinal() callback for aggregate or window UDF.");
              }
              xFunc = null;
            } else if (isFunc(xFinal)) {
              toss3("Missing xStep() callback for aggregate or window UDF.");
            } else {
              toss3("Missing function-type properties.");
            }
            if (false === isWindow) {
              if (isFunc(xValue) || isFunc(xInverse)) {
                toss3(
                  "xValue and xInverse are not permitted for non-window UDFs."
                );
              }
            } else if (isFunc(xValue)) {
              if (!isFunc(xInverse)) {
                toss3("xInverse must be provided if xValue is.");
              }
              isWindow = true;
            } else if (isFunc(xInverse)) {
              toss3("xValue must be provided if xInverse is.");
            }
            const pApp = opt.pApp;
            if (void 0 !== pApp && null !== pApp && ("number" !== typeof pApp || !util.isInt32(pApp))) {
              toss3(
                "Invalid value for pApp property. Must be a legal WASM pointer value."
              );
            }
            const xDestroy = opt.xDestroy || 0;
            if (xDestroy && !isFunc(xDestroy)) {
              toss3("xDestroy property must be a function.");
            }
            let fFlags = 0;
            if (getOwnOption(opt, "deterministic"))
              fFlags |= capi.SQLITE_DETERMINISTIC;
            if (getOwnOption(opt, "directOnly"))
              fFlags |= capi.SQLITE_DIRECTONLY;
            if (getOwnOption(opt, "innocuous"))
              fFlags |= capi.SQLITE_INNOCUOUS;
            name = name.toLowerCase();
            const xArity = xFunc || xStep;
            const arity = getOwnOption(opt, "arity");
            const arityArg = "number" === typeof arity ? arity : xArity.length ? xArity.length - 1 : 0;
            let rc;
            if (isWindow) {
              rc = capi.sqlite3_create_window_function(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy
              );
            } else {
              rc = capi.sqlite3_create_function_v2(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xFunc,
                xStep,
                xFinal,
                xDestroy
              );
            }
            DB.checkRc(this, rc);
            return this;
          },
          selectValue: function(sql, bind, asType) {
            return __selectFirstRow(this, sql, bind, 0, asType);
          },
          selectValues: function(sql, bind, asType) {
            const stmt = this.prepare(sql), rc = [];
            try {
              stmt.bind(bind);
              while (stmt.step())
                rc.push(stmt.get(0, asType));
              stmt.reset();
            } finally {
              stmt.finalize();
            }
            return rc;
          },
          selectArray: function(sql, bind) {
            return __selectFirstRow(this, sql, bind, []);
          },
          selectObject: function(sql, bind) {
            return __selectFirstRow(this, sql, bind, {});
          },
          selectArrays: function(sql, bind) {
            return __selectAll(this, sql, bind, "array");
          },
          selectObjects: function(sql, bind) {
            return __selectAll(this, sql, bind, "object");
          },
          openStatementCount: function() {
            return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
          },
          transaction: function(callback) {
            let opener = "BEGIN";
            if (arguments.length > 1) {
              if (/[^a-zA-Z]/.test(arguments[0])) {
                toss3(
                  capi.SQLITE_MISUSE,
                  "Invalid argument for BEGIN qualifier."
                );
              }
              opener += " " + arguments[0];
              callback = arguments[1];
            }
            affirmDbOpen(this).exec(opener);
            try {
              const rc = callback(this);
              this.exec("COMMIT");
              return rc;
            } catch (e5) {
              this.exec("ROLLBACK");
              throw e5;
            }
          },
          savepoint: function(callback) {
            affirmDbOpen(this).exec("SAVEPOINT oo1");
            try {
              const rc = callback(this);
              this.exec("RELEASE oo1");
              return rc;
            } catch (e5) {
              this.exec("ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1");
              throw e5;
            }
          },
          checkRc: function(resultCode) {
            return checkSqlite3Rc(this, resultCode);
          }
        };
        const affirmStmtOpen = function(stmt) {
          if (!stmt.pointer)
            toss3("Stmt has been closed.");
          return stmt;
        };
        const isSupportedBindType = function(v3) {
          let t4 = BindTypes[null === v3 || void 0 === v3 ? "null" : typeof v3];
          switch (t4) {
            case BindTypes.boolean:
            case BindTypes.null:
            case BindTypes.number:
            case BindTypes.string:
              return t4;
            case BindTypes.bigint:
              if (wasm.bigIntEnabled)
                return t4;
            default:
              return util.isBindableTypedArray(v3) ? BindTypes.blob : void 0;
          }
        };
        const affirmSupportedBindType = function(v3) {
          return isSupportedBindType(v3) || toss3("Unsupported bind() argument type:", typeof v3);
        };
        const affirmParamIndex = function(stmt, key) {
          const n5 = "number" === typeof key ? key : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
          if (0 === n5 || !util.isInt32(n5)) {
            toss3("Invalid bind() parameter name: " + key);
          } else if (n5 < 1 || n5 > stmt.parameterCount)
            toss3("Bind index", key, "is out of range.");
          return n5;
        };
        const affirmNotLockedByExec = function(stmt, currentOpName) {
          if (stmt._lockedByExec) {
            toss3(
              "Operation is illegal when statement is locked:",
              currentOpName
            );
          }
          return stmt;
        };
        const bindOne = function f4(stmt, ndx, bindType, val) {
          affirmNotLockedByExec(affirmStmtOpen(stmt), "bind()");
          if (!f4._) {
            f4._tooBigInt = (v3) => toss3(
              "BigInt value is too big to store without precision loss:",
              v3
            );
            f4._ = {
              string: function(stmt2, ndx2, val2, asBlob) {
                const [pStr, n5] = wasm.allocCString(val2, true);
                const f5 = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;
                return f5(stmt2.pointer, ndx2, pStr, n5, capi.SQLITE_WASM_DEALLOC);
              }
            };
          }
          affirmSupportedBindType(val);
          ndx = affirmParamIndex(stmt, ndx);
          let rc = 0;
          switch (null === val || void 0 === val ? BindTypes.null : bindType) {
            case BindTypes.null:
              rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
              break;
            case BindTypes.string:
              rc = f4._.string(stmt, ndx, val, false);
              break;
            case BindTypes.number: {
              let m3;
              if (util.isInt32(val))
                m3 = capi.sqlite3_bind_int;
              else if ("bigint" === typeof val) {
                if (!util.bigIntFits64(val)) {
                  f4._tooBigInt(val);
                } else if (wasm.bigIntEnabled) {
                  m3 = capi.sqlite3_bind_int64;
                } else if (util.bigIntFitsDouble(val)) {
                  val = Number(val);
                  m3 = capi.sqlite3_bind_double;
                } else {
                  f4._tooBigInt(val);
                }
              } else {
                val = Number(val);
                if (wasm.bigIntEnabled && Number.isInteger(val)) {
                  m3 = capi.sqlite3_bind_int64;
                } else {
                  m3 = capi.sqlite3_bind_double;
                }
              }
              rc = m3(stmt.pointer, ndx, val);
              break;
            }
            case BindTypes.boolean:
              rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
              break;
            case BindTypes.blob: {
              if ("string" === typeof val) {
                rc = f4._.string(stmt, ndx, val, true);
                break;
              } else if (val instanceof ArrayBuffer) {
                val = new Uint8Array(val);
              } else if (!util.isBindableTypedArray(val)) {
                toss3(
                  "Binding a value as a blob requires",
                  "that it be a string, Uint8Array, Int8Array, or ArrayBuffer."
                );
              }
              const pBlob = wasm.alloc(val.byteLength || 1);
              wasm.heap8().set(val.byteLength ? val : [0], pBlob);
              rc = capi.sqlite3_bind_blob(
                stmt.pointer,
                ndx,
                pBlob,
                val.byteLength,
                capi.SQLITE_WASM_DEALLOC
              );
              break;
            }
            default:
              sqlite3.config.warn("Unsupported bind() argument type:", val);
              toss3("Unsupported bind() argument type: " + typeof val);
          }
          if (rc)
            DB.checkRc(stmt.db.pointer, rc);
          stmt._mayGet = false;
          return stmt;
        };
        Stmt.prototype = {
          finalize: function() {
            if (this.pointer) {
              affirmNotLockedByExec(this, "finalize()");
              const rc = capi.sqlite3_finalize(this.pointer);
              delete __stmtMap.get(this.db)[this.pointer];
              __ptrMap.delete(this);
              delete this._mayGet;
              delete this.parameterCount;
              delete this._lockedByExec;
              delete this.db;
              return rc;
            }
          },
          clearBindings: function() {
            affirmNotLockedByExec(affirmStmtOpen(this), "clearBindings()");
            capi.sqlite3_clear_bindings(this.pointer);
            this._mayGet = false;
            return this;
          },
          reset: function(alsoClearBinds) {
            affirmNotLockedByExec(this, "reset()");
            if (alsoClearBinds)
              this.clearBindings();
            const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
            this._mayGet = false;
            checkSqlite3Rc(this.db, rc);
            return this;
          },
          bind: function() {
            affirmStmtOpen(this);
            let ndx, arg;
            switch (arguments.length) {
              case 1:
                ndx = 1;
                arg = arguments[0];
                break;
              case 2:
                ndx = arguments[0];
                arg = arguments[1];
                break;
              default:
                toss3("Invalid bind() arguments.");
            }
            if (void 0 === arg) {
              return this;
            } else if (!this.parameterCount) {
              toss3("This statement has no bindable parameters.");
            }
            this._mayGet = false;
            if (null === arg) {
              return bindOne(this, ndx, BindTypes.null, arg);
            } else if (Array.isArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  "When binding an array, an index argument is not permitted."
                );
              }
              arg.forEach(
                (v3, i3) => bindOne(this, i3 + 1, affirmSupportedBindType(v3), v3)
              );
              return this;
            } else if (arg instanceof ArrayBuffer) {
              arg = new Uint8Array(arg);
            }
            if ("object" === typeof arg && !util.isBindableTypedArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  "When binding an object, an index argument is not permitted."
                );
              }
              Object.keys(arg).forEach(
                (k2) => bindOne(this, k2, affirmSupportedBindType(arg[k2]), arg[k2])
              );
              return this;
            } else {
              return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
            }
            toss3("Should not reach this point.");
          },
          bindAsBlob: function(ndx, arg) {
            affirmStmtOpen(this);
            if (1 === arguments.length) {
              arg = ndx;
              ndx = 1;
            }
            const t4 = affirmSupportedBindType(arg);
            if (BindTypes.string !== t4 && BindTypes.blob !== t4 && BindTypes.null !== t4) {
              toss3("Invalid value type for bindAsBlob()");
            }
            return bindOne(this, ndx, BindTypes.blob, arg);
          },
          step: function() {
            affirmNotLockedByExec(this, "step()");
            const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
            switch (rc) {
              case capi.SQLITE_DONE:
                return this._mayGet = false;
              case capi.SQLITE_ROW:
                return this._mayGet = true;
              default:
                this._mayGet = false;
                sqlite3.config.warn(
                  "sqlite3_step() rc=",
                  rc,
                  capi.sqlite3_js_rc_str(rc),
                  "SQL =",
                  capi.sqlite3_sql(this.pointer)
                );
                DB.checkRc(this.db.pointer, rc);
            }
          },
          stepReset: function() {
            this.step();
            return this.reset();
          },
          stepFinalize: function() {
            try {
              const rc = this.step();
              this.reset();
              return rc;
            } finally {
              try {
                this.finalize();
              } catch (e5) {
              }
            }
          },
          get: function(ndx, asType) {
            if (!affirmStmtOpen(this)._mayGet) {
              toss3("Stmt.step() has not (recently) returned true.");
            }
            if (Array.isArray(ndx)) {
              let i3 = 0;
              const n5 = this.columnCount;
              while (i3 < n5) {
                ndx[i3] = this.get(i3++);
              }
              return ndx;
            } else if (ndx && "object" === typeof ndx) {
              let i3 = 0;
              const n5 = this.columnCount;
              while (i3 < n5) {
                ndx[capi.sqlite3_column_name(this.pointer, i3)] = this.get(i3++);
              }
              return ndx;
            }
            affirmColIndex(this, ndx);
            switch (void 0 === asType ? capi.sqlite3_column_type(this.pointer, ndx) : asType) {
              case capi.SQLITE_NULL:
                return null;
              case capi.SQLITE_INTEGER: {
                if (wasm.bigIntEnabled) {
                  const rc = capi.sqlite3_column_int64(this.pointer, ndx);
                  if (rc >= Number.MIN_SAFE_INTEGER && rc <= Number.MAX_SAFE_INTEGER) {
                    return Number(rc).valueOf();
                  }
                  return rc;
                } else {
                  const rc = capi.sqlite3_column_double(this.pointer, ndx);
                  if (rc > Number.MAX_SAFE_INTEGER || rc < Number.MIN_SAFE_INTEGER) {
                    toss3(
                      "Integer is out of range for JS integer range: " + rc
                    );
                  }
                  return util.isInt32(rc) ? rc | 0 : rc;
                }
              }
              case capi.SQLITE_FLOAT:
                return capi.sqlite3_column_double(this.pointer, ndx);
              case capi.SQLITE_TEXT:
                return capi.sqlite3_column_text(this.pointer, ndx);
              case capi.SQLITE_BLOB: {
                const n5 = capi.sqlite3_column_bytes(this.pointer, ndx), ptr = capi.sqlite3_column_blob(this.pointer, ndx), rc = new Uint8Array(n5);
                if (n5)
                  rc.set(wasm.heap8u().slice(ptr, ptr + n5), 0);
                if (n5 && this.db._blobXfer instanceof Array) {
                  this.db._blobXfer.push(rc.buffer);
                }
                return rc;
              }
              default:
                toss3(
                  "Don't know how to translate",
                  "type of result column #" + ndx + "."
                );
            }
            toss3("Not reached.");
          },
          getInt: function(ndx) {
            return this.get(ndx, capi.SQLITE_INTEGER);
          },
          getFloat: function(ndx) {
            return this.get(ndx, capi.SQLITE_FLOAT);
          },
          getString: function(ndx) {
            return this.get(ndx, capi.SQLITE_TEXT);
          },
          getBlob: function(ndx) {
            return this.get(ndx, capi.SQLITE_BLOB);
          },
          getJSON: function(ndx) {
            const s2 = this.get(ndx, capi.SQLITE_STRING);
            return null === s2 ? s2 : JSON.parse(s2);
          },
          getColumnName: function(ndx) {
            return capi.sqlite3_column_name(
              affirmColIndex(affirmStmtOpen(this), ndx).pointer,
              ndx
            );
          },
          getColumnNames: function(tgt = []) {
            affirmColIndex(affirmStmtOpen(this), 0);
            const n5 = this.columnCount;
            for (let i3 = 0; i3 < n5; ++i3) {
              tgt.push(capi.sqlite3_column_name(this.pointer, i3));
            }
            return tgt;
          },
          getParamIndex: function(name) {
            return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_index(this.pointer, name) : void 0;
          }
        };
        {
          const prop = {
            enumerable: true,
            get: function() {
              return __ptrMap.get(this);
            },
            set: () => toss3("The pointer property is read-only.")
          };
          Object.defineProperty(Stmt.prototype, "pointer", prop);
          Object.defineProperty(DB.prototype, "pointer", prop);
        }
        Object.defineProperty(Stmt.prototype, "columnCount", {
          enumerable: false,
          get: function() {
            return capi.sqlite3_column_count(this.pointer);
          },
          set: () => toss3("The columnCount property is read-only.")
        });
        sqlite3.oo1 = {
          DB,
          Stmt
        };
        if (util.isUIThread()) {
          sqlite3.oo1.JsStorageDb = function(storageName = "session") {
            const opt = dbCtorHelper.normalizeArgs(...arguments);
            storageName = opt.filename;
            if ("session" !== storageName && "local" !== storageName) {
              toss3("JsStorageDb db name must be one of 'session' or 'local'.");
            }
            opt.vfs = "kvvfs";
            dbCtorHelper.call(this, opt);
          };
          const jdb = sqlite3.oo1.JsStorageDb;
          jdb.prototype = Object.create(DB.prototype);
          jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;
          jdb.prototype.clearStorage = function() {
            return jdb.clearStorage(affirmDbOpen(this).filename);
          };
          jdb.storageSize = capi.sqlite3_js_kvvfs_size;
          jdb.prototype.storageSize = function() {
            return jdb.storageSize(affirmDbOpen(this).filename);
          };
        }
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const util = sqlite3.util;
        sqlite3.initWorker1API = function() {
          "use strict";
          const toss = (...args) => {
            throw new Error(args.join(" "));
          };
          if (!(globalThis.WorkerGlobalScope instanceof Function)) {
            toss("initWorker1API() must be run from a Worker thread.");
          }
          const sqlite32 = this.sqlite3 || toss("Missing this.sqlite3 object.");
          const DB = sqlite32.oo1.DB;
          const getDbId = function(db) {
            let id = wState.idMap.get(db);
            if (id)
              return id;
            id = "db#" + ++wState.idSeq + "@" + db.pointer;
            wState.idMap.set(db, id);
            return id;
          };
          const wState = {
            dbList: [],
            idSeq: 0,
            idMap: /* @__PURE__ */ new WeakMap(),
            xfer: [],
            open: function(opt) {
              const db = new DB(opt);
              this.dbs[getDbId(db)] = db;
              if (this.dbList.indexOf(db) < 0)
                this.dbList.push(db);
              return db;
            },
            close: function(db, alsoUnlink) {
              if (db) {
                delete this.dbs[getDbId(db)];
                const filename = db.filename;
                const pVfs = util.sqlite3__wasm_db_vfs(db.pointer, 0);
                db.close();
                const ddNdx = this.dbList.indexOf(db);
                if (ddNdx >= 0)
                  this.dbList.splice(ddNdx, 1);
                if (alsoUnlink && filename && pVfs) {
                  util.sqlite3__wasm_vfs_unlink(pVfs, filename);
                }
              }
            },
            post: function(msg, xferList) {
              if (xferList && xferList.length) {
                globalThis.postMessage(msg, Array.from(xferList));
                xferList.length = 0;
              } else {
                globalThis.postMessage(msg);
              }
            },
            dbs: /* @__PURE__ */ Object.create(null),
            getDb: function(id, require2 = true) {
              return this.dbs[id] || (require2 ? toss("Unknown (or closed) DB ID:", id) : void 0);
            }
          };
          const affirmDbOpen = function(db = wState.dbList[0]) {
            return db && db.pointer ? db : toss("DB is not opened.");
          };
          const getMsgDb = function(msgData, affirmExists = true) {
            const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];
            return affirmExists ? affirmDbOpen(db) : db;
          };
          const getDefaultDbId = function() {
            return wState.dbList[0] && getDbId(wState.dbList[0]);
          };
          const isSpecialDbFilename = (n5) => {
            return "" === n5 || ":" === n5[0];
          };
          const wMsgHandler = {
            open: function(ev) {
              const oargs = /* @__PURE__ */ Object.create(null), args = ev.args || /* @__PURE__ */ Object.create(null);
              if (args.simulateError) {
                toss("Throwing because of simulateError flag.");
              }
              const rc = /* @__PURE__ */ Object.create(null);
              oargs.vfs = args.vfs;
              oargs.filename = args.filename || "";
              const db = wState.open(oargs);
              rc.filename = db.filename;
              rc.persistent = !!sqlite32.capi.sqlite3_js_db_uses_vfs(
                db.pointer,
                "opfs"
              );
              rc.dbId = getDbId(db);
              rc.vfs = db.dbVfsName();
              return rc;
            },
            close: function(ev) {
              const db = getMsgDb(ev, false);
              const response = {
                filename: db && db.filename
              };
              if (db) {
                const doUnlink = ev.args && "object" === typeof ev.args ? !!ev.args.unlink : false;
                wState.close(db, doUnlink);
              }
              return response;
            },
            exec: function(ev) {
              const rc = "string" === typeof ev.args ? { sql: ev.args } : ev.args || /* @__PURE__ */ Object.create(null);
              if ("stmt" === rc.rowMode) {
                toss(
                  "Invalid rowMode for 'exec': stmt mode",
                  "does not work in the Worker API."
                );
              } else if (!rc.sql) {
                toss("'exec' requires input SQL.");
              }
              const db = getMsgDb(ev);
              if (rc.callback || Array.isArray(rc.resultRows)) {
                db._blobXfer = wState.xfer;
              }
              const theCallback = rc.callback;
              let rowNumber = 0;
              const hadColNames = !!rc.columnNames;
              if ("string" === typeof theCallback) {
                if (!hadColNames)
                  rc.columnNames = [];
                rc.callback = function(row, stmt) {
                  wState.post(
                    {
                      type: theCallback,
                      columnNames: rc.columnNames,
                      rowNumber: ++rowNumber,
                      row
                    },
                    wState.xfer
                  );
                };
              }
              try {
                const changeCount = !!rc.countChanges ? db.changes(true, 64 === rc.countChanges) : void 0;
                db.exec(rc);
                if (void 0 !== changeCount) {
                  rc.changeCount = db.changes(true, 64 === rc.countChanges) - changeCount;
                }
                if (rc.callback instanceof Function) {
                  rc.callback = theCallback;
                  wState.post({
                    type: theCallback,
                    columnNames: rc.columnNames,
                    rowNumber: null,
                    row: void 0
                  });
                }
              } finally {
                delete db._blobXfer;
                if (rc.callback)
                  rc.callback = theCallback;
              }
              return rc;
            },
            "config-get": function() {
              const rc = /* @__PURE__ */ Object.create(null), src = sqlite32.config;
              ["bigIntEnabled"].forEach(function(k2) {
                if (Object.getOwnPropertyDescriptor(src, k2))
                  rc[k2] = src[k2];
              });
              rc.version = sqlite32.version;
              rc.vfsList = sqlite32.capi.sqlite3_js_vfs_list();
              rc.opfsEnabled = !!sqlite32.opfs;
              return rc;
            },
            export: function(ev) {
              const db = getMsgDb(ev);
              const response = {
                byteArray: sqlite32.capi.sqlite3_js_db_export(db.pointer),
                filename: db.filename,
                mimetype: "application/x-sqlite3"
              };
              wState.xfer.push(response.byteArray.buffer);
              return response;
            },
            toss: function(ev) {
              toss("Testing worker exception");
            },
            "opfs-tree": async function(ev) {
              if (!sqlite32.opfs)
                toss("OPFS support is unavailable.");
              const response = await sqlite32.opfs.treeList();
              return response;
            }
          };
          globalThis.onmessage = async function(ev) {
            ev = ev.data;
            let result, dbId = ev.dbId, evType = ev.type;
            const arrivalTime = performance.now();
            try {
              if (wMsgHandler.hasOwnProperty(evType) && wMsgHandler[evType] instanceof Function) {
                result = await wMsgHandler[evType](ev);
              } else {
                toss("Unknown db worker message type:", ev.type);
              }
            } catch (err2) {
              evType = "error";
              result = {
                operation: ev.type,
                message: err2.message,
                errorClass: err2.name,
                input: ev
              };
              if (err2.stack) {
                result.stack = "string" === typeof err2.stack ? err2.stack.split(/\n\s*/) : err2.stack;
              }
              if (0)
                sqlite32.config.warn(
                  "Worker is propagating an exception to main thread.",
                  "Reporting it _here_ for the stack trace:",
                  err2,
                  result
                );
            }
            if (!dbId) {
              dbId = result.dbId || getDefaultDbId();
            }
            wState.post(
              {
                type: evType,
                dbId,
                messageId: ev.messageId,
                workerReceivedTime: arrivalTime,
                workerRespondTime: performance.now(),
                departureTime: ev.departureTime,
                result
              },
              wState.xfer
            );
          };
          globalThis.postMessage({
            type: "sqlite3-api",
            result: "worker1-ready"
          });
        }.bind({ sqlite3 });
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const wasm = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
        const vfs = /* @__PURE__ */ Object.create(null);
        sqlite3.vfs = vfs;
        capi.sqlite3_vfs.prototype.registerVfs = function(asDefault = false) {
          if (!(this instanceof sqlite3.capi.sqlite3_vfs)) {
            toss("Expecting a sqlite3_vfs-type argument.");
          }
          const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
          if (rc) {
            toss("sqlite3_vfs_register(", this, ") failed with rc", rc);
          }
          if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {
            toss(
              "BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS",
              this
            );
          }
          return this;
        };
        vfs.installVfs = function(opt) {
          let count = 0;
          const propList = ["io", "vfs"];
          for (const key of propList) {
            const o4 = opt[key];
            if (o4) {
              ++count;
              o4.struct.installMethods(o4.methods, !!o4.applyArgcCheck);
              if ("vfs" === key) {
                if (!o4.struct.$zName && "string" === typeof o4.name) {
                  o4.struct.addOnDispose(
                    o4.struct.$zName = wasm.allocCString(o4.name)
                  );
                }
                o4.struct.registerVfs(!!o4.asDefault);
              }
            }
          }
          if (!count)
            toss(
              "Misuse: installVfs() options object requires at least",
              "one of:",
              propList
            );
          return this;
        };
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const wasm = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
        const vtab = /* @__PURE__ */ Object.create(null);
        sqlite3.vtab = vtab;
        const sii = capi.sqlite3_index_info;
        sii.prototype.nthConstraint = function(n5, asPtr = false) {
          if (n5 < 0 || n5 >= this.$nConstraint)
            return false;
          const ptr = this.$aConstraint + sii.sqlite3_index_constraint.structInfo.sizeof * n5;
          return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
        };
        sii.prototype.nthConstraintUsage = function(n5, asPtr = false) {
          if (n5 < 0 || n5 >= this.$nConstraint)
            return false;
          const ptr = this.$aConstraintUsage + sii.sqlite3_index_constraint_usage.structInfo.sizeof * n5;
          return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
        };
        sii.prototype.nthOrderBy = function(n5, asPtr = false) {
          if (n5 < 0 || n5 >= this.$nOrderBy)
            return false;
          const ptr = this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n5;
          return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
        };
        const __xWrapFactory = function(methodName, StructType) {
          return function(ptr, removeMapping = false) {
            if (0 === arguments.length)
              ptr = new StructType();
            if (ptr instanceof StructType) {
              this.set(ptr.pointer, ptr);
              return ptr;
            } else if (!wasm.isPtr(ptr)) {
              sqlite3.SQLite3Error.toss(
                "Invalid argument to",
                methodName + "()"
              );
            }
            let rc = this.get(ptr);
            if (removeMapping)
              this.delete(ptr);
            return rc;
          }.bind(/* @__PURE__ */ new Map());
        };
        const StructPtrMapper = function(name, StructType) {
          const __xWrap = __xWrapFactory(name, StructType);
          return Object.assign(/* @__PURE__ */ Object.create(null), {
            StructType,
            create: (ppOut) => {
              const rc = __xWrap();
              wasm.pokePtr(ppOut, rc.pointer);
              return rc;
            },
            get: (pCObj) => __xWrap(pCObj),
            unget: (pCObj) => __xWrap(pCObj, true),
            dispose: (pCObj) => {
              const o4 = __xWrap(pCObj, true);
              if (o4)
                o4.dispose();
            }
          });
        };
        vtab.xVtab = StructPtrMapper("xVtab", capi.sqlite3_vtab);
        vtab.xCursor = StructPtrMapper("xCursor", capi.sqlite3_vtab_cursor);
        vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);
        vtab.xError = function f4(methodName, err2, defaultRc) {
          if (f4.errorReporter instanceof Function) {
            try {
              f4.errorReporter(
                "sqlite3_module::" + methodName + "(): " + err2.message
              );
            } catch (e5) {
            }
          }
          let rc;
          if (err2 instanceof sqlite3.WasmAllocError)
            rc = capi.SQLITE_NOMEM;
          else if (arguments.length > 2)
            rc = defaultRc;
          else if (err2 instanceof sqlite3.SQLite3Error)
            rc = err2.resultCode;
          return rc || capi.SQLITE_ERROR;
        };
        vtab.xError.errorReporter = 1 ? console.error.bind(console) : false;
        vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, "i64");
        vtab.setupModule = function(opt) {
          let createdMod = false;
          const mod = this instanceof capi.sqlite3_module ? this : opt.struct || (createdMod = new capi.sqlite3_module());
          try {
            const methods = opt.methods || toss("Missing 'methods' object.");
            for (const e5 of Object.entries({
              xConnect: "xCreate",
              xDisconnect: "xDestroy"
            })) {
              const k2 = e5[0], v3 = e5[1];
              if (true === methods[k2])
                methods[k2] = methods[v3];
              else if (true === methods[v3])
                methods[v3] = methods[k2];
            }
            if (opt.catchExceptions) {
              const fwrap = function(methodName, func) {
                if (["xConnect", "xCreate"].indexOf(methodName) >= 0) {
                  return function(pDb2, pAux, argc, argv, ppVtab, pzErr) {
                    try {
                      return func(...arguments) || 0;
                    } catch (e5) {
                      if (!(e5 instanceof sqlite3.WasmAllocError)) {
                        wasm.dealloc(wasm.peekPtr(pzErr));
                        wasm.pokePtr(pzErr, wasm.allocCString(e5.message));
                      }
                      return vtab.xError(methodName, e5);
                    }
                  };
                } else {
                  return function(...args) {
                    try {
                      return func(...args) || 0;
                    } catch (e5) {
                      return vtab.xError(methodName, e5);
                    }
                  };
                }
              };
              const mnames = [
                "xCreate",
                "xConnect",
                "xBestIndex",
                "xDisconnect",
                "xDestroy",
                "xOpen",
                "xClose",
                "xFilter",
                "xNext",
                "xEof",
                "xColumn",
                "xRowid",
                "xUpdate",
                "xBegin",
                "xSync",
                "xCommit",
                "xRollback",
                "xFindFunction",
                "xRename",
                "xSavepoint",
                "xRelease",
                "xRollbackTo",
                "xShadowName"
              ];
              const remethods = /* @__PURE__ */ Object.create(null);
              for (const k2 of mnames) {
                const m3 = methods[k2];
                if (!(m3 instanceof Function))
                  continue;
                else if ("xConnect" === k2 && methods.xCreate === m3) {
                  remethods[k2] = methods.xCreate;
                } else if ("xCreate" === k2 && methods.xConnect === m3) {
                  remethods[k2] = methods.xConnect;
                } else {
                  remethods[k2] = fwrap(k2, m3);
                }
              }
              mod.installMethods(remethods, false);
            } else {
              mod.installMethods(methods, !!opt.applyArgcCheck);
            }
            if (0 === mod.$iVersion) {
              let v3;
              if ("number" === typeof opt.iVersion)
                v3 = opt.iVersion;
              else if (mod.$xShadowName)
                v3 = 3;
              else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)
                v3 = 2;
              else
                v3 = 1;
              mod.$iVersion = v3;
            }
          } catch (e5) {
            if (createdMod)
              createdMod.dispose();
            throw e5;
          }
          return mod;
        };
        capi.sqlite3_module.prototype.setupModule = function(opt) {
          return vtab.setupModule.call(this, opt);
        };
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const installOpfsVfs = function callee2(options) {
          if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {
            return Promise.reject(
              new Error(
                "Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. The server must emit the COOP/COEP response headers to enable those. See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep"
              )
            );
          } else if ("undefined" === typeof WorkerGlobalScope) {
            return Promise.reject(
              new Error(
                "The OPFS sqlite3_vfs cannot run in the main thread because it requires Atomics.wait()."
              )
            );
          } else if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !navigator?.storage?.getDirectory) {
            return Promise.reject(new Error("Missing required OPFS APIs."));
          }
          if (!options || "object" !== typeof options) {
            options = /* @__PURE__ */ Object.create(null);
          }
          const urlParams = new URL(globalThis.location.href).searchParams;
          if (urlParams.has("opfs-disable")) {
            return Promise.resolve(sqlite3);
          }
          if (void 0 === options.verbose) {
            options.verbose = urlParams.has("opfs-verbose") ? +urlParams.get("opfs-verbose") || 2 : 1;
          }
          if (void 0 === options.sanityChecks) {
            options.sanityChecks = urlParams.has("opfs-sanity-check");
          }
          if (void 0 === options.proxyUri) {
            options.proxyUri = callee2.defaultProxyUri;
          }
          if ("function" === typeof options.proxyUri) {
            options.proxyUri = options.proxyUri();
          }
          const thePromise = new Promise(function(promiseResolve_, promiseReject_) {
            const loggers = [
              sqlite3.config.error,
              sqlite3.config.warn,
              sqlite3.config.log
            ];
            const logImpl = (level, ...args) => {
              if (options.verbose > level)
                loggers[level]("OPFS syncer:", ...args);
            };
            const log3 = (...args) => logImpl(2, ...args);
            const warn = (...args) => logImpl(1, ...args);
            const error = (...args) => logImpl(0, ...args);
            const toss = sqlite3.util.toss;
            const capi = sqlite3.capi;
            const util = sqlite3.util;
            const wasm = sqlite3.wasm;
            const sqlite3_vfs = capi.sqlite3_vfs;
            const sqlite3_file = capi.sqlite3_file;
            const sqlite3_io_methods = capi.sqlite3_io_methods;
            const opfsUtil = /* @__PURE__ */ Object.create(null);
            const thisThreadHasOPFS = () => {
              return globalThis.FileSystemHandle && globalThis.FileSystemDirectoryHandle && globalThis.FileSystemFileHandle && globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle && navigator?.storage?.getDirectory;
            };
            opfsUtil.metrics = {
              dump: function() {
                let k2, n5 = 0, t4 = 0, w2 = 0;
                for (k2 in state.opIds) {
                  const m3 = metrics[k2];
                  n5 += m3.count;
                  t4 += m3.time;
                  w2 += m3.wait;
                  m3.avgTime = m3.count && m3.time ? m3.time / m3.count : 0;
                  m3.avgWait = m3.count && m3.wait ? m3.wait / m3.count : 0;
                }
                sqlite3.config.log(
                  globalThis.location.href,
                  "metrics for",
                  globalThis.location.href,
                  ":",
                  metrics,
                  "\nTotal of",
                  n5,
                  "op(s) for",
                  t4,
                  "ms (incl. " + w2 + " ms of waiting on the async side)"
                );
                sqlite3.config.log("Serialization metrics:", metrics.s11n);
                W.postMessage({ type: "opfs-async-metrics" });
              },
              reset: function() {
                let k2;
                const r5 = (m3) => m3.count = m3.time = m3.wait = 0;
                for (k2 in state.opIds) {
                  r5(metrics[k2] = /* @__PURE__ */ Object.create(null));
                }
                let s2 = metrics.s11n = /* @__PURE__ */ Object.create(null);
                s2 = s2.serialize = /* @__PURE__ */ Object.create(null);
                s2.count = s2.time = 0;
                s2 = metrics.s11n.deserialize = /* @__PURE__ */ Object.create(null);
                s2.count = s2.time = 0;
              }
            };
            const opfsIoMethods = new sqlite3_io_methods();
            const opfsVfs = new sqlite3_vfs().addOnDispose(
              () => opfsIoMethods.dispose()
            );
            let promiseWasRejected = void 0;
            const promiseReject = (err2) => {
              promiseWasRejected = true;
              opfsVfs.dispose();
              return promiseReject_(err2);
            };
            const promiseResolve = () => {
              promiseWasRejected = false;
              return promiseResolve_(sqlite3);
            };
            const W = new Worker(
              new URL("sqlite3-opfs-async-proxy.js", import.meta.url)
            );
            setTimeout(() => {
              if (void 0 === promiseWasRejected) {
                promiseReject(
                  new Error(
                    "Timeout while waiting for OPFS async proxy worker."
                  )
                );
              }
            }, 4e3);
            W._originalOnError = W.onerror;
            W.onerror = function(err2) {
              error("Error initializing OPFS asyncer:", err2);
              promiseReject(
                new Error(
                  "Loading OPFS async Worker failed for unknown reasons."
                )
              );
            };
            const pDVfs = capi.sqlite3_vfs_find(null);
            const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;
            opfsIoMethods.$iVersion = 1;
            opfsVfs.$iVersion = 2;
            opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
            opfsVfs.$mxPathname = 1024;
            opfsVfs.$zName = wasm.allocCString("opfs");
            opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;
            opfsVfs.addOnDispose(
              "$zName",
              opfsVfs.$zName,
              "cleanup default VFS wrapper",
              () => dVfs ? dVfs.dispose() : null
            );
            const state = /* @__PURE__ */ Object.create(null);
            state.verbose = options.verbose;
            state.littleEndian = (() => {
              const buffer = new ArrayBuffer(2);
              new DataView(buffer).setInt16(0, 256, true);
              return new Int16Array(buffer)[0] === 256;
            })();
            state.asyncIdleWaitTime = 150;
            state.asyncS11nExceptions = 1;
            state.fileBufferSize = 1024 * 64;
            state.sabS11nOffset = state.fileBufferSize;
            state.sabS11nSize = opfsVfs.$mxPathname * 2;
            state.sabIO = new SharedArrayBuffer(
              state.fileBufferSize + state.sabS11nSize
            );
            state.opIds = /* @__PURE__ */ Object.create(null);
            const metrics = /* @__PURE__ */ Object.create(null);
            {
              let i3 = 0;
              state.opIds.whichOp = i3++;
              state.opIds.rc = i3++;
              state.opIds.xAccess = i3++;
              state.opIds.xClose = i3++;
              state.opIds.xDelete = i3++;
              state.opIds.xDeleteNoWait = i3++;
              state.opIds.xFileSize = i3++;
              state.opIds.xLock = i3++;
              state.opIds.xOpen = i3++;
              state.opIds.xRead = i3++;
              state.opIds.xSleep = i3++;
              state.opIds.xSync = i3++;
              state.opIds.xTruncate = i3++;
              state.opIds.xUnlock = i3++;
              state.opIds.xWrite = i3++;
              state.opIds.mkdir = i3++;
              state.opIds["opfs-async-metrics"] = i3++;
              state.opIds["opfs-async-shutdown"] = i3++;
              state.opIds.retry = i3++;
              state.sabOP = new SharedArrayBuffer(i3 * 4);
              opfsUtil.metrics.reset();
            }
            state.sq3Codes = /* @__PURE__ */ Object.create(null);
            [
              "SQLITE_ACCESS_EXISTS",
              "SQLITE_ACCESS_READWRITE",
              "SQLITE_BUSY",
              "SQLITE_ERROR",
              "SQLITE_IOERR",
              "SQLITE_IOERR_ACCESS",
              "SQLITE_IOERR_CLOSE",
              "SQLITE_IOERR_DELETE",
              "SQLITE_IOERR_FSYNC",
              "SQLITE_IOERR_LOCK",
              "SQLITE_IOERR_READ",
              "SQLITE_IOERR_SHORT_READ",
              "SQLITE_IOERR_TRUNCATE",
              "SQLITE_IOERR_UNLOCK",
              "SQLITE_IOERR_WRITE",
              "SQLITE_LOCK_EXCLUSIVE",
              "SQLITE_LOCK_NONE",
              "SQLITE_LOCK_PENDING",
              "SQLITE_LOCK_RESERVED",
              "SQLITE_LOCK_SHARED",
              "SQLITE_LOCKED",
              "SQLITE_MISUSE",
              "SQLITE_NOTFOUND",
              "SQLITE_OPEN_CREATE",
              "SQLITE_OPEN_DELETEONCLOSE",
              "SQLITE_OPEN_MAIN_DB",
              "SQLITE_OPEN_READONLY"
            ].forEach((k2) => {
              if (void 0 === (state.sq3Codes[k2] = capi[k2])) {
                toss("Maintenance required: not found:", k2);
              }
            });
            state.opfsFlags = Object.assign(/* @__PURE__ */ Object.create(null), {
              OPFS_UNLOCK_ASAP: 1,
              OPFS_UNLINK_BEFORE_OPEN: 2,
              defaultUnlockAsap: false
            });
            const opRun = (op, ...args) => {
              const opNdx = state.opIds[op] || toss("Invalid op ID:", op);
              state.s11n.serialize(...args);
              Atomics.store(state.sabOPView, state.opIds.rc, -1);
              Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
              Atomics.notify(state.sabOPView, state.opIds.whichOp);
              const t4 = performance.now();
              Atomics.wait(state.sabOPView, state.opIds.rc, -1);
              const rc = Atomics.load(state.sabOPView, state.opIds.rc);
              metrics[op].wait += performance.now() - t4;
              if (rc && state.asyncS11nExceptions) {
                const err2 = state.s11n.deserialize();
                if (err2)
                  error(op + "() async error:", ...err2);
              }
              return rc;
            };
            opfsUtil.debug = {
              asyncShutdown: () => {
                warn(
                  "Shutting down OPFS async listener. The OPFS VFS will no longer work."
                );
                opRun("opfs-async-shutdown");
              },
              asyncRestart: () => {
                warn(
                  "Attempting to restart OPFS VFS async listener. Might work, might not."
                );
                W.postMessage({ type: "opfs-async-restart" });
              }
            };
            const initS11n = () => {
              if (state.s11n)
                return state.s11n;
              const textDecoder = new TextDecoder(), textEncoder = new TextEncoder("utf-8"), viewU8 = new Uint8Array(
                state.sabIO,
                state.sabS11nOffset,
                state.sabS11nSize
              ), viewDV = new DataView(
                state.sabIO,
                state.sabS11nOffset,
                state.sabS11nSize
              );
              state.s11n = /* @__PURE__ */ Object.create(null);
              const TypeIds = /* @__PURE__ */ Object.create(null);
              TypeIds.number = {
                id: 1,
                size: 8,
                getter: "getFloat64",
                setter: "setFloat64"
              };
              TypeIds.bigint = {
                id: 2,
                size: 8,
                getter: "getBigInt64",
                setter: "setBigInt64"
              };
              TypeIds.boolean = {
                id: 3,
                size: 4,
                getter: "getInt32",
                setter: "setInt32"
              };
              TypeIds.string = { id: 4 };
              const getTypeId = (v3) => TypeIds[typeof v3] || toss(
                "Maintenance required: this value type cannot be serialized.",
                v3
              );
              const getTypeIdById = (tid) => {
                switch (tid) {
                  case TypeIds.number.id:
                    return TypeIds.number;
                  case TypeIds.bigint.id:
                    return TypeIds.bigint;
                  case TypeIds.boolean.id:
                    return TypeIds.boolean;
                  case TypeIds.string.id:
                    return TypeIds.string;
                  default:
                    toss("Invalid type ID:", tid);
                }
              };
              state.s11n.deserialize = function(clear = false) {
                ++metrics.s11n.deserialize.count;
                const t4 = performance.now();
                const argc = viewU8[0];
                const rc = argc ? [] : null;
                if (argc) {
                  const typeIds = [];
                  let offset3 = 1, i3, n5, v3;
                  for (i3 = 0; i3 < argc; ++i3, ++offset3) {
                    typeIds.push(getTypeIdById(viewU8[offset3]));
                  }
                  for (i3 = 0; i3 < argc; ++i3) {
                    const t5 = typeIds[i3];
                    if (t5.getter) {
                      v3 = viewDV[t5.getter](offset3, state.littleEndian);
                      offset3 += t5.size;
                    } else {
                      n5 = viewDV.getInt32(offset3, state.littleEndian);
                      offset3 += 4;
                      v3 = textDecoder.decode(viewU8.slice(offset3, offset3 + n5));
                      offset3 += n5;
                    }
                    rc.push(v3);
                  }
                }
                if (clear)
                  viewU8[0] = 0;
                metrics.s11n.deserialize.time += performance.now() - t4;
                return rc;
              };
              state.s11n.serialize = function(...args) {
                const t4 = performance.now();
                ++metrics.s11n.serialize.count;
                if (args.length) {
                  const typeIds = [];
                  let i3 = 0, offset3 = 1;
                  viewU8[0] = args.length & 255;
                  for (; i3 < args.length; ++i3, ++offset3) {
                    typeIds.push(getTypeId(args[i3]));
                    viewU8[offset3] = typeIds[i3].id;
                  }
                  for (i3 = 0; i3 < args.length; ++i3) {
                    const t5 = typeIds[i3];
                    if (t5.setter) {
                      viewDV[t5.setter](offset3, args[i3], state.littleEndian);
                      offset3 += t5.size;
                    } else {
                      const s2 = textEncoder.encode(args[i3]);
                      viewDV.setInt32(offset3, s2.byteLength, state.littleEndian);
                      offset3 += 4;
                      viewU8.set(s2, offset3);
                      offset3 += s2.byteLength;
                    }
                  }
                } else {
                  viewU8[0] = 0;
                }
                metrics.s11n.serialize.time += performance.now() - t4;
              };
              return state.s11n;
            };
            const randomFilename = function f4(len = 16) {
              if (!f4._chars) {
                f4._chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012346789";
                f4._n = f4._chars.length;
              }
              const a2 = [];
              let i3 = 0;
              for (; i3 < len; ++i3) {
                const ndx = Math.random() * (f4._n * 64) % f4._n | 0;
                a2[i3] = f4._chars[ndx];
              }
              return a2.join("");
            };
            const __openFiles = /* @__PURE__ */ Object.create(null);
            const opTimer = /* @__PURE__ */ Object.create(null);
            opTimer.op = void 0;
            opTimer.start = void 0;
            const mTimeStart = (op) => {
              opTimer.start = performance.now();
              opTimer.op = op;
              ++metrics[op].count;
            };
            const mTimeEnd = () => metrics[opTimer.op].time += performance.now() - opTimer.start;
            const ioSyncWrappers = {
              xCheckReservedLock: function(pFile, pOut) {
                const f4 = __openFiles[pFile];
                wasm.poke(pOut, f4.lockType ? 1 : 0, "i32");
                return 0;
              },
              xClose: function(pFile) {
                mTimeStart("xClose");
                let rc = 0;
                const f4 = __openFiles[pFile];
                if (f4) {
                  delete __openFiles[pFile];
                  rc = opRun("xClose", pFile);
                  if (f4.sq3File)
                    f4.sq3File.dispose();
                }
                mTimeEnd();
                return rc;
              },
              xDeviceCharacteristics: function(pFile) {
                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
              },
              xFileControl: function(pFile, opId, pArg) {
                return capi.SQLITE_NOTFOUND;
              },
              xFileSize: function(pFile, pSz64) {
                mTimeStart("xFileSize");
                let rc = opRun("xFileSize", pFile);
                if (0 == rc) {
                  try {
                    const sz = state.s11n.deserialize()[0];
                    wasm.poke(pSz64, sz, "i64");
                  } catch (e5) {
                    error("Unexpected error reading xFileSize() result:", e5);
                    rc = state.sq3Codes.SQLITE_IOERR;
                  }
                }
                mTimeEnd();
                return rc;
              },
              xLock: function(pFile, lockType) {
                mTimeStart("xLock");
                const f4 = __openFiles[pFile];
                let rc = 0;
                if (!f4.lockType) {
                  rc = opRun("xLock", pFile, lockType);
                  if (0 === rc)
                    f4.lockType = lockType;
                } else {
                  f4.lockType = lockType;
                }
                mTimeEnd();
                return rc;
              },
              xRead: function(pFile, pDest, n5, offset64) {
                mTimeStart("xRead");
                const f4 = __openFiles[pFile];
                let rc;
                try {
                  rc = opRun("xRead", pFile, n5, Number(offset64));
                  if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {
                    wasm.heap8u().set(f4.sabView.subarray(0, n5), pDest);
                  }
                } catch (e5) {
                  error("xRead(", arguments, ") failed:", e5, f4);
                  rc = capi.SQLITE_IOERR_READ;
                }
                mTimeEnd();
                return rc;
              },
              xSync: function(pFile, flags) {
                mTimeStart("xSync");
                ++metrics.xSync.count;
                const rc = opRun("xSync", pFile, flags);
                mTimeEnd();
                return rc;
              },
              xTruncate: function(pFile, sz64) {
                mTimeStart("xTruncate");
                const rc = opRun("xTruncate", pFile, Number(sz64));
                mTimeEnd();
                return rc;
              },
              xUnlock: function(pFile, lockType) {
                mTimeStart("xUnlock");
                const f4 = __openFiles[pFile];
                let rc = 0;
                if (capi.SQLITE_LOCK_NONE === lockType && f4.lockType) {
                  rc = opRun("xUnlock", pFile, lockType);
                }
                if (0 === rc)
                  f4.lockType = lockType;
                mTimeEnd();
                return rc;
              },
              xWrite: function(pFile, pSrc, n5, offset64) {
                mTimeStart("xWrite");
                const f4 = __openFiles[pFile];
                let rc;
                try {
                  f4.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n5));
                  rc = opRun("xWrite", pFile, n5, Number(offset64));
                } catch (e5) {
                  error("xWrite(", arguments, ") failed:", e5, f4);
                  rc = capi.SQLITE_IOERR_WRITE;
                }
                mTimeEnd();
                return rc;
              }
            };
            const vfsSyncWrappers = {
              xAccess: function(pVfs, zName, flags, pOut) {
                mTimeStart("xAccess");
                const rc = opRun("xAccess", wasm.cstrToJs(zName));
                wasm.poke(pOut, rc ? 0 : 1, "i32");
                mTimeEnd();
                return 0;
              },
              xCurrentTime: function(pVfs, pOut) {
                wasm.poke(
                  pOut,
                  24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
                  "double"
                );
                return 0;
              },
              xCurrentTimeInt64: function(pVfs, pOut) {
                wasm.poke(
                  pOut,
                  24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(),
                  "i64"
                );
                return 0;
              },
              xDelete: function(pVfs, zName, doSyncDir) {
                mTimeStart("xDelete");
                const rc = opRun(
                  "xDelete",
                  wasm.cstrToJs(zName),
                  doSyncDir,
                  false
                );
                mTimeEnd();
                return rc;
              },
              xFullPathname: function(pVfs, zName, nOut, pOut) {
                const i3 = wasm.cstrncpy(pOut, zName, nOut);
                return i3 < nOut ? 0 : capi.SQLITE_CANTOPEN;
              },
              xGetLastError: function(pVfs, nOut, pOut) {
                warn("OPFS xGetLastError() has nothing sensible to return.");
                return 0;
              },
              xOpen: function f4(pVfs, zName, pFile, flags, pOutFlags) {
                mTimeStart("xOpen");
                let opfsFlags = 0;
                if (0 === zName) {
                  zName = randomFilename();
                } else if (wasm.isPtr(zName)) {
                  if (capi.sqlite3_uri_boolean(zName, "opfs-unlock-asap", 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
                  }
                  if (capi.sqlite3_uri_boolean(zName, "delete-before-open", 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLINK_BEFORE_OPEN;
                  }
                  zName = wasm.cstrToJs(zName);
                }
                const fh = /* @__PURE__ */ Object.create(null);
                fh.fid = pFile;
                fh.filename = zName;
                fh.sab = new SharedArrayBuffer(state.fileBufferSize);
                fh.flags = flags;
                const rc = opRun("xOpen", pFile, zName, flags, opfsFlags);
                if (!rc) {
                  if (fh.readOnly) {
                    wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, "i32");
                  }
                  __openFiles[pFile] = fh;
                  fh.sabView = state.sabFileBufView;
                  fh.sq3File = new sqlite3_file(pFile);
                  fh.sq3File.$pMethods = opfsIoMethods.pointer;
                  fh.lockType = capi.SQLITE_LOCK_NONE;
                }
                mTimeEnd();
                return rc;
              }
            };
            if (dVfs) {
              opfsVfs.$xRandomness = dVfs.$xRandomness;
              opfsVfs.$xSleep = dVfs.$xSleep;
            }
            if (!opfsVfs.$xRandomness) {
              vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut) {
                const heap = wasm.heap8u();
                let i3 = 0;
                for (; i3 < nOut; ++i3)
                  heap[pOut + i3] = Math.random() * 255e3 & 255;
                return i3;
              };
            }
            if (!opfsVfs.$xSleep) {
              vfsSyncWrappers.xSleep = function(pVfs, ms) {
                Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
                return 0;
              };
            }
            opfsUtil.getResolvedPath = function(filename, splitIt) {
              const p2 = new URL(filename, "file://irrelevant").pathname;
              return splitIt ? p2.split("/").filter((v3) => !!v3) : p2;
            };
            opfsUtil.getDirForFilename = async function f4(absFilename, createDirs = false) {
              const path2 = opfsUtil.getResolvedPath(absFilename, true);
              const filename = path2.pop();
              let dh = opfsUtil.rootDirectory;
              for (const dirName of path2) {
                if (dirName) {
                  dh = await dh.getDirectoryHandle(dirName, {
                    create: !!createDirs
                  });
                }
              }
              return [dh, filename];
            };
            opfsUtil.mkdir = async function(absDirName) {
              try {
                await opfsUtil.getDirForFilename(
                  absDirName + "/filepart",
                  true
                );
                return true;
              } catch (e5) {
                return false;
              }
            };
            opfsUtil.entryExists = async function(fsEntryName) {
              try {
                const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
                await dh.getFileHandle(fn);
                return true;
              } catch (e5) {
                return false;
              }
            };
            opfsUtil.randomFilename = randomFilename;
            opfsUtil.treeList = async function() {
              const doDir = async function callee3(dirHandle, tgt) {
                tgt.name = dirHandle.name;
                tgt.dirs = [];
                tgt.files = [];
                for await (const handle of dirHandle.values()) {
                  if ("directory" === handle.kind) {
                    const subDir = /* @__PURE__ */ Object.create(null);
                    tgt.dirs.push(subDir);
                    await callee3(handle, subDir);
                  } else {
                    tgt.files.push(handle.name);
                  }
                }
              };
              const root = /* @__PURE__ */ Object.create(null);
              await doDir(opfsUtil.rootDirectory, root);
              return root;
            };
            opfsUtil.rmfr = async function() {
              const dir = opfsUtil.rootDirectory, opt = { recurse: true };
              for await (const handle of dir.values()) {
                dir.removeEntry(handle.name, opt);
              }
            };
            opfsUtil.unlink = async function(fsEntryName, recursive = false, throwOnError = false) {
              try {
                const [hDir, filenamePart] = await opfsUtil.getDirForFilename(
                  fsEntryName,
                  false
                );
                await hDir.removeEntry(filenamePart, { recursive });
                return true;
              } catch (e5) {
                if (throwOnError) {
                  throw new Error(
                    "unlink(",
                    arguments[0],
                    ") failed: " + e5.message,
                    {
                      cause: e5
                    }
                  );
                }
                return false;
              }
            };
            opfsUtil.traverse = async function(opt) {
              const defaultOpt = {
                recursive: true,
                directory: opfsUtil.rootDirectory
              };
              if ("function" === typeof opt) {
                opt = { callback: opt };
              }
              opt = Object.assign(defaultOpt, opt || {});
              const doDir = async function callee3(dirHandle, depth) {
                for await (const handle of dirHandle.values()) {
                  if (false === opt.callback(handle, dirHandle, depth))
                    return false;
                  else if (opt.recursive && "directory" === handle.kind) {
                    if (false === await callee3(handle, depth + 1))
                      break;
                  }
                }
              };
              doDir(opt.directory, 0);
            };
            const importDbChunked = async function(filename, callback) {
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true
              );
              const hFile = await hDir.getFileHandle(fnamePart, {
                create: true
              });
              let sah = await hFile.createSyncAccessHandle();
              let nWrote = 0, chunk, checkedHeader = false, err2 = false;
              try {
                sah.truncate(0);
                while (void 0 !== (chunk = await callback())) {
                  if (chunk instanceof ArrayBuffer)
                    chunk = new Uint8Array(chunk);
                  if (0 === nWrote && chunk.byteLength >= 15) {
                    util.affirmDbHeader(chunk);
                    checkedHeader = true;
                  }
                  sah.write(chunk, { at: nWrote });
                  nWrote += chunk.byteLength;
                }
                if (nWrote < 512 || 0 !== nWrote % 512) {
                  toss(
                    "Input size",
                    nWrote,
                    "is not correct for an SQLite database."
                  );
                }
                if (!checkedHeader) {
                  const header = new Uint8Array(20);
                  sah.read(header, { at: 0 });
                  util.affirmDbHeader(header);
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e5) {
                await sah.close();
                sah = void 0;
                await hDir.removeEntry(fnamePart).catch(() => {
                });
                throw e5;
              } finally {
                if (sah)
                  await sah.close();
              }
            };
            opfsUtil.importDb = async function(filename, bytes) {
              if (bytes instanceof Function) {
                return importDbChunked(filename, bytes);
              }
              if (bytes instanceof ArrayBuffer)
                bytes = new Uint8Array(bytes);
              util.affirmIsDb(bytes);
              const n5 = bytes.byteLength;
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true
              );
              let sah, err2, nWrote = 0;
              try {
                const hFile = await hDir.getFileHandle(fnamePart, {
                  create: true
                });
                sah = await hFile.createSyncAccessHandle();
                sah.truncate(0);
                nWrote = sah.write(bytes, { at: 0 });
                if (nWrote != n5) {
                  toss(
                    "Expected to write " + n5 + " bytes but wrote " + nWrote + "."
                  );
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e5) {
                if (sah) {
                  await sah.close();
                  sah = void 0;
                }
                await hDir.removeEntry(fnamePart).catch(() => {
                });
                throw e5;
              } finally {
                if (sah)
                  await sah.close();
              }
            };
            if (sqlite3.oo1) {
              const OpfsDb = function(...args) {
                const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
                opt.vfs = opfsVfs.$zName;
                sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
              };
              OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
              sqlite3.oo1.OpfsDb = OpfsDb;
              OpfsDb.importDb = opfsUtil.importDb;
              sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                opfsVfs.pointer,
                function(oo1Db, sqlite32) {
                  sqlite32.capi.sqlite3_busy_timeout(oo1Db, 1e4);
                  sqlite32.capi.sqlite3_exec(
                    oo1Db,
                    [
                      "pragma journal_mode=DELETE;",
                      "pragma cache_size=-16384;"
                    ],
                    0,
                    0,
                    0
                  );
                }
              );
            }
            const sanityCheck = function() {
              const scope = wasm.scopedAllocPush();
              const sq3File = new sqlite3_file();
              try {
                const fid = sq3File.pointer;
                const openFlags = capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE | capi.SQLITE_OPEN_MAIN_DB;
                const pOut = wasm.scopedAlloc(8);
                const dbFile = "/sanity/check/file" + randomFilename(8);
                const zDbFile = wasm.scopedAllocCString(dbFile);
                let rc;
                state.s11n.serialize("This is \xE4 string.");
                rc = state.s11n.deserialize();
                log3("deserialize() says:", rc);
                if ("This is \xE4 string." !== rc[0])
                  toss("String d13n error.");
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                log3("xAccess(", dbFile, ") exists ?=", rc);
                rc = vfsSyncWrappers.xOpen(
                  opfsVfs.pointer,
                  zDbFile,
                  fid,
                  openFlags,
                  pOut
                );
                log3(
                  "open rc =",
                  rc,
                  "state.sabOPView[xOpen] =",
                  state.sabOPView[state.opIds.xOpen]
                );
                if (0 !== rc) {
                  error("open failed with code", rc);
                  return;
                }
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                if (!rc)
                  toss("xAccess() failed to detect file.");
                rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
                if (rc)
                  toss("sync failed w/ rc", rc);
                rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
                if (rc)
                  toss("truncate failed w/ rc", rc);
                wasm.poke(pOut, 0, "i64");
                rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
                if (rc)
                  toss("xFileSize failed w/ rc", rc);
                log3("xFileSize says:", wasm.peek(pOut, "i64"));
                rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
                if (rc)
                  toss("xWrite() failed!");
                const readBuf = wasm.scopedAlloc(16);
                rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
                wasm.poke(readBuf + 6, 0);
                let jRead = wasm.cstrToJs(readBuf);
                log3("xRead() got:", jRead);
                if ("sanity" !== jRead)
                  toss("Unexpected xRead() value.");
                if (vfsSyncWrappers.xSleep) {
                  log3("xSleep()ing before close()ing...");
                  vfsSyncWrappers.xSleep(opfsVfs.pointer, 2e3);
                  log3("waking up from xSleep()");
                }
                rc = ioSyncWrappers.xClose(fid);
                log3("xClose rc =", rc, "sabOPView =", state.sabOPView);
                log3("Deleting file:", dbFile);
                vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 4660);
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                if (rc)
                  toss(
                    "Expecting 0 from xAccess(",
                    dbFile,
                    ") after xDelete()."
                  );
                warn("End of OPFS sanity checks.");
              } finally {
                sq3File.dispose();
                wasm.scopedAllocPop(scope);
              }
            };
            W.onmessage = function({ data }) {
              switch (data.type) {
                case "opfs-unavailable":
                  promiseReject(new Error(data.payload.join(" ")));
                  break;
                case "opfs-async-loaded":
                  W.postMessage({ type: "opfs-async-init", args: state });
                  break;
                case "opfs-async-inited": {
                  if (true === promiseWasRejected) {
                    break;
                  }
                  try {
                    sqlite3.vfs.installVfs({
                      io: { struct: opfsIoMethods, methods: ioSyncWrappers },
                      vfs: { struct: opfsVfs, methods: vfsSyncWrappers }
                    });
                    state.sabOPView = new Int32Array(state.sabOP);
                    state.sabFileBufView = new Uint8Array(
                      state.sabIO,
                      0,
                      state.fileBufferSize
                    );
                    state.sabS11nView = new Uint8Array(
                      state.sabIO,
                      state.sabS11nOffset,
                      state.sabS11nSize
                    );
                    initS11n();
                    if (options.sanityChecks) {
                      warn(
                        "Running sanity checks because of opfs-sanity-check URL arg..."
                      );
                      sanityCheck();
                    }
                    if (thisThreadHasOPFS()) {
                      navigator.storage.getDirectory().then((d2) => {
                        W.onerror = W._originalOnError;
                        delete W._originalOnError;
                        sqlite3.opfs = opfsUtil;
                        opfsUtil.rootDirectory = d2;
                        log3("End of OPFS sqlite3_vfs setup.", opfsVfs);
                        promiseResolve();
                      }).catch(promiseReject);
                    } else {
                      promiseResolve();
                    }
                  } catch (e5) {
                    error(e5);
                    promiseReject(e5);
                  }
                  break;
                }
                default: {
                  const errMsg = "Unexpected message from the OPFS async worker: " + JSON.stringify(data);
                  error(errMsg);
                  promiseReject(new Error(errMsg));
                  break;
                }
              }
            };
          });
          return thePromise;
        };
        installOpfsVfs.defaultProxyUri = "sqlite3-opfs-async-proxy.js";
        globalThis.sqlite3ApiBootstrap.initializersAsync.push(
          async (sqlite32) => {
            try {
              let proxyJs = installOpfsVfs.defaultProxyUri;
              if (sqlite32.scriptInfo.sqlite3Dir) {
                installOpfsVfs.defaultProxyUri = sqlite32.scriptInfo.sqlite3Dir + proxyJs;
              }
              return installOpfsVfs().catch((e5) => {
                sqlite32.config.warn(
                  "Ignoring inability to install OPFS sqlite3_vfs:",
                  e5.message
                );
              });
            } catch (e5) {
              sqlite32.config.error("installOpfsVfs() exception:", e5);
              return Promise.reject(e5);
            }
          }
        );
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        "use strict";
        const toss = sqlite3.util.toss;
        const toss3 = sqlite3.util.toss3;
        const initPromises = /* @__PURE__ */ Object.create(null);
        const capi = sqlite3.capi;
        const util = sqlite3.util;
        const wasm = sqlite3.wasm;
        const SECTOR_SIZE = 4096;
        const HEADER_MAX_PATH_SIZE = 512;
        const HEADER_FLAGS_SIZE = 4;
        const HEADER_DIGEST_SIZE = 8;
        const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
        const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
        const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
        const HEADER_OFFSET_DATA = SECTOR_SIZE;
        const PERSISTENT_FILE_TYPES = capi.SQLITE_OPEN_MAIN_DB | capi.SQLITE_OPEN_MAIN_JOURNAL | capi.SQLITE_OPEN_SUPER_JOURNAL | capi.SQLITE_OPEN_WAL;
        const OPAQUE_DIR_NAME = ".opaque";
        const getRandomName = () => Math.random().toString(36).slice(2);
        const textDecoder = new TextDecoder();
        const textEncoder = new TextEncoder();
        const optionDefaults = Object.assign(/* @__PURE__ */ Object.create(null), {
          name: "opfs-sahpool",
          directory: void 0,
          initialCapacity: 6,
          clearOnInit: false,
          verbosity: 2
        });
        const loggers = [
          sqlite3.config.error,
          sqlite3.config.warn,
          sqlite3.config.log
        ];
        const log3 = sqlite3.config.log;
        const warn = sqlite3.config.warn;
        const error = sqlite3.config.error;
        const __mapVfsToPool = /* @__PURE__ */ new Map();
        const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);
        const setPoolForVfs = (pVfs, pool) => {
          if (pool)
            __mapVfsToPool.set(pVfs, pool);
          else
            __mapVfsToPool.delete(pVfs);
        };
        const __mapSqlite3File = /* @__PURE__ */ new Map();
        const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);
        const setPoolForPFile = (pFile, pool) => {
          if (pool)
            __mapSqlite3File.set(pFile, pool);
          else
            __mapSqlite3File.delete(pFile);
        };
        const ioMethods = {
          xCheckReservedLock: function(pFile, pOut) {
            const pool = getPoolForPFile(pFile);
            pool.log("xCheckReservedLock");
            pool.storeErr();
            wasm.poke32(pOut, 1);
            return 0;
          },
          xClose: function(pFile) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            if (file) {
              try {
                pool.log(`xClose ${file.path}`);
                pool.mapS3FileToOFile(pFile, false);
                file.sah.flush();
                if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {
                  pool.deletePath(file.path);
                }
              } catch (e5) {
                return pool.storeErr(e5, capi.SQLITE_IOERR);
              }
            }
            return 0;
          },
          xDeviceCharacteristics: function(pFile) {
            return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
          },
          xFileControl: function(pFile, opId, pArg) {
            return capi.SQLITE_NOTFOUND;
          },
          xFileSize: function(pFile, pSz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xFileSize`);
            const file = pool.getOFileForS3File(pFile);
            const size3 = file.sah.getSize() - HEADER_OFFSET_DATA;
            wasm.poke64(pSz64, BigInt(size3));
            return 0;
          },
          xLock: function(pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xLock ${lockType}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xRead: function(pFile, pDest, n5, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xRead ${file.path} ${n5} @ ${offset64}`);
            try {
              const nRead = file.sah.read(
                wasm.heap8u().subarray(pDest, pDest + n5),
                { at: HEADER_OFFSET_DATA + Number(offset64) }
              );
              if (nRead < n5) {
                wasm.heap8u().fill(0, pDest + nRead, pDest + n5);
                return capi.SQLITE_IOERR_SHORT_READ;
              }
              return 0;
            } catch (e5) {
              return pool.storeErr(e5, capi.SQLITE_IOERR);
            }
          },
          xSectorSize: function(pFile) {
            return SECTOR_SIZE;
          },
          xSync: function(pFile, flags) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xSync ${flags}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            try {
              file.sah.flush();
              return 0;
            } catch (e5) {
              return pool.storeErr(e5, capi.SQLITE_IOERR);
            }
          },
          xTruncate: function(pFile, sz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xTruncate ${sz64}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            try {
              file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
              return 0;
            } catch (e5) {
              return pool.storeErr(e5, capi.SQLITE_IOERR);
            }
          },
          xUnlock: function(pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log("xUnlock");
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xWrite: function(pFile, pSrc, n5, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xWrite ${file.path} ${n5} ${offset64}`);
            try {
              const nBytes = file.sah.write(
                wasm.heap8u().subarray(pSrc, pSrc + n5),
                { at: HEADER_OFFSET_DATA + Number(offset64) }
              );
              return n5 === nBytes ? 0 : toss("Unknown write() failure.");
            } catch (e5) {
              return pool.storeErr(e5, capi.SQLITE_IOERR);
            }
          }
        };
        const opfsIoMethods = new capi.sqlite3_io_methods();
        opfsIoMethods.$iVersion = 1;
        sqlite3.vfs.installVfs({
          io: { struct: opfsIoMethods, methods: ioMethods }
        });
        const vfsMethods = {
          xAccess: function(pVfs, zName, flags, pOut) {
            const pool = getPoolForVfs(pVfs);
            pool.storeErr();
            try {
              const name = pool.getPath(zName);
              wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
            } catch (e5) {
              wasm.poke32(pOut, 0);
            }
            return 0;
          },
          xCurrentTime: function(pVfs, pOut) {
            wasm.poke(
              pOut,
              24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
              "double"
            );
            return 0;
          },
          xCurrentTimeInt64: function(pVfs, pOut) {
            wasm.poke(pOut, 24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(), "i64");
            return 0;
          },
          xDelete: function(pVfs, zName, doSyncDir) {
            const pool = getPoolForVfs(pVfs);
            pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
            pool.storeErr();
            try {
              pool.deletePath(pool.getPath(zName));
              return 0;
            } catch (e5) {
              pool.storeErr(e5);
              return capi.SQLITE_IOERR_DELETE;
            }
          },
          xFullPathname: function(pVfs, zName, nOut, pOut) {
            const i3 = wasm.cstrncpy(pOut, zName, nOut);
            return i3 < nOut ? 0 : capi.SQLITE_CANTOPEN;
          },
          xGetLastError: function(pVfs, nOut, pOut) {
            const pool = getPoolForVfs(pVfs);
            const e5 = pool.popErr();
            pool.log(`xGetLastError ${nOut} e =`, e5);
            if (e5) {
              const scope = wasm.scopedAllocPush();
              try {
                const [cMsg, n5] = wasm.scopedAllocCString(e5.message, true);
                wasm.cstrncpy(pOut, cMsg, nOut);
                if (n5 > nOut)
                  wasm.poke8(pOut + nOut - 1, 0);
              } catch (e6) {
                return capi.SQLITE_NOMEM;
              } finally {
                wasm.scopedAllocPop(scope);
              }
            }
            return e5 ? e5.sqlite3Rc || capi.SQLITE_IOERR : 0;
          },
          xOpen: function f4(pVfs, zName, pFile, flags, pOutFlags) {
            const pool = getPoolForVfs(pVfs);
            try {
              pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);
              const path2 = zName && wasm.peek8(zName) ? pool.getPath(zName) : getRandomName();
              let sah = pool.getSAHForPath(path2);
              if (!sah && flags & capi.SQLITE_OPEN_CREATE) {
                if (pool.getFileCount() < pool.getCapacity()) {
                  sah = pool.nextAvailableSAH();
                  pool.setAssociatedPath(sah, path2, flags);
                } else {
                  toss("SAH pool is full. Cannot create file", path2);
                }
              }
              if (!sah) {
                toss("file not found:", path2);
              }
              const file = { path: path2, flags, sah };
              pool.mapS3FileToOFile(pFile, file);
              file.lockType = capi.SQLITE_LOCK_NONE;
              const sq3File = new capi.sqlite3_file(pFile);
              sq3File.$pMethods = opfsIoMethods.pointer;
              sq3File.dispose();
              wasm.poke32(pOutFlags, flags);
              return 0;
            } catch (e5) {
              pool.storeErr(e5);
              return capi.SQLITE_CANTOPEN;
            }
          }
        };
        const createOpfsVfs = function(vfsName) {
          if (sqlite3.capi.sqlite3_vfs_find(vfsName)) {
            toss3("VFS name is already registered:", vfsName);
          }
          const opfsVfs = new capi.sqlite3_vfs();
          const pDVfs = capi.sqlite3_vfs_find(null);
          const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;
          opfsVfs.$iVersion = 2;
          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
          opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
          opfsVfs.addOnDispose(
            opfsVfs.$zName = wasm.allocCString(vfsName),
            () => setPoolForVfs(opfsVfs.pointer, 0)
          );
          if (dVfs) {
            opfsVfs.$xRandomness = dVfs.$xRandomness;
            opfsVfs.$xSleep = dVfs.$xSleep;
            dVfs.dispose();
          }
          if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {
            vfsMethods.xRandomness = function(pVfs, nOut, pOut) {
              const heap = wasm.heap8u();
              let i3 = 0;
              for (; i3 < nOut; ++i3)
                heap[pOut + i3] = Math.random() * 255e3 & 255;
              return i3;
            };
          }
          if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {
            vfsMethods.xSleep = (pVfs, ms) => 0;
          }
          sqlite3.vfs.installVfs({
            vfs: { struct: opfsVfs, methods: vfsMethods }
          });
          return opfsVfs;
        };
        class OpfsSAHPool {
          vfsDir;
          #dhVfsRoot;
          #dhOpaque;
          #dhVfsParent;
          #mapSAHToName = /* @__PURE__ */ new Map();
          #mapFilenameToSAH = /* @__PURE__ */ new Map();
          #availableSAH = /* @__PURE__ */ new Set();
          #mapS3FileToOFile_ = /* @__PURE__ */ new Map();
          #apBody = new Uint8Array(HEADER_CORPUS_SIZE);
          #dvBody;
          #cVfs;
          #verbosity;
          constructor(options = /* @__PURE__ */ Object.create(null)) {
            this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
            this.vfsName = options.name || optionDefaults.name;
            this.#cVfs = createOpfsVfs(this.vfsName);
            setPoolForVfs(this.#cVfs.pointer, this);
            this.vfsDir = options.directory || "." + this.vfsName;
            this.#dvBody = new DataView(
              this.#apBody.buffer,
              this.#apBody.byteOffset
            );
            this.isReady = this.reset(
              !!(options.clearOnInit ?? optionDefaults.clearOnInit)
            ).then(() => {
              if (this.$error)
                throw this.$error;
              return this.getCapacity() ? Promise.resolve(void 0) : this.addCapacity(
                options.initialCapacity || optionDefaults.initialCapacity
              );
            });
          }
          #logImpl(level, ...args) {
            if (this.#verbosity > level)
              loggers[level](this.vfsName + ":", ...args);
          }
          log(...args) {
            this.#logImpl(2, ...args);
          }
          warn(...args) {
            this.#logImpl(1, ...args);
          }
          error(...args) {
            this.#logImpl(0, ...args);
          }
          getVfs() {
            return this.#cVfs;
          }
          getCapacity() {
            return this.#mapSAHToName.size;
          }
          getFileCount() {
            return this.#mapFilenameToSAH.size;
          }
          getFileNames() {
            const rc = [];
            const iter = this.#mapFilenameToSAH.keys();
            for (const n5 of iter)
              rc.push(n5);
            return rc;
          }
          async addCapacity(n5) {
            for (let i3 = 0; i3 < n5; ++i3) {
              const name = getRandomName();
              const h4 = await this.#dhOpaque.getFileHandle(name, {
                create: true
              });
              const ah = await h4.createSyncAccessHandle();
              this.#mapSAHToName.set(ah, name);
              this.setAssociatedPath(ah, "", 0);
            }
            return this.getCapacity();
          }
          async reduceCapacity(n5) {
            let nRm = 0;
            for (const ah of Array.from(this.#availableSAH)) {
              if (nRm === n5 || this.getFileCount() === this.getCapacity()) {
                break;
              }
              const name = this.#mapSAHToName.get(ah);
              ah.close();
              await this.#dhOpaque.removeEntry(name);
              this.#mapSAHToName.delete(ah);
              this.#availableSAH.delete(ah);
              ++nRm;
            }
            return nRm;
          }
          releaseAccessHandles() {
            for (const ah of this.#mapSAHToName.keys())
              ah.close();
            this.#mapSAHToName.clear();
            this.#mapFilenameToSAH.clear();
            this.#availableSAH.clear();
          }
          async acquireAccessHandles(clearFiles) {
            const files = [];
            for await (const [name, h4] of this.#dhOpaque) {
              if ("file" === h4.kind) {
                files.push([name, h4]);
              }
            }
            return Promise.all(
              files.map(async ([name, h4]) => {
                try {
                  const ah = await h4.createSyncAccessHandle();
                  this.#mapSAHToName.set(ah, name);
                  if (clearFiles) {
                    ah.truncate(HEADER_OFFSET_DATA);
                    this.setAssociatedPath(ah, "", 0);
                  } else {
                    const path2 = this.getAssociatedPath(ah);
                    if (path2) {
                      this.#mapFilenameToSAH.set(path2, ah);
                    } else {
                      this.#availableSAH.add(ah);
                    }
                  }
                } catch (e5) {
                  this.storeErr(e5);
                  this.releaseAccessHandles();
                  throw e5;
                }
              })
            );
          }
          getAssociatedPath(sah) {
            sah.read(this.#apBody, { at: 0 });
            const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
            if (this.#apBody[0] && (flags & capi.SQLITE_OPEN_DELETEONCLOSE || (flags & PERSISTENT_FILE_TYPES) === 0)) {
              warn(
                `Removing file with unexpected flags ${flags.toString(16)}`,
                this.#apBody
              );
              this.setAssociatedPath(sah, "", 0);
              return "";
            }
            const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
            sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
            const compDigest = this.computeDigest(this.#apBody);
            if (fileDigest.every((v3, i3) => v3 === compDigest[i3])) {
              const pathBytes = this.#apBody.findIndex((v3) => 0 === v3);
              if (0 === pathBytes) {
                sah.truncate(HEADER_OFFSET_DATA);
              }
              return pathBytes ? textDecoder.decode(this.#apBody.subarray(0, pathBytes)) : "";
            } else {
              warn("Disassociating file with bad digest.");
              this.setAssociatedPath(sah, "", 0);
              return "";
            }
          }
          setAssociatedPath(sah, path2, flags) {
            const enc = textEncoder.encodeInto(path2, this.#apBody);
            if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {
              toss("Path too long:", path2);
            }
            this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
            this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);
            const digest = this.computeDigest(this.#apBody);
            sah.write(this.#apBody, { at: 0 });
            sah.write(digest, { at: HEADER_OFFSET_DIGEST });
            sah.flush();
            if (path2) {
              this.#mapFilenameToSAH.set(path2, sah);
              this.#availableSAH.delete(sah);
            } else {
              sah.truncate(HEADER_OFFSET_DATA);
              this.#availableSAH.add(sah);
            }
          }
          computeDigest(byteArray) {
            let h1 = 3735928559;
            let h22 = 1103547991;
            for (const v3 of byteArray) {
              h1 = 31 * h1 + v3 * 307;
              h22 = 31 * h22 + v3 * 307;
            }
            return new Uint32Array([h1 >>> 0, h22 >>> 0]);
          }
          async reset(clearFiles) {
            await this.isReady;
            let h4 = await navigator.storage.getDirectory();
            let prev, prevName;
            for (const d2 of this.vfsDir.split("/")) {
              if (d2) {
                prev = h4;
                h4 = await h4.getDirectoryHandle(d2, { create: true });
              }
            }
            this.#dhVfsRoot = h4;
            this.#dhVfsParent = prev;
            this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
              OPAQUE_DIR_NAME,
              { create: true }
            );
            this.releaseAccessHandles();
            return this.acquireAccessHandles(clearFiles);
          }
          getPath(arg) {
            if (wasm.isPtr(arg))
              arg = wasm.cstrToJs(arg);
            return (arg instanceof URL ? arg : new URL(arg, "file://localhost/")).pathname;
          }
          deletePath(path2) {
            const sah = this.#mapFilenameToSAH.get(path2);
            if (sah) {
              this.#mapFilenameToSAH.delete(path2);
              this.setAssociatedPath(sah, "", 0);
            }
            return !!sah;
          }
          storeErr(e5, code) {
            if (e5) {
              e5.sqlite3Rc = code || capi.SQLITE_IOERR;
              this.error(e5);
            }
            this.$error = e5;
            return code;
          }
          popErr() {
            const rc = this.$error;
            this.$error = void 0;
            return rc;
          }
          nextAvailableSAH() {
            const [rc] = this.#availableSAH.keys();
            return rc;
          }
          getOFileForS3File(pFile) {
            return this.#mapS3FileToOFile_.get(pFile);
          }
          mapS3FileToOFile(pFile, file) {
            if (file) {
              this.#mapS3FileToOFile_.set(pFile, file);
              setPoolForPFile(pFile, this);
            } else {
              this.#mapS3FileToOFile_.delete(pFile);
              setPoolForPFile(pFile, false);
            }
          }
          hasFilename(name) {
            return this.#mapFilenameToSAH.has(name);
          }
          getSAHForPath(path2) {
            return this.#mapFilenameToSAH.get(path2);
          }
          async removeVfs() {
            if (!this.#cVfs.pointer || !this.#dhOpaque)
              return false;
            capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
            this.#cVfs.dispose();
            try {
              this.releaseAccessHandles();
              await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {
                recursive: true
              });
              this.#dhOpaque = void 0;
              await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {
                recursive: true
              });
              this.#dhVfsRoot = this.#dhVfsParent = void 0;
            } catch (e5) {
              sqlite3.config.error(this.vfsName, "removeVfs() failed:", e5);
            }
            return true;
          }
          exportFile(name) {
            const sah = this.#mapFilenameToSAH.get(name) || toss("File not found:", name);
            const n5 = sah.getSize() - HEADER_OFFSET_DATA;
            const b2 = new Uint8Array(n5 > 0 ? n5 : 0);
            if (n5 > 0) {
              const nRead = sah.read(b2, { at: HEADER_OFFSET_DATA });
              if (nRead != n5) {
                toss(
                  "Expected to read " + n5 + " bytes but read " + nRead + "."
                );
              }
            }
            return b2;
          }
          async importDbChunked(name, callback) {
            const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
            sah.truncate(0);
            let nWrote = 0, chunk, checkedHeader = false, err2 = false;
            try {
              while (void 0 !== (chunk = await callback())) {
                if (chunk instanceof ArrayBuffer)
                  chunk = new Uint8Array(chunk);
                if (0 === nWrote && chunk.byteLength >= 15) {
                  util.affirmDbHeader(chunk);
                  checkedHeader = true;
                }
                sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });
                nWrote += chunk.byteLength;
              }
              if (nWrote < 512 || 0 !== nWrote % 512) {
                toss(
                  "Input size",
                  nWrote,
                  "is not correct for an SQLite database."
                );
              }
              if (!checkedHeader) {
                const header = new Uint8Array(20);
                sah.read(header, { at: 0 });
                util.affirmDbHeader(header);
              }
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18
              });
            } catch (e5) {
              this.setAssociatedPath(sah, "", 0);
              throw e5;
            }
            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            return nWrote;
          }
          importDb(name, bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            else if (bytes instanceof Function)
              return this.importDbChunked(name, bytes);
            const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
            const n5 = bytes.byteLength;
            if (n5 < 512 || n5 % 512 != 0) {
              toss("Byte array size is invalid for an SQLite db.");
            }
            const header = "SQLite format 3";
            for (let i3 = 0; i3 < header.length; ++i3) {
              if (header.charCodeAt(i3) !== bytes[i3]) {
                toss("Input does not contain an SQLite database header.");
              }
            }
            const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });
            if (nWrote != n5) {
              this.setAssociatedPath(sah, "", 0);
              toss(
                "Expected to write " + n5 + " bytes but wrote " + nWrote + "."
              );
            } else {
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18
              });
              this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            }
            return nWrote;
          }
        }
        class OpfsSAHPoolUtil {
          #p;
          constructor(sahPool) {
            this.#p = sahPool;
            this.vfsName = sahPool.vfsName;
          }
          async addCapacity(n5) {
            return this.#p.addCapacity(n5);
          }
          async reduceCapacity(n5) {
            return this.#p.reduceCapacity(n5);
          }
          getCapacity() {
            return this.#p.getCapacity(this.#p);
          }
          getFileCount() {
            return this.#p.getFileCount();
          }
          getFileNames() {
            return this.#p.getFileNames();
          }
          async reserveMinimumCapacity(min6) {
            const c4 = this.#p.getCapacity();
            return c4 < min6 ? this.#p.addCapacity(min6 - c4) : c4;
          }
          exportFile(name) {
            return this.#p.exportFile(name);
          }
          importDb(name, bytes) {
            return this.#p.importDb(name, bytes);
          }
          async wipeFiles() {
            return this.#p.reset(true);
          }
          unlink(filename) {
            return this.#p.deletePath(filename);
          }
          async removeVfs() {
            return this.#p.removeVfs();
          }
        }
        const apiVersionCheck = async () => {
          const dh = await navigator.storage.getDirectory();
          const fn = ".opfs-sahpool-sync-check-" + getRandomName();
          const fh = await dh.getFileHandle(fn, { create: true });
          const ah = await fh.createSyncAccessHandle();
          const close = ah.close();
          await close;
          await dh.removeEntry(fn);
          if (close?.then) {
            toss(
              "The local OPFS API is too old for opfs-sahpool:",
              "it has an async FileSystemSyncAccessHandle.close() method."
            );
          }
          return true;
        };
        let instanceCounter = 0;
        sqlite3.installOpfsSAHPoolVfs = async function(options = /* @__PURE__ */ Object.create(null)) {
          const vfsName = options.name || optionDefaults.name;
          if (0) {
            throw new Error("Just testing rejection.");
          }
          if (initPromises[vfsName]) {
            return initPromises[vfsName];
          }
          if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !navigator?.storage?.getDirectory) {
            return initPromises[vfsName] = Promise.reject(
              new Error("Missing required OPFS APIs.")
            );
          }
          return initPromises[vfsName] = apiVersionCheck().then(async function() {
            if (options.$testThrowInInit) {
              throw options.$testThrowInInit;
            }
            const thePool = new OpfsSAHPool(options);
            return thePool.isReady.then(async () => {
              const poolUtil = new OpfsSAHPoolUtil(thePool);
              if (sqlite3.oo1) {
                const oo1 = sqlite3.oo1;
                const theVfs = thePool.getVfs();
                const OpfsSAHPoolDb = function(...args) {
                  const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
                  opt.vfs = theVfs.$zName;
                  oo1.DB.dbCtorHelper.call(this, opt);
                };
                OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);
                poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
                oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                  theVfs.pointer,
                  function(oo1Db, sqlite32) {
                    sqlite32.capi.sqlite3_exec(
                      oo1Db,
                      [
                        "pragma journal_mode=DELETE;",
                        "pragma cache_size=-16384;"
                      ],
                      0,
                      0,
                      0
                    );
                  }
                );
              }
              thePool.log("VFS initialized.");
              return poolUtil;
            }).catch(async (e5) => {
              await thePool.removeVfs().catch(() => {
              });
              throw e5;
            });
          }).catch((err2) => {
            return initPromises[vfsName] = Promise.reject(err2);
          });
        };
      });
      "use strict";
      if ("undefined" !== typeof Module2) {
        const SABC = Object.assign(
          /* @__PURE__ */ Object.create(null),
          {
            exports: "undefined" === typeof wasmExports ? Module2["asm"] : wasmExports,
            memory: Module2.wasmMemory
          },
          globalThis.sqlite3ApiConfig || {}
        );
        globalThis.sqlite3ApiConfig = SABC;
        let sqlite3;
        try {
          sqlite3 = globalThis.sqlite3ApiBootstrap();
        } catch (e5) {
          console.error("sqlite3ApiBootstrap() error:", e5);
          throw e5;
        } finally {
          delete globalThis.sqlite3ApiBootstrap;
          delete globalThis.sqlite3ApiConfig;
        }
        Module2.sqlite3 = sqlite3;
      } else {
        console.warn(
          "This is not running in an Emscripten module context, so",
          "globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack",
          "of config info for the WASM environment.",
          "It must be called manually."
        );
      }
    });
    return sqlite3InitModule2.ready;
  };
})();
var toExportForESM = function() {
  const originalInit = sqlite3InitModule;
  if (!originalInit) {
    throw new Error(
      "Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build."
    );
  }
  const initModuleState = globalThis.sqlite3InitModuleState = Object.assign(
    /* @__PURE__ */ Object.create(null),
    {
      moduleScript: globalThis?.document?.currentScript,
      isWorker: "undefined" !== typeof WorkerGlobalScope,
      location: globalThis.location,
      urlParams: globalThis?.location?.href ? new URL(globalThis.location.href).searchParams : new URLSearchParams()
    }
  );
  initModuleState.debugModule = initModuleState.urlParams.has(
    "sqlite3.debugModule"
  ) ? (...args) => console.warn("sqlite3.debugModule:", ...args) : () => {
  };
  if (initModuleState.urlParams.has("sqlite3.dir")) {
    initModuleState.sqlite3Dir = initModuleState.urlParams.get("sqlite3.dir") + "/";
  } else if (initModuleState.moduleScript) {
    const li = initModuleState.moduleScript.src.split("/");
    li.pop();
    initModuleState.sqlite3Dir = li.join("/") + "/";
  }
  globalThis.sqlite3InitModule = function ff(...args) {
    return originalInit(...args).then((EmscriptenModule) => {
      const s2 = EmscriptenModule.sqlite3;
      s2.scriptInfo = initModuleState;
      if (ff.__isUnderTest)
        s2.__isUnderTest = true;
      const f4 = s2.asyncPostInit;
      delete s2.asyncPostInit;
      return f4();
    }).catch((e5) => {
      console.error("Exception loading sqlite3 module:", e5);
      throw e5;
    });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;
  if (globalThis.sqlite3InitModuleState.moduleScript) {
    const sim = globalThis.sqlite3InitModuleState;
    let src = sim.moduleScript.src.split("/");
    src.pop();
    sim.scriptDir = src.join("/") + "/";
  }
  initModuleState.debugModule("sqlite3InitModuleState =", initModuleState);
  if (0) {
    console.warn("Replaced sqlite3InitModule()");
    console.warn("globalThis.location.href =", globalThis.location.href);
    if ("undefined" !== typeof document) {
      console.warn(
        "document.currentScript.src =",
        document?.currentScript?.src
      );
    }
  }
  return globalThis.sqlite3InitModule;
}();
sqlite3InitModule = toExportForESM;

// ../../../node_modules/.pnpm/@eliaspourquoi+sqlite-node-wasm@3.46.0-build2/node_modules/@eliaspourquoi/sqlite-node-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs
globalThis.sqlite3Worker1Promiser = function callee(config = callee.defaultConfig) {
  if (1 === arguments.length && "function" === typeof arguments[0]) {
    const f4 = config;
    config = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig);
    config.onready = f4;
  } else {
    config = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig, config);
  }
  const handlerMap = /* @__PURE__ */ Object.create(null);
  const noop = function() {
  };
  const err = config.onerror || noop;
  const debug = config.debug || noop;
  const idTypeMap = config.generateMessageId ? void 0 : /* @__PURE__ */ Object.create(null);
  const genMsgId = config.generateMessageId || function(msg) {
    return msg.type + "#" + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1);
  };
  const toss = (...args) => {
    throw new Error(args.join(" "));
  };
  if (!config.worker)
    config.worker = callee.defaultConfig.worker;
  if ("function" === typeof config.worker)
    config.worker = config.worker();
  let dbId;
  let promiserFunc;
  config.worker.onmessage = function(ev) {
    ev = ev.data;
    debug("worker1.onmessage", ev);
    let msgHandler = handlerMap[ev.messageId];
    if (!msgHandler) {
      if (ev && "sqlite3-api" === ev.type && "worker1-ready" === ev.result) {
        if (config.onready)
          config.onready(promiserFunc);
        return;
      }
      msgHandler = handlerMap[ev.type];
      if (msgHandler && msgHandler.onrow) {
        msgHandler.onrow(ev);
        return;
      }
      if (config.onunhandled)
        config.onunhandled(arguments[0]);
      else
        err("sqlite3Worker1Promiser() unhandled worker message:", ev);
      return;
    }
    delete handlerMap[ev.messageId];
    switch (ev.type) {
      case "error":
        msgHandler.reject(ev);
        return;
      case "open":
        if (!dbId)
          dbId = ev.dbId;
        break;
      case "close":
        if (ev.dbId === dbId)
          dbId = void 0;
        break;
      default:
        break;
    }
    try {
      msgHandler.resolve(ev);
    } catch (e5) {
      msgHandler.reject(e5);
    }
  };
  return promiserFunc = function() {
    let msg;
    if (1 === arguments.length) {
      msg = arguments[0];
    } else if (2 === arguments.length) {
      msg = /* @__PURE__ */ Object.create(null);
      msg.type = arguments[0];
      msg.args = arguments[1];
      msg.dbId = msg.args.dbId;
    } else {
      toss("Invalid arguments for sqlite3Worker1Promiser()-created factory.");
    }
    if (!msg.dbId && msg.type !== "open")
      msg.dbId = dbId;
    msg.messageId = genMsgId(msg);
    msg.departureTime = performance.now();
    const proxy = /* @__PURE__ */ Object.create(null);
    proxy.message = msg;
    let rowCallbackId;
    if ("exec" === msg.type && msg.args) {
      if ("function" === typeof msg.args.callback) {
        rowCallbackId = msg.messageId + ":row";
        proxy.onrow = msg.args.callback;
        msg.args.callback = rowCallbackId;
        handlerMap[rowCallbackId] = proxy;
      } else if ("string" === typeof msg.args.callback) {
        toss(
          "exec callback may not be a string when using the Promise interface."
        );
      }
    }
    let p2 = new Promise(function(resolve, reject) {
      proxy.resolve = resolve;
      proxy.reject = reject;
      handlerMap[msg.messageId] = proxy;
      debug(
        "Posting",
        msg.type,
        "message to Worker dbId=" + (dbId || "default") + ":",
        msg
      );
      config.worker.postMessage(msg);
    });
    if (rowCallbackId)
      p2 = p2.finally(() => delete handlerMap[rowCallbackId]);
    return p2;
  };
};
globalThis.sqlite3Worker1Promiser.defaultConfig = {
  worker: function() {
    return new Worker(
      new URL("sqlite3-worker1-bundler-friendly.mjs", import.meta.url),
      {
        type: "module"
      }
    );
  },
  onerror: (...args) => console.error("worker1 promiser error", ...args)
};
sqlite3Worker1Promiser.v2 = function(config) {
  let oldFunc;
  if ("function" == typeof config) {
    oldFunc = config;
    config = {};
  } else if ("function" === typeof config?.onready) {
    oldFunc = config.onready;
    delete config.onready;
  }
  const promiseProxy = /* @__PURE__ */ Object.create(null);
  config = Object.assign(config || /* @__PURE__ */ Object.create(null), {
    onready: async function(func) {
      try {
        if (oldFunc)
          await oldFunc(func);
        promiseProxy.resolve(func);
      } catch (e5) {
        promiseProxy.reject(e5);
      }
    }
  });
  const p2 = new Promise(function(resolve, reject) {
    promiseProxy.resolve = resolve;
    promiseProxy.reject = reject;
  });
  try {
    this.original(config);
  } catch (e5) {
    promiseProxy.reject(e5);
  }
  return p2;
}.bind({
  original: sqlite3Worker1Promiser
});
var sqlite3_worker1_promiser_default = sqlite3Worker1Promiser.v2;

// ../../../node_modules/.pnpm/@eliaspourquoi+sqlite-node-wasm@3.46.0-build2/node_modules/@eliaspourquoi/sqlite-node-wasm/index.mjs
var sqlite3Worker1Promiser2 = globalThis.sqlite3Worker1Promiser;

// ../../../lix/packages/sqlite-wasm-kysely/dist/util/sqliteWasmBinary.js
function base64ToArrayBuffer(base64) {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i3 = 0; i3 < binaryString.length; i3++) {
    bytes[i3] = binaryString.charCodeAt(i3);
  }
  return bytes.buffer;
}
var sqliteWasmBase64 = "AGFzbQEAAAAB4AVeYAJ/fwF/YAF/AX9gA39/fwF/YAF/AGADf39/AGAEf39/fwF/YAJ/fwBgBX9/f39/AX9gBH9/f38AYAZ/f39/f38Bf2AEf39/fgF/YAJ/fgF/YAAAYAV/f39/fwBgAXwBfGAAAX9gAX8BfmAHf39/f39/fwF/YAZ/f39/f38AYAJ/fgBgA39/fgF/YAR/fn9/AX9gAX4Bf2ADf35/AX9gCX9/f39/f39/fwF/YAJ/fwF+YAN/f34AYAR/fn9/AGADf35+AX9gCH9/f39/f39/AX9gAnx8AXxgAX8BfGAFf39/f34AYAJ/fABgB39/f39/f38AYAl/f39/f39/f38AYAF8AX5gBH9/f34AYAABfGABfgF+YAV/f35/fwF/YAR/f35/AGACf38BfGAKf39/f39/f39/fwF/YAh/f39/f39/fwBgA39/fwF+YAN/fn8BfmAFf35+fn4AYAZ/f39+f38Bf2AHf39/f39+fgBgC39/f39/f39/f39/AX9gAXwBf2AAAX5gBn9/f39/fgF/YAV/fn9/fwF/YAt/f39/f39/f39/fwBgAn9+AX5gBH9/fn8Bf2ADf3x/AX9gA3x8fwF8YAF8AGACfH8BfGAGf3x/f39/AX9gAn5/AX9gBH9+fn8AYAR+fn5+AX9gA398fABgBn9/f35+fwF/YAV/f35/fwBgA39/fAF/YAJ8fgF/YAd/f39/fn9/AX9gCH9/f39/fn9/AGADf39+AX5gAn58AX9gB39/f35/f38Bf2ANf39/f39/f39/f39/fwBgCH9+fn9/f39/AX9gCH9/fn5+f39/AX9gBX9+fn5/AX9gCX9+f35+fn5/fwF/YAd/f39/fn9/AX5gBX9/f35+AGADf35+AGAGfn9/f39/AX5gB39+f39/f38Bf2AEf39+fgBgAnx/AX9gAn98AXxgA3x+fgF8YAR/f39+AX5gA35/fwF/YAJ+fgF+YAJ+fgF8AqIHIwNlbnYTX19zeXNjYWxsX2ZhY2Nlc3NhdAAFFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfY2xvc2UAAQNlbnYJX3R6c2V0X2pzAAQDZW52DV9sb2NhbHRpbWVfanMABgNlbnYTZW1zY3JpcHRlbl9kYXRlX25vdwAmA2VudiBfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYwAPA2VudhJlbXNjcmlwdGVuX2dldF9ub3cAJgNlbnYQX19zeXNjYWxsX2ZjaG1vZAAAA2Vudg9fX3N5c2NhbGxfY2htb2QAAANlbnYSX19zeXNjYWxsX2ZjaG93bjMyAAIDZW52EV9fc3lzY2FsbF9mY250bDY0AAIDZW52EF9fc3lzY2FsbF9vcGVuYXQABQNlbnYPX19zeXNjYWxsX2lvY3RsAAIWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF93cml0ZQAFFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfcmVhZAAFA2VudhFfX3N5c2NhbGxfZnN0YXQ2NAAAA2VudhBfX3N5c2NhbGxfc3RhdDY0AAADZW52FF9fc3lzY2FsbF9uZXdmc3RhdGF0AAUDZW52EV9fc3lzY2FsbF9sc3RhdDY0AAAWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9zeW5jAAEDZW52FV9fc3lzY2FsbF9mdHJ1bmNhdGU2NAALA2VudhBfX3N5c2NhbGxfZ2V0Y3dkAAAWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MRFlbnZpcm9uX3NpemVzX2dldAAAFndhc2lfc25hcHNob3RfcHJldmlldzELZW52aXJvbl9nZXQAABZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsAFQNlbnYRX19zeXNjYWxsX21rZGlyYXQAAgNlbnYKX211bm1hcF9qcwAJA2VudghfbW1hcF9qcwARA2VudhRfX3N5c2NhbGxfcmVhZGxpbmthdAAFA2Vudg9fX3N5c2NhbGxfcm1kaXIAAQNlbnYSX19zeXNjYWxsX3VubGlua2F0AAIDZW52E19fc3lzY2FsbF91dGltZW5zYXQABRZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxDWZkX2Zkc3RhdF9nZXQAAANlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAABA2VudgZtZW1vcnkCAYACgIACA5EWjxYMBQECBQcBAAYGAwEDARAGBgYGBgYGBgQBDwwGDAEDDwABAwEnJxYWAAsLBAQQCx8BBAsABgYEQgEEEAsGAQMUAQEBAQAABQUEBgAAAgcAAAUAAgEFAgMEAgUFBgIAAgACAAAFAAAHARkBBwADAQURAQEAAwkEABMoAgEGAAEAAAMBAwYAAAABAQMBA0MIFgYBAgMNBgYBAwACBQUBAgMAAQIAAAACAQADAwMBAQEAAwEFAwMQFwAAAAIAAwMDAAICBQEBAQQCBQYDAQYDAwYDBgYDAQABAwMBAQIAAQAAAR8fARAQAQAAAQEBAQEBAwgEDQMDASkhIQMEAAAGExMDAwgIAwYIRAMDBgAGCwYGAQQGAQEBAAIDAQABAgAEAAAAAAgLAQEAACoAAgcwAEUCFAAHBwICAQAAAgIBAQEAAgEBAAACAAUCAwMLBwEIAQEBAgEGBUYFA0cFAAIBCQIGFwECAAEHBAcFCQEGCAYBBQUHBRBIBQUBCwIGAAUBAgEBDAcRBgkFBwcAAAAGAQIBAQMFBAECAAACAgIHBwECDwAAAQ8PDwABAAIFEBMQARABAAEABgMBAggAAB0yMhgrAgcEAgACBQICAgIABQIABwcrAQEBAQIABQcJBwcJCQAGAwUHCQUCARgAAQABBQAAAwMCAQAEADMQFgMBAAACSQAAAAEBAQUBAQICAgUrCQAbAQECAgABCwYCMQMGBAIJAAAIGBAABAgIAgICAAABEAIQAhEFAgUBBQADABcHAgcCAgICAAEFBwQFGB0JAwICBAQEBwkYCQECAgICEwQBAgUHBggRAgcCAgMJCQAPDwMBDw8CAw8AAAEABwUHAgAEDwIFBwIAAgsAAQEBNDQnBhADAQAABhQLAAEAAwMKChULCwAAAAABAAIEAQEDAQcAAzYFBQMAFRcCAA8BAAAAAQAAAAAABwIFBQACAAAAAQoCCgQLCwAAEAAAAAIBAQoFCgsAAAIBCgoLAAAAAAIBFRcDAwYDAAMGAwUFAQYGAQEDAQcDAQMCAQEDAAcAAgYEBgUNAgoNEwIDBAEBAQMKCgsAAAQCCgMDAAAHAwIABgIDAAACAQMDAgACAwYAAAIoBwAXAAADAAABBAAEAAAEAAQABxIBAAMABgACAQEDAQECBQcDCQEDAQMFBgENCAMEBgMGBgMBAwYIAAYDAwAGBgMGAwMGAgIAFAAABAEDBgICAAEQARkFAAABBgUACwMBAQQAAQETAwgECAoBBgAFAgIEBgUDAQIAFgEFAQAABQECABAAAAILFUoHBgEDAEsAAQQBAwUABRYLKQUAAgIFBQEBAQQAKAECCAIAAQkAAAQBBAACAQUDAwUABgIABgYEBgMGBgYGAQUAAgEHBwACBAUABREACQkJAgAlEwQACQEKAAICAQQUAggBAAMGAAcFBQAEAgYCAAIABwcJAAEAAQMHAQECAAYGBgAFAAILAQACBBENAgQABwQiAw0DAhEHBAIAAgMGAgACDQQEBAECAA0ACAEGAgUAAQQEIgYGBQUCBwICAAIFAAAABgABBgQAAAAABAYIDQQDCAQHBTcCAAIGBBgEBgIBAAYFCAIEBAgFAgYJEgUIBAQRAhIEBAUDAgABBgIGDQIIBg0GCA0EAAQIAwUCAgMHCAMCBgQBBAIGAAMBBgEDBQQBEgYABgIEAAYAAAAFAhIGAAYAAgQILAQABAYAAQcFBB0GAAQGAw0FEgMEBgYABgEGAAgGCAgGCAAEAAgFAAABAQMCAgUdBggABgUEAQQAAgcFAggABgAdBgY3AwQGAgASABEABCNMEhIjEgEFBQACBAQIAAAEAgYABgYGDQYGEwAAAwEIAwEGDQgdBggEBwEIBgQGAAQGAgAEAQgCCAIGAw0IAAQAAgUEIgIBCAgBAAkjAQQNAAAACQAEBQEABQAAAAACBgcABAYGBAQGAAIAAAAGAwEAAwgIAAANAAYABwAIAgYNEAUEBQ0AAgACAAAABgAAEQUAAAEAAAAGBAQFAAIABAIGBgAwAAkBGRwLHAYGAwMQAwgSCyklCAkIBiAHBAQIBAIGBAkiBA0AAAAGBggCAAAEDREBGQAGFAIEABIDBhkZGQUBBAYAGQUCAQIAAAZNAAUEAgUbBgAAAAAAAAAEDQQHBAcHBQUDAAUSAAAjLAEAAAYFAAANBAAEDRIGBAQDBAQGBAQEBAsEBAMGAwQEBAQEBAQEBAQEBAQEBA0EBAQEBAQEBAQEBAQEBBMhEwMEAwMEAwQEAwMEBA4EDgQEBA4OBAQEBwAAAgEICAYHDQMGBAAABAQEAAYEAwQDBAMEAwQEAwQEAwQEAwMEBAMDBAMEBQMEBAMEAwQDBAEEBAQEAQAhAgADAAQCBQYGAwQGAwYEBAAEAQUAAwQEBAEDAggEBggEBAQFBAAEBAQEBAMGAwQEAwYDAgAADQkIAgYAAAEDAQEGAAIIBgkCAgEIAAYDBAYDAQMAAQEBAwEDAgMDBgMBAgECBAYIBgYDAwEBBQQDAwEHBQcDBAQBBAQEAQEBAQEBAAAFABYEAgUBBQEJAAEBCQMEAAEAAQMDBxgCAQAAAAECAAMYBQAFAgARTgAVBQUAAgMACAIBAAAUAAULCBYLBiIGAgEFAQkCAQUBCQUBAQEBAQEIAQECCREJAAEBCAABAwc4AAAAFgcLBAMNEgUEAQEEAAECAAAFAAABBQIKBwQNAAEGAgABAQEBAQMHAAAAAAEHAQUBCAADAwMAAgcHAhEIIAkCAAYaBgcHBE8LAgcICAUFFQUAFFAcAwgJUQQCAQUJCRoEBQICAgQGAgQCBAQCAAMHAgIAAgUBAgUEAQIGCQABAAEDBwEBAgAJEQkAAQMBBQABAQMHCQA4AQICBQEFAQM5HAECAggaAAILAAUABQMEFwEABRQJFwEDAQMAAwgGBQABBQUIAhQBAQEBAwcEAAEIAAAAAQcDAAIFAQcIBwEDAwMDAQEDAwEBBQMCGwMCCwMLEAsAAAMDAwMDAwMEAAIHBAIFBgMIAwEGCQoKCgoKCwEGLQAGAAAaGiUDBAYGBgYCCAMBUgQaAQABEAQGAQsCAAU2FAgBAgMDAAkjAAYEBhIGBggIGxsEBgQCDQICBgYGBgYGAAQIBAYIBCAaBgYGAQAEAAIGBAgIUwQEBAUEBgYGAwgIAAgIAQEAAgcBAAABBxAFAhcJBQIABwUIBQQHBwkLAwoGAQkDAlRVAgUHCw0BCRgFCAEJDQ0CAAUCAwkAAAEFBAMJBQMJCQkBAAAAAAAAAgkJCQABAQABAwcBAQEAAQIACAUtBhACBCUaBlYJEQkAAQMBAwABAwcVOjkVAQABAwECAAAFAAsFBQEBAQAAAQcBAgAGOgsABAUCAioEAgASKgIIAhUcHAAJAAEAAQcBAQIABQEJAAEAAQMHAQIDAwMBAgAJAAEAAQMHAQEDAQIBAAAJAAEAAQMHAQECAAkAAQABAwcBAQIAAgEBAgICAAgJBwkCAAICAAICAg4OAh4PAA4ODg4ODg4kHiQOAQEeB1c7Dh4ODAAQAABYDh8fDjNZJjwOJA4AAgEDAwECAQ4eJAEuAgIBAAAAAQUABQELAQIFAAwBDw8PDw8BAQMDPAEODi4AAgAAAAkMNQAFAA8MAQIGDRIGLAYBBAEBCAICAgE9Dg4FDgAAAAAAAQ8MAAAAAQECAgAAAVotATsODg4BBQIAAQA9BxEEAQhbPz8NAj4GJAUCAQECAAIBAwAAAAAGDwEvQEFBIVwTEw8PQC8vXQ8DAQQFAXAAuwUGCAF/AUHQqCgLB8Aw9gERX193YXNtX2NhbGxfY3RvcnMAIhBzcWxpdGUzX3N0YXR1czY0ACMOc3FsaXRlM19zdGF0dXMAJhFzcWxpdGUzX2RiX3N0YXR1cwAnDXNxbGl0ZTNfbXNpemUAMBBzcWxpdGUzX3Zmc19maW5kADoSc3FsaXRlM19pbml0aWFsaXplADsOc3FsaXRlM19tYWxsb2MAPwxzcWxpdGUzX2ZyZWUAQBRzcWxpdGUzX3Zmc19yZWdpc3RlcgBCFnNxbGl0ZTNfdmZzX3VucmVnaXN0ZXIARRBzcWxpdGUzX21hbGxvYzY0AEkPc3FsaXRlM19yZWFsbG9jAEoRc3FsaXRlM19yZWFsbG9jNjQATBJzcWxpdGUzX3ZhbHVlX3RleHQAXxJzcWxpdGUzX3JhbmRvbW5lc3MAaw9zcWxpdGUzX3N0cmljbXAAbBBzcWxpdGUzX3N0cm5pY21wAG4Vc3FsaXRlM191cmlfcGFyYW1ldGVyAHMQX19lcnJub19sb2NhdGlvbgDsFBNzcWxpdGUzX3VyaV9ib29sZWFuAHcRc3FsaXRlM19zZXJpYWxpemUAhQESc3FsaXRlM19wcmVwYXJlX3YyAIgBDHNxbGl0ZTNfc3RlcACJARRzcWxpdGUzX2NvbHVtbl9pbnQ2NACKAQ1zcWxpdGUzX3Jlc2V0AIsBDHNxbGl0ZTNfZXhlYwCMARJzcWxpdGUzX2NvbHVtbl9pbnQAjQEQc3FsaXRlM19maW5hbGl6ZQCPARRzcWxpdGUzX2ZpbGVfY29udHJvbACQARNzcWxpdGUzX2NvbHVtbl9uYW1lAKYBE3NxbGl0ZTNfY29sdW1uX3RleHQApwETc3FsaXRlM19jb2x1bW5fdHlwZQCoAQ5zcWxpdGUzX2Vycm1zZwCqARNzcWxpdGUzX2Rlc2VyaWFsaXplAK4BFnNxbGl0ZTNfY2xlYXJfYmluZGluZ3MA9wESc3FsaXRlM192YWx1ZV9ibG9iAPoBE3NxbGl0ZTNfdmFsdWVfYnl0ZXMA/gEUc3FsaXRlM192YWx1ZV9kb3VibGUAggIRc3FsaXRlM192YWx1ZV9pbnQAhAITc3FsaXRlM192YWx1ZV9pbnQ2NACGAhVzcWxpdGUzX3ZhbHVlX3N1YnR5cGUAhwIVc3FsaXRlM192YWx1ZV9wb2ludGVyAIgCEnNxbGl0ZTNfdmFsdWVfdHlwZQCKAhZzcWxpdGUzX3ZhbHVlX25vY2hhbmdlAIsCFnNxbGl0ZTNfdmFsdWVfZnJvbWJpbmQAjAIRc3FsaXRlM192YWx1ZV9kdXAAjQISc3FsaXRlM192YWx1ZV9mcmVlAJACE3NxbGl0ZTNfcmVzdWx0X2Jsb2IAkQIbc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnAJQCGnNxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtAJUCFXNxbGl0ZTNfcmVzdWx0X2RvdWJsZQCYAhRzcWxpdGUzX3Jlc3VsdF9lcnJvcgCbAhJzcWxpdGUzX3Jlc3VsdF9pbnQAngIUc3FsaXRlM19yZXN1bHRfaW50NjQAoAITc3FsaXRlM19yZXN1bHRfbnVsbAChAhZzcWxpdGUzX3Jlc3VsdF9wb2ludGVyAKMCFnNxbGl0ZTNfcmVzdWx0X3N1YnR5cGUApgITc3FsaXRlM19yZXN1bHRfdGV4dACnAhdzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYgCtAhlzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0AK4CGXNxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUAsAIRc3FsaXRlM191c2VyX2RhdGEAtAIZc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZQC1AhVzcWxpdGUzX3Z0YWJfbm9jaGFuZ2UAtgIVc3FsaXRlM192dGFiX2luX2ZpcnN0ALcCFHNxbGl0ZTNfdnRhYl9pbl9uZXh0AMACGXNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQAwQITc3FsaXRlM19nZXRfYXV4ZGF0YQDDAhNzcWxpdGUzX3NldF9hdXhkYXRhAMQCFHNxbGl0ZTNfY29sdW1uX2NvdW50AMYCEnNxbGl0ZTNfZGF0YV9jb3VudADHAhNzcWxpdGUzX2NvbHVtbl9ibG9iAMgCFHNxbGl0ZTNfY29sdW1uX2J5dGVzAMkCFXNxbGl0ZTNfY29sdW1uX2RvdWJsZQDKAhRzcWxpdGUzX2NvbHVtbl92YWx1ZQDLAhFzcWxpdGUzX2JpbmRfYmxvYgDNAhNzcWxpdGUzX2JpbmRfZG91YmxlANACEHNxbGl0ZTNfYmluZF9pbnQA0QISc3FsaXRlM19iaW5kX2ludDY0ANICEXNxbGl0ZTNfYmluZF9udWxsANMCFHNxbGl0ZTNfYmluZF9wb2ludGVyANQCEXNxbGl0ZTNfYmluZF90ZXh0ANUCHHNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQA2AIcc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleADaAhFzcWxpdGUzX2RiX2hhbmRsZQDdAhVzcWxpdGUzX3N0bXRfcmVhZG9ubHkA3gIWc3FsaXRlM19zdG10X2lzZXhwbGFpbgDfAhNzcWxpdGUzX3N0bXRfc3RhdHVzAOECC3NxbGl0ZTNfc3FsAOICFHNxbGl0ZTNfZXhwYW5kZWRfc3FsAOMCFXNxbGl0ZTNfcHJldXBkYXRlX29sZADmAhdzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudADwAhdzcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aADxAhtzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUA8gIVc3FsaXRlM19wcmV1cGRhdGVfbmV3APMCGnNxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlAPQCFnNxbGl0ZTNfc2V0X2F1dGhvcml6ZXIAmwMPc3FsaXRlM19zdHJnbG9iAJ0DD3NxbGl0ZTNfc3RybGlrZQCgAxZzcWxpdGUzX2F1dG9fZXh0ZW5zaW9uAKEDHXNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uAKIDHHNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24AowMSc3FsaXRlM19wcmVwYXJlX3YzAKcDFXNxbGl0ZTNfY3JlYXRlX21vZHVsZQCoAxhzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIAqgMUc3FsaXRlM19kcm9wX21vZHVsZXMAqwMUc3FsaXRlM19kZWNsYXJlX3Z0YWIArAMYc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ALYDFnNxbGl0ZTNfdnRhYl9jb2xsYXRpb24AuAMPc3FsaXRlM192dGFiX2luALsDFnNxbGl0ZTNfdnRhYl9yaHNfdmFsdWUAvAMVc3FsaXRlM192dGFiX2Rpc3RpbmN0AL8DFHNxbGl0ZTNfa2V5d29yZF9uYW1lAMADFXNxbGl0ZTNfa2V5d29yZF9jb3VudADBAxVzcWxpdGUzX2tleXdvcmRfY2hlY2sAwgMQc3FsaXRlM19jb21wbGV0ZQDEAxJzcWxpdGUzX2xpYnZlcnNpb24AxQMZc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlcgDGAxBzcWxpdGUzX3NodXRkb3duAMcDGXNxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQAzQMdc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQAzgMRc3FsaXRlM19jaGFuZ2VzNjQAzwMPc3FsaXRlM19jaGFuZ2VzANADF3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ANEDFXNxbGl0ZTNfdG90YWxfY2hhbmdlcwDSAxFzcWxpdGUzX3R4bl9zdGF0ZQDTAxBzcWxpdGUzX2Nsb3NlX3YyANgDFHNxbGl0ZTNfYnVzeV9oYW5kbGVyANkDGHNxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlcgDaAxRzcWxpdGUzX2J1c3lfdGltZW91dADbAxdzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbgDdAxpzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MgDgAx5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24A4QMZc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbgDiAxBzcWxpdGUzX3RyYWNlX3YyAOgDE3NxbGl0ZTNfY29tbWl0X2hvb2sA6QMTc3FsaXRlM191cGRhdGVfaG9vawDqAxVzcWxpdGUzX3JvbGxiYWNrX2hvb2sA6wMWc3FsaXRlM19wcmV1cGRhdGVfaG9vawDsAxRzcWxpdGUzX2Vycm9yX29mZnNldAD0Aw9zcWxpdGUzX2VycmNvZGUA9QMYc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlAPYDDnNxbGl0ZTNfZXJyc3RyAPcDDXNxbGl0ZTNfbGltaXQA+AMMc3FsaXRlM19vcGVuAPkDD3NxbGl0ZTNfb3Blbl92MgCEBBhzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24AhQQbc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyAIYEGHNxbGl0ZTNfY29sbGF0aW9uX25lZWRlZACIBBZzcWxpdGUzX2dldF9hdXRvY29tbWl0AIkEHXNxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhAIoEHXNxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzAJAED3NxbGl0ZTNfdXJpX2tleQCeBBFzcWxpdGUzX3VyaV9pbnQ2NAChBA9zcWxpdGUzX2RiX25hbWUAowQTc3FsaXRlM19kYl9maWxlbmFtZQCkBBpzcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZACmBBlzcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0AKcEE3NxbGl0ZTNzZXNzaW9uX2RpZmYAqAQVc3FsaXRlM3Nlc3Npb25fYXR0YWNoALcEFXNxbGl0ZTNzZXNzaW9uX2NyZWF0ZQC7BBVzcWxpdGUzc2Vzc2lvbl9kZWxldGUAvQQbc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyAL8EGHNxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldADABB1zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybQDLBBxzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtAMwEF3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0AM0EFXNxbGl0ZTNzZXNzaW9uX2VuYWJsZQDOBBdzcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdADPBBZzcWxpdGUzc2Vzc2lvbl9pc2VtcHR5ANAEGnNxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkANEEHHNxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcA0gQdc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUA0wQWc3FsaXRlM2NoYW5nZXNldF9zdGFydADUBBlzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyANYEG3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybQDXBB5zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0A2AQVc3FsaXRlM2NoYW5nZXNldF9uZXh0ANkEE3NxbGl0ZTNjaGFuZ2VzZXRfb3AA4QQTc3FsaXRlM2NoYW5nZXNldF9wawDiBBRzcWxpdGUzY2hhbmdlc2V0X29sZADjBBRzcWxpdGUzY2hhbmdlc2V0X25ldwDkBBlzcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0AOUEHXNxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzAOYEGXNxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUA5wQXc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQA6AQcc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybQDrBBlzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyAOwEFnNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkA9gQec3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtAPcEG3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybQD4BBZzcWxpdGUzY2hhbmdlZ3JvdXBfbmV3APkEFnNxbGl0ZTNjaGFuZ2Vncm91cF9hZGQA+gQZc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dACHBRtzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0AiQUec3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtAIoFGXNxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUAiwUXc3FsaXRlM2NoYW5nZXNldF9jb25jYXQAjAUcc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybQCNBRVzcWxpdGUzc2Vzc2lvbl9jb25maWcAjgUQc3FsaXRlM19zb3VyY2VpZACPBRhzcWxpdGUzX193YXNtX3BzdGFja19wdHIAkAUcc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVzdG9yZQCRBRpzcWxpdGUzX193YXNtX3BzdGFja19hbGxvYwCSBR5zcWxpdGUzX193YXNtX3BzdGFja19yZW1haW5pbmcAkwUac3FsaXRlM19fd2FzbV9wc3RhY2tfcXVvdGEAlAUWc3FsaXRlM19fd2FzbV9kYl9lcnJvcgCVBRlzcWxpdGUzX193YXNtX3Rlc3Rfc3RydWN0AJYFF3NxbGl0ZTNfX3dhc21fZW51bV9qc29uAJcFGHNxbGl0ZTNfX3dhc21fdmZzX3VubGluawCYBRRzcWxpdGUzX193YXNtX2RiX3ZmcwCZBRZzcWxpdGUzX193YXNtX2RiX3Jlc2V0AJoFH3NxbGl0ZTNfX3dhc21fZGJfZXhwb3J0X2NodW5rZWQAmwUac3FsaXRlM19fd2FzbV9kYl9zZXJpYWxpemUAnAUdc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUAnQUfc3FsaXRlM19fd2FzbV9wb3NpeF9jcmVhdGVfZmlsZQCfBSJzcWxpdGUzX193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrAKAFG3NxbGl0ZTNfX3dhc21fa3Z2ZnNfbWV0aG9kcwCiBRlzcWxpdGUzX193YXNtX3Z0YWJfY29uZmlnAKMFGnNxbGl0ZTNfX3dhc21fZGJfY29uZmlnX2lwAKQFG3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3BpaQClBRlzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19zAKYFFnNxbGl0ZTNfX3dhc21fY29uZmlnX2kApwUXc3FsaXRlM19fd2FzbV9jb25maWdfaWkAqAUWc3FsaXRlM19fd2FzbV9jb25maWdfagCpBRhzcWxpdGUzX193YXNtX3FmbXRfdG9rZW4AqgUZc3FsaXRlM19fd2FzbV9pbml0X3dhc21mcwCrBRlzcWxpdGUzX193YXNtX3Rlc3RfaW50cHRyAKwFGnNxbGl0ZTNfX3dhc21fdGVzdF92b2lkcHRyAK0FHHNxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9tYXgArgUcc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbgCvBR9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfdGltZXMyALAFH3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW5tYXgAsQUbc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0cHRyALIFIXNxbGl0ZTNfX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdwCzBRxzcWxpdGUzX193YXNtX3Rlc3Rfc3RyX2hlbGxvALQFH3NxbGl0ZTNfX3dhc21fU1FMVGVzdGVyX3N0cmdsb2IAtQUGbWFsbG9jAJcWBGZyZWUAmBYHcmVhbGxvYwCZFhlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQAbZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduAJsWCXN0YWNrU2F2ZQCuFgxzdGFja1Jlc3RvcmUArxYKc3RhY2tBbGxvYwCwFgnzCgEAQQELugVAtAG5AsAH0AebBpwGpQKqApIDlAOqCasJrAncA+QD7gP7A/0D/gPKA5oGnQbK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ADYCyAELIAVBAWohBQwBCwtBACEFIANBADYCACACIAmnQf////8HcTYCAAwBC0EAIQUgA0EANgIAQQEhASAAKQOIBEIAVwRAIAApA4AEQgBVIQELIAIgATYCAAsgBkEQaiQAIAULMQACfwJAIAAEf0EBIAAtAGFB9gBGDQIaIAAQLUUNAUHmswEFQY/0AQsiABAuC0EACwtVAwF/AX8BfyAAKALMAhAvIQIgACgC0AIQLyEDIAAoAtQCEC8gAmohAiAAKALYAhAvIQQgAQRAIAEgACgCvAIgAms2AgALIAAoArwCIAIgA2ogBGprC0QAAkAgAUUNACABLQAKDQAgACABKAIcEDEgACABKAIAEDIgACABKAIEEDIgACABKAIMEDMgACABKAIQEDQgACABEDULCy8BAX8CQCABRQ0AIAAoApAERQRAIAEgASgCGEEBayICNgIYIAINAQsgACABEDYLC+sBAwF/AX8BfyAAKAIAIQIgACgCdCIBBEAgASAALwGSAUEBdBA3IAIgACgCdBA4CyAAKALgASEBA0AgAQRAIAEoAhghAyACIAEoAgAgASgCBBA5IAIgARA1IAMhAQwBCwsCQCAALQCXAUUNACAAKAJkIAAuARAQNyAAKAKAASIBBEAgAiABEDgLIAAoAswBIgFFDQAgAiABEDgLIAIgACgCaCAAKAJsEDkgACgCyAEiAQRAIAIgARA4CwJAIAIoApAEDQAgACgCBCAAKAIINgIAIAAoAggiAUUNACABIAAoAgQ2AgQLIAIgABA4CzEBAX9BASEBIAAtAGEiAEHtAEYgAEH2AEZyIABBugFGckUEQEGjrQEQLkEAIQELIAELJQEBfyMAQRBrIgEkACABIAA2AgBBFUGz8wAgARBqIAFBEGokAAseAQF/A0AgAARAIAFBAWohASAAKAIAIQAMAQsLIAELGAAgAEUEQEIADwsgAEH87AUoAgARAQCsC2IBAX8DQCABBEAgASgCKCECIAAgASgCFBAzIAAgASgCGBCuAyAAIAEoAggQnwggACABKAIcEDQgACABKAIgEOkIIAAgASgCEBCkCCAAIAEoAiQQMiAAIAEQNSACIQEMAQsLCw0AIAEEQCAAIAEQNQsLDgAgAQRAIAAgARCgCAsLNgEBfyABBEADQCACIAEoAgBORQRAIAAgASACQQN0aigCCBAy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AwAgACkAAEKAgIBgg78iBKE5AyggAyABIAG9QoCAgGCDvyIFoTkDICADIAUgBKI5AxggAyAEIAMrAyCiIAMrAyggBaKgOQMQIAMgAysDGCADKwMQoDkDCCADIAMrAyggAysDIKIgAysDECADKwMYIgQgAysDCCIFoaCgOQMAIAMgAysDACAAKwMAIgQgAqIgACsDCCIFIAGioKA5AwAgACADKwMIIAMrAwCgOQMAIAAgAysDCCAAKwMAoTkDCCAAIAMrAwAgACsDCKA5AwgLFwAgAEUEQEEADwsgABDvFUH/////A3ELMQAgACACrBBUIgJBAEoEQCAAKAIEIAAoAhBqIAEgAhDlFBogACAAKAIQIAJqNgIQCwuaAQMBfgF8AX8gAC8BECIDQSRxBEAgACkDAA8LAkAgA0EIcQRAQoCAgICAgICAgH8hASAAKwMAIgJE////////38NjDQFC////////////ACEBIAJE////////30NkDQEgAplEAAAAAAAA4ENjBEAgArAPC0KAgICAgICAgIB/DwsgA0EScUUNACAAKAIIRQ0AIAAQhQIhAQsgAQsTACAABEAgACABEOwCDwsgARBICygAIAAgAToAFCAAKAIMBEAgABBgCyABQRJGBEAgACgCAEESEJwCGgsLCQAgAEEBEP0BCzUAIAAtABVBBHEEQCAAKAIAIAAoAgQQMiAAIAAtABVB+wFxOgAVCyAAQQA2AhAgAEIANwIEC1oAIAFFBEAgACACEOwCDwsCQAJAIAAoAuQCIAFNDQAgASAAKALcAk8EQCACQoEBWg0BDAILIAAoAuACIAFLDQAgADMBtgIgAloNAQsgACABIAIQuAUhAQsgAQsfAQF/IABFIABB6O4FRnJFBEAgABBjIQEgABBACyABCzoBAX8CQCAAKAIEIgFFDQAgASAAKAIQakEAOgAAIAAoAgxFDQAgAC0AFUEEcQ0AIAAQZA8LIAAoAgQLTQEBfwJAIAAoAgAgACgCEEEBaq0QXSIBBEAgASAAKAIEIAAoAhBBAWoQ5RQaIAAgAC0AFUEEcjoAFQwBCyAAQQcQXgsgACABNgIEIAELSwEBf0IYEEkiAUUEQEHo7gUPCyAABH8gACgCeAVBgJTr3AMLIQAgAUEAOwEUIAFBADYCECABIAA2AgwgAUEANgIIIAFCADcCACABC3cC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IABCADcDQCAAQQA2AjALKgAgACABNgJAAkAgAUUEQCAAKAKkAkUNAQsgACABELYBDwsgAEF/NgJECwsAIAAgAUEAEMwCCxQAIAAgARChARBfIQEgABCiASABCyAAIAAgARChAS8BECEBIAAQogEgAUE/cUHgowNqLQAACx0BAX8gAC0AlwEEfyAAEKMBBUEACyEBIAAQLCABC1UBAX8gAEUEQEGhJQ8LAkACfyAAEC1FBEBBp5ELECQMAQsgAC0AVwRAQaElDwtBACAAKAJARQ0AGiAAKAKkAhBfIgENASAAKAJACyIAELECIQELIAELPAEBfyAALQAcQSBxBEAgACgCFCIBIAEoAoABQQFrNgKAASAAIAEoApABNgIQIAEgADYCkAEPCyAAEJMGCxwBAX8gACgCAEUEQEEVQeA1QQAQakEBIQELIAELwwMFAX8BfwF/AX8BfwJAIAAtAGFBpwFHDQAgABDsAQ0AIABBABDtASAAEO4BA0AgACgCECECIAEgACgCFE5FBEACQCACIAFBBHRqIgIoAgQiA0UNACADEO8BIAJBADYCBCABQQFGDQAgAkEANgIMCyABQQFqIQEMAQsLIAIoAhwiAQRAIAEQygELIAAQywEgABDMASAAQagDaiEDA0AgAygCACIDBEAgAygCCCEBA0AgACABEPABIAEoAgwhAiAAIAEQMiACIgENAAsMAQsLIABBoANqEPEBIABBuANqIQQDQCAEKAIAIgQEQCAEKAIIIQVBACEBA0AgAUEDRwRAIAUgAUEUbGoiAigCECIDBEAgAigCCCADEQMACyABQQFqIQEMAQsLIAAgBRAyDAELCyAAQbADahDxASAAQYwDaiEBA0AgASgCACIBBEAgACABKAIIIgIQ8gEgACACEPMBDAELCyAAQYQDahDxASAAQQAQpQEgACgCpAIQ9AEgAEHVAToAYSAAIAAoAhAoAhwQMiAAKAL4ASIBBEAgACgC9AEgAREDAAsgAEHOAToAYSAALQC4AgRAIAAoAuACEEALIAAQQAsL6AIFAX8BfwF/AX8BfyMAQRBrIgYkACAGQQA2AgwCQCAAEChFBEBB2KMDECQhBwwBCyADQgBTBEBB2qMDECQhBwwBCyAEQgBTBEBB26MDECQhBwwBC0EBIQcgAUUEQCAAKAIQKAIAIQELAkAgACABEIcBIglB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cUUEQEEADwsgACgCDCEBIAJBgAhxBEAgACgCACABaiEBCyABIAAoAhQoAnhKC0EAAkAgAEUEQCADQQFqQQJJDQEgASADEQMADwsgAkKAgICACFoEQCABIAMgABCSAg8LIAAgASACp0EAIAMQkwILCxEAIAAEQCAAKAIAIAEQmQILC0gBAX4gABCaAiABvSICQoCAgICAgID4/wCDQoCAgICAgID4/wBRIAJC/////////weDQgBScUUEQCAAQQg7ARAgACABOQMACwsbACAALQARQZABcQRAIAAQogIPCyAAQQE7ARALIAAgAARAIABBATYCFCAAKAIAIAEgAqxBAUF/EJoBGgsLKwACQCAARQ0AIAAoAoACIgBFDQAgACABNgIMIAAgACgCJEEBajYCJAsgAQswACABIAAoAhhKBEAgACABQQAQ/AEPCyAAIAAoAiA2AgggACAALwEQQS1xOwEQQQALEgAgAARAIAAoAgAgAawQmQELCxUAIAAQmgIgAEEEOwEQIAAgATcDAAsRACAABEAgACgCACABEJkBCwsPACAABEAgACgCABCaAgsLQAEBfyAALgEQIgFBAEgEQCAAIAAoAgAQqQcaIAAvARAhAQsgAUGAIHEEQCAAKAIIIAAoAiQRAwALIABBATsBEAs5AAJAIABFBEAgA0EBakECSQ0BIAEgAxEDAA8LIAAoAgAiABD4ASAAQQE7ARAgACABIAIgAxCkAgsLOAAgABD5ASAAQfAAOgATIABBgTQ7ARAgACABNgIIIAAgA0EIIAMbNgIkIAAgAkHpnwMgAhs2AgALAwABC3QCAX8BfyMAQeABayICJAACQCAARQ0AAkAgACgCBCIDRQ0AIAMtAAdBAXENACACIAMoAiA2AgAgAEHIASACQRBqQeL5AiACEGlBfxCbAgwBCyAAKAIAIgAgAToAEyAAIAAvARBBgBByOwEQCyACQeABaiQACyoAAkAgAEUEQCADQQFqQQJJDQEgASADEQMADwsgACABIAJBASADEJMCCwtnAQF/AkAgAEUEQCADQQFqQQJJDQEgASADEQMADwsgAiACQn6DIARBAUYiBRsiAkKAgICACFoEQCABIAMgABCSAg8LIAAgASACp0EBQQIgBCAEQQRGGyAFGyADEJMCIAAoAgAQqQILC6cBAgF/AX8CQCAALwEQIgFBgsQB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C5kDBAF/AX8BfwF/IABBACACG0UEQEH40wUQJA8LAkACQCAAKAKMAiIEBEAgBCgCCCIFQQlHDQELQf3TBRAkIQMMAQsgBCgCUCIDRSAFQRdGckUEQCADIAHBEOcCIQELQRkhAyABQQBIDQAgASAEKAIELgE0IgZODQACQAJAIAVBEkYEQCAEKAIsIgNFBEAgBCgCACgCWCAEKAIwQShsaiIFLQARQQRxBEAgBRD7ASIDDQULIARBEGogBSgCDCAFKAIIEOkCIgNFDQMgBCADNgIsCyADKAIEIAFBKGxqIQUgBCgCTC4BICABRgRAIAUgBCkDQBCZAQwCC0HA1AMgBSABIAMvARRPGyEFDAELIAQoAkgiA0UEQCAEIAAgBkEobK0QxQIiAzYCSCADRQ0CCyADIAFBKGxqIgUvARANACAEKAJMLgEgIAFGBEAgBSAEKQNAEJkBDAELIAUgBCgCACgCWCABIAQoAjBqQShsakEoahCsAiIDDQILIAIgBTYCAEEAIQMMAQtBByEDCyAAIAMQpQEgACADEJ4BC0ABAX4Cf0KEgJCAgICAAiAAMwEQIgGIQgGDUARAIAFCP4OnDAELIABBABD1AiAALwEQQT9xCyIAQeCjA2otAAALlgIHAXwBfwF/AX4BfwF/AX8jAEEQayIEJAAgACgCCCIGIARBCGogACgCDCIHIAAtABIiCBD2AiIDQQBKBEAgBCsDCCECAkACQCADQQFHDQACQCACAn5CgICAgICAgICAfyIFIAJE////////38NjDQAaQv///////////wAiBSACRP///////99DZA0AGiACmUQAAAAAAADgQ2MEQCACsAwBC0KAgICAgICAgIB/CyIFEPcCBEAgACAFNwMADAELIAYgACAHIAgQ+AINAQsgAC8BEEEEciEDDAELIAAgAjkDACAAIAAvARBBCHIiAzsBECABRQ0AIAAQ+QIgAC8BECEDCyAAIANB/f8DcTsBEAsgBEEQaiQAC+sOEgF/AX4BfwF+AX8BfAF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQYABayIGJAAgAUIANwMAAkAgAkUNAAJAIANBAUYEQCAAIQRBASEDQQEhCgwBC0EDIANrIQQgAkF+cSECA0ACQCACIARMBH9BAQUgACAEai0AAEUNAUGcfwshCiAEQQFzIQIgACAD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U3INABogAUKAgICAgICABFMLC94EBwF/AX8BfwF/AX4BfwF/An8gA0EBRgRAIAAhBEEBDAELQQMgA2shBSACQX5xIQQDQAJAIAQgBUwNACAAIAVqLQAADQAgBUECaiEFDAELCyAFQQFzIQIgBCAFSiEJIAAgA0EBcWohBEECCyEDIAAgAmohAAJAA0BBASEHIAAgBE0NASAELQAAIgVBwKQDai0AAEEBcQRAIAMgBGohBAwBCwsCQAJAIAVBK2sOAwECAAILIAMgBGohBEEAIQcMAQsgAyAEaiEECyAEIQUDQAJAIAAgBUsEQCAFLQAAQTBGDQELQQAhAgNAAkAgAiAFaiIGIABPIgoNACAGLQAAIgZBMGtB/wFxQQlLDQAgAiADaiECIAhCCn4gBq1C/wGDfEIwfSEIDAELCyABQv///////////wBCgICAgICAgICAfyAHGyAIQgAgCH0gBxsgCEIAUxs3AwACfyACRQRAQX8iBiAEIAVGDQEaCyAJIAkNABogCSIGIAoNABogAiEEA0BBASIGIAQgBWotAABBwKQDai0AAEEBcUUNARogBSADIARqIgRqIABJDQALQQALIQYCQCACIANBE2wiBEkNAEEBIQAgAiAETQRAQQAhBEEAIQADQCAAIARBEUtyRQRAIAUgAyAEbGosAAAgBEHs0gJqLAAAa0EKbCEAIARBAWohBAwBCwsgAEUEQCAFIANBEmxqLAAAQThrIQALIABBAEgNAQsgAUL///////////8AQoCAgICAgICAgH8gBxs3AwBBAkEDIAYgBxsgABshBgsgBg8LIAMgBWohBQwACwALqQEDAX4BfAF/AkAgAC8BECIDQSBxRQRAAn5CgICAgICAgICAfyIBIAArAwAiAkT////////fw2MNABpC////////////ACIBIAJE////////30NkDQAaIAKZRAAAAAAAAOBDYwRAIAKwDAELQoCAgICAgICAgH8LIgFC////////////AHxCfVYgAiABuWJyDQEgACABNwMACyAAIANBwOQDcUEEcjsBEAsL+ggNAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEHQAmsiCCQAIAhBADYCzAICfyAGRQRAQZWgBhAkDAELIAZBADYCACADRSACRXJBASAAECgiBxsEQEGboAYQJAwBCyAFQQBH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IQELIAAgAjYCACADQRBqJAAgAQujAQYBfwF/AX4BfwF/AX8gACgCACAAKAIMIgFrQQxtIQRBASECIAAoAgggAWsiBUEMbSIGQRhsQcgJaq0hAwJAAkAgAEEQaiABRgRAQQAgAxDvCCIBRQ0CIAEgACgCDCAFQQxqEOUUGgwBCyABIAMQ7wgiAUUNAQsgACABNgIMIAAgASAEQQxsajYCACAAIAZBGGwgAWpBvAlqNgIIQQAhAgsgAgtLAgF/AX8gACgCBCECA0AgACgCACIBIAAoAgxNRQRAIAAgAUEMazYCACAAIAEvAQIgAUEEahC1AwwBCwsgAigCABCVASAAIAI2AgQLsLEBHgF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQaAGayIGJAAgACgCACEEAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAB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ACAAQdAOakEAQebiAmo2AgAgAEKIgICAwAA3A8gOIABBkTs2AsQOIABBtZ8DNgLADiACQYCBCCACa0GKICAAQcAOahDhFSACaiICQYCACE8NACAAQbAOakEAQYvjAmo2AgAgAEKMgICAwAA3A6gOIABBjyk2AqQOIABBtZ8DNgKgDiACQYCBCCACa0GKICAAQaAOahDhFSACaiICQYCACE8NACAAQZAOakEAQdbjAmo2AgAgAEKQgICAwAA3A4gOIABBhTs2AoQOIABBtZ8DNgKADiACQYCBCCACa0GKICAAQYAOahDhFSACaiICQYCACE8NACAAQfANakEAQdbjAmo2AgAgAEKUgICAwAA3A+gNIABBhiY2AuQNIABBtZ8DNgLgDSACQYCBCCACa0GKICAAQeANahDhFSACaiICQYCACE8NACAAQdANakEAQYvjAmo2AgAgAEKYgICAwAA3A8gNIABBx4QBNgLEDSAAQbWfAzYCwA0gAkGAgQggAmtBiiAgAEHADWoQ4RUgAmoiAkGAgAhPDQAgAEGwDWpBAEHW4wJqNgIAIABCnICAgMAANwOoDSAAQY6aATYCpA0gAEG1nwM2AqANIAJBgIEIIAJrQYogIABBoA1qEOEVIAJqIgJBgIAITw0AIABBkA1qQQBBmOMCajYCACAAQqCAgIDAADcDiA0gAEHg8wA2AoQNIABBtZ8DNgKADSACQYCBCCACa0GKICAAQYANahDhFSACaiICQYCACE8NACAAQfAMakEAQdbjAmo2AgAgAEKkgICAwAA3A+gMIABB7i42AuQMIABBtZ8DNgLgDCACQYCBCCACa0GKICAAQeAMahDhFSACaiICQYCACE8NACAAQdAMakEAQdbjAmo2AgAgAEKogICAwAA3A8gMIABB5ZABNgLEDCAAQbWfAzYCwAwgAkGAgQggAmtBiiAgAEHADGoQ4RUgAmoiAkGAgAhPDQAgAEGwDGpBAEHR5QJqNgIAIABCrICAgMAANwOoDCAAQdyDATYCpAwgAEG1nwM2AqAMIAJBgIEIIAJrQYogIABBoAxqEOEVIAJqIgJBgIAITw0AIABBkAxqQQBBi+MCajYCACAAQrCAgIDAADcDiAwgAEGUrQE2AoQMIABBtZ8DNgKADCACQYCBCCACa0GKICAAQYAMahDhFSACaiICQYCACE8NACAA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AkUNAiABIAAoArwBQQAgAhECABoMAgtBACECIAAtABEiASEDIAFFBEAgABD2BiECIAAtABEhAwsgA0H/AXFBAUYEQCAAQQIQ1AYhAgsCQCACDQAgACgCACICKAIcIgMEQCACIAAoArwBQQAgAxECABoLIAFBAUcNACAAQQEQ3wYaDAILIAENASAAEKUGDAELAkAgAUECaw4DAAEAAQsgACgCRCIBKAIAIgJFDQAgASACKAIEEQEAGiABQQA2AgALIAAtAAULbAIBfgF/IAApAwAhAgJAAkAgAUIAWQRAIAJCAFcNAUEBIQMgAkL///////////8AhSABWg0BDAILIAJCAFkNAEEBIQMgAUIBfEKBgICAgICAgIB/IAJ9Uw0BCyAAIAEgAnw3AwBBACEDCyADCxwBAX8gACAAKAIAIgEoAtQBNgIEIAEgADYC1AELhwEDAX8BfwF/IAAoAhQhAiAAEPgBIAJCIBDsAiIBRQRAQQcPCyACIAEQVSEDIAFBADYCFCABQgA3AgggASACNgIEIAFBADYCACABQQA2AhwgAUEBOwEaIAEgAUEgajYCECABIANB4P8/akEEdjsBGCAAQS42AiQgAEGQIDsBECAAIAE2AghBAAvJAQUBfwF/AX8BfwF/IwBBoAFrIgEkACABQQBBoAEQ5xQhAwNAIAAEQCAAKAIIIQRBACEBIABBADYCCANAIAMgAUECdGoiAigCACIFBEAgBSAAEMQHIQAgAkEANgIAIAFBAWohAQwBCwsgAiAANgIAIAQhAAwBCwsgAygCACEAQQEhAQNAIAFBKEZFBEACQCADIAFBAnRqKAIAIgJFDQAgAEUEQCACIQAMAQsgACACEMQHIQALIAFBAWohAQwBCwsgA0GgAWokACAAC14CAX8BfyMAQRBrIgQkAANAAkAgACIDKAIMIgAEQCAAIAEgBEEMahDDByAEKAIMIAM2AggMAQsgASADNgIACyADQQhqIQEgAygCCCIADQALIAIgAzYCACAEQRBqJAALegUBfwF+AX8BfwF+IwBBEGsiBSECAkADQCAAKQMAIQMgASEEA0AgBCIBKQMAIgYgA1kEQCADIAZTBEAgAiAANgIIIAAhAgsgACgCCCIADQIMAwsgAiABNgIIIAEhAiABKAIIIgQNAAsLIAAhAQsgAiABNgIIIAUoAggLbAQBfwF/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NgIsIAJBBXZBAXEhAUEAIQADQCAAQRdGRQRAIABBAnRBnOAGaiECA0AgAigCACICBEAgBSACQQEgARCbCyACQSRqIQIMAQsLIABBAWohAAwBCwsgB0GoA2ohAgNAIAIoAgAiAkUNByAFIAIoAghBACABEJsLDAALAAsgAEECNgIsIAdBuANqIQJBACEBA0AgAigCACICRQ0GIAYgAigCCCgCADYCxAFBACEAIAYgATYCwAEgBUEBQcTKACAGQcABahCPCyABQQFqIQEMAAsACyAAQQM2AixBACECA0AgAiAHKAIUTg0FIAcoAhAgAkEEdGoiASgCBCIABEAgASgCACEBIAYgABClBDYCuAEgBiABNgK0ASAGIAI2ArABIAVBAUG6wQAgBkGwAWoQjwsLIAJBAWohAgwACwALIAhFDQMgByAIIAQQhAMiAkUNAyAHIAIoAjwQ/AIhASAAQQU2AiwgACABEK8JIAJBCGohAiAGIi9BoAFqIQlBACEBA0AgAigCACICRQ0EIAIvADchACACLQA2IQMgAigCACEEIC8gAigCJEEARzYCoAEgBiAENgKUASAGIANBAEc2ApgBIAZBACIDQaiPBmogAEEDcUECdGooAgA2ApwBIAYgATYCkAEgBUEBQZKLASAGQZABahCPCyACQRRqIQIgAUEBaiEBDAALAAsgCEUNAiAHIAggBBCVCCIBRQRAIABBAiAIIAQQ+wIiAkUNAyACLQAcQYABcUUNAyACEK8DIgFFDQMLIAcgASgCGBD8AiECIAFBMkE0IAopAwhQIgMbai8BACEJIABBA0EGIAMbNgIsIAEoAgwhCyAAIAIQrwlBACECA0AgAiAJRg0DQQAhAyABKAIEIAJBAXRqLgEAIgRBAE4EQCALKAIEIARBDGxqKAIAIQMLIAYgAzYCiAEgBiAENgKEASAGIAI2AoABIAVBAUGdywEgBkGAAWoQjwsgCikDCFBFBEAgASgCHCACai0AACEDIAEoAiAgAkECdGooAgAhBCAGIAIgAS8BMkk2AnggBiAENgJ0IAYgAzYCcCAFQQRBossBIAZB8ABqEI8LCyAFQdQAQQEgACgCLBCKAxogAkEBaiECDAALAAsgAEEGNgIsIAAgBBCeCSAGIjBB1ABqIQwDQCAPIAcoAhRODQIgBygCECECAkAgBARAIAQgAiAPQQR0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B0FxEPQIGiAIKAJsIgdBAEoEQCAIKAJoIAdBGGxqQRZrIAZBLnE7AQALIAAoAngiByAAIAcbQQE6ABULagEBfyABEKULIQMCQCAALQAXRSADRXINACADLQAAQbABRg0AIAAgAxCwC0UNACACQQA2AgAgACADQX8QsQsPCyAAEJUJIgEgACADIAEQgQsiA0cEQCAAIAEQlglBACEBCyACIAE2AgAgAwsOACAAEKULKAIILQAERQuCAgUBfwF/AX8BfwF+IwBBEGsiBCQAIAAoAgghBQJAIAEtAAVBCHEEQCAFQccAQQAgASgCCCIBayABIAIbIAMQigMaDAELAkAgASgCCCIGIARBCGoQogQiB0ECRiACQQBHIAdBA0dyRXJFBEAgAkUgBCkDCCIIQoCAgICAgICAgH9Scg0BCyAGQdYpQQIQbkUEQCAEIAE2AgQgBEEAIgFBztcCQemfAyACG2o2AgAgAEG72wEgBBCyAgwCCyAFIAYgAiADELgLDAELIAIEQCAEQoCAgICAgICAgH9CACAIfSAHQQNGGzcDCAsgBUHIACADIARBCGpBcxC/CwsgBEEQaiQAC0sBAX8jAEEQayIEJAAgAQRAIAEgBEEIaiABEFpBARD2AhogAgRAIAQgBCsDCJo5AwgLIABBmQEgAyAEQQhqQXQQvwsLIARBEGokAAsKACAAEPYKQQFKCxsBAX8gAS0AAEGKAUYEQCAAIAEQrgshAgsgAgt+AQF/An8CQAJAAkAgAS0AACIGQbABaw4CAAIBCyAEIAEgAhDECzYCACABKAIcIAJqDwtBACIFIAZBigFHDQEaIAQgASgCFCgCHCACQQR0aigCCDYCACACIANqDwsgBCABKAIUIAJBBHRqKAIIIgE2AgAgACABIAUQtQsLIgULdgACQCAAKAIkDQACfyAIBEAgACACIAEQugMMAQsgACABIAIQugMLIQggASACEOQJEMALIQIgACgCCCADIAUgBiAEIAhBfhD0CBogACgCCCIAKAJsIgFBAEwNACAAKAJoIAFBGGxqQRZrIAIgB3JB/wFxOwEACwsjACAAKAIALQBXBEBBkIIIDwsgACgCaCAAKAJsQRhsakEYawssAQF/IAAoAgAiAyABQQAQpAkhASADLQBXRQRAIAAgASACEPcICyADIAEQMwsvAQF/IAAoAgBCCBDsAiIFBEAgBSADKQAANwAACyAAIAFBACACQQAgBSAEEPQIGgs/ACABQcEASCAAEOQJIgBBwQBIckUEQEHDAEHDAEHBACAAQcIASxsgAUHCAEsbDwsgASAAIABBwQBIG0HAAHILYwIBfwF/IAEoAgwiAxD2CiECAn8CQAJAIAEtAAVBEHFFDQAgACgCAC0AVw0AQQAgAiABKAIUKAIcKAIAIgFGDQIaIAAgASACEK8LDAELQQAgAkEBRg0BGiAAIAMQ1AsLQQELC50BBQF/AX8BfwF/AX8gASgCDCIFEPYKIQIgAS0ABUEQcQRAIAEoAhQhAwsgACgCACACQQFqrBBdIgQEQEEAIQEgAkEAIAJBAEobIQYDQCABIAZGRQRAIAUgARDECxDkCSEAIAMEQCADKAIcIAFBBHRqKAIIIAAQwAshAAsgASAEaiAAOgAAIAFBAWohAQwBCwsgAiAEakEAOgAACyAEC5cLEQF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfwF+AX4jAEEwayINJAAgABDwCCEKIAAgACgCKCIOQQFqNgIoAkAgA0UEQEEAIQMMAQsgAS0ABUEQcUUNACABKAIUKAIcIgcoAgAiC0EAIAtBAEobIQYDQAJAIAYgCEcEQCAHIAhBBHRqKAIIELoKRQ0BIAghBgsgA0EAIAYgC0cbIQMMAgsgCEEBaiEIDAALAAsgAkEEcSEIAkACQCAAKAIkDQAgASgCBEHAIHFBgCBHDQAgASgCFCIGKAI0DQAgBi0ABEEJcQ0AIAYoAjwNACAGKAIkDQAgBigCICIHKAIAQQFHDQAgBygCHA0AIAcoAhgiDC0AK0EBRg0AQQAhByAGKAIcIhEoAgAiC0EAIAtBAEobIRMDQCAHIBNHBEAgB0EEdCEJIAdBAWohByAJIBFqKAIILQAAQacBRg0BDAILCyAGRQ0AIAAgACgCACAMKAI8EPwCIhQQrwkCQCALQQFHDQAgESgCCC4BIEEATg0AIApBDxDxCCEGIAAgDiAUIAxB8AAQ9QggDSAMKAIANgIAIABBAEEAIghB/eEBaiANEKAKIAooAmwhACAKKAIALQBXBH9BkIIIBSAKKAJoIAZBGGxqCyIIIAA2AghBASEGDAILQQAhBkEBIQcDQCAHQQFxRSAGIAtOckUEQCABKAIMIAYQxAshCUHEACEHAkAgESAGQQR0aigCCC4BICIPQQBIDQAgDC4BIiAPTA0AIAwoAgQgD0EMbGotAAUhBwsgB8AiB0HCAEogCSAHEMALQcEAa0ECSXIhByAGQQFqIQYMAQsLIAdBAXFFDQAgDEEIaiEHQn8gC62GQn+FIRVBACEGA0AgBygCACIHRSAGckUEQEEAIQYCQCALIAcvATQiCUoNACAHKAIkIAlBPktyDQACQCAIRQ0AIAsgBy8BMkgNASAJIAtMDQAgBy0ANkUNAQtBACEQQgAhEgNAAkAgECATRg0AQQAhBiAAIAEoAgwgEBDECyARIBBBBHRqKAIIIgkQugMhDANAIAYgC0YiDw0BAkAgBygCBCAGQQF0ai8BACAJLwEgRgRAIAxFDQEgDCgCACAHKAIgIAZBAnRqKAIAEG1FDQELIAZBAWohBgwBCwsgDw0AQgEgBq2GIhYgEoNCAFINACAEBEAgBCAQQQJ0aiAGNgIACyASIBaEIRIgEEEBaiEQDAELC0EAIQYgEiAVUg0AIApBDxDxCCEMIA0gBygCADYCICAAQQBBAEHe4QFqIA1BIGoQoAogCkHwACAOIAcoAiwgFBDbCBogACAHEOAKIA0gBygCADYCECAKQbPuACANQRBqEPMIIAcoAhwtAAAhBgJAIANFDQAgACAAKAIsQQFqIgk2AiwgAyAJNgIAIAtBAUcNACAKIA4gCRDVCwtBACEJIAooAmwhDyAGQQNqIQYgCigCAC0AVwR/QZCCCAUgCigCaCAMQRhsagsiCSAPNgIICyAHQRRqIQcMAQsLIAYNAQsCQCACQQFxRQ0AIAEtAAVBEHENACABKAIMIQYgAUEANgIMIAAgARDKCSEHIAEgBjYCDCAHBEAgASgCFCgCAEECSg0BC0F/IQ4gACAAKAIoQQFrNgIoQQUhBgwBCyAALwGUASEGAkAgCARAQQAhCCAAQQA7AZQBDAELIANFBEBBACEIDAELIAAgACgCLEEBaiIINgIsIAMgCDYCAAsgACABIA4Q1gsgCARAIAogDiAIENULCyAAIAY7AZQBQQIhBgsCQCAERSAGQQNGciAGQQRGcg0AQQAhCCABKAIMEPYKIgBBACAAQQBKGyEAA0AgACAIRg0BIAQgCEECdGogCDYCACAIQQFqIQgMAAsACyAFIA42AgAgDUEwaiQAIAYLSAAgABC5CwRAAn8CQCAALQAAQYoBRwRAIAAtAAJBigFHDQELIAAoAhRBHGoMAQsgAEEUagsiACgCACABQQR0aigCCCEACyAAC3oDAX8BfwF/IAAgACgCACAAKAJAQQogACgCOCIFayIEQQJ0rRCqByIDNgJAIANFBEAgAEEANgI8DwsCQCAFQaZ/Sg0AIAAoAjxB5ABtIARB5ABuTg0AIAAQ3gsgACgCQCEDCyAAIAQ2AjwgAyACQQJ0aiABKAJsNgIAC54FCAF/AX8BfwF/AX8BfwF/AX8jAEEQayIIJAAgCAJ/IAMEQEGAgIDAACEKQX8hBSADKAIADAELAkAgAgRAQX8hBSABEN8LIQQMAQtBOCEEIAEtAAVBCHENACABKAIIIgZFDQAgBhDvFUH/////A3EiBEEBaiEFIARBPGpB+P///wdxIQQLIAAgBKwQ7AILIgQ2AggCQCAERQ0AIAEgAhDgCyEHAkAgBUEATg0AQQAhBSABLQAFQQhxDQAgASgCCCIGRQ0AIAYQWkEBaiEFCwJAIAIEQCAEIAEgB0H/H3EiBhDlFBoMAQtBNCEGIAQgAUEMQRxBNCABKAIEIglBgIABcRsgCUGAgARxGyIJEOUUIQsgCUEzSw0AIAkgC2pBAEE0IAlrEOcUGgsgBCAEKAIEQf//+r9/cSAHQYCABXEgCnJyIgc2AgQgBUEASgRAIAQgBCAGaiIHNgIIIAcgASgCCCAFEOUUGiAEKAIEIQcgBSAGaiEGCyAIIAQgBkEHakF4cWo2AgggASgCBCIFIAdyQYCAhARxDQAgASgCFCEGIAQCfyAFQYAgcQRAIAAgBiACEKUJDAELIAAgBiACQQAgAS0AAEGRAUcbEJAJCyIFNgIUIAEtAAdBAXEEQCAEIAAgBCABKAIsENkLNgIsCyABKAIMIQUgAS0AACEGIAQCfyACBEACQCAGQf8BcUGyAUYNACAFRQRAQQAhBQwBCyAAIAVBASAIQQhqEMYLIQULIAQgBTYCDEEAIAEoAhAiAUUNARogACABQQEgCEEIahDGCwwBCyAGQf8BcUGyAUcEQCAAIAVBABCkCSEFCyAEIAU2AgwgACABKAIQQQAQpAkLIgE2AhALIAMEQCADIAgoAgg2AgALIAhBEGokACAEC6IBBQF/AX8BfwF/AX8CQCAALQAAIgJBK2tB/wFxQQFLDQAgACgCEBDHCyEBAkAgACgCDBDHCyIDKAIEIgRBgYCAgAFxQYCAgIABRwRAIAEoAgQiBUGBgICAAnFBgICAgAJHDQELIAEgAyACQSxGGw8LIAVBgYCAgAFxQYCAgIABRyAEQYGAgIACcUGAgICAAkdxDQAgAyABIAJBLEYbIQALIAALPwEBfwJAIABFDQAgACgCZCABQShsakEoayIBLQAQQQFxDQAgACgCABCyASIARQ0AIAAgARCsAhogACECCyACC7QBAQF/QQEhBAJAIAFFIAJFcg0AIAEtABAgAi0AEEcNACABLQARIAItABFHDQAgAS0AEiACLQASRw0AIAEtABQgAi0AFEcNACAAIAEoAhggAigCGEF/EPgKDQAgACABKAIcIAIoAhxBfxD4Cg0AIAEoAgggAigCCEF/EJgKIgQNACABKAIMIAIoAgxBfxCYCiIEDQAgAwRAIAAgASgCKCACKAIoQX8Q+AoiBA0BC0EAIQQLIAQLCwAgAEEAOwEUQQILrwIDAX8BfwF/AkACQAJAAkAgAC8BFCIEQQJHDQAgAS0ABEEBcUUNAAwBCwJAAkACQAJAAkAgAS0AACIDQacBaw4NAwMDBgYBBgYGBQYGBQALIANBO0YNASADQccARiADQY0BRnINBCADQZwBRg0DDAYLIAEoAgQiAkGAgMAAcUUgBEEDTXEgAkGAgIAIcXJFBEAgBEEFRw0GIAEgAkGAgICABHI2AgQMBgsgACgCAARAIAAgARDMCw8LDAMLQQEhAiABEMkJDQMLIAAvARQhAyABLQAEQSBxBEBBACECIANBAkYNAgwDCyADQQNHDQFBACECIAEoAhwgACgCGEYNAgwBCwJAAkAgBEEEaw4CAQADCyABQfkAOgAADAMLCyAAQQA7ARRBAiECCyACDwtBAAuKAQIBfwF/An8CQAJAIAEtAAZBAXENACABKAIUIgNFDQAgAygCACECIAAgAxCzCRogAC8BFEUNAQsCQCAAKAIAKAIAIgMgASgCCCACIAMtAFRBABDjAyICRQ0AIAIoAhQNACACLQAFQShxRQ0AQQEiAiABLQAHQQFxRQ0CGgsgAEEAOwEUC0ECCyICC7cBAgF/AX8CQAJAA0AgACABIgIgACgCBBEAACIBBEAgAUECcQ8LIAItAAZBgQFxDQECQCACKAIMIgFFDQAgACABEM0LRQ0AQQIPCyACKAIQIgENAAsgAigCFCEDIAIoAgQiAUGAIHEEQEECIQEgACADELEJRQ0BDAILIAMEQEECIQEgACADELMJDQIgAigCBCEBCyABQYCAgAhxRQ0AQQIhASAAIAIoAixBARDOCw0BC0EAIQELIAELbwEBfwJAA0AgAUUEQEEADwtBAiEDIAAgASgCDBCzCQ0BIAAgASgCCBCzCQ0BIAAgASgCKBCyCQ0BIAAgASgCGBCyCQ0BIAAgASgCHBCyCSIDIAJyRQRAIAEoAiQhAQwBCwsgA0EAR0EBdCEDCyADCzIAAkAgACgCACIAKAKMAkUNACABKAI0DQAgARDKCigCQCIBRQ0AIAAgASgCCDYCjAILC5kCAgF/AX8DQCAAIAEgAiADEPgKRQRAIAItAABB+QBHDwtBACEGAkACQAJAAkACQAJAAkACQCABLQAAIgVB5gBrDg0CAQEBAQECAgIBBQcGAAsCQAJAAkAgBUEwaw4KAgEHBwMDAwMDAwALIAVBrQFrDgkICAQGBgYGBggFCyAERQ0GQQEhBCABLQAFQRBxDQUMBwsgBA0EQQEhBiAAIAEoAhQiBSgCCCACIANBARDQCw0EQQEhBCAAIAUoAhggAiADQQEQ0AtFDQYMBAtBASEECyAAIAEoAhAgAiADIAQQ0AtFDQRBAQ8LIAQNAUEBIQQgAS0AAkEtRg0DDAELIAVBE0YNAQsgBg8LQQEhBAsgASgCDCEBDAALAAu6AgMBfwF/AX9BASEDAkAgASgCBCICQQFxDQAgAkECcQRAIAAvARYNAQsCQAJAAkACQAJAAkAgAS0AACIEQStrDg8BAQYFBQMCBgYEBAQEBAQACyAEQZ0BayICQRRLDQRBASACdEGBgNMAcQ0FIAJBCkcNBCAAKAIYIAEoAhxHDQUgAEEBOwEUQQIPCyAAIAEoAgwgASgCEBDSC0EBDwsgAkGAIHENAyABKAIUKAIAQQBMDQMgACABKAIMELIJGkEBDwsgACABKAIMELIJGiAAIAEoAhQiASgCCCABKAIYENILQQEPCyABKAIQIQICQCABKAIMIgEtAABBpwFHDQAgASgCLCIBRQ0AIAEtACtBAUYNAgsgAi0AAEGnAUcNACACKAIsIgFFDQAgAS0AK0EBRg0BC0EAIQMLIAMLKwACQCAALwEUDQAgACABELIJGiAALwEURQ0AIABBADsBFCAAIAIQsgkaCwsOACABBEAgACABEKAICwsrACABLQAFQRBxBEAgACABKAIUKAIcKAIAQQEQrwsPCyAAQaixAUEAELICC54BAgF/AX8jAEEQayIDJAAgAEHHAEEAIAIQigMaIABBJCABEPIIIQQgAEHeACABQQAgAhDbCBogACgCbCICQQBKBEAgACgCaCACQRhsakEWa0GAATsBAAsgAyABNgIAIABBACICQfDnAmogAxDzCCAAKAJsIQEgACgCAC0AVwR/QZCCCAUgACgCaCAEQRhsagsiACABNgIIIANBEGokAAuQCAsBfwF/AX8BfwF/AX8BfwF/AX8BfwF/IwBB0ABrIgYkACAAKAIIIQQCQAJAIAEoAgQiA0HAAHENACAAKAI0DQAgA0GAgIAQcQRAIARBDxDxCCEHIAEtAAVBEHEEQCAGIAEoAhQoAhA2AiAgAEEAQbS/ASAGQSBqEKAKCyAEQQogASgCMCABKAIsEIoDGiAEQfMAIAIgASgCHBCKAxogBCgCbCEDIAQoAgAtAFcEf0GQgggFIAQoAmggB0EYbGoLIgQgAzYCCAwCCyABIANBgICAEHI2AgQgACAAKAIsQQFqIgM2AiwgASADNgIwIAEgBEHKAEEAIAMQigNBAWo2AiwgBEEPEPEIIQgLIAEoAgwiCxD2CiEHIAEgAjYCHCAEQfYAIAIgBxCKAyEMAkAgAS0ABUEQcQRAIAYgASgCFCgCEDYCECAEQacuIAZBEGoQ8wgMAQsgBEGg8ABBABDzCAsgACgCACAHQQEQzQohCSABKAIUIQUCQCABLQAFQRBxBEAgBSgCHCEKIAYgBSgCEDYCBCAGQQAiA0HpnwNBxJ4DIAgbajYCACAAQQFBob8BIAYQoAogCigCACAHRw0BIAZBQGtBADYCACAGQgA3AzggBiACNgI0IAZBCzoAMCAGIAAgARDCCyINNgJEIAVBADYCCCAAKAIAIAVBABClCSEDAkAgACgCACIFLQBXRQRAIAAgAyAGQTBqEOYJIQUgACgCACADEJ8IIAAoAgAgBigCRBAyIAUNAUEAIQMgB0EAIAdBAEobIQUDQCADIAVGDQQgCSADQQJ0aiAAIAsgAxDECyAKIANBBHRqKAIIELoDNgIUIANBAWohAwwACwALIAUgAxCfCCAAKAIAIA0QMgsgCRCTBwwCCyAFRQ0AIAYgCxDkCSIDOgAwAkAgA0HAAEwEQCAGQcEAOgAwDAELIANBxQBHDQAgBkHDADoAMAsgCQRAIAkgACABKAIMEOsINgIUCyAFQQhqIQcgABCVCSEDIAAQlQkhCiAFKAIAIQUDQCAFQQBMRQRAIAcoAgAhCwJAIAgEQCAAIAsQygkNASAEIAhBAWsQrAogBCAIEKwKIAEgASgCBEH///9vcTYCBAtBACEICyAAIAsgAxD3CCAEQeEAIANBASAKIAZBMGpBARD0CBogBEGKASACIAogA0EBEP8CGiAHQRBqIQcgBUEBayEFDAELCyAAIAMQlgkgACAKEJYJCyAJBEAgBCAMIAlBeBC9CgsgCEUNACAEQYgBIAIQ8ggaQQAhBSAEKAJsIQMgBCgCAC0AVwR/QZCCCAUgBCgCaCAIQRhsagsiBSADNgIIIARBwwAgASgCMCABKAIsQQEQ2wgaIABBADYCHCAAQQA6ABMLIAZB0ABqJAALMQIBfwF/AkAgACgCXCICQQEgAXQiA3ENACAAIAIgA3I2AlwgAUEBRw0AIAAQuAEaCwuaAQQBfwF/AX8BfwJAIAFFDQAgACABKAIAQRhsQQxqrRDFAiIERQ0AIAQgASgCADYCAAN/IAEoAgAgAkwEfyAEBSAEIAJBGGwiA2oiBSAAIAEgA2oiAygCFEEAEKUJNgIUIAUgACADKAIQQQAQkAk2AhAgBSAAIAMoAgwQoAE2AgwgBSADLQAgOgAgIAJBAWohAgwBCwshAgsgAguNAgIBfwF/AkAgAkUNACAAQuQAEMUCIgNFDQAgAyAAIAIoAgAQoAE2AgAgAyAAIAIoAgQQoAE2AgQgAyAAIAIoAihBABCkCTYCKCADIAIoAiw2AiwgAyAAIAIoAghBABCQCTYCCCADIAAgAigCDEEAEJAJNgIMIAMgAi0AEDoAECADIAItABI6ABIgAyACLQAROgARIAMgAi0AFDoAFCADIAIoAjg2AjggAyACKAI0NgI0IAMgAigCUDYCUCADIAIoAjA2AjAgAyACLQBgOgBgIAMgACACKAIYQQAQpAk2AhggACACKAIcQQAQpAkhACADIAE2AkggAyAANgIcIAMgAi0AEzoAEyADIQQLIAQLCgAgACgCGCABRwsqAAJAIAEtAABBrAFHDQAgAS0AB0EBcUUNACAAKAIYIAEoAiwQ3QsLQQALggEEAX8BfwF/AX8CQCABRQ0AIAAgASgCAEEDdEEIaq0Q7AIiA0UNACADIAEoAgA2AgAgAyABLQAEOgAEA38gASgCACACTAR/IAMFIAMgAkEDdCIEaiIFIAAgASAEaiIEKAIIEKABNgIIIAUgBCgCDDYCDCACQQFqIQIMAQsLIQILIAILkAEDAX8BfwF/AkAgAEUNACAAIgJBxABqIQMCQAJAIAAoAkQiBEUEQCABQQA2AiQMAQtBACAEIAFBABDJCw0BIAEgAigCRCIANgIkIABFDQAgACABQSRqNgIgCyACIAE2AkQgASADNgIgDwsgASgCCCACKAJEKAIIQX8QmApFDQAgACAAKAIEQYCAgBByNgIECwuIAQMBfwF/AX8gACgCACIBKAKoAgRAIABBCTYCDCAAIAAoAiRBAWo2AiQLAkAgASgC9AIiAkUNAAJAIAAoAgxBCUYNACAAIAAoAnBBAWoiAzYCcCADIAEoAvwCSQ0BIAEoAvgCIAIRAQBFDQAgAEEJNgIMIAAgACgCJEEBajYCJAsgAEEANgJwCwtzAwF/AX8BfwNAIABBARDgC0H/H3EhAQJAIAAtAAVBCHENACAAKAIIIgNFDQAgASADEO8VQf////8DcWpBAWohAQsgAUEHakF4cSEBIAAoAgwiAwRAIAMQ3wsgAWohAQsgASACaiECIAAoAhAiAA0ACyACCzkBAX9BNCECAkAgAUUNACAALQAGQQJxDQBBnIABIQIgACgCDA0AQZyAAUGMgAQgACgCFBshAgsgAgsUACAAQf78AEEAELICIABBATYCDAudBgwBfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEEwayIGJAAgACgCACEJIAZCADcDICAGQgA3AxgCfyABRQRAQQAMAQtB//8BIAEoAgAiBSAFQf//AU4bIQQgCSAFQQxsrRDFAgshCyACIAQ7AQAgAyALNgIAIARBACAEQQBKGyEMIAshCANAAn8CQAJAAkACQAJAIAogDEcEQCAAKAIkRQ0BIAohDAsgBkEYahDxASAAKAIkRQ0CQQAhBANAIAQgDEYNAiAJIAsgBEEMbGooAgAQMiAEQQFqIQQMAAsACyABIApBBHRqIg1BCGohDiANKAIMIgcEQCANLQARQQNxRQ0DCyAOKAIAEKULIQQDQCAELQAAIgVBjQFHBEACQAJ/IAVBO0cEQCAFQacBRw0CIAQtAAdBA3ENAiAEKAIsIgVFDQICQCAELgEgIgRBAE4NAEEAIQcgBS4BICIEQQBODQBBjq0BIQcMCAsgBSgCBCAEQf//A3FBDGxqDAELIARBCGoLIgQoAgAhBwsgB0UNBQwEBSAEKAIQIQQMAQsACwALIAkgCxAyIANBADYCACACQQA7AQALIAZBMGokAA8LIAcQhQoNACAJIAcQoAEMAQsgBiAKQQFqNgIQIAlB/bgBIAZBEGoQ/QILIQUgBkEANgIsA0ACQCAFRQ0AIAZBGGogBRCFAyIERQ0AIAQtAAlBgAFxBEAgCCAILwEKQYAIcjsBCgsgBRBaIg8hBCAGIA9BAEwEf0EABQNAAkAgBEEBTARAIAUtAAAhB0EAIQQMAQsgBSAEQQFrIgRqLQAAIgdBOmtBdUsNAQsLIAQgDyAHQf8BcUE6RhsLIgQ2AgAgBiAFNgIEIAYgBigCLEEBaiIENgIsIAYgBDYCCCAJQaEsIAYQ/QIhBSAAEN4LIAYoAixBBEkNAUEEIAZBLGoQawwBCwsgCCAFNgIAIAggBRCPCToAByANLQASQQFxBEAgCCAILwEKQYAIcjsBCgsCQCAFRQ0AIAZBGGogBSAOEOcDIA5HDQAgCRCVAQsgCEEMaiEIIApBAWohCgwACwALpgULAX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQTBrIggkAAJAIAAoAgAiDS0AVw0AIAAtANQBQQFLDQADQCACIgkoAjQiAg0ACyAJKAIcIQIgCEEIakEAQSQQ5xQaIAggCSgCIDYCDCACQQhqIQ4gASgCBCEFA0AgAS4BIiAKSgRAIAEgASgCHCAFLwEKQeIAcXI2AhxBACEGIA4gCkEEdCIHaigCACIMEOQJIQQgCSECAkADQCAFIAQ6AAUgBMBBwABKDQEgAigCOARAIAIoAhwgB2ooAggQgwwgBnIhBiACKAI4IgIoAhwgB2ooAggQ5AkhBAwBCwsgBSADOgAFIAMhBAsCQCAEwEHCAEgNACACKAI4IgtFIAIgCUZxDQADQCALBEAgCygCHCAHaigCCBCDDCAGciEGIAsoAjghCwwBCwtBwQAhAgJAIAZBAXEgBSwABSIEQcIARnENACAEQcMASCIHQQEgBkECcRtFDQAgBw0BQcYAIQIgDC0AAEEkRw0BCyAFIAI6AAUgAiEECwJAAkAgCEEIaiAMEIQMIgYEQCAEQf8BcSAGQQAQ7QhB/wFxRg0BIAUtAAUhBAtBwfEBIQZBASECAkAgBEH/AXEiBEHDAGsOBAEAAAEACwNAIAJBBkYNAiAEIAJB0MIEai0AAEcEQCACQQFqIQIMAQsLIAJBAnRBoIAGaigCACIGRQ0BCyAFIA0gBSgCACICIAYQWiIErSACEFoiB618QgJ8EKoHIgI2AgAgBSAFLwEKQfv7A3E7AQogAkUNACACIAdqQQFqIAYgBEEBahDlFBogBSAFLwEKQQRyOwEKCyAAIAwQ6wgiAgRAIA0gBSACKAIAEPIJCyAFQQxqIQUgCkEBaiEKDAELCyABQQE7ASgLIAhBMGokAAuHMSEBfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfAF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfwF/AX8jAEGAAmsiBCQAIAAoAhgiCCgCACEFIAEhEwJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAIgJBLWsOHwUJCQYHAgIGBgYGBgYJBAkJCQkJCQkJCQkJCQkJCQEACwJAIAJBigFrDgQHCQkDAAsCQCACQasBaw4CBQgACyACQRRGDQYgAkGcAUcNCCAILQAYQS5xRQ0IIAUgCEGDxAAgASABEOYLDAgLIAgoAgQhAiABQacBOgAAIAEgAigCGDYCLCABIAIoAjA2AhwgASABLwEgQQFrOwEgIAFBxAA6AAEMBwsgCCECA0AgAkUgA0EHS3JFBEAgBEHAAWogA0ECdGogAigCEDYCACADQQFqIQMgAigCDCECDAELCyAAIAEoAgwQsgkaQQEhAiAFLQDUAUEBSw0IIAEoAgwiABC6Cg0IIAghAwNAIAMEQCADLQAaQRBxRQ0KIAMoAgwhAwwBCwsgAS0AACEDIAFBmwE6AAAgASADQTNGNgIIIAEgASgCBEGAEHI2AgRBACEDA0AgCEUgA0EHS3JFBEAgCCAEQcABaiADQQJ0aigCADYCECADQQFqIQMgCCgCDCEIDAELCyAFKAIAIAAQMyABQQA2AgwMCAsgASgCDCEHIAgtABhBKHEEQCAFIAhBs/AAQQAgARDmCwsCfyABKAIQIgItAABBO0YEQCACIRMgBwwBCyACKAIQIRMgBygCCCEDIAIoAgwLIgAoAgghCiAFLQDUAUECSQ0AIAUgASATELAJIAUgAUEsaiAAELAJCyAFKAIAIQ8gBEEANgLAASATKAIIIQAgAUF/NgIcIANFBEAMBgsgCC0AGEEGcQ0FIA8oAhQiCUEAIAlBAEobIQdBACECA0ACQAJAIAIgB0YEQCAHIQIMAQsgDygCECIGIAJBBHRqKAIAIAMQbQ0BIAYgAkEEdGooAgwhEQsgAiAJRwRAIAMhCwwICyADIQtBq4QBIAMQbQ0HIA8oAhAiAigCACELIAIoAgwhEQwHCyACQQFqIQIMAAsACyABKAIQEKULIgNFDQAgAy0AACICQaoBRyACQTtHcQ0AQQIhAiAAIAMQ5AtBAkYNBSADLQAAQaoBRw0AIAEgAS0AADoAAiABQa8BOgAAQQAhAgwFCyAFKAIALQBXDQIgASgCDBD2CiECAkACfyABLQAAQTBGBEAgASgCFCIAKAIIEPYKIgMgAkcNAiAAQRhqDAELIAFBEGoLIgMoAgAQ9gohAwsgAiADRg0CIAVBqLEBQQAQsgIgBSgCACABEFcMAgsgAS0ABUEQcUUNASAIKAIQIQICQCAILQAYQS5xBEAgBSAIQYHQACABIAEQ5gsMAQsgACABKAIUELEJGgsgCCgCECACRwRAIAEgASgCBEHAAHI2AgQgASgCFCICIAIoAgRBgICAgAJyNgIECyAIIAgoAhhBwAByNgIYDAELQQAhAiABKAIUIgYEQCAGKAIAIQILIAUoAgAiBy0AVCEKIAEtAAdBAXEEQCABKAIsIgNBACADLQAQQaYBRxshAwsgCCgCGCEQIAhBGGohCQJAIAcgASgCCCINIAIgCkH/AXEiCkEAEOMDIgdFBEAgBSgCACANQX4gCkEAEOMDIgdBAEchAiAHRSEKDAELIAcoAhQhCgJAIActAAVBBHFFDQAgASABKAIEQYCAIHI2AgQgAkECRgRAIAYoAhghAiAEQoCAgICAgID4v383A8ABAkACQCACLQAAQZkBRgRAIAIoAggiAiAEQcABaiACEFpBARD2AhogBCsDwAEiFEQAAAAAAADwP2RFDQELIAFBfzYCHAwBCyABAn8gFEQAAAAAAACgQaIiFJlEAAAAAAAA4EFjBEAgFKoMAQtBgICAgHgLIgI2AhwgAkEATg0CCyAEIAE2AkAgBUGR1QIgBEFAaxCyAiAIIAgoAhRBAWo2AhQMAQsgAUGAgIAEQYCAgDwgBygCIC0AAEH1AEYbNgIcCwJAAkACQCAFQR9BACAHKAIgQQAQ+QgOAgIAAQsgBCABNgIwIAVB7NsBIARBMGoQsgIgCCAIKAIUQQFqNgIUCyABQfkAOgAAQQEhAgwECyAHKAIEIgJBgNAAcQRAIAEgASgCBEGAgMAAcjYCBAsgCSgCACELAkAgAkGAEHFFBEAgC0EqcUUNASAFIAhBlMgAQQAgARDmCyAHKAIEIQIMAQsgASALQS5xOgACIAtBgIAQcUUNACABIAEoAgRBgICAgARyNgIECyAKQQBHIQsCQCACQYCAEHFFDQAgBS0AEg0AIAUoAgAtABhBIHENAEEAIQdBASEKQQAhAgwBCwJAIAJBgICgAXFFBEBBASEKDAELQQEhCiAFLQDUAUEBSw0AIAUgASAHELMLC0EBIQILAkACQAJAAkAgBS0A1AFBAU0EQAJAIAdFDQBBACENIAcoAhggA0VyDQBBlf0AIQIMAgsCQCALRQ0AIAkoAgAiDEEBcUVBACAHKAIEQYCABHEiDSADG3JBASADRSAMQYCAAXFyG0UNACAEIAE2AgQgBEEAIgJB8CpBrZcBIAMgDXIbajYCACAFQf/6AiAEELICIAggCCgCFEEBajYCFEEAIQoMBQsCQAJAIAINACAFKAIALQCxAQ0AQQAhAiAFLQDTASINQQBHIApxDQFBm/sCQdbbASANGyECDAMLQQAhAiAKDQBBm/sCIQIMAgsgCw0CIAEtAAdBAXEEQCAEIAE2AhAgBUGN/AIgBEEQahCyAiAIIAgoAhRBAWo2AhRBACEKDAULQQAhCiABKAIMRQ0EIAUgARCCCyAIIAgoAhRBAWo2AhQMBAsgAS0AB0EBcQ0CIAEoAgwNAiALIQoMAwsgBCABNgIgIAUgAiAEQSBqELICIAggCCgCFEEBajYCFEEAIQogC0UNAgsgCSAJKAIAIANFQf//fnNxNgIAC0EBIQoLIAAgBhCzCRpBASECIApFDQIgASgCDCIGBEAgACAGKAIUELMJGgsCQAJ/IAMEQCAIKAIgIQogBS0A1AFBAU0EQCAKBH8gCigCSAVBAAshBgJAAkACQCADKAIAIgtFDQAgAy0AEA0AIAUgBiALEKILIgtFDQIgAyAFKAIAIAsoAghBABCQCTYCCCADIAUoAgAgCygCDEEAEJAJNgIMIAMgBSgCACALKAIYQQAQpAk2AhggAyAFKAIAIAsoAhxBABCkCTYCHCADIAstABE6ABEgAyALLQASOgASIAMgCy0AECIGOgAQIAMgCy0AFDoAFAwBCyAFIAMgBhCCCSADLQAQIQYLAkACQCAGQf8BcUHZAEcNACADKAIYRQRAIAMoAhxFDQELIAMoAgwiBgRAIAYoAgBBAUYNAQsgBUGmgAFBABCyAgwBCyAHLQAGQQFxRQ0AIAMoAihFBEAgBSgCACENIAcoAiAhC0EAIQYDQCAGQQhGDQIgBkEEdEGgjQZqKAIAIAtGBEAgDSADKAIYEDMgDSADKAIcEDMgA0EAOgAUIAMgBkEEdEGgjQZqIgYoAgw6ABIgAyAGLQAIIgs6ABEgAyAGKAIEOgAQIANCADcCGCALQdYARw0DIAMgDUGbAUG3zwIQyAk2AhgMAwUgBkEBaiEGDAELAAsACyAFQdXHAEEAELICCyADIAc2AiwLIAUoAgAtAFcNBAsgACADKAIIELMJGiAAIAMoAgwQswkaIAAgAygCKBCyCRogCiADEN0LIAkoAgAhAyAJIQZBgIACDAELIAFBADoAAiABQagBOgAAIAEiH0EHaiILLQAAQQFxBEAgACABKAIsKAIoELIJGgsgBCIaQfABaiEAIAQiIEHQAWohDQNAIAhFDQIgCCgCBCEGIARByAFqIgpCADcDACAgQgA3A9ABIARCADcDwAEgGkIANwP4ASAaQgA3A/ABIARBASIDQeEAajYCyAEgBEHjADYCzAEgBEHkADYCxAEgBCAEQegBajYC2AEgBSgCACEDIAQgBjYC7AEgBCADNgLoASAEQcABaiABKAIUELMJGiABKAIMIgMEQCAEQcABaiADKAIUELMJGgsgHy0AB0EBcQRAIARBwAFqIAEoAiwoAigQsgkaCyAEKAL4ASIDBEAgBSgCACADEDgLIAQvAdQBIgNFIANBAXFyRQRAIAEgCC0AHCABLQACakEBajoAAiAIKAIMIQgMAQsLIAdFDQEgASABLQACIAgtABxqOgACIAhBGGohBiAHKAIEQYCggMAAcUGQgIDAAHMhAyAIKAIYCyEAIAYgACADcjYCAAsgCSAJKAIAIBBBgYABcXI2AgAMAgsgBSgCJEEAR0EBdCECDAELIAUiIUH8AGohGyABQSxqIRxBpwEhFSAIIQ4CQAJAAkACQANAAkAgDigCBCIdRQRAQQAhBgwBCyAdQQhqIQlBACEGQQAhFwNAAkACQAJAAkAgHSgCACAXSgRAIAkoAhAhEiAJIhhBJmotAABBIHFFDQEgCSgCFCgCHCEDQQAhEEEAIQIDQAJAIAMoAgAgAkoEQCAEQQA2AugBIAMgAkEEdGoiB0EIaiAAIAogCyAEQegBahDqC0UNAQJAIAQoAugBRQRAAkAgBkEATA0AAkAgGC0AJkEEcQRAIAkoAiwgABDrC0EATg0BCyAPIAQoAsABEK4DIARBADYCwAEMAQsgCS0AJCIZQRBxRQ0EIBlBCHFFBEAgDyAEKALAARCuA0EAIQYgBEEANgLAAQwBCyAFIARBwAFqIAwgAS4BIBDsCwtBASEQIAZBAWohBgwBCyAGQQBKDQILIAEgAjsBICAHIiJBEWoiByAiLwARIgdBwAByOwAAIA1BAWohDSAJIQwgB0GAAXFFDQELIApFDQYgEEUNBAwGCyACQQFqIQIMAAsACyAMRQRAQQAhDAwGCyABIAwoAig2AhwgASAMKAIQIgI2AiwgDC0AJEHIAHEEQCABIAEoAgRBgICAAXI2AgQLIAIoAjwhEQwFCyAKRQ0BCwJAIAtFDQAgEigCPCARRw0CIBENACALQeDaAhDmFQ0CCyAJKAIMIgIEQCAKIAIQbQ0CIAUtANQBQQJJDQEgBUEAIBwQsAkMAQsgCiASKAIAEG1FDQAgEigCFEEBRw0BIAogEiAREO0LRQ0BCyAAEI8JIRBBACEDIBIuASIiAkEAIAJBAEobIQcgEigCBCECAkADQCADIAdGDQECQAJAIAItAAcgEEcNACACKAIAIAAQbQ0AAkAgBkEATA0AAkAgGC0AJkEEcQRAIAkoAiwgABDrC0EATg0BCyAPIAQoAsABEK4DIARBADYCwAEMAQsgCS0AJCIZQRBxRQ0BIBlBCHFFBEAgDyAEKALAARCuA0EAIQYgBEEANgLAAQwBCyAFIARBwAFqIAwgAS4BIBDsCwsgAUF/IAMgAyASLgEgRhs7ASAgBkEBaiEGIBgtACZBIHFFDQEgCSADEO4LDAELIAJBDGohAiADQQFqIQMMAQsLIAkhDAsgBg0AIAwgCSASKAIcQYAEcSICGyEMIAJBCXZBAXMgDWohDUEAIQYLIAlBQGshCSAXQQFqIRcMAAsACwJAIAYgC3INAEEAIQkCQCAhKAJ8IgJFDQAgBS0AlgEhAwJAIAUtAJcBBEAgDi0AGUEEcUUNAgJAIApFDQAgCiACKAIAEG1FDQAgCiACQQAQ7QtFDQMLIANB/wFxQYABRyEJDAELAkAgCkUgA0H/AXFBgAFGcg0AQf4qIAoQbQ0AQQEhCQwBCyAKRSADQf8BcUH/AEZyDQFB8aoBIAoQbQ0BCyABIAk2AhwgAiEJCwJAIApFDQAgDigCGEGABHFFDQAgDigCCCICRQ0AQeq3ASAKEG0NACACKAIgKAIYIQkgAUECNgIcCyAJRQRAQQAhBgwBCyAAEI8JIQZBACEDIAkuASIiEEEAIBBBAEobIQcgDUEBaiENIAkoAgQhAiAJKAI8IRECQAJAA0AgAyAHRg0BAkAgBiACLQAHRgRAIAIoAgAgABBtRQ0BCyACQQxqIQIgA0EBaiEDDAELC0F/IAMgAyAJLgEgRhsiByAQSA0BCyAAEIwERQ0AIAdBfyAJLQAdQQJxGyEHC0EAIQYgByAQTg0AAn8CQCABKAIcIgJBAkYEQCAFLQDUAUECTwRAIAEgCTYCLCABIAc7ASBBASEGQacBDAMLIAEgDigCCCgCJCAJIAfBEO4KajYCHEEBIQYMAQsgHCAJNgIAIAUtAJcBBEAgASAHOwEgIAFBpwE6AAJBASEGIAEgDigCCCAJIAfBEO4KaiAJLgEiQQFqIAJsakEBajYCHAwBCyABIAc7ASACQCAHQQBIBEAgAUHEADoAAQwBC0F/QQEgB3QgB0EfSxshAyACRQRAIAUgBSgCjAEgA3I2AowBDAELIAUgBSgCkAEgA3I2ApABC0EBIQZBzQAMAQtBsAELIRVBACEMCwJAIAxFIAYgDUEATHJyRQRAIA4oAhgiCUEocQ0BIAAQjARFDQFBACAMKAIQLQAdQQJxIAwvACUiAkGAwABxGw0BIAJBgMAAcUUEQCABQf//AzsBIAsgAUHEADoAASANIQYMAwsgBg0CIA4oAhghCQsCQCAKIAlBgAFxRXINAEEAIQIgDigCCCIGKAIAIgNBACADQQBKGyEHA0AgAiAHRg0BAkAgBiACQQR0aiIDLQARQQNxDQAgAygCDCIDIAAQbA0AIAYgAkEEdGooAggiBygCBCIAQRBxRSAJQQFxckUEQCAEIAM2ArABIAVB1toAIARBsAFqELICQQIhAgwJCyAAQYCAAnFFIAlBgIABcUEAIAggDkYbckUEQCAEIAM2AqABIAVB2NgAIARBoAFqELICQQIhAgwJCyAHEPYKQQFHBEAgBUGosQFBABCyAkECIQIMCQsgBSAGIAIgASAWEO8LIAUtANQBQQJJDQcgBUEAIAEQsAkMBwsgAkEBaiECDAALAAsgFkEBaiEWIA4oAgwiDg0ACwJAIAoEQEEBIQIMAQsCQCABLQAEQYABcUUNAAJAIA8tALEBDQAgDykDICEeQR4hAiAILQAaQQFxBEBBHSECIB5CgYCAgAWDQoGAgIAEUQ0BCyAepyACdkEBcUUNAQsgBCAANgKQAUEcQcKSAyAEQZABahBqIAFCADcCLCABQfUAOgAAQQEhAgwGC0EBIQIgARDJCQ0FC0EAIQ5BACEGDAELQQEhA0EAIQIgBkEBRg0BCwJAAkAgBCgCwAEiAwRAIAMoAgAgBkEBa0YEQCABKAIEIgJBgICABHFFDQIgASACQf///3txNgIEDAMLIA8gAxCPAwtBl4IBQYqfASACGyEDAkAgCwRAIAQgADYCjAEgBCAKNgKIASAEIAs2AoQBIAQgAzYCgAEgBUHD0wAgBEGAAWoQsgIMAQsgCgRAIAQgADYCeCAEIAo2AnQgBCADNgJwIAVB+NUAIARB8ABqELICDAELAkAgAkUNACATLQAEQYABcUUNACAEIAA2AmQgBCADNgJgIAVBhKYCIARB4ABqELICDAELIAQgADYCVCAEIAM2AlAgBUHj4wAgBEHQAGoQsgILIAUoAgAgARBXIAVBAToAESAIIAgoAhRBAWo2AhRB+QAhFSAGIQMMAgsgDyABKAIMEDMgAUEANgIMIA8gASgCEBAzIAFBADYCEAsgBSAEQcABaiAMIAEuASAQ7AsgAUGDqQE2AgggAUGsAToAACABIAQoAsABNgIUDAELIAEtAAZBgQFxRQRAIA8gASgCDBAzIAFBADYCDCAPIAEoAhAQMyABQQA2AhAgASABKAIEQYCAgARyNgIECwJAIAxFDQAgAS4BIEEATgRAIAwgDCkDMCABEPALhDcDMAwBCyAMQSVqIgIgDC8AJUGAgAFyOwAACyABIBU6AABBAiECIANBAUcNAQsCQCAFKAIAIgIoAuwCRQ0AIAEtAAAiAEGnAUcgAEHNAEdxDQAgDigCBCEDIAIgERD8AiIHQQBIDQAgAEHNAEcEQEEAIQIgAygCACIAQQAgAEEAShshAAN/IAAgAkYNAiABKAIcIAMgAkEGdGooAjBGBH8gAyACQQZ0akEYagUgAkEBaiECDAELCyEbCyAbKAIAIgJFDQAgBSACKAIAAn8gAS4BICIDQQBIBEBBACEAQciVAiACLgEgIgNBAEgNARogA0H//wNxIQMLIAIoAgQgA0EMbGooAgALIgMgBxDxC0ECRw0AIAFB+QA6AAALA0BBASECIAggCCgCEEEBajYCECAIIA5GDQEgCCgCDCEIDAALAAsgBEGAAmokACACC5oOFQF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQTBrIgMkAEEBIQgCQCABKAIEIgJBBHENACAAKAIAIQYgACgCGCEFIAJBwABxRQRAIAYgASAFEJEKQQJBASAGKAIkGyEIDAELIAEoAjQhDyAGKAIAIRAgA0EIakEEciIJIhJBGGohDSAJIhNBEGohESAJIRQgASECA0AgAgRAIAIgAigCBEEEcjYCBCASQQA2AhggE0IANwIQIBRCADcCCCAJQgA3AgAgAyACNgIoIAMgBjYCCEECIQggA0EIaiACKAI8EN8KDQIgAiIVQQZqLQAAQQFxBEAgAigCICgCHCACKAIwNgIwIAJBADYCMAsgBQRAIAUgBSgCHEEBajYCHAtBACEAA0AgAigCICIEKAIAIABKBEACQCAEIABBBnRqIgooAhwiBEUNACAELQAEQQRxDQAgBQR/IAUoAhAFQQALIQsgBigC/AEhByAKKAIQIgwEQCAGIAw2AvwBCyAGIAQgBRDyCyAGIAc2AvwBIAYoAiQNBSAFRQ0AIApBLWoiBCAKLwAtQff/A3EgBSgCECALSkEDdHI7AAALIABBAWohAAwBCwsCQCAFRQ0AIAUoAhwiAEUNACAFIABBAWs2AhwLIAMgBTYCFCADIAQ2AgwgA0GBgAE2AiAgA0EIaiACKAIcEP4KDQICfyACKAIoIgcgAygCICIAQRBxcgRAIAIgAigCBCAAQYCggMAAcXJBCHI2AgQgAEH//35xDAELIABB/v9+cQshACACKAIcIQQgAyAAQYABciIANgIgIAMgBDYCECACKAIsIgQEQCACLQAEQQhxRQRAIAZB1SVBABCyAgwECyADQQhqIAQQ3woNAyADKAIgIQALIAMgAEGAgMAAcjYCICADQQhqIAIoAiQQ3woNAiADIAMoAiBB//+/f3E2AiBBACEAA0AgAigCICIEKAIAIABKBEAgBCAAQQZ0aiIELQAtQQRxBEAgA0EIaiAEQUBrKAIAEP4KDQULIABBAWohAAwBCwsCQCAGLQDUAUECSQ0AIAJByABqIQQDQCAEKAIAIgBFDQEgA0EIaiAAKAIMEP4KDQQgAEEkaiEEIANBCGogACgCCBD+CkUNAAsMAwsgA0EANgIUIAMgAygCIEGBgAFyNgIgIBUtAAZBAXEEQCACIAIoAiAoAhwiACgCMDYCMCAAQQA2AjALIAIoAjAiAEUgDkUgD0EAR3FyRQRAIANBCGogAiAAQa/mARDzCw0DCyAQLQBXDQIgAyADKAIgQf//fnE2AiACQCAHRQ0AIANBCGogAiAHQZjrARDzCw0DIBAtAFcNA0EAIQAgBygCACIEQQAgBEEAShshCiAHQQhqIQQDQCAAIApGDQEgBCgCAC0ABEEQcQRAIAZB7JgBQQAQsgIMBQUgBEEQaiEEIABBAWohAAwBCwALAAsCQCACKAI4IgBFDQAgAigCHCgCACAAKAIcKAIARg0AIAYgABDnCQwDCyAOQQFqIQ4gAigCNCECDAELC0EBIQggD0UNACABKAIwIgdFDQACQCAHKAIAIgAgBigCACIJKAKAAUwEQEEAIQIgAEEAIABBAEobIQVBACEAA0AgACAFRkUEQCAHIABBBHRqIhZBEWoiBCAWLwARQfv/A3E7AAAgAEEBaiEADAELCwNAIAEiDCACNgI4IAEiAigCNCIBDQALIAdBCGohEUEBIQoDQCAMQQAgChtFBEBBACEAIAcoAgAiAkEAIAJBAEobIQRBASEIA0AgACAERg0FIABBBHQhAiAAQQFqIgUhACACIAdqLQARQQRxDQALIAMgBTYCACAGQZc6IAMQsgIMAwsgDCgCHCENQQAhACARIQJBACEEA0AgACEKAn8CQCAHKAIAIARKBEAgA0F/NgIsIAItAAlBBHENASACKAIAEKULIgtFDQECQCALIANBLGoQyQoEQCADKAIsIgFBAEogASANKAIAIgBMcQ0BIAZBr+YBIARBAWogACALEPQLDAgLIA0gCxD1CyIBRQRAQQAhASAJIAtBABCkCSEAAkAgCS0AVw0AIAYgDCAAEPYLIQEgBi0A1AFBAkkgAUEATHINACAGIAwgCxD2CxoLIAkgABAzC0EBIgAgAUEATA0DGgsgBi0A1AFBAU0EQCAJQZsBQQAQyAkiCEUNByAIIAE2AgggCCAIKAIEQYAQcjYCBCACIQUgCyACKAIAIgBHBEADQCAAIgUoAgwiAC0AAEHxAEYNAAsgBUEMaiEFCyAFIAg2AgAgCSALEKAIIAIgATsBDAsgAiACLwAJQQRyOwAJDAELIAwoAjghDAwDCyAKCyEAIAJBEGohAiAEQQFqIQQMAAsACwALIAZBypgBQQAQsgILQQIhCAsgA0EwaiQAIAgLcAEBfyMAQRBrIgUkACAFAn9BsMgAIAEoAhgiAUEgcQ0AGkGyPiABQQRxDQAaQb/JAEHNzAAgAUEIcRsLIgE2AgQgBSACNgIAIABB1tkAIAUQsgIgAwRAIANB+QA6AAALIAAoAgAgBBBXIAVBEGokAAucAQUBfgF/AX4BfwF/AkAgASgCICIBKAIAIgZFDQAgACgCGCIDIAMpAwgiBCAGrHwiAjcDCCADKAIAIAMoAhAgAkIChhBhIgBFBEAgA0IANwMIQQIhBQwBCyADIAA2AhBCACECA0AgAiABNAIAWQ0BIAAgBKdBAnRqIAEgAqdBBnRqKAIwNgIAIARCAXwhBCACQgF8IQIMAAsACyAFCyUBAX4gACgCGCIAKQMIIgJQRQRAIAAgAiABKAIgNAIAfTcDCAsLywEIAX8BfwF+AX4BfwF/AX8BfwJAAkAgAS0AAEGnAWsOAwABAAELIAAoAhgiBigCBCIHBEAgBygCACEDCyADQQAgA0EAShshCQNAAkAgAiAJRgRAIAYpAwgiBUIAIAVCAFUbIQVBAiEIA0AgBCAFUQ0CIASnIQIgBEIBfCEEIAYoAhAgAkECdGooAgAgASgCHEcNAAsMAwtBASEIIAJBBnQhAyACQQFqIQIgASgCHCADIAdqKAIwRw0BCwsgACAALwEUIAhyOwEUC0EAC/8BBAF/AX8BfwF/AkAgAC8ACUEDcSIHQQJHBEAgBEUgB0EDR3INAQsgACgCBCEGQQAhAANAIAAgBmoiCC0AACIFRSAFQS5GckUEQCAAQQFqIQAMAQsLIAMEQEEAIQUgBiADIAAQbg0BIAAgA2otAAANAQsgCEEBaiEGQQAhAANAIAAgBmoiCC0AACIFRSAFQS5GckUEQCAAQQFqIQAMAQsLIAIEQEEAIQUgBiACIAAQbg0BIAAgAmotAAANAQtBASEFAkAgAQRAAkACQCAHQQJrDgIAAQQLIAhBAWogARBtRQ8LIAEQjAQNAUEADwsgB0EDRw0BCyAEQQE2AgALIAULSAIBfwF/IAAoAgAiA0EAIANBAEobIQMDQAJAIAIgA0YEQEF/IQIMAQsgACACQQN0aigCCCABEG1FDQAgAkEBaiECDAELCyACC1oCAX8BfyAAKAIAQacBQQBBABCgCSIEBEAgAigCKCEFIAQgAzsBICAEIAU2AhwgBCACKAIQNgIsIAQgBCgCBEGAgIABcjYCBCABIAAgASgCACAEEMIJNgIACwttAAJAIABB8cMBQQcQbg0AIABBB2ohAAJAIAEoAgBBB2pB0fIAEOYVRQRAQQEhASAAQf/CARBtRQ0BIAJFDQIgAEHk8gAQbUUNASAAQZLDARBtRQ0BDAILIABBksMBEG0NAUEBIQELQQEPC0EACzABAX8gAC0AJkEgcQRAIAAoAhQoAhwgAUEEdGoiAkERaiIAIAIvABFBwAByOwAACwvlAQIBfwF/IwBBQGoiBSQAAkAgAygCKA0AIAAoAgAiBiABIAJBBHRqKAIIQQAQpAkhAiAGLQBXBEAgBiACEDMMAQsgBEEASgRAIAVCADcDGCAFQgA3AxAgBUIANwMIIAUgBDYCICAFQeUANgIMIAVBCGogAhCyCRoLIAMtAABB8QBGBEAgACACIAMoAggQ+AshAgsgBUEIaiACQTQQ5RQaIAIgA0E0EOUUIQICQCADIAVBCGpBNBDlFCIDLQAHQQFxRQ0AIAMoAiwiAUUNACABIAM2AkgLIAAgAhCDCxoLIAVBQGskAAtaAgF/AX4gAC4BICEBAkAgACgCLCIALQAcQeAAcUUNACAAKAIEIAFBDGxqLQAKQeAAcUUNAEJ/Qn8gADIBIiIChkJ/hSACQj9VGw8LQgFBPyABIAFBP04brYYL0wEEAX8BfwF/AX8jAEEwayIEJAACQCAAKAIAIgYtALEBDQAgBigC8AJBFCABIAIgBigCECADQQR0aigCACIHIAAoAvwBIAYoAuwCEQkAIgVBAUYEQCAEIAI2AiQgBCABNgIgQenWACAEQSBqEGchBQJAIANFBEAgBigCFEEDSA0BCyAEIAU2AhQgBCAHNgIQQYAkIARBEGoQZyEFCyAEIAU2AgAgAEHCsAEgBBCyAiAAQRc2AgxBASEFDAELIAVBfXFFDQAgABDhCwsgBEEwaiQAIAULRgEBfyMAQSBrIgMkACADQQA2AgwgAyACNgIYIAMgADYCACADQQEiAkHaAGo2AgggA0HaADYCBCADIAEQsQkaIANBIGokAAvqAggBfwF/AX8BfwF/AX8BfwF/IwBBMGsiBCQAIAJBCGohByAAKAIAIQogASgCHCgCACELAn8DQCACKAIAIAhKBEACQCAHKAIAIgkQpQsiBUUNAAJAIAMtAABBxwBHBEAgBCABKAIcIAUQ9QsiBjYCDCAGQQBKDQELIAUgBEEMahDJCgRAIAQoAgwiBkGAgARrQYCAfEsNASAKIAMgCEEBaiALIAUQ9AtBAQwFC0EAIQUgB0EAOwEMQQEgACAJEN8KDQQaA0AgBSABKAIcIgYoAgBODQJBACAJIAYgBUEEdGooAghBfxD4CkUEQCABKAJEBEAgBEIANwMgIARCADcDGCAEQgA3AxAgBCABNgIoIARB5gA2AhQgBEEQaiAJELIJGgsgByAFQQFqOwEMCyAFQQFqIQUMAAsACyAHIAY7AQwLIAdBEGohByAIQQFqIQgMAQsLIAogASACIAMQzwoLIQYgBEEwaiQAIAYLPQEBfyMAQRBrIgUkACAFIAM2AgggBSABNgIEIAUgAjYCACAAQZG+ASAFELICIAAoAgAgBBBXIAVBEGokAAtyBAF/AX8BfwF/AkAgAS0AAEE7Rw0AIAAoAgAiA0EAIANBAEobIQQgASgCCCEFQQAhAQNAIAEgBEYNAQJAIAAgAUEEdGoiAy0AEUEDcQ0AIAMoAgwgBRBsDQAgAUEBaiECDAILIAFBAWohAQwACwALIAILyAEDAX8BfwF/IwBBMGsiAyQAIAEoAhwhBSADQgA3AiQgA0IANwIcIANCADcCFCADIAA2AgggASgCICEBIANBgYEgNgIgIAMgBTYCECADIAE2AgwgACgCACIBLQBbIQAgAUEBOgBbIANBCGogAhDfCiEEIAEgADoAW0EAIQECQAJAIAQNAANAIAEgBSgCAE4NASABQQR0IQAgAUEBaiIEIQFBACAAIAVqKAIIIAJBfxD4CkEBSg0ACwwBC0EAIQQLIANBMGokACAECyAAIAEtAABBqAFGBEAgASABLQACIAAtABhqOgACC0EACzYBAX8jAEEQayIDJAAgAyACNgIIIAMgAhBaNgIMIAAgASADQQhqQQAQ0gkhAiADQRBqJAAgAgsEAEEAC94CBQF/AX8BfwF/AX8jAEEQayIFJAACQCABKAI0RQ0AIAEoAjAiBEUNACABIQIDQCACRQ0BAkACQCACLQAAQYcBaw4EAAEBAAELIAIoAjQhAgwBCwsgBC8BFA0AIARBCGohBiAEKAIAIQIDQCACQQBMDQEgBiACQQFrIgJBBHRqKAIALQAFQQJxRQ0AC0ECIQMgACgCACIAKAIAIgRCzAAQxQIiAkUNACAFQgA3AwggAEEAQQBBACAFQQhqIAJBABDbCSIGRQ0AIAIgAUHMABDlFCECIAEgBjYCICAEQbQBQQAQyAkhAyAAKAIAIAMQwQkhAyABQQA2AiQgAUGKAToAACABIAM2AhwgAkEANgIwIAJCADcCKCABQQA2AkggAUEANgJAIAFCADcCNCABIAEoAgRB//17cUGAgARyNgIEIAIoAjQgAjYCOCACQQA2AjxBACEDCyAFQRBqJAAgAwvpJCsBfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX8BfyMAQfABayIIJAAgACgCACIFKAIAIQ4gASABKAIEIhRBwAByNgIEQQIhBgJAIA4tAFcNAEEBIQYgFEHAAHENACAALwEUBEAgBSAFKAJsQQFqIgI2AmwgASACNgIQCyABKAJAIQIgASgCHCEVIAEoAiAhFgJAAkAgBSgCjAJFIBRBgICAAXFFckUEQCACRQRAIAEgDkIkEMUCIgI2AkBBAiEGIAJFDQQLIAJBATYCBAwBCyACRQ0BCyAFKAIkDQAgAiAFKAKMAjYCCCAFIAI2AowCCyAFIBYQmgogDiEiIBZBCGoiIyEEA0ACQAJAAkACQAJAAkACQAJAIBYoAgAgB0oEQCAEKAIQDQcgBCgCCCIGRQRAQQIhBiAAIAQoAhQQsQkNCyAEKAIUIQIgBCAFKAIAQsAAEMUCIgM2AhAgA0UNCyADQQE2AhggBSgCACEGIAMCfyAEKAIMIgkEQCAGIAkQoAEMAQsgCCAENgIAIAZBzeEBIAgQ/QILIgY2AgADQCACIgYoAjQiAg0ACyAFIAYoAhwgA0EiaiADQQRqEOILQQIhBiADQQI6ACsgA0H//wM7ASAgA0HIATsBJiADIAMoAhxBgIQBcjYCHCAFKAIkRQ0GDAsLAkAgBSgCjAIiDUUNACAFKAIkDQAgBCgCBA0AIAQtACZBAnENAANAIA1FDQFBACECIA0oAgAiA0EAIANBAEobIQkCQAJAA0AgAiAJRg0BIAJBGGwhAyACQQFqIQIgBiADIA1qIhAiGUEMaiISKAIAIgMQbQ0ACyAQIhxBGGooAgAiAkUNASAIIAM2AnAgBSACIAhB8ABqELICDAoLIA0oAgQNAiANKAIIIQ0MAQsLIAUoAgAhAkECIQYgBSAEEP4LDQsgAkLAABDFAiIKRQ0LIBAiJEEcaiIJKAIAIgNFBEAgJCACQhQQxQIiAzYCHAJAIAMEQCAFQcMAIAMQkAoNAQsgAiAKEDUMDQsgAyAQLQAgOgASCyAEIAo2AhAgCkEBNgIYIAIgGSgCDBCgASEJIApByAE7ASYgCkH//wM7ASAgCiAJNgIAIAogCigCHEGAhAFyNgIcIAQgAiAQKAIUQQAQpQkiCzYCFCACLQBXDQsgCyALKAIEQYCAgCByNgIEIAQvACUiAkECcQRAIAggBCgCODYCYCAFQYOXAyAIQeAAahCyAgwMCyAEIAM2AjwgBCACQYACcjsAJSADIAMoAgBBAWo2AgBBfyETIAstAAAiAiEDIAshEQJAIAJB/gFxQYYBRyIdDQADQCADQf8BcSACQf8BcUcNAUEAIQIgESgCICIMKAIAIgNBACADQQBKGyEJA0AgAiAJRwRAAkAgDCACQQZ0aiIDKAIMDQAgAygCECIPRQ0AIA8gGSgCDBBtDQAgAyAKNgIYIAogCigCGEEBajYCGCADQS1qIg8gAy8ALUHAAHI7AAAgESgCBCIPQYDAAHENByARIA9BgMAAcjYCBCATQQBIBEAgBSAFKAIoIhNBAWo2AigLIAMgEzYCMAsgAkEBaiECDAELCyARLQAFQSBxRQ0BIAstAAAhAiARKAI0IhEtAAAhAwwACwALIBxB9OsANgIYIAUoAowCIQkgBSANNgKMAgJAIAstAAVBIHEEQCARIAsoAkA2AkAgACARELEJIQIgEUEANgJAIAJFDQEMCwsgACALELEJDQoLIAUgDTYCjAIgCyECA0AgAiIDKAI0IgINAAsgAygCHCEDIBAoAhAiAkUEQCADIQIMBgsgA0UNBSADKAIAIgMgAigCACIMRg0FIBkoAgwhAiAIIAw2AkggCCADNgJEIAggAjYCQCAFQdHJACAIQUBrELICDAkLIAQgBUEAIAQQiAkiAjYCEEECIQYgAkUNCiACKAIYIgNB//8DTwRAIAggAigCADYCECAFQZ7CAiAIQRBqELICIARBADYCEAwLCyACIANBAWo2AhggAi0AK0EBRwRAIAUgBBD+Cw0LIAItACtFDQYLIAAtABQhAyAFIAIQmQkNCgJAAkACQCACLQArQQFrDgIBAAILAkAgIi0AI0GAAXENACACKAI8IA4oAhAoAhxGDQAgCCACKAIANgIgIAVB3bABIAhBIGoQsgILIAQgDiACKAIsQQAQpQk2AhQMAQsgBC0AJUGAAXFFDQAgAigCNCIGRQ0AIAYtABIgDigCIEEHdkEBcU0NACAIIAIoAgA2AjAgBUGwlgMgCEEwahCyAgsgAi8BIiEGIAJB//8DOwEiIABBATsBFCAAIAQoAhQQsQkaIAAgAzsBFCACIAY7ASIMBQtBAiEGIAUoAiQNCSABKAIgIgJByABqIQMgAkEIaiEKQQAhCQNAIAIoAgBBAWsgCUwEQCAVKAIAIgZBACAGQQBKGyEAQQAhAgNAIAAgAkcEQAJAIBUgAkEEdGooAggiBC0AACIHQY0BRwRAIAdBtAFHDQEMBwsgBCgCEC0AAEG0AUYNBgsgAkEBaiECIAQoAgQgF3IhFwwBCwsgASgCHCEDDAQLAkAgCigCEEUNACADKAIQIgxFDQACQAJAIAMtACQiDUEEcQRAIAMtACZBBHENASADKAIsDQFBACEHQQAhBANAIAQgDC4BIk5FBEACQCAMKAIEIARBDGxqIgYtAApBAnENACACQQAgCSAGKAIAIgBBAEEAQQEQ/wtFDQAgBSAHQQAQ0wkhBkEAIQcgBkUNACAFKAIAIAAQoAEhByAGKAIAQQN0IAZqIAc2AgAgBiEHCyAEQQFqIQQMAQsLIAcEQCADIAc2AiwgAyADLwAlQYAocjsAJQsgBSgCJA0KC0EBQQIgDUEgcRshEyADKAIsIRAgAy0AJkEEcUUNASAJQQFqIREgBSgCACENQQAhEgNAIBIgECgCAE4NAwJAIAwgECASQQN0aigCCCIEEJEJIg9BAE4EQCACQQAgCSAEIAhB7AFqIAhB6AFqIAMvACVBDHZBAXEQ/wsNAQsgCCAENgKAASAFQdXOACAIQYABahCyAgwLCyANIAIgCCgC7AEgCCgC6AEiBxCADCEGIAIgCCgC7AFBBnRqQQhqIAcQ7gtBACEHAkAgAi0ALEHAAHFFDQADQAJAIAIgCCgC7AFBAWogCSAEIAhB7AFqIAhB6AFqIAMvACVBDHZBAXEQ/wsEQCACIAgoAuwBQQZ0aiIALQAuQQRxBEAgACgCNCAEEOsLQQBODQILIAggBDYCkAEgBUHw/AIgCEGQAWoQsgILIAdFDQJBACEEIAUgBSAHIAYQwglBoI4GQQAQzAkhBgwCCyAFIAcgBhDCCSEHIA0gAiAIKALsASAIKALoASIAEIAMIQYgAiAIKALsAUEGdGpBCGogABDuCwwACwALIA0gAiARIA8QgAwhByADIA8Q7gsgBUE1IAYgBxChCSIEBEAgBCAEKAIEIBNyNgIEIAQgBygCHDYCJAsgASAFIAEoAiQgBBDOCTYCJCASQQFqIRIMAAsACyAIQQA2AqABIAVBuJkBIAhBoAFqELICDAgLIBBFDQAgECADKAIoIBMQ1gogASAFIAEoAiQgAygCLBDOCTYCJCADQQA2AiwgAyADLwAlQYAQcjsAJQsgCkFAayEKIANBQGshAyAJQQFqIQkMAAsACyAIIBkoAgw2AlAgBUGb6gAgCEHQAGoQsgIMCAsgFEGAEHEhECAVQQhqISUgBSgCACkDIELEAIMhJiABISdBACEDA0ACQCAGIBpKBEAgJSAaQQR0aiICKAIAIhgoAgQhKEEAIQxBACELIBgiBC0AACIGQbQBRwRAAkAgBkGNAUYEQCAYKAIQIgQtAABBtAFGDQELIAUgAyAYEMIJIgMEQCADKAIAQQR0IANqIgRBBGsgAigCBDYCACAEIilBAWoiBCApLwABQfz/A3EgAi8ACUEDcXI7AAAgAkEANgIECyACQQA2AgAMAwsgGCgCDCgCCCELCyAEKAIkIR4gIyEPQQAhCQNAAn8CQAJAAkAgCSAWKAIAIgJODQAgDygCECEGIA8oAgwiCkUEQCAGKAIAIQoLIA4tAFcNAAJ/IA8iH0Emai0AAEEgcQRAIA8oAhQoAhwhDUEADAELAkAgC0UNACALIAoQbUUNACAJQQFqDAULQQAhB0EAIQ1B4NoCIA4gBigCPBD8AiIEQQBIDQAaIA4oAhAgBEEEdGooAgALIRFBACEEIAlBAWoiKiACTg0BIA8tAGZBBHFFIBBFcg0BIA8oAmwhEkEAIQIDQCACIBIoAgBODQMCQCAOQTsgEiACQQN0aigCCCIAEMgJIgdFDQAgBy0ABEEDcQ0AIAcgHjYCJAsgBSADIAcQwgkiAwRAIAMoAgAhByAIIAA2AtABIAdBBHQgA2oiB0EEayAOQYHXACAIQdABahD9AjYCACAHIitBAWoiByArLwABQfz+A3FBggFyOwAACyACQQFqIQIMAAsACyAMDQUgCwRAIAggCzYC4AEgBUGJ6gAgCEHgAWoQsgIMBgsgBUH9tgFBABCyAgwFC0EAIRILIAYuASIgBi0AHUECcUUgEEEAR3FqIgJBACACQQBKGyEUIAtBAEcgDUEAR3EhHSAJQX9zISwgEEUgC0UgCUEAR3FxIRMDQAJAIAQgFEYNAEEAIQACQAJAIAYuASIgBEYEQANAIABBA0YNAyAAQQJ0QaiOBmohB0EAIQICQANAIAIgBEYNASAHKAIAIAYoAgQgAkEMbGooAgAQbARAIAJBAWohAgwBCwsgAEEBaiEAIAIgBEcNAQsLIAcoAgAhCQwBCyAGKAIEIARBDGxqIgIoAgAhCQJAIA1FDQAgDSAEQQR0aiIHLwARQQNxQQNGDQIgHUUNACAHQQhqQQAgC0EAQQAQ6gtFDQILICctAAZBAnFBASACLwEKIgJBAnEbRQ0BIAJBgAhxRSALcg0AIBBFDQELAkAgE0UNACAfLQAmQQRxRQ0AQQEhDCAPKAIsIAkQ6wtBAE4NAQsgDkE7IAkQyAkhDAJAAkAgFigCACICQQJOBEAgDy0AJEHAAHFFIBByDQEgAiAsaiEHIA8hAANAIAAhAiAHQQBMDQIgAkFAayEAIAdBAWshByACLQBmQQRxRQ0AIAIoAmwiAkUNACACIAkQ6wtBAEgNAAsLIAUtANQBQQJJDQELIAVBjQEgDkE7IAoQyAkiAiAMEKEJIQwCQCAFLQDUAUECSQ0AIBgoAgwiB0UNACAFIAIgBxCwCQsgEUUNACAFQY0BIA5BOyAREMgJIAwQoQkhDAsCQCAMRQ0AIAwtAARBA3ENACAMIB42AiQLIAUgAyAMEMIJIgNFBEBBASEMQQAhAwwCCyADKAIAQQFrIQICQAJAIBBFDQAgBS0A1AFBAUsNACADIAJBBHRqIgICfyANBEAgDiANIARBBHRqKAIMEKABDAELIAggCTYCyAEgCCAKNgLEASAIIBE2AsABIA5Bx9MAIAhBwAFqEP0CCyIHNgIMIAIiIEERaiICICAvABFBfHFBA0ECIAQgBi4BIkYbciIHOwAAAkAgHy0AJkEEcQRAIA8oAiwgCRDrC0EATg0BCyASBEAgEiAJEOsLQQBODQELQQEhDCAEIAYuASJODQMgBigCBCAEQQxsai0AC0EEcUUNAwsgICAHQYACcjsAEQwBCyADIAJBBHRqIgciG0ERaiECIAciIUEMaiEHICZCBFEEQCAIIAk2ArQBIAggCjYCsAEgISAOQenWACAIQbABahD9AjYCDCAbIBsvABFB/P8DcTsAEQwBCyAhIA4gCRCgATYCDCAbIBsvABFB/P8DcTsAEQtBASEMCyAEQQFqIQQMAQsLICoLIQkgD0FAayEPDAALAAsgDiAVEI8DIAEgAzYCHAwCCyAXIChyIRcgGkEBaiEaIBUoAgAhBgwACwALQQAhBiADRQ0GIAMoAgAgDigCgAFKBEAgBUH4OUEAELICDAMLIBdBiICAAnFFDQYgASABKAIEQYCAEHI2AgQMBgsgBSACIApBImogCkEEahDiCyAdRQRAIBxB6uEAQZngACALKAIEIgJBgMAAcRs2AhggACALELEJGgsgHEEANgIYIAUgCTYCjAILIAQtACVBAnFFDQEgBSAEEIEMRQ0BC0ECIQYMAwsgBEFAayEEIAdBAWohBwwBCwsgBSAJNgKMAgsgCEHwAWokACAGC4QBBAF/AX8BfwF/AkAgASgCBCICQYABcQ0AIAEgAkGAAXI2AgQgASgCICIDQQhqIQEgACgCACEEQQAhAANAIAAgAygCAE4NAQJAIAEoAhAiAi0AHUHAAHFFDQAgASgCFCIFRQ0AIAQgAiAFQcAAEOMLCyABQUBrIQEgAEEBaiEADAALAAsLFwAgAS0AB0EBcQRAIAEoAiwQowgLQQALPAIBfwF/IwBBEGsiAiQAIAEtACVBBHEEQCACIAEoAgg2AgAgAEHA/QAgAhCyAkEBIQMLIAJBEGokACADC30DAX8BfwF/A0ACQAJAIAEgAkoNACAAIAFBBnRqKAIYIgkgAxCRCSIHQQBIDQEgBgRAIAkoAgQgB0EMbGotAApBAnENAgtBASEIIARFDQAgACABQQZ0akEIaiAHEO4LIAQgATYCACAFIAc2AgALIAgPCyABQQFqIQEMAAsAC8YBBAF/AX8BfgF/IABBpwFBAEEAEKAJIgAEQCAAIAEgAkEGdGoiBSgCGCIENgIsIAAgBSgCMDYCHCADIAQuASBGBEAgAEH//wM7ASAgAA8LIAAgAzsBIAJAIAQtABxB4ABxRQ0AIAQoAgQgA0EMbGotAApB4ABxRQ0AIAEgAkEGdGpCf0J/IAQyASIiBoZCf4UgBkI/VRs3AzggAA8LIAEgAkEGdGoiB0E4aiICIAcpAzhCAUE/IAMgA0E/ThuthoQ3AwALIAALggEDAX8BfwF/IwBBEGsiAyQAIAEoAhBBCGohAiABKAI4IQQCfwJAA0AgAigCACICBEAgAigCACAEEG1FDQIgAkEUaiECDAELCyADQQA2AgQgAyAENgIAIABB6eAAIAMQsgIgAEEBOgARQQEMAQsgASACNgI8QQALIQIgA0EQaiQAIAILpgUKAX8BfwF/AX8BfwF/AX8BfwF/AX8jAEEwayIEJAAgACgCACECAkAgAS0AK0EBRgRAIAIgAigCOEEBajYCOAJAIAIgARC6Bw0AIAJBhANqIAEoAjAoAgAQhQMiA0UEQCAEIAEoAjAoAgA2AgAgAEGj6QAgBBCyAkEBIQMMAQsgBEEANgIsIAIgASADIAMoAgAoAgggBEEsahCJAyEDIAQoAiwhASADBEAgBCABNgIQIABBs+4AIARBEGoQsgIgACADNgIMCyACIAEQMgsgAiACKAI4QQFrNgI4DAELIAEuASJBAEgEQCAEIAEoAgA2AiAgAEHIswEgBEEgahCyAkEBIQMMAQsCQCACIAEoAixBABClCSIGRQRAQQEhAwwBCyAALQDUASEIIABBADoA1AEgACgCKCEJIAAoAmwhCiAAIAYoAiAQmgogAUEiaiIHQf//AzsBACACQQA7AbQCIAIoAuwCIQsgAkEANgLsAkEBIQMgAiACKAKwAkEBajYCsAIgACAGQcAAEPwJIQUgAiALNgLsAiAAIAo2AmwgACAJNgIoAkAgBUUEQCAHQQA7AQAMAQsgASgCECIDBEAgACADIAcgAUEEahDiC0EAIQMgACgCJA0BIAYoAhwoAgAgBy4BAEcNASAAIAEgBkHAABDjCwwBCyABIAUvASI7ASIgASAFKAIENgIEIAEgASgCHCAFKAIcQeIAcXI2AhxBACEDIAVBADYCBCAFQQA7ASILIAEgAS8BIjsBJCACIAUQKyACIAYQnwggAiACKAKwAkEBayIFNgKwAkEAIQYgBUUEQCACLwG2AiEGCyACIAY7AbQCIAAgCDoA1AELIAEoAjwiACAALwFOQQJyOwFOIAItAFdFDQAgAiABEOgICyAEQTBqJAAgAwuwAgQBfwF/AX8BfwNAAkACQCAAIgFFBEBBACEADAELAkACQAJAAkACQAJAAkAgAS0AACICQZoBaw4aAwYFAgYGBgYGBgYGBgEFAQYGBQgGBgYBAQgAC0ECIQACQCACQe8Aaw4HBAYIBgYGBwALQQAhACACQfkARg0IIAJBJEYNACACQYoBRw0FC0EFQQZBByABEOQJIgFBwgBGGyABQcIAShshAAwFCyABKAIUIQJBASEBQQAhAANAIAEgAigCACIETkUEQCACIAFBBHRqKAIIEIMMIAByIQAgAUECaiEBDAELCyAEQQFxRQ0EIAAgA3IhAyAEQQR0IAJqQQhrKAIAIQAMBgtBBCEADAMLQQYhAAwCC0EHIQAMAQtBASEACyAAIANyDwsgASgCDCEADAALAAvjAgcBfwF/AX8BfwF/AX8BfyMAQTBrIgQkAAJAIAEtAAAiAkGKAUcEQCACQacBRw0BIAEuASAhBQNAQQAhAgJAA0AgAEUgAnINAUEAIQIgACgCBCIIKAIAIgNBACADQQBKGyEDAkADQCACIANGDQEgCCACQQZ0aiIHKAIwIAEoAhxHBEAgAkEBaiECDAELCyAHKAIcIQYgBygCGCECDAELCyAAKAIMIQAMAQsLQQAhAyACRQ0BIAYEQCAGKAIcIgIoAgAgBUwNAiACIAVBBHRqKAIIIQIgBCAGKAIgNgIMIAQgADYCFCAEIAAoAgA2AgggBEEIaiACEIQMIQMMAgsgBUEASARAQYvmASEDDAILIAIoAgQgBUEMbGpBABCNBCEDDAELIAEoAhQiAigCHCgCCCEDIAQgAigCIDYCDCAEIAA2AhQgBCAAKAIANgIIIARBCGogAxCEDCEDCyAEQTBqJAAgAwuWAgYBfwF/AX8BfwF/AX8Cf0ECIgIgACgCACIGKAIkDQAaQQEiAiABLwEGQaAIcQ0AGgJAIAEoAhwiA0UNAEEAIQIDQCACIAMoAgBODQECQCADIAJBBHRqIgQoAgwiBUUNACAELQARQQNxDQAgBkEAIAUQsAkLIAJBAWohAgwACwALAkAgASgCICIHRQ0AQQAhBANAIAQgBygCAE4NAUEAIQIgBkEAIAcgBEEGdGoiBSgCEBCwCSAFKAI0IQMCQCAFLQAuQQRxRQRAIAAgAxCyCRoMAQsDQCACIAMoAgBODQEgBkEAIAMgAkEDdGooAggQsAkgAkEBaiECDAALAAsgBEEBaiEEDAALAAsgACABEIcMQQALIgILKgAgACgCACIAQQAgARCwCSABLQAHQQNxRQRAIABBACABQSxqELAJC0EAC4cCCQF/AX8BfwF/AX8BfwF/AX8BfyMAQTBrIgQkAAJAIAEoAkAiBUUNACAAKAIAIQJBACEBIAUoAhQtAARBwABxRQRAIAIgAigCACAFENgLQQEQhQkhAwsgBEEIakEEciIGIQkDQCAFKAIAIAFKBEAgBSABQRhsaiIKKAIUIQcgBkIANwIYIAlCADcCECAGQgA3AgggBkIANwIAIAQgAjYCCCACIQggAwRAIAIgByAEQQhqEJEKIAQoAgghCAsgCCgCAC0AVw0CIAAgBxCxCRogAiAKKAIQEOsJIAFBAWohAQwBCwsgA0UNACACKAKMAiADRw0AIAIgAygCCDYCjAILIARBMGokAAuEAgUBfwF/AX8BfwF/IwBBIGsiAyQAIAIoAgwhBiAAKAIAIgUoAnghByADQQA7ARwgA0EANgIYIAMgBzYCFCADIAU2AgggA0IANwIMAkAgAigCKEUEQANAIAQgAi8BMk8NAiAGKAIEIAIoAgQgBEEBdGouAQBBDGxqKAIAIQUgBARAIANBCGpBtZ8DQQIQTgsgA0EIaiAGKAIAEFYgA0EIakHL1wJBARBOIANBCGogBRBWIARBAWohBAwACwALIAMgAigCADYCACADQQhqQfaHAyADEFgLIANBCGoQYyEEIABBkwxBkxAgAi8AN0EDcUECRhsgASAEQXpBAhCMCiADQSBqJAALLgEBfyAAKAIAIgMgAUEAEKQJIQEgAy0AV0UEQCAAIAEgAkEQEMIKCyADIAEQMwuVAgUBfwF/AX8BfwF/IwBBIGsiBCQAAkAgASACQQZ0ai0ALCIFQcAAcQ0AIAAoAgQiCEEBcSEHAkAgBUEIcQRAIAdFDQIgACgCJCABIAJBBnRqKAIwRg0BDAILIAcNAQsCQCAIQQNxRQ0AIAEtACxBwABxRQ0AQQAhBSACQQAgAkEAShshBgNAIAUgBkYNASAAKAIkIAEgBUEGdGooAjBGBEBBACEGIAEgBUEGdGotACxBwABxDQMFIAVBAWohBQwBCwsLIAQgASACQQZ0aigCMDYCGCAEQQEiBUHmAEHMACADG2o2AgggBEHOADYCBCAEQQA2AgAgBEEDOwEUIAQgABCyCRogBC8BFCEGCyAEQSBqJAAgBguoBQUBfwF/AX8BfwF/IwBBQGoiBCQAAkAgAUUEQEEAIQEMAQsCQCABKAIEIgNBA3FFDQAgASgCJCAAKAIERw0AIAEgACgCCDYCJAsCfwJAAkAgAS0AACICQbMBRwRAIAJBpwFHDQEgA0EgcSABKAIcIAAoAgRHcg0BIAAoAgAhAyAAKAIQIAEuASAiBkEEdGooAggiAhC5CwRAIAMgAhDUCwwFCyADKAIAIQMCQCAAKAIMRQ0AAkAgAi0AAEGnAUcEQCAAKAIIIQUMAQsgACgCCCIFIAIoAhxGDQELIARBCGpBAEE0EOcUGiAEQZ3/AzsBKCAEIAU2AiQgBCACNgIUIARBswE6AAggBEGAgBA2AgwgBEEIaiECCyADIAJBABCkCSECIAMtAFdFBEAgACgCDARAIAIgAigCBEGAgIABcjYCBAsgASgCBEEDcSIFBEAgAiABKAIkIAUQ1goLIAMgARCgCCACLQAAQaoBRgRAIAIQtgshASACQZsBOgAAIAIgATYCCCACIAIoAgRBgBByNgIECyAAKAIAIAIQ6wggACgCACAAKAIUIAZBBHRqKAIIEOsIIgFGBEAgAi0AACIDQfEARiADQacBRnINBAtBACEDIAAoAgAiACACIAEEfyABKAIABUGAtAMLIgEQ+AsMBAsgAyACEDMMBAsgASgCHCAAKAIERw0AIAEgACgCCDYCHAsgASAAIAEoAgwQiww2AgwgASAAIAEoAhAQiww2AhAgASgCFCECAkAgAS0ABUEQcQRAIAAgAkEBENgKDAELIAAgAhC6DAsgAS0AB0EBcUUNAiABKAIsIgIgACACKAIoEIsMNgIoIAAgAigCCBC6DCAAIAIoAgwQugwMAgsgAgsiASABKAIEQf97cTYCBAsgBEFAayQAIAELSQEBfyMAQSBrIgMkACADIAI2AhggA0EANgIIIANBATsBFCADIAA2AgAgA0HoADYCBCADIAEQsgkaIAMvARQhAiADQSBqJAAgAgsbACAAIAEQ6wgiAUUEQCAAKAIAKAIIIQELIAELSAEBfwNAIAEQpQshAyAAIAI6AAgCQCADBEAgAy0AACACRg0BIAAgAUEAEI8MGgsPCyAAIAMoAgwgAhCODCADKAIQIQEMAAsAC5UCBQF/AX8BfwF/AX8gACgCDCIDIAAoAhAiBE4EQCAAKAIYIQUgACgCACIDKAIAKAIAIQYgACADIARB4ABsrRCjDCIDNgIYIANFBEAgAkEBcQRAIAYgARAzCyAAIAU2AhhBAA8LIAMgBSAAKAIMQTBsEOUUGiAAIAAoAhBBAXQ2AhAgACgCDCEDC0EBIQUgACADQQFqIgc2AgwgA0EwbCEGIAAoAhghBCACQQJxRQRAIAAgBzYCFAsgBCAGaiEGAkAgAUUNACABLQAGQQhxRQ0AIAE0AhwQmwRBjgJrIQULIAQgA0EwbGoiBCAFOwEIIAYgARClCzYCACAEIAA2AgQgBCACOwEKIARBDGpBAEEkEOcUGiADCycBAX8gASgCDCECA0AgAkEATEUEQCAAIAEgAkEBayICEMAMDAELCwvXAgcBfwF/AX8BfwF/AX8BfwJAIAEoAigNACABKAIEIgdBCXENACABKAIgIgMoAgBBAUcNACADKAIYLQArQQFHDQAgACgCDCIEQQAgBEEAShshBCADKAIwIQUgASgCMCEGA0AgAiAERwRAAkAgACgCGCACQTBsaiIDLQAKQQRxDQAgAy0ADg0AIAMoAhQgBUcNAyADKQMgQgBSDQMLIAJBAWohAgwBCwsCQCAGRQ0AQQAhAiAGKAIAIgNBACADQQBKGyEIA0AgAiAIRg0BIAYgAkEEdGoiBCgCCCIDLQAAQacBRw0CIAMoAhwgBUcNAiACQQFqIQIgBC0AEEECcUUNAAsMAQsCQCABKAIMIgJFDQAgB0GAAnENASAAIAIgASgCPCgCECAFQcoAEMEMIAEoAgxFDQAgAS0ABUEBcQ0BCyAAIAEoAgggASgCPCgCDCAFQckAEMEMCwspAQF/AkAgAS0AAEGsAUcNACABLQAGQRBxDQAgAEEAOwEUQQIhAgsgAgt+BAF/AX8BfwF+IwBB4ABrIgckACAEQYIBcSEIIAcgACABIAIgBCAFEJUMIQQDQAJAAkAgBARAIAQpAyAiCSADg0IAUg0CIAlCAFINASAIIAQvAQxxRQ0BIAQhBgsgB0HgAGokACAGDwsgBiAEIAYbIQYLIAcQlgwhBAwACwALNwEBfyAAKAIEIAFBAXRqLwEAIgHBIgJBAE4EQCAAKAIMKAIEIAFBDGxqLQAEQQ9xDwsgAkF/Rgv3AQEBfyAAQQA6ABggACABNgIEIAAgATYCACAAIAQ2AhQgAEIANwIIIAAgAjYCHCAAQQA2AhAgAEGBAjsAGQJAAkAgBQRAQX8hASAFKAIEIANBAXRqLwEAIgYgBSgCDCIELwEgRg0BIAbBIgFBAE4EQCAAIAQoAgQgAUEMbGotAAU6ABggACAFKAIgIANBAnRqKAIANgIIDAILIAFBfkcNASAAIAUoAiggA0EEdGooAgg2AgwgBSgCICADQQJ0aigCACEFIABB/v8DOwFIIAAgBTYCCCAAENkMDwsgAyEBIANBfkYNAQsgACABOwFIIAAQlgwhBgsgBgufBQkBfwF/AX8BfwF/AX8BfwF/AX8gAC0AGSEBIAAoAgQhBSAAKAIQIQYDQCAAIAFB/wFxQQFrIgFBAXRqLgFIIQggACABQQJ0aigCHCEJA0AgBSgCGCAGQTBsaiEBA0ACQCAFKAIMIAZKBEAgASgCFCAJRw0BIAEoAhggCEcNASAIQX5GBEAgASgCACgCDCAAKAIMIAkQ2AwNAgsgAC0AGUECTwRAIAEoAgAtAARBAXENAgsCQCABLwEMIgRBgBBxRQ0AIAAtABoiB0EKSw0AIAEoAgAoAhAQpQsiA0UNACADLQAAQacBRw0AIAMtAARBIHENAEEAIQICQANAIAIgB0YNAQJAIAAgAkECdGooAhwgAygCHEYEQCAAIAJBAXRqLwFIIAMvASBGDQELIAJBAWohAgwBCwsgAiAHRw0BCyAAIAdBAnRqIAMoAhw2AhwgACAHQQF0aiADLwEgOwFIIAAgB0EBajoAGiABLwEMIQQLIAQiAiAAKAIUcUUNASAAKAIIRSACQYACcXJFBEAgAC0AGCEEIAUoAgAoAgAhAwJAIAJBAXEEQCADIAEgBEH/AXEQ2gwiAg0BDAQLIAEoAgAiAiAEwBDbDEUNA0EAIQQgAyACELkDIgJFBEBBgLQDIQIMAQsgAigCACECCyACIAAoAggQbQ0CIAEvAQwhBAsCQCAEQYIBcUUNACABKAIAKAIQIgJFDQAgAi0AAEGnAUcNACACKAIcIAAoAhxHDQAgAi8BICAALwFIRg0CCyAAIAU2AgQgACAGQQFqNgIQIAEPC0EAIQYgBSgCBCIFDQIgAC0AGSIBIAAtABpPBEBBAA8LIAAgAUEBaiIBOgAZIAAoAgAhBQwDCyABQTBqIQEgBkEBaiEGDAALAAsACwALXwMBfwF+AX9CASEDIAEgACgCCEcEQEEBIAAoAgQiAiACQQFMGyEEQQEhAgN+IAIgBEYEQEIADwsgASAAIAJBAnRqKAIIRgR+QgEgAq2GBSACQQFqIQIMAQsLIQMLIAML2A0bAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX4BfgF+AX8BfwF+IwBBEGsiCSQAIAlBADYCCCAAKAIEIg8oAgwiA0EAIANBAEobIQUgACgCACIQKAIEIhQgACgCCCILLQAQIgxBBnRqIgMiHEEsaiENIAMiFkEwaiEHIANBCGohESADKAIYIRUgDygCGCEDIBAoAgghCiAQKAIAIQ4DQCAFIAZGRQRAIAMgAy8BCiIEQb//A3E7AQoCQCADKAIUIBYoAjBHDQAgAykDICACg0IAUg0AIAMvAQxB/+8DcUUgBEGAAXFyDQAgHC0ALEHYAHEEQCADIBEQ3AxFDQELIAMgBEHAAHI7AQogCEEBaiEICyADQTBqIQMgBkEBaiEGDAELCwJ/IApFBEBBAAwBCyAKKAIAIg1BACANQQBKGyEFQQAhAwJAA0AgAyAFRg0BAkACQEEAIAogA0EEdGoiBCgCCCIGEMoJDQAgBC0AEEECcQ0BIAYtAAAiBEHxAEcEQCAEQacBRw0CIAYoAhwgFigCMEcNAgwBCyAGKAIMIgQtAABBpwFHDQEgBCgCHCAWKAIwRw0BIAYgBC8BIDsBICAELgEgIgRBAEgNAEEAIREgBigCCCAVKAIEIARB//8DcUEMbGoQjgQiBkGAtAMgBhsQbA0BCyADQQFqIQMMAQsLIAMhBQtBACIDIAUgDUcNABogDSESAn8CQCAQLwEoIgNBgAFxRQ0AIBQgDEEGdGotAC5BwABxDQAgA0EJdkEBcUECcgwBCyADQQZ2QQFxCwshAwJAIA4oAgAgEkEDdCIGIAhBGGxqQeAAaq0QxQIiBUUEQCAOQaElQQAQsgJBByEDDAELIAUgDzYCSCAFQQA2AlQgBSADNgJQIAUgDjYCTCAFIAhBAnQgBWpB3ABqIhE2AgQgBSARIAhBDGxqIhU2AgwgBSAGIBVqNgIQIA8oAgwiA0EAIANBAEobIRAgDygCGCEDQQAhFEEAIQxBACEEQQAhBgNAAkACQAJAAkAgBiAQRwRAIAMvAQoiDUHAAHFFDQQgAygCGCEHIBEgBEEMbGoiCCAGNgIIIAggBzYCAAJAIAMvAQxB//8AcSIHQcAARwRAIAdBAUcNASANwUEASA0DIAVBASAEdEEAIARBIEgbIBRyIhQ2AlQMAwsgCCADLQAPOgAEDAQLIAdBgANxRQ0CIAgiF0EEaiEIIAdBgAJGBEAgF0HHADoABAwECyAXQcgAOgAEDAMLIAUgBDYCACASQQAgEkEAShshCEEAIQdBACEDA0AgAyAIRkUEQEEAIAogA0EEdGoiBigCCCIEEMoJRQRAIBUgB0EDdGoiDSAELgEgNgIAIA0gBi0AEEEBcToABCAHQQFqIQcLIANBAWohAwwBCwsgBSAHNgIIIAtBADsBLCALQYAINgIoIAtBADsBEiALQRxqIgMgCy0AHEH+AXE6AAAgDigCACALIAUoAgAiBhDIDARAIA4oAgAgBRDdDEEHIQMMBgsgACABQn9BACAFIAxB//8DcSIEIAlBDGogCUEIahDeDCEDIAkoAggEQCAAIAFCf0EAIAUgBCAJQQxqQQAQ3gwhAwsCQCADDQAgCSgCDCEEIAFCf4UiGSALKQMAgyIdUARAQQAhAyAERQ0BC0EAIQNBACEHIAQEQCAAIAFCf0EBIAUgDEH//wNxIAlBDGpBABDeDCEDIAspAwAgGYMiGFAhBwsgBkEAIAZBAEobIQYgDEH//wNxIQQgByEKA0AgAw0BQn8hAkEAIQMDQCADIAZGRQRAIA8oAhggBSgCBCADQQxsaigCCEEwbGopAyAgGYMiGiACIAIgGlYbIAIgEyAaVBshAiADQQFqIQMMAQsLIAJCf1IEQEEAIQMgAiETIAIgHVENASACIBhRDQEgACABIAEgAoRBACAFIAQgCUEMakEAEN4MIQMgCykDACABUg0BQQEhByAKQQEgCSgCDBshCgwBCwtBACEDIAdFBEAgACABIAFBACAFIAxB//8DcSAJQQxqQQAQ3gwhAyAKQQEgCSgCDBshCgsgAyAKcg0AIAAgASABQQEgBSAMQf//A3EgCUEMakEAEN4MIQMLIAUoAhwEQCAFKAIYEEALIA4oAgAgBRDdDAwFC0ECIQcLIAggBzoABCAHQTxxRQ0AIAMoAgAoAhAQuQtFDQAgCCIbQQRqIQhBASAEdEEAIARBEEgbIAxyIQwgB0EERwRAIAdBEEcNASAbQQg6AAQMAQsgG0EgOgAECyAEQQFqIQQLIANBMGohAyAGQQFqIQYMAAsACyAJQRBqJAAgAwuzDRQBfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX8BfwF/IwBB4ABrIgYkACAGQf//AzsBEiAAKAIAIgwoAgRBCGoiBSAAKAIIIgMtABAiC0EGdGoiCSgCECEIIAAoAgQhEAJAIAktACVBAnEEQCAJKAI8IQQMAQsgCC0AHEGAAXEEQCAIKAIIIQQMAQsgBkEYakEAQcgAEOcUGiAGQYOABDYCSCAGQQU6AE4gBkEDOwBPIAYgBkEUajYCICAGIAZBEmo2AhwgBkEBOwFMIAYgCDYCJCAILwEmIQQgBkEAOwEWIAYgBDsBFCAGQRhqIQQgCS0AJUEBcQ0AIAYgCSgCECgCCDYCLAsCQCAAKAIMDQAgDC8BKEGgIHENACAMKAIAKAIALQAhQYABcUUNACAJLwAlIgdBA3ENACAILQAcQYABcQ0AIAdBCHENACAHQcAAcQ0AIAktACRBEHENACAQKAIYIgcgECgCDEEwbGohDyAILwEmIgLBEMMMIgogAmoiAkEZayENIAJBHGohESAIIhRBHWohE0EAIQIDQCACIAcgD09yDQFBACECAkAgAykDCCAHKQMgg0IAUg0AIAcgCUIAEMcMRQ0AIANBATsBGCADQQE2AiwgA0EANgIgIAMoAjQgBzYCAAJ/IAgtACtBAkcEQCARIgIgFC0AHUHAAHFFDQEaCyANCyECIANBKzsBFiADIALBIgJBACACQQBKGzsBEiADQYCAATYCKCADIApBKxDICjsBFCADIAcpAyAgAYQ3AwAgACADEN8MIQILIAdBMGohBwwACwALIAUgC0EGdGoiBSEVIAUhEkEBIQ8DQAJAAkAgAiAERXJFBEACQCAEKAIkIgJFDQAgEigCKCAJLQAkIBAgAhDgDA0AQQAhAgwDC0EAIQIgBC0AOEECcQ0CIAQoAggvAQAhCiADQQA7ARwgA0EANgIYIANBADYCLCADQQA7ARIgA0EAOgARIAMgBDYCICADIAo7ARYgAyABNwMAQQEhAgJAIAQtADdBBHENACAAKAIAKAIIIhNFDQAgEigCKCERQQAhDQNAIA0gEygCAE4iAg0BAkACQCATIA1BBHRqKAIIEKULIgVFDQACQAJAIAUtAABBpwFrDgMAAQABCyAFKAIcIBFHDQAgBS4BICIHQQBIDQQgBC8BMiELQQAhAgNAIAIgC0YNAiACQQF0IQUgAkEBaiECIAUgBCgCBGovAQAgB0H//wNxRw0ACwwCC0EAIQIgBCgCKCILRQ0AA0AgAiAELwEyTw0BIAQoAgQgAkEBdGovAQBB/v8DRgRAIAUgCyACQQR0aigCCCARENgMRQ0DCyACQQFqIQIMAAsACyANQQFqIQ0MAQsLQQAhAgsCQCAELwA3IgVBA3FBA0YEQCADQYACNgIoIAMgCkEQajsBFCADQQAgDyACGzoAESAQIAMgCsEQ4QwMAQsCQCADAn8CQCAFQSBxBEAgBkIANwMIDAELIAYgBCkDQCAVKQMwgyIONwMIIAQoAiQiBQRAIAwoAgAgBCAFIAZBCGpBAEEAEKIMIAYpAwghDgsgA0GABDYCKAJAIA5CgICAgICAgICAf1IEQCAOUCAELwA3IgVBgCBxRSAFQYAQcXJyDQELIAwgBCASKAIoEOIMIgVFDQMgAygCKCAFcgwCCyAOQgBSDQILQcAECyIFNgIoQgAhDgsgDyEFAkAgAkUNAEEAIQUgCC0AHEGAAXENACAEKAIkDQAgCS0AJUECcQ0AIA5CAFINAyAELQA3QQRxDQMgBC4BMCAILgEoTg0DQQAhCyAMLQAoIgJBBHENA0HX7AUtAABFDQMgDCgCACgCAC0AUEEgcQ0DCyADIAU6ABEgAyAKIAQuATBBD2wgCC4BKG1qQQFqOwEUIA5QRQRAIApBEGohByASKAIoIQ1BACECA0ACQCACIAwoAlxODQAgDCgCaCACQTBsaiIFKAIAIA0gBBCwDEUNACACQQFqIQIgBS4BCCILQQBKBEBBbEF/IAUtAAxBggFxGyELCyAHIAtqIQcMAQsLIAMgAy4BFCAHwRDICjsBFAsgECADIArBEOEMIAktACRBEHFFDQAgBCgCKEUNACADIAo7ARYMAgsgACADEN8MIQIgAyAKOwEWIAJFDQELIAZB4ABqJAAgAg8LIABBADoAECAAIAkgBEEAEOMMIQIgAC0AEEEBRw0AIAggCCgCHEGAAnI2AhwLQQAhBSAPQQFqIQ8gCS0AJUECcUUEQCAEKAIUIQULIAUhBAwACwAL/AYVAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/IwBB4ARrIgMkACAAKAIAIQQgACgCBCILKAIYIQkgCygCDCEFIAAoAgghBiADQfAAakEAQTgQ5xQaAkAgBCgCBEEIaiAGLQAQQQZ0aiIELQAkQRBxDQAgBCgCKCEOIAkgBUEwbGohDyAEIRAgA0EIaiERIANBQGshEiADQfgAaiEMA0AgCSAPTyAHcg0BQQAhBwJAIAktAA1BAnFFDQAgBikDCCAJKAIYIgQpA6ADg1ANACAEKAIYIQggBCgCDCEEIAMgACkCCDcDsAEgAyAAKQIQNwO4ASADIAApAgA3A6gBIAggBEEwbGohEyADIANBOGo2ArQBQQEhBANAAkACQAJ/IAggE0kEQAJ/IAgtAA1BBHEEQCAIKAIYDAELIAgoAhQgDkcNBCALKAIAIQUgAyAINgLYASADQQE2AtQBIANBATYCzAEgA0EsOgDIASADIAs2AsQBIAMgBTYCwAEgA0HAAWoLIQUgA0EAOwE4IAMgBTYCrAECfyAQKAIQLQArQQFGBEAgA0GoAWogASACEJgMDAELIANBqAFqIAEQmQwLIgdFBEAgA0GoAWogASACEJoMIQcLIAMvATgiBUUEQCADQQA7AXBBAAwCCyAEBEAgAyAFOwFwIAwgEiAFQQR0EOUUGgwDCyARIAwgAy8BcCIUQQR0EOUUGkEAIQogA0EAOwFwA0AgCiAURg0DIAMgCkEEdGoiBCIVQRJqIQ0gBCEWIAQhF0EAIQQDQCAEIAVB//8DcU9FBEAgA0HwAGogA0E4aiAEQQR0aiIFKQMIIBcpAwiEIBYuARAgBS4BEBDICiAVLgESIAUuARIQyAoQ5AwgBEEBaiEEIAMvATghBQwBCwsgCkEBaiEKDAALAAsgAy8BcAshBSAGQQE7ASwgBigCNCAJNgIAQQAhBCAGQQA7ARIgBkGAwAA2AiggBkEAOgARIAZCADcDICAGQgA3AxggBUH//wNxIQ0DQCAHIAQgDU9yDQQgBiADQfAAaiAEQQR0aiIFLwEQQQFqOwEUIAYgBS8BEjsBFiAGIAUpAwg3AwAgBEEBaiEEIAAgBhDfDCEHDAALAAtBACEECyAIQTBqIQgMAAsACyAJQTBqIQkMAAsACyADQeAEaiQAIAcLQQIBfwF/IAEoAjQiAiABQTxqIgNHBEAgACACEDUgAUEDOwEwIAEgAzYCNAsgACABEOUMIAFBADYCKCABQQA7ASwLtw8fAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX4jAEEQayIHJABBAUEFQQogAC0ALCIIQQJGGyAIQQJJGyENIAAoAgAhFQJAIAFFDQAgACgCCCICRQ0AIAIoAgAhCwsgFSgCACALIAhBAnRBIGogDWxqQQF0rBDsAiITBEAgC0EBdCEGIBMgDUEFdCICaiIEQgA3AwAgBEIANwMYIARCADcDECAEQgA3AwggAiAEaiEQIA1BAXQhAiAIQQJ0IQUgEyEDA0AgAkEATEUEQCADIBA2AhggA0EgaiEDIAJBAWshAiAFIBBqIRAMAQsLAkAgC0UEQEEAIRAMAQsgEEEAIAYQ5xQaCyATIA1BBXRqIgNBMCAVLgGUASICIAJBME4bOwEQIAsEQCADQX8gCyAIGzoAFgsgAUEKayEcIABBPGohHSABQQpKIR5BASECIBMhDgNAIAQhGCAIIBRGRQRAQQAhDyACQQAgAkEAShshHyAUQQJ0IRsgGCEGQQAhGQNAIBkgH0ZFBEAgHSECA0AgAigCACIEBEACQCAEKQMAIAYpAwAiEUJ/hYNCAFINACAEKQMIIiAgEYNCAFINACAELQApQcAAcUEAIAYuARAiAkEDSBsNACAELgESIAIgBC8BFGrBEMgKIAYuARQQyAohEiAELwEWIQMCQCAGLAAWIglBAEgEQCAHQgA3AwggACAAKAIIIAYgAC8BKCAUQf//A3EgBCAHQQhqEMIMIQkMAQsgByAGKQMINwMICyACIANqIQICQCAJQQBIIAkgC05yRQRAIBAgCUEBdGoiBS8BACIDRQRAIAAoAhAoAhwoAgBBO2pBHm2sEJsEIAFqIQMgCQRAIAsgCWtB5ABsIAttrBCbBCADakHCAGshAwsgBQJ/IAAvASgiCkGAgAFxBEAgA0EQQQogCRtqIQMgAC4BKiIKIAEgASAKShsMAQsgHCABIApBgAJxQQh2GyABIB4bCyIKwRDDDCADaiIDOwEACyASIAPBEMgKQQNqIQoMAQsgEiIKQQJrIRILIBEgIIQhESACwSEaQQAhAyAPQQAgD0EAShshBSAOIQICQAJAA0AgAyAFRwRAIBEgAikDAFEEQCACLQAWIAlzwEEATg0DCyACQSBqIQIgA0EBaiEDDAELCwJAIA8iAiANSCIDDQAgCsEgDMFKDQMgFyECIApB//8DcSAMQf//A3FHDQAgEsEgFsFODQMLIA4gAkEFdGohAiADIA9qIQ8MAQsgAi4BEiIDIArBSA0BIANB//8DcSAKQf//A3FHDQAgAi4BECIDIBpIDQEgAyAaRw0AIAIuARQgEsFMDQELIAIgBCkDCCAGKQMAhDcDACAHKQMIIREgAiAJOgAWIAIgEjsBFCACIAo7ARIgAiAaOwEQIAIgETcDCCACKAIYIAYoAhggGxDlFBogAigCGCAbaiAENgIAIA0gD0oNACAOLwEQIRYgDi8BEiEMQQEhA0EAIRcgDiECA0AgAyANRg0BAkACQCACLgEyIgUgDMFKBEAgAi8BNCEJDAELIAVB//8DcSAMQf//A3FHDQEgAi4BNCIJIBbBTA0BCyAJIRYgBSEMIAMhFwsgAkEgaiECIANBAWohAwwACwALIARBOGohAgwBCwsgBkEgaiEGIBlBAWohGQwBCwsgFEEBaiEUIA8hAiAOIQQgGCEODAELCwJAIAIEQEEBIAIgAkEBTBshBSAYIQNBASECA0AgAiAFRgRAIABB+AVqIQZBACECA0AgAiAIRkUEQCAGIAJB4ABsaiIEIAMoAhggAkECdGooAgAiBTYCUCAEIAUtABAiBToAPCAEIAAoAgQgBUEGdGooAjA2AgQgAkEBaiECDAELCwJAIAFFIAAvAShBgANxQYACR3INACAALQAvDQAgACAAKAIMIANBgAEgCEEBayICQf//A3EgAygCGCACQQJ0aigCACAHQQhqEMIMIAAoAgwoAgBHDQAgAEECOgAvCyAAIAAtADAiBkH7AXE6ADACQCAAKAIIIgJFDQAgACADLAAWIgU6AC0CQCAALwEoIgRBgAFxBEAgAigCACAFRw0BIABBAjoALwwBCyAAIAMpAwg3A0ggBUEATARAIABBADoALSAIRQ0BIAMoAhggCEEBayIGQQJ0aigCACIMKAIoIgVBgCBxIAVBhAJxQYQCRnINASAHQgA3AwggACACIANBgBAgBkH//wNxIAwgB0EIahDCDCAAKAIIIgIoAgBGBEAgACAALQAwQQRyOgAwIAAgBykDCDcDSAsgAC8BKCEEDAELIARBA3FFIAhFIAVBAUdycg0AIAAgBkEEcjoAMAsgBEGABHFFDQAgCEUgAigCACAALAAtR3INACAHQgA3AwggACACIANBACAIQQFrIgRB//8DcSADKAIYIARBAnRqKAIAIAdBCGoQwgwgACgCCCgCAEcNACAAIAAtADBBCHI6ADAgACAHKQMINwNICyAAIAMvARA7ATIMAwUgGCACQQV0aiIEIAMgAy4BEiAELgESShshAyACQQFqIQIMAQsACwALIBVBwPsAQQAQsgILIBUoAgAgExA1CyAHQRBqJAALoAEFAX8BfwF/AX8BfyAAQTxqIQQgAC0ALCEFA0ACQCACIAVGDQAgACACQeAAbGooAsgGIgFFDQACQCABKAIoIgNBgAhxDQAgA0ENcUUNASABLQAQIQMgBCEBA0AgASgCACIBRQ0BAkAgAS0AECADQf8BcUcNACABLwEoQY+AAXENACABQn83AwALIAFBOGohAQwACwALIAJBAWohAgwBCwsLewQBfwF+AX8BfiAAKAIEIgMoAgAiAUEAIAFBAEobrSEEA0AgAiAEUUUEQAJAAkAgAyACp0EGdGoiAS0ALkEBcUUNACABKAJELQASDQAgASgCHCIBRQ0AIAEoAjANAQsgACAAKQNIQgEgAoaENwNICyACQgF8IQIMAQsLC78DDQF/AX8BfgF/AX8BfgF+AX8BfwF/AX8BfwF/IABB8ANqIgEgACgCDBDEDCEDIAAoAggiAgRAIAEgAhDEDCADhCEDCyAAKAIELQAsQcAAcSEMIAAtACwiBCEJQn8hBgNAIAkiBUECTgRAIAAoAgQgACAFQQFrIglB4ABsaiINKALIBiIBLQAQQQZ0aiICLQAsQRhxQQhHDQEgAC0AKUEBcUUEQCABLQApQRBxRQ0CCyABKQMIIgcgA4NCAFINASACIQogACgCaCIBIAAoAlxBMGxqIQsgASECA0AgAiALSQRAIAIpAyggB4NQRQRAIAIoAgAiCC0ABEEBcUUNBCAIKAIkIAooAjBHDQQLAkAgDEUNACACKAIAIggtAARBAnFFDQAgCCgCJCAKKAIwRg0ECyACQTBqIQIMAQsLIA1B+AVqIQIDQCABIAtJBEAgASkDKCAHg1BFBEAgASABLwEKQQRyOwEKCyABQTBqIQEMAQsLIAdCf4UgBoMhBiAEQf8BcSIBIAVHBEAgAiAAIAVB4ABsakH4BWogASAFa0HgAGwQ5hQaIAAtACwhBAsgACAEQQFrIgQ6ACwMAQsLIAYLrgEGAX8BfwF/AX8BfwF/IAAtACwhBgNAAkAgASAGRg0AIAAoAgQgACABQeAAbGooAsgGIgQtABBBBnRqKAIYIgUoAhwiAkEQcUUNACAFIAJBgAJyNgIcAkAgAUUNACAEKAIoIgJBgYCABHFBgYCABEcgAkGABnFFcg0AIAUuASYgA8FODQAgBCACQb///31xQYCAgAJyNgIoCyABQQFqIQEgBC8BFiADaiEDDAELCwv0AgYBfwF/AX8BfwF/AX8jAEEgayIGJAAgAEHIAGohCCABKAIMIQkDQAJAIAcgAS8BNE8NAAJAQQACfyABKAIEIAdBAXRqLgEAIgRBfkYEQCABKAIoIAdBBHRqKAIIDAELIARBAEgNASAJKAIEIARBDGxqIgQtAApBIHFFDQEgCSAEEJMJCyIEEMoJDQAgBC0AAEGsAUYEQCAGQgA3AgggBkEANgIYIAZCADcCECAGQekANgIEIAYgADYCACAGIAQQsgkaIAYvARQNAQsgACgCAEIcEF0iBUUNASAFIAAoAkg2AhQgBSAAKAIAIARBABCkCTYCACADKAIoIQQgBSAHNgIMIAUgAjYCCCAFIAQ2AgQgBSADLQAkQdgAcUEARzoAECAAKAIAIAEQ4QoEQCAFIAEoAhAgB2otAAA6ABELIAUgASgCADYCGCAIIAU2AgAgBSgCFA0AIABB6gAgCBCQChoLIAdBAWohBwwBCwsgBkEgaiQAC8oCAwF/AX8BfwJAIAItAAAiBkEsRgRAIAAgASACKAIQIAMgBCAFEKIMIAIoAgwiAi0AACEGCyAGQf8BcSIGQTVHIAZBLUdxDQAgAigCDCIGLQAAQacBRw0AQQAgAigCECIIEMoJRQ0AIAAgAhC5AyICBEBBASEHIAIoAgxBEkcNAQsgBi4BICICQQBIDQAgASgCDCgCBCACQQxsai0ABSIBQcIASQ0AIAUEQCAAKAIAIgNCHBBdIgJFDQEgBS0AJCEHIAIgAyAIQQAQpAk2AgAgBSgCKCEFIAIgBDYCCCACIAU2AgQgBi4BICEGIAIgB0HIAHFBAEc6ABAgAiAGNgIMIAAoAkwhBiACIAE6ABEgAiAGNgIUIAAgAjYCTCAGDQEgAEHqACAAQcwAahCQChoPCyACQT5LDQAgAyADKQMAQn4gAq2JgzcDAAsLQAIBfwF/IAAoAgAoAgAgAUIQfBDsAiICRQRAQQAPCyAAKAJAIQMgAiABNwMIIAIgAzYCACAAIAI2AkAgAkEQaguyDRkBfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX4BfwF+AX8BfwF/AX8BfiMAQTBrIg0kACAAKAIIIgdBDxDxCCEYIAEoAhgiBSABKAIMQTBsaiEMIAEoAgAoAgQiESADLQA8IhNBBnRqIgRBCGohCiAEIhlBGGooAgAhCyADKAJQIQ5BACEEAkADQCAFIAxJBEACQCAFLQAKQQJxDQAgBSgCACIGIBEgAy0APEEAEIoMRQ0AIAAgECAAKAIAIAZBABCkCRDOCSEQCwJAIAUgCiACEMcMRQ0AQoCAgICAgICAgH9CASAFKAIYIgathiAGQT9KGyEJIAhB/wFxRQRAIAsoAgAhCCANIAsoAgQgBkEMbGooAgA2AgQgDSAINgIAQZwCQd/fAiANEGoLQQEhCCAJIA+DQgBSDQAgACgCACAOIARBAWoiBhDIDA0DIA4oAjQgBEECdGogBTYCACAJIA+EIQ8gBiEECyAFQTBqIQUMAQsLIA5BwYQBNgIoIA4gBDsBGCAOIAQ7ASwgCy0AK0ECRgR+IA9Cf4UFIBEgE0EGdGopAzggD0J/hUKAgICAgICAgIB/hIMLIRdBPyALLgEiIgUgBUE/ThsiBkEAIAZBAEobrSEPQgAhCQNAIAkgD1FFBEAgBCAXIAmIp0EBcWohBCAJQgF8IQkMAQsLIAAoAgAgBCARIBNBBnRqIhpBOGopAwBCP4enIAVBP2txakEBaiIbwUEAIA1BLGoQiQoiBkUNACAOIAY2AiAgBiALNgIMIAZB7Sg2AgAgASgCGCEEQgAhCUEAIQUDQCAEIAxPBEACQEEAIQQDQCAJIA9RDQEgFyAJiEIBg1BFBEAgBigCBCAFQQF0aiAEOwEAQQAhDCAGKAIgIAVBAnRqQYC0AzYCACAFQQFqIQULIARBAWohBCAJQgF8IQkMAAsACwUCQCAEIAogAhDHDEUNAEKAgICAgICAgIB/QgEgBCgCGCIIrYYgCEE/ShsiHCAVg0IAUg0AIAQoAgAhEiAGKAIEIAVBAXRqIAg7AQAgACASELkDIggEfyAIKAIABUGAtAMLIQggFSAchCEVIAYoAiAgBUECdGogCDYCACAFQQFqIQUgEigCDCIIRQ0AQQEgFCAIEOQJQcIARxshFAsgBEEwaiEEDAELCwJAIBopAzhCAFkNAEE/IQQDQCAEIAsuASJODQEgBigCBCAFQQF0aiAEOwEAQQAhDCAGKAIgIAVBAnRqQYC0AzYCACAEQQFqIQQgBUEBaiEFDAALAAsgBigCBCAFQQF0akH//wM7AQBBACEEIAYoAiAgBUECdGpBgLQDNgIAIAAgACgCKCIMQQFqNgIoIAMgDDYCCCAHQfQAIAwgGxCKAxogACAGEOAKIA0gCygCADYCICAHQbTYACANQSBqEPMIIBRB/wFxRSAAKAIALQBSQQhxckUEQCAAIAEoAgAgAxDJDCAAIAAoAixBAWoiBDYCLCADIAQ2AjQgB0HNAEGQzgAgBBCKAxoLAkAgESATQQZ0aiIEIhZBLWoiDC0AAEEgcQRAIAQoAiQhCiAHQccAQQBBABCKAyESIAdBCyAKQQAgBCgCIBDbCBogB0EMIAoQ8gghCiANIBkoAhgoAgA2AhAgB0HH2gAgDUEQahDzCAwBC0EAIRIgB0EkIAMoAgQQ8gghCgtBACEIIBAEQCAAIAAoAjhBAWsiCDYCOCAAIBAgCEEQEMIKIA4gDigCKEGAgAhyNgIoCyAAEJUJIQQgACAGIAMoAgQgBEEAQQBBAEEAEJULIQYgAygCNCILBEAgB0G3ASALQQAgBiAOLwEYEP8CGgsgB0GKASADKAIIIAQQigMaIAcoAmwiC0EASgRAIAcoAmggC0EYbGpBFmtBEDsBAAsgEARAIAcgCBCNCgsCQCAWLQAtQSBxBEBBACEIIAUgBmohBSAHKAIALQBXBH9BkIIIBSAHKAJoIBJBGGxqCyIGIAU2AgggACAKIAMoAgQgESATQQZ0aigCKCADKAIIELYMIAcgChD4CBogFiAWLwAtQd//A3E7AC0gBygCbCEFDAELIAdBJyADKAIEIApBAWoQigMaIAcoAmwiBUEATA0AIAcoAmggBUEYbGpBFmtBAzsBAAtBACEMIAcoAgAtAFcEf0GQgggFIAcoAmggCkEYbGoLIgwgBTYCCCAAIAQQlglBACEEIAcoAmwhBSAHKAIALQBXBH9BkIIIBSAHKAJoIBhBGGxqCyIEIAU2AggLIAAoAgAgEBAzIA1BMGokAAvOBQ4BfwF/AX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/IAIoAlAhByAAKAIAIgUoAkwhDyAFQQA2AkwgBSgCSCEQIAVBADYCSCAFKAIIIgZBDxDxCCERA0AgBSAAIAIQyQwgBSAFKAI4QQFrIg02AjggAigCBCEKIAUgBSgCLEEBaiIENgIsIAIgBDYCNCAGQc0AQpDOAEKAreIEIAAoAgQiCSACLQA8IgtBBnRqKAIYLgEmEJoEIgwgDEKAreIEWhsiDCAMQpDOAFgbpyAEEIoDGiAGQSQgChDyCCEOIAAoAmgiBCAAKAJcQTBsaiEIA0AgBCAIT0UEQAJAIAQtAApBAnENACAEKAIAIAkgC0EAEIoMRQ0AIAUgBCgCACANQRAQwgoLIARBMGohBAwBCwsCQCAHLQApQQFxBEAgBkGHASAKIAUQlQkiBBCKAxogBkG3ASACKAI0QQAgBEEBEP8CGiAFIAQQlgkMAQsgBygCICELQQAhBCAFIAcvARgiCBDDCiEJA0AgBCAIRkUEQCAFIAsgCiAEIAQgCWoQkwsgBEEBaiEEDAELCyAGQbcBIAIoAjRBACAJIAgQ/wIaIAUgCSAIEMQKCyAGIA0QjQogBkEnIAIoAgQgDkEBahCKAxpBACEEIAYoAmwhCiAGKAIALQBXIgkEf0GQgggFIAYoAmggDkEYbGoLIgQgCjYCCCAHIAcoAihB////fXE2AigCQCAFKAIALQBSQRBxDQAgAC0ALCEIA0AgAUEBaiIBIAhODQEgACgCBCAAIAFB4ABsaiIELQC0BkEGdGotACxByABxDQAgBCgCyAYiB0UNACAHKQMAIAODQgBSDQAgBygCKEGEgIACcUGAgIACRw0ACyAEQfgFaiECIAEgCEgNAQsLQQAhBCAJBH9BkIIIBSAGKAJoIBFBGGxqCyIEIAo2AgggBSAPNgJMIAUgEDYCSAuYBwgBfwF/AX8BfwF/AX8BfwF/IwBB8AFrIgQkAAJAIAAoAngiBSAAIAUbLQDTAUECRw0AIAIoAlAiBigCKCIFQYDAAHEgA0EgcXINACABIAItADwiCUEGdGpBCGohByAAKAIAIQhBASECAkAgBUEwcSILDQAgBUGACHFFBEAgBi8BGA0BCyADQQNxQQBHIQILIAAoAgghCiAEQYACOwHsASAEQQA2AugBIARC5ICAgIDAss07NwPgASAEIAg2AtgBIAQgBzYCZCAEQQAiA0HU/wFBqPEBIAIbajYCYCAEIARB8ABqNgLcASAEQdgBakGT4AEgBEHgAGoQWAJAIAVBgApxRQRAIAYoAiAhAwJ/AkAgASAJQQZ0aigCGC0AHEGAAXEEQCADLwA3QQNxQQJGDQELQQAhAkGrzQEgBUGAgAhxDQEaQczNASAFQYCAAXENARpBmN8AQaHfACAFQcAAcRsMAQtBACEFIAJFDQJBr8oBCyEFIARB2AFqQbudA0EHEE4gBCADKAIANgIQIARB2AFqIAUgBEEQahBYIAYvAS4hCCAGKAIgIQcgBi8BGCIDRQRAIAYtAChBMHFFDQILIARB2AFqQfGCA0ECEE5BACEFA0AgAyAFRwRAIAcgBRDKDCECIAUEQCAEQdgBakG+ngNBBRBOCyAEIAI2AgAgBEHYAWpB+d8CQcSnAiAFIAhJGyAEEFggBUEBaiEFDAELCyADIQIgBigCKCIFQSBxBEAgBEHYAWogByAGLwEaIAMgA0GMsAIQywwgBigCKCEFQQEhAgsgBUEQcQRAIARB2AFqIAcgBi8BHCADIAJBsbACEMsMQQAhBQsgBEHYAWpBzYIDQQEQTgwBCyAFQYACcUUgBUEPcUVyRQRAIARBACICQY6tAWo2AlAgBEHYAWpBudcAIARB0ABqEFggBAJ/QT0iAiAFQQVxDQAaIAtBMEYEQCAEQQAiBUGOrQFqNgJAIARB2AFqQYPgACAEQUBrEFhBPAwBC0E+QTwgBUEgcRsLIgI2AjAgBEHYAWpBy+4CIARBMGoQWAwBCyAFQYAIcUUNACAGKAIYIQUgBCAGKAIgNgIkIAQgBTYCICAEQdgBakGc0wAgBEEgahBYCyABIAlBBnRqLQAsQQhxBEAgBEHYAWpBk/ABQQAQWAsgBEHYAWoQYyEFIApBvAEgCigCbCAAKALgAUEAIAVBehD0CBoLIARB8AFqJAALxwsUAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQRBrIg4kACAAKAIIIRECQAJAAkACQAJAAkACQCABKAIAIgotAAAiCEEyaw4EAgMDAQALIAhBLUcNAgsgACAKKAIQIAUQgQshBQwCCyARQcsAQQAgBRCKAxoMAQsCQCACKAJQIggtAClBBHENACAIKAIgIgZFDQAgBigCHCADai0AAEUNACAERSEECyADQQAgA0EAShshBwNAAkAgByAURgRAIAMgCC8BLCIGIAMgBkobIQlBACEHIAMhBgNAIAYgCUYNAiAHIAgoAjQgBkECdGooAgAoAgAgCkZqIQcgBkEBaiEGDAALAAsgCCgCNCAUQQJ0aigCACIGBEAgBigCACAKRg0ECyAUQQFqIRQMAQsLIA5BADYCDAJAAkAgCigCBCIGQYAgcQRAIAooAhQoAhwoAgBBAUcNAQsgACAKQQRBAEEAIA5BDGoQwwshFQwBCyAKKAIcQQAgBkGAgIAQcRtFBEAgACgCACISIApBABCkCSEPQQUhFQJAIBItAFcNACAPQRRqIQYDQCAGKAIAIhYEQEEAIQxBACEQIA8oAhQgFkYEQCAPKAIMKAIUIRALIBYoAhwhDSADIQZBACETA0AgBiAILwEsTkUEQAJAIAgoAjQgBkECdGooAgAiCSgCACAKRw0AIA0gCSgCHEEBa0EEdCIXaiIYQQhqIgkoAgAiC0UNACAAIBMgCxDCCSETIBhBADYCCCAQRQ0AIAAgDCAQIBdqIhlBCGoiCSgCABDCCSEMIBlBADYCCAsgBkEBaiEGDAELCyASIA0QrgMgEARAIBIgEBCPAyAPKAIMIAw2AhQLIBYgEzYCHAJAIAxFDQAgDCgCAEEBRw0AIAwoAgghBiAMQQA2AgggEiAPKAIMEDMgDyAGNgIMCwJAIBYoAjAiCUUNAEEAIQYgCSgCACILQQAgC0EAShshCwNAIAYgC0YNASAJIAZBBHRqQQA7ARQgBkEBaiEGDAALAAsgFkE0aiEGDAELC0EAIQ0gEi0AVw0AIAAgD0EEQQAgACgCACAHQQJ0rRDFAiINIA5BDGoQwwshFSAKIA4oAgw2AhwLIBIgDxAzDAELIAAgCkEEQQAgACgCACAHIAooAgwQ9goiBiAGIAdIG0ECdK0QxQIiDSAOQQxqEMMLIRULIBFBIEEkIARFIAQgFUEERhsiCRsgDigCDEEAEIoDGiAIIAgoAigiBkGAEHI2AiggAigCSEUEQCAAIAAoAjhBAWsiCzYCOCACIAs2AhALIAZBgIDAAHEgA0EATHJFBEAgCCAGQYCQEHI2AigLIAIgAigCSCILIAdqIgY2AkgCQAJAAkAgAigCTCIHRSABKAIEKAIAIAZBFGytEKMMIgZFckUEQCACIAYgByAHQQhrKAIAEOUUNgJMDAELIAIgBjYCTCAGRQ0BC0EmQScgCRshBCAFIANrIRcgBiALQRRsaiEHIBVBAUchECADIQZBACEMA0AgBiAILwEsTkUEQCAKIAgoAjQgBkECdGooAgAoAgBGBEAgBiAXaiEJIAcCfyAQRQRAIBFBhwEgDigCDCITIAkQigMMAQsCQCANRQRAQQAhCwwBCyANIAxBAnRqKAIAIQsgDEEBaiEMCyARQd4AIA4oAgwiEyALIAkQ2wgLIgs2AgQgEUEyIAkQ8ggaAkAgAyAGRgRAIAcgBDoAECAHIBM2AgAgA0EASgRAIAcgAzYCDCAHIBc2AggMAgsgB0EANgIMDAELIAdBuwE6ABALIAdBFGohBwsgBkEBaiEGDAELCyADQQBMDQEgCCgCKEGAiMAAcQ0BIBFB/QAgAigCCEEAIAMQ2wgaDAELIAJBADYCSAsgACgCACANEDIgAyAUSg0CCyACKAJQLQAqQSBxRQ0AIAEtAA1BCHENAQsgAiABEKkMCyAOQRBqJAAgBQuCAQEBfwJAAkAgAUUNACABELkLRQ0AIAEtAAVBEHEEQCAAKAIIQdAAIAAgARCuCyACIANBAWsQ2wgaDwsgA0EAIANBAEobIQMgASgCFCEBA0AgAyAERg0CIAAgASAEQQR0aigCCCACIARqEPcIIARBAWohBAwACwALIAAgASACEPcICwuRAQIBfwF/A0ACQCABLwEKIgJBBHENACAAKAIABEAgASgCAC0ABEEBcUUNAQsgASkDKCAAKQNYg0IAUg0AIAFBgARBBCACQYAIcRtBBCADGyACcjsBCiABKAIQIgJBAEgNACABKAIEKAIYIAJBMGxqIgEgAS0ADkEBayICOgAOIAJB/wFxDQAgA0EBaiEDDAELCwumAgcBfwF/AX8BfwF/AX8BfyMAQRBrIggkAANAIAJBAWoiAiABLQAsSARAIAEgAkHgAGxqIgYiCUGsBmooAgBFDQEgBigCyAYiBS8BLg0BIAUpAwAgBINCAFINASAGQfgFaiEHIAYiCkGEBmoiBiADNgIAAkAgBS0AKUEBcQRAIAAgBSgCNCgCACAHQQBBACAAEJUJEKcMIQUgACgCCEENIAUgAxCKAxogACgCCEHAACAJKAKsBiADIAVBARD/AhoMAQsgBS8BGCEFIAAgACAHQQBBACAIQQxqEKsMIgcgBSAIKAIMIgsQrgwgACgCACALEDIgACgCCEHAACAJKAKsBiADIAcgBRD/AhoLIAlBADYCrAYgCkEANgKEBgwBCwsgCEEQaiQAC/QEDAF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQSBrIgokACABKAJQIg4oAiAhBiAOLwEuIQUgACAAKAIsIgsgDi8BGCIMIANqIg9qNgIsIAtBAWohCCAAKAIIIQcgACgCACIDIAMgBhDhChCgASENAkAgBUUEQEEAIQUMAQsgASgCCCEJQQAhAyAHQcsAQQAgCCAFIAtqENsIGiAHQSBBJCACGyAJEPIIGiAKIAYoAgA2AhAgB0Gp2QAgCkEQahDzCCAHQQkQ8QghECABIAdBFUEYIAIbIAlBACAIIAUQ/wI2AhQgBygCbCELIAcoAgAtAFcEf0GQgggFIAcoAmggEEEYbGoLIAs2AggDQCADIAVGDQEgB0HeACAJIAMgAyAIahDbCBogCiAGIAMQygw2AgAgB0Gz7gAgChDzCCADQQFqIQMMAAsACyAFIAwgBSAMSxshDANAIAUgDEZFBEACQCAAIA4oAjQgBUECdGooAgAiAyABIAUgAiAFIAhqIgYQpwwiCSAGRg0AIA9BAUYEQCAAIAgQlgkgCSEIDAELIAdB0AAgCSAGEIoDGgsCQAJAIAMvAQwiBkEBcQRAIAMoAgAtAAVBEHFFIA1Fcg0CIAUgDWohAwwBCyAGQYACcQ0BIAMoAgAoAhAhBgJAIAMtAAtBCHENACAGELoKRQ0AIAdBMiAFIAhqIAEoAgwQigMaCyAAKAIkDQEgBgJ/IAYgBSANaiIDLAAAEMALQcEARwRAIAMtAAAMAQsgA0HBADoAAEHBAAsiCcAQ7AxFDQELIANBwQA6AAALIAVBAWohBQwBCwsgBCANNgIAIApBIGokACAICysAIAItAAtBAXEEQCAAEL0LIgIgASgCLCIBQQFxOwECIAIgAUEBdjYCDAsLXgMBfwF/AX8gAUEAIAFBAEobIQQDQCADIARGRQRAAkAgACADEMQLIgUgAiADaiIBLAAAEMALQcEARwRAIAUgASwAABDsDEUNAQsgAUHBADoAAAsgA0EBaiEDDAELCwudAQIBfwF/AkAgA0UNACAAKAIIIQUgAkEfdSACcSEEA0ACQCACQQBKBEAgAywAAEHBAEwNASACIQQLIAQhAAJAA0AgACICQQJOBEAgAyACQQFrIgBqLAAAQcIASA0BDAILC0EBIQIgBEEATA0DCyAFQeAAIAEgAkEAIAMgAhD0CBoMAgsgA0EBaiEDIAFBAWohASACQQFrIQIMAAsACwt6AgF/AX8DQCAALQAAQSxHRQRAIAAoAgwgASACEK8MIAAoAhAhAAwBCwsgAigCGCEDA0AgBCACKAIMTkUEQAJAIAMtAApBBHENAEEAIAMoAgAgACABEPgKDQAgAyADLwEKQQRyOwEKCyADQTBqIQMgBEEBaiEEDAELCwteAQF/IwBBMGsiAyQAIANCADcDGCADQgA3AyAgA0IANwMQIANB6wA2AhQgAyABNgIMIAMgAjYCCCADIANBCGo2AiggA0EQaiAAELIJGiADLwEkIQEgA0EwaiQAIAFFC18CAX8BfyABQdAAahDMDANAIAEoAjwiAgRAIAEgAigCODYCPCAAIAIQzQwMAQUgASgCQCECA0AgAgRAIAIoAgAhAyAAIAIQOCABIAM2AkAgAyECDAELCyAAIAEQOAsLCxgAIAAgASgCHCACKAIAQQAgAi0ABBDoCQvnAgcBfwF/AX8BfwF/AX8BfyAAKAIIIQcgBCgCACEGAkACQAJAIAFBAWsOAgIAAQsgACAAKAIsIgggBmo2AixBACEBIAZBACAGQQBKGyELIAZBAWshCiAIQQFqIQkgBygCbCAGaiEMA0AgASALRwRAIAEgCWohCCABIAVqIQIgACAEIAFBBHRqKAIIEOsIIQYCQCABIApIBEAgB0E0IAIgDCAIENsIGgwBCyAHQTUgAiADIAgQ2wgaCyAHQX8gBkF+EL0KIAcoAmwiBkEASgRAIAcoAmggBkEYbGpBFmtBgAE7AQALIAFBAWohAQwBCwsgB0HQACAFIAkgChDbCBogCQ8LIAAQlQkhASAHQR0gAiADIAUgBhD/AhogB0HhACAFIAYgARDbCBogB0GKASACIAEgBSAGEP8CGiAHKAJsIgZBAEoEQCAHKAJoIAZBGGxqQRZrQRA7AQALIAAgARCWCSACIQgLIAgL5wYKAX8BfwF/AX8BfwF/AX8BfwF/AX8gASgCACIOKAIAIgwgAS0AIEEBcSIIRSIQaiAFaiELIAEoAgQhCiAGBH8gAyAGawUgACAAKAIsIgcgC2o2AiwgB0EBagshCQJ/IAIoAgwiBwRAIAdBAWoMAQsgAigCCAshDSAAKAIIIQcgACAAKAI4QQFrIg82AjggASAPNgIYIAAgDiAJIARBBUEBIAQbEOgJIAhFBEAgB0H+ACABKAIIIAkgDGoQigMaCyAFQQBMIAZyRQRAIAAgAyAJIAxqIBBqIAUQxgoLQQAhBkEAIQUCQCAKQQBKBEAgACABIAIgCSALEPAMIQUgACABKAIEIgMgACgCLCIEajYCLCAEQQFqIQQCfyAIRQRAIAdBESAJIAxqEPIIDAELIAdB+AAgASgCCBDyCAshDiAHQdoAIAQgCSABKAIEENsIGkEAIQggBygCAC0AVwR/QZCCCAUgBygCaCABKAIUQRhsagshCCAAKAIALQBXDQEgCCALIANrNgIIIAgoAhAiAygCEEEAIAMvAQYQ5xQaIAdBfyADQXgQvQogCCAAIAEoAgAgCiADLwEIIAMvAQZBf3NqEKkKNgIQIAdBDiAHKAJsIg9BAWoiCEEAIAgQ2wgaIAAgACgCOEEBayIINgI4IAEgCDYCECAAIAAoAixBAWoiAzYCLCABIAM2AgwgB0EKIAMgCBCKAxogB0GSASABKAIIEPIIGiANBEAgB0ERIA0gASgCGBCKAxoLQQAhCCAHKAJsIQMgBygCAC0AVwR/QZCCCAUgBygCaCAOQRhsagsiCCADNgIIIAAgCSAEIAEoAgQQxgpBACEEIAcoAmwhCCAHKAIALQBXBH9BkIIIBSAHKAJoIA9BGGxqCyIEIAg2AggLIA0EQCABKAIIIQQgB0E8IA0gBygCbEEEahCKAxogB0EgIARBABCKAxogB0EoIARBACAJIApqIAwgCmsQ/wIhBiAHQYIBIAQQ8ggaCyAFRQRAIAAgASACIAkgCxDwDCEFCyAHQYsBQYoBIAEtACBBAXEbIAEoAgggBSAJIApqIAsgCmsQ/wIaIAZFDQAgASgCHCIBRQRAIAcoAmwhAQtBACEAIAcoAgAtAFcEf0GQgggFIAcoAmggBkEYbGoLIgAgATYCCAsLmgYOAX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX8BfiMAQdAAayIHJAAgAigCUCEOIAIoAjghCiAAKAIAIgQoAgghBSAHIAAoAgQiCCACLQA8IgtBBnRqIg9BGGooAgAoAgA2AgAgBEEBQfXfACAHEKAKIAFBACABQQBKGyEMQQAhAQNAIAEgDEcEQCAAIAFB4ABsaiIDKALIBikDCCEQIAAoAgQgAy0AtAZBBnRqIgYtAC1BIHEEQCAFQcsAQQAgBigCKCINIA0gBigCHCgCHCgCAGpBAWsQ2wgaCyAFQYgBIAMoAvwFEPIIGiADKAKABiIDBEAgBUGIASADEPIIGgsgCSAQhCEJIAFBAWohAQwBCwsgCCALQQZ0aiIBQQhqIQZBACEIAkAgAS0ALEHAAHENACAOKQMIIAmEQn+FIQlBACEBA0AgASAAKAJcTg0BIAAoAmggAUEwbGoiAy8BCkGCgAJxBEAgAy8BDEGAwABHDQILAkAgAykDKCAJg0IAUg0AIAMoAgAiAy0ABEEDcQ0AIAQgCCAEKAIAIANBABCkCRDOCSEICyABQQFqIQEMAAsACyAHQoGAgIAQNwMIIAdBEGogBkHAABDlFBogB0EAOgA0IAQgBC0AGkEBajoAGiAEIAdBCGogCEEAQQBBAEGAIEEAEKsKIgsEQCACKAIEIQwgBCAEKAIsIgFBAWoiAzYCLCALKAIcIQICQCAPKAIYIgYtABxBgAFxRQRAIAUgBiAMQX8gAxCSCUEBIQAMAQsgBCABIAYQrwMiDS8BMiIAajYCLEEAIQEDQCAAIAFGDQEgBSAGIAwgDSgCBCABQQF0ai4BACABIANqEJIJIAFBAWohAQwACwALIAVBwAAgCigCBEEAIAMgABD/AiEGIAVBHSAKKAIAIAIgAyAAEP8CGkEAIQMgBSgCbCEBIAUoAgAtAFcEf0GQgggFIAUoAmggBkEYbGoLIgMgATYCCCAFQQogCigCCCAKKAIMEIoDGiALELQKCyAEKAIAIAgQMyAEEMwKIAQgBC0AGkEBazoAGiAHQdAAaiQAC8YBAgF/AX8gACgCCCIGKAIALQBXBH9BkIIIBSAGKAJoIAFBGGxqCyEFAkAgACgCAC0AVw0AIAYoAmwiACABIAAgAUobIQADQCAAIAFGDQECQCAFKAIEIAJHDQAgBS0AACIGQYcBRwRAIAZB3gBHDQEgBUHQADoAACAFQQI7AQIgBSgCCCEGIAUgBSgCDDYCCCAFQQA2AgwgBSADIAZqNgIEDAELIAUgBDYCBCAFQf4AOgAACyAFQRhqIQUgAUEBaiEBDAALAAsL0QcKAX8BfwF/AX8BfwF/AX8BfwF/AX8jAEFAaiIGJAAgACgCGCICKAIIIQcgAigCBCEDIAIoAgAhBQJAAkACQAJAAkACQAJAIAEtAAAiBEGnAWsOAwEEAQALIARBswFGDQAgAi0AGkECcUUNASAFKAJIIgJFDQEDQCACRQ0CAkAgAigCBCIAQQBOBEBBACABIAIoAgAgABD4CkUNAQsgAigCFCECDAELCyABLQAHQQNxDQFBACEAIAMoAgAiBEEAIARBAEobIQQDQCAAIARGDQIgAEEBaiEAIAMoAjAgAigCBEcNAAsgASgCKA0BQQIhBCAFKAIkDQUgBkEIakEAQTQQ5xQaIAZBqQE6AAggBiACKAIINgIkIAYgAigCDDsBKCAFIAcgBkEIahDxDCAFKAIkDQUgBygCFCAGLgEqIgJBBHRqIAE2AgQgASACOwEiIAEgBzYCKAwECyADDQELQQAhBAwDC0EAIQQgAygCACICQQAgAkEAShshACADQQhqIQNBACECA0AgACACRg0DIAEoAhwgAygCKEYEQCAFIAcgARDxDAwEBSADQUBrIQMgAkEBaiECDAELAAsAC0EAIQQgAi0AGkECcQ0BIAAoAhAgAS0AAkcNASABKAIoDQEgB0EkaiEEIAcoAiAhA0EAIQIDQAJAAkAgAiAEKAIAIghODQAgAygCACIAIAFGDQBBACAAIAFBfxD4Cg0BIAQoAgAhCAsCQCACIAhIDQAgBSgCACICLQBUIQggByACIAcoAiBBGCAEIAZBCGoQ8gwiAzYCIEEAIQAgBigCCCICQQBIDQAgAyACQRhsaiABNgIAIAEoAhQiBARAIAQoAgAhAAsgAyACQRhsaiIEIAUoAgAgASgCCCAAIAhB/wFxQQAQ4wMiCDYCBAJAAkAgASgCDCIJRQ0AIAgtAARBIHENACAEIgpBBGohBCAFIAUoAigiCEEBajYCKCADIAJBGGxqIgsgCDYCEAJAAkAgAEEBRw0AIAkoAhQiACgCAEEBRw0AQQAgACgCCCABKAIUKAIIQQAQ+AoNACADIAJBGGxqIgBBADoAFCAAIAEtAARBAnZBAXE6ABUMAQsgC0EBOgAUCyADIAJBGGxqIAooAgQoAgRBFHZBAXE6ABYMAQsgBEF/NgIQC0F/IQACQCABLQAEQQRxRQ0AIAMgAkEYbGotABUNACAFIAUoAigiAEEBajYCKAsgAyACQRhsaiAANgIICyABIAc2AiggASACOwEiDAILIANBGGohAyACQQFqIQIMAAsAC0EBIQQLIAZBQGskACAECzMCAX8BfyABIAAoAhgiAigCECIDRgRAQQAPCyACIAE2AhAgACABELEJGiACIAM2AhBBAQuOBAUBfwF/AX8BfwF/IAEtAAAhAiAAKAIAIQUCQAJAAkAgACgCGCIDKAIQBEAgAkGnAUcNA0EAIQAgAygCBCIEKAIAIgZBACAGQQBKGyECA0ACQCAAIAJHBEAgASgCHCAEIABBBnRqKAIwRw0BIAAhAgtBACEEIAIgBkcNAwwFCyAAQQFqIQAMAAsACwJAAkAgAkGnAWsOBgICAwMDAAELIAEtAAdBAXFFDQIgAyECA0AgAigCACIARQ0CIABBJGohAkEBIQQgASgCLCAARw0ACwwDCyACQbMBRw0BC0ECIQQgBSgCACIALQBXDQECfwJAIAMoAggiAgRAQQAhAANAIAIoAgAgAEoEQEEAIAIgAEEEdGooAgggAUF/EPgKRQ0DIABBAWohACADKAIIIQIMAQsLIAUoAgAhAAsCQCAAIAFBABCkCSIARQ0AIAAtAABBqAFHDQAgAEGsAToAAAsgAyAFIAMoAgggABDCCSICNgIIQX8hAEEBDAELIAMoAgghAkEACyEGIAIEQCABIAEoAgQiAkGAgIDAAHI2AgQgBSgCACABEKAIIAFBAEE0EOcUIgFBpwE6AAAgAkGABHEhAiAGBEAgAygCCCgCAEEBayEACyABIAA7ASAgASADKAIAKAIwNgIcIAMoAgwhACABIAI2AgQgASAANgIsCyAFKAIALQBXDQELQQAhBAsgBAs8AgF/AX8CQCABRQ0AA0AgAiABKAIATg0BIAEgAkEEdGoiAyAAIAMoAggQiww2AgggAkEBaiECDAALAAsLNAEBfwJAIAEoAgAiAiAAKAIYIgAoAgBODQAgAkECdCAAaigCBCIAQQBMDQAgASAANgIACwv7AQIBfwF/AkAgAS0ABEEgcQ0AIAIQ5AkNACAAKAIAIAMQuQMiAwRAQQEhBCADKAIMQRJHDQELQQAhAyAAKAIIIgRBACAEQQBKGyEFA0AgAyAFRwRAIAAoAhggA0EDdGooAgAiBCgCHCABKAIcRgRAIAQvASAgAS8BIEYNAwsgA0EBaiEDDAELCyABEOQJQcEARgRAIABBATYCEAsgACAAKAIIQQFqIgM2AgggACAAKAIAKAIAIAAoAhggA0EDdK0QqgciAzYCGCADRQRAIABBADYCCA8LIAAoAghBA3QiBCADakEIayABNgIAIAQgACgCGGpBBGsgAjYCAAsLgQIGAX8BfwF/AX8BfwF/QQEhBQJAIAAoAgQtAAANAEEAIQUgAS0AAEGnAUcNACABKAIEIgYgACgCFEEgcnENACAAKAIIIgRBACAEQQBKGyEIQQEhBQNAIAMgCEYNAQJAIAAoAhgiByADQQN0aigCACIEIAFGDQAgBCgCHCABKAIcRw0AIAQvASAgAS8BIEcNACACBEAgBBDkCUHBAEYNAyAAKAIYIQcgASgCBCEGCyAAIAAoAgxBAWo2AgwgASAGQd///3txQSByNgIEIAEgACgCACgCACAHIANBAXQiA0ECdEEEcmooAgBBABCkCTYCDAwCCyADQQFqIQMMAAsACyAFCyABAX9BASECIAEtAAdBIHEEQCAAQQA7ARRBAiECCyACC4QBBAF/AX8BfwF/IAAoAhghBAJAA0AgBCgCACACSgRAQQAgASAEIAJBBHRqKAIIIgNBfxD4CkEBTARAQQEhBSAAKAIAIAMQjQwiA0UNAyADKAIMQRJGDQMLIAJBAWohAgwBCwsgAS0ABUEQcQRAIABBADsBFEECDwsgACABEMsLIQULIAUL0ysdAX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfgF/AX4BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfyMAQRBrIhEkAAJAIAEoAgAiAygCACILKAIAIg8tAFcNACABKAIYIgUgAkEwbCIEaiIHKAIAIQkgA0EANgLwAyADQfADaiIUIAkoAgwQzgwhEAJ+IAktAAAiA0ExRgRAIAsgCRDBCw0CIAkoAhQhBCAFIAJBMGxqAn4gCS0ABUEQcQRAIBQgBBDPDAwBCyAUIAQQxAwLIg03AyAgDSAQhAwBCyAEIAVqIBQgCSgCEBDODCINNwMgAkACQCAJKAIMRQ0AIAkoAgRBgKAQcQ0AIAkoAhRFDQELIBQgCRDQDAwBCyANIBCECyENIBQoAgAEQCAFIAJBMGxqIgQgBC8BCkGAIHI7AQoLAkAgCSgCBCIGQQNxRQ0AIBQgCSgCJBCXDCESIAZBAXEEQCASIA0gEoQiDUIBiFYEQCASQgF9IRwMAgsgC0HnOEEAELICDAILIA1CAYggElQNAAJAIAAoAgBBAEwNACAALQAsQcAAcUUNACALQec4QQAQsgIMAgsgCSAGQX1xIgY2AgQLIAUgAkEwbGoiBCANNwMoIARCfzcDECAEQQA7AQwCQAJAIANBLWsiCEEMS0EBIAh0QbE+cUVyRQRAIAkoAgwQhwohCCAJKAIQEIcKIQYgBSACQTBsaiIMKQMgIBCDUCEKIAwoAhwiDkEASgRAIAgoAhQgDkEEdGpBCGsoAgAhCAsgBCIdQQxqIRMgBCIeQRRqIQ5B//8AQYAQIAobIQogACARIAggAxDRDARAIB4gESgCADYCFCAMIBEoAgQ2AhggHSADENIMIApxOwEMCyADQS1GBEAgBSACQTBsaiIFIAUvAQpBgBByOwEKCwJAIAZFDQAgACARIAYgAxDRDEUNACAGLQAEQSBxDQBBACEIIAkhBSAHIQQCQCAeKAIUQQBIDQAgDyAJQQAQpAkhBSAPLQBXBEAgDyAFEDMMBgsgASAFQQMQjwwiBEUNBSABKAIYIQcgASAEIAIQ0wwgBEEwbCEEIANBLUYEQCAEIAdqIgMgAy8BCkGAEHI7AQoLIAQgB2ohByABKAIYIgMgAkEwbGoiBCAELwEKQQhyOwEKIAsoAgAtAFBBgAFxDQAgBS0AACIGQTVHIAZBLUdxDQAgBS0ABEEBcQ0AIAUoAgwQ5AkiBiAFKAIQEOQJIgxHIAZBwwBIIAxBwwBIcnENAAJAIAsgBRC5AyIGRQ0AQQEhDCAGKAIMQRJGDQAgBSgCECEGIAsgBSgCDBCNDCEMIAsgBhCNDCEGIAwoAgAgBigCABBtDQELQYAQIQggAyACQTBsaiIDIAMvAQxBgBByOwEMCwJAAkAgBSgCDCIDLQAAQbEBRg0AIAUoAhAiBi0AAEGxAUYNACALIAMgBhC6AyALIAUoAhAgBSgCDBC6A0YNAQsgBSAFKAIEQYAIczYCBAsgBSAFKQIMQiCJNwIMIAUtAAAiA0E2TwRAIAUgA0E2a0ECc0E2ajoAAAsgByARKAIANgIUIBEoAgQhAyAHIA03AyggByAQIByENwMgIAcgAzYCGCAHIAUtAAAQ0gwgCGogCnE7AQwgBCEHDAILIANBMkcNASAJKAIEIgNBAXENASAIELoKDQEgCUGqAToAACAJQZ6aATYCCCAJIANBgICAgAJyNgIEIARCADcDKCAdQQA7AQwMAQsCQAJAAkACQAJAAkACQAJAAkACQAJAIAktAAAiCEEwaw4EAQwMAwALIAhBK0YNASAIQawBRw0LIAEtAAhBLEcNCiAJKAIUIgNFDQogCygCACIZIAkoAgggAygCACIEQQFBABDjAyIDRQ0KIAMoAgQiGkEEcUUNCiAJKAIUIQggAygCCCIDLQACIRMgAy0AASEKIAMtAAAhFyAEQQNOBEAgCCgCKCIDLQAAQfUARw0LIAMoAggiAy0AACIMRQ0LIAMtAAEgDCAXQf8BcUZyIAwgCkH/AXFGcg0LCyAIKAIYIRsgCCgCCBCHCiIVLQAAIh9BnAFHDQQgGS0AIkGAAXFFDQMMBgsgAS0ACEEsRw0JIAkoAhQhCCACQTBsIQZBACEDA0AgA0ECRg0KIAsgA0GWwwRqLQAAIA8gCSgCDEEAEKQJIA8gCCADQQR0aigCCEEAEKQJEKEJIgUgCRDUDCAAIAEgASAFQQMQjwwiBRDADCABKAIYIQQgASAFIAIQ0wwgA0EBaiEDIAQgBmohBwwACwALIAEoAhgiEyACQTBsIhlqIgMoAgAhFyADIAEoAgAiGigCACIWKAIAIg5CqAMQxQIiBjYCGAJAIAZFDQAgAyADLwEKQRByOwEKIAZBIGpBAEGAAxDnFCEDIAZBADoACSAGIBo2AgAgBkEANgIUIAZBADYCBCAGIAM2AhggBkKAgICAgAE3AgwgBiAXQSsQjgwgACAGEJAMIA4tAFcNACAaQfADaiEMIAYoAhghBCAGKAIMIQhCfyEQQn8hEgNAIBBQIAhBAExyRQRAAkAgBC8BDCIDQf8DcUUEQCAOQqADEOwCIgNFBEBCACESDAILIAQgAzYCGCAEQX82AhQgBEGACDsBDCAEIAQvAQpBIHI7AQogA0EgakEAQYADEOcUIQUgASgCACEHIANBADoACSADIAc2AgAgA0EANgIUIANBADYCBCADIAU2AhggA0KAgICAgAE3AgwgAyAEKAIAQSwQjgwgACADEJAMIAMgATYCBEIAIRJCACENAkAgDi0AVw0AQQAhBSADKAIMIgdBACAHQQBKGyEKIAMoAhghAwNAIAUgCkYNAQJAIAMoAgAtAABBLWsiB0EMTUEAQQEgB3RBsT5xG0UEQCADLwEMQcAARw0BCyAMIAMoAhQQlwwgDYQhDQsgA0EwaiEDIAVBAWohBQwACwALIA0gEIMhEAwBCyAELwEKIgVBCHENACAMIAQoAhQQlwwhDSAFQQJxBEAgDCAGKAIYIAQoAhBBMGxqKAIUEJcMIA2EIQ0LIA0gEoNCACADQQJxGyESIA0gEIMhEAsgCEEBayEIIARBMGohBAwBCwsgBiAQNwOgA0F/IRggEyACQTBsaiIDQX82AhQgA0GABDsBDAJAIBBQDQAgAUEBOgAJIAYoAgxBAkcNACAGKAIYIQdBACEKA0AgByAKENUMIgRFDQEgCkEBaiEKQQAhBQNAIAdBMGogBRDVDCIDRQ0BAkAgAy8BCiAELwEKckGAAXENACAELwEMIgdBPnFFDQAgAy8BDCIIQT5xRQ0AIAcgCHIiB0EacSAHRyAHQSZxIAdHcQ0AQQAgBCgCACgCDCADKAIAKAIMQX8Q+AoNAEEAIAQoAgAoAhAgAygCACgCEEF/EPgKDQAgASgCACgCACgCACAEKAIAQQAQpAkiE0UNAEEIQSAgB0EYcRsgByAHQQFrIAdxGyEIQTUhAwNAIAMiB0EBaiEDQQIgB0E1a3QgCEcNAAsgEyAHOgAAIAAgASABIBNBAxCPDBDADAsgBUEBaiEFIAYoAhghBwwACwALAAsgElANAEEAIQcDQCAHIBVBAUtyRQRAIAYoAgwhBSAGKAIYIQMDQCAFQQBMDQMgBUEBayEFIAMgAy8BCkG//wNxOwEKAkAgGCADKAIUIgRHBEAgDCAEEJcMIBKDQgBSDQELIANBMGohAwwBCwsgAygCGCEIIAMoAgAoAgwhGEEBIQcDQCAHRSAFQQBIckUEQAJAAkAgBCADKAIURwRAIAMgAy8BCkG//wNxOwEKDAELQQAhByADKAIYIAhHDQEgCEF+RgRAIBYgAygCACgCDCAYQX8Q+AoNAgsgAygCACgCEBDkCSIKQQAgAygCACgCDBDkCSITIApHGw0BIAMgAy8BCkHAAHI7AQoLQQEhBwsgA0EwaiEDIAVBAWshBQwBCwsgFUEBaiEVIAQhGAwBCwsgB0UNACAGKAIYIQMgBigCDCEFQQAhBEEAIQcDQCAFQQBMRQRAIAMtAApBwABxBEAgDiADKAIAKAIQQQAQpAkhByAaKAIAIAQgBxDCCSEEIAMoAgAoAgwhBwsgBUEBayEFIANBMGohAwwBCwsgFkExIA4gB0EAEKQJQQAQoQkiAwRAIAMgFxDUDCADIAQ2AhQgACABIAEgA0EDEI8MIgMQwAwgASADIAIQ0wwMAQsgDiAEEK4DCyABKAIYIBlqIQcMCAsgCSgCDCIDLQAAQacBRw0HIAZBAXEgAy4BIEEASHINByABIAtBNiAPIANBABCkCSAPQfkAQQBBABCgCRChCUGDARCPDCIERQ0HIAEoAhggBEEwbGoiBUIANwMgIAUgAygCHDYCFCADLgEgIQMgBUEEOwEMIAUgAzYCGCABIAQgAhDTDCABKAIYIAJBMGxqIgcgBy8BCkEIcjsBCiAFIAcpAyg3AygMBwtBACEGAkAgCygC6AEgFS4BICIDEMgLIhZFDQBChICQgICAgAIgFjMBEIhCAYNQDQAgFhBfIQYLIAsoAggiBCAEKALcAUGAgICAeEEBIANBAWt0IANBH0obcjYC3AEMAQsgH0H1AEcNASAVKAIIIQYLQQAhBCAGRQRAQQEhCgwDCyAXQf8BcSEOIBNB/wFxIRgDQCAGIAQiCGoiEy0AACIDRSADIA5GciADIApB/wFxRiADIBhGcnJFBEAgCEEBaiEEIAMgDEcNASAIQQJqIAQgBCAGai0AABshBAwBCwtBASEKIAhBAUwEQEEAIQQgCEEBRw0DIAYtAAAgDEYNAwsgE0EBay0AAEH/AUYNAUEAIQ4gF0H/AXEgA0YEQCATLQABRSEOCwJAIBlB9QAgBhDICSIERQ0AQQAhAyAEKAIIIgogCGpBADoAAEEAIQYDQCADIAhORQRAIAYgCmogCiADIAMgCmosAAAgDEZqIgNqLQAAOgAAIAZBAWohBiADQQFqIQMMAQsLIAYgCmoiA0EAOgAAAkAgGy0AAEGnAUcNACAbEOQJQcIARw0AIBstAAdBA3ENASAbKAIsIghFDQEgCC0AK0EBRw0BCwJAIAogESAGQQEQ9gJBAEoNACAGQQFGBEAgCi0AAEEtRg0BCyADQQFrIgMgAy0AACIIQQFqOgAAIAogESAGQQEQ9gIhBiADIAg6AAAgBkEATA0BCyAZIAQQoAggFhD0AQwFC0EAIQogH0GcAUcNAyALKAIIIgMgAygC3AFBgICAgHhBASAVLgEgIghBAWt0IAhBH0obcjYC3AEgDkUNAiAVKAIILQABRQ0DIAsgFSALEJUJIggQgQsaQQAhBiADKAIALQBXBH9BkIIIBSADKAJoIAMoAmxBGGxqQRhrCyIDQQA2AgwgCyAIEJYJDAMLQQEhCgtBACEEC0EAIQ4LIBYQ9AEgCg0AIAkoAhQoAhghDCAPIARBABCkCSEGAkAgGkEIcSIKDQAgCygCAC0AVw0AIAUgAkEwbGoiAyADLwEKQYAIcjsBCkEAIQMDQCAEKAIIIANqIgctAAAiBUUNASAHIAVBACIIQcCkA2ogBWotAABBf3NB3wFycToAACAGKAIIIANqIAVBwKEDai0AADoAACADQQFqIQMMAAsACyAPLQBXRQRAIAYoAggiAxBaIANqQQFrIgUtAAAhAyAKRQRAIA5BACADQcAARxshDiADQcChA2otAAAhAwsgBSADQQFqOgAACyALQTkgCyAPIAxBABCkCUGAtANBs4oCIAobIgUQ+AsgBBChCSIDIAkQ1AwgASADQYMCEI8MIQMgC0E4IAsgDyAMQQAQpAkgBRD4CyAGEKEJIgUgCRDUDCABIAVBgwIQjwwhBSAAIAEgAxDADCAAIAEgBRDADCABKAIYIAJBMGxqIQcgDkUNACABIAMgAhDTDCABIAUgAhDTDAsgCS0AACEICwJAAkACQAJAAkACQAJAAkACQAJAIAhB/wFxIgNBMWsOBQIDAwMBAAsgA0EtRw0CCwJAIAkoAgwiAxD2CiIFQQJIDQAgCSgCECIEEPYKIAVHDQAgAy0ABUEQcQRAIAQtAAVBEHENAQsgAS0ACEEsRw0AQQAhAwNAIAMgBUYNBCALIAkoAgwgAyAFEPcKIQQgCyAJKAIQIAMgBRD3CiEUIAsgCS0AACAEIBQQoQkiBCAJENQMIAAgASABIARBgYACEI8MEMAMIANBAWohAwwACwALIAhB/wFxQTFHDQELIAcoAhwNACAJKAIMIgMtAABBsQFHDQAgCS0ABUEQcUUNACAJKAIUIgUoAjQEQCAFLQAFQQJxRQ0BCyAFKAJEDQAgAS0ACEEsRw0AQQAhBQNAIAMQ9gogBUwNByABIAlBgoACEI8MIQMgASgCGCADQTBsaiAFQQFqIgU2AhwgACABIAMQwAwgASADIAIQ0wwgCSgCDCEDDAALAAsgAS0ACEEsRw0FAkAgCEH/AXEiAEEza0ECSQ0AQQAhBkEAIQRBACEDQQAhBQJAIABBqwFrDgIBAAYLIAkoAhQiBUUNBCAFKAIAQQJHDQQCQCAFKAIYIgMtAABBpwFHDQAgAygCLC0AK0EBRw0AIAkoAgghBEEAIQADQCAAQQRGDQEgBCAAQQN0QeCOBmooAgAQbQRAIABBAWohAAwBBSAAQQN0QeCOBmotAAQhBiAFKAIIIQRBASEFDAgLAAsACyAFKAIIIgMtAABBpwFHDQQgAygCLCIALQArQQFHDQQgDyAAELoHKAIIIgAoAgAoAkgiBEUNBCAAQQIgCSgCCCARIBFBDGogBBEHACIGQZYBSA0EIAUoAhghBEEBIQUMBQsgCSgCECEAQQAhBSAJKAIMIgQtAABBpwFGBEAgBCgCLC0AK0EBRiEFCyAARQRAIAQhA0EAIQQMAwsgAC0AAEGnAUcNASAAKAIsLQArQQFHDQEgBUEBaiEFIAAhAwwCCyABKAIYIAJBMGxqIgBBgMAAOwEMIAAgAC8BCkEGcjsBCgwECyAEIQMgACEEC0HEACEGAkACQCAIQf8BcSIAQTNrDgIAAwELQcYAIQYMAgsgAEGrAUcEQEEAIQYMAgtBxQAhBgwBC0EAIQZBACEEQQAhA0EAIQULA0AgAyEAIAQhAyAFQQBMDQEgBUEBayEFIBQgAxDODCINIBQgACIEEM4Mg0IAUg0AIAtBLkEAIA8gA0EAEKQJEKEJIQQgCS0ABEEBcUUgBEVyRQRAIAQgBCgCBEEBcjYCBCAEIAkoAiQ2AiQLIAEgBEEDEI8MIQcgASgCGCAHQTBsaiIEIA03AyAgBCAAKAIcNgIUIAAuASAhCCAEIAY6AA8gBEHAADsBDCAEIAg2AhggASAHIAIQ0wwgASgCGCACQTBsaiIHIAcvAQpBCHI7AQogBCAHKQMoNwMoIAAhBAwACwALIAEoAhggAkEwbGoiACAAKQMgIByENwMgCyARQRBqJAALygEEAX8BfwF/AX8jAEEQayIFJAAgACgCACgCACIHKAIAIQYgBUEANgIMAkACQAJAIAIgBUEMahDJCkUNACAFKAIMIghBAEgNACAGQZsBQQAQyAkiAkUNAiACIAg2AgggAiACKAIEQYAQcjYCBAwBCyAGQbABQQAQyAkiAkUNASACIAE2AhwLIAdBLkEAIAIQoQkiAkUNACAAIAJBAxCPDCECIAAoAhggAkEwbGoiAiAEOgAPIAJBwAA7AQwgAiADNgIUCyAFQRBqJAALow0mAX8BfgF/AX8BfwF+AX8BfwF/AX8BfgF+AX4BfwF+AX8BfgF+AX8BfwF/AX8BfwF/AX8BfwF+AX4BfwF/AX8BfwF/AX8BfwF/AX8BfgJAIAQEQCAAKAIAKAIALQBQQcAAcQ0BCyABLwEAIh5BP0sNAEGDA0GCAyADQYMQcRshHyAAQfADaiEkIANBwAFxISUgAEHQAGohJiADQYABcSEgIANBgBBxISdCfyAerSIRhkJ/hSEXIAStISEgA0HAAHFBAEchKEEBIQsDQAJAAkACQAJAAkACQCALQf8BcUUgDCAXWnIgEiAhVnJFBEAgElBFBEAgCSkDCCAVhCEVCyAFIQkgEiAhVARAIAIoAhggEqdBAnRqKAIAIQkgJw0HCyAJLQApQQRxRQ0BIAwgFyAMIAktAB0bIANBgAVxQYABRhshDAsgDCAXUg0BIB4hBwwHCyAgBEAgCUEAOwEeCyAVQn+FIRggACgCBCAJLQAQQQZ0aigCMCEWQgAhCANAIAggEVFFBEACQEIBIAiGIhMgDINCAFINACABIAinQQR0aiIpQQhqIhkoAgAQpQsiDUUNAAJAIA0tAABBpwFrDgMAAQABCyANKAIcIBZHDQAgJiAWIA0uASAgGCAfQQAQkwwiD0UNACAPLwEMIg5BAUYEQCAJLwEsIQpBACEEA0AgBCAKRg0CIARBAnQhByAEQQFqIQQgDyAHIAkoAjRqKAIARw0ACwsCQCAOQYIBcUUNACANLgEgQQBIDQAgACgCACIEICkoAggQjQwhByAEIA8oAgAQuQMiBEUNASAHKAIAIAQoAgAQbQ0BCyAMIBOEIQwLIAhCAXwhCAwBCwsgCSgCKCIEQYAgcQ0DQQAhCgJ/IARBgAJxBEBBACEOQQAhI0EBDAELQQAhByAJKAIgIg5FDQcgDi0AN0EEcQ0HIARBgIACcUUgDi0ANkEAR3EhCyAOLwEyISMgDi8BNAshBEIBIBKGIRMgBEH//wNxISpBACEaQQAhG0EAIRwDQCAKICpGDQNBASEEAkACQCAKIAkvARgiDU8NACAKIAkvAS5JDQAgHyAJKAI0Ig8gCkECdGooAgAiBy8BDCIEcQRAQQAgCyAEQYADcRshCwwCCwJAIARBAXFFDQAgDUEBayEZIAcoAgAhFCAKIQcDQCAHIBlGDQFBACEEIA8gB0EBaiIHQQJ0aigCACgCACAURw0ACwwBC0EBIQQLAkACQAJ/AkAgDgRAQX8gDigCBCAKQQF0ai8BACIHIAcgDigCDCIPLwEgRhvBIRAgDigCHCAKai0AAEEBcSEdIAtB/wFxDQFBACELDAQLIAtB/wFxIQ1BfyEQQQAhHUEAIQtBASIHIA0NARoMAwsgEEEASA0BQQEiByAKIA1JDQAaIA8oAgQgEEEMbGotAARBD3FBAEcLIgchCwwBCyAQQX5HIQsLQgAhCANAIARB/wFxQQBHIAggEVRxIgdFDQQCQCAMIAiIp0EBcQ0AIAEgCKdBBHRqIhQiK0EIaiIZKAIAIg8QpQsiDUUNACAEQQAgJRshBAJAAkAgEEF/TgRAAkAgDS0AAEGnAWsOAwAEAAQLIA0oAhwgFkcNAyAQIA0uASBHDQMgEEF/Rw0BDAILIA0gDigCKCAKQQR0aigCCCAWENgMDQIgKygCCCEPCyAAKAIAIA8QjQwoAgAgDigCICAKQQJ0aigCABBtDQELICAEQCAJIApBAWo7AR4LAkAgKCAHQQFzcg0AIBwEQEEBIRwgGyAdc0H/AXEgFC0AEEEBcUYNAQwHC0EBIRwgFC0AEEEBcSAdcyIbRQRAQQAhGwwBCyAGIAYpAwAgE4Q3AwALIBQtABBBAnEEQCAKIAkvARhHDQYgCSAJKAIoQYCAIHI2AigLQQEgGiAQQX9GGyEaQgEgCIYgDIQhDAwCCyAIQgF8IQgMAAsACyAKQQFqIQoMAAsAC0H/ASEHIAtB/wFxDQUDQCARQgJTBEBBACEHDAcLIAxCfyARQgF9IhGGQn+FIgiDIAhSDQALIBGnIQcMBQsgC0EAIAogI08bQQAgChshCwsgCyAaciEEQQAhCyAEQf8BcUUNAQsgCSkDCCAihCIiQn+FISxCACEIA38gCCARUQR/QQEFAkBCASAIhiITIAyDQgBSDQAgJCABIAinQQR0aigCCCIEEM4MIhhQBEBBACAEEMoJRQ0BCyATQgAgGCAsg1AbIAyEIQwLIAhCAXwhCAwBCwshCwsgEkIBfCESDAALAAsgB8ALHwEBfyAAQQtOBEAgAK1C//8DgxCbBEEhayEBCyABwQs8AgF/AX4CQCABRQ0AA0AgAiABKAIATg0BIAAgASACQQR0aigCCBDODCADhCEDIAJBAWohAgwACwALIAMLZwMBfwF/AX8Cf0EBIgIgAS0AAEGsAUcNABogASgCFCIEBEAgBCgCACEDCyAAKAIAKAIAIgIgASgCCCADIAItAFRBABDjAyIBBEBBACICIAEtAAdBAXFFDQEaCyAAQQE7ARRBAQsiAgssAQF/A0AgASgCACICBEAgASACKAIUNgIAIAAgAigCABAzIAAgAhA1DAELCwtxAgF/AX8CQCAAKAIUIAEoAihHDQAgAC0ADEGCAXFFDQAgAS0AJEHYAHEEQCAAIAEQ3AxFDQELIAApAyAgAoNCAFINACAAKAIYIgRBAEgNACAAKAIAIAEoAhAoAgQgBEEMbGosAAUQ2wxBAEchAwsgAwtvAgF/AX8Cf0EAIAEvATAgAk4NABpBByIDIAAgAkEHakF4cSICQQJ0rRDsAiIERQ0AGiAEIAEoAjQgAS8BMEECdBDlFCEDIAEoAjQiBCABQTxqRwRAIAAgBBA1CyABIAI7ATAgASADNgI0QQALIgML+QIEAX8BfwF/AX8jAEGwAWsiAyQAIAAoAgghBSABKAIEIQEgAi0APCEEIAAoAgAhBiADQYACOwGsASADQQA2AqgBIANC5ICAgIDAss07NwOgASADIAY2ApgBIAMgASAEQQZ0aiIEQQhqNgIgIAMgA0EwajYCnAEgA0GYAWpB34IDIANBIGoQWAJAAkAgAigCUCIBLQApQQFxBEAgBCgCGCICLgEgIgFBAEgNASADIAIoAgQgAUH//wNxQQxsaigCADYCECADQZgBakHEpwIgA0EQahBYDAILIAEvAS4hAgNAIAIgAS8BGE8NAiABKAIgIAIQygwhBCABLwEuIAJJBEAgA0GYAWpBvp4DQQUQTgsgAyAENgIAIANBmAFqQcSnAiADEFggAkEBaiECDAALAAsgA0GYAWpBhqgCQQAQWAsgA0GYAWpBzYIDQQEQTiADQZgBahBjIQIgBUG8ASAFKAJsIAAoAuABQQAgAkF6EPQIGiADQbABaiQAC0gBAX9B8a8CIQICQAJAAkAgACgCBCABQQF0ai8BACIBQf7/A2sOAgIAAQtBjq0BDwsgACgCDCgCBCABwUEMbGooAgAhAgsgAgvfAQEBfyAEBEAgAEG+ngNBBRBOCyACQQJOBEAgAEHyggNBARBOC0EAIQQgAkEAIAJBAEobIQYDQCAEIAZHBEAgBARAIABBtNoCQQEQTgsgACABIAMgBGoQygwQViAEQQFqIQQMAQsLAkAgAkECTgRAIABBACIEQc2CA2pBARBOIAAgBUEBEE4gAEHyggNBARBODAELIAAgBUEBEE4LQQAhBANAIAQgBkcEQCAEBEAgAEG02gJBARBOCyAAQe+vAkEBEE4gBEEBaiEEDAELCyACQQJOBEAgAEHNggNBARBOCwt+AwF/AX8BfyAAKAIMIgFBAEoEQCAAKAIAKAIAKAIAIQIgACgCGCIAIAFBMGxqQTBrIQMDQCAALwEKIgFBAXEEQCACIAAoAgAQMyAALwEKIQELIAFBMHEEQCAAKAIYIgEQzAwgAiABEDILIAAgA0chASAAQTBqIQAgAQ0ACwsLDwAgACABEJsMIAAgARA4CxIAIAFFBEBCAA8LIAAgARDQDAvaAQUBfgF/AX8BfwF/A0AgAQRAIAEoAiAhBSAAIAEoAhwQxAwgACABKAIoEMQMhCAAIAEoAjAQxAyEIAAgASgCJBDODIQgACABKAIsEM4MhCAChCECQQAhAwJAIAVFDQADQCADIAUoAgBODQEgACAFIANBBnRqIgQoAhwQzwwgAoQhAiAELwAtIgZBgAhxRQRAIAAgBCgCNBDODCAChCECIAQvAC0hBgsgBkEEcQRAIAAgBEFAaygCABDEDCAChCECCyADQQFqIQMMAAsACyABKAI0IQEMAQsLIAILQAIBfgF/IAEoAgQiA0EgcSABLQAAQacBR3JFBEAgACABKAIcEJcMDwsgA0GAgIQEcUUEQCAAIAEQ1gwhAgsgAgu7AQQBfwF/AX8BfyACLQAAIgRBsQFHIANBNmtBA0tyRQRAIAIoAhQoAggiAi0AACEECwJAIARB/wFxQacBRwRAIAAoAgAiBEEAIARBAEobIQcDQCAFIAdGDQIgACAFQQZ0aigCGEEIaiEDAkADQCADKAIAIgRFDQEgBEEUaiEDIAQoAihFDQALIAAgASACIAUQ1wwPCyAFQQFqIQUMAAsACyABIAIoAhw2AgAgASACLgEgNgIEQQEhBgsgBgtBAQF/QQEhAQJAAkACQAJAIABBLWsOBgECAgIDAAILQYACIQEMAgtBgAEhAQwBC0ECIABBNWt0IQELIAFB//8DcQs1ACAAKAIYIgAgAUEwbGoiASACNgIQIAEgACACQTBsaiICLwEIOwEIIAIgAi0ADkEBajoADgswAQF/AkAgAEUNACABKAIEQQNxIgJFDQAgACAAKAIEIAJyNgIEIAAgASgCJDYCJAsLNwEBfyAALwEMQYAIRwRAQQAgACABGw8LIAEgACgCGCIAKAIMSARAIAAoAhggAUEwbGohAgsgAgvmAQIBfgF/IAEtAABBswFGBEAgACABKAIcEJcMIQILIAEoAgwiAwRAIAAgAxDQDCAChCECCwJAIAEoAhAiAwRAIAAgAxDQDCAChCECDAELIAEoAgQiA0GAIHEEQCADQcAAcQRAIABBATYCAAsgACABKAIUEM8MIAKEIQIMAQsgASgCFCIDRQ0AIAAgAxDEDCAChCECCwJAAkAgAS0AAEGoAWsOBQABAQEAAQsgAS0AB0EBcUUNACAAIAEoAiwoAggQxAwgACABKAIsKAIMEMQMhCAAIAEoAiwoAigQzgyEIAKEIQILIAILxwEEAX8BfwF/AX8DQCAAIANBBnRqIgQoAhhBCGohBSAEKAIwIQYDQCAFKAIAIgQEQAJAIAQoAihFDQBBACEFA0AgBSAELwEyTw0BAkAgBCgCBCAFQQF0ai8BAEH+/wNHDQAgAiAFQQR0IgcgBCgCKGooAgggBhDYDA0AQQAgBCgCKCAHaigCCBDKCQ0AIAFBfjYCBCABIAY2AgBBAQ8LIAVBAWohBQwACwALIARBFGohBQwBCwsgA0EBaiIDIAAoAgBIDQALQQALEwBBACAAEIcKIAEQhwogAhD4CgsUACAAIAAoAgwQ5Ak6ABggABCWDAugAQMBfwF/AX8jAEFAaiIEJAACfyABKAIAIgMoAgwiBRC5CwRAIAEoAhwhASAEQTU6AAggBEEANgIMIAQgAUEEdEEQayIBIAUoAhRqKAIINgIUIAQgAygCFCgCHCABaigCCDYCGCAEQQhqIQMLQQAgAyACwBDbDEUNABpBACEBQYC0AyAAIAMQuQMiA0UNABogAygCAAshAyAEQUBrJAAgAwt1AgF/AX8gACgCDBDkCSECAkAgACgCECIDBEAgAyACEMALIQIMAQsgAC0ABUEQcQRAIAAoAhQoAhwoAgggAhDACyECDAELIAINAEEBDwtBASEAIAJBwgBOBEAgAkHCAEYEQCABQcIARg8LIAFBwgBKIQALIAALPAIBfwF/AkAgACgCACIAKAIEIgNBA3FFDQAgACgCJCABKAIoRw0AIAEtACRBGHFFIANBAnFFciECCyACC0UDAX8BfwF/IAFB3ABqIQMDQCACIAEoAgBORQRAIAMgAkECdGoiBCgCABD0ASAEQQA2AgAgAkEBaiECDAELCyAAIAEQNQuICw8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEFAaiIOJAAgBCgCECEMIAAoAgQhEiAAKAIIIgktABAhDyAAKAIAIggoAgQhECAIKAIAIQ0gBCgCACERIAZBADYCACAJIAE3AwAgEUEAIBFBAEobIRMgBCgCBCEIA0AgCiATRkUEQCASKAIYIQsgCEEAOgAFAkAgCyAIKAIIQTBsaiILKQMgIgEgAoMgAVINACALLwEMIANxDQAgB0UEQCALLQAPQcsAa0H/AXFB/QFLDQELIAhBAToABQsgCEEMaiEIIApBAWohCgwBCwsgDEEAIBFBA3QQ5xQhAyAEQQA2AjggBEIZNwMwIARCrr6elOrV0LbUADcDKCAEQQA2AiAgBEIANwIUIBAgD0EGdGoiCikDOCEBIARBADYCWCAEIAE3A0AgDSgCACIIIAoiFEEYaigCACIKELoHKAIIIQwgCCAIKAI4QQFqNgI4IAwgBCAMKAIAKAIMEQAAIQsgDSgCACIIIAgoAjhBAWs2AjgCQCALRSALQRNGcg0AIAtBB0YEQCAIEJUBDAELIAwoAggiCEUEQCAOIAsQsQI2AiAgDUGz7gAgDkEgahCyAgwBCyAOIAg2AjAgDUGz7gAgDkEwahCyAgsCQCAKKAI0LQARRQ0AQQAhCCANKAIAKAIUIgpBACAKQQBKGyEKA0AgCCAKRkUEQCANIAgQrwkgCEEBaiEIDAELCyANKAJYRQ0AQQAhCANAIAggCkYNASANQQAgCBC1CSAIQQFqIQgMAAsACyAMKAIIEEBBACEIIAxBADYCCAJAIAsEQCALQRNGDQEgCyEIDAELIAkoAjRBACARQQJ0EOcUGiAJQgA3AyAgCUIANwMYIAQoAgQhDEF/IQ9BACEKA0AgCiATRwRAAkAgAyAKQQN0aiIVKAIAIghBAEwNAAJAAkAgCCARSg0AIAwoAggiEEEASA0AIBAgEigCDE4NACAJKAI0IAhBAWsiC0ECdGoiFigCAA0AIAwtAAUNAQsgDiAUKAIYKAIANgIQIA1B5PwAIA5BEGoQsgJBASEIDAQLIAkgCSkDACASKAIYIBBBMGxqIggpAyCENwMAIBYgCDYCAAJAIBUtAARFDQAgBSAKdkEBcSAKQQ9LckUEQCAJIAkvAR5BASALdHI7AR4LIAgtAA9BygBHDQAgCSAJLQAcQQJyOgAcCyALIA9KIRACQCAEKAJYQQEgCnRBACAKQSBJG3EEQCAJIAkoAiRBASALdHI2AiQMAQsgCC0ADEEBcUUNACAEQQA2AiAgBCAEKAI4QX5xNgI4IAZBATYCAAsgCyAPIBAbIQ8gCC0AD0HLAGtB/wFxQf4BSQ0AQQAhCCAGKAIARQRAA0AgCCAKRg0CIAhBA3QhCyAIQQFqIQggAyALaigCAEEASg0ACwsgBCgCHARAIAQoAhgQQCAEQgA3AxgLIAdBATYCAEEAIQgMAwsgDEEMaiEMIApBAWohCgwBCwsgCSAPQQFqOwEsQX8gDyAPQQBIG0EBaiELQQAhCAJAA0AgCCALRg0BIAhBAnQhCiAIQQFqIQggCiAJKAI0aigCAA0ACyAOIBQoAhgoAgA2AgAgDUHk/AAgDhCyAkEBIQgMAQsgCSAEKAIUNgIYIAkgCS0AHEH+AXEgBC0AHEEBcXI6ABwgBEEANgIcIAkgBCgCGDYCIEEAIQggBCgCIARAIAQoAgghCAsgCUEAOwESIAkgCDoAHSAJIAQrAygQmQQ7ARQgCSAEKQMwEJsEOwEWIAkgCSgCKEH/X3EgBCgCOEEMdEGAIHFyNgIoIAAgCRDfDCEIIAktABxBAXFFDQAgCSgCIBBAIAkgCS0AHEH+AXE6ABwLIA5BQGskACAIC5oFBgF/AX8BfwF/AX8BfwJAIAAoAhQiAkUEQEHlACECIAAoAgwiAUUNASABQQA7AQBB5QAPCyAAKAIAIgcoAgAoAgAhBiAAIAJBAWs2AhQCQCAHKAI8IgJFDQAgASgCKEGABHFFDQAgAS0AECEEA0ACQCACLQAQIARHDQAgAi0AKUECcUUNACABAn8gAiABEOYMBEAgASACLgEUIgMgAS4BFCIFIAMgBUgbOwEUIAEuARYiAyACLgEWIgVBAWsgAyAFSBsMAQsgASACEOYMRQ0BIAEgAi4BFCIDIAEuARQiBSADIAVKGzsBFCABLgEWIgMgAi4BFiIFQQFqIAMgBUobCyIDOwEWCyACKAI4IgINAAsLIAAoAgwiBARAQQAhAiABLwEsRQ0BIAQgASkDACABLgEUIAEuARYQ5AxBAA8LIAdBPGogARDnDCICRQRAQQAPCwJAAkAgAigCACIDRQRAIAIgBkLIABDsAiIDNgIAIAMNAUEHDwsgA0E4aiECA0AgAigCAEUNAiACIAEQ5wwiAkUNAiACKAIAIgRFDQIgAiAEKAI4NgIAIAYgBBDNDAwACwALIANBAzsBMCADQQA7ASwgA0EANgI4IANBADYCKCADIANBPGo2AjQLIAYgAxDlDAJ/AkAgAS8BLCICIAMvATBNDQAgBiADIAIQyAxFDQAgA0EAQTAQ5xQaQQcMAQsgAyABQTAQ5RQiAigCNCABKAI0IAIvASxBAnQQ5RQaIAEoAigiBEGACHEEQCABQRxqIgIgAS0AHEH+AXE6AABBAAwBC0EAIgIgBEGAgAFxRQ0AGiABQQA2AiBBAAshAiADLQApQQRxDQAgAygCICIBRQ0AIAEvADdBA3FBA0cNACADQQA2AiALIAIL0wEFAX8BfwF/AX8BfwJAIAFBwABxDQAgAigCACgCACEEA0AgAy0AAEEsRgRAIAAgASACIAMoAgwQ4AxFDQIgAygCECEDDAELC0EAIAQgBCgCAC0AIkGAAXEbIQcgAUEgcSEIIAIoAhghAUEAIQQDQCAEIAIoAgxODQECQAJAIAEoAgAiBi0ABEEBcQRAIAYoAiQgAEYNAQwCCyAIDQELIAcgBiADIAAQsgtFDQAgAS0ACkGAAXENAEEBIQUMAgsgAUEwaiEBIARBAWohBAwACwALIAULzAMJAX8BfwF/AX8BfwF/AX4BfgF+IwBBEGsiBiQAIAEpAwgiCSABKQMAhEJ/hSEKIAAoAhghBCAAKAIUIQcDQCAHQQBMRQRAAkAgBCkDKCILIAqDQgBSIAkgC4NQcg0AIAQtAApBAnENACABLwEsIQMDQCADBEAgASgCNCADQQFrIgNBAnRqKAIAIgVFDQEgBCAFRg0CIAUoAhAiBUEASA0BIAAoAhggBUEwbGogBEcNAQwCCwsgACgCACgCABDeCwJAIAEpAwgiCSAEKQMoUg0AIAQtAAxBP3FFBEAgACgCACgCBCABLQAQQQZ0ai0ALEHIAHENAQsgASABKAIoQYCAgARyNgIoCyABLwEWIQMgBC4BCCIFQQBMBEAgASADIAVqOwEWDAELIAEgA0EBazsBFiAELQAMQYIBcUUNACAEKAIAKAIQIQMgBkEANgIMIAMgBkEMahDJCiEDQRRBCkEUIAYoAgwiBUECSBsgBUF+TBtBFCADGyIDIAhB//8DcU0NACAEIAQvAQpBgMAAcjsBCiADIQgLIARBMGohBCAHQQFrIQcMAQsLIAIgCEH//wNxayIDIAEuARZIBEAgASADOwEWCyAGQRBqJAAL2gEFAX8BfwF/AX8BfyMAQTBrIgMkAAJAIAAoAhAiBkUEQAwBCyABLQA4QRBxRQRAIAEvATQhB0EAIQADQCAAIAdGDQIgAEEBdCEFIABBAWohACAFIAEoAgRqLgEAQT9IDQALCyADQQhqIgBCADcDACADQgA3AxAgA0EBIgVBPGo2AgggA0IANwMAIAMgAjYCJCADIAE2AiAgA0HsADYCBCADIANBIGo2AhggA0EAOwEoIAMgBhCxCRpBAEGAgIAgQcAAIAMtACgbIAMtACkbIQQLIANBMGokACAEC90SIAF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX4BfwF/AX8BfwF/AX8jAEHgAGsiEiQAAkAgACgCACgCACITKAIkBEAgEygCDCEHDAELIBMoAgAhDwJ/QRhBvwMgACgCCCIEKAIoIhZBIHEbIgUgAi8ANyIHQYQCcUUNABogBUGDA3EgBSAHQQRxGyIFIAdBgAJxRQ0AGiAFIAVBvAJxIAEtACVBAnEbCyEFIAQvARwhFyAELwEWIRQgBCkDACEYIAQvAS4hGSAELwEaIRogBC8BLCEQIBIgACgCBCABKAIoIAQvARgiCSAFIAIQlQwhBSAEQQA7ARIgEEEBaiEbIAIoAgguAQAiHhDDDCIcQf//A3EhH0EAIQcCQANAIAcgBUVyDQECQAJAAkAgBS8BDCIMQYACRwRAIAUtAApBgAFxRQ0BC0EAIQcgAiAJEJQMDQELQQAhByAEKQMIIh0gBSkDIINCAFINACAFIiBBC2oiES0AAEEBcSAMQRBGcQ0AIAEtACRB2ABxBEAgBSABENwMRQ0BCyAAAn8gAi0ANgRAQQIiBiACLwEyQQFrIAlGDQEaC0EBCyIGIAAtABByOgAQIAQgEDsBLCAEIBc7ARwgBCAaOwEaIAQgCTsBGCAEIBY2AiggECIGIAQvATBPBEAgDyAEIBsQyAwNAiAEKQMIIR0gBC8BLCEGCyAEIAZBAWoiCDsBLCAEKAI0IAZBAnRqIAU2AgAgBCAFKQMgIBiEIB1Cf4WDNwMAAkAgDEEBcQRAAkAgBSgCACINLQAFQRBxBEBBASAIQf//A3EiBiAGQQFMG0EBayEOQQAhBkEuIQgDQCAGIA5GDQIgBCgCNCAGQQJ0aigCACIRBEAgCEEAIBEoAgAgDUcbIQgLIAZBAWohBgwACwALQQAhCCANKAIUIgZFDQAgBigCACIGRQ0AIAasEJsEQf//A3EhCAsCQCACLQA3QYABcUUgHEEKSHINACACKAIIIAlBAXRqLwEAIAggH2prIAjBEMMMakEKakGAgAJxRQ0AIANBAUoNAyAPLQBSQQJxDQMgBCAEKAIoQYCAwAByNgIoCyAEIAQoAihBBHIiBzYCKAwBCyAMQYIBcQRAIAIoAgQgCUEBdGouAQAhBiAEIAQoAigiCEEBciIHNgIoQYEgIRECQAJAIAZBf0YNACADIAZBAEhyDQEgAi8BMiIGQQFrIAlHDQEgAi0AN0EIcQ0AAkAgBkEBRw0AIAItADZFDQAgDEECRg0BC0GBgAQhEQsgBCAIIBFyIgc2AigLQQAhCCASLQAZQQJJDQEgBCAHQYCAgAFyIgc2AigMAQsgDEGAAnEEQCAEIAQoAihBCHIiBzYCKEEAIQgMAQsgASgCKCEhQQEhBkEBIAUoAgAoAgwQ9goiByACLwE0IAlrIgggByAISBsiByAHQQFMGyEVAkADQCAGIBVGDQEgBSgCACIHKAIQIg4iIkEUaiEIIAZBBHQiDSAHKAIMKAIUaigCCCEHIA4tAAVBEHEEQCAiKAIUQRxqIQgLAkAgBy0AAEGnAUcNACAHKAIcICFHDQAgBy8BICACKAIEIAYgCWoiDkEBdGovAQBHDQAgAigCHCIKIA5qLQAAIAkgCmotAABHDQAgCCgCACANaigCCCIKIAcQ5AkQwAshDUHEACEIAkAgBy4BICILQQBIDQAgAigCDCIjLgEiIAtMDQAgIygCBCALQQxsai0ABSEICyANQf8BcSAIQf8BcUcNACATIAcgChC6AyIHRQ0AIAcoAgAgAigCICAOQQJ0aigCABBtDQAgBkEBaiEGDAELCyAGIRULIAQoAighBiAMQSRxBEAgBCAVOwEaIAQgBkEiciIHNgIoQQAhCCAFIQpBACELICAtAAtBAXFFDQEgDyAEIAQvASxBAWoQyAwNAyAEIAQvASwiB0EBajsBLCAEKAI0IAdBAnRqIAVBMGoiCzYCACAEQQE7ARwgBCAEKAIoQRByIgc2AigMAQsgBCAVOwEcIAQgBkESciIHNgIoQQAhCCAGQSBxBH8gBCgCNCAELwEsQQJ0akEIaygCAAVBAAshCiAFIQsLAkAgBAJ/IAdBAnEEQCALIAogBC4BFiIGEOoMEOoMIQUCQCAKRSALRXINACAKLgEIQQBMDQAgBUEUayAFIAsuAQhBAEobIQULQX9BACAKGyALQQBHayAGaiIGQQogBcEiBSAFQQpMGyIFIAUgBkobDAELIAQgBC8BGEEBaiIGOwEYAkAgBS4BCCIFQQBKDQAgAigCBCAJQQF0ai4BAEEASA0AIAQvARYgBSAIa2oMAQsgBCAELwEWIAIoAgggBkH//wNxQQF0aiIFLwEAIAVBAmsvAQBraiIFOwEWIAxBgAJxRQ0BIAVBCmoLIgU7ARYLIAVB//8DcSEGIBwgAi8AN0EDcUEDRgR/IAZBEGoFIAYgAi4BMEEPbCABKAIQLgEobWpBAWoLIgbBEMgKIQYgB0HAgoAgcUUEQCAGIAVBEGrBEMgKIQYLIAQgBSADIAhqIgxqOwEWIAQgBiAMajsBFCAAKAIEIAQgHhDhDCAAIAQQ3wwhByAEIBQgBSAEKAIoIgZBAnEbOwEWAkAgBkEQcQ0AIAQvARgiBSACLwE0Tw0AIAIvATIgBU0EQCACLwA3QQNxQQJGDQELIAVBBE8EQCATEN4LCyAAIAEgAiAMwRDjDBoLIAQgFDsBFgsgEhCWDCEFDAELC0EAIQcLIAQgGTsBLiAEIBc7ARwgBCAaOwEaIAQgCTsBGCAEIBg3AwAgBCAWNgIoIAQgEDsBLCAEIBQ7ARYgCSAZRw0AIAkgEEcgCUEBaiIFIAIvATJPcg0AIAIvADdBwAFxQYABRw0AIA8tAFFBwABxDQAgAigCCCAFQQF0ai4BAEEqSA0AIA8gBCAbEMgMIgcNACAEIAQvARhBAWo7ARggBCAELwEuQQFqOwEuIAQgBC8BLCIGQQFqOwEsQQAhByAEKAI0IAZBAnRqQQA2AgAgBCAEKAIoQYCAAnI2AiggBCAELwEWIAIoAggiBiAJQQF0ai8BACAGIAVBAXRqLwEAayIFazsBFiAAIAEgAiADIAVqQQVqwRDjDBogBCAJOwEuIAQgCTsBGCAEIBQ7ARYgBCAWNgIoCyASQeAAaiQAIAcLhAIHAX8BfwF/AX8BfwF+AX8gAC8BACIGIQUgAEEIaiIIIQQCQAJAA0AgBUH//wNxBEAgAiAELgEIIgdMBEAgBCkDACABgyABUQ0DCyACIAdOBEAgBCkDACIJIAGDIAlRDQQLIARBEGohBCAFQQFrIQUMAQsLIAZBAksEQEEBIQUgCCEEA0AgBC4BCCEHIAUgBkZFBEAgCCAFQQR0IgpqIAQgByAAIApqLgEQShshBCAFQQFqIQUMAQsLIAIgB04NAgwBCyAAIAZBAWo7AQAgACAGQQR0aiIEIAM7ARIgBEEIaiEECyAEIAI7AQggBCABNwMAIAQuAQogA0wNACAEIAM7AQoLC4IBAgF/AX8CQCABKAIoIgJBgIgBcUUNAAJAAkAgAkGACHFFDQAgAS0AHEEBcUUNACABQSBqIgIoAgAQQCABIAEtABxB/gFxOgAcDAELIAJBgIABcUUNASABIgNBIGoiAigCACIBRQ0BIAAgASgCEBAyIAAgAygCIBA1CyACQQA2AgALC+kBBQF/AX8BfwF/AX8CQCAALgEUIAEuARRKBEAgAC4BFiABLgEWSg0BCwJAAkAgAC8BGCABLwEYTw0AIAAoAiAgASgCIEcNACAALwEuDQAgAS8BLkUNAQsgAC8BLCIEIAAvAS4iAmsgAS8BLCIGIAEvAS4iBWtOIAIgBUlyDQEDQCAEQQBKBEAgBiECIAAoAjQgBEEBayIEQQJ0aigCACIFRQ0BA0AgAkEATA0EIAUgASgCNCACQQFrIgJBAnRqKAIARw0ACwwBCwsgAC0AKEHAAHFFDQAgAS0AKEHAAHFFDQELQQEhAwsgAwvgAQQBfwF+AX4BfgNAAkAgACgCACICRQ0AAkAgAi0AECABLQAQRw0AIAItABEgAS0AEUcNAAJAIAItAClBwABxRQ0AIAEvAS4NACABKAIoQYEEcUGBBEcNACABKQMAIgMgAikDAIMgA1ENAgsCQCABKQMAIgQgAikDACIDgyIFIANSDQAgAi4BEiABLgESSg0AIAIuARQgAS4BFEoNACACLgEWIAEuARZKDQBBACEADAILIAQgBVINACACLgEUIAEuARRIDQAgAi4BFiABLgEWTg0BCyACQThqIQAMAQsLIAAL8QEEAX8BfwF/AX8gACgCGCIEKAIAIQICQAJAAkAgAS0AAEGnAWsOAwABAAELIAEoAhwgBCgCBEcNASACLwE0IQMgAigCBCEFQQAhAAJAA0AgACADRg0BIABBAXQhAiAAQQFqIQAgAiAFai8BACABLwEgRw0AC0EADwsgBEEBOgAJQQIPCyACLQA4QRBxRQ0AIAQoAgQhBUEAIQADQCAAIAIvATRPDQECQCACKAIEIABBAXRqLwEAQf7/A0YEQEEAIAEgAigCKCAAQQR0aigCCCAFEPgKRQ0BCyAAQQFqIQAMAQsLQQEhAyAEQQE6AAgLIAMLRQIBfwF/AkAgAS0AAEGnAUcNACABKAIcIAAoAhgiAygCBEcNACADKAIAIAEuASAQ5wJBAE4NACAAQQE7ARRBAiECCyACCzgBAX8CQCAARQ0AIAAuAQgiAkEATARAIAEgAmohAQwBCyABIAFBFGsgAC0ACkGAAXEbIQELIAHBC8sBAwF/AX8BfyABKAIMIQMgASABMwE0QgF8EEgiAjYCECACBEBBACECA0AgAiABLwE0T0UEQAJ/IAEoAgQgAkEBdGovAQAiAMEiBEEATgRAIAMoAgQgAEEMbGotAAUMAQtBxAAgBEF/Rg0AGiABKAIoIAJBBHRqKAIIEOQJCyEAIAEoAhAgAmpBwwBBwQAgAMAiACAAQcEATBsiACAAQcMATxs6AAAgAkEBaiECDAELCyABKAIQIAJqQQA6AAAgASgCEA8LIAAQlQFBAAuzAQMBfwF/AX8Cf0EBIgIgAUHBAEYNABoCQANAAkACQCAALQAAIgJBrQFrDgQAAAMBAwtBASADIAJBrgFGGyEDIAAoAgwhAAwBCwsgAC0AAiECCwJAAkACQAJAAkAgAiIEQZkBaw4DAgQBAAsgBEH1AEYNAkEAIgIgBEGnAUcgAUHDAEhyDQQaIAAvASBBD3YPCyABQcIASg8LIAFBwgBKDwsgA0UgAUHCAEZxDwsgA0ULIgILcQQBfwF/AX8BfwJAIAAoAgQiAygCDCIFRQ0AIAAoAgAQ8AghBkEAIQAgAygCTCADKAIIIgMEQCADKAIAIQQLIARqIQMDQCAAIAUoAgBODQEgBkHeACABIAAgA2ogACACahDbCBogAEEBaiEADAALAAsLxgcMAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/QaEBQaIBIAMbIQ5BASADayEPIARBAWohECAAKAIAIgoQ8AghBSABIQYDQCAGBEBBACEAIAYoAiwhCAJ/QQAiCSAGLQBgDQAaQQAgBigCSCgCFCIHRQ0AGiAHKAIACyIJQQAgCUEAShshBwNAIAAgB0ZFBEACQAJAIABBAUYEQEEAIQsgCCgCIEGAwwRGDQELIAVB3gAgAiAGKAJQIABqIAAgBGoQ2wgaDAELIAVB3gAgASgCMCAGKAJQQQFqIBAQ2wgaCyAAQQFqIQAMAQsLAkACQCABKAJYDQAgCC0ABUEQcUUNACAGLQARQdoARg0AIAVBMiAEEPIIIQgCQCADRQRAIAVB1gAgBigCQEEBakEBEIoDGiAFQdEAIAQgBigCQBCKAxogBUHhACAGKAJAIgBBAiAAQQJqENsIGiAFQYoBIAYoAjwgBigCQEECahCKAxogBSgCbCEAIAUoAgAtAFchBwwBCyAFQRcgBigCPEEAIARBARD/AhogBUGCASAGKAI8EPIIGkEAIQsgBSgCbCEAIAUoAgAtAFciBwR/QZCCCAUgBSgCaCAAQRhsakEwawsiCyAANgIIC0EAIQsgB0H/AXEEf0GQgggFIAUoAmggCEEYbGoLIgcgADYCCAwBCyAGKAJAIgAEQCAFQdYAIAAgD2pBARCKAxoMAQtBASEAIAgoAhBB7QBGDQACQCAGKAIoRQRAQQAhDQwBCyAKEJUJIQAgBUHeACACIAYoAlAgCWogABDbCBogBUERIABBAEEBENsIIQ0gCiAAEJYJCyAEIQwCQCAGLQBgRQ0AIAUoAmwhACAKIAYoAkgoAhQoAgAiCRDDCiEMIAogBigCSCgCFCAMQQBBABDoCSAAIAUoAmwiByAAIAdKGyELA0AgACALRg0BQQAhBwJAIAUoAgAtAFcEf0GQgggFIAUoAmggAEEYbGoLIgctAABB3gBHDQAgBygCBCABKAIwRw0AIAcgAjYCBAsgAEEBaiEADAALAAsgCC0ABEEgcQRAIAVB1QBBAEEAQQAgCiAGKAJIKAIUKAIIEI0MQX4Q9AgaCyAFIA4gAyAMIAYoAjQQ2wgaIAUgCEF5EKoKIAUoAmwiAEEASgRAIAUoAmggAEEYbGpBFmsgCUH/AXE7AQALIAYtAGAEQCAKIAwgCRDECgsgDUUNAEEAIQcgBSgCbCEAIAUoAgAtAFcEf0GQgggFIAUoAmggDUEYbGoLIgcgADYCCAsgBigCJCEGDAELCwsDAAELTwMBfwF/AX8gASgCBCEFIAAgACgCLEEBaiIGNgIsIAAoAgghByABKAIkIgEEQCAAIAIgARCyDAsgB0HhACADIAVqIAQgBWsgBhDbCBogBgvIAwgBfwF/AX8BfwF/AX8BfwF/IwBBEGsiByQAIAEoAhgiA0EAIANBAEobIQQgAUEYaiEIIAEoAhQiCSEDAkACQANAIAQgBkcEQCADKAIEIAJGDQMCQCADKAIIIAIoAhxHDQAgAy8BDCACLwEgRw0AIAItAAAiBUGzAUcNAwsgA0EQaiEDIAZBAWohBgwBCwsgASAAKAIAIAlBECAIIAdBDGoQ8gwiAzYCFCAHKAIMIgZBAEgNASADIAZBBHRqIgMgAigCLDYCACADIAIoAhwiCDYCCCACLwEgIQUgAyACNgIEIAMgBTsBDCADIQoCQAJAIAEoAhAiBEUNACACLQAAQbMBRg0AQQAhAyAEKAIAIgBBACAAQQBKGyEAIARBCGohBCAFQf//A3EhCQNAIAAgA0YNAQJAAkAgBCgCACIFLQAAQacBRw0AIAUoAhwgCEcNACAFLwEgIAlGDQELIARBEGohBCADQQFqIQMMAQsLIAogAzsBDiADwUEATg0BCyABIAEvAQIiA0EBajsBAiAKIAM7AQ4LIAItAAAhBQsgAiABNgIoIAVB/wFxQacBRgRAIAJBqQE6AAALIAIgBjsBIgsgB0EQaiQAC2wCAX8BfiAEIAMoAgAiBTYCAAJAIAWsIgYgBkIBfYNQRQRAIAEhAAwBCyAAIAEgAq0gBkIBhkIBIAUbfhBhIgANACAEQX82AgAgAQ8LIAAgAiAFbGpBACACEOcUGiADIAMoAgBBAWo2AgAgAAvkAgkBfwF/AX8BfwF/AX8BfwF/AX8jAEEQayIJJAACQAJAIAAgARCOCiIIRQ0AAkAgACgCAC0AIkEEcQ0AIAEoAjgiB0UNACAHIAhGDQEgCCEFA0AgBSIGKAIgIgUEQCAFIAdHDQELCyAGQQA2AiALQZyIAkHUiAIgAkGAAUYbIQpBACEGIAJB/wBGIQsgAkGBAUchDCAIIQUDQAJAAkAgBS0ACCIHIAJHDQAgBSgCECADEPcMRQ0AIAYgBS0ACXIhBgwBCyAHQZYBRgRAIAUgAjoACEECQQEgAS0AK0EBRyINGyEHIAsgDXJFBEAgCSAKNgIAIABBpc4AIAkQsgJBASEHCyAFIAc6AAkgBiAHciEGDAELIAUtAApFIAxyIAdB/wBHcg0AIAAoAngNACAGIAUtAAlyIQYLIAUoAiAiBQ0ACwwBC0EAIQgLIAQEQCAEIAY2AgALIAlBEGokACAIQQAgBhsLWwMBfwF/AX8gASgCFCIFQQAgBUEAShshBgNAIAQgBkYEQEEADwsgAiABIARBA3RqKAIkIgVBAnRqKAIAQQBIBEAgBEEBaiEEIANFDQEgBSAALgEgRw0BCwtBAQvDAQYBfwF/AX8BfwF/AX8gASgCFCIEQQAgBEEAShshCANAIAUgCEYEQEEADwtBACEEIAAuASIiBkEAIAZBAEobIQkgASAFQQN0aigCKCEHAkADQCAEIAlHBEACQCACIARBAnRqKAIAQQBIBEAgA0UNASAEIAAuASBHDQELIAAoAgQhBiAHBEAgBiAEQQxsaigCACAHEG0NAQwECyAGIARBDGxqLQAKQQFxDQMLIARBAWohBAwBCwsgBUEBaiEFDAELC0EBC9gBBwF/AX8BfwF/AX8BfwF/IABB9ABqIQIgACgCACEHIAAoAgghBQNAAkAgAigCACICRQ0AIAIoAgwhAyAHKAIQIQEgAigCCCEEIAAQlQkhBiAFQTcgA0ECaiAFKAJsQQdqIAMQ2wgaIABBACACKAIIIAEgBEEEdGooAgwoAkhB8QAQ9QggBUEFQaDEBBCAAyIBRQ0AIAEgA0EBaiIENgJUIAEgBjYCUCABIAY2AjwgASADQQFrNgI0IAEgBDYCICABIAQ2AgQgAUEIOwFKIAAgBhCWCQwBCwsLWAMBfwF/AX8gAEUgAUVyRQRAIAEoAgAiAkEAIAJBAEobIQNBACECA0AgAiADRgRAQQAPCyACQQR0IQQgAkEBaiECIAAgASAEaigCDBDrC0EASA0ACwtBAQv3CQ8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEGwA2siBCQAIAAoAngiBSAAIAUbIg0iD0GAAWoiBiEFAkADQCAFKAIAIgUEQCABIAUoAgBGBEAgBSgCDCADRg0DCyAFQQRqIQUMAQsLQQAhBQJAIAAoAgAiB0IYEMUCIglFDQAgCSAPKAKAATYCBCAPIAk2AoABIAkgB0IcEMUCIgo2AgggCkUNACAKIA0oAggiBSgC4AE2AhggBSAKNgLgASAJQn83AhAgCSADNgIMIAkgATYCACAEQdAAaiAHELcBIARCADcChAMgBEIANwL8AiAEQgA3AvQCIARCADcC7AIgBCACNgLMASAEIA02AsgBIAQgBEHQAGo2AugCIAQgASgCADYCzAIgBCABLQAIOgDmASAEIAAvAZQBOwHkASAEIAAtABk6AGkCQCAEQdAAahDwCCIIBEAgASgCACEOIAMQ/gwhECABLQAJIQwgAS0ACCEGIAQgAigCADYCSCAEQQAiBUGciAJqQemfAyICIAZBgAFGGzYCRCAEQUBrQbXSAUHpnwMgBkH/AEYbNgIAIAQgEDYCNCAEIA42AjAgBEHUiAJB6Z8DIAZBgQFGGzYCPCAEQeeKAkGN5AEgDEEBRhs2AjggCEHF4QIgBEEwahDzCCABKAIAIgUEQCAEIAU2AiAgCEF/IAdB598AIARBIGoQ/QJBehC9CgsgASgCDCIFBEAgByAFQQAQpAkhBQJAIActAFcNACAEQegCaiAFEN8KDQAgBCAEKAKIAUEBayILNgKIASAEQdAAaiAFIAtBEBDCCgsgByAFEDMLIANB/wFxIQIgAUEcaiEFIAQoAlAhBiAEKAJYIQcgA0ELRyEOIARBkANqQQRyIgwhESAMIRIDQCAFKAIAIgUEQCACIQMgDkUEQCAFLQABIQMLIAQgAzoA6AEgBSgCJCIDBEAgBCADNgIQIAdBuAFB/////wdBAUEAIAZB0u0AIARBEGoQ/QJBehD0CBoLAkACQAJAAkACQCAFLQAAQf8Aaw4DAQIAAwsgBEHQAGogBEHQAGogBRD/DCAGIAUoAhhBABCQCSAGIAUoAhRBABCkCSAELQDoAUEAEN0JIAdBgwEQ8QgaDAMLIARB0ABqIARB0ABqIAUQ/wwgBiAFKAIIQQAQpQkgBiAFKAIcENwLIAQtAOgBIAYgBSgCIBCADRDWCSAHQYMBEPEIGgwCCyAEQdAAaiAEQdAAaiAFEP8MIAYgBSgCFEEAEKQJEN4JIAdBgwEQ8QgaDAELIAYgBSgCCEEAEKUJIQMgBEEEOgCQAyARQQA2AhAgEkIANwIIIAxCADcCACAEQdAAaiADIARBkANqEOYJGiAGIAMQnwgLIAVBKGohBQwBCwsgCwRAIAggCxCNCgsgCEHGABDxCBogASgCACEFIAQgEDYCBCAEIAU2AgAgCEHE1gAgBBDzCCAAIARB0ABqEIENIAAoAiRFBEAgCCgCaCEFIAggDUHoAGoQjQMgCiAIKAJsNgIEIAhBADYCaCAKIAU2AgALIAogBCgCfDYCCCAEKAJ4IQUgCiABNgIUIAogBTYCDCAJIAQoAtwBNgIQIAkgBCgC4AE2AhQgCBAsDAELIAAgBEHQAGoQgQ0LIARB0ABqELkBIAkhBQsgACgCAEF/NgJECyAEQbADaiQAIAULvgEEAX8BfwF/AX8jAEEQayIGJAAgABDwCCEHAkAgACABIAIgBBD4DCICRQ0AIAEoAgAEfyAAKAIALQAhQSBxRQVBAAshCCAAIAAoAixBAWoiCTYCLCAHQTAgAyAFIAkgAigCCEF8EPQIGiABKAIAIQAgBiAEEP4MNgIEIAYgAEEAIgFB+yZqIAAbNgIAIAdBntYAIAYQ8wggBygCbCIAQQBMDQAgBygCaCAAQRhsakEWayAIOwEACyAGQRBqJAALZQQBfwF/AX8BfyABKAIgIgQoAgAiA0EAIANBAEobIQUCQANAIAIgBUYNASACQQZ0IQMgAkEBaiECIAMgBGooAhggACgCGEcNAAsgASABKAIEQYCAgIACcjYCBCAAQQE7ARQLQQALMAEBfwJAIAEoAgQiAkGAIHFFDQAgASgCFC0AB0EgcUUNACABIAJBwAByNgIEC0EAC8EGCAF/AX8BfwF/AX8BfwF/AX8gABDwCCEKIAAgACgCOEEBayINNgI4IAAoAighCSAHQQBIBEAgCkExIAQtABggDRCKAxoLIAlBAWshDiAGQQFqIQtBACEJA0AgCSAEKAIUIgxORQRAIApBMiAEKAIAIAUgCUECdGouAQAQ7gogC2ogDRCKAxogCUEBaiEJDAELCwJAIAgNACADRQRAIAAQlQkhCSAKQdEAIAQoAgAgBS4BABDuCiALaiAJEIoDGiAKQQ0gCUEAEIoDIQUCQCAHQQFHDQAgBCgCACACRw0AIApBNSAGIA0gCRDbCBogCigCbCILQQBMDQAgCigCaCALQRhsakEWa0GQATsBAAsgACAOIAEgAkHwABD1CCAKQR8gDkEAIAkQ2wgaIAogDRD4CBogCigCbCELAkAgCigCAC0AVwRAQZCCCCIFIAs2AggMAQsgCigCaCIMIAtBGGxqQShrIAs2AgAgDCAFQRhsaiEFCyAFIAs2AgggACAJEJYJDAELIAAgDBDDCiEPIApB8AAgDiADKAIsIAEQ2wgaIAAgAxDgCkEAIQkgDEEAIAxBAEobIQEDQCAEKAIAIQggASAJRkUEQCAKQdAAIAggBSAJQQJ0ai4BABDuCiALaiAJIA9qEIoDGiAJQQFqIQkMAQsLIAdBAUcgAiAIR3JFBEAgDCAKKAJsakEBaiEQQQAhCQNAIAEgCUcEQCAKQTQgBCgCACAFIAlBAnRqLgEAEO4KIAtqIBAgBiADKAIMIAMoAgQgCUEBdGovAQAiCMEQ7gogC2ogCCACLwEgRhsQ2wgaIAooAmwiCEEASgRAIAooAmggCEEYbGpBFmtBEDsBAAsgCUEBaiEJDAELCyAKIA0Q+AgaCyAKQeAAIA8gDEEAIAAoAgAgAxDhCiAMEPQIGiAKQR0gDiANIA8gDBD/AhogACAPIAwQxAoLAkACQCAELQAYIgkNAAJAIAAoAgAtACJBCHENACAAKAJ4DQAgAC0AFA0AIABBkwZBAkEAQX9BBBCMCgwCCyAHQQBMDQAgACgCeCIEIAAgBBtBAToAFQsgCkGeASAJIAcQigMaCyAKIA0QjQogCkH6ACAOEPIIGguhBAgBfwF/AX8BfwF/AX8BfwF/IwBBMGsiCSQAIAAoAgAhCyAAEPAIIQ0gB0EASARAIA1BMSAELQAYQQAQigMhDAsgBEEkaiEPA0AgCCAEKAIUTkUEQCAAIAogAEE1IAAgAiAGIAMEfyADKAIEIAhBAXRqLwEABUH//wMLIg7BEIINIAtBOyAEKAIAKAIEIAUgCEECdGogDyAFGy4BAEEMbGooAgAQyAkQoQkQzgkhCiAIQQFqIQgMAQsLAkAgB0EATA0AIAQoAgAgAkcNACAAIAoCfwJAIAItABxBgAFxBEBBACEFQQAhCANAIAggAy8BMk8NAiAAIAUgAEEtIAAgAiAGIAMoAgQgCEEBdGouAQAiDhCCDSALQTsgAigCBCAOQQxsaigCABDICRChCRDOCSEFIAhBAWohCAwACwALIAAgAiAGQX8Qgg0hAyABKAIwIQUgC0GnAUEAEMgJIggEQCAIQf//AzsBICAIIAU2AhwgCCACNgIsCyAAQTQgAyAIEKEJDAELIABBEyAFQQAQoQkLIggQzgkhCgsgCUEANgIoIAlCADcDICAJQgA3AxggCUIANwMQIAkgATYCDCAJIAA2AgggCUEIaiAKEN8KGgJAIAAoAiQNACAAIAEgCkEAQQBBAEEAQQAQqwohCCANQZ4BIAQtABggBxCKAxogCEUNACAIELQKCyALIAoQMyAMBEAgDSAMEOMKCyAJQTBqJAALIQAgAEEBayIAQQpLBEBB7cMBDwsgAEECdEHE3QZqKAIAC/MBBQF/AX8BfwF/AX8jAEEQayIEJAAgACgCACIFIAEoAgwQoAEhBgJAAn8CQCAAQQBBAEEAEL4JIgMEQCABKAIEKAIUIQIgAyAGNgIQIAUoAhAoAhwgAkcEQCADIAI2AggLIAEoAhAiAkUEQCADIQIMBAtBACIBIAUgAkEAEKcJIgJFDQIaIAIoAgBBAkgNASAALQDUAUEBSw0BIABBACACQQBBAEEAQQBBgBBBABDFCSEBIARCADcDCCAAQQBBAEEAIARBCGogAUEAENsJDAILIAUgBhAyDAILIAILIQEgACADIAEQ3AkhAgsgBEEQaiQAIAILSgAgAUUEQEEADwsgACAAIAEoAgBBABCQCSAAIAEoAgRBABCkCSAAIAEoAghBABCQCSAAIAEoAgxBABCkCSAAIAEoAhAQgA0Q1QkLNgAgACgCJEUEQCAAIAEoAgQ2AgQgACABKAIkNgIkIAAgASgCDDYCDA8LIAEoAgAgASgCBBAyC5QBAwF/AX8BfyAAKAIAIgZBsAFBABDICSIEBEACQCADQQBIDQAgAS8BICADQf//A3FGDQAgASgCBCEFIAQgASADEO4KIAJqQQFqNgIcIAQgBSADQQxsaiIDLQAFOgABIAMQjgQiA0UEQCAGKAIIKAIAIQMLIAAgBCADEPgLDwsgBEHEADoAASAEIAI2AhwgBCEFCyAFC1MBAX8CQCABLQAAQacBRw0AAkAgAS4BICICQQBIBEBBAiEBDAELQQEhASAAKAIYIAJB//8DcUECdGooAgBBAEgNAQsgACAALwEUIAFyOwEUC0EACz8AAkAgAS0AAEGnAUcNACABLgEgIgFBAEgNACAAIAAvARQgACgCGCgCBCABQf//A3FBDGxqLwEKcjsBFAtBAAuFBAwBfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEEQayIIJAAgASgCKCEKIAAoAgAhCyABIAMQ/wohDCAAKAIIIgZB/NEBQQAQtQoCQCADRSAEIApGcg0AIAItABxBgAFxRQRAIAZBjgEgBCAAEJUJIgUQigMaIAZBHiAKQQAgBRDbCBogACAFEJYJDAELIAAgACgCLCIFIAIQrwMiCS8BMiINajYCLCAFQQFqIQ5BACEFA0AgBSANRkUEQCAGQd4AIAQgAyAFQQF0Ig8gCSgCBGouAQAQ5wIgBSAOahDbCBogAygCACEQIAggAigCBCAJKAIEIA9qLgEAQQxsaigCADYCBCAIIBA2AgAgBkHp1gAgCBDzCCAFQQFqIQUMAQsLQQAhBSAGQR0gCkEAIA4gDRD/AiEJIAZBxgBBC0ECQQBB2ZoBQX8Q9AgaIAAoAngiAyAAIAMbQQE6ABUgBigCbCEDIAYoAgAtAFcEf0GQgggFIAYoAmggCUEYbGoLIgUgAzYCCAsgCyABKAIgQQAQpwkhBQNAIAIuASIgB0oEQCACKAIEIAdBDGxqLQAFQcUARgRAIAZB1wAgASgCJCAHahDyCBoLIAdBAWohBwwBCwsgACAFIAsgDCgCCEEAEJAJIAsgDCgCDEEAEKQJQQIgDBDdCSAGQZbSAUEAELUKIAhBEGokAAu+CQoBfwF/AX8BfwF/AX8BfwF/AX8BfyMAQUBqIgQkACAABEAgACgCACgCFCEDCyAEQQA2AjwgBEEANgI4IARBADYCMCACKAIAEF8iBkHpnwMiBSAGGyELIAIoAgQQXyECAkACQAJAAkACQAJAAkAgAy0AsgFBBHEEQCAEQQA2AjRBkMIBEDoiAkUNByACQcXFBCADIARBNGpBAEGAAhCABCICDQYgAyAEKAI0IgIQgQQiBgRAIAMoAhAiByADLQCwAUEEdCIIaiIFIgxBBGohCSAFKAIEIgoEQCAKEO8BCyAMIAI2AgQgByAIaiAGNgIMQQAhCCADQQA6AF8MAgsgAhDvAUEHIQIMBgsCQCAEAn8gAygCFCIIIAMoApQBIgZBAmpIBEAgAkHpnwMgAhshBkEAIQIgCEEAIAhBAEobIQcDQCACIAdGDQMgAyACIAYQyQghBSACQQFqIQIgBUUNAAsgBCAGNgIQIANB6pkBIARBEGoQ/QIMAQsgBCAGNgIgIANBsLwBIARBIGoQ/QILIgU2AjBBACECDAMLAkAgAygCECICIANBzANqRgRAIANCMBDsAiIHRQ0IIAcgAygCECICKQIANwIAIAcgAikCGDcCGCAHIAIpAhA3AhAgByACKQIINwIIDAELIAMgAiAIQQR0QRBqrRBhIgdFDQcLIAMgBzYCECAHIAMoAhQiCUEEdGoiBUIANwIAIAVCADcCCCAEIAMoAjw2AjQgAygCACgCECALIARBNGogBEEsaiAEQTxqIARBOGoQ/wMiAgRAIAJBB0YEQCADEJUBCyAAIAQoAjgiAkF/EJsCIAIQQAwHCyAEKAIsIAQoAjwiCCADIAVBBGpBACAEKAI0QYACchCABCECIAMgAygCFEEBajYCFCAFIAMgBhCgATYCACADQQA6AF8gAkUNACACQRNGBEAgBCADQZG3AUEAEP0CNgIwQQEhAgsgByAJQQR0akEDOgAIDAELIAUgAyAFKAIEEIEEIgY2AgxBACEHAkAgBkUEQEEHIQJBACEJDAELQQAhAkEBIQkgBi0ATEUNACAGLQBNIAMtAFRGDQBBACEJIAQgA0HqmgFBABD9AjYCMEEBIQILIAUoAgQoAgQoAgAgAy0AWRCMCxogAygCECgCBCIKBEAgCigCBC8BGEECdkEDcSEHCyAFKAIEIgYgBxCLCxogBSgCBCADKAIgQThxQQNyEJwIIAVBAzoACCAJRQ0AQQBBByAFKAIAGyECCyAIEIMEIAJFBEAgA0EAOgCwASADIAMoAhhBb3E2AhggAy0AsgFBBHENBSADIARBMGoQiwQiAkUNBQsgAy0AsgFBBHEEQCAEKAIwIQUMAQsgAygCECADKAIUQQFrIgVBBHRqKAIEIgYEQCAGEO8BIAMoAhAgBUEEdGoiBkEANgIMIAZBADYCBAsgAxDAASADIAU2AhQgBAJ/IAJBihhHIAJBB0dxRQRAIAMQlQEgAyAEKAIwEDIgA0GhJUEAEP0CDAELIAQoAjAiBQ0CIAQgCzYCACADQcTnACAEEP0CCyIFNgIwCyAFRQ0BCyAAIAVBfxCbAiADIAQoAjAQMgsgAkUNAQsgACACELACCyAEQUBrJAALJAAgAQRAIAEtAABBO0cEQCAAIAEQ3woPCyABQfUAOgAAC0EAC+ACCQF/AX8BfwF/AX8BfwF/AX8BfyMAQZABayIGJAAgAigCABBfIQVBACECIAAEQCAAKAIAKAIUIQILIAIoAhQiBEEAIARBAEobIQQgBUHpnwMgBRshBwJAAkADQEEAIQUgAyAERgRAQeDnACEDDAILAkAgAigCECIIIANBBHRqIgkoAgQiBQRAIAIgAyAHEMkIDQELIANBAWohAwwBCwtBACEEIANBAkkEQEGj2wAhAwwBCyAFLQAIBEBB6bQBIQMMAQsgBSgCEARAQem0ASEDDAELIAkiC0EEaiEHIAggA0EEdGoiCkEMaiEJIAgoAhxBMGohAwNAIAMoAgAiAwRAIAMoAggiBCgCGCAKKAIMRw0BIAQgBCgCFDYCGAwBCwsgBRDvASALQQA2AgQgCkEANgIMIAIQzAEMAQsgBiAHNgIAIABBgAEgBkEQaiADIAYQaUF/EJsCCyAGQZABaiQAC5UDCQF/AX8BfwF/AX8BfwF/AX8BfyMAQUBqIgUkACAAKAIAIQogABDwCCIIBEAgCigCECABQQR0aiEJA0AgBkEDRkUEQCAFQTFqIAZqIgxBADoAAAJAIAogBkEDdEHwkAZqKAIAIgsgCSgCABCEAyIHRQRAIAYNAUEAIQcgCSgCACENIAVBjjw2AgggBSALNgIEIAUgDTYCACAAQcjfAiAFEI0JIAUgACgCZDYCNCAMQRA6AAAMAQsgBUE0aiAGQQJ0aiAHKAIUIgc2AgAgAwRAIAkoAgAhByAFIAM2AiwgBSAENgIoIAUgCzYCJCAFIAc2AiAgAEHk5wEgBUEgahCNCQwBCyAKKAKIAgRAIAkoAgAhByAFIAs2AhQgBSAHNgIQIABB79YAIAVBEGoQjQkMAQsgCEGRASAHIAEQigMaCyAGQQFqIQYMAQsLIAhB8QAgAiAFKAI0IAFBAxD/AhogCCgCbCIGQQBKBEAgCCgCaCAGQRhsakEWayAFLQAxOwEACyAIQanHAkEAEPMICyAFQUBrJAALtw4ZAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEEwayIPJAAgBEEJaiISIAAoAixKBEAgACASNgIsCyAAKAIAIQwCQCABRSAAEPAIIgZFcg0AIAEtACsNAEHOkAMgASgCACIHQdwAEKADRQ0AIABBHCAHQQAgDCgCECAMIAEoAjwQ/AIiGkEEdGooAgAQ+QgNACAMKAKIAgRAIAxCzQAQxQIiDUUNASANQf//DzYCICANIA1BQGs2AgAgDUGpxwIiBykAADcAQCANQa7HAikAADcARSAAKAIIQbsBQQBBAEEAIA1BehD0CBoLIARBCGohFiAEQQdqIRsgBEEFaiEdIARBBGohCyAEQQNqIR4gBEECaiETIARBAWohFyAAIAAoAigiByAFQQJqIgggByAIShs2AiggACAFIBogAUHwABD1CCAGIARBBmoiHCABKAIAEPYIGiABQQhqIQcgBUEBaiEQQQEhGANAIAcoAgAiCARAAkAgAkEAIAIgCEcbDQACfwJAAkAgAS0AHEGAAXFFIAgvADciB0EDcUECR3JFBEAgASgCACEJIAgvATIhCgwBCyAIKAIAIQkgCC8BNCEKIAdBCHENAQsgCgwBCyAILwEyCyEHIAgoAiQhESAGIBsgCRD2CBogASgCACEOIA8gCTYCJCAPIA42AiAgBkHQ0wAgD0EgahDzCCAHQQFrIgkgEmoiDiAAKAIsSgRAIAAgDjYCLAsgGEEAIBEbIRggBkHwACAQIAgoAiwgGhDbCBogACAIEOAKIA8gCCgCADYCECAGQQAiEUGz7gBqIA9BEGoQ8wggBkHHACAMKALwAyAdEIoDGiAGQccAIAogExCKAxogBkHHACAILwEyIB4QigMaIAZB4gAgECALIAwoAlBBC3ZBAXEQ2wgaIABBACATIBdBBEGIkQZBABC0CyAGQSQgEBDyCCEUIAZBxwBBACATEIoDGgJAIAdBAkkEQCAGKAJsIRUMAQsgACAAKAI4QQFrIhk2AjggDCAJQQJ0rRDsAiIORQ0BIAZBCRDxCBogBigCbCEVAkAgCUEBRw0AIAgvATJBAUcNACAILQA2RQ0AIAZBMyASIBkQigMaC0EAIQcDQCAHIAlHBEAgACAHQQJ0IgogCCgCIGooAgAQ8QkhESAGQccAIAcgExCKAxogBkHeACAQIAcgCxDbCBogBiAIIAcQjA0gCiAOaiAGQTQgC0EAIAcgEmogEUF+EPQINgIAIAYoAmwiCkEASgRAIAYoAmggCkEYbGpBFmtBgAE7AQALIAdBAWohBwwBCwsgBkHHACAJIBMQigMaIAYgGRD4CBpBACEKIAYoAmwhByAGKAIALQBXBH9BkIIIBSAGKAJoIBVBGGxqQRhrCyIKIAc2AghBACEHA0AgByAJRkUEQEEAIREgBigCbCEKIAYoAgAtAFcEf0GQgggFIAYoAmggDiAHQQJ0aigCAEEYbGoLIhEgCjYCCCAGQd4AIBAgByAHIBJqENsIGiAGIAggBxCMDSAHQQFqIQcMAQsLIAYgGRCNCiAMIA4QNQsgAEEBIBcgC0ECQbCRBkEAELQLAkAgDCgC8AMEQEEAIQkgBkEyIAsQ8gghCiAGQRAgCxDyCCERIAZBGCAQQQAgEkEBEP8CIQ4gBigCbCEHIAYoAgAtAFcEf0GQgggFIAYoAmggCkEYbGoLIgkgBzYCCCAGQScgECAVEIoDGiAGKAJsIQcCQCAGKAIALQBXBEBBkIIIIgkgBzYCCAwBCyAGKAJoIgkgEUEYbGogBzYCCCAJIA5BGGxqIQkLIAkgBzYCCAwBCyAGQScgECAVEIoDGgsgCCgCJARAQQAhCSAGKAJsIQcgBigCAC0AVwR/QZCCCAUgBigCaCAUQRhsagsiCSAHNgIIQQAhFAsgAEEAIBcgFkEBQQAiB0HYkQZqQQAQtAsgBkHhACAcQQMgC0GdowJBABD0CBogBkH/ACADIAQQigMaIAZBgAEgAyALIAQQ2wgaIAZBfyANQXsQvQogBigCbCIHQQBKBEAgBigCaCAHQRhsakEWa0EIOwEACyAURQ0AQQAhCSAGKAIALQBXBH9BkIIIBSAGKAJoIBRBGGxqCyIJIAc2AggLIAhBFGohBwwBCwsgAiAYQf8BcUVyDQAgDyABKAIANgIAIAZBACIHQbPuAGogDxDzCCAGQeIAIAUgFhCKAxogBkERIBYQ8gghACAGQcsAQQAgGxCKAxogBkHhACAcQQMgC0GdowJBABD0CBogBkH/ACADIAQQigMaIAZBgAEgAyALIAQQ2wgaIAYoAmwiB0EASgRAIAYoAmggB0EYbGpBFmtBCDsBAAsgBkF/IA1BexC9CkEAIQggBigCbCEHIAYoAgAtAFcEf0GQgggFIAYoAmggAEEYbGoLIgYgBzYCCAsgD0EwaiQACxcAIAAQ8AgiAARAIABBlgEgARDyCBoLC6sBAgF/AX8jAEEwayIDJAACQAJAAkACQCABKAIEIAJBAXRqLwEAIgRB/v8Daw4CAQACCyADIAEoAgA2AhAgAEG+rAEgA0EQahDzCAwCCyABKAIAIQEgAyACNgIkIAMgATYCICAAQeTnAiADQSBqEPMIDAELIAEoAgAhAiADIAEoAgwoAgQgBMFBDGxqKAIANgIEIAMgAjYCACAAQenWACADEPMICyADQTBqJAALpgEFAX8BfgF/AX4BfyAABH8gACgCACgCFAVBAAshBSACKAIAEFwhBCACKAIEEFwhBiAFIASnIgdBA3RBMGqsEMUCIgNFBEAgABCVAg8LIAMgBTYCACACKAIIEFwhBCADQgA3AxAgAyAENwMIIAIoAgwQXCEEIAMgA0EwajYCKCADQQA6ACQgAyAGPgIgIAMgBzYCHCADIAQ+AhggACADQTBB7gAQkQILCwAgACgCACAAEDULuAEEAX8BfwF+AX8gAigCABD6ASEDIAIoAgQQXCEFIAMgAykDEFAEfkIBBSADKAIcIgQgBaciAiACIARIGyEGA0AgAiAGRkUEQCADKAIoIAJBA3RqIgQgBCkDAEIBfDcDACACQQFqIQIMAQsLIAMpAxBCAXwLIgU3AxACQCADKAIYIgJFDQAgBSACrCADLQAkIgStQv8Bg0IBfH5YDQAgAyAEQQFqOgAkIAAgAygCKCkDAEIAUhCeAgsL6wEGAX8BfwF+AX8BfgF+IwBBMGsiAyQAIAIoAgAQ+gEiBCgCICEGQQAhAiADQQA7ASwgA0EANgIoIANBADYCICADQgA3AxggAyAGQeQAbEHkAGo2AiQgAyAEQQhBECAELQAkG2opAwA3AxAgA0EYakH6KyADQRBqEFgDQCACIAQoAiBORQRAIANCAkIBIAQpAxAiBUIKfiAEKAIoIAJBA3RqKQMAIgdCAXwiCEILflYbIAUgB3wgCIAiBSAFQgJRGzcDACADQRhqQfkrIAMQWCACQQFqIQIMAQsLIAAgA0EYahCRDSADQTBqJAALTAEBfwJAIAEtABQiAgRAIAAgAhCwAgwBCyABLQAVQQRxBEBBASECIAAgASgCBCABKAIQQQIQpwIPCyAAQemfA0EAQQAQpwILIAEQYAsOACAAQYAgQX9BABCnAgsYACACKAIAEF8iAgRAIAAgAhCmBBCeAgsLLgEBfyACKAIAEFynIgJBOU0EQCACQQJ0QdDbBmooAgAhAwsgACADQX9BABCnAgvfBAkBfwF/AX8BfwF/AX8BfwF/AX8CQEKq1arVqtWq1ap/IAIoAgAiAzMBEIinQQFxDQAgAxBfIgdFDQBBACEDQQEhBSACKAIAEP4BIQQCQAJAAkAgAUEBRgRAQYjMBCEIQeCzBiEGDAELIAIoAgQQXyIJRQ0DQQAhASAJIQIDQCACLQAAIgUEQCACQQFqIgMhAiAFQcABTwRAA0AgAyICQQFqIQMgAi0AAEHAAXFBgAFGDQALCyABQQFqIQEMAQsLIAFFDQEgACABrUIDhhCWDSIGRQ0DIAYgAUECdGohCEEAIQUgCSEBA0AgAS0AAARAIAYgBUECdCILaiABNgIAIAFBAWoiAyECIAEtAABBwAFPBEADQCADIgJBAWohAyACLQAAQcABcUGAAUYNAAsLIAggC2ogAiABazYCACAFQQFqIQUgAiEBDAELCyAFRQ0BCyAABEAgACgCBCgCCCEKCwJAIApBAXFFIARFcg0AA0BBACECQQAhAwNAAkAgAiAFRg0AIAQgCCACQQJ0IgFqKAIAIgNPBEAgByABIAZqKAIAIAMQ6hRFDQELIAJBAWohAgwBCwsgAiAFTw0BIAMgB2ohByAEIANrIgQNAAtBACEECwJAIApBAnFFIARFckUEQANAIAQhAUEAIQIDQCACIAVGDQMCQCAIIAJBAnQiC2ooAgAiAyABTQRAIAcgASADayIEaiAGIAtqKAIAIAMQ6hRFDQELIAJBAWohAgwBCwtBACEBIAQNAAwCCwALIAQhAQsgCUUNASAGEEAMAQsgBCEBCyAAIAcgAUF/EKcCCws1AQF/AkACQCABIAAoAgAoAhQ0AnhVBEAgABCUAgwBCyABEEgiAg0BIAAQlQILQQAhAgsgAgvOAQUBfwF/AX8BfwF/IAAEf0F/QQAgACgCBCgCCBsFQQALIQQCQEKq1arVqtWq1ap/IAIoAgAzARCIp0EBcQ0AIAAoAgwoAmggACgCEEEYbGpBCGsoAgAhBUEBIAEgAUEBTBshBkEBIQEDQCABIAZHBEBCqtWq1arVqtWqfyACIAFBAnRqKAIAIgczARCIp0EBcQ0CIAMgASACIANBAnRqKAIAIAcgBRCyByAEc0EASBshAyABQQFqIQEMAQsLIAAgAiADQQJ0aigCABCrAgsLzgEDAX8BfwF/IAIoAgAhAwJAAkAgAEEoEMECIgJFDQAgAi8BECEEQqrVqtWq1arVqn8gAzMBEIhCAYNQRQRAIARB//8DcUUNAQwCCyAEQf//A3EEQCAAKAIEKAIIIgRFIAIgAyAAKAIMKAJoIAAoAhBBGGxqQQhrKAIAELIHIgVBAE5yQQAgBUEATCAEchtFBEAgAiADEKwCGg8LDAILIAIgAAR/IAAoAgAoAhQFQQALIgA2AhQgAiADEKwCGgsPCyAAQQE6ABkgAEF/NgIUCwkAIABBABCaDQsrAQF/AkAgAEEAEMECIgJFDQAgAi8BEARAIAAgAhCrAgsgAQ0AIAIQ+AELCwkAIABBARCaDQspACAAIAIoAgAvARBBP3FB4KMDai0AAEECdEHsswZqKAIAQX9BABCnAgsiAQF/IAIoAgAiAi0AEUEIcQRAIAItABMhAwsgACADEJ4CC5gBAgF/AX8CQAJAAkACQCACKAIAIgIvARBBP3FB4KMDai0AAEEBaw4EAAABAAILIAAgAhD+ARCeAg8LIAIQXyIDRQ0BIAMhAgNAIAItAAAiBARAIAJBAWohAiAEQcABSQ0BA0AgAi0AAEHAAXFBgAFHDQIgA0EBaiEDIAJBAWohAgwACwALCyAAIAIgA2sQngIPCyAAEKECCwt+AAJAAkACQAJAIAIoAgAiAi8BEEE/cUHgowNqLQAAQQFrDgQBAQIAAwsgACACEP4BEJ4CDwsgAEIBQgIgACgCACgCFC0AVEECSRsgAhD+Aax+EKACDwsgAi0AEkEBTQRAIAAgAhD+ARCeAg8LIAAgAhCBAhCeAg8LIAAQoQIL0QMKAX8BfwF/AX8BfwF+AX4BfwF/AX9BASEEQqrVqtWq1arVqn8gAigCACIDMwEQIgiIQqrVqtWq1arVqn8gAigCBDMBECIJiISnQQFxRQRAIAMQ/gEhBQJAAkAgAigCBBD+ASIKQQBMBEBBACECDAELAkACQAJAAkACQAJAAn9CgYCEgICAwAAgCEI/gyIIiEKBgISAgIDAACAJQj+DIgmIg6dBAXEiDARAIAIoAgAQ+gEhAyACKAIEEPoBDAELIAIoAgAhA0L+//v///+/fyAIiEIBg1BC/v/7////v38gCYhCAYNQcg0BIAMQXyEDIAIoAgQQXwsiCw0DDAELIAMQjQIiBhBfIgMNAQtBACECDAMLIAYQ/gEhBSACKAIEEI0CIgcQXyILRQRAIAchAgwDCyAHEP4BIQoMAQsgBUUEQAwBC0EAIQIgA0UNAQsgCy0AACECA0ACQAJAIAUgCkgEQEEAIQQMAQsgAy0AACACRw0BIAMgCyAKEOoUDQELIAchAgwDCyAEQQFqIQQDQCADQQFqIQMgBUEBayEFIAwNASADLQAAQcABcUGAAUYNAAsMAAsACyAAEJUCDAELIAAgBBCeAgsgBhD0ASACEPQBCwu2AQMBfwF/AX8jAEEwayIDJAAgAAR/IAAoAgAoAhQFQQALIQQCQCABQQBMDQAgAigCABBfIgVFDQAgA0EANgIkIAMgAkEEajYCKCADIAFBAWs2AiAgBCgCeCEBIANBgAQ7ARwgA0EANgIYIAMgATYCFCADIAQ2AgggA0IANwIMIAMgA0EgajYCACADQQhqIAUgAxBYQQEhASADKAIYIQIgACADQQhqEGMgAkECEKcCCyADQTBqJAALPwEBfyMAQRBrIgMkACADIAIoAgAQXyICNgIMAkAgAkUNACACLQAARQ0AIAAgA0EMahCfAxCeAgsgA0EQaiQAC8sCBQF/AX8BfwF/AX4gAUECdEEBcqwQSSIFBEAgAUEAIAFBAEobIQYgBSEBA0AgBCAGRkUEQAJ/Qf3/AyACIARBAnRqKAIAEFwiB6dB////AHEgB0L//8MAVhsiA0H/AE0EQCABIAM6AAAgAUEBagwBCyADQf8PTQRAIAEgA0E/cUGAAXI6AAEgASADQQZ2QcABcjoAACABQQJqDAELIANB//8DTQRAIAEgA0E/cUGAAXI6AAIgASADQQx2QeABcjoAACABIANBBnZBP3FBgAFyOgABIAFBA2oMAQsgASADQT9xQYABcjoAAyABIANBEnZB8AFyOgAAIAEgA0EGdkE/cUGAAXI6AAIgASADQQx2QT9xQYABcjoAASABQQRqCyEBIARBAWohBAwBCwsgAUEAOgAAIAAgBSABIAVrrEEBQQEQqAIPCyAAEJUCC4cBAgF+AXwCQAJAAkAgAigCACICLwEQQT9xQeCjA2otAABBAWsOBQACAgIBAgsgAhBcIgNCAFMEQCADQoCAgICAgICAgH9RBEAgAEHDKkF/EJsCDwtCACADfSEDCyAAIAMQoAIPCyAAEKECDwsgACACEFEiBJogBCAERAAAAAAAAAAAYxsQmAILtQIDAXwBfwF/IwBBIGsiBCQAAkAgAUECRgRAQqrVqtWq1arVqn8gAigCBCIBMwEQiKdBAXENAUEeIAEQXKciASABQR5OGyIBQQAgAUEAShshBQtCqtWq1arVqtWqfyACKAIAIgIzARCIp0EBcQ0AIAQgAhBRIgM5AxgCQCADRAAAAAAAADDDYyADRAAAAAAAADBDZHINACAFRQRAAn4gA0QAAAAAAADgv0QAAAAAAADgPyADRAAAAAAAAAAAYxugIgOZRAAAAAAAAOBDYwRAIAOwDAELQoCAgICAgICAgH8LuSEDDAELIAQgAzkDCCAEIAU2AgBB7pEBIAQQZyICRQRAIAAQlQIMAgsgAiAEQRhqIAIQWkEBEPYCGiACEEAgBCsDGCEDCyAAIAMQmAILIARBIGokAAuLAQUBfwF/AX8BfwF/IAIoAgAQXyEEIAIoAgAQ/gEhAwJAIARFDQAgACADrEIBfBCWDSIFRQ0AQQAhAiADQQAgA0EAShshBgNAIAIgBkZFBEAgAiAFaiACIARqLQAAIgcgB0HApANqLQAAQX9zQd8BcnE6AAAgAkEBaiECDAELCyAAIAUgA0EBEKcCCwt9BAF/AX8BfwF/IAIoAgAQXyEEIAIoAgAQ/gEhAwJAIARFDQAgACADrEIBfBCWDSIFRQ0AQQAhAiADQQAgA0EAShshBgNAIAIgBkZFBEAgAiAFaiACIARqLQAAQcChA2otAAA6AAAgAkEBaiECDAELCyAAIAUgA0EBEKcCCwulAQUBfwF/AX8BfwF/IAIoAgAQ+gEhAyAAIAIoAgAQ/gEiAqxCAYZCAYQQlg0iBARAIAJBACACQQBKGyEGIAQhAgNAIAUgBkZFBEAgAiADLQAAIgdBD3FBkMwEai0AADoAASACIAdBBHZBkMwEai0AADoAACADQQFqIQMgBUEBaiEFIAJBAmohAgwBCwsgAkEAOgAAIAAgBCACIARrrEEBQQEQqAILC5MDBwF/AX8BfwF/AX8BfwF/IwBBEGsiBCQAIAQgAigCABBfIgM2AgggAigCABD+ASEFAn8gAUECRwRAQemfAyEHQQAMAQsgAigCBBBfIQcgAigCBBD+AQshAgJAIANFIAdFcg0AAkAgACAFQQJtQQFqrBCWDSIFRQRADAELIAIgB2ohCCAFIQYDQCADLQAAIgJFDQECQCACQf8BcSIBQcCkA2otAABBCHFFBEACQCACwEEATgRAIAQgA0EBajYCCAwBCyAEQQhqEJ8DIQELIAQgBzYCDANAIAQoAgwiAiAITw0CAn8gAiwAACIDQQBOBEAgBCACQQFqNgIMIANB/wFxDAELIARBDGoQnwMLIgMgAUcNAAsgBCgCCCEDDAILIAQgA0ECaiIJNgIIIAMtAAEiA0HApANqLQAAQQhxRQ0AIAYgA0EZdEEfdUEJcSADakEPcSABQRl0QR91QQlxIAJqQQR0cjoAACAGQQFqIQYgCSEDDAELCyAFEEAMAQsgACAFIAYgBWtBARCRAgsgBEEQaiQACxEAIAAgASACQQBB6Z8DEKsNC/kBBgF+AX8BfwF/AX8BfiABQQAgAUEAShshCQNAIAYgCUZFBEAgBSACIAZBAnRqKAIAEP4BrHwhBSAGQQFqIQYMAQsLIAFBAWsgA2ysIAV8QgF8EEkiBwRAIAOtIQpCACEFQQAhBgNAIAYgCUZFBEACQCACIAZBAnRqIggoAgAQ/gEiAUEATA0AIAgoAgAQXyIIRQ0AIANBAEwgBUIAV3JFBEAgByAFp2ogBCADEOUUGiAFIAp8IQULIAcgBadqIAggARDlFBogAawgBXwhBQsgBkEBaiEGDAELCyAHIAWnakEAOgAAIAAgByAFQQFBARCoAg8LIAAQlQILLwIBfwF/IAIoAgAQ/gEhAyACKAIAEF8iBARAIAAgAUEBayACQQRqIAMgBBCrDQsLSwIBfwF+IwBBEGsiAyQAQQggA0EIahBrIAMpAwgiBEIAUwRAIANCACAEQv///////////wCDfSIENwMICyAAIAQQoAIgA0EQaiQACzcCAX4BfyAAQgEgAigCABBcIgMgA0IBVxsiAxCWDSICBEAgA6ciBCACEGsgACACIARBARCRAgsLMwAgAigCACACKAIEIAAoAgwoAmggACgCEEEYbGpBCGsoAgAQsgcEQCAAIAIoAgAQqwILCw8AIABBzqkBQX9BABCnAgs2AgF/AX4jAEEQayIDJAAgAigCABBcIQQgAyACKAIEEF82AgAgBKdBs+4AIAMQaiADQRBqJAALpAQJAX8BfwF/AX8BfAF/AX4BfwF/IwBB4ABrIgMkACAABEAgACgCACgCFCEECyAEKAJ4IQYgA0EAOwFUIANBADYCUCADIAY2AkwgAyAENgJAIANCADcCRAJAAkACQAJAAkACQCACKAIAIgQvARBBP3FB4KMDai0AAEEBaw4EAQADAgQLIAMgBBBRIgc5AxAgA0FAa0G1kAEgA0EQahBYIAMoAlAiBEUNBCADKAJEIARqQQA6AAAgAygCRCIERQ0EIAQgA0HYAGogAygCUEEBEPYCGiAHIAMrA1hhDQQgA0FAaxBgIAMgBzkDACADQUBrQbOqASADEFgMBAsgAyAEEFw3AyAgA0FAa0GJrAEgA0EgahBYDAMLIAQQ+gEhCCADQUBrIAQQ/gEiAqxCAYYiCUIEfBBUGiADLQBUDQJBACEEIAJBACACQQBKGyEKIAMoAkQhBQNAIAQgCkZFBEAgBEEBdCAFaiICQZDMBCIGIAQgCGoiCy0AAEEEdmotAAA6AAIgAiALLQAAQQ9xQZDMBGotAAA6AAMgBEEBaiEEDAELCyAJpyIEIAVqQSc7AAIgBUHYzgA7AAAgAyAEQQNqNgJQDAILIAMgBBBfNgIwIANBQGtB8OoBIANBMGoQWAwBCyADQUBrQY/0AUEEEE4LQQEhBCAAIANBQGsQYyADKAJQQQIQpwIgAy0AVARAIAAQoQIgACADLQBUELACCyADQeAAaiQACxoAIAAgAAR/IAAoAgAoAhQFQQALEM0DEKACCxoAIAAgAAR/IAAoAgAoAhQFQQALEM8DEKACCxoAIAAgAAR/IAAoAgAoAhQFQQALENEDEKACC8EDEQF/AX8BfwF/AX8BfwF+AX8BfwF/AX8BfwF/AX8BfgF+AX8gAAR/IAAoAgAoAhQFQQALIQ0CQCACKAIAEF8iC0UNACACKAIAEP4BIQYgAigCBBBfIgxFDQAgDC0AAEUEQCAAIAsgBkF/EKcCDwsgAigCBBD+ASEHIAIoAggQXyIORQ0AIAIoAggQ/gEhCCAAIAZBAWqsIgkQlg0iA0UNACAHQQFrIQ8gBiAHayEQIAZBf3OsIREgCCAHa6whEkEAIQIDQAJ/AkACQCACIBBMBEACQCACIAtqIhMtAAAiBCAMLQAARgRAIBMgDCAHEOoURQ0BCyADIAVqIAQ6AAAgBUEBagwECyAHIAhODQEgDTQCeCAJIBJ8IglCAX1TBEAgABCUAiADEEAPCyAKQQFqIgQgCnEEQCAEIQoMAgsgBCEKIAMgCcQgCSARfHwQSyIEDQIgABCVAiADEEAPCyADIAVqIAIgC2ogBiACayICEOUUGiADIAIgBWoiAmpBADoAACAAIAMgAkEBEKcCDAQLIAMhBAsgBCAFaiAOIAgQ5RQaIAIgD2ohAiAEIQMgBSAIagshBSACQQFqIQIMAAsACwsmAQF+IAAgAigCABBcIgNCACADQgBVGxCuAiICBEAgACACELACCwugBQsBfgF/AX8BfgF+AX8BfwF+AX8BfgF/AkACQEKq1arVqtWq1ap/IAIoAgQiBTMBEIinQQFxDQAgAUEDRgRAQqrVqtWq1arVqn8gAigCCDMBEIinQQFxDQELIAIoAgAzARAhAyAFEFwhBiACKAIAIQUgBqchCwJAQoGAhICAgMAAIAOIQgGDIgxQRQRAIAUQ/gEhCSACKAIAEPoBIgVFDQIMAQsgBRBfIgVFDQEgC0EATg0AIAUhBANAIAQtAAAiDUUNASAEQQFqIgghBCANQcABTwRAA0AgCCIEQQFqIQggBC0AAEHAAXFBgAFGDQALCyAJQQFqIQkMAAsACwJ+IAFBA0YEQCACKAIIEFwiA8QiB0IAIAd9IANCgICAgAiDUCIEGwwBC0EBIQQgACgCACgCFDQCeAshAyAGxCEGAkAgC0EASARAIAYgCax8IgdCAFkNASADIAd8IQZCACEHIAZCACAGQgBVGyEDDAELIAsEQCAGQgF9IQcMAQtCACEHIAMgA0IAVa19IQMLIAcgByADfSIKQgAgCkIAVRsgBBshBiADIAcgAyAKQgBTGyAEGyEDIAxQBEADQCAFLQAAIgJFIAZQcg0DIAVBAWoiBCEFIAJBwAFPBEADQCAEIgVBAWohBCAFLQAAQcABcUGAAUYNAAsLIAZCAX0hBgwACwALIAAgBSAGp2ogCawiByAGfSIKQgAgCkIAVRsgAyADIAZ8IAdVG0F/EJcCCw8LIAUhCANAIAJB/wFxRSADUHJFBEAgCEEBaiEEAkAgAkH/AXFBvwFLBEADQCAEIghBAWohBCAILQAAIgJBwAFxQYABRg0ADAILAAsgBC0AACECIAQhCAsgA0IBfSEDDAELCyAAIAUgCCAFa6xBf0EBEKgCC+gBAgF/AX8jAEEQayIDJAACQCAAQSgQwQIiAEUgAigCABD0AiIEQQVGcg0AIAAgACkDGEIBfDcDGCAALQAgRQRAIARBAUcEQCAAIAApAxAQug0gAEEBOgAgIAAgAigCABBRELsNDAILIAMgACkDEDcDCCADQQhqIAIoAgAQXBC/B0UEQCAAIAMpAwg3AxAMAgsgAEEBOgAhIAAgACkDEBC6DSAAQQE6ACAgACACKAIAEFwQvA0MAQsgBEEBRgRAIAAgAigCABBcELwNDAELIABBADoAISAAIAIoAgAQURC7DQsgA0EQaiQAC00BAX4gAAJ8IAFCgICAgICAgAh9QoCAgICAgIBwWARAIAAgASABQoCAAYEiAn25OQMAIAK5DAELIAAgAbk5AwBEAAAAAAAAAAALOQMIC3gBAX8jAEEgayICIAE5AxggAiAAKwMAOQMQIAIgAisDECACKwMYoDkDCCAAIAArAwgCfCACKwMQmSACKwMYmWQEQCACKwMQIAIrAwihIAIrAxigDAELIAIrAxggAisDCKEgAisDEKALIgGgOQMIIAAgAisDCDkDAAtAAQF+AkAgAUKAgICAgICACH1CgICAgICAgHBWBEAgASECDAELIAAgASABQoCAAYEiAn25ELsNCyAAIAK5ELsNC4MBAwF/AXwBfAJAIABBABDBAiIBRQ0AIAEpAxhCAFcNACABLQAgBEAgAS0AIQRAIABBwypBfxCbAg8LIAErAwAhAiABKwMIIgO9QoCAgICAgID4/wCDQoCAgICAgID4/wBSBEAgACADIAKgEJgCDwsgACACEJgCDwsgACABKQMQEKACCwunAQIBfgF/IABBKBDBAiIARSACKAIAEPQCIgRBBUZyRQRAIAAgACkDGEIBfTcDGCAALQAgRQRAIAIoAgAQXCEDIAAgACkDECADfTcDEA8LIAIoAgAhAiAEQQFGBEAgAhBcIgNCgICAgICAgICAf1IEQCAAQgAgA30QvA0PCyAAQv///////////wAQ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HBBcIQ8gAigCIBBcIRACQCANRSAMRSAFRXJyDQAgDqciCkEASA0AIAkoAuwCIREgCSAFIAQQhAMiCEUNACAKIAguASJODQAgCCgCBCAKQQxsaigCACELIANBADYCyAIgA0HAAmoiB0IANwMAIANCADcDuAIgA0F/IAogCiAILgEgRhs2AsACIAlBADYC7AIgA0EgaiAEIAkgDCAQpxDUDSEHIANBADYCFCADQgA3AgwgA0EBIgZB7gBqNgIIIANB8AA2AgQgAyAINgLEAiADIANBuAJqNgIYIAMgA0EgajYCAAJAIAcNAAJAAkAgAygCkAIiBgRAAkACQCAGLQArDgMBBAAECyAGKAIsIgQgBCgCBEH///9+cTYCBCADQQA2AiwgA0EgaiAEQQAQkQpBByADKAIsIAktAFcbIgcNBCADIAQQsQkaDAMLIAUgBigCABBsIQcgAyAGNgLEAiAHDQEgBi4BIiAKSgRAIANBIGogA0G4AmogBigCBCAKQQxsaigCABDXDRoLIAMoAsACQQBIBEAgA0EgaiADQbgCaiADKAKQAkEgahDXDRoLIAMgAygCkAIoAhAQswkaIAMoApACQQhqIQQDQCAEKAIAIgQEQCADIAQoAigQswkaIARBFGohBAwBCwsgA0GUAmohBANAIAQoAgAiBARAIAMgBCgCKBCzCRogBEEUaiEEDAEFQQAhBANAIAQgAygCkAIiBi4BIk4NBCADIAYgBigCBCAEQQxsahCTCRCyCRogBEEBaiEEDAALAAsACwALIAMoApQCIgUEQCADIAUoAigQswkaIAMgAygClAIoAiQQsgkaDAILIANBIGoQ2A0iBw0CIAMoApgCQRxqIQUDQCAFKAIAIgUEQAJAIAUoAgwiB0UNACADQSBqQQAgByAEEPsCIAhHDQAgBSgCICIHBEAgA0EgaiADQbgCaiAHKAIIIAsQ2Q0LIANBIGogA0G4AmogBSgCHCALENoNIANBIGogA0G4AmogBSgCGCALENkNCyAFQShqIQUMAQsLIAggAygCnAFGBEAgA0EgaiADQbgCaiADKAKYAigCECALENoNCyADIAMoApgCENsNDAELIAZBMGohBANAIAQoAgAiCEUNAUEAIQQDQCAEIAgoAhRORQRAAkAgBw0AIAggBEEDdGpBJGoiBigCACAKRw0AIANBIGogA0G4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QgBSDQELCyADIAo2AmALQQAhCSAGQQA2AlAgBkEANgJEIAYgBikDOEIBfDcDOCAFrBDRDyAFICdqakEBaiEECyASIBIpAwAgBKx8NwMAIBsgBCAJaiADQeAAahDSECADKAJgIgQNACAGKAJQRQRAIAZBATYCUCAGKAJMQQA6AAALIBsgJiAHIAUgFCAIENYQIgQNACAAIBMQsA8hBAsgBEHkAEcgBigCBCIFIAFIckUEQCADQQA2AhQMAwsgBEHkAEYNAAsgAyAENgIUIAQNAwsgBigCBCEFCyAFQX9zIQ8gBigCzAQhCEEAIQRBACENA0AgCEEATCAEckUEQCAIQQFrIQhBACEHIAYoAswEIgVBACAFQQBKGyEEQQAhBQNAIAQgBUcEQCAFQQJ0IQcgBUEBaiEFIAcgEygCAGooAgAiBygCACAIRw0BCwsgBygCKARAIAcoAgAhCSAHKAI8IQUgBygCQCEHIANBADYCIEIAIQ4gA0IANwMYIANBADYCaCADQgA3A2AgA0IANwNYIANBADYCVEIAIRAgAEEgIANB1ABqQQAQug8iBEUEQCADKAJUIgRBASAMENICGiAEQQIgCRDRAhoCfyAEEIkBQeQARwRAQQAMAQsgBEEEEMgCIQogBEEEEMkCIRQgBEEBEIoBIRAgCiAUIANBGGogByAFIANB2ABqENcQCyIKIAQQiwEgChshBAsDQAJAIAQNACADKQNYIgtQDQAgA0EANgJQIANBADYCTAJAIAAgCyADQdAAaiADQcwAahDADyIEDQAgAygCUCADKAJMIANB4ABqIAcgBSADQdgAahDXECIEDQAgACALIAMoAmAgAygCZBDIECEECyADKAJQEEAgCyEODAELCwJAIA5QIARyDQAgA0EANgJQIABBESADQdAAakEAELoPIgQNACADKAJQIgVBASAQENICGiAFQQIgDkIBfRDSAhogBRCJARogBRCLASEECwJAIAQNACADQQA2AlAgAEEhIANB0ABqQQAQug8iBA0AIAMoAlAiBUEBIA4Q0gIaIAVBAiADKAIYIAMoAhxBABDNAhogBUEDIAwQ0gIaIAVBBCAJENECGiAFEIkBGiAFEIsBIQQgBUEBEM8CGgsgAygCGBBAIAMoAmAQQCANQQFqIQ0MAgUgACAHEMoQIgQNAiAHKAIAIQcgA0EANgIYIABB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KAIARwRAIAdBADoAACAAIAdBAWo2AgBBASEICyAGQTBqJAAgCAuxBQcBfwF/AX8BfwF/AX4BfiMAQTBrIgMkACADIAAoAgA2AiwgAyABKAIAIgY2AiggAyACKAIANgIkA0ACQAJAAkACQAJAAkACQAJAAkAgBi0AACIFRQRAIAMoAiQiBC0AAEUNBUH/////ByEEDAELQQAhBCAFQQFHDQACfyAGLAABIgRBAEgEQCAGQQFqIANBIGoQvw8aIAMoAiAMAQsgBEH/AXELIgRFDQELQf////8HIQUCQCADKAIkIgctAAAOAgMAAgsCfyAHLAABIgVBAEgEQCAHQQFqIANBHGoQvw8aIAMoAhwMAQsgBUH/AXELIgUNAgtBiwIhBQwGC0EAIQULIAQgBUcNAiADQgA3AxAgA0IANwMIIANCADcDACADIAcgA0EsaiAEELkQIgRqNgIkIAMgBCAGajYCKCADQShqIANBEGoQuhAgA0EkaiADQQhqELoQIAMpAxAiCEICWQRAIAMpAwgiCUIBVQ0CCyADKAIkIQQgAygCKCEGCyADIAMoAiwiB0EBajYCLEEAIQUgB0EAOgAAIAAgAygCLDYCACABIAZBAWo2AgAgAiAEQQFqNgIADAMLA0AgA0EsaiADIAggCSAIIAlTGxC7ECADIAMpAwBCAn03AwACQCAIIAlRBEAgA0EoaiADQRBqELwQIANBJGogA0EIahC8EAwBCyAIIAlTBEAgA0EoaiADQRBqELwQDAELIANBJGogA0EIahC8EAsgAykDECIIQv///////////wBSIAMpAwgiCUL///////////8AUnINAAsMAQsgBCAFSARAIAMgA0EsaiAEELkQIAZqNgIoIANBLGogA0EoahDTDwwBCyADIANBLGogBRC5ECAHajYCJCADQSxqIANBJGoQ0w8LIAMoAighBgwBCwsgA0EwaiQAIAULNwEBfyABRQRAQQAPCyAAKAIAIgJBAWogAawQ0g8hASACQQE6AAAgACACIAFBAWoiAWo2AgAgAQs8AQF/IwBBEGsiAiQAIAAgACgCACACQQhqELIPIAAoAgBqNgIAIAEgASkDACACKQMIfDcDACACQRBqJAALJAAgACAAKAIAIAIgASkDAH0Q0g8gACgCAGo2AgAgASACNwMAC4EBBAF/AX8BfwF/IwBBEGsi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BAsgBiAJQShqrRBJIgQ2AgwgBEUNACAEQgA3AgAgBEELNgIgIARCADcCGCAEQgA3AhAgBEIANwIIIAQgBEEoajYCJCAFRQ0BIAYgBSgCADYCCCAAIAZBCGogAiADEMkQIQMgBigCCCECIAUoAgBFBEAgBSACNgIACyAFIAQ2AgQgBSgCCCEAIAQgAjYCACAEIAA2AgggBCAFKAIcNgIcIAQgBSgCGDYCGCAFQQA2AhwMAgtBByEDDAILIAQgBDYCCCAAIAZBDGogAiADEMkQIQMgBigCDCEECyABIAQ2AgALIAZBEGokACADC2YBAX8jAEEQayICJAACQCABKQMIUARAQQAhAAwBCyAAQREgAkEMakEAELoPIgANACACKAIMIgBBASABKQMIENICGiAAQQIgASkDGBDSAhogABCJARogABCLASEACyACQRBqJAAgAAswAgF/AX8gACgCJEEKIAIQ0Q8iA2siBGogAToAACAAKAIkIANrQQtqIAIQ0g8aIAQLwgECAX8BfyMAQSBrIgkkAAJAIABBCyAJQRxqQQAQug8iCg0AIAkoAhwiAEEBIAEQ0gIaIABBAiACENECGiAAQQMgAxDSAhogAEEEIAQQ0gIaAkAgBlAEQCAAQQUgBRDSAhoMAQsgCSAGNwMIIAkgBTcDAEG+qwEgCRBnIgpFBEBBByEKDAILIABBBSAKQX9BARDVAhoLIABBBiAHIAhBABDNAhogABCJARogABCLASEKIABBBRDPAhoLIAlBIGokACAKC4IDBgF/AX8BfwF/AX8BfiMAQSBrIgMkAAJAIABBJSADQRxqQQAQug8iBg0AIAMoAhwiBEEBIAFCAXwQ0gIaIARBAiABQoAIf0IKhkL/B4QQ0gIaIAJCA35CAn8hCANAAkAgBSEHIAQQiQFB5ABHDQAgA0IANwMQIARBAiADQQhqIANBEGoQzxBBACEHIAMpAxAiAkIAVw0AQQEhBSACIAhXDQELCyAEEIsBIQYgB0UNACADQQA2AhAgA0EANgIIIAYNACAAQSYgA0EQakEAELoPIgYNACAAQScgA0EIakEAELoPIgYNACAEQQEgARDSAhogAygCECEFQQAhBwJAA0AgBBCJAUHkAEcNASAFQQEgBxDRAhogBUECIARBABCNARDRAhogBUEDIARBARCNARDRAhogBRCJARogB0EB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eBBADAELIAAgAygCeEF/QQEQpwILIANB0AFqJAALUAEBfyMAQRBrIgQkACADIAJBkPEAEIgCIgI2AgBBACEDIAJFBEAgBCABNgIAIABBu9gAIAQQZyIDQX8QmwIgAxBAQQEhAwsgBEEQaiQAIAMLUQEBfyMAQRBrIgMkACADQgA3AgQgAyAANgIAIAAoAhBBjAEgAxDdECEAIAEEQCABIAMoAgQ2AgALIAIEQCACIAMoAgg2AgALIANBEGokACAAC64BBAF/AX4BfwF/IwBBEGsiAyQAIAIoAhAiBSABQShsaiIGIAAoAhQoAkA2AgAgAigCACAAIAIoAgQgA0EMahDtECECAkAgAygCDCIARQ0AIANCADcDACAGIAA2AgQgA0EMaiADEN8QIAMpAwAiBEIAUwRAQYsCIQIMAQsgBSABQShsaiIAIAMoAgwiATYCICAAIAE2AhAgACAENwMYIAAgBDcDCAsgA0EQaiQAIAILLQEBfyMAQRBrIgMkACADQQA2AgwgACADQQxqIAEgAhDwECECIANBEGokACACC4oBBAF/AX8BfgF+IwBBEGsiAyQAIAMgACgCACIENgIMAkAgBEUNACADIAEpAwAiBTcDACACrCEGA0AgAygCDCEEAkAgBSAGUwRAIAQtAABBAk8NAUJ/IQVBACEECyABIAU3AwAgACAENgIADAILIANBDGogAxDfECADKQMAIQUMAAsACyADQRBqJAALawQBfwF/AX8BfyMAQRBrIgMkAAJAIAAoAgAiBCwAACICQQBIBEAgBCADQQxqEL8PIQIgAygCDCEFDAELIAJB/wFxIQVBASECCyAAIAIgBGo2AgAgASABKQMAIAVBAmusfDcDACADQRBqJAALmAEDAX8BfwF+IAJBAEgEQCABEO8VIQILAkAgACgCCCIDIAIgACgCBCIEakEBakoEQCAAKAIAIQMMAQsgACgCACACrCADrHxC5AB8IgUQTCIDRQRAQQcPCyAAIAU+AgggACADNgIAIAAoAgQhBAsgAyAEaiABIAIQ5RQaIAAgACgCBCACaiICNgIEIAAoAgAgAmpBADoAAEEAC4kHDgF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX8jAEGwAWsiAyQAAkAgAEGPwQAgAigCACADQRxqENoQDQAgACADKAIcIgQQiRANACAEKAIAIggoAiQoAgAhCiADQQA2AqgBIANCADcDoAEgBCgCEEUEQCAAQemfA0EAQQAQpwIMAQsgA0IANwOYASADQgA3A5ABIANCADcDiAEgA0IANwOAAQJAIARBACADQawBahDbECICDQAgAyADKAKsAUEYbK0Q+g8iAjYCmAECQCACRQ0AIAQpAyAhCyADIAQ2AoABIAMgCzcDkAEDQCAIKAIYIAdMBEBBACECDAMLIANBADYCdCADQQA2AnAgA0EANgJsIANBADYCiAEgAyAHNgKEASADQQA2AmggBCgCEEGNASADQYABahDdECICDQIgBCgCDCAHQQFqIgwQpwEhAiAEKAIMIAwQyQIhBgJAIAJFBEAgBCgCDCAMEKgBQQVHDQMMAQsgCCgCJCAEKAIUIAIgBiADQfwAahD7DyICDQMgAygCfCINIANB+ABqIANB9ABqIANB8ABqIANB7ABqIANB6ABqIAooAhQRCQAhAgNAIAMoAqwBIgZBACAGQQBKGyEOIAMoApgBIQ8CQANAIAINAUEAIQJB/////wchCUEAIQUDQCACIA5GRQRAIA8gAkEYbGoiBigCAARAIAYpAwggBikDEH0iC6cgCSALIAmsUyIQGyEJIAYgBSAQGyEFCyACQQFqIQIMAQsLQeUAIQIgBUUNAAsCQCAFKAIALQAAQQFNBEAgBUEANgIADAELIAUgBUEIahDfEAtBACECIAMoAnwhDQNAAkAgAg0AIAMoAmggCU4NACANIANB+ABqIANB9ABqIANB8ABqIANB7ABqIANB6ABqIAooAhQRCQAhAgwBCwsgAkUEQCADIAc2AgAgAyADKAJwIgI2AgggAyADKAJsIAJrNgIMIAMgBSADKAKYAWtBGG02AgQgA0GgAWpBwAAgA0EgakGUmgMgAxBpQX8Q4BAhAgwCCyACQeUARw0BQeUAQYsCIAgoAigbIQIMAQsLIA0gCigCEBEBABogAkHlAEcNAwsgDCEHDAALAAtBByECCyADKAKYARBAIAgQqg8gAgRAIAAgAhCwAiADKAKgARBADAELIAAgAygCoAEgAygCpAFBAWtBARCnAgsgA0GwAWokAAvCAQcBfwF+AX8BfgF/AX8BfiMAQRBrIgMkACADQgA3AwAgAigCACAAIAIoAgQgA0EMahDtECEIIAAoAhQoAkAhBSADKAIMBEAgA0EM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QSxqIQggASgCGCEEAkADQAJAIAEoAgAiBUUNACAEIAEoAgwoAghIDQAgACABEJYSIAAoAiwNAiABKAIMRQ0CIAZCADcDAEEEIQQMAQsLAkACQCABKAI0IARKBEAgASABKAIMKAIAIARqIANBGGoQ7REgBGqsNwMYIAEgASkDWCADKQMYfDcDWAwBCyABLQAEQQFxDQECQCAFBEBBACEFIANBADYCGCABKAIMENkSIARHBEAgASgCDCgCACAEaiADQRhqEOwRIARqIQQgAygCGCEFCyABIASsNwMYIAAgASAFELcSDAELIANBADYCGCADQQA2AhQgA0EANgIQIAAoAgwiBCAEKAIQKAIENgIQIAQgA0EUaiADQRBqIANBGGogA0EMahDEEiADKAIYIgRFDQIgASgCDCIFIAQ2AgAgBSADKAIMIgc2AgggBSAHNgIEIAEgBzYCNCAIIAFByABqIAMoAhAgAygCFBCtEiABIAQgBhDtEa03AxgLIAJFDQAgAkEBNgIACyAAIAEQlxIMAQsgASgCDBBAIAFBADYCDAsgA0EgaiQAC8EGCQF/AX8BfwF/AX4BfwF/AX8BfyMAQSBrIgQkACABKAIMIQUgBEEANgIcAkACQAJAIAEoAmAgASgCGGoiAyAFKAIISARAIAUoAgAhBgJAIAEoAjQgA0wEQEEBIQggBRDZEiADRg0BIAMgBmogBEEcahDsESADaiEDDAELIAMgBmogBEEQahDtESEFIAEgASkDWCAEKQMQfDcDWCADIAVqIQMLIAEgA6w3AxgMAQsCQCABKAIARQRAIARBADYCECAEQQA2AgwgBEEANgIIIARBADYCBCABLQAEQQFxRQRAIAAoAgwiAyADKAIQKAIENgIQIAMgBEEMaiAEQQhqIARBEGogBEEEahDEEiAEKAIQIgMNAgsgASgCDBBAIAFBADYCDAwECyABQTRqIQogAUHYAGohC0EAIQMDQCADDQIgACABEJYSIAEoAgwiBUUNBCAEIAUoAgAiCS8AACIDQQh0IANBCHZyQf//A3EiAzYCEAJAIANFIAUoAggiBiADTHJFBEAgBCADIAlqIAsQ7REgA2oiAzYCECABIAOtNwMYIAUoAggiBiAFKAIETg0BIAEgBSgCACAGaiAKEOwRIAZqNgIwIAUoAgghBgwBCyAFKAIEIAZMDQAgASAG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ACgCKCABQQN0aikDAFANAAsgACABNgIgIAINAQsgACgCECIBLQAQRQ0BIABBATYCDAsgAyEBDAELIAEgBEEYahDKEyEDIAQoAhghAQJAIAAoAhgiAkEASA0AIAAoAhwgAyABIAIgASACSBsQ6hQiBUEATkEAIAUgASACTHIbDQAgAEEBNgIMDAILIARBHGogAEE4aiABIAMQrRIgACgCJEEAIAZBA3QiARDnFBogACgCKEEAIAEQ5xQaIABBADYCICAEKAIcIgENACAHKAIcIQMgBqwhCgNAAkAgACgCCCgCDCgCOCEJIARCADcDECAEQQA2AgwgACgCECIIKAIMIQEgCCgCCCECAkACQAJAAkAgAw4CAQADCyAJDQEDQCACIAEgBEEMaiAEQRBqEKoSDQIgACgCJCIDIAMpAwBCAXw3AwAMAAsAC0F/IQUCQAJAIAkOAwACAQILA0AgAiABIARBDGogBEEQahCqEg0DIAQoAhQiAyAFRwRAIAMgBk4NBSAAKAIoIANBA3RqIgUgBSkDAEIBfDcDACADIQULIAAoAiQgA0EDdGoiAyADKQMAQgF8NwMADAALAAsDQCACIAEgBEEMaiAEQRBqEKoSDQIgBCkDECILIApZDQMgACgCKCALp0EDdGoiAyADKQMAQgF8NwMADAALAAsgACgCKCIBIAEpAwBCAXw3AwALIAgQyRMiASAHKAIcIgNBAkZyDQIgACgCECIFIARBGGoQyhMhCEEAIQEgBCgCGCICIAAoAjxHDQIgAkEASgRAIAggACgCOCACEOoUDQMLIAUtABBFDQEMAgsLQYsCIQELIAENAUEAIQEgACgCDA0BIAcoAhwNASAAKAIgIgEgBiABIAZKGyECA0ACQCABIAJHBEAgACgCKCABQQN0aikDAFANASABIQILQYsCQQAgAiAGRhshAQwDCyAAIAFBAWoiATYCIAwACwALQQAhAQsgBEEgaiQAIAELdgMBfwF/AX8gACgCHCIBIABBAEIAEJISAkAgASgCLA0AIAAgACgCSC8BBEHoAGxqIgEiAkHcAGooAgAiA0UNACABKAKYAS0AAEEwRg0AIAMQQCACQQA2AlwgAEEBOgAQCyAAKAIcIgAoAiwhASAAQQA2AiwgAQszAQF/IAAgACgCSC8BBEHoAGxqIgIoApgBIQAgASACKAKcAUEBazYC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BCAFRgRAQYsCDwUgBSgCACEFDAILAAsLIARFDQAgACAEKAIAEOoTGiACBEAgAiACKAIQQQFqNgIQCyAEIAI2AgALIAAgASACKQMIQbUBQbYBIAMbQQFqERwACy0AIAAoAlhBASABENICGiAAKAJYQQIgAhDSAhogACgCWBCJARogACgCWBCLAQstACAAKAJkQQEgARDSAhogACgCZEECIAIQ0gIaIAAoAmQQiQEaIAAoAmQQiwELywEEAX8BfwF/AX8jAEHgAGsiAyQAAkAgASgCACIFRQRADAELIAEoAhgiAi0AAyEEIAItAAIhAiAAIAFBACADQTBqEM4TQQEgBCACQQh0ciICIAJBAU0bIQRBASECA0AgAiAERkUEQCAAIAEgAiADEM4TIAAgA0EwaiADEIkUIAJBAWohAgwBCwsgAyAENgIAIAMgASkDCDcDMCAAIAEgAxCOFCICDQAgACAFIANBMGogAygCABCPFCAAIAUQlBQhAgsgA0HgAGokACACC2IDAX8BfwF/IABBA0EAELcDGiAAQQRBABC3AxoCQCAAQZntAhCsAyIHDQBCEBBJIgZFBEBBByEHDAELIAZCADcCACAGIAA2AgxBACEHIAZBADYCCCAGIQgLIAQgCDYCACAHC9kCBgF/AX8BfwF/AX8BfyABKAIAIgZBACAGQQBKGyEHAkADQCADIAdGDQECQAJAIAEoAgQiBSADQQxsaiICKAIAQQJHDQAgAi0ABEECRw0AIAUgA0EMbGotAAUNAUETDwsgA0EBaiEDDAELCyABKAIQIANBA3RqIgJBAToABCACQQE2AgBBAiEECyABQoCAgICAkKGXwQA3AyhBACECA0ACQCACIAdHBEAgASgCBCACQQxsaiIFLQAFRQ0BIAUoAgBBAEoNASAFLQAEQQJHDQEgAUEBNgI4IAFCATcDMCABQoCAgICAgID4PzcDKCABKAIQIAJBA3RqIgJBAToABCACQQJBASADIAZIGzYCACAEQQFyIQQLIAEgBDYCFCABKAIIQQBMBEBBAA8LAkAgASgCDCICKAIAQQBKDQAgAi0ABA0AIAFBATYCIAtBAA8LIAJBAWohAgwACwALCAAgABBAQQALPQEBf0IcEEkiAkUEQEEHDwsgAkIANwIIIAJBfzYCBCACIAA2AgAgAkEANgIYIAJCADcCECABIAI2AgBBAAsZAQF/IAAoAhAiAQRAIAEQ/wYLIAAQQEEAC/QBAgF/AX8gACgCACgCDCEFIABCATcCBAJAAkAgAUECcQRAIAAgBSAEKAIAEF8QhwEiBjYCFCAGQQBODQEMAgsgAEEANgIUCyAFKAIQIAZBBHRqKAIEIgVFDQAgACAFKAIEIgUoAgA2AgwgACAFKAIkNgIYIAAgBSgCMDYCCCABQQFxBEAgACAEIAFBAXRBfHFqKAIAEFynIgE2AgQCQCABQQBKBEAgACgCCCABTg0BCyAAQQE2AgRBACEBCyAAIAE2AggLIABBEGohASAAKAIQIgUEQCAFEP8GCyAAKAIMIgBBASABQQAgACgC3AERBQAPC0EACxEAIAAgACgCBEEBajYCBEEACw0AIAAoAgQgACgCCEoLzwEDAX8BfwF/IwBBEGsiAyQAAkACQAJAAkAgAg4CAAECCyABIAAoAgQQngJBACECDAILQQAhAiADQQA2AgwgACgCBCIEQezxBSgCACAAKAIYIgVtQQFqRgRAIAEgBRCtAgwCCyAAKAIMIgIgBCADQQxqQQAgAigC3AERBQAiAkUEQCABIAMoAgwoAgQgACgCGEF/EJECCyADKAIMEI4BDAELQQAhAiABIAEoAgAoAhQoAhAgACgCFEEEdGooAgBBf0EAEKcCCyADQRBqJAAgAgsOACABIAA0AgQ3AwBBAAu+AwYBfwF/AX8BfwF/AX4jAEEQayIEJAAgBEEANgIMAkACQCAAKAIMLQAjQRBxBEBB6CYhAQwBCyABQQFGBEBBj5cBIQEMAQtBACEBIAIoAgAQXCEJQqrVqtWq1arVqn8gAigCADMBEIinQQFxBEBBgTIhAQwBCyAJpyIFIAIoAgQQXKdHBEBBgTIhAQwBCyACKAIQEF8iAUUEQEHHwwEhAQwBCyAAKAIMIgYgARCHASIHQQBIBEBBx8MBIQEMAQtBlPcAIQEgBUUNACAGKAIQIAdBBHRqKAIEIgZFDQBBACEBIAUgBigCBCIHKAIwSwRAQZT3ACEBDAELQoGAhICAgMAAIAIoAgwiCDMBEIhCAYNQBEBBrpYBIQEMAQsgBygCJCEBQQAhByAIEP4BIAFHBEBBrpYBIQEMAQsCQCAGKAIEKAIAIgAgBSAEQQxqQQAgACgC3AERBQAiAA0AIAIoAgwQ+gEiAgRAIAQoAgwQwgEiAA0BIAQoAgwoAgQgAiABEOUUGgtBACEACyAEKAIMEI4BDAELIAAoAggQQCAEIAE2AgAgAEGz7gAgBBBnNgIIQQEhAAsgBEEQaiQAIAALRwIBfwF/IAAoAgwhAUEAIQADQCABKAIUIABKBEAgASgCECAAQQR0aigCBCICBEAgAkEBQQAQuwEaCyAAQQFqIQAMAQsLQQALvwEDAX8BfwF/IwBBEGsiBiQAAkACQCACQQRIDQAgBiADKAIMIgI2AgggBiACEFo2AgwgACAGQQhqEJ8LIghBAE4NACAGIAMoAgw2AgAgBUHg5wAgBhBnNgIAQQEhAgwBCyAAQQNBABC3AxoCQCAAQbCsBRCsAyICDQBCFBBJIgNFBEBBByECDAELIANCADcCACADIAg2AhAgAyAANgIMQQAhAiADQQA2AgggAyEHCyAEIAc2AgALIAZBEGokACACC48DBgF/AX8BfwF/AX8BfyABKAIAIgNBACADQQBKGyEHQX8hBEF/IQVBfyEGA0AgAiAHRwRAAkAgASgCBCACQQxsaiIDLQAEQQJHDQAgAy0ABUUEQEETDwsCQAJAAkAgAygCACIDQQprDgIBAgALIAMNAiACIQUMAgsgAiEEDAELIAIhBgsgAkEBaiECDAELC0EAIQIgBEEATgRAIAEoAhAgBEEDdGoiA0EBOgAEIANBATYCACABIAEoAhRBAXI2AhRBASECCyAFQQBOBEAgASgCECAFQQN0aiACQQFqIgI2AgAgASABKAIUQQJyNgIUCyAGQQBOBEAgASgCECAGQQN0aiACQQFqNgIAIAEgASgCFEEEcjYCFAsgAUKAgICAgICA+D83AygCQAJAAkACQCABKAIIQQFrDgIAAQMLIAEoAgwiAigCAA0CIAItAARFDQEMAgsgASgCDCICKAIADQEgAi0ABA0BIAIoAghBAUcNASACLQAMDQELIAFBATYCICABIAEoAhRBCHI2AhQLQQALCAAgABBAQQALNgEBf0LQChBJIgJFBEBBBw8LIAJBAEHQChDnFCICIAA2AgAgAiAAKAIQNgIMIAEgAjYCAEEACxYAIAAQphQgACgCBBCPARogABBAQQALagMBfwF/AX8DQCABQSBGRQRAIAAgAUEobGoiAkEQahCrFCACIgNBFGoiAigCABBAIANBADYCFCABQQFqIQEMAQsL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IAAtAAlFBEAgBiAHKAIcNgIAIABBs+4AIAYQZyIBNgKcCkEAQQcgARshAyAqKAIkIQELIAFBACABQQBKGyEEIAciK0EsaiEFQQAhAQNAIAEgBEZFBEAgKygCLCABQRhsaigCACACaiECIAFBAWohAQwBCwsgACAAKQO4CiACrHw3A7gKIAAtAAkNAQsLIAZBQGskACADC6UBAwF/AX8BfyMAQRBrIgMkACAAKAIEIgQoAiQhBSADQQA2AgwCQCACKAIERQRAIAIgBUGAAmoQPyIENgIEIARFBEBBByEADAILIAQgBWpBAEGAAhDnFBogACgCBCEECyAEKAIAIgAgASADQQxqQQAgACgC3AERBQAiAA0AIAIoAgQgAygCDCgCBCAFEOUUGiADKAIMEI4BQQAhAAsgA0EQaiQAIAALygEHAX8BfwF/AX8BfwF/AX4jAEEQayIBJAAgACgCACICKAIMKAIQIAIoAhBBBHRqKAIEIgUoAgQiAygCACgCQCECIAEgACgClAoiBK03AwACQAJAIAIoAgAiBgRAIAJBqIgOIAEgBigCKBECAEUNASAAKAKUCiEEIAUoAgQhAwsgACAAKQPICiADNAIkfCIHNwPICiAAIAcgBEEBa61+NwPACgwBCyAAIAEpAwA3A8AKIAAgACkDyAogASkDCHw3A8gKCyABQRBqJAALJQEBfyAAKAIEIQEgABCsFCAAKAIMEEAgAEEAQSgQ5xQgATYCBAtMAgF/AX8gACgCHARAA0AgACgCHCECIAEgACgCFE5FBEAgAiABQRhsaigCDBBAIAFBAWohAQwBCwsgAhBACyAAQQA2AhwgAEEANgIUCwcAIAAtAAgLnwIAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4LAAECAwQFBgcICQoLCyABIAAoApgKQX9BfxCnAgwLCyAALQAJDQogASAAKAKcCkF/QX8QpwIMCgsgAC0ACQRAIAEgADQCpAoQoAIMCgsgASAANQKUChCgAgwJCyAALQAJDQggASAAKAKgCkF/QQAQpwIMCAsgASAANAKoChCgAgwHCyABIAApA7gKEKACDAYLIAEgACkDsAoQoAIMBQsgASAANAKsChCgAgwECyAALQAJDQMgASAAKQPAChCgAgwDCyABIAApA8gKEKACDAILIAEgASgCACgCFCgCECAA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nhYgAEkEQCAAECFFDQELQYDeBiAANgIAIAEPCxDsFEEwNgIAQX8LuwoIAX4BfwF/AX4BfwF+AX8BfiMAQfAAayIHJAAgBEL///////////8AgyEIAkACQCABUCIGIAJC////////////AIMiBUKAgICAgIDA//8AfUKAgICAgIDAgIB/VCAFUBtFBEAgA0IAUiAIQoCAgICAgMD//wB9IgpCgICAgICAwICAf1YgCkKAgICAgIDAgIB/URsNAQsgBiAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgCEKAgICAgIDA//8AVCAIQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASAFQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiBhshBEIAIAEgBhshAwwCCyADIAhCgICAgICAwP//AIWEUA0BIAEgBYRQBEAgAyAIhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAIhFBFDQAgASEDIAIhBAwBCyADIAEgASADVCAFIAhUIAUgCFEbIgkbIQggBCACIAkbIgpC////////P4MhBSACIAQgCRsiAkIwiKdB//8BcSELIApCMIinQf//AXEiBkUEQCAHQeAAaiAIIAUgCCAFIAVQIgYbeSAGQQZ0rXynIgZBD2sQoRZBECAGayEGIAcpA2AhCCAHKQNoIQULIAEgAyAJGyEDIAJC////////P4MhBCALRQRAIAdB0ABqIAMgBCADIAQgBFAiCRt5IAlBBnStfKciCUEPaxChFkEQIAlrIQsgBykDWCEEIAcpA1AhAwsgBEIDhiADQj2IhEKAgICAgICABIQhASAFQgOGIAhCPYiEIQQgA0IDhiEFIAIgCoUhAwJAIAYgC0YNACAGIAtrIglB/wBLBEBCACEBQgEhBQwBCyAHQUBrIAUgAUGAASAJaxChFiAHQTBqIAUgASAJEKoWIAcpAzAgBykDQCAHKQNIhEIAUq2EIQUgBykDOCEBCyAEQoCAgICAgIAEhCEMIAhCA4YhCAJAIANCAFMEQEIAIQNCACEEIAUgCIUgASAMhYRQDQIgCCAFfSECIAwgAX0gBSAIVq19IgRC/////////wNWDQEgB0EgaiACIAQgAiAEIARQIgkbeSAJQQZ0rXynQQxrIgkQoRYgBiAJayEGIAcpAyghBCAHKQMgIQIMAQsgBSAIfCICIAVUrSABIAx8fCIEQoCAgICAgIAIg1ANACAFQgGDIARCP4YgAkIBiISEIQIgBkEBaiEGIARCAYghBAsgCkKAgICAgICAgIB/gyEFIAZB//8BTgRAIAVCgICAgICAwP//AIQhBEIAIQMMAQtBACEJAkAgBkEASgRAIAYhCQwBCyAHQRBqIAIgBCAGQf8AahChFiAHIAIgBEEBIAZrEKoWIAcpAwAgBykDECAHKQMYhEIAUq2EIQIgBykDCCEECyAEQj2GIAJCA4iEIQMgBEIDiEL///////8/gyAJrUIwhoQgBYQhBCACp0EHcSEGAkACQAJAAkACQBCoFg4DAAECAwsgBCADIAZBBEutfCIFIANUrXwhBCAGQQRHBEAgBSEDDAMLIAQgBUIBgyIBIAV8IgMgAVStfCEEDAMLIAQgAyAGQQBHIAVCAFJxrXwiBSADVK18IQQgBSEDDAELIAQgAyAFUCAGQQBHca18IgUgA1StfCEEIAUhAwsgBkUNAQsQqRYaCyAAIAM3AwAgACAENwMIIAdB8ABqJAALUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgL3QEDAX8BfgF+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC9UBAwF/AX4BfkF/IQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQAgACAChCAFIAaEhFAEQEEADwsgASADg0IAWQRAIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPCyAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLgAIFAX4BfwF+AX4BfyMAQRBrIgMkAAJ+IAG9IgRC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQUgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCAEQjyGIQUgBEIEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgAyACQgAgBKdnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahChFiADKQMAIQUgAykDCEKAgICAgIDAAIVBjPgAIAZrrUIwhoQLIQIgACAFNwMAIAAgAiAEQoCAgICAgICAgH+DhDcDCCADQRBqJAALcgMBfwF+AX8jAEEQayICJAACQCABQgBTDQAgAUIwiKdB//8BcSIEQf//AEkNAEJ/IQMgBEG/gAFrQUBJDQAgAiAAIAFC////////P4NCgICAgICAwACEQe+AASAEaxCqFiACKQMAIQMLIAJBEGokACADC4MBAwF+AX8BfyMAQRBrIgMkACAAAn4gAVAEQEIADAELIAMgASABQj+HIgKFIAJ9IgJCACACeaciBEExahChFiADKQMIQoCAgICAgMAAhUG+gAEgBGutQjCGfCABQoCAgICAgICAgH+DhCECIAMpAwALIgE3AwAgACACNwMIIANBEGokAAtnAwF/AX4BfyMAQRBrIgIkACAAAn4gAVAEQEIADAELIAIgAUIAIAF5pyIEQTFqEKEWIAIpAwhCgICAgICAwACFQb6AASAEa61CMIZ8IQMgAikDAAsiATcDACAAIAM3AwggAkEQaiQACwQAQQALBABBAAtQAQF+AkAgA0HAAHEEQCACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAvvChQBfwF+AX4BfwF+AX8BfgF+AX4BfgF/AX4BfgF+AX8BfgF+AX4BfgF+IwBB4ABrIgUkACAEQv///////z+DIQsgAiAEhUKAgICAgICAgIB/gyEGIAJC////////P4MiCUIgiCEOIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIPQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiB0KAgICAgIDA//8AVCAHQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQYMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBiADIQEMAgsgASAHQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhBkIAIQEMAwsgBkKAgICAgIDA//8AhCEGQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgB4QhAkIAIQEgAlAEQEKAgICAgIDg//8AIQYMAwsgBkKAgICAgIDA//8AhCEGDAILIAEgB4RQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAdC////////P1gEQCAFQdAAaiABIAkgASAJIAlQIgobeSAKQQZ0rXynIgpBD2sQoRZBECAKayEKIAUpA1giCUIgiCEOIAUpA1AhAQsgAkL///////8/Vg0AIAVBQGsgAyALIAMgCyALUCITG3kgE0EGdK18pyITQQ9rEKEWIAogE2tBEGohCiAFKQNIIQsgBSkDQCEDCyADQg+GIgdCgID+/w+DIgIgAUIgiCIEfiIQIAdCIIgiByABQv////8PgyIBfnwiDUIghiIRIAEgAn58IgwgEVStIAIgCUL/////D4MiCX4iFSAEIAd+fCIRIAtCD4YiEiADQjGIhEL/////D4MiAyABfnwiCyANIBBUrUIghiANQiCIhHwiECACIA5CgIAEhCINfiIWIAcgCX58Ig4gEkIgiEKAgICACIQiAiABfnwiEiADIAR+fCIUQiCGfCIXfCEBIAggD2ogCmpB//8AayEIAkAgAiAEfiIYIAcgDX58IgQgGFStIAQgAyAJfnwiByAEVK18IAIgDX58IAcgESAVVK0gCyARVK18fCIEIAdUrXwgAyANfiIDIAIgCX58IgIgA1StQiCGIAJCIIiEfCAEIAJCIIZ8IgIgBFStfCACIBIgFFatIA4gFlStIA4gElatfHxCIIYgFEIgiIR8IgQgAlStfCAEIAsgEFatIBAgF1atfHwiAiAEVK18IgRCgICAgICAwACDUEUEQCAIQQFqIQgMAQsgDEI/iCEDIARCAYYgAkI/iIQhBCACQgGGIAFCP4iEIQIgDEIBhiEMIAMgAUIBhoQhAQsgCEH//wFOBEAgBkKAgICAgIDA//8AhCEGQgAhAQwBCyAGAn4gCEEATARAQQEgCGsiD0H/AE0EQCAFQTBqIAwgASAIQf8AaiIIEKEWIAVBIGogAiAEIAgQoRYgBUEQaiAMIAEgDxCqFiAFIAIgBCAPEKoWIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQwgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAILQgAhAQwCCyAEQv///////z+DIAitQjCGhAsiBIQhBiAMUCABQgBZIAFCgICAgICAgICAf1EbRQRAIAYgAkIBfCIBIAJUrXwhBgwBCyAMIAFCgICAgICAgICAf4WEUEUEQCACIQEMAQsgBiACIAJCAYN8IgEgAlStfCEGCyAAIAE3AwAgACAGNwMIIAVB4ABqJAALdQEBfiAAIAEgBH4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCABIAJ+IANC/////w+DfCIBQiCIfDcDCCAAIAVC/////w+DIAFCIIaENwMAC9cDBAF+AX4BfwF/IwBBIGsiBCQAAkAgAUL///////////8AgyICQoCAgICAgMCAPH0gAkKAgICAgIDA/8MAfVQEQCABQgSGIABCPIiEIQIgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIAJCgYCAgICAgIDAAHwhAwwCCyACQoCAgICAgICAQH0hAyAAQoCAgICAgICACFINASADIAJCAYN8IQMMAQsgAFAgAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCEDDAELQoCAgICAgID4/wAhAyACQv///////7//wwBWDQBCACEDIAJCMIinIgVBkfcASQ0AIARBEGogACABQv///////z+DQoCAgICAgMAAhCICIAVBgfcAaxChFiAEIAAgAkGB+AAgBWsQqhYgBCkDCEIEhiAEKQMAIgJCPIiEIQMgBCkDECAEKQMYhEIAUq0gAkL//////////w+DhCICQoGAgICAgICACFoEQCADQgF8IQMMAQsgAkKAgICAgICAgAhSDQAgA0IBgyADfCEDCyAEQSBqJAAgAyABQoCAgICAgICAgH+DhL8LBAAjAAsGACAAJAALEgEBfyMAIABrQXBxIgEkACABCwuHogagAwBBgCALp4EDMy40Ni4wAHt9ACVzIiVzIjogeyJvZmZzZXQiOiVkLCJzaXplb2YiOiAlZCwic2lnbmF0dXJlIjoiJXMifQAlc3sAJXMiY2hhbmdlc2V0IjogewAlcyJzdG10U3RhdHVzIjogewAlcyJkYlN0YXR1cyI6IHsAJXMic3FsaXRlM1N0YXR1cyI6IHsAJXMibGltaXRzIjogewAlcyJhY2Nlc3MiOiB7ACVzImJsb2JGaW5hbGl6ZXJzIjogewAsIm1lbWJlcnMiOiB7ACVzImVuY29kaW5ncyI6IHsAJXMib3BlbkZsYWdzIjogewAlcyJ1ZGZGbGFncyI6IHsAJXMicHJlcGFyZUZsYWdzIjogewAlcyJzeW5jRmxhZ3MiOiB7ACVzImRhdGFUeXBlcyI6IHsAJXMicmVzdWx0Q29kZXMiOiB7ACVzImF1dGhvcml6ZXIiOiB7ACVzImlvQ2FwIjogewAlcyJzZXNzaW9uIjogewAlcyJ2ZXJzaW9uIjogewAlcyJmY250bCI6IHsAJXMiZmxvY2siOiB7ACVzImNvbmZpZyI6IHsAJXMiZGJDb25maWciOiB7ACVzInNlcmlhbGl6ZSI6IHsAJXMidHhuU3RhdGUiOiB7ACVzInRyYWNlIjogewAlcyJ2dGFiIjogewBwZ3N6ACV6JXMlegAlcy4legBJbiBSVHJlZSAlcy4lczoKJXoAanNvbl9wcmV0dHkAaW5kaWNhdGUgYWNjdW11bGF0b3IgZW1wdHkAaW5maW5pdHkAYWZmaW5pdHkAYnVzeQB0ZW1wX3N0b3JlX2RpcmVjdG9yeQBub3QgYSB3cml0YWJsZSBkaXJlY3RvcnkAb3BlbkRpcmVjdG9yeQBzaHJpbmtfbWVtb3J5AG91dCBvZiBtZW1vcnkAZmFpbGVkIHRvIGFsbG9jYXRlICV1IGJ5dGVzIG9mIG1lbW9yeQBIQVZJTkcgY2xhdXNlIG9uIGEgbm9uLWFnZ3JlZ2F0ZSBxdWVyeQB0ZW1wb3JhcnkAeERlc3Ryb3kAU0FWRVBPSU5UIGNoYW5nZXNldF9hcHBseQBST0xMQkFDSyBUTyBjaGFuZ2VzZXRfYXBwbHkAUkVMRUFTRSBjaGFuZ2VzZXRfYXBwbHkAcXVlcnlfb25seQByZWFkLW9ubHkAdW5saWtlbHkAZmtleQB0YWJsZSAiJXMiIGhhcyBtb3JlIHRoYW4gb25lIHByaW1hcnkga2V5AGZvcmVpZ24ga2V5AGpzb25fZ3JvdXBfYXJyYXkAanNvbmJfZ3JvdXBfYXJyYXkAanNvbl9hcnJheQBqc29uYl9hcnJheQBqdWxpYW5kYXkAbk9yZGVyQnkAYU9yZGVyQnkAZnRzNGF1eAB1bml4AHNxbGl0ZV9yZW5hbWVfcXVvdGVmaXgAcHJlZml4AExJS0Ugb3IgR0xPQiBwYXR0ZXJuIHRvbyBjb21wbGV4AHVuaGV4AGF1dG9tYXRpY19pbmRleABhdXRvLWluZGV4AG9ycGhhbiBpbmRleABhcmd2SW5kZXgAeEJlc3RJbmRleAB0YmwsIGlkeABwY3gAbWF4ACVzJS4zeCslLjZ4ACUwMngALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAAgRlJPTSAnJXEnLiclcSVzJyBBUyB4AENSRUFURSBUQUJMRSB4AHJ3AHBzb3cAaW1wbGllc19ub25udWxsX3JvdwBvdXRwdXQgZmluYWwgcm93AG91dHB1dCBvbmUgcm93AHBvdwBub3cAaW50ZWdlciBvdmVyZmxvdwBmdHM1OiBwYXJzZXIgc3RhY2sgb3ZlcmZsb3cAd2luZG93AHNoYWRvdwBuZXcAbm8gc3VjaCB2aWV3AGNhbm5vdCBtb2RpZnkgJXMgYmVjYXVzZSBpdCBpcyBhIHZpZXcAQ2Fubm90IGFkZCBhIGNvbHVtbiB0byBhIHZpZXcAY2Fubm90IFVQU0VSVCBhIHZpZXcAayBQUklNQVJZIEtFWSwgdgAgJWxsdQAlYyV1AEZhaWxlZCB0byByZWFkIHB0cm1hcCBrZXk9JXUAJS4qejoldQBPZmZzZXQgJXUgb3V0IG9mIHJhbmdlICV1Li4ldQBpbnZhbGlkIHBhZ2UgbnVtYmVyICV1AGZhaWxlZCB0byBnZXQgcGFnZSAldQAybmQgcmVmZXJlbmNlIHRvIHBhZ2UgJXUARnJhZ21lbnRhdGlvbiBvZiAldSBieXRlcyByZXBvcnRlZCBhcyAldSBvbiBwYWdlICV1AGZyZWVsaXN0IGxlYWYgY291bnQgdG9vIGJpZyBvbiBwYWdlICV1AE11bHRpcGxlIHVzZXMgZm9yIGJ5dGUgJXUgb2YgcGFnZSAldQAlcyBpcyAldSBidXQgc2hvdWxkIGJlICV1AFJlc3VsdCBvZiBTRUxFQ1QgJXUAdW5hYmxlIHRvIHVzZSBmdW5jdGlvbiAlcyBpbiB0aGUgcmVxdWVzdGVkIGNvbnRleHQAeE5leHQAcE5leHQAaW5jb21wbGV0ZSBpbnB1dABidXN5X3RpbWVvdXQAbG9jYWxob3N0AGVzdGltYXRlZENvc3QAY2Fubm90IGRyb3AgY29sdW1uICIlcyI6IG5vIG90aGVyIGNvbHVtbnMgZXhpc3QAcGVyc2lzdABmb3JlaWduX2tleV9saXN0AGluZGV4X2xpc3QAZnVuY3Rpb25fbGlzdABjb2xsYXRpb25fbGlzdABkYXRhYmFzZV9saXN0AG1vZHVsZV9saXN0AFBSQUdNQSB0YWJsZV9saXN0AHByYWdtYV9saXN0AHNldCBsaXN0AFZhbHVlTGlzdABzcWxpdGVfcmVuYW1lX3Rlc3QAZGVmZXIgSVBLIFJFUExBQ0UgdW50aWwgbGFzdABBdXhpbGlhcnkgcnRyZWUgY29sdW1ucyBtdXN0IGJlIGxhc3QAZmFzdABzcXJ0AEdST1VQIEJZIHNvcnQAYWJvcnQAIlwvYmZucnQAanNvbl9pbnNlcnQAanNvbmJfaW5zZXJ0AGNhbm5vdCBpbnNlcnQAcmVzdGFydABEaW1lbnNpb24gJWQgb2YgY2VsbCAlZCBvbiBub2RlICVsbGQgaXMgY29ycnVwdABmcmVlbGlzdF9jb3VudABtYXhfcGFnZV9jb3VudABQUkFHTUEgIiV3Ii5wYWdlX2NvdW50AHRyaWdnZXIgY291bnQAd2FsX2F1dG9jaGVja3BvaW50AHdhbF9jaGVja3BvaW50AHhTYXZlcG9pbnQAR3JvdXBieSByZXN1bHQgZ2VuZXJhdG9yIGVudHJ5IHBvaW50AGEgQ0hFQ0sgY29uc3RyYWludAAlc09OIENPTkZMSUNUIGNsYXVzZSBkb2VzIG5vdCBtYXRjaCBhbnkgUFJJTUFSWSBLRVkgb3IgVU5JUVVFIGNvbnN0cmFpbnQAbkNvbnN0cmFpbnQAYUNvbnN0cmFpbnQAX2NvbnRlbnQAJV9wYXJlbnQARGltZW5zaW9uICVkIG9mIGNlbGwgJWQgb24gbm9kZSAlbGxkIGlzIGNvcnJ1cHQgcmVsYXRpdmUgdG8gcGFyZW50AERJU1RJTkNUIGFnZ3JlZ2F0ZXMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFyZ3VtZW50AGNvbW1lbnQAQVBJIGNhbGxlZCB3aXRoIGZpbmFsaXplZCBwcmVwYXJlZCBzdGF0ZW1lbnQAQVBJIGNhbGxlZCB3aXRoIE5VTEwgcHJlcGFyZWQgc3RhdGVtZW50AGFyZ3VtZW50IHRvICVzKCkgaXMgbm90IGEgdmFsaWQgU1FMIHN0YXRlbWVudABkZWZhdWx0IHZhbHVlIG9mIGNvbHVtbiBbJXNdIGlzIG5vdCBjb25zdGFudABzcWxpdGVfc3RtdABJbml0IHN1YnF1ZXJ5IHJlc3VsdABJbml0IEVYSVNUUyByZXN1bHQAQ2Fubm90IGFkZCBhIGNvbHVtbiB3aXRoIG5vbi1jb25zdGFudCBkZWZhdWx0AGxhbm9pdABzdGF0X2luaXQAb21pdAB4Q29tbWl0AGFuYWx5c2lzX2xpbWl0AHNvZnRfaGVhcF9saW1pdABoYXJkX2hlYXBfbGltaXQAam91cm5hbF9zaXplX2xpbWl0AHJlY29yZCBMRUZUIEpPSU4gaGl0AE9OIGNsYXVzZSByZWZlcmVuY2VzIHRhYmxlcyB0byBpdHMgcmlnaHQAaGlnaGxpZ2h0AGhnaHQAc3FsaXRlX29mZnNldABpVGVybU9mZnNldAByZXNldABTQVZFUE9JTlQgY2hhbmdlc2V0AFJFTEVBU0UgY2hhbmdlc2V0AGpzb25fc2V0AGpzb25iX3NldAB0b28gbWFueSBjb2x1bW5zIGluIHJlc3VsdCBzZXQAJXIgT1JERVIgQlkgdGVybSBkb2VzIG5vdCBtYXRjaCBhbnkgY29sdW1uIGluIHRoZSByZXN1bHQgc2V0AHNuaXBwZXQAc3RhdF9nZXQAc3FsaXRlX2NvbXBpbGVvcHRpb25fZ2V0AHN0cmljdAB4RGlzY29ubmVjdAB4Q29ubmVjdABqc29uX2dyb3VwX29iamVjdABqc29uYl9ncm91cF9vYmplY3QAanNvbl9vYmplY3QAanNvbmJfb2JqZWN0AGpzb25fZXh0cmFjdABqc29uYl9leHRyYWN0AGxzdGF0AGZzdGF0AGRic3RhdAAlc19zdGF0AHRibCxpZHgsc3RhdAB0YmwsID8yLCBzdGF0AHVuc3VwcG9ydGVkIGZpbGUgZm9ybWF0AGdyb3VwX2NvbmNhdABkZWZlcl9mb3JlaWduX2tleXMAYWx3YXlzAGVzdGltYXRlZFJvd3MAcGFyYW1ldGVycyBhcmUgbm90IGFsbG93ZWQgaW4gdmlld3MAY29uY2F0X3dzAHN0YXR1cwBzeW5jaHJvbm91cwBpbmRleCAlcyBhbHJlYWR5IGV4aXN0cwBvdXRwdXQgZmlsZSBhbHJlYWR5IGV4aXN0cwAlcyAlVCBhbHJlYWR5IGV4aXN0cwB0cmlnZ2VyICVUIGFscmVhZHkgZXhpc3RzAGlnbm9yZV9jaGVja19jb25zdHJhaW50cwBDSEVDSyBjb25zdHJhaW50cwBleHByZXNzaW9ucyBwcm9oaWJpdGVkIGluIFBSSU1BUlkgS0VZIGFuZCBVTklRVUUgY29uc3RyYWludHMAanNvbl9vYmplY3QoKSByZXF1aXJlcyBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMAanNvbl8lcygpIG5lZWRzIGFuIG9kZCBudW1iZXIgb2YgYXJndW1lbnRzAHdyb25nIG51bWJlciBvZiB2dGFibGUgYXJndW1lbnRzACVzX3NlZ21lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IHVzZXItZnVuY3Rpb24gZHVlIHRvIGFjdGl2ZSBzdGF0ZW1lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IGNvbGxhdGlvbiBzZXF1ZW5jZSBkdWUgdG8gYWN0aXZlIHN0YXRlbWVudHMAb2Zmc2V0cwByZXZlcnNlX3Vub3JkZXJlZF9zZWxlY3RzAGlpc3Nzc3NzAGlzcwBzZXNzAHVuY29tcHJlc3MAY2Fubm90IG9wZW4gc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IHJlbGVhc2Ugc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IGNvbW1pdCB0cmFuc2FjdGlvbiAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGNhbm5vdCBWQUNVVU0gLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBvdXNuZXNzAHhSYW5kb21uZXNzAGZ1bG5lc3MAaXZlbmVzcwBhY2Nlc3MAeEFjY2VzcwBJZiBOVUxMLXNjYW4gMXN0IHBhc3MASWYgTlVMTC1zY2FuIDJuZCBwYXNzAHNlcGFyYXRvcnMAcGFyYW1ldGVycwByZWN1cnNpdmVfdHJpZ2dlcnMAdGhlIElOREVYRUQgQlkgY2xhdXNlIGlzIG5vdCBhbGxvd2VkIG9uIFVQREFURSBvciBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAdGhlIE5PVCBJTkRFWEVEIGNsYXVzZSBpcyBub3QgYWxsb3dlZCBvbiBVUERBVEUgb3IgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAHF1YWxpZmllZCB0YWJsZSBuYW1lcyBhcmUgbm90IGFsbG93ZWQgb24gSU5TRVJULCBVUERBVEUsIGFuZCBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAQ2hpbGQgcGFnZSBkZXB0aCBkaWZmZXJzAHRva2VuY2hhcnMAdW5hYmxlIHRvIGNsb3NlIGR1ZSB0byB1bmZpbmFsaXplZCBzdGF0ZW1lbnRzIG9yIHVuZmluaXNoZWQgYmFja3VwcwBhY29zAGNvbXBpbGVfb3B0aW9ucwBESVNUSU5DVCBpcyBub3Qgc3VwcG9ydGVkIGZvciB3aW5kb3cgZnVuY3Rpb25zAEZJTFRFUiBjbGF1c2UgbWF5IG9ubHkgYmUgdXNlZCB3aXRoIGFnZ3JlZ2F0ZSB3aW5kb3cgZnVuY3Rpb25zAG5vbi1kZXRlcm1pbmlzdGljIGZ1bmN0aW9ucwBpbmRleCBleHByZXNzaW9ucwBTRUxFQ1RzIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBvZiAlcyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcmVzdWx0IGNvbHVtbnMAdmlydHVhbCB0YWJsZXMgY2Fubm90IHVzZSBjb21wdXRlZCBjb2x1bW5zAGdlbmVyYXRlZCBjb2x1bW5zAHRhYmxlICVzIGhhcyAlZCB2YWx1ZXMgZm9yICVkIGNvbHVtbnMAcmFkaWFucwBhbGwgVkFMVUVTIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgdGVybXMAZW1wdHlfcmVzdWx0X2NhbGxiYWNrcwBpcwBmbGdzAGZsYWdzAGlkeEZsYWdzAGZpbGU6c2Vzc2lvbj92ZnM9a3Z2ZnMAZmlsZTpsb2NhbD92ZnM9a3Z2ZnMAbXVsdGlwbGUgY29udGVudD0uLi4gZGlyZWN0aXZlcwBtdWx0aXBsZSB0b2tlbml6ZT0uLi4gZGlyZWN0aXZlcwBtdWx0aXBsZSBjb250ZW50X3Jvd2lkPS4uLiBkaXJlY3RpdmVzACVkIGNvbHVtbnMgYXNzaWduZWQgJWQgdmFsdWVzAEpTT04gY2Fubm90IGhvbGQgQkxPQiB2YWx1ZXMAZmFpbGVkIG1lbW9yeSByZXNpemUgJXUgdG8gJXUgYnl0ZXMAcGFydGlhbCBpbmRleCBXSEVSRSBjbGF1c2VzAHNob3J0X2NvbHVtbl9uYW1lcwBmdWxsX2NvbHVtbl9uYW1lcwB1bmFibGUgdG8gb3BlbiBhIHRlbXBvcmFyeSBkYXRhYmFzZSBmaWxlIGZvciBzdG9yaW5nIHRlbXBvcmFyeSB0YWJsZXMAY2Fubm90IGNyZWF0ZSB0cmlnZ2VycyBvbiBzaGFkb3cgdGFibGVzAGNhbm5vdCBjcmVhdGUgdHJpZ2dlcnMgb24gdmlydHVhbCB0YWJsZXMAJXMgUkVUVVJOSU5HIGlzIG5vdCBhdmFpbGFibGUgb24gdmlydHVhbCB0YWJsZXMAY2Fubm90IGpvaW4gdXNpbmcgY29sdW1uICVzIC0gY29sdW1uIG5vdCBwcmVzZW50IGluIGJvdGggdGFibGVzAEFVVE9JTkNSRU1FTlQgbm90IGFsbG93ZWQgb24gV0lUSE9VVCBST1dJRCB0YWJsZXMAJXMgY2Fubm90IHVzZSB2YXJpYWJsZXMAdG9vIG1hbnkgU1FMIHZhcmlhYmxlcwBjYXRlZ29yaWVzAHN1YnF1ZXJpZXMAY2Fubm90IHVzZSB3aW5kb3cgZnVuY3Rpb25zIGluIHJlY3Vyc2l2ZSBxdWVyaWVzAGNvdW50X2NoYW5nZXMAdG90YWxfY2hhbmdlcwBkZWdyZWVzAFJFVFVSTklORyBtYXkgbm90IHVzZSAiVEFCTEUuKiIgd2lsZGNhcmRzAHBNZXRob2RzAHRocmVhZHMAeERldmljZUNoYXJhY3RlcmlzdGljcwByZW1vdmVfZGlhY3JpdGljcwBhYnMAJXolLipzAC4lLipzACwlLipzAENSRUFURSAlcyAlLipzAENSRUFURSVzIElOREVYICUuKnMAaW52YWxpZCB1cmkgYXV0aG9yaXR5OiAlLipzAHVua25vd24gc3BlY2lhbCBxdWVyeTogJS4qcwB1bmtub3duIHRhYmxlIG9wdGlvbjogJS4qcwAlLipzJXMALCVzJXMlcwBTQ0FOICVzJXMlcwBzcWxpdGVfYWx0ZXJ0YWJfJXMAU0NBTiAlZCBDT05TVEFOVCBST1clcwAlUSVzACBWSVJUVUFMIFRBQkxFIElOREVYICVkOiVzAHJbJWRdPSVzLiVzACVzOiAlcy4lcy4lcwBBbmFseXNpcyBmb3IgJXMuJXMAcmVjdXJzaXZlIGRlZmluaXRpb24gZm9yICVzLiVzAG1pc3NpbmcgZGF0YXR5cGUgZm9yICVzLiVzAGNhbm5vdCBzdG9yZSAlcyB2YWx1ZSBpbiAlcyBjb2x1bW4gJXMuJXMAbm9uLSVzIHZhbHVlIGluICVzLiVzAFRFWFQgdmFsdWUgaW4gJXMuJXMATlVMTCB2YWx1ZSBpbiAlcy4lcwBOVU1FUklDIHZhbHVlIGluICVzLiVzAG1hbGZvcm1lZCBpbnZlcnRlZCBpbmRleCBmb3IgRlRTJWQgdGFibGUgJXMuJXMAbWFsZm9ybWVkIGludmVydGVkIGluZGV4IGZvciBGVFM1IHRhYmxlICVzLiVzACVzOiAlcy4lcwBubyBzdWNoIHRhYmxlIGNvbHVtbjogJXMuJXMAQ2FsbDogJXMuJXMAbm8gc3VjaCBmdHM1IHRhYmxlOiAlcy4lcwBFbmQ6ICVzLiVzAFVOSVFVRSBjb25zdHJhaW50IGZhaWxlZDogJXMuJXMAREVMRVRFIEZST00gJVEuJXMALi4lcwAlLjE4cy0lcwBrdnZmcy0lcy0lcwBDUkVBVEUgVEFCTEUgJVEuJyVxXyVxJyglcyklcwAgVVNJTkcgSU5URUdFUiBQUklNQVJZIEtFWSAoJXMAcHJlcCBpbmRleCAlcwB1c2UgRFJPUCBWSUVXIHRvIGRlbGV0ZSB2aWV3ICVzAG1hdGNoIGFnYWluc3QgJXMAcm93IG5vdCBpbiBQUklNQVJZIEtFWSBvcmRlciBmb3IgJXMAaWxsZWdhbCBmaXJzdCBhcmd1bWVudCB0byAlcwBtaXN1c2Ugb2YgYWxpYXNlZCB3aW5kb3cgZnVuY3Rpb24gJXMAdG9vIG1hbnkgY29sdW1ucyBvbiAlcwBuZXh0IHNraXAtc2NhbiBvbiAlcwBiZWdpbiBza2lwLXNjYW4gb24gJXMAdG9vIG1hbnkgY29sdW1ucyBpbiAlcwAlcyBwcm9oaWJpdGVkIGluICVzAENIRUNLIGNvbnN0cmFpbnQgZmFpbGVkIGluICVzAG5vbi1kZXRlcm1pbmlzdGljIHVzZSBvZiAlcygpIGluICVzAHJlY292ZXJlZCAlZCBwYWdlcyBmcm9tICVzAG5leHQgcm93IG9mICVzAG1pc3VzZSBvZiBhbGlhc2VkIGFnZ3JlZ2F0ZSAlcwAlcyAlVCBjYW5ub3QgcmVmZXJlbmNlIG9iamVjdHMgaW4gZGF0YWJhc2UgJXMAY2Fubm90IGRldGFjaCBkYXRhYmFzZSAlcwBhIEpPSU4gY2xhdXNlIGlzIHJlcXVpcmVkIGJlZm9yZSAlcwBjYW5ub3Qgb3BlbiB2YWx1ZSBvZiB0eXBlICVzAGNhbm5vdCBmc3RhdCBkYiBmaWxlICVzAHJlY292ZXJlZCAlZCBmcmFtZXMgZnJvbSBXQUwgZmlsZSAlcwBzcWxpdGUzY2hhbmdlc2V0X2FwcGx5KCk6IHByaW1hcnkga2V5IG1pc21hdGNoIGZvciB0YWJsZSAlcwBQUklNQVJZIEtFWSBtaXNzaW5nIG9uIHRhYmxlICVzAHVzZSBEUk9QIFRBQkxFIHRvIGRlbGV0ZSB0YWJsZSAlcwBTRUxFQ1QgJXMgT1JERVIgQlkgcm93aWQgJXMAU0VMRUNUICVzIFdIRVJFIHJvd2lkIEJFVFdFRU4gJWxsZCBBTkQgJWxsZCBPUkRFUiBCWSByb3dpZCAlcwB0aGVyZSBpcyBhbHJlYWR5IGFuIGluZGV4IG5hbWVkICVzAHRhYmxlICVTIGhhcyBubyBjb2x1bW4gbmFtZWQgJXMAdGhlcmUgaXMgYWxyZWFkeSBhIHRhYmxlIG5hbWVkICVzAHN0YXRlbWVudCBhYm9ydHMgYXQgJWQ6IFslc10gJXMAQ09WRVJJTkcgSU5ERVggJXMAU0VMRUNUICVzAHVuc3VwcG9ydGVkIHVzZSBvZiBOVUxMUyAlcwBVU0UgVEVNUCBCLVRSRUUgRk9SICVzAC0tIFRSSUdHRVIgJXMAUklHSFQtSk9JTiAlcwA+PyBBTkQgJXMAOyAlcwAlejogJXMAcmVjdXJzaXZlIHJlZmVyZW5jZSBpbiBhIHN1YnF1ZXJ5OiAlcwB2dGFibGUgY29uc3RydWN0b3IgY2FsbGVkIHJlY3Vyc2l2ZWx5OiAlcwBubyBzdWNoIGluZGV4OiAlcwBubyBzdWNoIHdpbmRvdzogJXMAY2Fubm90IG92ZXJyaWRlICVzIG9mIHdpbmRvdzogJXMAY2Fubm90IG9wZW4gdmlldzogJXMAbm8gc3VjaCBzYXZlcG9pbnQ6ICVzAG5vIHN1Y2ggdmZzOiAlcwBtdWx0aXBsZSByZWN1cnNpdmUgcmVmZXJlbmNlczogJXMAZXJyb3IgaW4gJXMgJXMlcyVzOiAlcwBmdHM1OiBlcnJvciBjcmVhdGluZyBzaGFkb3cgdGFibGUgJXFfJXM6ICVzAHVuYWJsZSB0byB2YWxpZGF0ZSB0aGUgaW52ZXJ0ZWQgaW5kZXggZm9yIEZUUyVkIHRhYmxlICVzLiVzOiAlcwB1bmFibGUgdG8gdmFsaWRhdGUgdGhlIGludmVydGVkIGluZGV4IGZvciBGVFM1IHRhYmxlICVzLiVzOiAlcwBlcnJvciBpbiAlcyAlcyBhZnRlciAlczogJXMAdW5rbm93biB0b2tlbml6ZXI6ICVzAG5vIHN1Y2ggdG9rZW5pemVyOiAlcwBlcnJvciBwYXJzaW5nIHByZWZpeCBwYXJhbWV0ZXI6ICVzAHVucmVjb2duaXplZCBwYXJhbWV0ZXI6ICVzAHVucmVjb2duaXplZCBvcmRlcjogJXMAdW5yZWNvZ25pemVkIG1hdGNoaW5mbzogJXMAdW5yZWNvZ25pemVkIGNvbHVtbiBvcHRpb246ICVzAHBhcnNlIGVycm9yIGluIHJhbmsgZnVuY3Rpb246ICVzAG5vIHN1Y2ggZnVuY3Rpb246ICVzAG5vIHN1Y2ggY29sdW1uOiAlcwBmaWxlIHJlbmFtZWQgd2hpbGUgb3BlbjogJXMAZmlsZSB1bmxpbmtlZCB3aGlsZSBvcGVuOiAlcwBjYW5ub3QgbGltaXQgV0FMIHNpemU6ICVzAE1KIGRlbGV0ZTogJXMAdGFyZ2V0IG9iamVjdC9hbGlhcyBtYXkgbm90IGFwcGVhciBpbiBGUk9NIGNsYXVzZTogJXMAb2JqZWN0IG5hbWUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzZTogJXMAdW5rbm93biBkYXRhYmFzZTogJXMAdW5hYmxlIHRvIG9wZW4gZGF0YWJhc2U6ICVzAG5vIHN1Y2ggZGF0YWJhc2U6ICVzAHRoZXJlIGlzIGFscmVhZHkgYW5vdGhlciB0YWJsZSBvciBpbmRleCB3aXRoIHRoaXMgbmFtZTogJXMAZHVwbGljYXRlIGNvbHVtbiBuYW1lOiAlcwByZXNlcnZlZCBmdHM1IGNvbHVtbiBuYW1lOiAlcwBkdXBsaWNhdGUgV0lUSCB0YWJsZSBuYW1lOiAlcwByZXNlcnZlZCBmdHM1IHRhYmxlIG5hbWU6ICVzAG5vIHN1Y2ggbW9kdWxlOiAlcwBtdWx0aXBsZSBsaW5rcyB0byBmaWxlOiAlcwBjYW5ub3Qgb3BlbiB2aXJ0dWFsIHRhYmxlOiAlcwBzcWxpdGUzY2hhbmdlc2V0X2FwcGx5KCk6IG5vIHN1Y2ggdGFibGU6ICVzAG11bHRpcGxlIHJlZmVyZW5jZXMgdG8gcmVjdXJzaXZlIHRhYmxlOiAlcwBjYW5ub3QgVVBEQVRFIGEgc3Vic2V0IG9mIGNvbHVtbnMgb24gZnRzNSBjb250ZW50bGVzcy1kZWxldGUgdGFibGU6ICVzAGNhbm5vdCAlcyBjb250ZW50bGVzcyBmdHM1IHRhYmxlOiAlcwBubyBzdWNoICVzIG1vZGU6ICVzAE1KIGNvbGxpZGU6ICVzAG5vIHN1Y2ggY29sbGF0aW9uIHNlcXVlbmNlOiAlcwBjaXJjdWxhciByZWZlcmVuY2U6ICVzAGNhbm5vdCBvcGVuIHRhYmxlIHdpdGhvdXQgcm93aWQ6ICVzACVzIG1vZGUgbm90IGFsbG93ZWQ6ICVzAHZ0YWJsZSBjb25zdHJ1Y3RvciBmYWlsZWQ6ICVzAGF1dG9tYXRpYyBleHRlbnNpb24gbG9hZGluZyBmYWlsZWQ6ICVzAHZ0YWJsZSBjb25zdHJ1Y3RvciBkaWQgbm90IGRlY2xhcmUgc2NoZW1hOiAlcwBhYm9ydCBhdCAlZCBpbiBbJXNdOiAlcwAtLSAlcwAleiAtICVzAG9zX3VuaXguYzolZDogKCVkKSAlcyglcykgLSAlcwBTRUxFQ1Qgcm93aWQsIHJhbmsgRlJPTSAlUS4lUSBPUkRFUiBCWSAlcygiJXciJXMlcykgJXMAd3IAaW5zdHIAY3N0cgBzdWJzdHIAZnRzNV9hcGlfcHRyAE5VTEwtc2NhbiBwYXNzIGN0cgBpZHhTdHIAbmVlZFRvRnJlZUlkeFN0cgBleHByX2ltcGxpZXNfZXhwcgBiZWdpbiBJTiBleHByAGVuZCBJTiBleHByAGludmFsaWQgYXJndW1lbnRzIHRvIGZ0czRhdXggY29uc3RydWN0b3IAZXJyb3IgaW4gdG9rZW5pemVyIGNvbnN0cnVjdG9yAG1pc3NpbmcgJXMgcGFyYW1ldGVyIGluIGZ0czQgY29uc3RydWN0b3IAUkhTIG9mIElOIG9wZXJhdG9yAHRoZSAiLiIgb3BlcmF0b3IAZW5kIGdyb3VwYnkgcmVzdWx0IGdlbmVyYXRvcgByZXNldCBhY2N1bXVsYXRvcgBpbmRpY2F0ZSBkYXRhIGluIGFjY3VtdWxhdG9yAGZ0czNjdXJzb3IAbmVhciAiJVQiOiBzeW50YXggZXJyb3IAdW5rbm93biBlcnJvcgBub3QgYW4gZXJyb3IAU1FMIGxvZ2ljIGVycm9yAGRpc2sgSS9PIGVycm9yAHhHZXRMYXN0RXJyb3IAeERsRXJyb3IAZmxvb3IAcm1kaXIAbWtkaXIAc2VnZGlyAGZ0czNfdG9rZW5pemVyAHVua25vd24gdG9rZW5pemVyAHBvd2VyAGxvd2VyAHNxbGl0ZV90ZW1wX21hc3RlcgBzcWxpdGVfbWFzdGVyAHBvcnRlcgBMSUtFIGxvb3AgY291bnRlcgBMSU1JVCBjb3VudGVyAFplcm8gT0ZGU0VUIGNvdW50ZXIAc3RtdC1wb2ludGVyAEFQSSBjYWxsIHdpdGggJXMgZGF0YWJhc2UgY29ubmVjdGlvbiBwb2ludGVyAHhGaWx0ZXIARVNDQVBFIGV4cHJlc3Npb24gbXVzdCBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIAdXBwZXIAeFNobUJhcnJpZXIAY2Fubm90IHVzZSBSRVRVUk5JTkcgaW4gYSB0cmlnZ2VyAHNlY29uZCBhcmd1bWVudCB0byBudGhfdmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAYXJndW1lbnQgb2YgbnRpbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAZnJhbWUgc3RhcnRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBmcmFtZSBlbmRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBSb3dpZCAlbGxkIG91dCBvZiBvcmRlcgBmcmFtZSBzdGFydGluZyBvZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIAZnJhbWUgZW5kaW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcgBiYWQgcGFnZSBudW1iZXIAYWRkcgBjaGFyAHllYXIAc2VxACVxAHJlZ2V4cABTQVZFUE9JTlQgcmVwbGFjZV9vcABSRUxFQVNFIHJlcGxhY2Vfb3AAL3Vzci90bXAAL3Zhci90bXAAdGVtcABjdXJyZW50X3RpbWVzdGFtcAB4U2xlZXAAbXVubWFwAHhTaG1Vbm1hcABtbWFwAG1yZW1hcAB4U2htTWFwAHNxbGl0ZV9yZXR1cm5pbmdfJXAAdnRhYjolcABzc2Vuc3VvAGlsc3VvAGF1dG8AaW50bwBpbmNyZW1lbnRhbF92YWN1dW0gZW5hYmxlZCB3aXRoIGEgbWF4IHJvb3RwYWdlIG9mIHplcm8Ac2Vxbm8ASU5TRVJUIElOVE8iJXciLiIld19yb3dpZCIocm93aWQsbm9kZW5vKVZBTFVFUyg/MSw/MilPTiBDT05GTElDVChyb3dpZClETyBVUERBVEUgU0VUIG5vZGVubz1leGNsdWRlZC5ub2Rlbm8AQ1JFQVRFIFRBQkxFICIldyIuIiV3X3Jvd2lkIihyb3dpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLG5vZGVubwBoZWxsbwBpbmRleF94aW5mbwB0YWJsZV94aW5mbwBtYXRjaGluZm8AaW5kZXhfaW5mbwB0YWJsZV9pbmZvAHhSb2xsYmFja1RvAEwqIE4qIENvAHVua25vd24AZmNob3duAGpzb24Abm8gcXVlcnkgc29sdXRpb24AaW5kZXggY29ycnVwdGlvbgBkYXRhYmFzZSBjb3JydXB0aW9uAGZyZWUgc3BhY2UgY29ycnVwdGlvbgBjYWxsIGZsdXNoX3BhcnRpdGlvbgBqc29uX2Vycm9yX3Bvc2l0aW9uAHVua25vd24gY29sdW1uICIlcyIgaW4gZm9yZWlnbiBrZXkgZGVmaW5pdGlvbgAlcy54QmVzdEluZGV4IG1hbGZ1bmN0aW9uAGF1dGhvcml6ZXIgbWFsZnVuY3Rpb24AJSNUKCkgbWF5IG5vdCBiZSB1c2VkIGFzIGEgd2luZG93IGZ1bmN0aW9uACclcycgaXMgbm90IGEgZnVuY3Rpb24AeEZpbmRGdW5jdGlvbgBjYW5ub3Qgc3RhcnQgYSB0cmFuc2FjdGlvbiB3aXRoaW4gYSB0cmFuc2FjdGlvbgBjYW5ub3QgY2hhbmdlICVzIHdhbCBtb2RlIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AdGVtcG9yYXJ5IHN0b3JhZ2UgY2Fubm90IGJlIGNoYW5nZWQgZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgBjYW5ub3QgVkFDVVVNIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AU2FmZXR5IGxldmVsIG1heSBub3QgYmUgY2hhbmdlZCBpbnNpZGUgYSB0cmFuc2FjdGlvbgBpemF0aW9uAHVua25vd24gb3BlcmF0aW9uAHVuc3VwcG9ydGVkIGZyYW1lIHNwZWNpZmljYXRpb24Ac2Vzc2lvbgBSQU5HRSB3aXRoIG9mZnNldCBQUkVDRURJTkcvRk9MTE9XSU5HIHJlcXVpcmVzIG9uZSBPUkRFUiBCWSBleHByZXNzaW9uAHRvbyBtYW55IGxldmVscyBvZiB0cmlnZ2VyIHJlY3Vyc2lvbgB1c2VyX3ZlcnNpb24Ac3FsaXRlX3ZlcnNpb24AUFJBR01BICVRLmRhdGFfdmVyc2lvbgBzY2hlbWFfdmVyc2lvbgBpVmVyc2lvbgBzcWxpdGVfZHJvcF9jb2x1bW4Ac3FsaXRlX3JlbmFtZV9jb2x1bW4AYWZ0ZXIgZHJvcCBjb2x1bW4Abm8gc3VjaCBjb2x1bW4AbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub24tZ2VuZXJhdGVkIGNvbHVtbgBjYW5ub3QgdXNlIERFRkFVTFQgb24gYSBnZW5lcmF0ZWQgY29sdW1uAGFkZCBjb2x1bW4AQ2Fubm90IGFkZCBhIFBSSU1BUlkgS0VZIGNvbHVtbgBDYW5ub3QgYWRkIGEgVU5JUVVFIGNvbHVtbgBjYW5ub3QgYWRkIGEgU1RPUkVEIGNvbHVtbgB4Q29sdW1uAGlDb2x1bW4AbG4AYnVpbHRpbgBhc2luAGF0IG1vc3QgJWQgdGFibGVzIGluIGEgam9pbgBtaW4ALG9yaWdpbgB4QmVnaW4AbWFpbgBleHBsYWluAHNpZ24Ac3NlbgBvcGVuAHhPcGVuAHhEbE9wZW4AaGlkZGVuAGF0YW4AbmFuAHhEbFN5bQBhdXRvX3ZhY3V1bQBpbmNyZW1lbnRhbF92YWN1dW0Ac3VtAGZsZXhudW0AaWR4TnVtAGFsaXNtAHBtAGRyb3AgY29sdW1uIGZyb20AREVMRVRFIGZyb20AL2Rldi91cmFuZG9tAHJ0cmltAGx0cmltAHJlYWRvbmx5X3NobQAlcy1zaG0AdG5lbQBSQUlTRSgpIG1heSBvbmx5IGJlIHVzZWQgd2l0aGluIGEgdHJpZ2dlci1wcm9ncmFtAHRyaWdyYW0AZnVsAGZjbnRsAGlvY3RsAHhGaWxlQ29udHJvbABpZ29sAGxvY2tpbmcgcHJvdG9jb2wAbmNvbABqcm5sAG5vdG51bGwAaWZudWxsAC9kZXYvbnVsbABkYXRhYmFzZSBvciBkaXNrIGlzIGZ1bGwAY29sbABjYWNoZV9zcGlsbAB4TmV4dFN5c3RlbUNhbGwAeFNldFN5c3RlbUNhbGwAeEdldFN5c3RlbUNhbGwAZGVsZXRlLWFsbABjZWlsAGRldGFpbABmYWlsAHVuaXgtZXhjbAB0YmwAd2FsAHZpcnR1YWwAdG90YWwAaW5jcmVtZW50YWwAc2Vzc2lvbi1qb3VybmFsAGxvY2FsLWpvdXJuYWwAaW50ZXJuYWwAYXRpb25hbABub3JtYWwASW5kZXggYWxyZWFkeSBvcHRpbWFsAHBhcnRpYWwAcmVhbABsb2NhbABwawBvawB1bmxpbmsAcmVhZGxpbmsAbm9sb2NrAHhVbmxvY2sAYmxvY2sAJXMubG9jawB4TG9jawB4U2htTG9jawB4Q2hlY2tSZXNlcnZlZExvY2sAYnlwYXNzIHJlY2hlY2sAcnRyZWVjaGVjawBpbnRlZ3JpdHlfY2hlY2sAZm9yZWlnbl9rZXlfY2hlY2sAcXVpY2tfY2hlY2sAY2VsbF9zaXplX2NoZWNrAGludGVncml0eS1jaGVjawByb2xsYmFjawB4Um9sbGJhY2sAagByZXppAG5vaXRhemkAaXRpdmkAc3NlbmV2aQBpdml0aQBiaWxpdGkAYWxpdGkAaWNpdGkAaXNzaXNpAGlzaXNpAHBpAG5vaQBnbmkAZW50bGkAb3VzbGkAZWxpAGJsaQBzaXNzaWkAaXNzaXNpaQBzc3NpaWkAYXNjaWkAc2VpAGl0aWNpAGV0YWNpAGxhY2kAcnRyZWVkZXB0aABtb250aABqc29uX2FycmF5X2xlbmd0aABvY3RldF9sZW5ndGgAb3ZlcmZsb3cgbGlzdCBsZW5ndGgAd2R0aABzdGF0X3B1c2gAZmx1c2gAYWNvc2gAYXNpbmgAYXRhbmgAeFVuZmV0Y2gAeEZldGNoAGpzb25fcGF0Y2gAanNvbmJfcGF0Y2gAZGF0YXR5cGUgbWlzbWF0Y2gAYXJndW1lbnQgdHlwZSBtaXNtYXRjaAB0YWJsZSBzY2hlbWFzIGRvIG5vdCBtYXRjaABhYmJyZXZpYXRlZCBxdWVyeSBhbGdvcml0aG0gc2VhcmNoAHVuaXhlcG9jaABzcWxpdGVfYXR0YWNoAHNxbGl0ZV9kZXRhY2gAanNvbl9lYWNoAGF2ZwB6RXJyTXNnAG5hcmcAUnRyZWVNYXRjaEFyZwBzcWxpdGVfbG9nAHN0YXRlbWVudCB0b28gbG9uZwBjYW5ub3Qgb3BlbiAlcyBjb2x1bW4gZm9yIHdyaXRpbmcAc3Vic3RyaW5nAHVudGVybWluYXRlZCBzdHJpbmcAJXM6IHRhYmxlIGRvZXMgbm90IHN1cHBvcnQgc2Nhbm5pbmcAY2VpbGluZwBjb25maWcAc3RyaW5nIG9yIGJsb2IgdG9vIGJpZwBzdHJpbmdfYWdnAHNldCBhYm9ydCBmbGFnAGNsZWFyIGFib3J0IGZsYWcAY2hlY2sgYWJvcnQgZmxhZwBpbml0IExFRlQgSk9JTiBtYXRjaCBmbGFnACUuMTZnACUhMC4xNWcAJSEuMTVnACAlZwBzc2VubHVmAHByaW50ZgB0eXBlb2YAbW9kZW9mAHhFb2YAb3V0IG9mAHJlbmFtZSBjb2x1bW5zIG9mAGluZgAtSW5mAG51bGxpZgBpaWYAb2ZmAHRpbWVkaWZmADAxMjM0NTY3ODlhYmNkZWYAblJlZgBsZWFmACVjJTA0ZC0lMDJkLSUwMmQgJTAyZDolMDJkOiUwNi4zZgAlLjNmADUwZgA0MGYAJSEuKmYAY29sdW1uc2l6ZQBoYXNoc2l6ZQBnZXRwYWdlc2l6ZQBkb2NzaXplAG1tYXBfc2l6ZQBjYWNoZV9zaXplAFBSQUdNQSAlUS5wYWdlX3NpemUAZnRzM3Rva2VuaXplAG9wdGltaXplAGFsaXplAG5LZXlTaXplAHhTZWN0b3JTaXplAHhGaWxlU2l6ZQBqc29uX3JlbW92ZQBqc29uYl9yZW1vdmUAY2FzZV9zZW5zaXRpdmUAcGFyc2UgZXJyb3IgaW4gdG9rZW5pemUgZGlyZWN0aXZlAG1hbGZvcm1lZCBwcmVmaXg9Li4uIGRpcmVjdGl2ZQBtYWxmb3JtZWQgZGV0YWlsPS4uLiBkaXJlY3RpdmUAbWFsZm9ybWVkIGNvbHVtbnNpemU9Li4uIGRpcmVjdGl2ZQBtYWxmb3JtZWQgY29udGVudGxlc3NfZGVsZXRlPS4uLiBkaXJlY3RpdmUAbWFsZm9ybWVkIHRva2VuZGF0YT0uLi4gZGlyZWN0aXZlAGNhbm5vdCBjb21taXQgLSBubyB0cmFuc2FjdGlvbiBpcyBhY3RpdmUAY2Fubm90IHJvbGxiYWNrIC0gbm8gdHJhbnNhY3Rpb24gaXMgYWN0aXZlAGF0aXZlAGV4Y2x1c2l2ZQB0cnVlAHVuaXF1ZQBkZmx0X3ZhbHVlAENhbm5vdCBhZGQgYSBSRUZFUkVOQ0VTIGNvbHVtbiB3aXRoIG5vbi1OVUxMIGRlZmF1bHQgdmFsdWUAYmFkIHBhZ2UgdmFsdWUAanNvbl9xdW90ZQBwd3JpdGUAeFdyaXRlAGNvbnRlbnRsZXNzX2RlbGV0ZQBvbl9kZWxldGUAc2VjdXJlX2RlbGV0ZQBzZWN1cmUtZGVsZXRlAGNhbm5vdCBkZWxldGUAeERlbGV0ZQBwcml2YXRlAGFnZ3JlZ2F0ZQBjcmVhdGUAeENyZWF0ZQBvbl91cGRhdGUAeFVwZGF0ZQBjdXJyZW50X2RhdGUAZmFsbG9jYXRlAGZ0cnVuY2F0ZQB4VHJ1bmNhdGUAaWNhdGUAYmFkIHBhcmFtZXRlciBvciBvdGhlciBBUEkgbWlzdXNlAHRvbyBtYW55IHRlcm1zIGluICVzIEJZIGNsYXVzZQB0b28gbWFueSB0ZXJtcyBpbiBPUkRFUiBCWSBjbGF1c2UAYWdncmVnYXRlIGZ1bmN0aW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gdGhlIEdST1VQIEJZIGNsYXVzZQBQQVJUSVRJT04gY2xhdXNlAGEgTkFUVVJBTCBqb2luIG1heSBub3QgaGF2ZSBhbiBPTiBvciBVU0lORyBjbGF1c2UAZGF0YWJhc2UgJXMgaXMgYWxyZWFkeSBpbiB1c2UAY2xvc2UAeENsb3NlAHhEbENsb3NlAGZhbHNlAHBocmFzZQB4UmVsZWFzZQBhdHRlbXB0IHRvIHdyaXRlIGEgcmVhZG9ubHkgZGF0YWJhc2UAY29ycnVwdCBkYXRhYmFzZQBhdHRhY2hlZCBkYXRhYmFzZXMgbXVzdCB1c2UgdGhlIHNhbWUgdGV4dCBlbmNvZGluZyBhcyBtYWluIGRhdGFiYXNlAE5vZGUgJWxsZCBtaXNzaW5nIGZyb20gZGF0YWJhc2UAZmlsZSBpcyBub3QgYSBkYXRhYmFzZQB0ZW1wX3N0b3JlAGlnbm9yZQBzcWxpdGUzY2hhbmdlc2V0X2FwcGx5KCk6IHRhYmxlICVzIGhhcyAlZCBjb2x1bW5zLCBleHBlY3RlZCAlZCBvciBtb3JlACVzIGNsYXVzZSBzaG91bGQgY29tZSBhZnRlciAlcyBub3QgYmVmb3JlAGV4cHJfY29tcGFyZQBzdWJ0eXBlAGpzb25fdHlwZQBpbHRuZQB1bml4LW5vbmUAZW5kIGlubmVyLWxvb3Agc3Vicm91dGluZQBBLWx0LUIgc3Vicm91dGluZQBBLWd0LUIgc3Vicm91dGluZQBBLWVxLUIgc3Vicm91dGluZQBlb2YtQiBzdWJyb3V0aW5lAGVvZi1BIHN1YnJvdXRpbmUAaWNuZQBsb2NhbHRpbWUAc3RyZnRpbWUAZGF0ZXRpbWUAY3VycmVudF90aW1lAHhDdXJyZW50VGltZQB0bmVtZQBteFBhdGhuYW1lAHhGdWxsUGF0aG5hbWUAYWZ0ZXIgcmVuYW1lAG5vbi10ZXh0IGZpbGVuYW1lAHhSZW5hbWUAYW1iaWd1b3VzIGNvbHVtbiBuYW1lAHRlbXBvcmFyeSB0cmlnZ2VyIG1heSBub3QgaGF2ZSBxdWFsaWZpZWQgbmFtZQAgT1JERVIgQlkgbmFtZQB6TmFtZQB4U2hhZG93TmFtZQBwTW9kdWxlAHNpbXBsZQB1bml4LWRvdGZpbGUAY2Fubm90IG9wZW4gZmlsZQB1bmFibGUgdG8gb3BlbiBkYXRhYmFzZSBmaWxlAHN6T3NGaWxlAGltbXV0YWJsZQBsZWdhY3lfYWx0ZXJfdGFibGUAc3FsaXRlX3JlbmFtZV90YWJsZQByZWN1cnNpdmVseSBkZWZpbmVkIGZ0czUgY29udGVudCB0YWJsZQBjb250ZW50bGVzc19kZWxldGU9MSByZXF1aXJlcyBhIGNvbnRlbnRsZXNzIHRhYmxlAE1hcHBpbmcgKCVsbGQgLT4gJWxsZCkgbWlzc2luZyBmcm9tICVzIHRhYmxlAGNhbm5vdCBjcmVhdGUgdHJpZ2dlciBvbiBzeXN0ZW0gdGFibGUAdmlydHVhbCB0YWJsZQBubyBzdWNoIHRhYmxlAFF1ZXVlIHRhYmxlAFRvbyBtYW55IGNvbHVtbnMgZm9yIGFuIHJ0cmVlIHRhYmxlAFRvbyBmZXcgY29sdW1ucyBmb3IgYW4gcnRyZWUgdGFibGUAV3JvbmcgbnVtYmVyIG9mIGNvbHVtbnMgZm9yIGFuIHJ0cmVlIHRhYmxlAG51bWJlciBvZiBjb2x1bW5zIGluIGZvcmVpZ24ga2V5IGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgcmVmZXJlbmNlZCB0YWJsZQAnZGVsZXRlLWFsbCcgbWF5IG9ubHkgYmUgdXNlZCB3aXRoIGEgY29udGVudGxlc3Mgb3IgZXh0ZXJuYWwgY29udGVudCBmdHM1IHRhYmxlACdyZWJ1aWxkJyBtYXkgbm90IGJlIHVzZWQgd2l0aCBhIGNvbnRlbnRsZXNzIGZ0czUgdGFibGUAJ2RlbGV0ZScgbWF5IG5vdCBiZSB1c2VkIHdpdGggYSBjb250ZW50bGVzc19kZWxldGU9MSB0YWJsZQB1c2FibGUAbG9jYWwgdGltZSB1bmF2YWlsYWJsZQBhbm90aGVyIHJvdyBhdmFpbGFibGUAbm8gbW9yZSByb3dzIGF2YWlsYWJsZQB1dGYxNmxlAGNhc2Vfc2Vuc2l0aXZlX2xpa2UAY2FjaGUAY3Jpc2lzbWVyZ2UAdXNlcm1lcmdlAGF1dG9tZXJnZQBkZWxldGVtZXJnZQBjb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlAG5vdGlmaWNhdGlvbiBtZXNzYWdlAHdhcm5pbmcgbWVzc2FnZQBhQ29uc3RyYWludFVzYWdlAGludmFsaWQgcm9vdHBhZ2UAc3FsaXRlX2RicGFnZQBFeHRlbmRzIG9mZiBlbmQgb2YgcGFnZQBNQVhfUEFHRV9DT1VOVD0weGZmZmZmZmZlAFNjaGVtYSBjb3JydXB0IG9yIG5vdCBhbiBydHJlZQBqc29uX3RyZWUAZGVlAHJ0cmVlbm9kZQBfbm9kZQBqb3VybmFsX21vZGUAbG9ja2luZ19tb2RlAG9wY29kZQB1bmljb2RlAGJ5dGVjb2RlAGNvYWxlc2NlAHNxbGl0ZV9zZXF1ZW5jZQBpbnN0YW5jZQBqc29uX3JlcGxhY2UAanNvbmJfcmVwbGFjZQB1dGYxNmJlAGZ0czU6IDIwMjQtMDUtMjMgMTM6MjU6MjcgOTZjOTJhYmEwMGM4Mzc1YmMzMmZhZmNkZjEyNDI5YzU4YmQ4YWFiZmNhZGFiNjY4M2UzNWJiYjljZGViZjE5ZQAyMGM6MjBlADIwYjoyMGUAJSEwLjIwZQBnZXRjd2QAdGhzdG5kcmQAbGlrZWxpaG9vZABmY2htb2QAcm91bmQAc3Vic2Vjb25kAGVuZABvbGQAeyVsbGQAV3JvbmcgbnVtYmVyIG9mIGVudHJpZXMgaW4gJSUlcyB0YWJsZSAtIGV4cGVjdGVkICVsbGQsIGFjdHVhbCAlbGxkACVsbGQgJWxsZABubyBzdWNoIGN1cnNvcjogJWxsZABubyBzdWNoIHJvd2lkOiAlbGxkACwiU1FMSVRFX1dBU01fREVBTExPQyI6ICVsbGQAcmVidWlsZABsYXN0X2luc2VydF9yb3dpZABjb250ZW50X3Jvd2lkACVfcm93aWQAJXMucm93aWQAU0VMRUNUKkZST00iJXciLiVzIE9SREVSIEJZIHJvd2lkAFNFTEVDVCpGUk9NIiV3Ii4lcyBXSEVSRSAlcyBPUkRFUiBCWSByb3dpZAB4Um93aWQAZ2V0ZXVpZABpbnZhbGlkAGpzb25fdmFsaWQAZmtpZABfX2xhbmdpZAAleiwgbGFuZ2lkAGxhbmd1YWdlaWQAZG9jaWQAYXBwbGljYXRpb25faWQAc3FsaXRlX3NvdXJjZV9pZABmdHM1X3NvdXJjZV9pZABub3QgYXV0aG9yaXplZABJbmRleCBvcHRpbWl6ZWQAbm90aW5kZXhlZAB1bmluZGV4ZWQAdW5hYmxlIHRvIGlkZW50aWZ5IHRoZSBvYmplY3QgdG8gYmUgcmVpbmRleGVkAHZpZXdzIG1heSBub3QgYmUgaW5kZXhlZAB2aXJ0dWFsIHRhYmxlcyBtYXkgbm90IGJlIGluZGV4ZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBpbmRleGVkAHJlYWRfdW5jb21taXR0ZWQAcmVjdXJzaXZlIGFnZ3JlZ2F0ZSBxdWVyaWVzIG5vdCBzdXBwb3J0ZWQAcXVlcnkgYWJvcnRlZAByb3dzIGluc2VydGVkAGNvcnJ1cHRlZABpbnRlcnJ1cHRlZABjaGVja3BvaW50ZWQAYWNjZXNzIHRvICV6IGlzIHByb2hpYml0ZWQAYWNjZXNzIHRvIHZpZXcgIiVzIiBwcm9oaWJpdGVkAHJvd3MgZGVsZXRlZABnZW5lcmF0ZWQAcm93cyB1cGRhdGVkAG5vdHVzZWQAcm93IHZhbHVlIG1pc3VzZWQAdGFibGVzX3VzZWQAc3FsaXRlX2NvbXBpbGVvcHRpb25fdXNlZABQYWdlICV1OiBuZXZlciB1c2VkAGNvbFVzZWQAc3RvcmVkAHZpcnR1YWwgdGFibGVzIG1heSBub3QgYmUgYWx0ZXJlZAB2aWV3ICVzIG1heSBub3QgYmUgYWx0ZXJlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGFsdGVyZWQAc2hhcmVkAGluZGV4IGFzc29jaWF0ZWQgd2l0aCBVTklRVUUgb3IgUFJJTUFSWSBLRVkgY29uc3RyYWludCBjYW5ub3QgYmUgZHJvcHBlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGRyb3BwZWQAdmlldyAlcyBpcyBjaXJjdWxhcmx5IGRlZmluZWQAdW5vcGVuZWQAb3JkZXJCeUNvbnN1bWVkAGRhdGFiYXNlIGRpc2sgaW1hZ2UgaXMgbWFsZm9ybWVkACVzIGNvbnN0cmFpbnQgZmFpbGVkAEZPUkVJR04gS0VZIGNvbnN0cmFpbnQgZmFpbGVkAGZ0czN0b2tlbml6ZSBkaXNhYmxlZABkYXRhYmFzZSAlcyBpcyBsb2NrZWQAZGF0YWJhc2UgaXMgbG9ja2VkAGRhdGFiYXNlIHRhYmxlIGlzIGxvY2tlZABhdXRob3JpemF0aW9uIGRlbmllZABhY2Nlc3MgcGVybWlzc2lvbiBkZW5pZWQAdGFibGUgJVMgaGFzICVkIGNvbHVtbnMgYnV0ICVkIHZhbHVlcyB3ZXJlIHN1cHBsaWVkAHRlbXBvcmFyeSB0YWJsZSBuYW1lIG11c3QgYmUgdW5xdWFsaWZpZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBtb2RpZmllZABjb25mbGljdGluZyBPTiBDT05GTElDVCBjbGF1c2VzIHNwZWNpZmllZABubyB0YWJsZXMgc3BlY2lmaWVkAGRhdGFiYXNlIGlzIGFscmVhZHkgYXR0YWNoZWQASnVtcCBhaGVhZCBpZiBMSU1JVCByZWFjaGVkAGRhdGFiYXNlIHNjaGVtYSBoYXMgY2hhbmdlZABlZWQAZXhjbHVkZWQAUGFnZSAldTogcG9pbnRlciBtYXAgcmVmZXJlbmNlZABwcmVhZAB4UmVhZAAlMDRkACUwM2QAJTAyZDolMDJkOiUwMmQAJTA0ZC0lMDJkLSUwMmQAJTJkADQwZi0yMWEtMjFkADUwZi0yMGEtMjBkADQwZi0yMGEtMjBkAHNxbGl0ZV9zdGF0JWQAY29sdW1uJWQALCBULmMlZAAsIGMlZAAsYSVkAHNxbGl0ZV9hdXRvaW5kZXhfJXNfJWQAYSVkPT8lZAB2YXJpYWJsZSBudW1iZXIgbXVzdCBiZSBiZXR3ZWVuID8xIGFuZCA/JWQAdXNlc1N0bXRKb3VybmFsPSVkAHVuYWJsZSB0byBnZXQgdGhlIHBhZ2UuIGVycm9yIGNvZGU9JWQAJWQuLiVkAGsoJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHJvb3RwYWdlPSVkIFdIRVJFICMlZCBBTkQgcm9vdHBhZ2U9IyVkAFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCB0eXBlPSclcycsIG5hbWU9JVEsIHRibF9uYW1lPSVRLCByb290cGFnZT0jJWQsIHNxbD0lUSBXSEVSRSByb3dpZD0jJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHR5cGU9J3RhYmxlJywgbmFtZT0lUSwgdGJsX25hbWU9JVEsIHJvb3RwYWdlPTAsIHNxbD0lUSBXSEVSRSByb3dpZD0jJWQAdG9vIG1hbnkgYXR0YWNoZWQgZGF0YWJhc2VzIC0gbWF4ICVkAHRvbyBtYW55IGFyZ3VtZW50cyBvbiAlcygpIC0gbWF4ICVkAGV4cGVjdGVkICVkIGNvbHVtbnMgZm9yICclcycgYnV0IGdvdCAlZABhdHRlbXB0IHRvIG9wZW4gIiVzIiBhcyBmaWxlIGRlc2NyaXB0b3IgJWQAJXMgZXhwci1jb2x1bW4gJWQAJXMgY29sdW1uICVkAGJ0cmVlSW5pdFBhZ2UoKSByZXR1cm5zIGVycm9yIGNvZGUgJWQAJXIgJXMgQlkgdGVybSBvdXQgb2YgcmFuZ2UgLSBzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAlZABzdWItc2VsZWN0IHJldHVybnMgJWQgY29sdW1ucyAtIGV4cGVjdGVkICVkAElOKC4uLikgZWxlbWVudCBoYXMgJWQgdGVybSVzIC0gZXhwZWN0ZWQgJWQAJXNMSVNUIFNVQlFVRVJZICVkAFJFVVNFIExJU1QgU1VCUVVFUlkgJWQAJXNTQ0FMQVIgU1VCUVVFUlkgJWQAUkVVU0UgU1VCUVVFUlkgJWQASU5ERVggJWQAdG9vIG1hbnkgRlJPTSBjbGF1c2UgdGVybXMsIG1heDogJWQAJXMiJXMiOiAlZAAic2l6ZW9mIjogJWQAcndjAHV0YwBkZXNjAGFzYwBjaGVja3BvaW50X2Z1bGxmc3luYwBmdWxsX2ZzeW5jAHhTeW5jAHRydW5jAHhGdW5jAGVuYwBudW1lcmljAHN1YnNlYwAlLjRjJXMlLjE2YwBhcGkvc3FsaXRlMy13YXNtLmMAJXMvZXRpbHFzXyVsbHglYwB1bnJlY29nbml6ZWQgbWF0Y2hpbmZvIHJlcXVlc3Q6ICVjAHdiAHJiAGdsb2IAemVyb2Jsb2IAcmFuZG9tYmxvYgBqc29uYgBpbGIAaXRpbGliAG1lbWRiAEFUVEFDSCAlUSBBUyB2YWN1dW1fZGIAcFZ0YWIAZnRzNXZvY2FiAHJ3YQByb3RhAGV2aXRhAGxhbm9pdGEAZXRhAHRva2VuZGF0YQAlc19kYXRhAHBBcHBEYXRhAGljbmEAc3FsaXRlX3RlbXBfc2NoZW1hAHNxbGl0ZV9zY2hlbWEAd3JpdGFibGVfc2NoZW1hAHRydXN0ZWRfc2NoZW1hAGNvcnJ1cHQgc2NoZW1hAG5vIHN1Y2ggc2NoZW1hAGlsbGEAZXppbGEAaXRpbGEAbXNpbGEAbi9hAHNxbGl0ZV8AcHJhZ21hXwBTUUxJVEVfAF9ST1dJRF8AJXMgYXQgbGluZSAlZCBvZiBbJS4xMHNdAGJpbmQgb24gYSBidXN5IHByZXBhcmVkIHN0YXRlbWVudDogWyVzXQBtYWxmb3JtZWQgTUFUQ0ggZXhwcmVzc2lvbjogWyVzXQBbJWxsZF0AW10ALCAic3RydWN0cyI6IFsAU1FMSVRFX0NPTkZJR19QQ0FDSEVfSERSU1oAU1FMSVRFX0NPTkZJR19QTUFTWgBTUUxJVEVfRU1QVFkAU1FMSVRFX0JVU1kAU1FMSVRFX0ZDTlRMX1dJTjMyX0FWX1JFVFJZAFNRTElURV9FUlJPUl9SRVRSWQBTUUxJVEVfUkVBRE9OTFlfRElSRUNUT1JZAFNRTElURV9PUEVOX01FTU9SWQBTUUxJVEVfQlVTWV9SRUNPVkVSWQBTUUxJVEVfUkVBRE9OTFlfUkVDT1ZFUlkATEVGVC1NT1NUIFNVQlFVRVJZAENPTVBPVU5EIFFVRVJZAFNRTElURV9TRVJJQUxJWkVfTk9DT1BZAFNRTElURV9ERU5ZAEFOWQBTUUxJVEVfT0tfTE9BRF9QRVJNQU5FTlRMWQBTUUxJVEVfRElSRUNUT05MWQBTUUxJVEVfVlRBQl9ESVJFQ1RPTkxZAFNRTElURV9PUEVOX1JFQURPTkxZAFNRTElURV9ERVNFUklBTElaRV9SRUFET05MWQBTUUxJVEVfUkVBRE9OTFkAU1FMSVRFX1NZTkNfREFUQU9OTFkAU1FMSVRFX0NIQU5HRVNFVF9GT1JFSUdOX0tFWQBTUUxJVEVfQ09OU1RSQUlOVF9QUklNQVJZS0VZAFNRTElURV9DT05TVFJBSU5UX0ZPUkVJR05LRVkAU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9GS0VZAGdlbmVyYXRlZCBjb2x1bW5zIGNhbm5vdCBiZSBwYXJ0IG9mIHRoZSBQUklNQVJZIEtFWQBBVVRPSU5DUkVNRU5UIGlzIG9ubHkgYWxsb3dlZCBvbiBhbiBJTlRFR0VSIFBSSU1BUlkgS0VZAGRvY2lkIElOVEVHRVIgUFJJTUFSWSBLRVkARk9SRUlHTiBLRVkAVVNFIFRFTVAgQi1UUkVFIEZPUiAlc09SREVSIEJZAFVTRSBURU1QIEItVFJFRSBGT1IgTEFTVCAlZCBURVJNUyBPRiBPUkRFUiBCWQBHUk9VUCBCWQBpaXNYAGlzaVgAU1FMSVRFX0NPTkZJR19NVVRFWABTUUxJVEVfQ09ORklHX0dFVE1VVEVYAFNRTElURV9PUEVOX05PTVVURVgAU1FMSVRFX09QRU5fRlVMTE1VVEVYAFNRTElURV9DT1JSVVBUX0lOREVYAFNRTElURV9EUk9QX0lOREVYAFNRTElURV9EUk9QX1RFTVBfSU5ERVgAU1FMSVRFX0NSRUFURV9URU1QX0lOREVYAFNRTElURV9DUkVBVEVfSU5ERVgAU1FMSVRFX1NUTVRTVEFUVVNfQVVUT0lOREVYAFNRTElURV9XQVJOSU5HX0FVVE9JTkRFWABTUUxJVEVfUkVJTkRFWABBVVRPTUFUSUMgUEFSVElBTCBDT1ZFUklORyBJTkRFWABBVVRPTUFUSUMgQ09WRVJJTkcgSU5ERVgAU1FMSVRFX0RCU1RBVFVTX01BWABTUUxJVEVfREJDT05GSUdfTUFYAC1taiUwNlg5JTAyWABTUUxJVEVfUk9XAFNRTElURV9UUkFDRV9ST1cAU0NBTiBDT05TVEFOVCBST1cAU1FMSVRFX09QRU5fTk9GT0xMT1cAU1FMSVRFX1NUQVRVU19QQUdFQ0FDSEVfT1ZFUkZMT1cAU1FMSVRFX0RST1BfVklFVwBTUUxJVEVfRFJPUF9URU1QX1ZJRVcAU1FMSVRFX0NSRUFURV9URU1QX1ZJRVcAU1FMSVRFX0NSRUFURV9WSUVXAFNRTElURV9EQkNPTkZJR19FTkFCTEVfVklFVwBwcFYAU1FMSVRFX0ZDTlRMX1JCVQBTUUxJVEVfVEVYVABqc29uX29iamVjdCgpIGxhYmVscyBtdXN0IGJlIFRFWFQAU1FMSVRFX0JVU1lfVElNRU9VVABTUUxJVEVfRkNOVExfTE9DS19USU1FT1VUAEZJUlNUAExBU1QAU1FMSVRFX1NUTVRTVEFUVVNfU09SVABTUUxJVEVfVlRBQl9DT05TVFJBSU5UX1NVUFBPUlQAU1FMSVRFX0NIQU5HRVNFVF9BQk9SVABTUUxJVEVfQUJPUlQAU1FMSVRFX0NIQU5HRVNFVEFQUExZX0lOVkVSVABTUUxJVEVfQ0hBTkdFU0VUU1RBUlRfSU5WRVJUAEJlZ2luIERPIFVQREFURSBvZiBVUFNFUlQARW5kIERPIFVQREFURSBvZiBVUFNFUlQAU1FMSVRFX0lOU0VSVABTUUxJVEVfRkNOVExfQ0tQVF9TVEFSVABTUUxJVEVfQ09SUlVQVABTUUxJVEVfSU5URVJSVVBUAEVYQ0VQVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9JU05PVABTUUxJVEVfQlVTWV9TTkFQU0hPVABTUUxJVEVfRVJST1JfU05BUFNIT1QAU1FMSVRFX1NUQVRVU19NQUxMT0NfQ09VTlQAU1FMSVRFX1NBVkVQT0lOVABTUUxJVEVfQ0hBTkdFU0VUQVBQTFlfTk9TQVZFUE9JTlQAU1FMSVRFX0ZDTlRMX1NJWkVfSElOVABTUUxJVEVfQ0hBTkdFU0VUX0NPTlNUUkFJTlQAU1FMSVRFX0NPTlNUUkFJTlQALCUuKnMgSU5UAENSRUFURSBUQUJMRSB4KCUuKnMgSU5UAFNRTElURV9QUkVQQVJFX1BFUlNJU1RFTlQAU1FMSVRFX0lPRVJSX0RFTEVURV9OT0VOVABTUUxJVEVfVFJBQ0VfU1RNVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9MVABTRVQgREVGQVVMVABTUUxJVEVfUkVBRE9OTFlfQ0FOVElOSVQATVVURVhfT01JVABTUUxJVEVfQ0hBTkdFU0VUX09NSVQAQ09NTUlUAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0xJTUlUAFNRTElURV9GQ05UTF9TSVpFX0xJTUlUAFNRTElURV9TVE1UU1RBVFVTX0ZJTFRFUl9ISVQAU1FMSVRFX0RCU1RBVFVTX0NBQ0hFX0hJVABTUUxJVEVfREJTVEFUVVNfTE9PS0FTSURFX0hJVABSSUdIVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9HVABMRUZUAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX09GRlNFVABMSU1JVCtPRkZTRVQARElTVElOQ1QAUkVTVFJJQ1QAU1FMSVRFX0NIQU5HRVNFVF9DT05GTElDVABJTlRFUlNFQ1QAU1FMSVRFX1NFTEVDVABTUUxJVEVfTUFYX0NPTVBPVU5EX1NFTEVDVABTUUxJVEVfTElNSVRfQ09NUE9VTkRfU0VMRUNUAHJpZ2h0IFNFTEVDVABsZWZ0IFNFTEVDVAB0b28gbWFueSB0ZXJtcyBpbiBjb21wb3VuZCBTRUxFQ1QAU1FMSVRFX0lPRVJSX0ZTVEFUAFNRTElURV9GTE9BVABTUUxJVEVfRk9STUFUAFNRTElURV9EQkNPTkZJR19MRUdBQ1lfRklMRV9GT1JNQVQAdW5rbm93biBqb2luIHR5cGU6ICVUJXMlVCVzJVQALSVUAHRvbyBtYW55IGFyZ3VtZW50cyBvbiBmdW5jdGlvbiAlVAB1bmtub3duIGRhdGFiYXNlICVUAGZvcmVpZ24ga2V5IG9uICVzIHNob3VsZCByZWZlcmVuY2Ugb25seSBvbmUgY29sdW1uIG9mIHRhYmxlICVUAENSRUFURSBWSVJUVUFMIFRBQkxFICVUAGhleCBsaXRlcmFsIHRvbyBiaWc6ICVzJSNUAG5vIHN1Y2ggZnVuY3Rpb246ICUjVABub3QgYXV0aG9yaXplZCB0byB1c2UgZnVuY3Rpb246ICUjVABTRUxFQ1QgJXMgRlJPTSAlcyBBUyBUAFNRTElURV9EQkNPTkZJR19TVE1UX1NDQU5TVEFUVVMAU1FMSVRFX0NPTkZJR19NRU1TVEFUVVMAU1FMSVRFX0lOTk9DVU9VUwBTUUxJVEVfVlRBQl9JTk5PQ1VPVVMAU1FMSVRFX0FDQ0VTU19FWElTVFMARU5BQkxFX0VYUExBSU5fQ09NTUVOVFMAU1FMSVRFX1NUTVRTVEFUVVNfRklMVEVSX01JU1MAU1FMSVRFX0RCU1RBVFVTX0NBQ0hFX01JU1MAU1FMSVRFX0lPRVJSX0FDQ0VTUwBERUZBVUxUX1JFQ1VSU0lWRV9UUklHR0VSUwBFTkFCTEVfTUFUSF9GVU5DVElPTlMASU5TAFNRTElURV9EQlNUQVRVU19ERUZFUlJFRF9GS1MAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfSVMAU1FMSVRFX0ZDTlRMX1pJUFZGUwBTUUxJVEVfSU9FUlJfQ09SUlVQVEZTAFNRTElURV9OT0xGUwBTUUxJVEVfRkNOVExfUkVTRVJWRV9CWVRFUwBTUUxJVEVfTUFYX1dPUktFUl9USFJFQURTAFNRTElURV9MSU1JVF9XT1JLRVJfVEhSRUFEUwBTUUxJVEVfVlRBQl9VU0VTX0FMTF9TQ0hFTUFTACVzICVTAFNDQU4gJVMAbm8gc3VjaCBpbmRleDogJVMAY2Fubm90IGNyZWF0ZSAlcyB0cmlnZ2VyIG9uIHZpZXc6ICVTAG5vIHN1Y2ggdHJpZ2dlcjogJVMAY2Fubm90IGNyZWF0ZSBJTlNURUFEIE9GIHRyaWdnZXIgb24gdGFibGU6ICVTAG1hdGVyaWFsaXplICUhUwBlbmQgJSFTAE1BVEVSSUFMSVpFICUhUwBDTy1ST1VUSU5FICUhUwBTUUxJVEVfSU9FUlIAVVNJTkcgSU5ERVggJXMgRk9SIElOLU9QRVJBVE9SAFVTSU5HIFJPV0lEIFNFQVJDSCBPTiBUQUJMRSAlcyBGT1IgSU4tT1BFUkFUT1IAU1FMSVRFX0VSUk9SAEVOQUJMRV9BUElfQVJNT1IATVVMVEktSU5ERVggT1IAU1FMSVRFX0NBTlRPUEVOX0lTRElSAFNRTElURV9UTVBESVIAU1FMSVRFX0NBTlRPUEVOX05PVEVNUERJUgBTUUxJVEVfREJDT05GSUdfRU5BQkxFX0ZUUzNfVE9LRU5JWkVSAFNRTElURV9GQ05UTF9WRlNfUE9JTlRFUgBTUUxJVEVfRkNOVExfSk9VUk5BTF9QT0lOVEVSAFNRTElURV9GQ05UTF9GSUxFX1BPSU5URVIAQUZURVIAU1FMSVRFX0FVVEhfVVNFUgBTUUxJVEVfRkNOVExfQlVTWUhBTkRMRVIAU1FMSVRFX0NPTlNUUkFJTlRfVFJJR0dFUgBTUUxJVEVfRFJPUF9UUklHR0VSAFNRTElURV9EUk9QX1RFTVBfVFJJR0dFUgBTUUxJVEVfQ1JFQVRFX1RFTVBfVFJJR0dFUgBTUUxJVEVfQ1JFQVRFX1RSSUdHRVIAU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9UUklHR0VSAFNRTElURV9JTlRFR0VSAGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIHN6IEJMT0IsIG9yaWdpbiBJTlRFR0VSAFNRTElURV9EQkNPTkZJR19SRVZFUlNFX1NDQU5PUkRFUgBTUUxJVEVfRkNOVExfRVhURVJOQUxfUkVBREVSAFNRTElURV9WRVJTSU9OX05VTUJFUgBTUUxJVEVfTUFYX1ZBUklBQkxFX05VTUJFUgBTUUxJVEVfTElNSVRfVkFSSUFCTEVfTlVNQkVSAE5FQVIAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfRVEAU1FMSVRFX0VSUk9SX01JU1NJTkdfQ09MTFNFUQAleiVzJVEAREVMRVRFIEZST00gJVEuJXMgV0hFUkUgJXM9JVEAbmFtZT0lUSBBTkQgc3FsPSVRAERFTEVURSBGUk9NICVRLnNxbGl0ZV9zZXF1ZW5jZSBXSEVSRSBuYW1lPSVRACwgeC4lUQAsIFQuJVEAU0VMRUNUICogRlJPTSAlUS4lUQBBVFRBQ0ggeCBBUyAlUQBVUERBVEUgIiV3Ii5zcWxpdGVfc2VxdWVuY2Ugc2V0IG5hbWUgPSAlUSBXSEVSRSBuYW1lID0gJVEAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gcHJpbnRmKCclJS4lZHMsICcsc3FsKSB8fCAlUSB8fCBzdWJzdHIoc3FsLDErbGVuZ3RoKHByaW50ZignJSUuJWRzJyxzcWwpKSkgV0hFUkUgdHlwZSA9ICd0YWJsZScgQU5EIG5hbWUgPSAlUQBiYWQgSlNPTiBwYXRoOiAlUQBmdHM1dm9jYWI6IHVua25vd24gdGFibGUgdHlwZTogJVEAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfUkVHRVhQAFNFVFVQAEdST1VQAFNRTElURV9EQkNPTkZJR19UUklHR0VSX0VRUABTUUxJVEVfTUFYX1ZEQkVfT1AAU1FMSVRFX0xJTUlUX1ZEQkVfT1AAU1FMSVRFX0NIQU5HRVNFVEFQUExZX0lHTk9SRU5PT1AAQE5QAFNRTElURV9TVE1UU1RBVFVTX0ZVTExTQ0FOX1NURVAAU1FMSVRFX1NUTVRTVEFUVVNfVk1fU1RFUABSRUNVUlNJVkUgU1RFUABTUUxJVEVfSU9FUlJfTU1BUABTUUxJVEVfSU9FUlJfU0hNTUFQAFNRTElURV9DT05GSUdfSEVBUABAUABTUUxJVEVfRkNOVExfQ09NTUlUX1BIQVNFVFdPAFNRTElURV9GQ05UTF9MQVNUX0VSUk5PAFNOYU4AUU5hTgBTUUxJVEVfU1RNVFNUQVRVU19SVU4AbWFsZm9ybWVkIEpTT04AU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfRlVOQ1RJT04AU1FMSVRFX0NPTlNUUkFJTlRfRlVOQ1RJT04ARU5BQkxFX1VOS05PV05fU1FMX0ZVTkNUSU9OAFNRTElURV9GVU5DVElPTgBTUUxJVEVfVFJBTlNBQ1RJT04ATk8gQUNUSU9OAEVOQUJMRV9TRVNTSU9OAFNRTElURV9WRVJTSU9OAFNRTElURV9GQ05UTF9EQVRBX1ZFUlNJT04AT01JVF9MT0FEX0VYVEVOU0lPTgBTUUxJVEVfREJDT05GSUdfRU5BQkxFX0xPQURfRVhURU5TSU9OAFVOSU9OAFNRTElURV9NQVhfQ09MVU1OAFNRTElURV9MSU1JVF9DT0xVTU4AIExFRlQtSk9JTgBCRUdJTgBTUUxJVEVfSU9DQVBfVU5ERUxFVEFCTEVfV0hFTl9PUEVOAFNRTElURV9DQU5UT1BFTgBTUUxJVEVfSU9FUlJfU0hNT1BFTgAsYXJnIEhJRERFTgAsc2NoZW1hIEhJRERFTgBOQU4AU1FMSVRFX0NPTkZJR19DT1ZFUklOR19JTkRFWF9TQ0FOAERFRkFVTFRfQVVUT1ZBQ1VVTQAgTlVNAFNRTElURV9QRVJNAFBNAFJUUklNAFNRTElURV9JT0VSUl9OT01FTQBTUUxJVEVfTk9NRU0AQU0AU1FMSVRFX1BST1RPQ09MAFNRTElURV9EQkNPTkZJR19EUVNfRE1MAFNRTElURV9OVUxMAFNRTElURV9DT05TVFJBSU5UX05PVE5VTEwAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfSVNOT1ROVUxMAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0lTTlVMTABDYW5ub3QgYWRkIGEgTk9UIE5VTEwgY29sdW1uIHdpdGggZGVmYXVsdCB2YWx1ZSBOVUxMAE5PVCBOVUxMAFNFVCBOVUxMAFNFTEVDVCAxIEZST00gJVEuJyVxX3NlZ21lbnRzJyBXSEVSRSBibG9ja2lkPT8gQU5EIGJsb2NrIElTIE5VTEwAU1FMSVRFX0RCU1RBVFVTX0xPT0tBU0lERV9NSVNTX0ZVTEwAU1FMSVRFX0ZVTEwAU1FMSVRFX1NZTkNfRlVMTABTUUxJVEVfQ09ORklHX1NUTVRKUk5MX1NQSUxMAFNRTElURV9EQlNUQVRVU19DQUNIRV9TUElMTABVTklPTiBBTEwAU1FMSVRFX0ZBSUwAU1FMSVRFX0RCQ09ORklHX0RRU19EREwAU1FMSVRFX0ZDTlRMX1BFUlNJU1RfV0FMAFNRTElURV9OT1RJQ0VfUkVDT1ZFUl9XQUwAU1FMSVRFX09QRU5fV0FMAFNRTElURV9PUEVOX1NVUEVSX0pPVVJOQUwAU1FMSVRFX09QRU5fVEVNUF9KT1VSTkFMAFNRTElURV9PUEVOX01BSU5fSk9VUk5BTABTUUxJVEVfT1BFTl9TVUJKT1VSTkFMAFNRTElURV9JTlRFUk5BTABTUUxJVEVfU1lOQ19OT1JNQUwAU1FMSVRFX0lPQ0FQX1NFUVVFTlRJQUwALCUuKnMgUkVBTABTUUxJVEVfT0sARU5BQkxFX1BSRVVQREFURV9IT09LAFNRTElURV9DT05TVFJBSU5UX0NPTU1JVEhPT0sAU1FMSVRFX0NBTlRPUEVOX1NZTUxJTksAU1FMSVRFX0lPRVJSX1NFRUsAU1FMSVRFX0lPRVJSX0xPQ0sAU1FMSVRFX1JFQURPTkxZX0NBTlRMT0NLAFNRTElURV9JT0VSUl9VTkxPQ0sAU1FMSVRFX0lPRVJSX1NITUxPQ0sAU1FMSVRFX0lPRVJSX1JETE9DSwBTUUxJVEVfSU9FUlJfQ0hFQ0tSRVNFUlZFRExPQ0sAU1FMSVRFX0ZDTlRMX1dBTF9CTE9DSwBTUUxJVEVfQ09OU1RSQUlOVF9DSEVDSwBTUUxJVEVfU1RBVFVTX1BBUlNFUl9TVEFDSwBTUUxJVEVfUkVBRE9OTFlfUk9MTEJBQ0sAU1FMSVRFX0FCT1JUX1JPTExCQUNLAFNRTElURV9OT1RJQ0VfUkVDT1ZFUl9ST0xMQkFDSwBTUUxJVEVfUk9MTEJBQ0sAYWJvcnQgZHVlIHRvIFJPTExCQUNLAFNRTElURV9JT0NBUF9BVE9NSUM4SwBTUUxJVEVfSU9DQVBfQVRPTUlDMTZLAFNRTElURV9JT0NBUF9BVE9NSUM0SwBTUUxJVEVfSU9DQVBfQVRPTUlDNjRLAFNRTElURV9JT0NBUF9BVE9NSUMySwBTUUxJVEVfSU9DQVBfQVRPTUlDMzJLAFNRTElURV9JT0NBUF9BVE9NSUMxSwBTUUxJVEVfT1BFTl9VUkkAU1FMSVRFX0NPTkZJR19VUkkAVVNFX1VSSQBTUUxJVEVfSU9FUlJfQVVUSABTUUxJVEVfQVVUSABTUUxJVEVfTUFYX0VYUFJfREVQVEgAU1FMSVRFX0xJTUlUX0VYUFJfREVQVEgAU1FMSVRFX01BWF9UUklHR0VSX0RFUFRIAFNRTElURV9MSU1JVF9UUklHR0VSX0RFUFRIAFNRTElURV9NQVhfTEVOR1RIAFNRTElURV9MSU1JVF9MRU5HVEgAU1FMSVRFX01BWF9MSUtFX1BBVFRFUk5fTEVOR1RIAFNRTElURV9MSU1JVF9MSUtFX1BBVFRFUk5fTEVOR1RIAFNRTElURV9NQVhfU1FMX0xFTkdUSABTUUxJVEVfTElNSVRfU1FMX0xFTkdUSABTUUxJVEVfSU9FUlJfQ09OVlBBVEgAU1FMSVRFX0NBTlRPUEVOX0NPTlZQQVRIAFNRTElURV9JT0VSUl9HRVRURU1QUEFUSABTUUxJVEVfQ0FOVE9QRU5fRlVMTFBBVEgAU1FMSVRFX0NPTkZJR19TQ1JBVENIAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX01BVENIAFNRTElURV9NSVNNQVRDSABTRUFSQ0gAU1FMSVRFX0FUVEFDSABTUUxJVEVfREVUQUNIAFNRTElURV9EQkNPTkZJR19FTkFCTEVfUVBTRwBTUUxJVEVfTUFYX0ZVTkNUSU9OX0FSRwBTUUxJVEVfTElNSVRfRlVOQ1RJT05fQVJHAFNRTElURV9DT05GSUdfTE9HAFNRTElURV9DT05GSUdfU1FMTE9HAFVTSU5HAFNRTElURV9XQVJOSU5HAFNRTElURV9MT0NLX1BFTkRJTkcAU1FMSVRFX1RPT0JJRwBJTkYAMDEyMzQ1Njc4OUFCQ0RFRgBTUUxJVEVfQU5BTFlaRQBTUUxJVEVfREJTVEFUVVNfTE9PS0FTSURFX01JU1NfU0laRQBTUUxJVEVfRkNOVExfTU1BUF9TSVpFAFNRTElURV9DT05GSUdfTU1BUF9TSVpFAFNRTElURV9NQVhfQUxMT0NBVElPTl9TSVpFAFNRTElURV9GQ05UTF9DSFVOS19TSVpFAFNRTElURV9TRVNTSU9OX09CSkNPTkZJR19TSVpFAFNRTElURV9DT05GSUdfU09SVEVSUkVGX1NJWkUAU1FMSVRFX1NUQVRVU19QQUdFQ0FDSEVfU0laRQBTUUxJVEVfU1RBVFVTX01BTExPQ19TSVpFAFNRTElURV9DT05GSUdfTUVNREJfTUFYU0laRQBTUUxJVEVfQ09ORklHX1dJTjMyX0hFQVBTSVpFAFNRTElURV9TRVNTSU9OX0NPTkZJR19TVFJNU0laRQBTUUxJVEVfSU9FUlJfU0hNU0laRQBTUUxJVEVfUFJFUEFSRV9OT1JNQUxJWkUAU1FMSVRFX09QRU5fRVhDTFVTSVZFAFNRTElURV9MT0NLX0VYQ0xVU0lWRQBTUUxJVEVfUkVDVVJTSVZFAFNRTElURV9EQkNPTkZJR19ERUZFTlNJVkUAU1FMSVRFX0NPTlNUUkFJTlRfVU5JUVVFAFNRTElURV9JTkRFWF9TQ0FOX1VOSVFVRQAgVU5JUVVFAFNRTElURV9JT0VSUl9XUklURQBTUUxJVEVfVFhOX1dSSVRFAFNRTElURV9EQlNUQVRVU19DQUNIRV9XUklURQBTUUxJVEVfRkNOVExfQ09NTUlUX0FUT01JQ19XUklURQBTUUxJVEVfRkNOVExfQkVHSU5fQVRPTUlDX1dSSVRFAFNRTElURV9GQ05UTF9ST0xMQkFDS19BVE9NSUNfV1JJVEUAU1FMSVRFX0ZDTlRMX09WRVJXUklURQBTUUxJVEVfSU9DQVBfUE9XRVJTQUZFX09WRVJXUklURQBTUUxJVEVfRkNOVExfUE9XRVJTQUZFX09WRVJXUklURQBTUUxJVEVfQUNDRVNTX1JFQURXUklURQBTUUxJVEVfT1BFTl9SRUFEV1JJVEUAU1FMSVRFX0lPRVJSX0RFTEVURQBTUUxJVEVfREVMRVRFAFNRTElURV9GQ05UTF9MT0NLU1RBVEUAU1FMSVRFX09QRU5fQ1JFQVRFAFNRTElURV9VUERBVEUAU1FMSVRFX0lPRVJSX1RSVU5DQVRFAFNRTElURV9NSVNVU0UAJXUtUk9XIFZBTFVFUyBDTEFVU0UAU1FMSVRFX0lPRVJSX0NMT1NFAFNRTElURV9JT0VSUl9ESVJfQ0xPU0UAU1FMSVRFX0RCQ09ORklHX05PX0NLUFRfT05fQ0xPU0UAU1FMSVRFX1RSQUNFX0NMT1NFAFNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UAU1FMSVRFX0RFU0VSSUFMSVpFX0ZSRUVPTkNMT1NFAFJFTEVBU0UATk9DQVNFAFNRTElURV9EQkNPTkZJR19SRVNFVF9EQVRBQkFTRQBTUUxJVEVfSUdOT1JFAEJFRk9SRQBDUkUAU1FMSVRFX1NUTVRTVEFUVVNfUkVQUkVQQVJFAFNRTElURV9SRVNVTFRfU1VCVFlQRQBTUUxJVEVfU1VCVFlQRQBTUUxJVEVfQ09OU1RSQUlOVF9EQVRBVFlQRQBTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9ORQBTUUxJVEVfVFhOX05PTkUAU1FMSVRFX0xPQ0tfTk9ORQBTUUxJVEVfRkNOVExfQ0tQVF9ET05FAFNRTElURV9ET05FAFNRTElURV9GQ05UTF9WRlNOQU1FAFNRTElURV9GQ05UTF9URU1QRklMRU5BTUUAU1FMSVRFX0RCQ09ORklHX01BSU5EQk5BTUUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfTEUAU1FMSVRFX0ZDTlRMX0NLU01fRklMRQBTUUxJVEVfRkNOVExfU0VUX0xPQ0tQUk9YWUZJTEUAU1FMSVRFX0ZDTlRMX0dFVF9MT0NLUFJPWFlGSUxFAFNRTElURV9UUkFDRV9QUk9GSUxFAFNRTElURV9GQ05UTF9XSU4zMl9TRVRfSEFORExFAFNRTElURV9GQ05UTF9XSU4zMl9HRVRfSEFORExFAFNRTElURV9EQkNPTkZJR19MRUdBQ1lfQUxURVJfVEFCTEUAU1FMSVRFX0FMVEVSX1RBQkxFAFNRTElURV9EUk9QX1RBQkxFAFNRTElURV9EUk9QX1RFTVBfVEFCTEUAU1FMSVRFX0NSRUFURV9URU1QX1RBQkxFAFNRTElURV9DUkVBVEVfVEFCTEUAU1FMSVRFX0RST1BfVlRBQkxFAFNRTElURV9DUkVBVEVfVlRBQkxFAFNRTElURV9JT0NBUF9JTU1VVEFCTEUAU1FMSVRFX0RFU0VSSUFMSVpFX1JFU0laRUFCTEUAU1FMSVRFX1VURjE2TEUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfTElLRQBTUUxJVEVfRkNOVExfUkVTRVRfQ0FDSEUAT01JVF9TSEFSRURfQ0FDSEUAU1FMSVRFX0NPTkZJR19QQ0FDSEUAU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEUAU1FMSVRFX09QRU5fUFJJVkFURUNBQ0hFAFNRTElURV9DT05GSUdfUEFHRUNBQ0hFAFNRTElURV9PUEVOX1NIQVJFRENBQ0hFAFNRTElURV9MT0NLRURfU0hBUkVEQ0FDSEUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfR0UAU1FMSVRFX1JBTkdFAEVOQUJMRV9SVFJFRQAlcyBVU0lORyBURU1QIEItVFJFRQBTUUxJVEVfSU9FUlJfVk5PREUAU1FMSVRFX09QRU5fRVhSRVNDT0RFAFNRTElURV9DT05GSUdfTE9PS0FTSURFAFNRTElURV9EQkNPTkZJR19MT09LQVNJREUAQ0FTQ0FERQBTUUxJVEVfQ09SUlVQVF9TRVFVRU5DRQBTUUxJVEVfTk9USUNFAFNRTElURV9GQ05UTF9UUkFDRQBTUUxJVEVfQ0hBTkdFU0VUX1JFUExBQ0UAU1FMSVRFX1JFUExBQ0UARG8gSVBLIFJFUExBQ0UAU1FMSVRFX1VURjE2QkUAU1FMSVRFX0NIQU5HRVNFVF9OT1RGT1VORABTUUxJVEVfTk9URk9VTkQAU1FMSVRFX0lPQ0FQX1NBRkVfQVBQRU5EAEFORABTUUxJVEVfU09VUkNFX0lEAFNRTElURV9DT05TVFJBSU5UX1JPV0lEAHVuaXF1ZW5lc3MgY2hlY2sgZm9yIFJPV0lEACBXSVRIT1VUIFJPV0lEAE9JRABTUUxJVEVfQ09ORklHX1NFUklBTElaRUQAU1FMSVRFX0xPQ0tfUkVTRVJWRUQAU1FMSVRFX0ZDTlRMX0hBU19NT1ZFRABTUUxJVEVfUkVBRE9OTFlfREJNT1ZFRABTUUxJVEVfRkNOVExfU1lOQ19PTUlUVEVEAE9NSVRfREVQUkVDQVRFRABTUUxJVEVfU1RBVFVTX01FTU9SWV9VU0VEAFNRTElURV9EQlNUQVRVU19TVE1UX1VTRUQAU1FMSVRFX0RCU1RBVFVTX0NBQ0hFX1VTRUQAU1FMSVRFX1NUQVRVU19QQUdFQ0FDSEVfVVNFRABTUUxJVEVfREJTVEFUVVNfTE9PS0FTSURFX1VTRUQAU1FMSVRFX0RCU1RBVFVTX1NDSEVNQV9VU0VEAFNRTElURV9TVE1UU1RBVFVTX01FTVVTRUQAU1FMSVRFX0xPQ0tfU0hBUkVEAFNRTElURV9EQlNUQVRVU19DQUNIRV9VU0VEX1NIQVJFRABTUUxJVEVfQ09OU1RSQUlOVF9QSU5ORUQAU1FMSVRFX1VURjE2X0FMSUdORUQAU1FMSVRFX0xPQ0tFRABTUUxJVEVfSU9FUlJfQkxPQ0tFRABTUUxJVEVfTUFYX0FUVEFDSEVEAFNRTElURV9MSU1JVF9BVFRBQ0hFRABESVJFQ1RfT1ZFUkZMT1dfUkVBRABTUUxJVEVfSU9FUlJfU0hPUlRfUkVBRABTUUxJVEVfQUNDRVNTX1JFQUQAU1FMSVRFX0lPRVJSX1JFQUQAU1FMSVRFX1RYTl9SRUFEAFNRTElURV9SRUFEAFNRTElURV9DT05GSUdfTVVMVElUSFJFQUQAU1FMSVRFX0NPTkZJR19TSU5HTEVUSFJFQUQAU0VMRUNUICVzIEZST00gJXMgVCBXSEVSRSBULiVRIDw9ID8gQU5EIFQuJVEgPj0gPyBPUkRFUiBCWSBULiVRIERFU0MAU0VMRUNUIGlkeCwgc3RhcnRfYmxvY2ssIGxlYXZlc19lbmRfYmxvY2ssIGVuZF9ibG9jaywgcm9vdCBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPyBPUkRFUiBCWSBpZHggQVNDAFNFTEVDVCBpZHgsIHN0YXJ0X2Jsb2NrLCBsZWF2ZXNfZW5kX2Jsb2NrLCBlbmRfYmxvY2ssIHJvb3QgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID9PUkRFUiBCWSBsZXZlbCBERVNDLCBpZHggQVNDAFNFTEVDVCBsZXZlbCwgaWR4LCBlbmRfYmxvY2sgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID8gT1JERVIgQlkgbGV2ZWwgREVTQywgaWR4IEFTQwBTRUxFQ1QgJXMgRlJPTSAlcyBUIFdIRVJFIFQuJVEgPj0gPyBBTkQgVC4lUSA8PSA/IE9SREVSIEJZIFQuJVEgQVNDAFNFTEVDVCBpZHggRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbD0/IE9SREVSIEJZIDEgQVNDAFNZU1RFTV9NQUxMT0MAU1FMSVRFX0NPTkZJR19TTUFMTF9NQUxMT0MAU1FMSVRFX0NPTkZJR19NQUxMT0MAU1FMSVRFX0NPTkZJR19HRVRNQUxMT0MAU1FMSVRFX0ZDTlRMX1NZTkMAU1FMSVRFX0lPRVJSX0ZTWU5DAFNRTElURV9JT0VSUl9ESVJfRlNZTkMARU5BQkxFX09GRlNFVF9TUUxfRlVOQwBTUUxJVEVfREVURVJNSU5JU1RJQwBTUUxJVEVfSU9FUlJfQ09NTUlUX0FUT01JQwBTUUxJVEVfSU9DQVBfQVRPTUlDAFNRTElURV9JT0VSUl9CRUdJTl9BVE9NSUMAU1FMSVRFX0lPRVJSX1JPTExCQUNLX0FUT01JQwBTUUxJVEVfSU9DQVBfQkFUQ0hfQVRPTUlDAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0dMT0IAU1FMSVRFX0JMT0IAaWQgSU5URUdFUiBQUklNQVJZIEtFWSwgc3ogQkxPQgBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBibG9jayBCTE9CAFNRTElURV9PUEVOX1RSQU5TSUVOVF9EQgBTUUxJVEVfT1BFTl9URU1QX0RCAFNRTElURV9PUEVOX01BSU5fREIAU1FMSVRFX0ZDTlRMX1BEQgBTUUxJVEVfTk9UQURCAEJCQgBTUUxJVEVfQ09SUlVQVF9WVEFCAFNRTElURV9DT05TVFJBSU5UX1ZUQUIARU5BQkxFX0RCU1RBVF9WVEFCAFNRTElURV9QUkVQQVJFX05PX1ZUQUIARU5BQkxFX0RCUEFHRV9WVEFCAEVOQUJMRV9CWVRFQ09ERV9WVEFCAFNRTElURV9MT0NLRURfVlRBQgBFTkFCTEVfU1RNVFZUQUIAT3V0cHV0IHJvdXRpbmUgZm9yIEIAU1FMSVRFX0NIQU5HRVNFVF9EQVRBAFNRTElURV9JT0VSUl9EQVRBAFNRTElURV9GQ05UTF9QUkFHTUEAU1FMSVRFX1BSQUdNQQBTUUxJVEVfU0NIRU1BAFNRTElURV9EQkNPTkZJR19XUklUQUJMRV9TQ0hFTUEAU1FMSVRFX0RCQ09ORklHX1RSVVNURURfU0NIRU1BAE91dHB1dCByb3V0aW5lIGZvciBBAEAAJXM6ICIlcyIgLSBzaG91bGQgdGhpcyBiZSBhIHN0cmluZyBsaXRlcmFsIGluIHNpbmdsZS1xdW90ZXM/AFVQREFURSBPUiBGQUlMICVRLiclcV9zZWdkaXInIFNFVCBsZXZlbD0tMSxpZHg9PyBXSEVSRSBsZXZlbD0/IEFORCBpZHg9PwBVUERBVEUgJVEuJyVxX3NlZ2RpcicgU0VUIGlkeCA9ID8gV0hFUkUgbGV2ZWw9PyBBTkQgaWR4PT8AJXM9PwBTRUxFQ1QgZGF0YSBGUk9NICVRLiclcV9ub2RlJyBXSEVSRSBub2Rlbm89PwBTRUxFQ1QgJXMgV0hFUkUgcm93aWQ9PwBERUxFVEUgRlJPTSAnJXEnLiclcV9pZHgnIFdIRVJFIHNlZ2lkPT8AU0VMRUNUIHNpemUgRlJPTSAlUS4nJXFfZG9jc2l6ZScgV0hFUkUgZG9jaWQ9PwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcgV0hFUkUgaWQ9PwBTRUxFQ1QgdmFsdWUgRlJPTSAlUS4nJXFfc3RhdCcgV0hFUkUgaWQ9PwBTRUxFQ1Qgc3olcyBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBpZD0/AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBpZD0/AFNFTEVDVCAlcyBGUk9NICVzIFQgV0hFUkUgVC4lUT0/AERFTEVURSBGUk9NICclcScuJyVxX2RhdGEnIFdIRVJFIGlkPj0/IEFORCBpZDw9PwAsPwApIFZBTFVFUyg/ACBBTkQgKD8AIElTID8AREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgQkVUV0VFTiA/IEFORCA/AFNFTEVDVCBtYXgobGV2ZWwpIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgQkVUV0VFTiA/IEFORCA/AERFTEVURSBGUk9NICVRLiclcV9zZWdtZW50cycgV0hFUkUgYmxvY2tpZCBCRVRXRUVOID8gQU5EID8AVVBEQVRFICVRLiclcV9zZWdkaXInIFNFVCBzdGFydF9ibG9jayA9ID8sIHJvb3QgPSA/V0hFUkUgbGV2ZWwgPSA/IEFORCBpZHggPSA/AFNFTEVDVCBpZHgsIHN0YXJ0X2Jsb2NrLCBsZWF2ZXNfZW5kX2Jsb2NrLCBlbmRfYmxvY2ssIHJvb3QgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8gQU5EIGlkeCA9ID8AREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/IEFORCBpZHggPSA/AERFTEVURSBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPwBTRUxFQ1QgY291bnQoKikgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8AU0VMRUNUICVzIFdIRVJFIHJvd2lkID0gPwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcgV0hFUkUgcm93aWQgPSA/AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBkb2NpZCA9ID8ALCA/ADxleHByPgA8Yj4APGI+Li4uPC9iPgAtPj4ALT4Ac2VwYXJhdG9ycz0AdG9rZW5jaGFycz0AYXV0b21lcmdlPQA8AEJFR0lOIElNTUVESUFURTsgQ09NTUlUOwBDUkVBVEUgVEFCTEUgIiV3Ii4iJXdfcGFyZW50Iihub2Rlbm8gSU5URUdFUiBQUklNQVJZIEtFWSxwYXJlbnRub2RlKTsAKTtDUkVBVEUgVEFCTEUgIiV3Ii4iJXdfbm9kZSIobm9kZW5vIElOVEVHRVIgUFJJTUFSWSBLRVksZGF0YSk7AElOU0VSVCBJTlRPICVRLnNxbGl0ZV9tYXN0ZXIgVkFMVUVTKCdpbmRleCcsJVEsJVEsIyVkLCVRKTsAQ1JFQVRFIFRBQkxFIHgodHlwZSBURVhULHNjaGVtYSBURVhULG5hbWUgVEVYVCx3ciBJTlQsc3VicHJvZyBURVhULHN0bXQgSElEREVOKTsAQ1JFQVRFIFRBQkxFIHgoYWRkciBJTlQsb3Bjb2RlIFRFWFQscDEgSU5ULHAyIElOVCxwMyBJTlQscDQgVEVYVCxwNSBJTlQsY29tbWVudCBURVhULHN1YnByb2cgVEVYVCxuZXhlYyBJTlQsbmN5Y2xlIElOVCxzdG10IEhJRERFTik7AENSRUFURSBUQUJMRSAlUS4nJXFfc2VnbWVudHMnKGJsb2NraWQgSU5URUdFUiBQUklNQVJZIEtFWSwgYmxvY2sgQkxPQik7AENSRUFURSBUQUJMRSAlUS4nJXFfZG9jc2l6ZScoZG9jaWQgSU5URUdFUiBQUklNQVJZIEtFWSwgc2l6ZSBCTE9CKTsAQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJVEuJyVxX3N0YXQnKGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIHZhbHVlIEJMT0IpOwBDUkVBVEUgVEFCTEUgJVEuJyVxX3NlZ2RpcicobGV2ZWwgSU5URUdFUixpZHggSU5URUdFUixzdGFydF9ibG9jayBJTlRFR0VSLGxlYXZlc19lbmRfYmxvY2sgSU5URUdFUixlbmRfYmxvY2sgSU5URUdFUixyb290IEJMT0IsUFJJTUFSWSBLRVkobGV2ZWwsIGlkeCkpOwBVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgdGJsX25hbWUgPSAlUSwgbmFtZSA9IENBU0UgV0hFTiB0eXBlPSd0YWJsZScgVEhFTiAlUSBXSEVOIG5hbWUgTElLRSAnc3FsaXRlWF9hdXRvaW5kZXglJScgRVNDQVBFICdYJyAgICAgIEFORCB0eXBlPSdpbmRleCcgVEhFTiAnc3FsaXRlX2F1dG9pbmRleF8nIHx8ICVRIHx8IHN1YnN0cihuYW1lLCVkKzE4KSBFTFNFIG5hbWUgRU5EIFdIRVJFIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlIEFORCAodHlwZT0ndGFibGUnIE9SIHR5cGU9J2luZGV4JyBPUiB0eXBlPSd0cmlnZ2VyJyk7AERFTEVURSBGUk9NICVRLiclcV9kYXRhJztERUxFVEUgRlJPTSAlUS4nJXFfaWR4JzsARFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX3NlZ21lbnRzJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfc2VnZGlyJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfZG9jc2l6ZSc7RFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX3N0YXQnOyVzIERST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9jb250ZW50JzsAQUxURVIgVEFCTEUgJVEuJyVxX2NvbnRlbnQnICBSRU5BTUUgVE8gJyVxX2NvbnRlbnQnOwBEUk9QIFRBQkxFICclcScuJyVxX25vZGUnO0RST1AgVEFCTEUgJyVxJy4nJXFfcm93aWQnO0RST1AgVEFCTEUgJyVxJy4nJXFfcGFyZW50JzsAQUxURVIgVEFCTEUgJVEuJyVxX3N0YXQnICBSRU5BTUUgVE8gJyVxX3N0YXQnOwBBTFRFUiBUQUJMRSAlUS4nJXFfc2VnbWVudHMnIFJFTkFNRSBUTyAnJXFfc2VnbWVudHMnOwBBTFRFUiBUQUJMRSAlUS4nJXFfJXMnIFJFTkFNRSBUTyAnJXFfJXMnOwBBTFRFUiBUQUJMRSAlUS4nJXFfc2VnZGlyJyAgIFJFTkFNRSBUTyAnJXFfc2VnZGlyJzsARFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX2RhdGEnO0RST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9pZHgnO0RST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9jb25maWcnOwBEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfZG9jc2l6ZSc7AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJzsAQUxURVIgVEFCTEUgJVEuJyVxX2RvY3NpemUnICBSRU5BTUUgVE8gJyVxX2RvY3NpemUnOwBBTFRFUiBUQUJMRSAlUS4nJXFfbm9kZScgICBSRU5BTUUgVE8gIiV3X25vZGUiO0FMVEVSIFRBQkxFICVRLiclcV9wYXJlbnQnIFJFTkFNRSBUTyAiJXdfcGFyZW50IjtBTFRFUiBUQUJMRSAlUS4nJXFfcm93aWQnICBSRU5BTUUgVE8gIiV3X3Jvd2lkIjsAOm1lbW9yeToAZmlsZToAOnNlc3Npb25TdG9yYWdlOgA6bG9jYWxTdG9yYWdlOgAtOWU5OTkAOS4wZTk5OQArLSAKCTAxMjM0NTY3ODkAXHUwMDA5AHY4AHV0ZjgAU1FMSVRFX1VURjgATUFYX0ZVTkNUSU9OX0FSRz0xMjcAREVGQVVMVF9TRUNUT1JfU0laRT00MDk2AE1BWF9WQVJJQUJMRV9OVU1CRVI9MzI3NjYATUFYX1BBR0VfU0laRT02NTUzNgBPTUlUX1VURjE2AFNRTElURV9VVEYxNgBmdHM1AHA1AEVOQUJMRV9GVFM1AHRvbyBtYW55IHJlZmVyZW5jZXMgdG8gIiVzIjogbWF4IDY1NTM1AGJtMjUARkxBR1MgcGFyYW1ldGVyIHRvIGpzb25fdmFsaWQoKSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMTUAdjQAc3FsaXRlX3N0YXQ0AGZ0czQAcDQARU5BQkxFX0ZUUzQAREVGQVVMVF9GSUxFX0ZPUk1BVD00AERFRkFVTFRfQ0FDSEVfU0laRT0tMTYzODQAeEN1cnJlbnRUaW1lSW50NjQAcHdyaXRlNjQAcHJlYWQ2NABNQUxMT0NfU09GVF9MSU1JVD0xMDI0AHNxbGl0ZV9zdGF0MwBTQVZFUE9JTlQgZnRzMwBST0xMQkFDSyBUTyBmdHMzAFJFTEVBU0UgZnRzMwBwMwBFTkFCTEVfRlRTMwAuLlAzAHAyAGF0YW4yAGxvZzIAaWYgJXMgZ290byBQMgBTUUxJVEVfQ09ORklHX1BDQUNIRTIAU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEUyAHJlbW92ZV9kaWFjcml0aWNzPTIAREVGQVVMVF9TWU5DSFJPTk9VUz0yAERFRkFVTFRfV0FMX1NZTkNIUk9OT1VTPTIAVEVNUF9TVE9SRT0yAE1BWF9ERUZBVUxUX1BBR0VfU0laRT04MTkyAHJ0cmVlX2kzMgBTUUxJVEVfSU9DQVBfQVRPTUlDNTEyAFNFTEVDVCBzZWdpZCwgdGVybSwgKHBnbm8+PjEpLCAocGdubyYxKSBGUk9NICVRLiclcV9pZHgnIFdIRVJFIHNlZ2lkPSVkIE9SREVSIEJZIDEsIDIAU0VMRUNUIHRibCxpZHgsc3RhdCBGUk9NICVRLnNxbGl0ZV9zdGF0MQBwMQBTRUxFQ1QgcGFyZW50bm9kZSBGUk9NICVRLiclcV9wYXJlbnQnIFdIRVJFIG5vZGVubz0/MQBTRUxFQ1Qgbm9kZW5vIEZST00gJVEuJyVxX3Jvd2lkJyBXSEVSRSByb3dpZD0/MQBTRUxFQ1QgKiBGUk9NICIldyIuIiV3X3Jvd2lkIiBXSEVSRSByb3dpZD0/MQBTRUxFQ1QgcGFyZW50bm9kZSBGUk9NICclcScuJyVxX3BhcmVudCcgV0hFUkUgbm9kZW5vID0gPzEAREVMRVRFIEZST00gJyVxJy4nJXFfcGFyZW50JyBXSEVSRSBub2Rlbm8gPSA/MQBERUxFVEUgRlJPTSAnJXEnLiclcV9ub2RlJyBXSEVSRSBub2Rlbm8gPSA/MQBTRUxFQ1Qgbm9kZW5vIEZST00gJyVxJy4nJXFfcm93aWQnIFdIRVJFIHJvd2lkID0gPzEAREVMRVRFIEZST00gJyVxJy4nJXFfcm93aWQnIFdIRVJFIHJvd2lkID0gPzEAcmVtb3ZlX2RpYWNyaXRpY3M9MQBBVE9NSUNfSU5UUklOU0lDUz0xAHVuaWNvZGU2MQBVUERBVEUgT1IgRkFJTCAlUS4nJXFfc2VnZGlyJyBTRVQgbGV2ZWw9PyBXSEVSRSBsZXZlbD0tMQBERUZBVUxUX0pPVVJOQUxfU0laRV9MSU1JVD0tMQAiU1FMSVRFX1NUQVRJQyI6MCwgIlNRTElURV9UUkFOU0lFTlQiOi0xACsxAFNFTEVDVCBwZ25vIEZST00gJyVxJy4nJXFfaWR4JyBXSEVSRSBzZWdpZD0/IEFORCB0ZXJtPD0/IE9SREVSIEJZIHRlcm0gREVTQyBMSU1JVCAxAFNFTEVDVCBsZXZlbCwgY291bnQoKikgQVMgY250IEZST00gJVEuJyVxX3NlZ2RpcicgICBHUk9VUCBCWSBsZXZlbCBIQVZJTkcgY250Pj0/ICBPUkRFUiBCWSAobGV2ZWwgJSUgMTAyNCkgQVNDLCAyIERFU0MgTElNSVQgMQBTRUxFQ1QgcGdubyBGUk9NICclcScuJyVxX2lkeCcgV0hFUkUgc2VnaWQ9PyBBTkQgdGVybT4/IE9SREVSIEJZIHRlcm0gQVNDIExJTUlUIDEAUFJBR01BIGRlZmVyX2ZvcmVpZ25fa2V5cyA9IDEAU0VMRUNUIGxlbmd0aChkYXRhKSBGUk9NICclcScuJyVxX25vZGUnIFdIRVJFIG5vZGVubyA9IDEALCAxAFNFTEVDVCAoU0VMRUNUIG1heChpZHgpIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/KSArIDEAU0VMRUNUJ0lOU0VSVCBJTlRPIHZhY3V1bV9kYi4nfHxxdW90ZShuYW1lKXx8JyBTRUxFQ1QqRlJPTSIldyIuJ3x8cXVvdGUobmFtZSlGUk9NIHZhY3V1bV9kYi5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGU9J3RhYmxlJ0FORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0ndGFibGUnQU5EIG5hbWU8PidzcWxpdGVfc2VxdWVuY2UnIEFORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAHJlbW92ZV9kaWFjcml0aWNzPTAAY29udGVudGxlc3NfZGVsZXRlPTEgaXMgaW5jb21wYXRpYmxlIHdpdGggY29sdW1uc2l6ZT0wAERRUz0wAE1BWF9XT1JLRVJfVEhSRUFEUz0wAERFRkFVTFRfV09SS0VSX1RIUkVBRFM9MABNQVhfTU1BUF9TSVpFPTAAREVGQVVMVF9NTUFQX1NJWkU9MABUSFJFQURTQUZFPTAAOTIyMzM3MjAzNjg1NDc3NTgwAERFRkFVTFRfUENBQ0hFX0lOSVRTWj0yMABsb2cxMABNQVhfQVRUQUNIRUQ9MTAAXHUwMABNQVhfQ09NUE9VTkRfU0VMRUNUPTUwMABNQVhfQ09MVU1OPTIwMDAAREVGQVVMVF9XQUxfQVVUT0NIRUNLUE9JTlQ9MTAwMABNQVhfRVhQUl9ERVBUSD0xMDAwAE1BWF9UUklHR0VSX0RFUFRIPTEwMDAAXHUwMDAwAE1BWF9MSUtFX1BBVFRFUk5fTEVOR1RIPTUwMDAwAE1BWF9WREJFX09QPTI1MDAwMDAwMABNQVhfTEVOR1RIPTEwMDAwMDAwMDAATUFYX1NRTF9MRU5HVEg9MTAwMDAwMDAwMABzZWNvbmQgYXJndW1lbnQgdG8gJSNUKCkgbXVzdCBiZSBhIGNvbnN0YW50IGJldHdlZW4gMC4wIGFuZCAxLjAAQ09NUElMRVI9Y2xhbmctMTYuMC4wAFBSQUdNQSBkZWZlcl9mb3JlaWduX2tleXMgPSAwAFNFTEVDVCAwLCAndGJsJywgICcnLCAwLCAnJywgMSAgICAgVU5JT04gQUxMIFNFTEVDVCAxLCAnaWR4JywgICcnLCAwLCAnJywgMiAgICAgVU5JT04gQUxMIFNFTEVDVCAyLCAnc3RhdCcsICcnLCAwLCAnJywgMAAlcyUuM3gvAC9wcm9jL3NlbGYvZmQvAElOU0VSVCBJTlRPIG1haW4uAERFTEVURSBGUk9NIG1haW4uAFVQREFURSBtYWluLgAlUS4ATi4ALS0AIm5hbWUiOiAic3FsaXRlM19pbmRleF9vcmRlcmJ5IiwAIm5hbWUiOiAic3FsaXRlM19pbmRleF9jb25zdHJhaW50IiwAIm5hbWUiOiAiV2FzbVRlc3RTdHJ1Y3QiLAAibmFtZSI6ICJzcWxpdGUzX3ZmcyIsACJuYW1lIjogInNxbGl0ZTNfa3Z2ZnNfbWV0aG9kcyIsACJuYW1lIjogInNxbGl0ZTNfaW9fbWV0aG9kcyIsACJuYW1lIjogInNxbGl0ZTNfdnRhYl9jdXJzb3IiLAAibmFtZSI6ICJzcWxpdGUzX2luZGV4X2luZm8iLAAibmFtZSI6ICJzcWxpdGUzX21vZHVsZSIsACJuYW1lIjogInNxbGl0ZTNfZmlsZSIsACJuYW1lIjogInNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZSIsACJuYW1lIjogInNxbGl0ZTNfdnRhYiIsAG5vc2tpcHNjYW4qAHVub3JkZXJlZCoAc3o9WzAtOV0qAF9yb3dpZF8sICoAU0VMRUNUICVzLCVzIEZST00gIiV3Ii4iJXciLCAiJXciLiIldyIgV0hFUkUgJXMgQU5EICgleikAIEFORCAoPyVkIE9SID8lZCBJUyAldy4ldykAKHN1YnF1ZXJ5LSV1KQAoam9pbi0ldSkAQmFkIHB0ciBtYXAgZW50cnkga2V5PSV1IGV4cGVjdGVkPSgldSwldSkgZ290PSgldSwldSkAbWF4IHJvb3RwYWdlICgldSkgZGlzYWdyZWVzIHdpdGggaGVhZGVyICgldSkAQ1JFQVRFIFRBQkxFIHgodHlwZSB0ZXh0LG5hbWUgdGV4dCx0YmxfbmFtZSB0ZXh0LHJvb3RwYWdlIGludCxzcWwgdGV4dCkAQ1JFQVRFIFRBQmxFIHZvY2FiKHRlcm0sIGRvYywgY250KQBDUkVBVEUgVEFCbEUgdm9jYWIodGVybSwgY29sLCBkb2MsIGNudCkAQ1JFQVRFIFRBQmxFIHZvY2FiKHRlcm0sIGRvYywgY29sLCBvZmZzZXQpACBBTkQgKD82IE9SID8zIElTIHN0YXQpAGkoc3NzKQBpKHNzKQBpKHBzKQBOb2RlICVsbGQgaXMgdG9vIHNtYWxsICglZCBieXRlcykATm9kZSAlbGxkIGlzIHRvbyBzbWFsbCBmb3IgY2VsbCBjb3VudCBvZiAlZCAoJWQgYnl0ZXMpAGkocykAUkVQTEFDRSBJTlRPICVRLiclcV9kb2NzaXplJyBWQUxVRVMoPyw/JXMpAHJ0cmVlIGNvbnN0cmFpbnQgZmFpbGVkOiAlcy4oJXM8PSVzKQBDUkVBVEUgVEFCTEUgJVEuJXMoJXMpAGF1dG9tYXRpYyBpbmRleCBvbiAlcyglcykAQU5ZKCVzKQBJTlNFUlQgSU5UTyAlUS4nJXFfY29udGVudCcgVkFMVUVTKCVzKQBSRVBMQUNFIElOVE8gJVEuJyVxX2NvbnRlbnQnIFZBTFVFUyglcykAQ1JFQVRFIFRBQkxFICVRLiclcV9jb250ZW50JyglcykAbWFsZm9ybWVkIGRhdGFiYXNlIHNjaGVtYSAoJXMpAFNFTEVDVCAlcyVzIEZST00gJVEuJVEgV0hFUkUgKCVzKSBJUyAoJXMpAE1FUkdFICglcykAU3RhcnQ6ICVzLiVzICglcyAlcyVzJXMgT04gJXMpAFNFTEVDVCAlcyBGUk9NICIldyIuIiV3IiBXSEVSRSBOT1QgRVhJU1RTICggIFNFTEVDVCAxIEZST00gIiV3Ii4iJXciIFdIRVJFICVzKQBDUkVBVEUgVEFCTEUgJVEuc3FsaXRlX3NlcXVlbmNlKG5hbWUsc2VxKQBpKHBpc3BwKQBpKHBwaXBwcCkAaShwcHApAGkocGlwcCkAdihwcCkAcChwcCkAaShwcCkAaShwanApAGkocGlzaXApAGkocHBwaXApAGkocHBpcCkAcChwaXApAGkocGlwKQBpKHBqaXApAGkocGlpaXApAHYocCkAaShwKQBDUkVBVEUgVEFCTEUgeChpbnB1dCwgdG9rZW4sIHN0YXJ0LCBlbmQsIHBvc2l0aW9uKQBzZWdpZCwgdGVybSwgcGdubywgUFJJTUFSWSBLRVkoc2VnaWQsIHRlcm0pAENSRUFURSBUQUJMRSB4KHNxbCxuY29sLHJvLGJ1c3ksbnNjYW4sbnNvcnQsbmFpZHgsbnN0ZXAscmVwcmVwLHJ1bixtZW0pAChudWxsKQBmdHM1OiAlcyBxdWVyaWVzIGFyZSBub3Qgc3VwcG9ydGVkIChkZXRhaWwhPWZ1bGwpAGkocGopAGkocHBpaikAaShzc3BpKQBpKHBwaSkAaShwaSkAaShwaWlpKQBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfZHJvcF9jb2x1bW4oJWQsIHNxbCwgJWQpIFdIRVJFICh0eXBlPT0ndGFibGUnIEFORCB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSkAZnRzNTogY29sdW1uIHF1ZXJpZXMgYXJlIG5vdCBzdXBwb3J0ZWQgKGRldGFpbD1ub25lKQBtZW1kYiglcCwlbGxkKQBGb3VuZCAoJWxsZCAtPiAlbGxkKSBpbiAlcyB0YWJsZSwgZXhwZWN0ZWQgKCVsbGQgLT4gJWxsZCkAJXMoJWQpACVzLmV4cHIoJWQpAGZpcnN0X2VudHJ5X2luKCVkKQB6ZXJvYmxvYiglZCkAUnRyZWUgZGVwdGggb3V0IG9mIHJhbmdlICglZCkAdG9vIG1hbnkgcHJlZml4IGluZGV4ZXMgKG1heCAlZCkARlRTIGV4cHJlc3Npb24gdHJlZSBpcyB0b28gbGFyZ2UgKG1heGltdW0gZGVwdGggJWQpAGZ0czUgZXhwcmVzc2lvbiB0cmVlIGlzIHRvbyBsYXJnZSAobWF4aW11bSBkZXB0aCAlZCkARXhwcmVzc2lvbiB0cmVlIGlzIHRvbyBsYXJnZSAobWF4aW11bSBkZXB0aCAlZCkAKGJsb2IpAFVTRSBURU1QIEItVFJFRSBGT1IgJXMoT1JERVIgQlkpAFVTRSBURU1QIEItVFJFRSBGT1IgJXMoRElTVElOQ1QpAFVQREFURSAiJXciLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfY29sdW1uKHNxbCwgdHlwZSwgbmFtZSwgJVEsICVRLCAlZCwgJVEsICVkLCAlZCkgV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyAgQU5EICh0eXBlICE9ICdpbmRleCcgT1IgdGJsX25hbWUgPSAlUSkAQ1JFQVRFIFRBQkxFIHgoa2V5LHZhbHVlLHR5cGUsYXRvbSxpZCxwYXJlbnQsZnVsbGtleSxwYXRoLGpzb24gSElEREVOLHJvb3QgSElEREVOKQAleiwgJVEgSElEREVOLCAlcyBISURERU4pAENSRUFURSBUQUJMRSB4KHRlcm0sIGNvbCwgZG9jdW1lbnRzLCBvY2N1cnJlbmNlcywgbGFuZ3VhZ2VpZCBISURERU4pAENSRUFURSBUQUJMRSB4KHBnbm8gSU5URUdFUiBQUklNQVJZIEtFWSwgZGF0YSBCTE9CLCBzY2hlbWEgSElEREVOKQBDUkVBVEUgVEFCTEUgeCglcyAlUSBISURERU4sIGRvY2lkIEhJRERFTiwgJVEgSElEREVOKQAoTlVMTCkAKEZLKQA/MSwgKENBU0UgV0hFTiA/Mj1YJycgVEhFTiBOVUxMIEVMU0UgPzIgRU5EKQAlYz8pAFNFTEVDVCBOT1QgRVhJU1RTKFNFTEVDVCBkb2NpZCBGUk9NICVRLiclcV9jb250ZW50JyBXSEVSRSByb3dpZCE9PykAUkVQTEFDRSBJTlRPICVRLiclcV9zZWdkaXInIFZBTFVFUyg/LD8sPyw/LD8sPykASU5TRVJUIElOVE8gJyVxJy4nJXFfaWR4JyhzZWdpZCx0ZXJtLHBnbm8pIFZBTFVFUyg/LD8sPykAUkVQTEFDRSBJTlRPICclcScuJyVxX2RhdGEnKGlkLCBibG9jaykgVkFMVUVTKD8sPykAUkVQTEFDRSBJTlRPICVRLiclcV9zdGF0JyBWQUxVRVMoPyw/KQBSRVBMQUNFIElOVE8gJVEuJyVxX2NvbmZpZycgVkFMVUVTKD8sPykAUkVQTEFDRSBJTlRPICVRLiclcV9kb2NzaXplJyBWQUxVRVMoPyw/KQAsJXMoPykAUkVQTEFDRSBJTlRPICVRLiclcV9zZWdtZW50cycoYmxvY2tpZCwgYmxvY2spIFZBTFVFUyg/LCA/KQBwcmVmaXggbGVuZ3RoIG91dCBvZiByYW5nZSAobWF4IDk5OSkAREVMRVRFIEZST00gbWFpbi5zcWxpdGVfc3RhdDEgV0hFUkUgdGJsPT8xIEFORCBpZHggSVMgQ0FTRSBXSEVOIGxlbmd0aCg/Mik9MCBBTkQgdHlwZW9mKD8yKT0nYmxvYicgVEhFTiBOVUxMIEVMU0UgPzIgRU5EIEFORCAoPzQgT1Igc3RhdCBJUyA/MykASU5TRVJUIElOVE8gbWFpbi5zcWxpdGVfc3RhdDEgVkFMVUVTKD8xLCBDQVNFIFdIRU4gbGVuZ3RoKD8yKT0wIEFORCB0eXBlb2YoPzIpPSdibG9iJyBUSEVOIE5VTEwgRUxTRSA/MiBFTkQsID8zKQBJTlNFUlQgT1IgUkVQTEFDRSBJTlRPICclcScuJyVxX3BhcmVudCcgVkFMVUVTKD8xLCA/MikASU5TRVJUIE9SIFJFUExBQ0UgSU5UTyAnJXEnLiclcV9ub2RlJyBWQUxVRVMoPzEsID8yKQBJTlNFUlQgT1IgUkVQTEFDRSBJTlRPICclcScuJyVxX3Jvd2lkJyBWQUxVRVMoPzEsID8yKQBERUxFVEUgRlJPTSAnJXEnLiclcV9pZHgnIFdIRVJFIChzZWdpZCwgKHBnbm8vMikpID0gKD8xLCA/MikAU0VMRUNUIGNvYWxlc2NlKChTRUxFQ1QgbWF4KGJsb2NraWQpIEZST00gJVEuJyVxX3NlZ21lbnRzJykgKyAxLCAxKQBJTlNFUlQgSU5UTyB2YWN1dW1fZGIuc3FsaXRlX3NjaGVtYSBTRUxFQ1QqRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZSBJTigndmlldycsJ3RyaWdnZXInKSBPUih0eXBlPSd0YWJsZSdBTkQgcm9vdHBhZ2U9MCkAU0VMRUNUICogRlJPTSAoU0VMRUNUICdzcWxpdGVfc2NoZW1hJyBBUyBuYW1lLDEgQVMgcm9vdHBhZ2UsJ3RhYmxlJyBBUyB0eXBlIFVOSU9OIEFMTCBTRUxFQ1QgbmFtZSxyb290cGFnZSx0eXBlIEZST00gIiV3Ii5zcWxpdGVfc2NoZW1hIFdIRVJFIHJvb3RwYWdlIT0wKQBJTlNFUlQgSU5UTyAiJXciLiIld19ub2RlIlZBTFVFUygxLHplcm9ibG9iKCVkKSkAd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBoaWdobGlnaHQoKQB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIHNuaXBwZXQoKQBtaXN1c2Ugb2Ygc3FsaXRlM19yZXN1bHRfc3VidHlwZSgpIGJ5ICVzKCkAbWlzdXNlIG9mIGFnZ3JlZ2F0ZTogJXMoKQBwKCkAd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBydHJlZWNoZWNrKCkASW52YWxpZCBhcmd1bWVudCB0byBydHJlZWRlcHRoKCkAbWlzdXNlIG9mICVzIGZ1bmN0aW9uICUjVCgpAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJSNUKCkAdW5zYWZlIHVzZSBvZiAlI1QoKQBPUkRFUiBCWSBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAEZJTFRFUiBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAHVua25vd24gZnVuY3Rpb246ICUjVCgpAG1pc3VzZSBvZiBhZ2dyZWdhdGU6ICUjVCgpAGFtYmlndW91cyByZWZlcmVuY2UgdG8gJXMgaW4gVVNJTkcoKQBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX2NvbHVtbihzcWwsIHR5cGUsIG5hbWUsICVRLCAlUSwgJWQsICVRLCAlZCwgMSkgV0hFUkUgdHlwZSBJTiAoJ3RyaWdnZXInLCAndmlldycpAFVQREFURSBzcWxpdGVfdGVtcF9zY2hlbWEgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfdGFibGUoJVEsIHR5cGUsIG5hbWUsIHNxbCwgJVEsICVRLCAxKSwgdGJsX25hbWUgPSBDQVNFIFdIRU4gdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UgQU5EICAgc3FsaXRlX3JlbmFtZV90ZXN0KCVRLCBzcWwsIHR5cGUsIG5hbWUsIDEsICdhZnRlciByZW5hbWUnLCAwKSBUSEVOICVRIEVMU0UgdGJsX25hbWUgRU5EIFdIRVJFIHR5cGUgSU4gKCd2aWV3JywgJ3RyaWdnZXInKQAsJXMoeC4nYyVkJXEnKQBQUkFHTUEgJyVxJy50YWJsZV9pbmZvKCclcScpAElOU0VSVCBJTlRPICVRLnNxbGl0ZV9tYXN0ZXIgVkFMVUVTKCd0cmlnZ2VyJywlUSwlUSwwLCdDUkVBVEUgVFJJR0dFUiAlcScpAElOU0VSVCBJTlRPICVRLiVRKCVRKSBWQUxVRVMoJ2ZsdXNoJykAU0VMRUNUIDIgKiB0b3RhbCgxICsgbGVhdmVzX2VuZF9ibG9jayAtIHN0YXJ0X2Jsb2NrKSAgIEZST00gKFNFTEVDVCAqIEZST00gJVEuJyVxX3NlZ2RpcicgICAgICAgICBXSEVSRSBsZXZlbCA9ID8gT1JERVIgQlkgaWR4IEFTQyBMSU1JVCA/ICApAAopAENSRUFURSBUQUJMRSB4KABCTE9PTSBGSUxURVIgT04gJVMgKABTRUxFQ1Qgc3FsIEZST00gIiV3Ii5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGU9J2luZGV4JwBERUxFVEUgRlJPTSAlUS5zcWxpdGVfbWFzdGVyIFdIRVJFIG5hbWU9JVEgQU5EIHR5cGU9J2luZGV4JwBuYW1lPSclcScgQU5EIHR5cGU9J2luZGV4JwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcAREVMRVRFIEZST00gJVEuJyVxX3N0YXQnAERFTEVURSBGUk9NICVRLiclcV9zZWdtZW50cycAU0VMRUNUIGNvdW50KCopIEZST00gJVEuJyVxJXMnAFNFTEVDVCBjb3VudCgqKSBGUk9NICVRLiclcV8lcycAREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicAU0VMRUNUID8gVU5JT04gU0VMRUNUIGxldmVsIC8gKDEwMjQgKiA/KSBGUk9NICVRLiclcV9zZWdkaXInAFNFTEVDVCBtYXgoIGxldmVsICUlIDEwMjQgKSBGUk9NICVRLiclcV9zZWdkaXInAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0ndHJpZ2dlcicAREVMRVRFIEZST00gJVEuc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0lUSBhbmQgdHlwZSE9J3RyaWdnZXInAHRibF9uYW1lPSclcScgQU5EIHR5cGUhPSd0cmlnZ2VyJwAnJS4qcScAJXosICdjJWQlcScAdHlwZT0ndHJpZ2dlcicgQU5EIG5hbWU9JyVxJwAsIHguJyVxJwBpbmRleCAnJXEnAFNFTEVDVCBrLCB2IEZST00gJVEuJyVxX2NvbmZpZycAREVMRVRFIEZST00gJVEuJyVxX2RvY3NpemUnAGludmFsaWQgZnRzNSBmaWxlIGZvcm1hdCAoZm91bmQgJWQsIGV4cGVjdGVkICVkIG9yICVkKSAtIHJ1biAncmVidWlsZCcAU0VMRUNUICogRlJPTSAlUS4nJXFfcm93aWQnAFNFTEVDVCBzdGF0IEZST00gJVEuc3FsaXRlX3N0YXQxIFdIRVJFIHRibCA9ICclcV9yb3dpZCcAU0VMRUNUIHQuJVEgRlJPTSAlUS4lUSBBUyB0IFdIRVJFIHQuJVEgTUFUQ0ggJyppZCcAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV90YWJsZSglUSwgdHlwZSwgbmFtZSwgc3FsLCAlUSwgJVEsICVkKSBXSEVSRSAodHlwZSE9J2luZGV4JyBPUiB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSlBTkQgICBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnAFNFTEVDVCBDQVNFIFdIRU4gcXVpY2tfY2hlY2sgR0xPQiAnQ0hFQ0sqJyBUSEVOIHJhaXNlKEFCT1JULCdDSEVDSyBjb25zdHJhaW50IGZhaWxlZCcpIFdIRU4gcXVpY2tfY2hlY2sgR0xPQiAnbm9uLSogdmFsdWUgaW4qJyBUSEVOIHJhaXNlKEFCT1JULCd0eXBlIG1pc21hdGNoIG9uIERFRkFVTFQnKSBFTFNFIHJhaXNlKEFCT1JULCdOT1QgTlVMTCBjb25zdHJhaW50IGZhaWxlZCcpIEVORCAgRlJPTSBwcmFnbWFfcXVpY2tfY2hlY2soJVEsJVEpIFdIRVJFIHF1aWNrX2NoZWNrIEdMT0IgJ0NIRUNLKicgT1IgcXVpY2tfY2hlY2sgR0xPQiAnTlVMTConIE9SIHF1aWNrX2NoZWNrIEdMT0IgJ25vbi0qIHZhbHVlIGluKicAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9xdW90ZWZpeCglUSwgc3FsKVdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScAVVBEQVRFIHRlbXAuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9xdW90ZWZpeCgndGVtcCcsIHNxbClXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnIEFORCBzcWwgTk9UIExJS0UgJ2NyZWF0ZSB2aXJ0dWFsJSUnAHNxbGl0ZVxfJQAkAFNFTEVDVCpGUk9NIiV3IgBTRUxFQ1QqRlJPTSIldyIuIiV3IgAleiVzIiV3Ii4iJXciLiIldyIAJXolcyIldyIuIiV3Ii4iJXciPSIldyIuIiV3Ii4iJXciACV6JXMiJXciLiIldyIuIiV3IiBJUyBOT1QgIiV3Ii4iJXciLiIldyIAU0VMRUNUIHJhaXNlKEFCT1JULCVRKSBGUk9NICIldyIuIiV3IgBBTkFMWVpFICIldyIuIiV3IgBmb3JlaWduIGtleSBtaXNtYXRjaCAtICIldyIgcmVmZXJlbmNpbmcgIiV3IgBkb3VibGUtcXVvdGVkIHN0cmluZyBsaXRlcmFsOiAiJXciAGZ0czU6IHN5bnRheCBlcnJvciBuZWFyICIlLjFzIgAuIiUuKnMiAGV4cGVjdGVkIGludGVnZXIsIGdvdCAiJS4qcyIAZnRzNTogc3ludGF4IGVycm9yIG5lYXIgIiUuKnMiAHN5bnRheCBlcnJvciBhZnRlciBjb2x1bW4gbmFtZSAiJS4qcyIAdW5yZWNvZ25pemVkIG9wdGlvbjogIiUuKnMiACVjIiVzIgAoIiVzIgBjYW5ub3QgJXMgJXMgIiVzIgBnZW5lcmF0ZWQgY29sdW1uIGxvb3Agb24gIiVzIgBjYW5ub3QgSU5TRVJUIGludG8gZ2VuZXJhdGVkIGNvbHVtbiAiJXMiAGVycm9yIGluIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgBjYW5ub3QgVVBEQVRFIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgAlcyBpbiAiJXMiAHBhcnNlIGVycm9yIGluICIlcyIAdHJpZ2dlciAiJXMiIG1heSBub3Qgd3JpdGUgdG8gc2hhZG93IHRhYmxlICIlcyIAVVBTRVJUIG5vdCBpbXBsZW1lbnRlZCBmb3IgdmlydHVhbCB0YWJsZSAiJXMiAHVuc2FmZSB1c2Ugb2YgdmlydHVhbCB0YWJsZSAiJXMiAGNhbm5vdCBjcmVhdGUgYSBURU1QIGluZGV4IG9uIG5vbi1URU1QIHRhYmxlICIlcyIAbm8gc3VjaCBpbmRleDogIiVzIgB1bmtub3duIGRhdGF0eXBlIGZvciAlcy4lczogIiVzIgBjYW5ub3QgZHJvcCAlcyBjb2x1bW46ICIlcyIAbm8gc3VjaCBjb2x1bW46ICIlcyIAdW5yZWNvZ25pemVkIHRva2VuOiAiJXMiACVzIiVzIjogIiVzIgB1bmRlcnNpemUgUlRyZWUgYmxvYnMgaW4gIiVxX25vZGUiAFwiAG5vIHN1Y2ggY29sdW1uOiAiJVQiAHVucmVjb2duaXplZCB0b2tlbjogIiVUIgAuIgB3ZWVrZGF5IABub24tdW5pcXVlIGVudHJ5IGluIGluZGV4IAB3cm9uZyAjIG9mIGVudHJpZXMgaW4gaW5kZXggACB2YWx1ZXMgZGlmZmVyIGZyb20gaW5kZXggACBtaXNzaW5nIGZyb20gaW5kZXggACBvZiBpbmRleCAAcm93aWQgbm90IGF0IGVuZC1vZi1yZWNvcmQgZm9yIHJvdyAAJXIgAHN0YXJ0IG9mIAAlZCAlZCAlZCAlZCAAIFVTSU5HIENPVkVSSU5HIElOREVYIABVUERBVEUgIiV3Ii4iJXdfcm93aWQiU0VUIAAgU0VU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AwAAAEAAAOsDAAAAAAQA9wMAAAAAAIDsAwAAAABAAO0DAAAAAAEA7gMAAAAIAADvAwAAAACAAPADAAAAAAAB8QMAAAAAAALyAwAAAAAAEPMDAAABAAAI9AMAAAAAAAT2AwAAAAAAIPUDAAAAAABA+AMAAAIAAAD5AwAAgAAAAPoDAAAABAAA+wMAAAAQAAAAypo7AMqaO9AHAADoAwAA9AEAAICy5g5/AAAACgAAAFDDAAD+fwAA6AMAAAAAAAD///////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0OD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2dUF+SChY9cAQfCzAwuUH1NRTGl0ZSBmb3JtYXQgMwBCSU5BUlkAU2F2ZXBvaW50AABBdXRvQ29tbWl0AABUcmFuc2FjdGlvbgAAQ2hlY2twb2ludAAASm91cm5hbE1vZGUAAFZhY3V1bQAAVkZpbHRlcgBpcGxhbj1yW1AzXSB6cGxhbj0nUDQnAFZVcGRhdGUAZGF0YT1yW1AzQFAyXQBJbml0AFN0YXJ0IGF0IFAyAEdvdG8AAEdvc3ViAABJbml0Q29yb3V0aW5lAABZaWVsZAAATXVzdEJlSW50AABKdW1wAABPbmNlAABJZgAASWZOb3QAAElzVHlwZQBpZiB0eXBlb2YoUDEuUDMpIGluIFA1IGdvdG8gUDIATm90AHJbUDJdPSAhcltQMV0ASWZOdWxsUm93AGlmIFAxLm51bGxSb3cgdGhlbiByW1AzXT1OVUxMLCBnb3RvIFAyAFNlZWtMVABrZXk9cltQM0BQNF0AU2Vla0xFAGtleT1yW1AzQFA0XQBTZWVrR0UAa2V5PXJbUDNAUDRdAFNlZWtHVABrZXk9cltQM0BQNF0ASWZOb3RPcGVuAGlmKCAhY3NyW1Ax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Ml0tcltQMV0ATXVsdGlwbHkAcltQM109cltQMV0qcltQMl0ARGl2aWRlAHJbUDNdPXJbUDJdL3JbUDFdAFJlbWFpbmRlcgByW1AzXT1yW1AyXSVyW1AxXQBDb25jYXQAcltQM109cltQMl0rcltQMV0AT3BlblJlYWQAcm9vdD1QMiBpRGI9UDMAT3BlbldyaXRlAHJvb3Q9UDIgaURiPVAzAEJpdE5vdAByW1AyXT0gfnJbUDFdAE9wZW5EdXAAAE9wZW5BdXRvaW5kZXgAbkNvbHVtbj1QMgBTdHJpbmc4AHJbUDJdPSdQNCcAT3BlbkVwaGVtZXJhbABuQ29sdW1uPVAyAFNvcnRlck9wZW4AAFNlcXVlbmNlVGVzdABpZiggY3Vyc29yW1AxXS5jdHIrKyApIHBjID0gUDIAT3BlblBzZXVkbwBQMyBjb2x1bW5zIGluIHJbUDJdAENsb3NlAABDb2x1bW5zVXNlZAAAU2Vla1NjYW4AU2Nhbi1haGVhZCB1cCB0byBQMSByb3dzAFNlZWtIaXQAc2V0IFAyPD1zZWVrSGl0PD1QMwBTZXF1ZW5jZQByW1AyXT1jdXJzb3JbUDFdLmN0cisrAE5ld1Jvd2lkAHJbUDJdPXJvd2lkAEluc2VydABpbnRrZXk9cltQM10gZGF0YT1yW1AyXQBSb3dDZWxsAABEZWxldGUAAFJlc2V0Q291bnQAAFNvcnRlckNvbXBhcmUAaWYga2V5KFAxKSE9dHJpbShyW1AzXSxQNCkgZ290byBQMgBTb3J0ZXJEYXRhAHJbUDJdPWRhdGEAUm93RGF0YQByW1AyXT1kYXRhAFJvd2lkAHJbUDJdPVBYIHJvd2lkIG9mIFAxAE51bGxSb3cAAFNlZWtFbmQAAElkeEluc2VydABrZXk9cltQMl0AU29ydGVySW5zZXJ0AGtleT1yW1AyXQBJZHhEZWxldGUAa2V5PXJbUDJAUDNdAERlZmVycmVkU2VlawBNb3ZlIFAzIHRvIFAxLnJvd2lkIGlmIG5lZWRlZABJZHhSb3dpZAByW1AyXT1yb3dpZABGaW5pc2hTZWVrAABEZXN0cm95AABDbGVhcgAAUmVzZXRTb3J0ZXIAAENyZWF0ZUJ0cmVlAHJbUDJdPXJvb3QgaURiPVAxIGZsYWdzPVAzAFNxbEV4ZWMAAFBhcnNlU2NoZW1hAABMb2FkQW5hbHlzaXMAAERyb3BUYWJsZQAARHJvcEluZGV4AABSZWFsAHJbUDJdPVA0AERyb3BUcmlnZ2VyAABJbnRlZ3JpdHlDawAAUm93U2V0QWRkAHJvd3NldChQMSk9cltQMl0AUGFyYW0AAEZrQ291bnRlcgBma2N0cltQMV0rPVAyAE1lbU1heAByW1AxXT1tYXgocltQMV0scltQMl0pAE9mZnNldExpbWl0AGlmIHJbUDFdPjAgdGhlbiByW1AyXT1yW1AxXSttYXgoMCxyW1AzXSkgZWxzZSByW1AyXT0oLTEpAEFnZ0ludmVyc2UAYWNjdW09cltQM10gaW52ZXJzZShyW1AyQFA1XSkAQWdnU3RlcABhY2N1bT1yW1AzXSBzdGVwKHJbUDJAUDVdKQBBZ2dTdGVwMQBhY2N1bT1yW1AzXSBzdGVwKHJbUDJAUDVdKQBBZ2dWYWx1ZQByW1AzXT12YWx1ZSBOPVAyAEFnZ0ZpbmFsAGFjY3VtPXJbUDFdIE49UDIARXhwaXJlAABDdXJzb3JMb2NrAABDdXJzb3JVbmxvY2sAAFRhYmxlTG9jawBpRGI9UDEgcm9vdD1QMiB3cml0ZT1QMwBWQmVnaW4AAFZDcmVhdGUAAFZEZXN0cm95AABWT3BlbgAAVkNoZWNrAABWSW5pdEluAHJbUDJdPVZhbHVlTGlzdChQMSxQMykAVkNvbHVtbgByW1AzXT12Y29sdW1uKFAyKQBWUmVuYW1lAABQYWdlY291bnQAAE1heFBnY250AABDbHJTdWJ0eXBlAHJbUDFdLnN1YnR5cGUgPSAwAEdldFN1YnR5cGUAcltQMl0gPSByW1AxXS5zdWJ0eXBlAFNldFN1YnR5cGUAcltQMl0uc3VidHlwZSA9IHJbUDFdAEZpbHRlckFkZABmaWx0ZXIoUDEpICs9IGtleShQM0BQNCkAVHJhY2UAAEN1cnNvckhpbnQAAFJlbGVhc2VSZWcAcmVsZWFzZSByW1AxQFAyXSBtYXNrIFAzAE5vb3AAAEV4cGxhaW4AAEFib3J0YWJsZQAAAAAAAAECAAICAAECAQEBAgECEAEBAQEBAQIBARAQABAAAgIAQZHTAwuYAQECAwQGCAgAAAAAAAABAQICAwMEBAUFBgYHBwgICQkKCgsLDAwNDQ4ODw8QEBEREhITExQUFRUWFhcXGBgZGRoaGxscHB0dHh4fHyAgISEiIiMjJCQlJSYmJycoKCkpKiorKywsLS0uLi8vMDAxMTIyMzM0NDU1NjY3Nzg4OTkQQAJAAAABAgMEBggAAAAAIQAgAB4AHAAaAEGy1AMLCQEBAwAFAAYACABB0NQDCwEBAEH01AMLnQEQAEEAgQEBgYODAQEDAwESAcnJyckBSUlJSclJwQFBQcEBQUFBQUEmJkEjC4EBAwMLCwsLCwsBAwMDAUEBAAACAggAEBAQABAAEBAAABAQAAAAAgICAAASHiBAAAAAEBAAQCYmJiYmJiYmJiZAABJAQBBAAAAAQABAQBAQAAAAAABAAFAAQAQEAEBQQBAAABAAAAAAABAAAAYQAAQaAEGd1gMLCkAQUEAAEBACEhIAQbHWAwtCAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHwABAgMEBQYHCAkKCwwNDg8AAQIDBAUGBwABAgMAAQAAAwIBAEGA1wMLlAJUXIZSaR0AAF4AVUgANSNWDwAqYTZZhxMAAIwAKIEAFmsACQAAe1AATgYAQWeTAIhzAAAwAFoYABEAG0YXGgU8jm56AElbR5E9eEoAMQALKQBxAAAAbQpvdH0OMnwAZAASeZA4gotYUyUefgAAbDODgAAiAACEAGImJwAULXVdAABidKEnOil8QyGEPj8vAkGjJhiKEHafC4OgW4AVFSsyUg2JXjMTQnkviAYcc3aiRwkUd5dFRIJNWV8oky8Fdn17AxpRdg4gMJhckiMfeJ1xEWQIj38uBB5GYQeMLYGLUGCelUgbHWMshVd+DzEkPAoldmRkVVgqVKZJU1aOdpQSkUpdpZZ2DExLWoaQTk+kPSJAh3oAQaXZAws0BAArAABqcgAAAAIAAI8AAAANAAAAAI0AAHc0AACJDAAAPgCKAIUAACQAABxNAAAAADsALwBB49kDCyZFAAAAAACSAwA6AAFLAAAAHwAAAAAAfwBoAEBCPwAAAAAALgAQCABBk9oDCyFRZQBwFQdDAE9gdgAARAAAYywANwBMAF8gITkZAGYAAFcAQcDaAwurAh0cHBwcHBwcHAcHHAcHHBwcHBwcHBwcHBwcHBwcHBwcBw8IBQQWGAgREhUUFwsaEAMDAwMDAwMDAwMFEwwODQYFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAgIJHBwcAggBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQACAhwKHBkcGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbHhsbGxsbGxsbGxsbGxsbGxsAAAAAOwA7ADsAOwAAADsAOwA7AAAAOwA7ADsAOwAAAAAAAAA7AAAAAAA7AEH03AMLKzsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwAAAAAAAAA7ADsAQbjdAwtROwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7AEHA3wMLsVv//f/9AP////7+/v37+v8A/f8A+/4A/f7//gD8+v4AAP79/Pz8/f37/vz8//79/AD/AP7+/f39/v7///79/gD+/gD//vn7+/YAAP0A/v///P4A9/z//fz//f/+//f2/P/7+///AAD7/fv+AAD+/gD7+vj6+gD+//3//fv9//79/P78AAD9/gD9+/3//wD+/gAA/QD+AP78/PoA/gD+/vz3+/n9+/n4AP709/v4/v7/AP39//3//fv//////fr7+Pz69/v/+/39/f39/f39/v37/v39/Pr7/v7+/f/++//++/37+/z7+/z+AAAA/f8A/fT/AAD9+/0A/vz+/f4A/fv6+/r+/vv1//4A///9AP79/v39/vf4+v38+v////z6/QD+//3//fr5+v/4//z4AP/9//79//79+v///f37+/r8+/4A/fr///7//v7+AP7+/v/+/v///P77///+///+/QD//v8A/v/8/v////////4A/vz+/v3/AP/////+//8A/////////////wD9/wD/AAD///3+APz+AP//AAAAAAAAAAAHNAbWBUIBQgGPATIBJwU7BZYFJAckByQHRAKPAY8BjwGPAY8BAAAAANYARQQkByQHJAckByQHJAckByQHJAckByQHJAckByQHJAdqBGoEbQFtATcAFgG0AckCyQLJAMkAyQDJACgAbwACAWkB1QEAAkcCbgK1AtwCIwNKA5EDMQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRZBEUEwAS9A70D8wVCBooGJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAeJALUAtQC1ALUAtQC1ALUAYADeAI8A3QHJAm0E9ATJAskCTwBPAMkCAgNTAEEAQQBBACABogCiAF4IXgi4ArgCuALuANoB2gHaAdoBwQTBBKYC3QFEAY4ByQLJAskCyQLJAskCyQLJAskCyQLJAskCyQLJAskCyQLJAskCyQLEBG4BbgHJApUDGwEbAbIBsgFdAl0CEgVeCF4IXgheCF4IXgheCJsEhQSFBOcBDwJJAoUC7QKSA8gD8ALJAskCyQLJAskCyQLJAskCyQLJAi8ByQLJAskCyQLJAskCyQLJAskCyQLJAskCHQMdAx0DyQLJAskCvwPJAskCyQKRBPcEyQLJAjIFyQLJAskCyQLJAskCyQLJAnUCBwBbAGwDbANsA2wDuQNbAFsA3gQpBFIEXgUxBUQF1AFEBXIFEQMxBTEFEQMxBdQBcgVbA1YDegWpBakFqQWVBJUElQSVBEsFSwUGBD0FlQHOBAMHAwevBq8GJQclB68GtQa3BjoHKQdEB0QHRAdEB68GTAfMBrcGtwbMBjoHKQfMBikHzAavBkwH0QYzB68GTAdfB68GTAevBkwHXwcJBwkHCQc/B2wHbAdfBwkHBQcJBz8HCQcJB+EGeAcmByYHXwevBkYHRgdTB1MHEgcXB5QHrwYPBxIHHQcfB8wGmQerB6sHtge2B7YHXgheCF4IXgheCF4IXgheCF4IXgheCF4IXgheCF4IFADIBAABVwRbBFoEqATYBZAF4QWTBWMBZwUBBuIFAgYRBi8GMAY3BlkGHQKlBRoGqgUkBusFlAX8BTgGXQbwBV4GZwbmBQgGfgaLBg8GMADMB9EHvwc0B8kHygfCB8UHUgdHB10HxwfHB8sHVAfNB1UH1AflB1kHZgfHB2cHrQfGB8cHVge3B7kHuge7B28HfgfSB2gH8gfxB+EHhQdYB7gH4ge8B68H1QdwB4wH6QfuB/AHgQeIB/MHwwf0B/UH9gf4B8QH1gf3B6gH+Qf6B88H5wf8B/sHfwcACAEIAgj+BwMIBQi9B48HCAgJCK4H/wcNCJUHDAgECAYIBwgKCNMH3AfXBwsI3wfYBw4IFwgZCBoIGAgbCBEIqgesBx8IDAgiCCQIJQgnCCYIKQgoCCsILQgzCC4ILwgwCDEINAg1CDYIzgfAB8EH0Ac3CDIIPQhFCFAIAADCABQBFQEWAdgAwgDCANkAwgDCAMIAwgDgAMIAwgAUARUBFgHMABMAzgDKACkB2QDaAM0AzwDZAM0A2QDaAB8A2QDaANkA2gAdANkA2gAnACEA2QDcACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADgBEwDwAPEAPAHwAPEAwgAuAC8AMAAxABYA/gBBAP0A/gD/AP0AwgD/AMIABwECAQMBKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAFAEVARYBHQFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQA7ALoAuwC8AL0AvgC/ADYB7wA9AT4BxABWAMYAWAA9ARMAPwE9AT4BzQAIARkA0wDUANUAzQB5AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5APAA8QB0AHUAdgB3APAA8QB6AHsAfABFACoB/QDCAP8AagBrAIQA/QCNAP8ANgA3ADgAOQA6AM8ADAFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQDWAIAAgQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQCGABkAiACJACwBpQCmAJkAEwCbADYANwA4ADkAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAFAEVARYBcQDCABMAFgAXAMIAQwAYAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxANwA+gA7APwA2QDaACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAGoAawBsAG0AbgBvAHAAcQD+ADsAzQCKAIsAEwAUAMIAFgAHARYAFwDnABkASAAUARUBFgF0AHUAdgBlACQATABmAGcAaABpAGoAawBsAG0AbgBvAHAAcQBZAPAA8QBcAEkAwgDCAEkAEwA7ALwAvQC+AL8A/QBRAP8AlwDEABkAxgBHAHQAdQB2ADcBOAHNANkA2gA8AVEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkADgEWABcAZAAZADsAZQCKAIsAagBrAH8AgACBAH8A8ADxAHIA/gB0AHUAdgBMAEwAeQCKAIsABwH9AAgB/wDNABMBVwATAFkAWQDCAFwAXADHAIoAiwAMAWYAZwBoAGkAagBrAGwAbQBuAG8AcABxAJkAmgCbAJwAnQBRAHQAdQB2AIEA8ADxAOAAEwDiADoBOwEXABkALAE7ABYA6gD9AGUA/wDsAO0AGgDCALcAwgCYAEgAFgCRAJYAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkA2QDaANkA2gATAL0AOwC/ABcAOwCKAIsAxACHAMYA6AAbAegAjAA7AB8BzQATAXQAzQB0AHUAdgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQDCAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAPAA8QDCAPAA8QA6ATsBdAB1AHYAdAB1AHYA/QDCAP8A/QA7AP8AEwB0AHUAdgAXABYA2QDaAI4ADAHNABMBZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAEwDCACwBOwAXAHcA8ADxAHoAewB8ADoBOwHCAOwA7QDCAHUAhAD9AFEA/wDNADsAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkA2QDaAMIAwgDCAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACYB8ADxAHgAdAB1AHYAOwDCANkA2gDTANQA1QD9ABMA/wDCABMAFwD+AIoAiwAYAOgAdQDCAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABMACAFsAEwAFwB/AIAAgQA3ATgBdAB1AHYAPAFXADIBWQA0AcIAXAAWADsAwgAWACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AMIAXwDZANoACQFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQDoADsAcQAZADsAwgDZANoAdwB4AHkAegB7AHwAfQATAJEAwgDCABcAgwDoAHQAdQB2ACMAwgBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQATAMIAQgDCAHQAdQB2AHQAdQB2AEoA8gAmAcIAwgDOABcAwgAZAMIAbwBwAHEAGQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAYAMIAwgDZANoAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA8QDoAMIA1ADVAPIA8gDZANoA8gCCAAsA/QDCAP8AEwAJAZUAOwAyAcIANAHoADUBNgHZANoAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAwgDCADsAwgDvABMAwgAZAP4ALwEwARcAwgAZAH4AMgEyATQBNAEyAQ8BNAF1AB4B2QDaANkA2gDCAMIAnwAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxADsA7wDCAHQAdQB2AAQB/gDCAPAA8QDCAOkAzQDwAPEAzQDvAIAAgQAOAQkB/QDCAP8A2QDaAP0AwgD/AI8AGAFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQB2AJ8A2QDaAPAA8QB2APAA8QDCAMIAwgDvAHQAdQB2ABYA/QD+AP8A/QATAP8A6QDCAI8AGAAHAdQA1QDCAI8A2QDaANkA2gAFAQYBDwH+AI8AEwAHAAgACQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAQABMAFgAXACYBKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOAHCANYAFQA8ASsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AGoAawAeAcIAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAzwCeADsAoAAWAE0AGABPAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAMIAwgDlAMIA5wBlAFAAFgBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAgATsADADZANoAJQHZANoAEwBqAGsAOwATABAAfwCAAIEAGwBzAHQAdQB2AMIAeAA7ABYAwgAYAMIAewBkAIAAKgAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAdQDCANkA2gB5AGQAPwDCAPUAmQDCAJsAdQATAHMAwgBJANYAwgAAAaEAdAB1AMIA2QDaAHkATQDCAE8A2QDaAMIA2QDaAHUAmQCaAJsA/gAuANkA2gCQAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAOgADgGZAJoAmwBzAHQAQgATABQAtwAWAAwAOAH+AMIABgE8AdEA0gAKAe8AwgDCAGwAJABVABsAEwAUAAkBFgC3APUAkABeABkAMADZANoAJQHCACoADgEAASQA2QDaADsAwgAZAIcAwgBzAMIAoQCMAMIAwgAPAEcAwgA4AT8A2QDaADwBwgA7AIMALQEuAdkA2gBVANkA2gDZANoAWgBHANkA2gATANkA2gD1AJIABgFkANkA2gAKAQkBVQBqAGsAAAE4AVoA0QDSADwBcgA8AHQAdQB2AMIAZAB5AMIAwgCRAHMAagBrABMALgATABQAGAAWAHIAwgB0AHUAdgDCAPUAeQDCAKQAwgDZANoAJADCAAIBAwEAAcIAmQCaAJsAnACdANkA2gCWAB8A2QDaAI4A2QDaANkA2gAnADsA2QDaAJkAmgCbAJwAnQCVAJYABQCRAEcAtwD1AAoACwAMAA0ADgDCAHQAEQCBAOMAAAFVAMIAcwDCABcAWgAZALcAYwAeAGEAIAAWABYAwgBkAMIA2QDaACgAmABqAGsAFwDZANoAwgATABQAcgAWAHQAdQB2AAEBwgB5ANkA2gDZANoAwgCFADUAJAAXABcAGQAZAEYAeAB5AD0AjQAHAAgAeQBOANkA2gBRABcA4wAZANkA2gCDADsAmQCaAJsAnACdAAAAAQACADsAYgAFAEcAFwDjABkACgALAAwADQAOAFMAVAARABcAFwAZABkAOwDCAMIAtwAXABcAGQAZAB4AwgAgABMAFABkABYAwgDCAIUAKABqAGsAbACKAIsAwgDZANoAcgAkAHQAdQB2ANkA2gB5AMIAwgDCABcAdQAZAMIAFwAXABkAGQCiAMIARgDCAJEAOwAXAJkAGQCbAE4AwgB1AFEA2QDaAMIARwDZANoAmQCaAJsAnACdAMIA2QDaAMIAFwBiABkAQQHCANkA2gDCABMAFADCABYAmQAXAJsAGQDCAGQAwgDZANoAtwDCAGoAawAkAMIA2QDaAO0AwgByAPMAdAB1AHYAhQDCAHkA2QDaAIoAiwDCAMIAwgAiASEBOwDZANoAwgDCANkA2gDCAMIAjADCAMIARwDCAPQAwgDCAKIA2QDaAMIAwgCZAJoAmwCcAJ0A2QDaAMIA2QDaAMIA2QDaAAEB2QDaANkA2gABAWQAwgABAdkA2gABAWoAawDXACsBwgC3AMAAwgByAMIAdAB1AHYAAQACAHkA3QAFANkA2gARAcUACgALAAwADQAOANkA2gARANkA2gDZANoAjADCAPYAwgARAScB9wARAR4A9wAgAA0BDQGZAJoAmwCcAJ0AKAD2ABEBJwHmAOIA2QDaANkA2gDcAAUB3AAaAdwAEwAUAPQAFgD6AI0A+gD2ADwAyQC3AAUBBQEFAckARgArASQAKwHJACYAlwCWAE4AHQEWAFEAKAEoASsA6wASAO4AyQASARAB7gDuAO4AEgA7AMgAlQBiAPcAEgESAesA9wD3APcA6wBHABAByQDIAJ4AJAE+ACMByQDIABYAyQDeAMgA3gDJAMgAcwDbANsAQADbAOQAFgB+AN0AhQClAN4AZADhAIoAiwDhANsAagBrABgA2wDkANsA2wAzAXIAcQB0AHUAdgA7ARwBeQAcAd4AyQBbAKIAQAFAAVIAlAALAZEACwEWABcByQCeABkB+wCTAJIAGQDLAPoA+QD7APgADQD3AMMAwwAGAJkAmgCbAJwAnQDBAMEAMQHBANAAMQEuAdYA1gDWANAA3wDfANYABADXANcA1gADABYA0ACjAA8AFwAQALcAFwCLAJcAggAZABQAjgAYABAAkAABAI4AggCCAD0AJQA1AJcANQA1ADUAggB0AAEAIgCNAAUAFgBzAKEASwAZAEQAjQApAHMARAAYABQAEwCDAH0AQwBDAGAAFgAWABYAJQAXABYAGAAWADsAQwAXAJUAHAAWABkAFwAXABcAFgCNACIAYQAXABcAIgB0ABYAjwAZACIASwAiACIASwBYACIAVgAXABYAIgAZABgAIgAZAF0AFwAsAI4AFwCOABcAFwAWAAsAGQAXABkAFwAWABYAFgABABcAFwAXABYAFgAPAI0AjQAZABkAAQBCAUIBQgGHAEIBQgFCAUIBQgFCAUIBjQBCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFAAoAAfQDoAFYGJQJAAgoFAQVAAkgBQAIUBdQAQAKAAH0A6ABCApwBQgKHAQYGMwAzAAsClQENBRECMwAzANcDMwAzAFEAUQBTBD0APQDYA1MEDAV8AYcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGACkGnAEfAR8BBwAfAR8BpgEaBBoEKAQrBCEBLALsAT0CDAIxAj0C8QExAuIBEgIGAeUAhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAgAB9AOgA4gWEAIQAhACEAIMAgwCCAIIAggCBAH4AwgG0BOcEAQABAEYCAgDrBCMGpAEuBnsBQAGWBJkAlgQwBpwBegEuBh8CPQVKAW8AOgI6AjoCJQEeBIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAYcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAB8BHwG0BLUEtAT/AB8BHwH+AfsB+gGJAMcBPQLUADECvwG+AfkBPQJQBjEChgCGAIYAhgB/AJAB8wCEAIQAhACEAIMAgwCCAIIAggCBAH4AwgEaAdcBWQGEAIQAhACEAIMAgwCCAIIAggCBAH4AwgE+ApsAqAOoA8YB4wAJAtQEnAHUBIYAhgCGAIYAhACEAIQAhACDAIMAggCCAIIAgQB+AMIBggCCAIIAgQB+AMIBhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAgAB9AOgAwgFAApwBjQHhBLQAXABdAIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAX0BgwG0BH8BUQBRAIcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAYMAgwCCAIIAggCBAH4AwgEsArQELgE/ATcCeQA4AuABBAArAn0EeQZcBnkGLQCAAH0A6AC0BLUEtATiBDsCkQSEAIQAhACEAIMAgwCCAIIAggCBAH4AwgGRBB8BHwGRBPsDQAKmAfsDnAHDAUIGRgICAOsEPQIsADECXwBAAW4AmQA1ArQEtQS0BAoCCgI9BVEAUQAHACwAhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAJwF9BHoGEAR6BrQEewQ/ATcCdwB3AFcB0gFLAVcBHwEfAXgALALDAUECwwGRBJEEBAQ/ATcCtgE9AtIAMQI7BasFIgITApEEkQQ+BpEEkQSgAT8BNwLzAIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAQQEBAQGBAcEIwAsALQEtQS0BNgBHwEfATAFnAEbBXQBOwZnAeEAxgG0BMMAMAU9AnsEMQI1BTUFEgFAAqQEQAJUAS4AxAAZAtkAhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAEwATABMAEwCcAUUCtATrBP8BtAQ/ATcCQAGwA5kAqQHrAa4BrwO0BOgBPQWqBRQC/QS0BLUEtASHAIgAWgDMBMwEJwQqBB0EHQSFAIUAhgCGAIYAhgA/AoQAhACEAIQAgwCDAIIAggCCAIEAfgDCAR8BHwEQAh8BHwF0ATsGtAS1BLQEtAS1BLQEPQLmATECPQJ5AzECnAG0BLUEtAR2AygAFgAWANwA8wANAqkFhACEAIQAhACDAIMAggCCAIIAgQB+AMIBhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAnAG0AMYBtARvA/8AHwEfAf4B+wH6AXQBOwYgBjMFMwVAAnkD+QE9AiwAMQIvArcEhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAUQBRAKYBQAJ5AYQAhACEAIQAgwCDAIIAggCCAIEAfgDCASkBHwEfAcwBtAS1BLQEtAQWAhMAEwDAAcABwAE9ApwBMQLmALQBowQXAj8BNwJrAbABtwSbBYQAhACEAIQAgwCDAIIAggCCAIEAfgDCAYcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAJwB0wC1A5EEEQRWBFYE7gEjAiMCtAS1BLQEBwAbAiIGkQR4AUACkQQFALQE5gEDAIcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAEACAQITABMAqwGEAIQAhACEAIMAgwCCAIIAggCBAH4AwgExAbQEsQHhALQEgQETABMAEQEiAXMBBAJuAQMCBAGcARoCIAYlAgAEagG1AbQEtQS0BIYDEAaEAIQAhACEAIMAgwCCAIIAggCBAH4AwgGHAIgAWgDMBMwEJwQqBB0EHQSFAIUAhgCGAIYAhgCcAZsFAgIBBbQEtQS0BLQEtQS0BIcDMABWASAGIAb/BFsGIAaPA0ACgQB+AMIBbgCHAIgAWgDMBMwEJwQqBB0EHQSFAIUAhgCGAIYAhgAJAUACywETABMAhACEAIQAhACDAIMAggCCAIIAgQB+AMIBQQXMAEACywHKATIALwATABMAMQCyAVEEPQLxATECnAGsAWwAyAQhBhIGeAHNACYCJgJRAFEAhACEAIQAhACDAIMAggCCAIIAgQB+AMIBhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYA4AFAArQEQAIFBpwBmwXJAzsBewaOARwB8QHJA30DIQYhBngBeAEhBs0BeAHIBMsBUABQAFEAUQDxAXYBcgBaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAbQE4QVAArQEtQS0BFYFPAHmARkBGQHxAa8BLQIgASABkgE8BdcBWQEqAa0BPQJAAjECUQBRAD0CdgExAssDggGEAIQAhACEAIMAgwCCAIIAggCBAH4AwgHnAHUAUQBRAB8BHwHnAB8BHwFAAucFQAI4BbQEtQS0BIsAPQIsAjECPQKcATECuQHIAckD1QAuAucF6QUOBskDjwCPAJEAkQBYBToB3gG8AcoDnAFSA1MDVAOHAIgAWgDMBMwEJwQqBB0EHQSFAIUAhgCGAIYAhgBlAZwBjQF8BDABhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAJwZDAQYAXgMHAIcAfABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAJkBmAHnBdQAhACEAIQAhACDAIMAggCCAIIAgQB+AMIBmwF2ALQEdAAKAGABCQFjAYQAhACEAIQAgwCDAIIAggCCAIEAfgDCAUACRAEyAUACMgHiBNUBngCEAIQAhACEAIMAgwCCAIIAggCBAH4AwgHPAMgEZgRBAEEA1gFCAEIAnAG/Ab4BcgMTAk8BAgEBAQABZwTRBLQEtQS0BEcB0wRqA58AQAIQAOABPQQQBNIEaASIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYABQRAAlEAUQAEBBAEmgNAAs8B1ARAAtQEyAT2AWsAmwWbAwYAQAKaAdoFcgMFBOABFQAVAAQETAFkBU4BNQA1APEBUQBRAGoDBAQEBAYEvQEDARMAEwAVAoQAhACEAIQAgwCDAIIAggCCAIEAfgDCAScCLQEEBAQEBgRrABQCIQJ5ADgCpAQEAGYEKAbBAUACzgEHAAIFogHOAV4BmwVAAgYCOwIgAmcEeQA4AroBBACkBNABFQKcBMcECQBDAEMA5wFAAmgELwGaATsCNgA2AMMBQAJ7ALADQAKhAUACTQGvA2MFQALsADUCQAImBjQCRABEAAcAQALDAWoBowG2AEUARQAdAkYARgBHAEcAHAI1AkgASADkATcANwDZAZwEKAEQBDgAOAAoAe0BHQJ3AHcAmgElBh4COQKiAQcAeADcBMMBQQLDAdEBEAQEBEACFQYoAtwBdwB3AA8CAwF5ADgC8AAEAHgAQALDAUECwwFAAt0BBARAApwAQAI5ADkAOwJAAh4B5QCaAVABBAQEBAYEBwQjADsAOwDbANcDPAA8ANwASQBJAEoASgDYA8MBSwBLAAQEBAQGBAcEIwBgANgAIwEoAjUCpAQ+AYsBiwGKARQBiAFAAuUBWwPaAR8FmgEdAkACoQH6BXgEHAKPAaQEJAHtAIEERgEmABcAQAIQBEACFAAUAEUBKwF3AHcApABMAEwA+QV5ADgCeAAEAMMBQQLDAcsAQAIEBI0AjQCOAI4AQAJCAScAOwJVAf0DbgAIAe8AhQOEA6cB8gCMA40DcgGtAE0ATQArAN8BHgUIAT4APgBxAcMBBAQEBAYEBwQjAEEGqATFAUQE7gAjATUCowAdBW4AiwGLAYoBFAGIAdoD2wNbA+EBWgEIAW4ACATpAUACpAT3AUAEBQEFAe0AQAJGAXkAOAIQBAQAWwFgBZ0BRQF3AHcAtAM/ATcCXwFOAE4AeAA7AsMBQQLDAU8ATwAEBGIBZAFAAmgBRARuAEACzgOuAwgBewDJAWYB7wBAAgcCwwGrA1AEewBQBK0AQAIIBCsAPwA/ACwFNQKoAKgABAQEBAYEBwQjAEACqQCpABwFaAPuAJ0ANQZAAlYAVgBtAVkAOAJ3AQQATwStA08EewBAAhAEbQVAAEAApASaBXcAdwA7AkACUgBSADMCQAJ4AKUAwwFBAsMBnQFSBQQEkACQAD8BNwJAAl4FMgLyARcBwwFTAFMAnwVAAqYApgBAAgkFKgJAAgAFNQJAAgwAQAL0BMkBkgCSAPMEQAIEBAQEBgQHBCMAjACMAPUEpwCnAEkGoACgAE8FlgCWAJUAlQA3ARAEQAI4AZMAkwA5AXcAdwDeAOsAQAKkBIwBQAJ4AEACwwFBAsMBqATFAQQE/AEjAZQAlACNBUwGiwGLAYoBFAGIAVUAVQBbA1cAVwBUAFQAKQJAAiYBQAKSBVIBUwGRBe0ALAFGAYgFgQUEBAQEBgQHBCMARQFYAZMB4wHiABsFNAA0ADoAOgBwAVsF3gU2At0FeQA4At0ABADQAAwB0QCGAdwEDQakBFwFWgVZBQsG7wC4ADsC6QClAdkEXwDaAK0A4wXBACsAWwBeALIAugDTAbwA1AGOBQ0AvQC+AL8A9QHDAfUAbADuAJEBlAWTBZYF2wGUAdgFxQA1Ag4A6gH5AGUA7gXwAV0BGAH7AMkAYQHzAfwAlgH2BP0ABQIvBS4FswEtBSYFZwB9AxAFnQHjAJcBEARaBj8BNwJZBhEFdwB3ALcBbwElBQ8FWAYOAngAuAHDAUECwwE6BjUBBAQ2AXUBCgELAckBLAYrBrsBigByBSgCcQULAMsFgAFzAD0BRgVtABgCKgBDAn4B1gBFBYQBrgSFARMBFQEWAQQEBAQGBAcEIwBEAvEEngHsBKoAnwG3AP4F/wX9BasAmgAzAfwFTgPfAOAAWADEAdcArABBAeoATgSYAKQETARJAbkArgDHBJ0DuwDxAFEB9ABcBMAArwCwAKgBqgFhAMIAYgBjAGQAsQBfBFsE9gD3AKEAGAD4AFwB1gQIAVQE+gDvAccAxgAPAF0D9AFxAf4A+AH9AQACyABmABkAswBpARoAbAFoAHsDNAGiAGkAiAMIAmoAoQQtBIMEEQDkABsAggQbAR0BBwHSA8oAzAN7ABwAlwQdAB4AmwSTBB8AlQSIBCkAIADOACQCIQBuAJoEOwQIAHAALgRxACwEMAQiADEEMAJlBA0BZAQOASQAEgCqBAkEaQOXAHoAJQCJAQ8BEAE8ArUAqQToBOgE6ASnA+gE6AToBOgE6AToBOgEUQYAAAAAfwZ/Bn8G0wXmBFcF5gTmBOYE5gTTBdMF0wXmBOYE5gTmBOYE5gR1BXUFCAYHBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBNIF5gTmBOYE5gQqBioG5gTmBOYE5gTmBBsGGgbmBOYE5gR+BeYEhQXmBOYE5gTmBOYE1AXVBeYE5gTmBAcGCQbkBYwFiwWKBYkF9gVpBYMFfAWABc8F0AXOBWkG1QXUBeYEfwWvBb8FrgXmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBLcFvgW9BbwFxQW7BbgFsQWwBbIFswX+BOYE+wQxBeYE5gTmBOYE5gS0BQcFqAWnBaYF5gTCBbUFwQXABQ8GTwZOBuUF5gTmBOYE5gTmBOYEKgbmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBGsFKgYqBuYEBwUqBioGbAVsBQMFAwVvBRYGTgVOBU4FTgVXBU4F5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYEDAYKBuYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBFMF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBEgG5gTxBT8FUwVTBVMFUwVVBUAFPgVNBQgF7QR3Bo8FhAVUBYQFdAaCBY8FjwWCBY8FVAV0BhgFXgYTBXUFdQV1BWsFawVrBWsFbwVvBdEFVAVNBeYEdwZ3Bl0FXQV2BnYGXQXlBWYGmAU0BToFOgU6BToFXQX4BIIFZgZmBoIFmAU0BYIFNAWCBV0F+AT1BXEGXQX4BNsFXQX4BF0F+ATbBTIFMgUyBScF5gTmBNsFMgUYBTIFJwUyBTIFPAbmBN8F3wXbBV0FNAY0BngFeAV9BW8F1gVdBeYEfQV7BXkFggUqBUsGSwZHBkcGRwZ8BnwGFgZXBgcFBwUHBQcFVwYaBRoFCAUIBQcFVwbmBOYE5gTmBOYE5gRSBuYEEQbmBWEF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gQcBuYE5gTmBOYE5gTmBOYE5gTmBOYE5gSdBeYE6QQTBuYE5gTmBOYE5gTmBOYE5gSGBYcFYgXmBOYE5gTmBOYE5gTmBJUF5gTmBOYEkAXmBOYE5gTmBOYE5gTmBOYEcwbmBOYE5gTmBOYE5gT0BfMF5gTmBF8F5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gQWBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gR6BeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gQ5BnAF5gTmBOYE5gRqBuYE5gTmBOYESAXmBOYE5gTmBOYE5gTmBOYE5gTmBOYEYgZCBZ4F5gShBfwE5gTyBOYE5gQAAAkAQZC7BAuyBr4AvgC9AL8AwADAAMAAwAC/AL8AvwC/AL8AxADGAMgAyADHAMcAxQDFAMwAzADOAM4AzwDRANEA0QDSANYA1wDYANgA2ADYANgA2ADYANgA2ADYANgA2ADYAOEA4QDdAN0A3wDfAOIA4gDiAOIA4wDjAOMA4wDjAOAA4ADkAOQA5ADLAOYA5wDnAOcA5wDnAOoA2wDbAOsA6wDsAOwAvwDuAO4AvwC/AL8AzQDNAM0A8ADzAPMA8wDxAPEA/QDxAP8A/wD0APQA9AAAAfUA9QD1AAEBAQH2APYAAwEDAQIBAgECAQIBAgHJAMkA7wDvAAgBCAEIAQgBBAEEAQQBBAEFAQUBBQEKAQYBBgH6APoA6ADoANwA3ADcAAsBCwELAfgA+AD5APkA+wD7APsA+wC/APcA9wANAQ0BDQENAb8ADgEOAQ4BDgG/AL8AEQERAREBEQERAREBEgEPAQ8BEAEQAQkBCQHaANoA2gDaANkA2QDZANoA2gDaANoA2gDaANoA2gDaANkA2gDaANoA2gDaANoA2gDaANoAFAHaANoA2gDaANoA2gDaANoA2gDaANoA2gAVARUB2gAWARYB2gDaANoA2gDaANoAGQEZARoBGgEYAQcB/gD+ABcBFwG/ABsBGwHeAN4A6QDpABwBHAG/AL8AvwAdAR0BvwC/AL8AvwC/ANQA1QC/AB8B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ACkASQAlACkCKQFlBF4AJQBpAGUAHgOFAF4AOQB+AF4AJQBpBgUGXgQ6AKwASwD+Bt4BJQAeC8kEJgDVAOUENQAxADcArAUxACwANQBMADUATAA1ACwAZwNnAFUAogB5AFUANwBVAFoAbAE1AFUABwQmAEcBrAJNAZUARwAsAGcMNQAnAOwAIgA6AMwARgBMADoAjABHAE0BZwBaACcA1QEiACcALADHA2wDJwtsAScATQEnBCwBRgA6AHUAJgDHAowAJgAsASYAbAAmAKwA9QEnA2wANQAnAGcBbANsACoAxwYsACoALAAnAGoADAGKACwASgAnAOwARwFMAFUATQE1ACYAxwDnACwASgAHAUcAxwLnACcAhwAsACcAagCMAEoASgAsACcAKgBHAGcATABNAUcAVwDPADoANwBMACoAxwBHAMcC5wBHAEcARwAsAGoATABMAGwALACHACcATQFMAGcALABMACoAJwFnAMcC5wBHAKcALAAnAGoArABMACoASgAsACcARwBMAE0BNQA3ACwASgAHAUcAxwLnAEcApwAsACcAKgAsACoAjABKAEoALAAsACoARwBnAEwATQE6ACcAzwAsACcAxwBnAIcARwAnAEcARwBnAIcBSgAsAEoAagBqACwAJwAqAE0BbwDaADcAOgBqAAcBZwDnAkcBpwAnAGwAigBsAIwATABHAEcATABNAe8AOgBKAAcBZwDnAkcBpwAsACcAKgAsAKoALABKAEoATABKACcARwBMAE0BRwBKAAcBZwAnBScAagCMAGoAagAsACcAKgBHAEwATQHPADoAxwBKAEcCBwMnAScA5wAsAGoAbAAsAAoBSgA1AAcGLABHAOwANwDHACYADAE1AE0BVQBHACcARwAnACcAhwDnAGcAJwAnAEcAhwAsAEcAzABMACcApwAmAMwATQGHACcAegD1AToANQB6AEwA2gBNAU8BOgAsADoALAA6ACwANgAyADYAMgBKAAcBhwTMASoArAA1AEwApwBsAYwEGgEsANoAWgC1AJoAVQBnBUoAjAAqAMwAKgBMAEoATAAnAE0B1QDHAEoATACHAGwAJwBqAEcA6gBnAIwApwEsAEoATADKACwAJwAqAE0BagAsAFoAyQQpACkAZwU1ACYAhymHAOcAJwCHACcFhwAnBIcA5wAnAIcA5wEnB4cAZwhsADUBjwIHAloBpwoxAIdNVQAnAj0ARwM2ADIAZwl1AG4ApwGHAGwARwJsAFUARwJMAKcBZwBMAIcGTAAqAOwACgEsAEoAbAF1ACYAdQA3ACcALABNAU8B1QAxAJUAbAA9AE0BZwQmAIcGJwUsACcAxwinA2wAigBMAGoASgAsAMoAbAA6AFUATQHHA6cAhwUqAucASgBNAS8AWgTnAkwAagBVAKcGKgAsACoA7AAsACoALABKAAwBygBMASwATQFNAfUAJgDVAIwAKgDnBSwAKgCsACoALACqACwASgDnAE0B9QBaASwBOgFMACoAxwMqAIwASgBMACoALABKAEcATQGHBSwAKgBMAGoALAAqAGwASgCVAIcECgEMAUoATAC1AE0BZwBNAccDxgBVABUBbAA1AKwBKgDsAIcALACHAEoALABHAIUF5gelASYARQSmBOwEjADeEgUBXgwFAQkBxQDJAAUBCQEFAQkBxQDJAAUBKQApACkAXgDlAAkBxQEFAQgBBQEIAQUBCAGlAEUAiQAoADgAJQB4AGUARQCJACgAeACFAEUAiQB4AAUBqQB4AGUARQCJACgAWAB9AaIA0QBVADQAMwA2AFQAMwA2ADQAFQE7ADwAogA9ADUBNAAzAJUAUAB1ADkANgAyAHUBOQA1ADAAVQE9AKIAwgAvACYAzwB5ADYAMgAmAE8BeQA2ADIApgFXA6wBiwAsAGsAjAFaACkAmgApAFoAJQBpAEUAaQAlADoAKQBaADkAqQDaACkAOgApADoAKQA6AIkAOgAlAIkAJQCHACUAWgBFAEkAuQBeAGUAOgA5AFoAJQA6AA8CbgReAI4ALwC5ALoAWQCaADkAWgA5AFoAOQD6ADkA+gNZAFoAOQA6ADkA+gOZIRoBmQCaAlkA+gA2ADIAOgo5ANoDOQMaBdkAWgL6BHoBjwfaCc8C+hY5ADoBOQDaBhkB+g05ABoS+gw2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIAzwOaBbkANgAyAPkDNgAyADYAMgA2ADIANgAyADYAMgAZAhogeRA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyAPkHNgAyADYAMgAZBDYAMgBZIBoGuQJaANkAWgHpBeUFfgBJAEUA/gBpACUAXgAlAF4ApQBGAGkAJQBeDCUA2gCeAGwAXgCVAC8AVQDFBCUAJQAHByYANQAsAOcC5wDnAOcA5wDnAOcA5wDnAAwEVQA0ADMANAAzAHUANAAzADUANAAzADUBMQBVADEANQA0ADMAVQA0ADMANgAyADYAMgA2ADIANgAyALUAJgBVAVEAWgM6C9oamgE9AHUAOgAmACcALgA2ADIANgAyADYAMgA2ADIANgAyAFoANgAyADYAMgA2ADIANgAyADEANgBSADoALgGMAEoAMQCmAFoAbgAmACcANQBaAMcKTABYAEYAJwAxAEcLNQBmACcAJwXHC1oAjwBaAWcDmgQHAvoDTwHaAw8BOgDvARoETwH6BO8B+gcaICcAJwAaCCcAJwCnAiYA5476BgcFxgBVAIchJgB1AAcCTQFHAN4FJwAsAGsANQBMATUAJgAeAywAxwhOAUwA1QD4AiYBWADeAUUA3gcmAAUBvgBeASYAWACeAJ4AfgFGACUA5wAsAGcALACHACwA5wJKAEwAKgCaAM8AWgA3ADoAhwaVAEoARwYKAiwAVQBNAUwCxwB1ACcATQGHAwwBVQDnAmwBSgA1AKcDbAAqAOcFLABKAIwASgAsAIoAtQEmAE0BVQAnBcwASgBMAEoATABnACwABwEsACoATQGVAAcCJgDHAHoAJwAqAAcGLAAnAGwARwBMAKcATAAnACwAJwBHACYAVQBnASoATABKAFUAJwBGACoALADHAMcAxwDnAOcAZwRKACwASgAsAEoANQAqACwATQEnACcA5wInBiQARABEACQAPwA/AMctRw3lAKUAJwAsAEcBOQCnAacAJwBHAEcAhw0YAmctNgAyAAcIxwaHATcAOgAMAvUANgAyADUA7AA1AFEAUAA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyAFUANgAyAJUAcAB1AJUAMQA2ADIANgAyADYAMgB1ADkAMQB5ADUANwBVAKcA5xAiAHUANwB1ADYAMgA1ADkANQAxAFUATQFVAHkAVQBJAzYANQAyADgAMAA4AEUDNgA5ADIAOQA2ADIANQA2ADIAVQBHASYApwVGAOcDxwDHAMcAZwBXADkAOAA6AFcAOgCZAFoAYgBaAIcBRwNnAkcA5wHHAWcPdQCvBToBrgaPADoCLwCaAboFLACnAycG5wOPACcCLgAHAS4AxwM1AIcEBwE1AK4ACQUFBccJTQHHACcAhwVHACcA5wI1AA8BxwLPADUARwM1AAcHRwAnAGwATACMAIcAZwBnA2wALAAPATUBpwNPADUAxwb1AMcCDwFnAg8BJwnvAyoALAAqAKcG7AH1AI8CTQFMACoApwVqAIwASgBMAFUAIgCVACcDTQFsAIcErAAqAAwBTQGVAEwAKgAHBmoALAFKAIcAlQBNAWcFLAAqACwASgDMACoALABNAedtbgyVAOeFJ0enCCcAygWMAKYBRwDaHvoEmgdKAGwAegDKAAIBDAFaAOwA2gOMABoGWghsADoA+gpPAkkDRQNJA+UARQJJA0UDKQBJACkASQCJAAkBhQAlAOUAZQFJA0UDSQCJAAkB6QBFA0kAiQCpACkA6QBFA0kDRQNJA0UDSQNFA0kDRQNJA0UDSQOFAykDOQAlAzkAxQApAzkAJQM5AMUAKQM5ACUDOQDFACkDOQAlAzkAxQApAzkAJQM5AMUAXgBNBocAZwNHACcAJwBHAYcAJwAnACcAJwAnACcAZwBHACcAJwAnACcAJwAnAEcAJwCHAOcAhwCHACcARwEnAmcApwAnAlkAmgWaDPoB2gH6AfoBbwH6A5oHegW6A3oFOgFaADoE2gDaCJoCugS6ADoC+gc6ANoWmgDaB5oAGgPaCHoB2giaDicAJwAnACcAJwAnAMdDIgACDAwePwA/AEGChgULIL8F2QbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbjBuUGAEGyhgUL/CQgACEAJAAlACgAKQAqACsALAAtAC4AMAA6ADwAPwBBAFsAXABdAF4AXwBgAGEAewB8AH0AfgB/AKAAoQCiAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAtAC1ALYAuAC5ALoAuwC8AL8AwADXANgA3wD3APgAAAE4ATkBSQFKAXkBfwGBAYMBhAGHAYoBjAGOAZIBkwGVAZYBmQGcAZ4BnwGhAaIBpwGrAawBrwGyAbQBtQG4AboBuwG8Ab4BwAHEAcUBxgHHAcgByQHKAcsBzAHNAd0B3gHwAfEB8gHzAfQB9wH5AfoBNAI6AjwCPQI/AkECRAJHAkgCUAKUApUCsALCAsYC0gLgAuUC7ALtAu4C7wIAA3ADdAN1A3YDegN7A34DhAOGA4cDiAOMA44DkAORA6MDrAPPA9ED0gPVA9gD8AP0A/YD9wP6A/wD/QMwBGAEggSDBIgEigTBBM8E0AQxBVkFWgVhBYkFigWPBZEFvgW/BcAFwQXDBcQFxgXHBdAF8AXzBQAGBgYJBgsGDAYOBhAGGwYeBiAGQAZBBksGYAZqBm4GcAZxBtQG1QbWBt0G3gbfBuUG5wbpBuoG7gbwBvoG/Qb/BgAHDwcQBxEHEgcwB00HpgexB8AHygfrB/QH9gf3B/oHAAgWCBoIGwgkCCUIKAgpCDAIQAhZCF4IoAiiCOQIAAkDCQQJOgk7CTwJPQk+CUEJSQlNCU4JUAlRCVgJYglkCWYJcAlxCXIJeQmBCYIJhQmPCZMJqgmyCbYJvAm9Cb4JwQnHCcsJzQnOCdcJ3AnfCeIJ5gnwCfIJ9An6CfsJAQoDCgUKDwoTCioKMgo1CjgKPAo+CkEKRwpLClEKWQpeCmYKcApyCnUKgQqDCoUKjwqTCqoKsgq1CrwKvQq+CsEKxwrJCssKzQrQCuAK4grmCvAK8QoBCwILBQsPCxMLKgsyCzULPAs9Cz4LPwtAC0ELRwtLC00LVgtXC1wLXwtiC2YLcAtxC3ILgguDC4ULjguSC5kLnAueC6MLqAuuC74LwAvBC8YLygvNC9AL1wvmC/AL8wv5C/oLAQwFDA4MEgwqDDUMPQw+DEEMRgxKDFUMWAxgDGIMZgx4DH8MggyFDI4MkgyqDLUMvAy9DL4MvwzADMYMxwzKDMwM1QzeDOAM4gzmDPEMAg0FDQ4NEg09DT4NQQ1GDUoNTQ1ODVcNYA1iDWYNcA15DXoNgg2FDZoNsw29DcANyg3PDdIN1g3YDfIN9A0BDjEOMg40Dj8OQA5GDkcOTw5QDloOgQ6EDocOig6NDpQOmQ6hDqUOpw6qDq0OsQ6yDrQOuw69DsAOxg7IDtAO3A4ADwEPBA8TDxQPFQ8YDxoPIA8qDzQPNQ82DzcPOA85DzoPOw88Dz0PPg9AD0kPcQ9/D4APhQ+GD4gPjQ+ZD74Pxg/HD84P0A/VD9kPABArEC0QMRAyEDgQORA7ED0QPxBAEEoQUBBWEFgQWhBeEGEQYhBlEGcQbhBxEHUQghCDEIUQhxCNEI4QjxCQEJoQnRCeEKAQxxDNENAQ+xD8EP0QShJQElgSWhJgEooSkBKyErgSwBLCEsgS2BISExgTXRNgE2kTgBOQE6ATABQBFG0WbxaAFoEWmxacFqAW6xbuFgAXDhcSFyAXMhc1F0AXUhdgF24XcheAF7QXthe3F74XxhfHF8kX1BfXF9gX2xfcF90X4BfwFwAYBhgHGAsYDhgQGCAYQxhEGIAYqRiqGLAYABkgGSMZJxkpGTAZMhkzGTkZQBlEGUYZUBlwGYAZsBnBGcgZ0BnaGd4ZABoXGhkaHhogGlUaVhpXGlgaYBphGmIaYxplGm0acxp/GoAakBqgGqcaqBoAGwQbBRs0GzUbNhs7GzwbPRtCG0MbRRtQG1obYRtrG3QbgBuCG4MboRuiG6YbqBuqG6sbrBuuG7AbuhvmG+cb6BvqG+0b7hvvG/Ib/BsAHCQcLBw0HDYcOxxAHE0cUBxaHHgcfhzAHNAc0xzUHOEc4hzpHO0c7hzyHPQc9RwAHSwdax14HXkdmx3AHfwdAB6WHp4eAB8IHxAfGB8gHygfMB84H0AfSB9QH1kfWx9dH18fYR9oH3AfgB+IH5AfmB+gH6gfsB+2H7gfvB+9H74fvx/CH8YfyB/MH80f0B/WH9gf3R/gH+gf7R/yH/Yf+B/8H/0fACALIBAgFiAYIBkgGiAbIB0gHiAfICAgKCApICogLyAwIDkgOiA7ID8gQSBEIEUgRiBHIFIgUyBUIFUgXyBgIGogcCBxIHQgeiB9IH4gfyCAIIogjSCOIJAgoCDQIN0g4SDiIOUgACECIQMhByEIIQohCyEOIRAhEyEUIRUhFiEYIRkhHiEkISUhJiEnISghKSEqIS4hLyEwITQhNSE5ITohPCE+IUAhRSFHIUohSyFMIU4hTyFQIWAhgyGFIYkhkCGVIZohnCGgIaEhoyGkIaYhpyGuIa8hziHQIdIh0yHUIdUh9CEAIwgjDCMgIyIjKSMqIysjfCN9I5sjtCPcI+IjACRAJGAknCTqJAAltyW4JcElwiX4JQAmbyZwJgEnaCdpJ2onaydsJ20nbidvJ3AncSdyJ3MndCd1J3YnlCfAJ8UnxifHJ+Yn5yfoJ+kn6ifrJ+wn7SfuJ+8n8CcAKAApgymEKYUphimHKYgpiSmKKYspjCmNKY4pjymQKZEpkimTKZQplSmWKZcpmCmZKdgp2SnaKdsp3Cn8Kf0p/ikAKzArRStHK1ArACwwLGAsYyxlLGcsbixxLHIsdCx1LHcsfCx+LIEsgizkLOUs6yzvLPIs+Sz9LP4sAC0nLS0tMC1v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/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/AAEXAh0YEwMeGxkLFAgEDR8WHBIaCgcMFREJBhAFDw5ObyBlcnJvciBpbmZvcm1hdGlvbgBJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhh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";
var wasmBinary = base64ToArrayBuffer(sqliteWasmBase64);

// ../../../lix/packages/sqlite-wasm-kysely/dist/kysely/ConnectionMutex.js
var _ConnectionMutex_promise;
var _ConnectionMutex_resolve;
_ConnectionMutex_promise = /* @__PURE__ */ new WeakMap(), _ConnectionMutex_resolve = /* @__PURE__ */ new WeakMap();

// ../../../lix/packages/sqlite-wasm-kysely/dist/kysely/SqliteWasmConnection.js
var _SqliteWasmConnection_db;
_SqliteWasmConnection_db = /* @__PURE__ */ new WeakMap();

// ../../../lix/packages/sqlite-wasm-kysely/dist/kysely/SqliteWasmDriver.js
var _SqliteWasmDriver_config;
var _SqliteWasmDriver_connectionMutex;
var _SqliteWasmDriver_db;
var _SqliteWasmDriver_connection;
_SqliteWasmDriver_config = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_connectionMutex = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_db = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_connection = /* @__PURE__ */ new WeakMap();

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s2) => s2.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i3 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i3 < glob.length) {
      const c4 = glob.charAt(i3);
      if ((c4 === "!" || c4 === "^") && i3 === pos + 1) {
        negate = true;
        i3++;
        continue;
      }
      if (c4 === "]" && sawStart && !escaping) {
        endPos = i3 + 1;
        break;
      }
      sawStart = true;
      if (c4 === "\\") {
        if (!escaping) {
          escaping = true;
          i3++;
          continue;
        }
      }
      if (c4 === "[" && !escaping) {
        for (const [cls, [unip, u2, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i3)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i3 += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u2;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c4 > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c4));
        } else if (c4 === rangeStart) {
          ranges.push(braceEscape(c4));
        }
        rangeStart = "";
        i3++;
        continue;
      }
      if (glob.startsWith("-]", i3 + 1)) {
        ranges.push(braceEscape(c4 + "-"));
        i3 += 2;
        continue;
      }
      if (glob.startsWith("-", i3 + 1)) {
        rangeStart = c4;
        i3 += 2;
        continue;
      }
      ranges.push(braceEscape(c4));
      i3++;
    }
  if (endPos < i3) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r5 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r5), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/unescape.js
var unescape = (s2, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s2.replace(/\[([^\/\\])\]/g, "$1") : s2.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c4) => types.has(c4);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p2 of this.#parts) {
      if (typeof p2 === "string")
        continue;
      if (p2.type || p2.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p2) => String(p2)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p2) => String(p2)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n5;
    while (n5 = this.#negs.pop()) {
      if (n5.type !== "!")
        continue;
      let p2 = n5;
      let pp = p2.#parent;
      while (pp) {
        for (let i3 = p2.#parentIndex + 1; !pp.type && i3 < pp.#parts.length; i3++) {
          for (const part of n5.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i3]);
          }
        }
        p2 = pp;
        pp = p2.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p2 of parts) {
      if (p2 === "")
        continue;
      if (typeof p2 !== "string" && !(p2 instanceof _AST && p2.#parent === this)) {
        throw new Error("invalid part: " + p2);
      }
      this.#parts.push(p2);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p2) => typeof p2 === "string" ? p2 : p2.toJSON()) : [this.type, ...this.#parts.map((p2) => p2.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p2 = this.#parent;
    for (let i3 = 0; i3 < this.#parentIndex; i3++) {
      const pp = p2.#parts[i3];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c4 = new _AST(this.type, parent);
    for (const p2 of this.#parts) {
      c4.copyIn(p2);
    }
    return c4;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i4 = pos;
      let acc2 = "";
      while (i4 < str.length) {
        const c4 = str.charAt(i4++);
        if (escaping || c4 === "\\") {
          escaping = !escaping;
          acc2 += c4;
          continue;
        }
        if (inBrace) {
          if (i4 === braceStart + 1) {
            if (c4 === "^" || c4 === "!") {
              braceNeg = true;
            }
          } else if (c4 === "]" && !(i4 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c4;
          continue;
        } else if (c4 === "[") {
          inBrace = true;
          braceStart = i4;
          braceNeg = false;
          acc2 += c4;
          continue;
        }
        if (!opt.noext && isExtglobType(c4) && str.charAt(i4) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c4, ast);
          i4 = _AST.#parseAST(str, ext2, i4, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c4;
      }
      ast.push(acc2);
      return i4;
    }
    let i3 = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i3 < str.length) {
      const c4 = str.charAt(i3++);
      if (escaping || c4 === "\\") {
        escaping = !escaping;
        acc += c4;
        continue;
      }
      if (inBrace) {
        if (i3 === braceStart + 1) {
          if (c4 === "^" || c4 === "!") {
            braceNeg = true;
          }
        } else if (c4 === "]" && !(i3 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c4;
        continue;
      } else if (c4 === "[") {
        inBrace = true;
        braceStart = i3;
        braceNeg = false;
        acc += c4;
        continue;
      }
      if (isExtglobType(c4) && str.charAt(i3) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c4, part);
        part.push(ext2);
        i3 = _AST.#parseAST(str, ext2, i3, opt);
        continue;
      }
      if (c4 === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c4 === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i3;
      }
      acc += c4;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i3;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p2) => {
        const [re, _2, hasMagic, uflag] = typeof p2 === "string" ? _AST.#parseGlob(p2, this.#hasMagic, noEmpty) : p2.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s2 = this.toString();
      this.#parts = [s2];
      this.type = null;
      this.#hasMagic = void 0;
      return [s2, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p2) => {
      if (typeof p2 === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _2, _hasMagic, uflag] = p2.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p2) => !(this.isStart() && this.isEnd()) || !!p2).join("|");
  }
  static #parseGlob(glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i3 = 0; i3 < glob.length; i3++) {
      const c4 = glob.charAt(i3);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c4) ? "\\" : "") + c4;
        continue;
      }
      if (c4 === "\\") {
        if (i3 === glob.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c4 === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob, i3);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i3 += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c4 === "*") {
        if (noEmpty && glob === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic = true;
        continue;
      }
      if (c4 === "?") {
        re += qmark;
        hasMagic = true;
        continue;
      }
      re += regExpEscape(c4);
    }
    return [re, unescape(glob), !!hasMagic, uflag];
  }
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/escape.js
var escape = (s2, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s2.replace(/[?*()[\]]/g, "[$&]") : s2.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/index.js
var minimatch = (p2, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p2);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f4) => !f4.startsWith(".") && f4.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f4) => f4.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f4) => !f4.startsWith(".") && f4.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f4) => f4.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f4) => !f4.startsWith(".") && f4.includes(".");
var starDotStarTestDot = (f4) => f4 !== "." && f4 !== ".." && f4.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f4) => f4 !== "." && f4 !== ".." && f4.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f4) => f4.length !== 0 && !f4.startsWith(".");
var starTestDot = (f4) => f4.length !== 0 && f4 !== "." && f4 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f4) => noext(f4) && f4.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f4) => noext(f4) && f4.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f4) => noext(f4) && f4.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f4) => noext(f4) && f4.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f4) => f4.length === len && !f4.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f4) => f4.length === len && f4 !== "." && f4 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p2) => minimatch(p2, pattern, options);
minimatch.filter = filter;
var ext = (a2, b2 = {}) => Object.assign({}, a2, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m3 = (p2, pattern, options = {}) => orig(p2, pattern, ext(def, options));
  return Object.assign(m3, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s2, options = {}) => orig.unescape(s2, ext(def, options)),
    escape: (s2, options = {}) => orig.escape(s2, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f4) => mm.match(f4));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._2) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s2) => this.slashSplit(s2));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s2, _2, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s2[0] === "" && s2[1] === "" && (s2[2] === "?" || !globMagic.test(s2[2])) && !globMagic.test(s2[3]);
        const isDrive = /^[a-z]:/i.test(s2[0]);
        if (isUNC) {
          return [...s2.slice(0, 4), ...s2.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s2[0], ...s2.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s2.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s2) => s2.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i3 = 0; i3 < this.set.length; i3++) {
        const p2 = this.set[i3];
        if (p2[0] === "" && p2[1] === "" && this.globParts[i3][2] === "?" && typeof p2[3] === "string" && /^[a-z]:$/i.test(p2[3])) {
          p2[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i3 = 0; i3 < globParts.length; i3++) {
        for (let j2 = 0; j2 < globParts[i3].length; j2++) {
          if (globParts[i3][j2] === "**") {
            globParts[i3][j2] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i3 = gs;
        while (parts[i3 + 1] === "**") {
          i3++;
        }
        if (i3 !== gs) {
          parts.splice(gs, i3 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i3 = 1; i3 < parts.length - 1; i3++) {
          const p2 = parts[i3];
          if (i3 === 1 && p2 === "" && parts[0] === "")
            continue;
          if (p2 === "." || p2 === "") {
            didSomething = true;
            parts.splice(i3, 1);
            i3--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p2 = parts[dd - 1];
        if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p2 = parts[gs + 2];
          const p22 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p2 || p2 === "." || p2 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i3 = 1; i3 < parts.length - 1; i3++) {
            const p2 = parts[i3];
            if (i3 === 1 && p2 === "" && parts[0] === "")
              continue;
            if (p2 === "." || p2 === "") {
              didSomething = true;
              parts.splice(i3, 1);
              i3--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p2 = parts[dd - 1];
          if (p2 && p2 !== "." && p2 !== ".." && p2 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i3 = 0; i3 < globParts.length - 1; i3++) {
      for (let j2 = i3 + 1; j2 < globParts.length; j2++) {
        const matched = this.partsMatch(globParts[i3], globParts[j2], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i3] = [];
          globParts[j2] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a2, b2, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a2.length && bi < b2.length) {
      if (a2[ai] === b2[bi]) {
        result.push(which === "b" ? b2[bi] : a2[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a2[ai] === "**" && b2[bi] === a2[ai + 1]) {
        result.push(a2[ai]);
        ai++;
      } else if (emptyGSMatch && b2[bi] === "**" && a2[ai] === b2[bi + 1]) {
        result.push(b2[bi]);
        bi++;
      } else if (a2[ai] === "*" && b2[bi] && (this.options.dot || !b2[bi].startsWith(".")) && b2[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a2[ai]);
        ai++;
        bi++;
      } else if (b2[bi] === "*" && a2[ai] && (this.options.dot || !a2[ai].startsWith(".")) && a2[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a2.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i3 = 0; i3 < pattern.length && pattern.charAt(i3) === "!"; i3++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p2 = pattern[pi];
      var f4 = file[fi];
      this.debug(pattern, p2, f4);
      if (p2 === false) {
        return false;
      }
      if (p2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p2, f4]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p2 === "string") {
        hit = f4 === p2;
        this.debug("string match", p2, f4, hit);
      } else {
        hit = p2.test(f4);
        this.debug("pattern match", p2, f4, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m3;
    let fastTest = null;
    if (m3 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m3 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m3[1]);
    } else if (m3 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m3);
    } else if (m3 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m3 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p2) => {
        if (p2 instanceof RegExp) {
          for (const f4 of p2.flags.split(""))
            flags.add(f4);
        }
        return typeof p2 === "string" ? regExpEscape2(p2) : p2 === GLOBSTAR ? GLOBSTAR : p2._src;
      });
      pp.forEach((p2, i3) => {
        const next = pp[i3 + 1];
        const prev = pp[i3 - 1];
        if (p2 !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i3 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i3] = twoStar;
          }
        } else if (next === void 0) {
          pp[i3 - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i3 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i3 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p2) => p2 !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p2) {
    if (this.preserveMultipleSlashes) {
      return p2.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p2)) {
      return ["", ...p2.split(/\/+/)];
    } else {
      return p2.split(/\/+/);
    }
  }
  match(f4, partial = this.partial) {
    this.debug("match", f4, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f4 === "";
    }
    if (f4 === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f4 = f4.split("\\").join("/");
    }
    const ff = this.slashSplit(f4);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i3 = ff.length - 2; !filename && i3 >= 0; i3--) {
        filename = ff[i3];
      }
    }
    for (let i3 = 0; i3 < set.length; i3++) {
      const pattern = set[i3];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// ../../../node_modules/.pnpm/dedent@1.5.1/node_modules/dedent/dist/dedent.mjs
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var dedent_default = createDedent({});
function createDedent(options) {
  dedent.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings)
    } = options;
    let result = "";
    for (let i3 = 0; i3 < raw.length; i3++) {
      let next = raw[i3];
      if (escapeSpecialCharacters) {
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\{/g, "{");
      }
      result += next;
      if (i3 < values.length) {
        result += values[i3];
      }
    }
    const lines = result.split("\n");
    let mindent = null;
    for (const l2 of lines) {
      const m3 = l2.match(/^(\s+)\S+/);
      if (m3) {
        const indent = m3[1].length;
        if (!mindent) {
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m3 = mindent;
      result = lines.map((l2) => l2[0] === " " || l2[0] === "	" ? l2.slice(m3) : l2).join("\n");
    }
    return result.trim().replace(/\\n/g, "\n");
  }
}

// ../sdk2/dist/json-schema/pattern.js
var import_typebox = __toESM(require_typebox(), 1);
var VariableReference = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("variable"),
  name: import_typebox.Type.String()
});
var Literal = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("literal"),
  name: import_typebox.Type.String()
});
var Option = import_typebox.Type.Object({
  name: import_typebox.Type.String(),
  value: import_typebox.Type.Union([Literal, VariableReference])
});
var FunctionAnnotation = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("function"),
  name: import_typebox.Type.String(),
  options: import_typebox.Type.Array(Option)
});
var Expression = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("expression"),
  arg: import_typebox.Type.Union([VariableReference, Literal]),
  annotation: import_typebox.Type.Optional(FunctionAnnotation)
});
var Text = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("text"),
  value: import_typebox.Type.String()
});
var Declaration = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("input"),
  name: import_typebox.Type.String(),
  value: Expression
});
var Pattern = import_typebox.Type.Array(import_typebox.Type.Union([Text, Expression]));

// ../sdk2/dist/human-id/human-id.js
var import_murmurhash3js = __toESM(require_murmurhash3js(), 1);

// ../sdk2/dist/json-schema/settings.js
var import_typebox2 = __toESM(require_typebox(), 1);
var SDKSettings = import_typebox2.Type.Object({
  // TODO SDK-v2 SETTINGS do we need to generate a settings v2 schema?
  $schema: import_typebox2.Type.Optional(import_typebox2.Type.Literal("https://inlang.com/schema/project-settings")),
  baseLocale: import_typebox2.Type.String({
    title: "Base locale",
    description: "The base locale of the project. We recommend BCP-47 language tags."
  }),
  locales: import_typebox2.Type.Array(import_typebox2.Type.String(), {
    uniqueItems: true,
    title: "Project Locales",
    description: "Set the locales that are available in your project. All locales needs to be a valid BCP-47 language tag. Needs to include the base locale tag."
  }),
  // exits for backwards compatibility
  // remove in SDK-v3
  sourceLanguageTag: import_typebox2.Type.Optional(import_typebox2.Type.String({
    description: "Use baseLocale instead.",
    deprecated: true
  })),
  // exits for backwards compatibility
  // remove in SDK-v3
  languageTags: import_typebox2.Type.Optional(import_typebox2.Type.Array(import_typebox2.Type.String(), {
    uniqueItems: true,
    deprecated: true,
    description: "Use locales instead."
  })),
  /**
   * The modules to load.
   *
   * @example
   *  modules: [
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
   *  ]
   */
  modules: import_typebox2.Type.Optional(import_typebox2.Type.Array(import_typebox2.Type.Intersect([
    import_typebox2.Type.String({
      description: "The module must be a valid URI according to RFC 3986.",
      pattern: "(?:[A-Za-z][A-Za-z0-9+.-]*:/{2})?(?:(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})+(?::([A-Za-z0-9-._~]?|[%][A-Fa-f0-9]{2})+)?@)?(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.){1,126}[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?::[0-9]+)?(?:/(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})*)*(?:\\?(?:[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)(?:&|;[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)*)?"
    }),
    import_typebox2.Type.String({
      description: "The module must end with `.js`.",
      pattern: ".*\\.js$"
    }),
    import_typebox2.Type.String({
      description: "The module can only contain a major version number.",
      pattern: "^(?!.*@\\d\\.)[^]*$"
    })
  ]), {
    uniqueItems: true,
    description: "The modules to load. Must be a valid URI but can be relative.",
    examples: [
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
      "./local-testing-plugin.js"
    ]
  })),
  telemetry: import_typebox2.Type.Optional(import_typebox2.Type.Union([
    import_typebox2.Type.Literal("off", {
      description: "No telemetry events "
    })
  ], { description: "If not set, defaults to all" })),
  experimental: import_typebox2.Type.Optional(import_typebox2.Type.Record(import_typebox2.Type.String(), import_typebox2.Type.Literal(true), {
    title: "Experimental settings",
    description: "Experimental settings that are used for product development."
  }))
  /**
   * plugin.*: JSONObject
   *
   * The plugin settings are validated when importing plugins
   */
});
var ExternalSettings = import_typebox2.Type.Record(
  import_typebox2.Type.String({
    pattern: `^((plugin)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)|\\$schema|${// pattern must include the settings properties
    Object.keys(SDKSettings.properties).map((key) => key.replaceAll(".", "\\.")).join("|")})$`,
    description: "The key must be conform to `plugin.*`.",
    examples: ["plugin.csv-importer", "plugin.i18next"]
  }),
  // Using JSON (array and object) as a workaround to make the
  // intersection between `InternalSettings`, which contains an array,
  // and `ExternalSettings` which are objects possible
  import_typebox2.Type.Record(import_typebox2.Type.String(), import_typebox2.Type.Any()),
  { description: "Settings defined by apps, plugins, etc." }
);
var ProjectSettings = import_typebox2.Type.Intersect([SDKSettings, ExternalSettings]);

// ../settings-component2/dist/helper/checkRequired.js
var checkRequired = (schema, property) => {
  if (schema && schema.required && schema.required.includes(property)) {
    return true;
  }
  return false;
};
var checkRequired_default = checkRequired;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/limit.js
var limit_default = (x2, low = 0, high = 1) => {
  return min(max(low, x2), high);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/clip_rgb.js
var clip_rgb_default = (rgb2) => {
  rgb2._clipped = false;
  rgb2._unclipped = rgb2.slice(0);
  for (let i3 = 0; i3 <= 3; i3++) {
    if (i3 < 3) {
      if (rgb2[i3] < 0 || rgb2[i3] > 255)
        rgb2._clipped = true;
      rgb2[i3] = limit_default(rgb2[i3], 0, 255);
    } else if (i3 === 3) {
      rgb2[i3] = limit_default(rgb2[i3], 0, 1);
    }
  }
  return rgb2;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/type.js
var classToType = {};
for (let name of [
  "Boolean",
  "Number",
  "String",
  "Function",
  "Array",
  "Date",
  "RegExp",
  "Undefined",
  "Null"
]) {
  classToType[`[object ${name}]`] = name.toLowerCase();
}
function type_default(obj) {
  return classToType[Object.prototype.toString.call(obj)] || "object";
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/unpack.js
var unpack_default = (args, keyOrder = null) => {
  if (args.length >= 3)
    return Array.prototype.slice.call(args);
  if (type_default(args[0]) == "object" && keyOrder) {
    return keyOrder.split("").filter((k2) => args[0][k2] !== void 0).map((k2) => args[0][k2]);
  }
  return args[0];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/last.js
var last_default = (args) => {
  if (args.length < 2)
    return null;
  const l2 = args.length - 1;
  if (type_default(args[l2]) == "string")
    return args[l2].toLowerCase();
  return null;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/index.js
var { PI, min, max } = Math;
var TWOPI = PI * 2;
var PITHIRD = PI / 3;
var DEG2RAD = PI / 180;
var RAD2DEG = 180 / PI;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/input.js
var input_default = {
  format: {},
  autodetect: []
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/Color.js
var Color = class {
  constructor(...args) {
    const me = this;
    if (type_default(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
      return args[0];
    }
    let mode = last_default(args);
    let autodetect = false;
    if (!mode) {
      autodetect = true;
      if (!input_default.sorted) {
        input_default.autodetect = input_default.autodetect.sort((a2, b2) => b2.p - a2.p);
        input_default.sorted = true;
      }
      for (let chk of input_default.autodetect) {
        mode = chk.test(...args);
        if (mode)
          break;
      }
    }
    if (input_default.format[mode]) {
      const rgb2 = input_default.format[mode].apply(
        null,
        autodetect ? args : args.slice(0, -1)
      );
      me._rgb = clip_rgb_default(rgb2);
    } else {
      throw new Error("unknown format: " + args);
    }
    if (me._rgb.length === 3)
      me._rgb.push(1);
  }
  toString() {
    if (type_default(this.hex) == "function")
      return this.hex();
    return `[${this._rgb.join(",")}]`;
  }
};
var Color_default = Color;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/version.js
var version = "2.6.0";

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/chroma.js
var chroma = (...args) => {
  return new chroma.Color(...args);
};
chroma.Color = Color_default;
chroma.version = version;
var chroma_default = chroma;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/cmyk2rgb.js
var cmyk2rgb = (...args) => {
  args = unpack_default(args, "cmyk");
  const [c4, m3, y2, k2] = args;
  const alpha = args.length > 4 ? args[4] : 1;
  if (k2 === 1)
    return [0, 0, 0, alpha];
  return [
    c4 >= 1 ? 0 : 255 * (1 - c4) * (1 - k2),
    // r
    m3 >= 1 ? 0 : 255 * (1 - m3) * (1 - k2),
    // g
    y2 >= 1 ? 0 : 255 * (1 - y2) * (1 - k2),
    // b
    alpha
  ];
};
var cmyk2rgb_default = cmyk2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/rgb2cmyk.js
var { max: max2 } = Math;
var rgb2cmyk = (...args) => {
  let [r5, g3, b2] = unpack_default(args, "rgb");
  r5 = r5 / 255;
  g3 = g3 / 255;
  b2 = b2 / 255;
  const k2 = 1 - max2(r5, max2(g3, b2));
  const f4 = k2 < 1 ? 1 / (1 - k2) : 0;
  const c4 = (1 - r5 - k2) * f4;
  const m3 = (1 - g3 - k2) * f4;
  const y2 = (1 - b2 - k2) * f4;
  return [c4, m3, y2, k2];
};
var rgb2cmyk_default = rgb2cmyk;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/index.js
Color_default.prototype.cmyk = function() {
  return rgb2cmyk_default(this._rgb);
};
chroma_default.cmyk = (...args) => new Color_default(...args, "cmyk");
input_default.format.cmyk = cmyk2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "cmyk");
    if (type_default(args) === "array" && args.length === 4) {
      return "cmyk";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/hsl2css.js
var rnd = (a2) => Math.round(a2 * 100) / 100;
var hsl2css = (...args) => {
  const hsla = unpack_default(args, "hsla");
  let mode = last_default(args) || "lsa";
  hsla[0] = rnd(hsla[0] || 0);
  hsla[1] = rnd(hsla[1] * 100) + "%";
  hsla[2] = rnd(hsla[2] * 100) + "%";
  if (mode === "hsla" || hsla.length > 3 && hsla[3] < 1) {
    hsla[3] = hsla.length > 3 ? hsla[3] : 1;
    mode = "hsla";
  } else {
    hsla.length = 3;
  }
  return `${mode}(${hsla.join(",")})`;
};
var hsl2css_default = hsl2css;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/rgb2hsl.js
var rgb2hsl = (...args) => {
  args = unpack_default(args, "rgba");
  let [r5, g3, b2] = args;
  r5 /= 255;
  g3 /= 255;
  b2 /= 255;
  const minRgb = min(r5, g3, b2);
  const maxRgb = max(r5, g3, b2);
  const l2 = (maxRgb + minRgb) / 2;
  let s2, h4;
  if (maxRgb === minRgb) {
    s2 = 0;
    h4 = Number.NaN;
  } else {
    s2 = l2 < 0.5 ? (maxRgb - minRgb) / (maxRgb + minRgb) : (maxRgb - minRgb) / (2 - maxRgb - minRgb);
  }
  if (r5 == maxRgb)
    h4 = (g3 - b2) / (maxRgb - minRgb);
  else if (g3 == maxRgb)
    h4 = 2 + (b2 - r5) / (maxRgb - minRgb);
  else if (b2 == maxRgb)
    h4 = 4 + (r5 - g3) / (maxRgb - minRgb);
  h4 *= 60;
  if (h4 < 0)
    h4 += 360;
  if (args.length > 3 && args[3] !== void 0)
    return [h4, s2, l2, args[3]];
  return [h4, s2, l2];
};
var rgb2hsl_default = rgb2hsl;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/rgb2css.js
var { round } = Math;
var rgb2css = (...args) => {
  const rgba = unpack_default(args, "rgba");
  let mode = last_default(args) || "rgb";
  if (mode.substr(0, 3) == "hsl") {
    return hsl2css_default(rgb2hsl_default(rgba), mode);
  }
  rgba[0] = round(rgba[0]);
  rgba[1] = round(rgba[1]);
  rgba[2] = round(rgba[2]);
  if (mode === "rgba" || rgba.length > 3 && rgba[3] < 1) {
    rgba[3] = rgba.length > 3 ? rgba[3] : 1;
    mode = "rgba";
  }
  return `${mode}(${rgba.slice(0, mode === "rgb" ? 3 : 4).join(",")})`;
};
var rgb2css_default = rgb2css;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/hsl2rgb.js
var { round: round2 } = Math;
var hsl2rgb = (...args) => {
  args = unpack_default(args, "hsl");
  const [h4, s2, l2] = args;
  let r5, g3, b2;
  if (s2 === 0) {
    r5 = g3 = b2 = l2 * 255;
  } else {
    const t32 = [0, 0, 0];
    const c4 = [0, 0, 0];
    const t22 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const t1 = 2 * l2 - t22;
    const h_ = h4 / 360;
    t32[0] = h_ + 1 / 3;
    t32[1] = h_;
    t32[2] = h_ - 1 / 3;
    for (let i3 = 0; i3 < 3; i3++) {
      if (t32[i3] < 0)
        t32[i3] += 1;
      if (t32[i3] > 1)
        t32[i3] -= 1;
      if (6 * t32[i3] < 1)
        c4[i3] = t1 + (t22 - t1) * 6 * t32[i3];
      else if (2 * t32[i3] < 1)
        c4[i3] = t22;
      else if (3 * t32[i3] < 2)
        c4[i3] = t1 + (t22 - t1) * (2 / 3 - t32[i3]) * 6;
      else
        c4[i3] = t1;
    }
    [r5, g3, b2] = [round2(c4[0] * 255), round2(c4[1] * 255), round2(c4[2] * 255)];
  }
  if (args.length > 3) {
    return [r5, g3, b2, args[3]];
  }
  return [r5, g3, b2, 1];
};
var hsl2rgb_default = hsl2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/css2rgb.js
var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
var { round: round3 } = Math;
var css2rgb = (css) => {
  css = css.toLowerCase().trim();
  let m3;
  if (input_default.format.named) {
    try {
      return input_default.format.named(css);
    } catch (e5) {
    }
  }
  if (m3 = css.match(RE_RGB)) {
    const rgb2 = m3.slice(1, 4);
    for (let i3 = 0; i3 < 3; i3++) {
      rgb2[i3] = +rgb2[i3];
    }
    rgb2[3] = 1;
    return rgb2;
  }
  if (m3 = css.match(RE_RGBA)) {
    const rgb2 = m3.slice(1, 5);
    for (let i3 = 0; i3 < 4; i3++) {
      rgb2[i3] = +rgb2[i3];
    }
    return rgb2;
  }
  if (m3 = css.match(RE_RGB_PCT)) {
    const rgb2 = m3.slice(1, 4);
    for (let i3 = 0; i3 < 3; i3++) {
      rgb2[i3] = round3(rgb2[i3] * 2.55);
    }
    rgb2[3] = 1;
    return rgb2;
  }
  if (m3 = css.match(RE_RGBA_PCT)) {
    const rgb2 = m3.slice(1, 5);
    for (let i3 = 0; i3 < 3; i3++) {
      rgb2[i3] = round3(rgb2[i3] * 2.55);
    }
    rgb2[3] = +rgb2[3];
    return rgb2;
  }
  if (m3 = css.match(RE_HSL)) {
    const hsl2 = m3.slice(1, 4);
    hsl2[1] *= 0.01;
    hsl2[2] *= 0.01;
    const rgb2 = hsl2rgb_default(hsl2);
    rgb2[3] = 1;
    return rgb2;
  }
  if (m3 = css.match(RE_HSLA)) {
    const hsl2 = m3.slice(1, 4);
    hsl2[1] *= 0.01;
    hsl2[2] *= 0.01;
    const rgb2 = hsl2rgb_default(hsl2);
    rgb2[3] = +m3[4];
    return rgb2;
  }
};
css2rgb.test = (s2) => {
  return RE_RGB.test(s2) || RE_RGBA.test(s2) || RE_RGB_PCT.test(s2) || RE_RGBA_PCT.test(s2) || RE_HSL.test(s2) || RE_HSLA.test(s2);
};
var css2rgb_default = css2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/index.js
Color_default.prototype.css = function(mode) {
  return rgb2css_default(this._rgb, mode);
};
chroma_default.css = (...args) => new Color_default(...args, "css");
input_default.format.css = css2rgb_default;
input_default.autodetect.push({
  p: 5,
  test: (h4, ...rest) => {
    if (!rest.length && type_default(h4) === "string" && css2rgb_default.test(h4)) {
      return "css";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/gl/index.js
input_default.format.gl = (...args) => {
  const rgb2 = unpack_default(args, "rgba");
  rgb2[0] *= 255;
  rgb2[1] *= 255;
  rgb2[2] *= 255;
  return rgb2;
};
chroma_default.gl = (...args) => new Color_default(...args, "gl");
Color_default.prototype.gl = function() {
  const rgb2 = this._rgb;
  return [rgb2[0] / 255, rgb2[1] / 255, rgb2[2] / 255, rgb2[3]];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/hcg2rgb.js
var { floor } = Math;
var hcg2rgb = (...args) => {
  args = unpack_default(args, "hcg");
  let [h4, c4, _g] = args;
  let r5, g3, b2;
  _g = _g * 255;
  const _c = c4 * 255;
  if (c4 === 0) {
    r5 = g3 = b2 = _g;
  } else {
    if (h4 === 360)
      h4 = 0;
    if (h4 > 360)
      h4 -= 360;
    if (h4 < 0)
      h4 += 360;
    h4 /= 60;
    const i3 = floor(h4);
    const f4 = h4 - i3;
    const p2 = _g * (1 - c4);
    const q2 = p2 + _c * (1 - f4);
    const t4 = p2 + _c * f4;
    const v3 = p2 + _c;
    switch (i3) {
      case 0:
        [r5, g3, b2] = [v3, t4, p2];
        break;
      case 1:
        [r5, g3, b2] = [q2, v3, p2];
        break;
      case 2:
        [r5, g3, b2] = [p2, v3, t4];
        break;
      case 3:
        [r5, g3, b2] = [p2, q2, v3];
        break;
      case 4:
        [r5, g3, b2] = [t4, p2, v3];
        break;
      case 5:
        [r5, g3, b2] = [v3, p2, q2];
        break;
    }
  }
  return [r5, g3, b2, args.length > 3 ? args[3] : 1];
};
var hcg2rgb_default = hcg2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/rgb2hcg.js
var rgb2hcg = (...args) => {
  const [r5, g3, b2] = unpack_default(args, "rgb");
  const minRgb = min(r5, g3, b2);
  const maxRgb = max(r5, g3, b2);
  const delta = maxRgb - minRgb;
  const c4 = delta * 100 / 255;
  const _g = minRgb / (255 - delta) * 100;
  let h4;
  if (delta === 0) {
    h4 = Number.NaN;
  } else {
    if (r5 === maxRgb)
      h4 = (g3 - b2) / delta;
    if (g3 === maxRgb)
      h4 = 2 + (b2 - r5) / delta;
    if (b2 === maxRgb)
      h4 = 4 + (r5 - g3) / delta;
    h4 *= 60;
    if (h4 < 0)
      h4 += 360;
  }
  return [h4, c4, _g];
};
var rgb2hcg_default = rgb2hcg;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/index.js
Color_default.prototype.hcg = function() {
  return rgb2hcg_default(this._rgb);
};
chroma_default.hcg = (...args) => new Color_default(...args, "hcg");
input_default.format.hcg = hcg2rgb_default;
input_default.autodetect.push({
  p: 1,
  test: (...args) => {
    args = unpack_default(args, "hcg");
    if (type_default(args) === "array" && args.length === 3) {
      return "hcg";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/hex2rgb.js
var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
var hex2rgb = (hex) => {
  if (hex.match(RE_HEX)) {
    if (hex.length === 4 || hex.length === 7) {
      hex = hex.substr(1);
    }
    if (hex.length === 3) {
      hex = hex.split("");
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    const u2 = parseInt(hex, 16);
    const r5 = u2 >> 16;
    const g3 = u2 >> 8 & 255;
    const b2 = u2 & 255;
    return [r5, g3, b2, 1];
  }
  if (hex.match(RE_HEXA)) {
    if (hex.length === 5 || hex.length === 9) {
      hex = hex.substr(1);
    }
    if (hex.length === 4) {
      hex = hex.split("");
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    const u2 = parseInt(hex, 16);
    const r5 = u2 >> 24 & 255;
    const g3 = u2 >> 16 & 255;
    const b2 = u2 >> 8 & 255;
    const a2 = Math.round((u2 & 255) / 255 * 100) / 100;
    return [r5, g3, b2, a2];
  }
  throw new Error(`unknown hex color: ${hex}`);
};
var hex2rgb_default = hex2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/rgb2hex.js
var { round: round4 } = Math;
var rgb2hex = (...args) => {
  let [r5, g3, b2, a2] = unpack_default(args, "rgba");
  let mode = last_default(args) || "auto";
  if (a2 === void 0)
    a2 = 1;
  if (mode === "auto") {
    mode = a2 < 1 ? "rgba" : "rgb";
  }
  r5 = round4(r5);
  g3 = round4(g3);
  b2 = round4(b2);
  const u2 = r5 << 16 | g3 << 8 | b2;
  let str = "000000" + u2.toString(16);
  str = str.substr(str.length - 6);
  let hxa = "0" + round4(a2 * 255).toString(16);
  hxa = hxa.substr(hxa.length - 2);
  switch (mode.toLowerCase()) {
    case "rgba":
      return `#${str}${hxa}`;
    case "argb":
      return `#${hxa}${str}`;
    default:
      return `#${str}`;
  }
};
var rgb2hex_default = rgb2hex;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/index.js
Color_default.prototype.hex = function(mode) {
  return rgb2hex_default(this._rgb, mode);
};
chroma_default.hex = (...args) => new Color_default(...args, "hex");
input_default.format.hex = hex2rgb_default;
input_default.autodetect.push({
  p: 4,
  test: (h4, ...rest) => {
    if (!rest.length && type_default(h4) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h4.length) >= 0) {
      return "hex";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/hsi2rgb.js
var { cos } = Math;
var hsi2rgb = (...args) => {
  args = unpack_default(args, "hsi");
  let [h4, s2, i3] = args;
  let r5, g3, b2;
  if (isNaN(h4))
    h4 = 0;
  if (isNaN(s2))
    s2 = 0;
  if (h4 > 360)
    h4 -= 360;
  if (h4 < 0)
    h4 += 360;
  h4 /= 360;
  if (h4 < 1 / 3) {
    b2 = (1 - s2) / 3;
    r5 = (1 + s2 * cos(TWOPI * h4) / cos(PITHIRD - TWOPI * h4)) / 3;
    g3 = 1 - (b2 + r5);
  } else if (h4 < 2 / 3) {
    h4 -= 1 / 3;
    r5 = (1 - s2) / 3;
    g3 = (1 + s2 * cos(TWOPI * h4) / cos(PITHIRD - TWOPI * h4)) / 3;
    b2 = 1 - (r5 + g3);
  } else {
    h4 -= 2 / 3;
    g3 = (1 - s2) / 3;
    b2 = (1 + s2 * cos(TWOPI * h4) / cos(PITHIRD - TWOPI * h4)) / 3;
    r5 = 1 - (g3 + b2);
  }
  r5 = limit_default(i3 * r5 * 3);
  g3 = limit_default(i3 * g3 * 3);
  b2 = limit_default(i3 * b2 * 3);
  return [r5 * 255, g3 * 255, b2 * 255, args.length > 3 ? args[3] : 1];
};
var hsi2rgb_default = hsi2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/rgb2hsi.js
var { min: min2, sqrt, acos } = Math;
var rgb2hsi = (...args) => {
  let [r5, g3, b2] = unpack_default(args, "rgb");
  r5 /= 255;
  g3 /= 255;
  b2 /= 255;
  let h4;
  const min_ = min2(r5, g3, b2);
  const i3 = (r5 + g3 + b2) / 3;
  const s2 = i3 > 0 ? 1 - min_ / i3 : 0;
  if (s2 === 0) {
    h4 = NaN;
  } else {
    h4 = (r5 - g3 + (r5 - b2)) / 2;
    h4 /= sqrt((r5 - g3) * (r5 - g3) + (r5 - b2) * (g3 - b2));
    h4 = acos(h4);
    if (b2 > g3) {
      h4 = TWOPI - h4;
    }
    h4 /= TWOPI;
  }
  return [h4 * 360, s2, i3];
};
var rgb2hsi_default = rgb2hsi;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/index.js
Color_default.prototype.hsi = function() {
  return rgb2hsi_default(this._rgb);
};
chroma_default.hsi = (...args) => new Color_default(...args, "hsi");
input_default.format.hsi = hsi2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsi");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsi";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/index.js
Color_default.prototype.hsl = function() {
  return rgb2hsl_default(this._rgb);
};
chroma_default.hsl = (...args) => new Color_default(...args, "hsl");
input_default.format.hsl = hsl2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsl");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsl";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/hsv2rgb.js
var { floor: floor2 } = Math;
var hsv2rgb = (...args) => {
  args = unpack_default(args, "hsv");
  let [h4, s2, v3] = args;
  let r5, g3, b2;
  v3 *= 255;
  if (s2 === 0) {
    r5 = g3 = b2 = v3;
  } else {
    if (h4 === 360)
      h4 = 0;
    if (h4 > 360)
      h4 -= 360;
    if (h4 < 0)
      h4 += 360;
    h4 /= 60;
    const i3 = floor2(h4);
    const f4 = h4 - i3;
    const p2 = v3 * (1 - s2);
    const q2 = v3 * (1 - s2 * f4);
    const t4 = v3 * (1 - s2 * (1 - f4));
    switch (i3) {
      case 0:
        [r5, g3, b2] = [v3, t4, p2];
        break;
      case 1:
        [r5, g3, b2] = [q2, v3, p2];
        break;
      case 2:
        [r5, g3, b2] = [p2, v3, t4];
        break;
      case 3:
        [r5, g3, b2] = [p2, q2, v3];
        break;
      case 4:
        [r5, g3, b2] = [t4, p2, v3];
        break;
      case 5:
        [r5, g3, b2] = [v3, p2, q2];
        break;
    }
  }
  return [r5, g3, b2, args.length > 3 ? args[3] : 1];
};
var hsv2rgb_default = hsv2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/rgb2hsv.js
var { min: min3, max: max3 } = Math;
var rgb2hsl2 = (...args) => {
  args = unpack_default(args, "rgb");
  let [r5, g3, b2] = args;
  const min_ = min3(r5, g3, b2);
  const max_ = max3(r5, g3, b2);
  const delta = max_ - min_;
  let h4, s2, v3;
  v3 = max_ / 255;
  if (max_ === 0) {
    h4 = Number.NaN;
    s2 = 0;
  } else {
    s2 = delta / max_;
    if (r5 === max_)
      h4 = (g3 - b2) / delta;
    if (g3 === max_)
      h4 = 2 + (b2 - r5) / delta;
    if (b2 === max_)
      h4 = 4 + (r5 - g3) / delta;
    h4 *= 60;
    if (h4 < 0)
      h4 += 360;
  }
  return [h4, s2, v3];
};
var rgb2hsv_default = rgb2hsl2;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/index.js
Color_default.prototype.hsv = function() {
  return rgb2hsv_default(this._rgb);
};
chroma_default.hsv = (...args) => new Color_default(...args, "hsv");
input_default.format.hsv = hsv2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsv");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsv";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/lab-constants.js
var lab_constants_default = {
  // Corresponds roughly to RGB brighter/darker
  Kn: 18,
  // D65 standard referent
  Xn: 0.95047,
  Yn: 1,
  Zn: 1.08883,
  t0: 0.137931034,
  // 4 / 29
  t1: 0.206896552,
  // 6 / 29
  t2: 0.12841855,
  // 3 * t1 * t1
  t3: 8856452e-9
  // t1 * t1 * t1
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/lab2rgb.js
var { pow } = Math;
var lab2rgb = (...args) => {
  args = unpack_default(args, "lab");
  const [l2, a2, b2] = args;
  let x2, y2, z2, r5, g3, b_;
  y2 = (l2 + 16) / 116;
  x2 = isNaN(a2) ? y2 : y2 + a2 / 500;
  z2 = isNaN(b2) ? y2 : y2 - b2 / 200;
  y2 = lab_constants_default.Yn * lab_xyz(y2);
  x2 = lab_constants_default.Xn * lab_xyz(x2);
  z2 = lab_constants_default.Zn * lab_xyz(z2);
  r5 = xyz_rgb(3.2404542 * x2 - 1.5371385 * y2 - 0.4985314 * z2);
  g3 = xyz_rgb(-0.969266 * x2 + 1.8760108 * y2 + 0.041556 * z2);
  b_ = xyz_rgb(0.0556434 * x2 - 0.2040259 * y2 + 1.0572252 * z2);
  return [r5, g3, b_, args.length > 3 ? args[3] : 1];
};
var xyz_rgb = (r5) => {
  return 255 * (r5 <= 304e-5 ? 12.92 * r5 : 1.055 * pow(r5, 1 / 2.4) - 0.055);
};
var lab_xyz = (t4) => {
  return t4 > lab_constants_default.t1 ? t4 * t4 * t4 : lab_constants_default.t2 * (t4 - lab_constants_default.t0);
};
var lab2rgb_default = lab2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/rgb2lab.js
var { pow: pow2 } = Math;
var rgb2lab = (...args) => {
  const [r5, g3, b2] = unpack_default(args, "rgb");
  const [x2, y2, z2] = rgb2xyz(r5, g3, b2);
  const l2 = 116 * y2 - 16;
  return [l2 < 0 ? 0 : l2, 500 * (x2 - y2), 200 * (y2 - z2)];
};
var rgb_xyz = (r5) => {
  if ((r5 /= 255) <= 0.04045)
    return r5 / 12.92;
  return pow2((r5 + 0.055) / 1.055, 2.4);
};
var xyz_lab = (t4) => {
  if (t4 > lab_constants_default.t3)
    return pow2(t4, 1 / 3);
  return t4 / lab_constants_default.t2 + lab_constants_default.t0;
};
var rgb2xyz = (r5, g3, b2) => {
  r5 = rgb_xyz(r5);
  g3 = rgb_xyz(g3);
  b2 = rgb_xyz(b2);
  const x2 = xyz_lab(
    (0.4124564 * r5 + 0.3575761 * g3 + 0.1804375 * b2) / lab_constants_default.Xn
  );
  const y2 = xyz_lab(
    (0.2126729 * r5 + 0.7151522 * g3 + 0.072175 * b2) / lab_constants_default.Yn
  );
  const z2 = xyz_lab(
    (0.0193339 * r5 + 0.119192 * g3 + 0.9503041 * b2) / lab_constants_default.Zn
  );
  return [x2, y2, z2];
};
var rgb2lab_default = rgb2lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/index.js
Color_default.prototype.lab = function() {
  return rgb2lab_default(this._rgb);
};
chroma_default.lab = (...args) => new Color_default(...args, "lab");
input_default.format.lab = lab2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "lab");
    if (type_default(args) === "array" && args.length === 3) {
      return "lab";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lch2lab.js
var { sin, cos: cos2 } = Math;
var lch2lab = (...args) => {
  let [l2, c4, h4] = unpack_default(args, "lch");
  if (isNaN(h4))
    h4 = 0;
  h4 = h4 * DEG2RAD;
  return [l2, cos2(h4) * c4, sin(h4) * c4];
};
var lch2lab_default = lch2lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lch2rgb.js
var lch2rgb = (...args) => {
  args = unpack_default(args, "lch");
  const [l2, c4, h4] = args;
  const [L, a2, b_] = lch2lab_default(l2, c4, h4);
  const [r5, g3, b2] = lab2rgb_default(L, a2, b_);
  return [r5, g3, b2, args.length > 3 ? args[3] : 1];
};
var lch2rgb_default = lch2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/hcl2rgb.js
var hcl2rgb = (...args) => {
  const hcl = unpack_default(args, "hcl").reverse();
  return lch2rgb_default(...hcl);
};
var hcl2rgb_default = hcl2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lab2lch.js
var { sqrt: sqrt2, atan2, round: round5 } = Math;
var lab2lch = (...args) => {
  const [l2, a2, b2] = unpack_default(args, "lab");
  const c4 = sqrt2(a2 * a2 + b2 * b2);
  let h4 = (atan2(b2, a2) * RAD2DEG + 360) % 360;
  if (round5(c4 * 1e4) === 0)
    h4 = Number.NaN;
  return [l2, c4, h4];
};
var lab2lch_default = lab2lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/rgb2lch.js
var rgb2lch = (...args) => {
  const [r5, g3, b2] = unpack_default(args, "rgb");
  const [l2, a2, b_] = rgb2lab_default(r5, g3, b2);
  return lab2lch_default(l2, a2, b_);
};
var rgb2lch_default = rgb2lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/index.js
Color_default.prototype.lch = function() {
  return rgb2lch_default(this._rgb);
};
Color_default.prototype.hcl = function() {
  return rgb2lch_default(this._rgb).reverse();
};
chroma_default.lch = (...args) => new Color_default(...args, "lch");
chroma_default.hcl = (...args) => new Color_default(...args, "hcl");
input_default.format.lch = lch2rgb_default;
input_default.format.hcl = hcl2rgb_default;
["lch", "hcl"].forEach(
  (m3) => input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, m3);
      if (type_default(args) === "array" && args.length === 3) {
        return m3;
      }
    }
  })
);

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/colors/w3cx11.js
var w3cx11 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
var w3cx11_default = w3cx11;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/named/index.js
Color_default.prototype.name = function() {
  const hex = rgb2hex_default(this._rgb, "rgb");
  for (let n5 of Object.keys(w3cx11_default)) {
    if (w3cx11_default[n5] === hex)
      return n5.toLowerCase();
  }
  return hex;
};
input_default.format.named = (name) => {
  name = name.toLowerCase();
  if (w3cx11_default[name])
    return hex2rgb_default(w3cx11_default[name]);
  throw new Error("unknown color name: " + name);
};
input_default.autodetect.push({
  p: 5,
  test: (h4, ...rest) => {
    if (!rest.length && type_default(h4) === "string" && w3cx11_default[h4.toLowerCase()]) {
      return "named";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/num2rgb.js
var num2rgb = (num2) => {
  if (type_default(num2) == "number" && num2 >= 0 && num2 <= 16777215) {
    const r5 = num2 >> 16;
    const g3 = num2 >> 8 & 255;
    const b2 = num2 & 255;
    return [r5, g3, b2, 1];
  }
  throw new Error("unknown num color: " + num2);
};
var num2rgb_default = num2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/rgb2num.js
var rgb2num = (...args) => {
  const [r5, g3, b2] = unpack_default(args, "rgb");
  return (r5 << 16) + (g3 << 8) + b2;
};
var rgb2num_default = rgb2num;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/index.js
Color_default.prototype.num = function() {
  return rgb2num_default(this._rgb);
};
chroma_default.num = (...args) => new Color_default(...args, "num");
input_default.format.num = num2rgb_default;
input_default.autodetect.push({
  p: 5,
  test: (...args) => {
    if (args.length === 1 && type_default(args[0]) === "number" && args[0] >= 0 && args[0] <= 16777215) {
      return "num";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/rgb/index.js
var { round: round6 } = Math;
Color_default.prototype.rgb = function(rnd2 = true) {
  if (rnd2 === false)
    return this._rgb.slice(0, 3);
  return this._rgb.slice(0, 3).map(round6);
};
Color_default.prototype.rgba = function(rnd2 = true) {
  return this._rgb.slice(0, 4).map((v3, i3) => {
    return i3 < 3 ? rnd2 === false ? v3 : round6(v3) : v3;
  });
};
chroma_default.rgb = (...args) => new Color_default(...args, "rgb");
input_default.format.rgb = (...args) => {
  const rgba = unpack_default(args, "rgba");
  if (rgba[3] === void 0)
    rgba[3] = 1;
  return rgba;
};
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "rgba");
    if (type_default(args) === "array" && (args.length === 3 || args.length === 4 && type_default(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
      return "rgb";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/temperature2rgb.js
var { log } = Math;
var temperature2rgb = (kelvin) => {
  const temp = kelvin / 100;
  let r5, g3, b2;
  if (temp < 66) {
    r5 = 255;
    g3 = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g3 = temp - 2) + 104.49216199393888 * log(g3);
    b2 = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b2 = temp - 10) + 115.67994401066147 * log(b2);
  } else {
    r5 = 351.97690566805693 + 0.114206453784165 * (r5 = temp - 55) - 40.25366309332127 * log(r5);
    g3 = 325.4494125711974 + 0.07943456536662342 * (g3 = temp - 50) - 28.0852963507957 * log(g3);
    b2 = 255;
  }
  return [r5, g3, b2, 1];
};
var temperature2rgb_default = temperature2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/rgb2temperature.js
var { round: round7 } = Math;
var rgb2temperature = (...args) => {
  const rgb2 = unpack_default(args, "rgb");
  const r5 = rgb2[0], b2 = rgb2[2];
  let minTemp = 1e3;
  let maxTemp = 4e4;
  const eps = 0.4;
  let temp;
  while (maxTemp - minTemp > eps) {
    temp = (maxTemp + minTemp) * 0.5;
    const rgb3 = temperature2rgb_default(temp);
    if (rgb3[2] / rgb3[0] >= b2 / r5) {
      maxTemp = temp;
    } else {
      minTemp = temp;
    }
  }
  return round7(temp);
};
var rgb2temperature_default = rgb2temperature;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/index.js
Color_default.prototype.temp = Color_default.prototype.kelvin = Color_default.prototype.temperature = function() {
  return rgb2temperature_default(this._rgb);
};
chroma_default.temp = chroma_default.kelvin = chroma_default.temperature = (...args) => new Color_default(...args, "temp");
input_default.format.temp = input_default.format.kelvin = input_default.format.temperature = temperature2rgb_default;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/oklab2rgb.js
var { pow: pow3, sign } = Math;
var oklab2rgb = (...args) => {
  args = unpack_default(args, "lab");
  const [L, a2, b2] = args;
  const l2 = pow3(L + 0.3963377774 * a2 + 0.2158037573 * b2, 3);
  const m3 = pow3(L - 0.1055613458 * a2 - 0.0638541728 * b2, 3);
  const s2 = pow3(L - 0.0894841775 * a2 - 1.291485548 * b2, 3);
  return [
    255 * lrgb2rgb(4.0767416621 * l2 - 3.3077115913 * m3 + 0.2309699292 * s2),
    255 * lrgb2rgb(-1.2684380046 * l2 + 2.6097574011 * m3 - 0.3413193965 * s2),
    255 * lrgb2rgb(-0.0041960863 * l2 - 0.7034186147 * m3 + 1.707614701 * s2),
    args.length > 3 ? args[3] : 1
  ];
};
var oklab2rgb_default = oklab2rgb;
function lrgb2rgb(c4) {
  const abs3 = Math.abs(c4);
  if (abs3 > 31308e-7) {
    return (sign(c4) || 1) * (1.055 * pow3(abs3, 1 / 2.4) - 0.055);
  }
  return c4 * 12.92;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/rgb2oklab.js
var { cbrt, pow: pow4, sign: sign2 } = Math;
var rgb2oklab = (...args) => {
  const [r5, g3, b2] = unpack_default(args, "rgb");
  const [lr, lg, lb] = [
    rgb2lrgb(r5 / 255),
    rgb2lrgb(g3 / 255),
    rgb2lrgb(b2 / 255)
  ];
  const l2 = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
  const m3 = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
  const s2 = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);
  return [
    0.2104542553 * l2 + 0.793617785 * m3 - 0.0040720468 * s2,
    1.9779984951 * l2 - 2.428592205 * m3 + 0.4505937099 * s2,
    0.0259040371 * l2 + 0.7827717662 * m3 - 0.808675766 * s2
  ];
};
var rgb2oklab_default = rgb2oklab;
function rgb2lrgb(c4) {
  const abs3 = Math.abs(c4);
  if (abs3 < 0.04045) {
    return c4 / 12.92;
  }
  return (sign2(c4) || 1) * pow4((abs3 + 0.055) / 1.055, 2.4);
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/index.js
Color_default.prototype.oklab = function() {
  return rgb2oklab_default(this._rgb);
};
chroma_default.oklab = (...args) => new Color_default(...args, "oklab");
input_default.format.oklab = oklab2rgb_default;
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "oklab");
    if (type_default(args) === "array" && args.length === 3) {
      return "oklab";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/oklch2rgb.js
var oklch2rgb = (...args) => {
  args = unpack_default(args, "lch");
  const [l2, c4, h4] = args;
  const [L, a2, b_] = lch2lab_default(l2, c4, h4);
  const [r5, g3, b2] = oklab2rgb_default(L, a2, b_);
  return [r5, g3, b2, args.length > 3 ? args[3] : 1];
};
var oklch2rgb_default = oklch2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/rgb2oklch.js
var rgb2oklch = (...args) => {
  const [r5, g3, b2] = unpack_default(args, "rgb");
  const [l2, a2, b_] = rgb2oklab_default(r5, g3, b2);
  return lab2lch_default(l2, a2, b_);
};
var rgb2oklch_default = rgb2oklch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/index.js
Color_default.prototype.oklch = function() {
  return rgb2oklch_default(this._rgb);
};
chroma_default.oklch = (...args) => new Color_default(...args, "oklch");
input_default.format.oklch = oklch2rgb_default;
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "oklch");
    if (type_default(args) === "array" && args.length === 3) {
      return "oklch";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/alpha.js
Color_default.prototype.alpha = function(a2, mutate = false) {
  if (a2 !== void 0 && type_default(a2) === "number") {
    if (mutate) {
      this._rgb[3] = a2;
      return this;
    }
    return new Color_default([this._rgb[0], this._rgb[1], this._rgb[2], a2], "rgb");
  }
  return this._rgb[3];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/clipped.js
Color_default.prototype.clipped = function() {
  return this._rgb._clipped || false;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/darken.js
Color_default.prototype.darken = function(amount = 1) {
  const me = this;
  const lab2 = me.lab();
  lab2[0] -= lab_constants_default.Kn * amount;
  return new Color_default(lab2, "lab").alpha(me.alpha(), true);
};
Color_default.prototype.brighten = function(amount = 1) {
  return this.darken(-amount);
};
Color_default.prototype.darker = Color_default.prototype.darken;
Color_default.prototype.brighter = Color_default.prototype.brighten;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/get.js
Color_default.prototype.get = function(mc) {
  const [mode, channel] = mc.split(".");
  const src = this[mode]();
  if (channel) {
    const i3 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
    if (i3 > -1)
      return src[i3];
    throw new Error(`unknown channel ${channel} in mode ${mode}`);
  } else {
    return src;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/luminance.js
var { pow: pow5 } = Math;
var EPS = 1e-7;
var MAX_ITER = 20;
Color_default.prototype.luminance = function(lum, mode = "rgb") {
  if (lum !== void 0 && type_default(lum) === "number") {
    if (lum === 0) {
      return new Color_default([0, 0, 0, this._rgb[3]], "rgb");
    }
    if (lum === 1) {
      return new Color_default([255, 255, 255, this._rgb[3]], "rgb");
    }
    let cur_lum = this.luminance();
    let max_iter = MAX_ITER;
    const test = (low, high) => {
      const mid = low.interpolate(high, 0.5, mode);
      const lm = mid.luminance();
      if (Math.abs(lum - lm) < EPS || !max_iter--) {
        return mid;
      }
      return lm > lum ? test(low, mid) : test(mid, high);
    };
    const rgb2 = (cur_lum > lum ? test(new Color_default([0, 0, 0]), this) : test(this, new Color_default([255, 255, 255]))).rgb();
    return new Color_default([...rgb2, this._rgb[3]]);
  }
  return rgb2luminance(...this._rgb.slice(0, 3));
};
var rgb2luminance = (r5, g3, b2) => {
  r5 = luminance_x(r5);
  g3 = luminance_x(g3);
  b2 = luminance_x(b2);
  return 0.2126 * r5 + 0.7152 * g3 + 0.0722 * b2;
};
var luminance_x = (x2) => {
  x2 /= 255;
  return x2 <= 0.03928 ? x2 / 12.92 : pow5((x2 + 0.055) / 1.055, 2.4);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/index.js
var interpolator_default = {};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/mix.js
var mix_default = (col1, col2, f4 = 0.5, ...rest) => {
  let mode = rest[0] || "lrgb";
  if (!interpolator_default[mode] && !rest.length) {
    mode = Object.keys(interpolator_default)[0];
  }
  if (!interpolator_default[mode]) {
    throw new Error(`interpolation mode ${mode} is not defined`);
  }
  if (type_default(col1) !== "object")
    col1 = new Color_default(col1);
  if (type_default(col2) !== "object")
    col2 = new Color_default(col2);
  return interpolator_default[mode](col1, col2, f4).alpha(
    col1.alpha() + f4 * (col2.alpha() - col1.alpha())
  );
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/mix.js
Color_default.prototype.mix = Color_default.prototype.interpolate = function(col2, f4 = 0.5, ...rest) {
  return mix_default(this, col2, f4, ...rest);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/premultiply.js
Color_default.prototype.premultiply = function(mutate = false) {
  const rgb2 = this._rgb;
  const a2 = rgb2[3];
  if (mutate) {
    this._rgb = [rgb2[0] * a2, rgb2[1] * a2, rgb2[2] * a2, a2];
    return this;
  } else {
    return new Color_default([rgb2[0] * a2, rgb2[1] * a2, rgb2[2] * a2, a2], "rgb");
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/saturate.js
Color_default.prototype.saturate = function(amount = 1) {
  const me = this;
  const lch2 = me.lch();
  lch2[1] += lab_constants_default.Kn * amount;
  if (lch2[1] < 0)
    lch2[1] = 0;
  return new Color_default(lch2, "lch").alpha(me.alpha(), true);
};
Color_default.prototype.desaturate = function(amount = 1) {
  return this.saturate(-amount);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/set.js
Color_default.prototype.set = function(mc, value, mutate = false) {
  const [mode, channel] = mc.split(".");
  const src = this[mode]();
  if (channel) {
    const i3 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
    if (i3 > -1) {
      if (type_default(value) == "string") {
        switch (value.charAt(0)) {
          case "+":
            src[i3] += +value;
            break;
          case "-":
            src[i3] += +value;
            break;
          case "*":
            src[i3] *= +value.substr(1);
            break;
          case "/":
            src[i3] /= +value.substr(1);
            break;
          default:
            src[i3] = +value;
        }
      } else if (type_default(value) === "number") {
        src[i3] = value;
      } else {
        throw new Error(`unsupported value for Color.set`);
      }
      const out = new Color_default(src, mode);
      if (mutate) {
        this._rgb = out._rgb;
        return this;
      }
      return out;
    }
    throw new Error(`unknown channel ${channel} in mode ${mode}`);
  } else {
    return src;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/shade.js
Color_default.prototype.tint = function(f4 = 0.5, ...rest) {
  return mix_default(this, "white", f4, ...rest);
};
Color_default.prototype.shade = function(f4 = 0.5, ...rest) {
  return mix_default(this, "black", f4, ...rest);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/rgb.js
var rgb = (col1, col2, f4) => {
  const xyz0 = col1._rgb;
  const xyz1 = col2._rgb;
  return new Color_default(
    xyz0[0] + f4 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f4 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f4 * (xyz1[2] - xyz0[2]),
    "rgb"
  );
};
interpolator_default.rgb = rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lrgb.js
var { sqrt: sqrt3, pow: pow6 } = Math;
var lrgb = (col1, col2, f4) => {
  const [x1, y1, z1] = col1._rgb;
  const [x2, y2, z2] = col2._rgb;
  return new Color_default(
    sqrt3(pow6(x1, 2) * (1 - f4) + pow6(x2, 2) * f4),
    sqrt3(pow6(y1, 2) * (1 - f4) + pow6(y2, 2) * f4),
    sqrt3(pow6(z1, 2) * (1 - f4) + pow6(z2, 2) * f4),
    "rgb"
  );
};
interpolator_default.lrgb = lrgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lab.js
var lab = (col1, col2, f4) => {
  const xyz0 = col1.lab();
  const xyz1 = col2.lab();
  return new Color_default(
    xyz0[0] + f4 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f4 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f4 * (xyz1[2] - xyz0[2]),
    "lab"
  );
};
interpolator_default.lab = lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/_hsx.js
var hsx_default = (col1, col2, f4, m3) => {
  let xyz0, xyz1;
  if (m3 === "hsl") {
    xyz0 = col1.hsl();
    xyz1 = col2.hsl();
  } else if (m3 === "hsv") {
    xyz0 = col1.hsv();
    xyz1 = col2.hsv();
  } else if (m3 === "hcg") {
    xyz0 = col1.hcg();
    xyz1 = col2.hcg();
  } else if (m3 === "hsi") {
    xyz0 = col1.hsi();
    xyz1 = col2.hsi();
  } else if (m3 === "lch" || m3 === "hcl") {
    m3 = "hcl";
    xyz0 = col1.hcl();
    xyz1 = col2.hcl();
  } else if (m3 === "oklch") {
    xyz0 = col1.oklch().reverse();
    xyz1 = col2.oklch().reverse();
  }
  let hue0, hue1, sat0, sat1, lbv0, lbv1;
  if (m3.substr(0, 1) === "h" || m3 === "oklch") {
    [hue0, sat0, lbv0] = xyz0;
    [hue1, sat1, lbv1] = xyz1;
  }
  let sat, hue, lbv, dh;
  if (!isNaN(hue0) && !isNaN(hue1)) {
    if (hue1 > hue0 && hue1 - hue0 > 180) {
      dh = hue1 - (hue0 + 360);
    } else if (hue1 < hue0 && hue0 - hue1 > 180) {
      dh = hue1 + 360 - hue0;
    } else {
      dh = hue1 - hue0;
    }
    hue = hue0 + f4 * dh;
  } else if (!isNaN(hue0)) {
    hue = hue0;
    if ((lbv1 == 1 || lbv1 == 0) && m3 != "hsv")
      sat = sat0;
  } else if (!isNaN(hue1)) {
    hue = hue1;
    if ((lbv0 == 1 || lbv0 == 0) && m3 != "hsv")
      sat = sat1;
  } else {
    hue = Number.NaN;
  }
  if (sat === void 0)
    sat = sat0 + f4 * (sat1 - sat0);
  lbv = lbv0 + f4 * (lbv1 - lbv0);
  return m3 === "oklch" ? new Color_default([lbv, sat, hue], m3) : new Color_default([hue, sat, lbv], m3);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lch.js
var lch = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "lch");
};
interpolator_default.lch = lch;
interpolator_default.hcl = lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/num.js
var num = (col1, col2, f4) => {
  const c1 = col1.num();
  const c22 = col2.num();
  return new Color_default(c1 + f4 * (c22 - c1), "num");
};
interpolator_default.num = num;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hcg.js
var hcg = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "hcg");
};
interpolator_default.hcg = hcg;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsi.js
var hsi = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "hsi");
};
interpolator_default.hsi = hsi;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsl.js
var hsl = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "hsl");
};
interpolator_default.hsl = hsl;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsv.js
var hsv = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "hsv");
};
interpolator_default.hsv = hsv;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/oklab.js
var oklab = (col1, col2, f4) => {
  const xyz0 = col1.oklab();
  const xyz1 = col2.oklab();
  return new Color_default(
    xyz0[0] + f4 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f4 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f4 * (xyz1[2] - xyz0[2]),
    "oklab"
  );
};
interpolator_default.oklab = oklab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/oklch.js
var oklch = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "oklch");
};
interpolator_default.oklch = oklch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/average.js
var { pow: pow7, sqrt: sqrt4, PI: PI2, cos: cos3, sin: sin2, atan2: atan22 } = Math;
var average_default = (colors, mode = "lrgb", weights = null) => {
  const l2 = colors.length;
  if (!weights)
    weights = Array.from(new Array(l2)).map(() => 1);
  const k2 = l2 / weights.reduce(function(a2, b2) {
    return a2 + b2;
  });
  weights.forEach((w2, i3) => {
    weights[i3] *= k2;
  });
  colors = colors.map((c4) => new Color_default(c4));
  if (mode === "lrgb") {
    return _average_lrgb(colors, weights);
  }
  const first = colors.shift();
  const xyz = first.get(mode);
  const cnt = [];
  let dx = 0;
  let dy = 0;
  for (let i3 = 0; i3 < xyz.length; i3++) {
    xyz[i3] = (xyz[i3] || 0) * weights[0];
    cnt.push(isNaN(xyz[i3]) ? 0 : weights[0]);
    if (mode.charAt(i3) === "h" && !isNaN(xyz[i3])) {
      const A = xyz[i3] / 180 * PI2;
      dx += cos3(A) * weights[0];
      dy += sin2(A) * weights[0];
    }
  }
  let alpha = first.alpha() * weights[0];
  colors.forEach((c4, ci) => {
    const xyz2 = c4.get(mode);
    alpha += c4.alpha() * weights[ci + 1];
    for (let i3 = 0; i3 < xyz.length; i3++) {
      if (!isNaN(xyz2[i3])) {
        cnt[i3] += weights[ci + 1];
        if (mode.charAt(i3) === "h") {
          const A = xyz2[i3] / 180 * PI2;
          dx += cos3(A) * weights[ci + 1];
          dy += sin2(A) * weights[ci + 1];
        } else {
          xyz[i3] += xyz2[i3] * weights[ci + 1];
        }
      }
    }
  });
  for (let i3 = 0; i3 < xyz.length; i3++) {
    if (mode.charAt(i3) === "h") {
      let A = atan22(dy / cnt[i3], dx / cnt[i3]) / PI2 * 180;
      while (A < 0)
        A += 360;
      while (A >= 360)
        A -= 360;
      xyz[i3] = A;
    } else {
      xyz[i3] = xyz[i3] / cnt[i3];
    }
  }
  alpha /= l2;
  return new Color_default(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
};
var _average_lrgb = (colors, weights) => {
  const l2 = colors.length;
  const xyz = [0, 0, 0, 0];
  for (let i3 = 0; i3 < colors.length; i3++) {
    const col = colors[i3];
    const f4 = weights[i3] / l2;
    const rgb2 = col._rgb;
    xyz[0] += pow7(rgb2[0], 2) * f4;
    xyz[1] += pow7(rgb2[1], 2) * f4;
    xyz[2] += pow7(rgb2[2], 2) * f4;
    xyz[3] += rgb2[3] * f4;
  }
  xyz[0] = sqrt4(xyz[0]);
  xyz[1] = sqrt4(xyz[1]);
  xyz[2] = sqrt4(xyz[2]);
  if (xyz[3] > 0.9999999)
    xyz[3] = 1;
  return new Color_default(clip_rgb_default(xyz));
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/scale.js
var { pow: pow8 } = Math;
function scale_default(colors) {
  let _mode = "rgb";
  let _nacol = chroma_default("#ccc");
  let _spread = 0;
  let _domain = [0, 1];
  let _pos = [];
  let _padding = [0, 0];
  let _classes = false;
  let _colors = [];
  let _out = false;
  let _min = 0;
  let _max = 1;
  let _correctLightness = false;
  let _colorCache = {};
  let _useCache = true;
  let _gamma = 1;
  const setColors = function(colors2) {
    colors2 = colors2 || ["#fff", "#000"];
    if (colors2 && type_default(colors2) === "string" && chroma_default.brewer && chroma_default.brewer[colors2.toLowerCase()]) {
      colors2 = chroma_default.brewer[colors2.toLowerCase()];
    }
    if (type_default(colors2) === "array") {
      if (colors2.length === 1) {
        colors2 = [colors2[0], colors2[0]];
      }
      colors2 = colors2.slice(0);
      for (let c4 = 0; c4 < colors2.length; c4++) {
        colors2[c4] = chroma_default(colors2[c4]);
      }
      _pos.length = 0;
      for (let c4 = 0; c4 < colors2.length; c4++) {
        _pos.push(c4 / (colors2.length - 1));
      }
    }
    resetCache();
    return _colors = colors2;
  };
  const getClass = function(value) {
    if (_classes != null) {
      const n5 = _classes.length - 1;
      let i3 = 0;
      while (i3 < n5 && value >= _classes[i3]) {
        i3++;
      }
      return i3 - 1;
    }
    return 0;
  };
  let tMapLightness = (t4) => t4;
  let tMapDomain = (t4) => t4;
  const getColor2 = function(val, bypassMap) {
    let col, t4;
    if (bypassMap == null) {
      bypassMap = false;
    }
    if (isNaN(val) || val === null) {
      return _nacol;
    }
    if (!bypassMap) {
      if (_classes && _classes.length > 2) {
        const c4 = getClass(val);
        t4 = c4 / (_classes.length - 2);
      } else if (_max !== _min) {
        t4 = (val - _min) / (_max - _min);
      } else {
        t4 = 1;
      }
    } else {
      t4 = val;
    }
    t4 = tMapDomain(t4);
    if (!bypassMap) {
      t4 = tMapLightness(t4);
    }
    if (_gamma !== 1) {
      t4 = pow8(t4, _gamma);
    }
    t4 = _padding[0] + t4 * (1 - _padding[0] - _padding[1]);
    t4 = limit_default(t4, 0, 1);
    const k2 = Math.floor(t4 * 1e4);
    if (_useCache && _colorCache[k2]) {
      col = _colorCache[k2];
    } else {
      if (type_default(_colors) === "array") {
        for (let i3 = 0; i3 < _pos.length; i3++) {
          const p2 = _pos[i3];
          if (t4 <= p2) {
            col = _colors[i3];
            break;
          }
          if (t4 >= p2 && i3 === _pos.length - 1) {
            col = _colors[i3];
            break;
          }
          if (t4 > p2 && t4 < _pos[i3 + 1]) {
            t4 = (t4 - p2) / (_pos[i3 + 1] - p2);
            col = chroma_default.interpolate(
              _colors[i3],
              _colors[i3 + 1],
              t4,
              _mode
            );
            break;
          }
        }
      } else if (type_default(_colors) === "function") {
        col = _colors(t4);
      }
      if (_useCache) {
        _colorCache[k2] = col;
      }
    }
    return col;
  };
  var resetCache = () => _colorCache = {};
  setColors(colors);
  const f4 = function(v3) {
    const c4 = chroma_default(getColor2(v3));
    if (_out && c4[_out]) {
      return c4[_out]();
    } else {
      return c4;
    }
  };
  f4.classes = function(classes) {
    if (classes != null) {
      if (type_default(classes) === "array") {
        _classes = classes;
        _domain = [classes[0], classes[classes.length - 1]];
      } else {
        const d2 = chroma_default.analyze(_domain);
        if (classes === 0) {
          _classes = [d2.min, d2.max];
        } else {
          _classes = chroma_default.limits(d2, "e", classes);
        }
      }
      return f4;
    }
    return _classes;
  };
  f4.domain = function(domain) {
    if (!arguments.length) {
      return _domain;
    }
    _min = domain[0];
    _max = domain[domain.length - 1];
    _pos = [];
    const k2 = _colors.length;
    if (domain.length === k2 && _min !== _max) {
      for (let d2 of Array.from(domain)) {
        _pos.push((d2 - _min) / (_max - _min));
      }
    } else {
      for (let c4 = 0; c4 < k2; c4++) {
        _pos.push(c4 / (k2 - 1));
      }
      if (domain.length > 2) {
        const tOut = domain.map((d2, i3) => i3 / (domain.length - 1));
        const tBreaks = domain.map((d2) => (d2 - _min) / (_max - _min));
        if (!tBreaks.every((val, i3) => tOut[i3] === val)) {
          tMapDomain = (t4) => {
            if (t4 <= 0 || t4 >= 1)
              return t4;
            let i3 = 0;
            while (t4 >= tBreaks[i3 + 1])
              i3++;
            const f5 = (t4 - tBreaks[i3]) / (tBreaks[i3 + 1] - tBreaks[i3]);
            const out = tOut[i3] + f5 * (tOut[i3 + 1] - tOut[i3]);
            return out;
          };
        }
      }
    }
    _domain = [_min, _max];
    return f4;
  };
  f4.mode = function(_m) {
    if (!arguments.length) {
      return _mode;
    }
    _mode = _m;
    resetCache();
    return f4;
  };
  f4.range = function(colors2, _pos2) {
    setColors(colors2, _pos2);
    return f4;
  };
  f4.out = function(_o) {
    _out = _o;
    return f4;
  };
  f4.spread = function(val) {
    if (!arguments.length) {
      return _spread;
    }
    _spread = val;
    return f4;
  };
  f4.correctLightness = function(v3) {
    if (v3 == null) {
      v3 = true;
    }
    _correctLightness = v3;
    resetCache();
    if (_correctLightness) {
      tMapLightness = function(t4) {
        const L0 = getColor2(0, true).lab()[0];
        const L1 = getColor2(1, true).lab()[0];
        const pol = L0 > L1;
        let L_actual = getColor2(t4, true).lab()[0];
        const L_ideal = L0 + (L1 - L0) * t4;
        let L_diff = L_actual - L_ideal;
        let t0 = 0;
        let t1 = 1;
        let max_iter = 20;
        while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
          (function() {
            if (pol) {
              L_diff *= -1;
            }
            if (L_diff < 0) {
              t0 = t4;
              t4 += (t1 - t4) * 0.5;
            } else {
              t1 = t4;
              t4 += (t0 - t4) * 0.5;
            }
            L_actual = getColor2(t4, true).lab()[0];
            return L_diff = L_actual - L_ideal;
          })();
        }
        return t4;
      };
    } else {
      tMapLightness = (t4) => t4;
    }
    return f4;
  };
  f4.padding = function(p2) {
    if (p2 != null) {
      if (type_default(p2) === "number") {
        p2 = [p2, p2];
      }
      _padding = p2;
      return f4;
    } else {
      return _padding;
    }
  };
  f4.colors = function(numColors, out) {
    if (arguments.length < 2) {
      out = "hex";
    }
    let result = [];
    if (arguments.length === 0) {
      result = _colors.slice(0);
    } else if (numColors === 1) {
      result = [f4(0.5)];
    } else if (numColors > 1) {
      const dm = _domain[0];
      const dd = _domain[1] - dm;
      result = __range__(0, numColors, false).map(
        (i3) => f4(dm + i3 / (numColors - 1) * dd)
      );
    } else {
      colors = [];
      let samples = [];
      if (_classes && _classes.length > 2) {
        for (let i3 = 1, end = _classes.length, asc = 1 <= end; asc ? i3 < end : i3 > end; asc ? i3++ : i3--) {
          samples.push((_classes[i3 - 1] + _classes[i3]) * 0.5);
        }
      } else {
        samples = _domain;
      }
      result = samples.map((v3) => f4(v3));
    }
    if (chroma_default[out]) {
      result = result.map((c4) => c4[out]());
    }
    return result;
  };
  f4.cache = function(c4) {
    if (c4 != null) {
      _useCache = c4;
      return f4;
    } else {
      return _useCache;
    }
  };
  f4.gamma = function(g3) {
    if (g3 != null) {
      _gamma = g3;
      return f4;
    } else {
      return _gamma;
    }
  };
  f4.nodata = function(d2) {
    if (d2 != null) {
      _nacol = chroma_default(d2);
      return f4;
    } else {
      return _nacol;
    }
  };
  return f4;
}
function __range__(left, right, inclusive) {
  let range = [];
  let ascending = left < right;
  let end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i3 = left; ascending ? i3 < end : i3 > end; ascending ? i3++ : i3--) {
    range.push(i3);
  }
  return range;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/bezier.js
var binom_row = function(n5) {
  let row = [1, 1];
  for (let i3 = 1; i3 < n5; i3++) {
    let newrow = [1];
    for (let j2 = 1; j2 <= row.length; j2++) {
      newrow[j2] = (row[j2] || 0) + row[j2 - 1];
    }
    row = newrow;
  }
  return row;
};
var bezier = function(colors) {
  let I2, lab0, lab1, lab2;
  colors = colors.map((c4) => new Color_default(c4));
  if (colors.length === 2) {
    [lab0, lab1] = colors.map((c4) => c4.lab());
    I2 = function(t4) {
      const lab3 = [0, 1, 2].map((i3) => lab0[i3] + t4 * (lab1[i3] - lab0[i3]));
      return new Color_default(lab3, "lab");
    };
  } else if (colors.length === 3) {
    [lab0, lab1, lab2] = colors.map((c4) => c4.lab());
    I2 = function(t4) {
      const lab3 = [0, 1, 2].map(
        (i3) => (1 - t4) * (1 - t4) * lab0[i3] + 2 * (1 - t4) * t4 * lab1[i3] + t4 * t4 * lab2[i3]
      );
      return new Color_default(lab3, "lab");
    };
  } else if (colors.length === 4) {
    let lab3;
    [lab0, lab1, lab2, lab3] = colors.map((c4) => c4.lab());
    I2 = function(t4) {
      const lab4 = [0, 1, 2].map(
        (i3) => (1 - t4) * (1 - t4) * (1 - t4) * lab0[i3] + 3 * (1 - t4) * (1 - t4) * t4 * lab1[i3] + 3 * (1 - t4) * t4 * t4 * lab2[i3] + t4 * t4 * t4 * lab3[i3]
      );
      return new Color_default(lab4, "lab");
    };
  } else if (colors.length >= 5) {
    let labs, row, n5;
    labs = colors.map((c4) => c4.lab());
    n5 = colors.length - 1;
    row = binom_row(n5);
    I2 = function(t4) {
      const u2 = 1 - t4;
      const lab3 = [0, 1, 2].map(
        (i3) => labs.reduce(
          (sum, el, j2) => sum + row[j2] * u2 ** (n5 - j2) * t4 ** j2 * el[i3],
          0
        )
      );
      return new Color_default(lab3, "lab");
    };
  } else {
    throw new RangeError("No point in running bezier with only one color.");
  }
  return I2;
};
var bezier_default = (colors) => {
  const f4 = bezier(colors);
  f4.scale = () => scale_default(f4);
  return f4;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/blend.js
var blend = (bottom, top, mode) => {
  if (!blend[mode]) {
    throw new Error("unknown blend mode " + mode);
  }
  return blend[mode](bottom, top);
};
var blend_f = (f4) => (bottom, top) => {
  const c0 = chroma_default(top).rgb();
  const c1 = chroma_default(bottom).rgb();
  return chroma_default.rgb(f4(c0, c1));
};
var each = (f4) => (c0, c1) => {
  const out = [];
  out[0] = f4(c0[0], c1[0]);
  out[1] = f4(c0[1], c1[1]);
  out[2] = f4(c0[2], c1[2]);
  return out;
};
var normal = (a2) => a2;
var multiply = (a2, b2) => a2 * b2 / 255;
var darken = (a2, b2) => a2 > b2 ? b2 : a2;
var lighten = (a2, b2) => a2 > b2 ? a2 : b2;
var screen = (a2, b2) => 255 * (1 - (1 - a2 / 255) * (1 - b2 / 255));
var overlay = (a2, b2) => b2 < 128 ? 2 * a2 * b2 / 255 : 255 * (1 - 2 * (1 - a2 / 255) * (1 - b2 / 255));
var burn = (a2, b2) => 255 * (1 - (1 - b2 / 255) / (a2 / 255));
var dodge = (a2, b2) => {
  if (a2 === 255)
    return 255;
  a2 = 255 * (b2 / 255) / (1 - a2 / 255);
  return a2 > 255 ? 255 : a2;
};
blend.normal = blend_f(each(normal));
blend.multiply = blend_f(each(multiply));
blend.screen = blend_f(each(screen));
blend.overlay = blend_f(each(overlay));
blend.darken = blend_f(each(darken));
blend.lighten = blend_f(each(lighten));
blend.dodge = blend_f(each(dodge));
blend.burn = blend_f(each(burn));
var blend_default = blend;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/cubehelix.js
var { pow: pow9, sin: sin3, cos: cos4 } = Math;
function cubehelix_default(start = 300, rotations = -1.5, hue = 1, gamma = 1, lightness = [0, 1]) {
  let dh = 0, dl;
  if (type_default(lightness) === "array") {
    dl = lightness[1] - lightness[0];
  } else {
    dl = 0;
    lightness = [lightness, lightness];
  }
  const f4 = function(fract) {
    const a2 = TWOPI * ((start + 120) / 360 + rotations * fract);
    const l2 = pow9(lightness[0] + dl * fract, gamma);
    const h4 = dh !== 0 ? hue[0] + fract * dh : hue;
    const amp = h4 * l2 * (1 - l2) / 2;
    const cos_a = cos4(a2);
    const sin_a = sin3(a2);
    const r5 = l2 + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
    const g3 = l2 + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
    const b2 = l2 + amp * (1.97294 * cos_a);
    return chroma_default(clip_rgb_default([r5 * 255, g3 * 255, b2 * 255, 1]));
  };
  f4.start = function(s2) {
    if (s2 == null) {
      return start;
    }
    start = s2;
    return f4;
  };
  f4.rotations = function(r5) {
    if (r5 == null) {
      return rotations;
    }
    rotations = r5;
    return f4;
  };
  f4.gamma = function(g3) {
    if (g3 == null) {
      return gamma;
    }
    gamma = g3;
    return f4;
  };
  f4.hue = function(h4) {
    if (h4 == null) {
      return hue;
    }
    hue = h4;
    if (type_default(hue) === "array") {
      dh = hue[1] - hue[0];
      if (dh === 0) {
        hue = hue[1];
      }
    } else {
      dh = 0;
    }
    return f4;
  };
  f4.lightness = function(h4) {
    if (h4 == null) {
      return lightness;
    }
    if (type_default(h4) === "array") {
      lightness = h4;
      dl = h4[1] - h4[0];
    } else {
      lightness = [h4, h4];
      dl = 0;
    }
    return f4;
  };
  f4.scale = () => chroma_default.scale(f4);
  f4.hue(hue);
  return f4;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/random.js
var digits = "0123456789abcdef";
var { floor: floor3, random } = Math;
var random_default = () => {
  let code = "#";
  for (let i3 = 0; i3 < 6; i3++) {
    code += digits.charAt(floor3(random() * 16));
  }
  return new Color_default(code, "hex");
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/analyze.js
var { log: log2, pow: pow10, floor: floor4, abs } = Math;
function analyze(data, key = null) {
  const r5 = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  if (type_default(data) === "object") {
    data = Object.values(data);
  }
  data.forEach((val) => {
    if (key && type_default(val) === "object")
      val = val[key];
    if (val !== void 0 && val !== null && !isNaN(val)) {
      r5.values.push(val);
      r5.sum += val;
      if (val < r5.min)
        r5.min = val;
      if (val > r5.max)
        r5.max = val;
      r5.count += 1;
    }
  });
  r5.domain = [r5.min, r5.max];
  r5.limits = (mode, num2) => limits(r5, mode, num2);
  return r5;
}
function limits(data, mode = "equal", num2 = 7) {
  if (type_default(data) == "array") {
    data = analyze(data);
  }
  const { min: min6, max: max6 } = data;
  const values = data.values.sort((a2, b2) => a2 - b2);
  if (num2 === 1) {
    return [min6, max6];
  }
  const limits2 = [];
  if (mode.substr(0, 1) === "c") {
    limits2.push(min6);
    limits2.push(max6);
  }
  if (mode.substr(0, 1) === "e") {
    limits2.push(min6);
    for (let i3 = 1; i3 < num2; i3++) {
      limits2.push(min6 + i3 / num2 * (max6 - min6));
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "l") {
    if (min6 <= 0) {
      throw new Error(
        "Logarithmic scales are only possible for values > 0"
      );
    }
    const min_log = Math.LOG10E * log2(min6);
    const max_log = Math.LOG10E * log2(max6);
    limits2.push(min6);
    for (let i3 = 1; i3 < num2; i3++) {
      limits2.push(pow10(10, min_log + i3 / num2 * (max_log - min_log)));
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "q") {
    limits2.push(min6);
    for (let i3 = 1; i3 < num2; i3++) {
      const p2 = (values.length - 1) * i3 / num2;
      const pb = floor4(p2);
      if (pb === p2) {
        limits2.push(values[pb]);
      } else {
        const pr = p2 - pb;
        limits2.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
      }
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "k") {
    let cluster;
    const n5 = values.length;
    const assignments = new Array(n5);
    const clusterSizes = new Array(num2);
    let repeat = true;
    let nb_iters = 0;
    let centroids = null;
    centroids = [];
    centroids.push(min6);
    for (let i3 = 1; i3 < num2; i3++) {
      centroids.push(min6 + i3 / num2 * (max6 - min6));
    }
    centroids.push(max6);
    while (repeat) {
      for (let j2 = 0; j2 < num2; j2++) {
        clusterSizes[j2] = 0;
      }
      for (let i3 = 0; i3 < n5; i3++) {
        const value = values[i3];
        let mindist = Number.MAX_VALUE;
        let best;
        for (let j2 = 0; j2 < num2; j2++) {
          const dist = abs(centroids[j2] - value);
          if (dist < mindist) {
            mindist = dist;
            best = j2;
          }
          clusterSizes[best]++;
          assignments[i3] = best;
        }
      }
      const newCentroids = new Array(num2);
      for (let j2 = 0; j2 < num2; j2++) {
        newCentroids[j2] = null;
      }
      for (let i3 = 0; i3 < n5; i3++) {
        cluster = assignments[i3];
        if (newCentroids[cluster] === null) {
          newCentroids[cluster] = values[i3];
        } else {
          newCentroids[cluster] += values[i3];
        }
      }
      for (let j2 = 0; j2 < num2; j2++) {
        newCentroids[j2] *= 1 / clusterSizes[j2];
      }
      repeat = false;
      for (let j2 = 0; j2 < num2; j2++) {
        if (newCentroids[j2] !== centroids[j2]) {
          repeat = true;
          break;
        }
      }
      centroids = newCentroids;
      nb_iters++;
      if (nb_iters > 200) {
        repeat = false;
      }
    }
    const kClusters = {};
    for (let j2 = 0; j2 < num2; j2++) {
      kClusters[j2] = [];
    }
    for (let i3 = 0; i3 < n5; i3++) {
      cluster = assignments[i3];
      kClusters[cluster].push(values[i3]);
    }
    let tmpKMeansBreaks = [];
    for (let j2 = 0; j2 < num2; j2++) {
      tmpKMeansBreaks.push(kClusters[j2][0]);
      tmpKMeansBreaks.push(kClusters[j2][kClusters[j2].length - 1]);
    }
    tmpKMeansBreaks = tmpKMeansBreaks.sort((a2, b2) => a2 - b2);
    limits2.push(tmpKMeansBreaks[0]);
    for (let i3 = 1; i3 < tmpKMeansBreaks.length; i3 += 2) {
      const v3 = tmpKMeansBreaks[i3];
      if (!isNaN(v3) && limits2.indexOf(v3) === -1) {
        limits2.push(v3);
      }
    }
  }
  return limits2;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/contrast.js
var contrast_default = (a2, b2) => {
  a2 = new Color_default(a2);
  b2 = new Color_default(b2);
  const l1 = a2.luminance();
  const l2 = b2.luminance();
  return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/delta-e.js
var { sqrt: sqrt5, pow: pow11, min: min4, max: max4, atan2: atan23, abs: abs2, cos: cos5, sin: sin4, exp, PI: PI3 } = Math;
function delta_e_default(a2, b2, Kl = 1, Kc = 1, Kh = 1) {
  var rad2deg = function(rad) {
    return 360 * rad / (2 * PI3);
  };
  var deg2rad = function(deg) {
    return 2 * PI3 * deg / 360;
  };
  a2 = new Color_default(a2);
  b2 = new Color_default(b2);
  const [L1, a1, b1] = Array.from(a2.lab());
  const [L2, a22, b22] = Array.from(b2.lab());
  const avgL = (L1 + L2) / 2;
  const C1 = sqrt5(pow11(a1, 2) + pow11(b1, 2));
  const C2 = sqrt5(pow11(a22, 2) + pow11(b22, 2));
  const avgC = (C1 + C2) / 2;
  const G2 = 0.5 * (1 - sqrt5(pow11(avgC, 7) / (pow11(avgC, 7) + pow11(25, 7))));
  const a1p = a1 * (1 + G2);
  const a2p = a22 * (1 + G2);
  const C1p = sqrt5(pow11(a1p, 2) + pow11(b1, 2));
  const C2p = sqrt5(pow11(a2p, 2) + pow11(b22, 2));
  const avgCp = (C1p + C2p) / 2;
  const arctan1 = rad2deg(atan23(b1, a1p));
  const arctan2 = rad2deg(atan23(b22, a2p));
  const h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
  const h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
  const avgHp = abs2(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
  const T2 = 1 - 0.17 * cos5(deg2rad(avgHp - 30)) + 0.24 * cos5(deg2rad(2 * avgHp)) + 0.32 * cos5(deg2rad(3 * avgHp + 6)) - 0.2 * cos5(deg2rad(4 * avgHp - 63));
  let deltaHp = h2p - h1p;
  deltaHp = abs2(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
  deltaHp = 2 * sqrt5(C1p * C2p) * sin4(deg2rad(deltaHp) / 2);
  const deltaL = L2 - L1;
  const deltaCp = C2p - C1p;
  const sl = 1 + 0.015 * pow11(avgL - 50, 2) / sqrt5(20 + pow11(avgL - 50, 2));
  const sc = 1 + 0.045 * avgCp;
  const sh = 1 + 0.015 * avgCp * T2;
  const deltaTheta = 30 * exp(-pow11((avgHp - 275) / 25, 2));
  const Rc = 2 * sqrt5(pow11(avgCp, 7) / (pow11(avgCp, 7) + pow11(25, 7)));
  const Rt2 = -Rc * sin4(2 * deg2rad(deltaTheta));
  const result = sqrt5(
    pow11(deltaL / (Kl * sl), 2) + pow11(deltaCp / (Kc * sc), 2) + pow11(deltaHp / (Kh * sh), 2) + Rt2 * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))
  );
  return max4(0, min4(100, result));
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/distance.js
function distance_default(a2, b2, mode = "lab") {
  a2 = new Color_default(a2);
  b2 = new Color_default(b2);
  const l1 = a2.get(mode);
  const l2 = b2.get(mode);
  let sum_sq = 0;
  for (let i3 in l1) {
    const d2 = (l1[i3] || 0) - (l2[i3] || 0);
    sum_sq += d2 * d2;
  }
  return Math.sqrt(sum_sq);
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/valid.js
var valid_default = (...args) => {
  try {
    new Color_default(...args);
    return true;
  } catch (e5) {
    return false;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/scales.js
var scales_default = {
  cool() {
    return scale_default([chroma_default.hsl(180, 1, 0.9), chroma_default.hsl(250, 0.7, 0.4)]);
  },
  hot() {
    return scale_default(["#000", "#f00", "#ff0", "#fff"], [0, 0.25, 0.75, 1]).mode(
      "rgb"
    );
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/colors/colorbrewer.js
var colorbrewer = {
  // sequential
  OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
  PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
  BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
  Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
  BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
  YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
  YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
  Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
  RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
  Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
  YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
  Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
  GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
  Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
  YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
  PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
  Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
  PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
  Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
  // diverging
  Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
  RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
  RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
  PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
  PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
  RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
  BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
  RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
  PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
  // qualitative
  Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
  Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
  Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
  Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
  Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
  Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
  Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
  Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
};
for (let key of Object.keys(colorbrewer)) {
  colorbrewer[key.toLowerCase()] = colorbrewer[key];
}
var colorbrewer_default = colorbrewer;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/index.js
Object.assign(chroma_default, {
  average: average_default,
  bezier: bezier_default,
  blend: blend_default,
  cubehelix: cubehelix_default,
  mix: mix_default,
  interpolate: mix_default,
  random: random_default,
  scale: scale_default,
  analyze,
  contrast: contrast_default,
  deltaE: delta_e_default,
  distance: distance_default,
  limits,
  valid: valid_default,
  scales: scales_default,
  input: input_default,
  colors: w3cx11_default,
  brewer: colorbrewer_default
});
var chroma_js_default = chroma_default;

// ../settings-component2/dist/helper/overridePrimitiveColors.js
var overridePrimitiveColors = () => {
  const inlangSettings = document.querySelector("inlang-settings");
  if (!inlangSettings)
    return void 0;
  const primitives = ["primary", "success", "warning", "danger", "neutral"];
  for (const primitive of primitives) {
    const unformattedColor = window.getComputedStyle(inlangSettings).getPropertyValue(`--inlang-color-${primitive}`).trim();
    if (unformattedColor !== "") {
      const colorShades = getPalette(unformattedColor);
      appendCSSProperties(colorShades, primitive, inlangSettings);
    }
  }
};
var appendCSSProperties = (colorShades, primitive, element) => {
  let textContent = Object.entries(colorShades).map(([index, shade]) => `--sl-color-${primitive}-${index}: ${shade} !important;`).join("\n");
  textContent = ":host { " + textContent + " }";
  const shadowRoot = element.shadowRoot || element.attachShadow({ mode: "open" });
  const style = document.createElement("style");
  style.textContent = textContent;
  shadowRoot.appendChild(style);
};
var getColor = (unformattedColor) => chroma_js_default(unformattedColor);
var getPalette = (unformattedColor) => {
  const color = getColor(unformattedColor);
  const colors = chroma_js_default.scale(["white", color, "black"]).domain([0, 0.6, 1]).mode("lrgb");
  const palette = {};
  palette[50] = colors(0.05).hex();
  for (let i3 = 0.1; i3 < 0.9; i3 += 0.1) {
    palette[Math.round(i3 * 1e3)] = colors(i3).hex();
  }
  palette[950] = colors(0.95).hex();
  return palette;
};
var overridePrimitiveColors_default = overridePrimitiveColors;

// ../settings-component2/dist/stories/field-header.js
var __decorate = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var FieldHeader = class FieldHeader2 extends h3 {
  constructor() {
    super(...arguments);
    this.optional = false;
  }
  static {
    this.styles = [
      //baseStyling,
      i`
			.header {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
			h3 {
				margin: 0;
				font-size: 14px;
				font-weight: 800;
				line-height: 1.5;
			}
			.help-text {
				font-size: 14px;
				color: var(--sl-input-help-text-color);
				margin: 0;
				line-height: 1.5;
			}
			.optinal {
				font-size: 14px;
				font-style: italic;
				font-weight: 500;
				color: var(--sl-input-help-text-color);
			}
			.example-container {
				display: flex;
				flex-wrap: wrap;
				gap: 4px;
			}
			.example {
				background-color: var(--sl-input-background-color-disabled);
				width: fit-content;
				padding: 0px 6px;
				border-radius: 2px;
				font-size: 14px;
				display: flex;
				align-items: center;
				justify-content: center;
				color: var(--sl-input-color-disabled);
				margin: 0;
				line-height: 1.5;
			}
		`
    ];
  }
  render() {
    return ke` <div class="header">
			${this.fieldTitle && ke`<h3 part="property-title">
				${this.fieldTitle}${this.optional ? ke`<span class="optinal">${" (optional)"}</span>` : ""}
			</h3>`}
			${this.description && ke`<p part="property-paragraph" class="help-text">${this.description}</p>`}
			${this.examples ? ke`<div class="example-container">
						<p class="help-text">Examples:</p>
						${this.examples.map((example) => ke`<p class="example">${example}</p>`)}
				  </div>` : ``}
		</div>`;
  }
};
__decorate([
  n4()
], FieldHeader.prototype, "fieldTitle", void 0);
__decorate([
  n4()
], FieldHeader.prototype, "description", void 0);
__decorate([
  n4({ type: Array })
], FieldHeader.prototype, "examples", void 0);
__decorate([
  n4({ type: Boolean })
], FieldHeader.prototype, "optional", void 0);
FieldHeader = __decorate([
  t2("field-header")
], FieldHeader);

// ../settings-component2/dist/stories/input-fields/string/string-input.js
var __decorate2 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var StringInput = class StringInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = "";
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  static {
    this.styles = [
      i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			h3 {
				margin: 0;
				font-size: 14px;
				font-weight: 800;
			}
			.help-text {
				font-size: 14px;
				color: var(--sl-input-help-text-color);
				margin: 0;
				line-height: 1.5;
			}
			.description-container {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
		`
    ];
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _examples() {
    return this.schema.examples;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  render() {
    return ke` <div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.description=${this._description}
				.examples=${this._examples}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			<sl-input
				value=${this.value}
				size="small"
				@input=${(e5) => {
      this.handleInlangProjectChange(e5.target.value, this.property, this.moduleId);
    }}
			>
			</sl-input>
		</div>`;
  }
};
__decorate2([
  n4()
], StringInput.prototype, "property", void 0);
__decorate2([
  n4()
], StringInput.prototype, "moduleId", void 0);
__decorate2([
  n4()
], StringInput.prototype, "value", void 0);
__decorate2([
  n4()
], StringInput.prototype, "schema", void 0);
__decorate2([
  n4()
], StringInput.prototype, "required", void 0);
__decorate2([
  n4()
], StringInput.prototype, "handleInlangProjectChange", void 0);
StringInput = __decorate2([
  t2("string-input")
], StringInput);

// ../settings-component2/dist/stories/input-fields/array/default-array-input.js
var __decorate3 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var DefaultArrayInput = class DefaultArrayInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = [];
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
    this._inputValue = void 0;
  }
  static {
    this.styles = [
      i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.item-container {
				display: flex;
				flex-direction: column;
				gap: 4px;
				padding-bottom: 8px;
			}
			.disabled-input::part(base) {
				cursor: unset;
				opacity: 1;
			}
			.disabled-input::part(suffix) {
				cursor: pointer;
				opacity: 0.5;
			}
			.disabled-input::part(suffix):hover {
				opacity: 1;
			}
			.add-input {
				flex-grow: 1;
			}
			.add-input::part(suffix) {
				cursor: pointer;
			}
			.new-line-container {
				display: flex;
				gap: 4px;
			}
			.icon-wrapper {
				display: flex;
			}
		`
    ];
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  handleInputChange(e5) {
    const inputElement = e5.target;
    this._inputValue = inputElement.value;
  }
  handleAddItemClick() {
    if (this._inputValue && this._inputValue.trim() !== "") {
      this.value ? this.value.push(this._inputValue) : this.value = [this._inputValue];
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
    }
  }
  handleDeleteItemClick(index) {
    if (this.value) {
      this.value.splice(index, 1);
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
    }
  }
  render() {
    return ke`<div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.description=${this._description}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			${this.value && this.value.length > 0 ? ke`<div class="item-container">
						${this.value.map((arrayItem, index) => {
      return ke`<sl-input
								class="disabled-input"
								size="small"
								value=${arrayItem}
								disabled
								filled
							>
								<div
									slot="suffix"
									class="icon-wrapper"
									@click=${() => {
        this.handleDeleteItemClick(index);
      }}
								>
									<svg class="icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
										<path
											xmlns="http://www.w3.org/2000/svg"
											d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"
										/>
									</svg>
								</div>
							</sl-input>`;
    })}
				  </div>` : void 0}
			<div class="new-line-container">
				<sl-input
					class="add-input"
					size="small"
					placeholder="Add new item"
					@input=${(e5) => this.handleInputChange(e5)}
					@keydown=${(e5) => {
      if (e5.key === "Enter") {
        this.handleAddItemClick();
      }
    }}
					value=${this._inputValue}
				>
				</sl-input>
				<sl-button
					exportparts="base:button"
					size="small"
					variant="neutral"
					@click=${() => {
      this.handleAddItemClick();
    }}
				>
					Add
				</sl-button>
			</div>
		</div>`;
  }
};
__decorate3([
  n4()
], DefaultArrayInput.prototype, "property", void 0);
__decorate3([
  n4()
], DefaultArrayInput.prototype, "moduleId", void 0);
__decorate3([
  n4()
], DefaultArrayInput.prototype, "value", void 0);
__decorate3([
  n4()
], DefaultArrayInput.prototype, "schema", void 0);
__decorate3([
  n4()
], DefaultArrayInput.prototype, "required", void 0);
__decorate3([
  n4()
], DefaultArrayInput.prototype, "handleInlangProjectChange", void 0);
__decorate3([
  r4()
], DefaultArrayInput.prototype, "_inputValue", void 0);
DefaultArrayInput = __decorate3([
  t2("default-array-input")
], DefaultArrayInput);

// ../settings-component2/dist/stories/input-fields/array/locale-input.js
var __decorate4 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var LocaleInput = class LocaleInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = [];
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
    this._inputValue = void 0;
  }
  static {
    this.styles = [
      i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.tags-container {
				display: flex;
				flex-wrap: wrap;
				gap: 4px;
			}
			.disabled-input::part(base) {
				cursor: unset;
				opacity: 1;
			}
			.disabled-input::part(suffix) {
				cursor: pointer;
				opacity: 0.5;
			}
			.disabled-input::part(suffix):hover {
				opacity: 1;
			}
			.add-input {
				flex-grow: 1;
			}
			.add-input::part(suffix) {
				cursor: pointer;
			}
			.new-line-container {
				display: flex;
				gap: 4px;
			}
			sl-tag::part(base) {
				background-color: var(--sl-input-filled-background-color-disabled);
				color: var(--sl-input-color);
				border-color: transparent;
				border-radius: var(--sl-input-border-radius-small);
			}
			sl-tag::part(remove-button) {
				color: var(--sl-input-placeholder-color);
			}
			sl-tag::part(remove-button):hover {
				color: var(--sl-input-color);
			}
		`
    ];
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  handleInputChange(e5) {
    const inputElement = e5.target;
    this._inputValue = inputElement.value;
  }
  handleAddItemClick() {
    if (this._inputValue && this._inputValue.trim() !== "") {
      this.value ? this.value.push(this._inputValue) : this.value = [this._inputValue];
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
    }
  }
  handleDeleteItemClick(index) {
    if (this.value) {
      this.value.splice(index, 1);
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
    }
  }
  render() {
    return ke`<div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.description=${this._description}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			<div class="tags-container">
				${this.value && this.value.map((arrayItem, index) => {
      return ke`
						<sl-tag
							@sl-remove=${() => {
        this.handleDeleteItemClick(index);
      }}
							removable
							size="small"
							>${arrayItem}</sl-tag
						>
					`;
    })}
			</div>
			<div class="new-line-container">
				<sl-input
					class="add-input"
					size="small"
					placeholder="Enter locale ..."
					@input=${(e5) => this.handleInputChange(e5)}
					@keydown=${(e5) => {
      if (e5.key === "Enter") {
        this.handleAddItemClick();
      }
    }}
					value=${this._inputValue}
				>
				</sl-input>
				<sl-button
					exportparts="base:button"
					size="small"
					variant="neutral"
					@click=${() => {
      this.handleAddItemClick();
    }}
				>
					Add
				</sl-button>
			</div>
		</div>`;
  }
};
__decorate4([
  n4()
], LocaleInput.prototype, "property", void 0);
__decorate4([
  n4()
], LocaleInput.prototype, "moduleId", void 0);
__decorate4([
  n4()
], LocaleInput.prototype, "value", void 0);
__decorate4([
  n4()
], LocaleInput.prototype, "schema", void 0);
__decorate4([
  n4()
], LocaleInput.prototype, "required", void 0);
__decorate4([
  n4()
], LocaleInput.prototype, "handleInlangProjectChange", void 0);
__decorate4([
  r4()
], LocaleInput.prototype, "_inputValue", void 0);
LocaleInput = __decorate4([
  t2("locale-input")
], LocaleInput);

// ../settings-component2/dist/stories/input-fields/array/reference-pattern-input.js
var __decorate5 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var ReferencePatternInput = class ReferencePatternInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = [];
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  static {
    this.styles = [
      i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.disabled-input::part(base) {
				cursor: unset;
				opacity: 1;
			}
			.disabled-input::part(suffix) {
				cursor: pointer;
				opacity: 0.5;
			}
			.disabled-input::part(suffix):hover {
				opacity: 1;
			}
			.add-input::part(form-control-label) {
				color: var(--sl-input-help-text-color);
				font-size: 0.8rem;
				padding-left: 0.2rem;
				padding-bottom: 0.2rem;
			}
			.add-input {
				flex-grow: 1;
			}
			.add-input::part(suffix) {
				cursor: pointer;
			}
			.new-line-container {
				display: flex;
				gap: 4px;
			}
			sl-input::part(input) {
				width: inherit;
			}
		`
    ];
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  get _examples() {
    return this.schema.examples;
  }
  render() {
    return ke`<div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.description=${this._description}
				.examples=${this._examples}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			<div class="new-line-container">
				<sl-input
					class="add-input"
					size="small"
					label="Opening pattern"
					placeholder="Enter pattern ..."
					value=${this.value ? this.value[0] : ""}
					@input=${(e5) => {
      if (this.value === void 0)
        this.value = [];
      this.value[0] = e5.target.value;
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
    }}
				>
				</sl-input>
				<sl-input
					class="add-input"
					size="small"
					label="Closing pattern"
					placeholder="Enter pattern ..."
					?disabled=${!this.value}
					value=${this.value ? this.value[1] : ""}
					@input=${(e5) => {
      if (this.value === void 0)
        this.value = [];
      this.value[1] = e5.target.value;
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
    }}
				>
				</sl-input>
			</div>
		</div>`;
  }
};
__decorate5([
  n4()
], ReferencePatternInput.prototype, "property", void 0);
__decorate5([
  n4()
], ReferencePatternInput.prototype, "moduleId", void 0);
__decorate5([
  n4()
], ReferencePatternInput.prototype, "value", void 0);
__decorate5([
  n4()
], ReferencePatternInput.prototype, "schema", void 0);
__decorate5([
  n4()
], ReferencePatternInput.prototype, "required", void 0);
__decorate5([
  n4()
], ReferencePatternInput.prototype, "handleInlangProjectChange", void 0);
ReferencePatternInput = __decorate5([
  t2("reference-pattern-input")
], ReferencePatternInput);

// ../settings-component2/dist/stories/input-fields/array/array-input.js
var __decorate6 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var ArrayInput = class ArrayInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = [];
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  render() {
    const schemaPattern = this.schema.items.pattern;
    if (schemaPattern && schemaPattern === "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$") {
      return ke`
				<locale-input
					exportparts="property, property-title, property-paragraph, button"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></locale-input>
			`;
    } else if (this.property === "variableReferencePattern") {
      return ke`
				<reference-pattern-input
					exportparts="property, property-title, property-paragraph"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></reference-pattern-input>
			`;
    } else {
      return ke`
				<default-array-input
					exportparts="property, property-title, property-paragraph, button"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></default-array-input>
			`;
    }
  }
};
__decorate6([
  n4()
], ArrayInput.prototype, "property", void 0);
__decorate6([
  n4()
], ArrayInput.prototype, "moduleId", void 0);
__decorate6([
  n4()
], ArrayInput.prototype, "modules", void 0);
__decorate6([
  n4()
], ArrayInput.prototype, "value", void 0);
__decorate6([
  n4()
], ArrayInput.prototype, "schema", void 0);
__decorate6([
  n4()
], ArrayInput.prototype, "required", void 0);
__decorate6([
  n4()
], ArrayInput.prototype, "handleInlangProjectChange", void 0);
ArrayInput = __decorate6([
  t2("array-input")
], ArrayInput);

// ../settings-component2/dist/stories/input-fields/object/default-object-input.js
var __decorate7 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var DefaultObjectInput = class DefaultObjectInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.keyPlaceholder = "Enter key";
    this.valuePlaceholder = "Enter value";
    this.value = {};
    this.schema = {};
    this.withTitle = true;
    this.withDescription = true;
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
    this._inputValue = void 0;
    this._inputKey = void 0;
  }
  static {
    this.styles = [
      i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.disabled-input::part(base) {
				cursor: unset;
				opacity: 1;
			}
			.disabled-input::part(suffix) {
				cursor: pointer;
				opacity: 0.5;
			}
			.disabled-input::part(suffix):hover {
				opacity: 1;
			}
			.add-input::part(suffix) {
				cursor: pointer;
			}
			.add-item-container {
				display: flex;
				align-items: center;
				gap: 4px;
			}
			.add-item-side {
				flex-grow: 1;
			}
			.remove-icon {
				width: 44px;
				display: flex;
				justify-content: flex-start;
				margin-left: 6px;
				cursor: pointer;
				color: var(--sl-input-placeholder-color);
			}
			.remove-icon:hover {
				color: var(--sl-input-color);
			}
			.list-container {
				display: flex;
				flex-direction: column;
				gap: 3px;
				padding-bottom: 8px;
			}
			.icon {
				padding-top: 0.5rem;
			}
			sl-input::part(input) {
				width: inherit;
			}
		`
    ];
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  handleAddItemClick() {
    if (this._inputValue && this._inputKey && this._inputValue.trim() !== "" && this._inputKey.trim() !== "") {
      if (!this.value) {
        this.value = {};
      }
      this.value[this._inputKey] = this._inputValue;
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
      this._inputKey = "null";
      this._inputKey = void 0;
    }
  }
  handleDeleteItemClick(key) {
    if (this.value) {
      delete this.value[key];
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
      this._inputKey = "null";
      this._inputKey = void 0;
    }
  }
  render() {
    return ke` <div part="property" class="property">
			<field-header
				.fieldTitle=${this.withTitle ? this._title ? this._title : this.property : void 0}
				.description=${this.withDescription ? this._description : ``}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			${this.value ? ke`<div class="list-container">
						${this.value && Object.entries(this.value).map(([key, value]) => {
      return ke`<div class="add-item-container">
								<sl-input
									class="disabled-input add-item-side"
									size="small"
									value=${key}
									disabled
									filled
								>
								</sl-input>
								<sl-input
									class="disabled-input add-item-side"
									size="small"
									value=${value}
									disabled
									filled
								>
								</sl-input>
								<div class="remove-icon">
									<div
										@click=${() => {
        this.handleDeleteItemClick(key);
      }}
									>
										<svg
											class="icon"
											width="16"
											height="16"
											fill="currentColor"
											viewBox="0 0 16 16"
										>
											<path
												xmlns="http://www.w3.org/2000/svg"
												d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"
											/>
										</svg>
									</div>
								</div>
							</div>`;
    })}
				  </div>` : ``}
			<div class="add-item-container">
				<sl-input
					class="add-item-side"
					placeholder=${this.keyPlaceholder}
					size="small"
					@input=${(e5) => {
      this._inputKey = e5.target.value;
    }}
					@keydown=${(e5) => {
      if (e5.key === "Enter") {
        this.handleAddItemClick();
      }
    }}
					value=${this._inputKey}
				>
				</sl-input>
				<sl-input
					class="add-item-side"
					placeholder=${this.valuePlaceholder}
					size="small"
					@input=${(e5) => {
      this._inputValue = e5.target.value;
    }}
					@keydown=${(e5) => {
      if (e5.key === "Enter") {
        this.handleAddItemClick();
      }
    }}
					value=${this._inputValue}
				>
				</sl-input>
				<sl-button
					exportparts="base:button"
					size="small"
					variant="neutral"
					@click=${() => {
      this.handleAddItemClick();
    }}
				>
					Add
				</sl-button>
			</div>
		</div>`;
  }
};
__decorate7([
  n4()
], DefaultObjectInput.prototype, "property", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "keyPlaceholder", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "valuePlaceholder", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "moduleId", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "value", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "schema", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "withTitle", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "withDescription", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "required", void 0);
__decorate7([
  n4()
], DefaultObjectInput.prototype, "handleInlangProjectChange", void 0);
__decorate7([
  r4()
], DefaultObjectInput.prototype, "_inputValue", void 0);
__decorate7([
  r4()
], DefaultObjectInput.prototype, "_inputKey", void 0);
DefaultObjectInput = __decorate7([
  t2("default-object-input")
], DefaultObjectInput);

// ../settings-component2/dist/stories/input-fields/object/lint-rule-level-object-input.js
var __decorate8 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var LintRuleLevelObjectInput = class LintRuleLevelObjectInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = {};
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  static {
    this.styles = [
      i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.container {
				display: flex;
				flex-direction: column;
				padding-top: 8px;
				gap: 12px;
			}
			.ruleId {
				font-size: 0.8rem;
				margin: 0;
				color: var(--sl-input-color);
			}
			.rule-container {
				display: flex;
				align-items: center;
				gap: 12px;
				flex-wrap: wrap;
			}
			.select {
				max-width: 140px;
				min-width: 100px;
			}
			.title-container {
				display: flex;
				gap: 8px;
			}
			sl-select::part(expand-icon) {
				color: var(--sl-input-placeholder-color);
			}
			sl-select::part(expand-icon):hover {
				color: var(--sl-input-color);
			}
			sl-select::part(base):hover {
				border: var(--sl-input-placeholder-color);
			}
			.level-icon {
				color: var(--sl-color-neutral-400);
				margin-top: 1px;
				margin-right: 6px;
			}
			.level-icon.danger {
				color: var(--sl-color-danger-600);
			}
		`
    ];
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  get _valueOptions() {
    const valuesOptions = Object.values(this.schema.patternProperties)[0]?.anyOf;
    return valuesOptions ? valuesOptions : void 0;
  }
  handleUpdate(key, value) {
    if (key && value) {
      if (!this.value) {
        this.value = {};
      }
      this.value[key] = value;
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
    }
  }
  async update(changedProperties) {
    super.update(changedProperties);
    if (changedProperties.has("value")) {
      await this.updateComplete;
      const newValue = changedProperties.get("value");
      if (newValue) {
        for (const moduleId of Object.keys(newValue)) {
          const slSelect = this.shadowRoot?.getElementById(moduleId);
          if (slSelect) {
            const input = slSelect.shadowRoot?.querySelector(".select__display-input");
            if (input && input.value) {
              input.value = this.value[moduleId] ? this.value[moduleId] : "warning";
            }
          }
        }
      }
    }
  }
  render() {
    return this.modules && this.modules.some((module) => module.id.split(".")[0] !== "plugin") ? ke` <div part="property" class="property">
					<div class="title-container">
						<field-header
							.fieldTitle=${this._title ? this._title : this.property}
							.description=${this._description}
							.optional=${this.required ? false : true}
							exportparts="property-title, property-paragraph"
						></field-header>
					</div>
					<div class="container">
						${this.modules && this.modules.map((module) => {
      return module.id.split(".")[0] !== "plugin" ? ke`<div class="rule-container">
										<sl-select
											id=${module.id}
											exportparts="listbox:option-wrapper"
											value=${this.value ? this.value[module.id] : "warning"}
											placeholder="warning"
											class="select"
											size="small"
											@sl-change=${(e5) => {
        this.handleUpdate(module.id, e5.target.value);
      }}
										>
											${this.value[module.id] === "error" ? ke`<svg
														class="level-icon danger"
														slot="prefix"
														width="20"
														height="20"
														viewBox="0 0 24 24"
												  >
														<path
															fill="currentColor"
															d="M12 17q.425 0 .713-.288T13 16t-.288-.712T12 15t-.712.288T11 16t.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7t-.712.288T11 8v4q0 .425.288.713T12 13m0 9q-2.075 0-3.9-.788t-3.175-2.137T2.788 15.9T2 12t.788-3.9t2.137-3.175T8.1 2.788T12 2t3.9.788t3.175 2.137T21.213 8.1T22 12t-.788 3.9t-2.137 3.175t-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12t-2.325-5.675T12 4T6.325 6.325T4 12t2.325 5.675T12 20m0-8"
														/>
												  </svg>` : ke`<svg
														class="level-icon"
														slot="prefix"
														width="20"
														height="20"
														viewBox="0 0 24 24"
												  >
														<path
															fill="currentColor"
															d="M12 17q.425 0 .713-.288T13 16t-.288-.712T12 15t-.712.288T11 16t.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7t-.712.288T11 8v4q0 .425.288.713T12 13m0 9q-2.075 0-3.9-.788t-3.175-2.137T2.788 15.9T2 12t.788-3.9t2.137-3.175T8.1 2.788T12 2t3.9.788t3.175 2.137T21.213 8.1T22 12t-.788 3.9t-2.137 3.175t-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12t-2.325-5.675T12 4T6.325 6.325T4 12t2.325 5.675T12 20m0-8"
														/>
												  </svg>`}
											${this._valueOptions?.map((option) => {
        return ke`<sl-option
													exportparts="base:option"
													value=${option.const}
													class="add-item-side"
												>
													${option.const}
												</sl-option>`;
      })}
										</sl-select>
										<p class="ruleId">${module.displayName.en}</p>
								  </div>` : void 0;
    })}
					</div>
			  </div>` : void 0;
  }
};
__decorate8([
  n4()
], LintRuleLevelObjectInput.prototype, "property", void 0);
__decorate8([
  n4()
], LintRuleLevelObjectInput.prototype, "moduleId", void 0);
__decorate8([
  n4()
], LintRuleLevelObjectInput.prototype, "modules", void 0);
__decorate8([
  n4()
], LintRuleLevelObjectInput.prototype, "value", void 0);
__decorate8([
  n4()
], LintRuleLevelObjectInput.prototype, "schema", void 0);
__decorate8([
  n4()
], LintRuleLevelObjectInput.prototype, "required", void 0);
__decorate8([
  n4()
], LintRuleLevelObjectInput.prototype, "handleInlangProjectChange", void 0);
LintRuleLevelObjectInput = __decorate8([
  t2("lint-rule-level-object-input")
], LintRuleLevelObjectInput);

// ../settings-component2/dist/stories/input-fields/object/object-input.js
var __decorate9 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var ObjectInput = class ObjectInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = {};
    this.schema = {};
    this.withTitle = true;
    this.withDescription = true;
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  render() {
    if (this.property === "messageLintRuleLevels") {
      return ke`<lint-rule-level-object-input
				exportparts="property, property-title, property-paragraph, option, option-wrapper"
				.property=${this.property}
				.moduleId=${this.moduleId}
				.modules=${this.modules}
				.value=${this.value}
				.schema=${this.schema}
				.handleInlangProjectChange=${this.handleInlangProjectChange}
				.required=${this.required}
			></lint-rule-level-object-input>`;
    } else {
      return ke`<default-object-input
				exportparts="property, property-title, property-paragraph, button"
				.property=${this.property}
				.moduleId=${this.moduleId}
				.value=${this.value}
				.schema=${this.schema}
				.keyPlaceholder=${this.keyPlaceholder}
				.valuePlaceholder=${this.valuePlaceholder}
				.handleInlangProjectChange=${this.handleInlangProjectChange}
				.withTitle=${this.withTitle}
				.withDescription=${this.withDescription}
				.required=${this.required}
			></default-object-input>`;
    }
  }
};
__decorate9([
  n4()
], ObjectInput.prototype, "property", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "moduleId", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "modules", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "keyPlaceholder", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "valuePlaceholder", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "value", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "schema", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "withTitle", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "withDescription", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "required", void 0);
__decorate9([
  n4()
], ObjectInput.prototype, "handleInlangProjectChange", void 0);
ObjectInput = __decorate9([
  t2("object-input")
], ObjectInput);

// ../settings-component2/dist/stories/input-fields/union/path-pattern-input.js
var __decorate10 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var PathPatternInput = class PathPatternInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = "";
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
    this._isObject = void 0;
    this._isInitialized = false;
  }
  static {
    this.styles = [
      i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			sl-checkbox::part(base) {
				font-size: 14px;
				color: var(--sl-input-help-text-color);
			}
			.description-container {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
		`
    ];
  }
  get _descriptionObject() {
    if (this.schema.description) {
      return this.schema.description;
    } else {
      return "Specify the pathPattern to locate language files of specific namespaces in your repository. The namespace is a string taht shouldn't include '.', the path must include `{languageTag}` and end with `.json`.";
    }
  }
  get _examplesObject() {
    return [
      '{ common: "./locales/{languageTag}/common.json", app: "./locales/{languageTag}/app.json" }'
    ];
  }
  get _descriptionString() {
    if (this.schema.description) {
      return this.schema.description;
    } else {
      return this.schema.anyOf[0].description || void 0;
    }
  }
  get _examplesString() {
    return this.schema.anyOf[0].examples;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  render() {
    if (this._isInitialized === false) {
      if (typeof this.value === "object") {
        this._isObject = true;
      } else {
        this._isObject = false;
      }
      this._isInitialized = true;
    }
    return ke` <div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.optional=${this.required ? false : true}
				exportparts="property-title"
			></field-header>
			<sl-checkbox
				?checked=${this._isObject}
				@input=${(e5) => {
      if (e5.target.checked) {
        this._isObject = true;
      } else {
        this._isObject = false;
      }
    }}
				>with namespaces</sl-checkbox
			>
			${this._isObject ? ke`<div part="property" class="property">
						<field-header
							.description=${this._descriptionObject}
							.examples=${this._examplesObject}
							.optional=${this.required ? false : true}
							exportparts="property-title, property-paragraph"
						></field-header>
						<object-input
							exportparts="button"
							.value=${typeof this.value === "object" ? this.value : ""}
							.keyPlaceholder=${"Namespace"}
							.valuePlaceholder=${"Path to resource [./**/*.json]"}
							.handleInlangProjectChange=${this.handleInlangProjectChange}
							.property=${this.property}
							.moduleId=${this.moduleId}
							.schema=${this.schema}
							.withTitle=${false}
							.withDescription=${false}
							.required=${this.required}
						>
						</object-input>
				  </div>` : ke`<div part="property" class="property">
						<field-header
							.description=${this._descriptionString}
							.examples=${this._examplesString}
							.optional=${this.required ? false : true}
							exportparts="property-title, property-paragraph"
						></field-header>
						<sl-input
							value=${typeof this.value === "object" ? "" : this.value}
							size="small"
							placeholder="Path to resource [./**/*.json]"
							@input=${(e5) => {
      this.handleInlangProjectChange(e5.target.value, this.property, this.moduleId);
    }}
						>
						</sl-input>
				  </div>`}
		</div>`;
  }
};
__decorate10([
  n4()
], PathPatternInput.prototype, "property", void 0);
__decorate10([
  n4()
], PathPatternInput.prototype, "moduleId", void 0);
__decorate10([
  n4()
], PathPatternInput.prototype, "value", void 0);
__decorate10([
  n4()
], PathPatternInput.prototype, "schema", void 0);
__decorate10([
  n4()
], PathPatternInput.prototype, "required", void 0);
__decorate10([
  n4()
], PathPatternInput.prototype, "handleInlangProjectChange", void 0);
__decorate10([
  r4()
], PathPatternInput.prototype, "_isObject", void 0);
__decorate10([
  r4()
], PathPatternInput.prototype, "_isInitialized", void 0);
PathPatternInput = __decorate10([
  t2("path-pattern-input")
], PathPatternInput);

// ../settings-component2/dist/stories/input-fields/general-input.js
var __decorate11 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
var GeneralInput = class GeneralInput2 extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = "";
    this.schema = {};
    this.required = {};
    this.handleInlangProjectChange = () => {
    };
  }
  render() {
    if (this.schema.type) {
      if (this.schema.type === "string") {
        return ke` <div>
					<string-input
						exportparts="property, property-title, property-paragraph"
						.property=${this.property}
						.moduleId=${this.moduleId}
						.value=${this.value}
						.schema=${this.schema}
						.handleInlangProjectChange=${this.handleInlangProjectChange}
						.required=${this.required}
					></string-input>
				</div>`;
      } else if (this.schema.type === "array") {
        return ke` <div>
					<array-input
						exportparts="property, property-title, property-paragraph, button"
						.property=${this.property}
						.moduleId=${this.moduleId}
						.modules=${this.modules}
						.value=${this.value}
						.schema=${this.schema}
						.handleInlangProjectChange=${this.handleInlangProjectChange}
						.required=${this.required}
					></array-input>
				</div>`;
      } else if (this.schema.type === "object") {
        return ke` <div>
					<object-input
						exportparts="property, property-title, property-paragraph, option, option-wrapper, button"
						.property=${this.property}
						.moduleId=${this.moduleId}
						.modules=${this.modules}
						.value=${this.value}
						.schema=${this.schema}
						.handleInlangProjectChange=${this.handleInlangProjectChange}
						.required=${this.required}
						.withTitle=${true}
						.withDescription=${true}
						.keyPlaceholder=${"Enter key"}
						.valuePlaceholder=${"Enter value"}
					></object-input>
				</div>`;
      } else {
        return ke` <div>
					<string-input
						exportparts="property, property-title, property-paragraph"
						.property=${this.property}
						.moduleId=${this.moduleId}
						.value=${this.value}
						.schema=${this.schema}
						.handleInlangProjectChange=${this.handleInlangProjectChange}
						.required=${this.required}
					></string-input>
				</div>`;
      }
    } else if (this.property === "pathPattern" || this.property === "sourceLanguageFilePath") {
      return ke` <div>
				<path-pattern-input
					exportparts="property, property-title, property-paragraph, button"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></path-pattern-input>
			</div>`;
    } else {
      return ke` <div>
				<string-input
					exportparts="property, property-title, property-paragraph"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></string-input>
			</div>`;
    }
  }
};
__decorate11([
  n4()
], GeneralInput.prototype, "property", void 0);
__decorate11([
  n4()
], GeneralInput.prototype, "moduleId", void 0);
__decorate11([
  n4()
], GeneralInput.prototype, "modules", void 0);
__decorate11([
  n4()
], GeneralInput.prototype, "value", void 0);
__decorate11([
  n4()
], GeneralInput.prototype, "schema", void 0);
__decorate11([
  n4()
], GeneralInput.prototype, "required", void 0);
__decorate11([
  n4()
], GeneralInput.prototype, "handleInlangProjectChange", void 0);
GeneralInput = __decorate11([
  t2("general-input")
], GeneralInput);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.V2OL7VMD.js
var tag_styles_default = i`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6I2T3DLI.js
var icon_button_styles_default = i`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3Y6SB6QS.js
var basePath = "";
function setBasePath(path2) {
  basePath = path2;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s2) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s2.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s2.src);
      });
      let path2 = "";
      if (fallbackScript) {
        path2 = fallbackScript.getAttribute("src");
      }
      setBasePath(path2.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P7ZG6EMR.js
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`)
};
var library_default_default = library;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3TFKS637.js
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZL53POKZ.js
var registry2 = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry2.find((lib) => lib.name === name);
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QLXRCYS4.js
var icon_styles_default = i`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IFDWM6P4.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i3 = decorators.length - 1, decorator; i3 >= 0; i3--)
    if (decorator = decorators[i3])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2FB5TK5H.js
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update2 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update2.call(this, changedProps);
    };
  };
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUVJKY7S.js
var component_styles_default = i`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RVOOE4AQ.js
var ShoelaceElement = class extends h3 {
  constructor() {
    super();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      customElements.define(name, class extends elementConstructor {
      }, options);
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.14.0";
ShoelaceElement.dependencies = {};
__decorateClass([
  n4()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass([
  n4()
], ShoelaceElement.prototype, "lang", 2);

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directive-helpers.js
var { I: et2 } = si;
var nt = (o4, t4) => void 0 === t4 ? void 0 !== o4?._$litType$ : o4?._$litType$ === t4;
var rt = (o4) => void 0 === o4.strings;
var ht = {};
var dt = (o4, t4 = ht) => o4._$AH = t4;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7YG67M3U.js
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library2) {
    var _a;
    let fileData;
    if (library2 == null ? void 0 : library2.spriteSheet) {
      return ke`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e5) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR;
      if (!parser)
        parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e5) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return {
        url: library2.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a;
    const { url, fromLibrary } = this.getIconSource();
    const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library2);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (nt(svg)) {
      this.svg = svg;
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a = library2 == null ? void 0 : library2.mutator) == null ? void 0 : _a.call(library2, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([
  r4()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  n4({ reflect: true })
], SlIcon.prototype, "name", 2);
__decorateClass([
  n4()
], SlIcon.prototype, "src", 2);
__decorateClass([
  n4()
], SlIcon.prototype, "label", 2);
__decorateClass([
  n4({ reflect: true })
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directive.js
var t3 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e4 = (t4) => (...e5) => ({ _$litDirective$: t4, values: e5 });
var i2 = class {
  constructor(t4) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t4, e5, i3) {
    this.t = t4, this._$AM = e5, this.i = i3;
  }
  _$AS(t4, e5) {
    return this.update(t4, e5);
  }
  update(t4, e5) {
    return this.render(...e5);
  }
};

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/class-map.js
var Rt = e4(class extends i2 {
  constructor(s2) {
    if (super(s2), s2.type !== t3.ATTRIBUTE || "class" !== s2.name || s2.strings?.length > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t4) {
    return " " + Object.keys(t4).filter((s2) => t4[s2]).join(" ") + " ";
  }
  update(t4, [s2]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t4.strings && (this.nt = new Set(t4.strings.join(" ").split(/\s/).filter((t5) => "" !== t5)));
      for (const t5 in s2)
        s2[t5] && !this.nt?.has(t5) && this.st.add(t5);
      return this.render(s2);
    }
    const i3 = t4.element.classList;
    for (const t5 of this.st)
      t5 in s2 || (i3.remove(t5), this.st.delete(t5));
    for (const t5 in s2) {
      const r5 = !!s2[t5];
      r5 === this.st.has(t5) || this.nt?.has(t5) || (r5 ? (i3.add(t5), this.st.add(t5)) : (i3.remove(t5), this.st.delete(t5)));
    }
    return R;
  }
});

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/static.js
var $e = Symbol.for("");
var xe = (t4) => {
  if (t4?.r === $e)
    return t4?._$litStatic$;
};
var er = (t4, ...r5) => ({ _$litStatic$: r5.reduce((r6, e5, a2) => r6 + ((t5) => {
  if (void 0 !== t5._$litStatic$)
    return t5._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t5}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e5) + t4[a2 + 1], t4[0]), r: $e });
var Te = /* @__PURE__ */ new Map();
var Ee = (t4) => (r5, ...e5) => {
  const a2 = e5.length;
  let o4, s2;
  const i3 = [], l2 = [];
  let n5, u2 = 0, c4 = false;
  for (; u2 < a2; ) {
    for (n5 = r5[u2]; u2 < a2 && void 0 !== (s2 = e5[u2], o4 = xe(s2)); )
      n5 += o4 + r5[++u2], c4 = true;
    u2 !== a2 && l2.push(s2), i3.push(n5), u2++;
  }
  if (u2 === a2 && i3.push(r5[a2]), c4) {
    const t5 = i3.join("$$lit$$");
    void 0 === (r5 = Te.get(t5)) && (i3.raw = i3, Te.set(t5, r5 = i3)), e5 = l2;
  }
  return t4(r5, ...e5);
};
var ke2 = Ee(ke);
var Oe2 = Ee(Oe);
var Se2 = Ee(Se);

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/if-defined.js
var to = (t4) => t4 ?? D;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7XLSSP47.js
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? er`a` : er`button`;
    return ke2`
      <${tag}
        part="base"
        class=${Rt({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : "button")}
        href=${to(isLink ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${to(this.name)}
          library=${to(this.library)}
          src=${to(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e3(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass([
  r4()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "name", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "library", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "src", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "href", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "target", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "download", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "label", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);

// ../../../node_modules/.pnpm/@shoelace-style+localize@3.2.1/node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var translations = /* @__PURE__ */ new Map();
var fallback;
var documentDirection = "ltr";
var documentLanguage = "en";
var isClient = typeof MutationObserver !== "undefined" && typeof document !== "undefined" && typeof document.documentElement !== "undefined";
if (isClient) {
  const documentElementObserver = new MutationObserver(update);
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  documentElementObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["dir", "lang"]
  });
}
function registerTranslation(...translation2) {
  translation2.map((t4) => {
    const code = t4.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t4));
    } else {
      translations.set(code, t4);
    }
    if (!fallback) {
      fallback = t4;
    }
  });
  update();
}
function update() {
  if (isClient) {
    documentDirection = document.documentElement.dir || "ltr";
    documentLanguage = document.documentElement.lang || navigator.language;
  }
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a;
    const { primary, secondary } = this.getTranslationData((_a = options.lang) !== null && _a !== void 0 ? _a : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MAS2SHYD.js
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num2) => {
    if (num2 === 0)
      return "No options selected";
    if (num2 === 1)
      return "1 option selected";
    return `${num2} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WLV3FVBR.js
var LocalizeController2 = class extends LocalizeController {
};
registerTranslation(en_default);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7J6CPMBU.js
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return ke`
      <span
        part="base"
        class=${Rt({
      tag: true,
      // Types
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      // Sizes
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      // Modifiers
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? ke`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  n4({ reflect: true })
], SlTag.prototype, "variant", 2);
__decorateClass([
  n4({ reflect: true })
], SlTag.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlTag.prototype, "pill", 2);
__decorateClass([
  n4({ type: Boolean })
], SlTag.prototype, "removable", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AN6YZWTU.js
var select_styles_default = i`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix */
  .select__prefix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RK73WSZS.js
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset3 = getOffset(element, container);
  const offsetTop = offset3.top + container.scrollTop;
  const offsetLeft = offset3.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SI4ACBFK.js
var form_control_styles_default = i`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GI7VDIWX.js
var defaultValue = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || b;
      const fromAttribute = typeof converter === "function" ? converter : (_a = converter == null ? void 0 : converter.fromAttribute) != null ? _a : b.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3KSWVBQ5.js
var popup_styles_default = i`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

// ../../../node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min5 = Math.min;
var max5 = Math.max;
var round8 = Math.round;
var floor5 = Math.floor;
var createCoords = (v3) => ({
  x: v3,
  y: v3
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max5(start, min5(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}

// ../../../node_modules/.pnpm/@floating-ui+core@1.6.7/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const {
      name,
      fn
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent2 = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent2)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent2)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent: offsetParent2,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min5(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min5(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max6 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max6);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max6 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min6 = mainAxisCoord + overflow[minSide];
        const max6 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min6, mainAxisCoord, max6);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min6 = crossAxisCoord + overflow[minSide];
        const max6 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min6, crossAxisCoord, max6);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min5(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min5(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min5(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min5(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max5(overflow.left, 0);
        const xMax = max5(overflow.right, 0);
        const yMin = max5(overflow.top, 0);
        const yMax = max5(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max5(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max5(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../../node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e5) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../../node_modules/.pnpm/@floating-ui+dom@1.6.10/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round8(width) !== offsetWidth || round8(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round8(rect.width) : rect.width) / width;
  let y2 = ($2 ? round8(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent2) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent2) {
      if (isElement(offsetParent2)) {
        scale = getScale(offsetParent2);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent2) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent2 && isElement(offsetParent2) ? getWindow(offsetParent2) : offsetParent2;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent2 && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent: offsetParent2,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent2);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent2 === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent2);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent2) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent2);
    }
    if (isHTMLElement(offsetParent2)) {
      const offsetRect = getBoundingClientRect(offsetParent2);
      scale = getScale(offsetParent2);
      offsets.x = offsetRect.x + offsetParent2.clientLeft;
      offsets.y = offsetRect.y + offsetParent2.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max5(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max5(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max5(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max5(rect.top, accRect.top);
    accRect.right = min5(rect.right, accRect.right);
    accRect.bottom = min5(rect.bottom, accRect.bottom);
    accRect.left = max5(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent2, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent2);
  const documentElement = getDocumentElement(offsetParent2);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent2);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent2) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent2);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent2, true, isFixed, offsetParent2);
      offsets.x = offsetRect.x + offsetParent2.clientLeft;
      offsets.y = offsetRect.y + offsetParent2.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent2 = getTrueOffsetParent(element, polyfill);
  while (offsetParent2 && isTableElement(offsetParent2) && isStaticPositioned(offsetParent2)) {
    offsetParent2 = getTrueOffsetParent(offsetParent2, polyfill);
  }
  if (offsetParent2 && isLastTraversableNode(offsetParent2) && isStaticPositioned(offsetParent2) && !isContainingBlock(offsetParent2)) {
    return win;
  }
  return offsetParent2 || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor5(top);
    const insetRight = floor5(root.clientWidth - (left + width));
    const insetBottom = floor5(root.clientHeight - (top + height));
    const insetLeft = floor5(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max5(0, min5(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e5) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../../node_modules/.pnpm/composed-offset-position@0.0.4/node_modules/composed-offset-position/dist/composed-offset-position.mjs
function offsetParent(element) {
  return offsetParentPolyfill(element);
}
function flatTreeParent(element) {
  if (element.assignedSlot) {
    return element.assignedSlot;
  }
  if (element.parentNode instanceof ShadowRoot) {
    return element.parentNode.host;
  }
  return element.parentNode;
}
function offsetParentPolyfill(element) {
  for (let ancestor = element; ancestor; ancestor = flatTreeParent(ancestor)) {
    if (!(ancestor instanceof Element)) {
      continue;
    }
    if (getComputedStyle(ancestor).display === "none") {
      return null;
    }
  }
  for (let ancestor = flatTreeParent(element); ancestor; ancestor = flatTreeParent(ancestor)) {
    if (!(ancestor instanceof Element)) {
      continue;
    }
    const style = getComputedStyle(ancestor);
    if (style.display === "contents") {
      continue;
    }
    if (style.position !== "static" || style.filter !== "none") {
      return ancestor;
    }
    if (ancestor.tagName === "BODY") {
      return ancestor;
    }
  }
  return null;
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JLIBGQ2M.js
function isVirtualElement(e5) {
  return e5 !== null && typeof e5 === "object" && "getBoundingClientRect" in e5;
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset2({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size2({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip2({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift2({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size2({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow2({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent2 = this.strategy === "absolute" ? (element) => platform.getOffsetParent(element, offsetParent) : platform.getOffsetParent;
    computePosition2(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: getOffsetParent2
      })
    }).then(({ x: x2, y: y2, middlewareData, placement }) => {
      const isRtl = getComputedStyle(this).direction === "rtl";
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x2}px`,
        top: `${y2}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return ke`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${Rt({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${Rt({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? ke`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([
  e3(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass([
  e3(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass([
  n4()
], SlPopup.prototype, "anchor", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlPopup.prototype, "active", 2);
__decorateClass([
  n4({ reflect: true })
], SlPopup.prototype, "placement", 2);
__decorateClass([
  n4({ reflect: true })
], SlPopup.prototype, "strategy", 2);
__decorateClass([
  n4({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass([
  n4({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass([
  n4({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass([
  n4({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass([
  n4({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p2) => p2.trim()).filter((p2) => p2 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass([
  n4({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass([
  n4({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass([
  n4({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass([
  n4({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass([
  n4()
], SlPopup.prototype, "sync", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass([
  n4({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass([
  n4({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DL5222VR.js
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a = formCollections.get(this.form)) == null ? void 0 : _a.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.getElementById(formId);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a;
        return (_a = input.disabled) != null ? _a : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a;
    return (_a = this.form) != null ? _a : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  customError: true
}));

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DHU6MIVB.js
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B4BZKR24.js
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LHI6QEL2.js
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NYIIDP5N.js
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/unsafe-html.js
var le = class extends i2 {
  constructor(i3) {
    if (super(i3), this.it = D, i3.type !== t3.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t4) {
    if (t4 === D || null == t4)
      return this._t = void 0, this.it = t4;
    if (t4 === R)
      return t4;
    if ("string" != typeof t4)
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t4 === this.it)
      return this._t;
    this.it = t4;
    const i3 = [t4];
    return i3.raw = i3, this._t = { _$litType$: this.constructor.resultType, strings: i3, values: [] };
  }
};
le.directiveName = "unsafeHTML", le.resultType = 1;
var ae = e4(le);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.44XN5ATB.js
var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.typeToSelectString = "";
    this.hasFocus = false;
    this.displayLabel = "";
    this.selectedOptions = [];
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.placeholder = "";
    this.multiple = false;
    this.maxOptionsVisible = 3;
    this.disabled = false;
    this.clearable = false;
    this.open = false;
    this.hoist = false;
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.form = "";
    this.required = false;
    this.getTag = (option) => {
      return ke`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(event) => this.handleTagRemove(event, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
    };
    this.handleDocumentFocusIn = (event) => {
      const path2 = event.composedPath();
      if (this && !path2.includes(this)) {
        this.hide();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      const target = event.target;
      const isClearButton = target.closest(".select__clear") !== null;
      const isIconButton = target.closest("sl-icon-button") !== null;
      if (isClearButton || isIconButton) {
        return;
      }
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.preventDefault();
        event.stopPropagation();
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
      if (event.key === "Enter" || event.key === " " && this.typeToSelectString === "") {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.open) {
          this.show();
          return;
        }
        if (this.currentOption && !this.currentOption.disabled) {
          if (this.multiple) {
            this.toggleOptionSelection(this.currentOption);
          } else {
            this.setSelectedOptions(this.currentOption);
          }
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
          if (!this.multiple) {
            this.hide();
            this.displayInput.focus({ preventScroll: true });
          }
        }
        return;
      }
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
        const allOptions = this.getAllOptions();
        const currentIndex = allOptions.indexOf(this.currentOption);
        let newIndex = Math.max(0, currentIndex);
        event.preventDefault();
        if (!this.open) {
          this.show();
          if (this.currentOption) {
            return;
          }
        }
        if (event.key === "ArrowDown") {
          newIndex = currentIndex + 1;
          if (newIndex > allOptions.length - 1)
            newIndex = 0;
        } else if (event.key === "ArrowUp") {
          newIndex = currentIndex - 1;
          if (newIndex < 0)
            newIndex = allOptions.length - 1;
        } else if (event.key === "Home") {
          newIndex = 0;
        } else if (event.key === "End") {
          newIndex = allOptions.length - 1;
        }
        this.setCurrentOption(allOptions[newIndex]);
      }
      if (event.key.length === 1 || event.key === "Backspace") {
        const allOptions = this.getAllOptions();
        if (event.metaKey || event.ctrlKey || event.altKey) {
          return;
        }
        if (!this.open) {
          if (event.key === "Backspace") {
            return;
          }
          this.show();
        }
        event.stopPropagation();
        event.preventDefault();
        clearTimeout(this.typeToSelectTimeout);
        this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
        if (event.key === "Backspace") {
          this.typeToSelectString = this.typeToSelectString.slice(0, -1);
        } else {
          this.typeToSelectString += event.key.toLowerCase();
        }
        for (const option of allOptions) {
          const label = option.getTextLabel().toLowerCase();
          if (label.startsWith(this.typeToSelectString)) {
            this.setCurrentOption(option);
            break;
          }
        }
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path2 = event.composedPath();
      if (this && !path2.includes(this)) {
        this.hide();
      }
    };
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.open = false;
  }
  addOpenListeners() {
    var _a;
    const root = this.getRootNode();
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        if (this.open) {
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
      };
    }
    root.addEventListener("focusin", this.handleDocumentFocusIn);
    root.addEventListener("keydown", this.handleDocumentKeyDown);
    root.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a;
    const root = this.getRootNode();
    root.removeEventListener("focusin", this.handleDocumentFocusIn);
    root.removeEventListener("keydown", this.handleDocumentKeyDown);
    root.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  handleFocus() {
    this.hasFocus = true;
    this.displayInput.setSelectionRange(0, 0);
    this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(event) {
    const path2 = event.composedPath();
    const isIconButton = path2.some((el) => el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button");
    if (this.disabled || isIconButton) {
      return;
    }
    event.preventDefault();
    this.displayInput.focus({ preventScroll: true });
    this.open = !this.open;
  }
  handleComboboxKeyDown(event) {
    if (event.key === "Tab") {
      return;
    }
    event.stopPropagation();
    this.handleDocumentKeyDown(event);
  }
  handleClearClick(event) {
    event.stopPropagation();
    if (this.value !== "") {
      this.setSelectedOptions([]);
      this.displayInput.focus({ preventScroll: true });
      this.updateComplete.then(() => {
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  handleClearMouseDown(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  handleOptionClick(event) {
    const target = event.target;
    const option = target.closest("sl-option");
    const oldValue = this.value;
    if (option && !option.disabled) {
      if (this.multiple) {
        this.toggleOptionSelection(option);
      } else {
        this.setSelectedOptions(option);
      }
      this.updateComplete.then(() => this.displayInput.focus({ preventScroll: true }));
      if (this.value !== oldValue) {
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
      if (!this.multiple) {
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
    }
  }
  handleDefaultSlotChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    const values = [];
    if (customElements.get("sl-option")) {
      allOptions.forEach((option) => values.push(option.value));
      this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
    } else {
      customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
    }
  }
  handleTagRemove(event, option) {
    event.stopPropagation();
    if (!this.disabled) {
      this.toggleOptionSelection(option, false);
      this.updateComplete.then(() => {
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(option) {
    const allOptions = this.getAllOptions();
    allOptions.forEach((el) => {
      el.current = false;
      el.tabIndex = -1;
    });
    if (option) {
      this.currentOption = option;
      option.current = true;
      option.tabIndex = 0;
      option.focus();
    }
  }
  // Sets the selected option(s)
  setSelectedOptions(option) {
    const allOptions = this.getAllOptions();
    const newSelectedOptions = Array.isArray(option) ? option : [option];
    allOptions.forEach((el) => el.selected = false);
    if (newSelectedOptions.length) {
      newSelectedOptions.forEach((el) => el.selected = true);
    }
    this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(option, force) {
    if (force === true || force === false) {
      option.selected = force;
    } else {
      option.selected = !option.selected;
    }
    this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var _a, _b, _c, _d;
    this.selectedOptions = this.getAllOptions().filter((el) => el.selected);
    if (this.multiple) {
      this.value = this.selectedOptions.map((el) => el.value);
      if (this.placeholder && this.value.length === 0) {
        this.displayLabel = "";
      } else {
        this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length);
      }
    } else {
      this.value = (_b = (_a = this.selectedOptions[0]) == null ? void 0 : _a.value) != null ? _b : "";
      this.displayLabel = (_d = (_c = this.selectedOptions[0]) == null ? void 0 : _c.getTextLabel()) != null ? _d : "";
    }
    this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((option, index) => {
      if (index < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const tag = this.getTag(option, index);
        return ke`<div @sl-remove=${(e5) => this.handleTagRemove(e5, option)}>
          ${typeof tag === "string" ? ae(tag) : tag}
        </div>`;
      } else if (index === this.maxOptionsVisible) {
        return ke`<sl-tag>+${this.selectedOptions.length - index}</sl-tag>`;
      }
      return ke``;
    });
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.open = false;
      this.handleOpenChange();
    }
  }
  handleValueChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.listbox.hidden = false;
      this.popup.active = true;
      requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const { keyframes, options } = getAnimation(this, "select.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      if (this.currentOption) {
        scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
      }
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "select.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.listbox.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.valueInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(options) {
    this.displayInput.focus(options);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && this.value.length > 0;
    const isPlaceholderVisible = this.placeholder && this.value.length === 0;
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${Rt({
      select: true,
      "select--standard": true,
      "select--filled": this.filled,
      "select--pill": this.pill,
      "select--open": this.open,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--focused": this.hasFocus,
      "select--placeholder-visible": isPlaceholderVisible,
      "select--top": this.placement === "top",
      "select--bottom": this.placement === "bottom",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large"
    })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? ke`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${hasClearIcon ? ke`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag
};
__decorateClass([
  e3(".select")
], SlSelect.prototype, "popup", 2);
__decorateClass([
  e3(".select__combobox")
], SlSelect.prototype, "combobox", 2);
__decorateClass([
  e3(".select__display-input")
], SlSelect.prototype, "displayInput", 2);
__decorateClass([
  e3(".select__value-input")
], SlSelect.prototype, "valueInput", 2);
__decorateClass([
  e3(".select__listbox")
], SlSelect.prototype, "listbox", 2);
__decorateClass([
  r4()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass([
  r4()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass([
  r4()
], SlSelect.prototype, "currentOption", 2);
__decorateClass([
  r4()
], SlSelect.prototype, "selectedOptions", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "name", 2);
__decorateClass([
  n4({
    converter: {
      fromAttribute: (value) => value.split(" "),
      toAttribute: (value) => value.join(" ")
    }
  })
], SlSelect.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlSelect.prototype, "defaultValue", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "size", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "placeholder", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "multiple", 2);
__decorateClass([
  n4({ attribute: "max-options-visible", type: Number })
], SlSelect.prototype, "maxOptionsVisible", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "open", 2);
__decorateClass([
  n4({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "filled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "pill", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "label", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "placement", 2);
__decorateClass([
  n4({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "form", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "required", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "getTag", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleValueChange", 1);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleOpenChange", 1);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FXXKMG2P.js
var option_styles_default = i`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWDN2DUL.js
var SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.current = false;
    this.selected = false;
    this.hasHover = false;
    this.value = "";
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "option");
    this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleMouseEnter() {
    this.hasHover = true;
  }
  handleMouseLeave() {
    this.hasHover = false;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    if (this.value.includes(" ")) {
      console.error(`Option values cannot include a space. All spaces have been replaced with underscores.`, this);
      this.value = this.value.replace(/ /g, "_");
    }
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const nodes = this.childNodes;
    let label = "";
    [...nodes].forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!node.hasAttribute("slot")) {
          label += node.textContent;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        label += node.textContent;
      }
    });
    return label.trim();
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      option: true,
      "option--current": this.current,
      "option--disabled": this.disabled,
      "option--selected": this.selected,
      "option--hover": this.hasHover
    })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e3(".option__label")
], SlOption.prototype, "defaultSlot", 2);
__decorateClass([
  r4()
], SlOption.prototype, "current", 2);
__decorateClass([
  r4()
], SlOption.prototype, "selected", 2);
__decorateClass([
  r4()
], SlOption.prototype, "hasHover", 2);
__decorateClass([
  n4({ reflect: true })
], SlOption.prototype, "value", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlOption.prototype, "disabled", 2);
__decorateClass([
  watch("disabled")
], SlOption.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("selected")
], SlOption.prototype, "handleSelectedChange", 1);
__decorateClass([
  watch("value")
], SlOption.prototype, "handleValueChange", 1);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OZYH3LSG.js
var input_styles_default = i`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear:not(.input__clear--visible) {
    visibility: hidden;
  }

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/live.js
var Ft = e4(class extends i2 {
  constructor(r5) {
    if (super(r5), r5.type !== t3.PROPERTY && r5.type !== t3.ATTRIBUTE && r5.type !== t3.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!rt(r5))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(r5) {
    return r5;
  }
  update(r5, [e5]) {
    if (e5 === R || e5 === D)
      return e5;
    const i3 = r5.element, n5 = r5.name;
    if (r5.type === t3.PROPERTY) {
      if (e5 === i3[n5])
        return R;
    } else if (r5.type === t3.BOOLEAN_ATTRIBUTE) {
      if (!!e5 === i3.hasAttribute(n5))
        return R;
    } else if (r5.type === t3.ATTRIBUTE && i3.getAttribute(n5) === e5 + "")
      return R;
    return dt(r5), e5;
  }
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.54TJVTKO.js
var SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.title = "";
    this.__numberInput = Object.assign(document.createElement("input"), { type: "number" });
    this.__dateInput = Object.assign(document.createElement("input"), { type: "date" });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return ((_a = this.input) == null ? void 0 : _a.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a;
    this.__numberInput.value = this.value;
    return ((_a = this.input) == null ? void 0 : _a.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    this.value = "";
    this.emit("sl-clear");
    this.emit("sl-input");
    this.emit("sl-change");
    this.input.focus();
    event.stopPropagation();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible = hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      input: true,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${to(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${to(this.placeholder)}
              minlength=${to(this.minlength)}
              maxlength=${to(this.maxlength)}
              min=${to(this.min)}
              max=${to(this.max)}
              step=${to(this.step)}
              .value=${Ft(this.value)}
              autocapitalize=${to(this.autocapitalize)}
              autocomplete=${to(this.autocomplete)}
              autocorrect=${to(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${to(this.pattern)}
              enterkeyhint=${to(this.enterkeyhint)}
              inputmode=${to(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${hasClearIcon ? ke`
                  <button
                    part="clear-button"
                    class=${Rt({
      input__clear: true,
      "input__clear--visible": isClearIconVisible
    })}
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? ke`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? ke`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : ke`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e3(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass([
  r4()
], SlInput.prototype, "hasFocus", 2);
__decorateClass([
  n4()
], SlInput.prototype, "title", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "type", 2);
__decorateClass([
  n4()
], SlInput.prototype, "name", 2);
__decorateClass([
  n4()
], SlInput.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlInput.prototype, "defaultValue", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "filled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "pill", 2);
__decorateClass([
  n4()
], SlInput.prototype, "label", 2);
__decorateClass([
  n4({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass([
  n4({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "disabled", 2);
__decorateClass([
  n4()
], SlInput.prototype, "placeholder", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "readonly", 2);
__decorateClass([
  n4({ attribute: "password-toggle", type: Boolean })
], SlInput.prototype, "passwordToggle", 2);
__decorateClass([
  n4({ attribute: "password-visible", type: Boolean })
], SlInput.prototype, "passwordVisible", 2);
__decorateClass([
  n4({ attribute: "no-spin-buttons", type: Boolean })
], SlInput.prototype, "noSpinButtons", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "form", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "required", 2);
__decorateClass([
  n4()
], SlInput.prototype, "pattern", 2);
__decorateClass([
  n4({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass([
  n4({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass([
  n4()
], SlInput.prototype, "min", 2);
__decorateClass([
  n4()
], SlInput.prototype, "max", 2);
__decorateClass([
  n4()
], SlInput.prototype, "step", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocorrect", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocomplete", 2);
__decorateClass([
  n4({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass([
  n4()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass([
  n4({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (value) => !value || value === "false" ? false : true,
      toAttribute: (value) => value ? "true" : "false"
    }
  })
], SlInput.prototype, "spellcheck", 2);
__decorateClass([
  n4()
], SlInput.prototype, "inputmode", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("step", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleStepChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleValueChange", 1);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7DUCI5S4.js
var spinner_styles_default = i`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TY4GUJRD.js
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
  }
  render() {
    return ke`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QPYT3OK4.js
var button_styles_default = i`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      .sl-button-group__button:not(
          .sl-button-group__button--first,
          .sl-button-group__button--radio,
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host(.sl-button-group__button--focus),
  :host(.sl-button-group__button[checked]) {
    z-index: 2;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.64QWL6LI.js
var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? er`a` : er`button`;
    return ke2`
      <${tag}
        part="base"
        class=${Rt({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${to(isLink ? void 0 : this.name)}
        value=${to(isLink ? void 0 : this.value)}
        href=${to(isLink ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink ? this.rel : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? ke2` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? ke2`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e3(".button")
], SlButton.prototype, "button", 2);
__decorateClass([
  r4()
], SlButton.prototype, "hasFocus", 2);
__decorateClass([
  r4()
], SlButton.prototype, "invalid", 2);
__decorateClass([
  n4()
], SlButton.prototype, "title", 2);
__decorateClass([
  n4({ reflect: true })
], SlButton.prototype, "variant", 2);
__decorateClass([
  n4({ reflect: true })
], SlButton.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "caret", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "loading", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "outline", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "pill", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "circle", 2);
__decorateClass([
  n4()
], SlButton.prototype, "type", 2);
__decorateClass([
  n4()
], SlButton.prototype, "name", 2);
__decorateClass([
  n4()
], SlButton.prototype, "value", 2);
__decorateClass([
  n4()
], SlButton.prototype, "href", 2);
__decorateClass([
  n4()
], SlButton.prototype, "target", 2);
__decorateClass([
  n4()
], SlButton.prototype, "rel", 2);
__decorateClass([
  n4()
], SlButton.prototype, "download", 2);
__decorateClass([
  n4()
], SlButton.prototype, "form", 2);
__decorateClass([
  n4({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass([
  n4({ attribute: "formenctype" })
], SlButton.prototype, "formEnctype", 2);
__decorateClass([
  n4({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass([
  n4({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass([
  n4({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlButton.prototype, "handleDisabledChange", 1);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.W7K6OMDR.js
var checkbox_styles_default = i`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FHOQLXTU.js
var SlCheckbox = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      value: (control) => control.checked ? control.value || "on" : void 0,
      defaultValue: (control) => control.defaultChecked,
      setValue: (control, checked) => control.checked = checked
    });
    this.hasSlotController = new HasSlotController(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.indeterminate = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked;
    this.input.indeterminate = this.indeterminate;
    this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return ke`
      <div
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="base"
          class=${Rt({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${to(this.value)}
            .indeterminate=${Ft(this.indeterminate)}
            .checked=${Ft(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? ke`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? ke`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox.styles = [component_styles_default, checkbox_styles_default];
SlCheckbox.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e3('input[type="checkbox"]')
], SlCheckbox.prototype, "input", 2);
__decorateClass([
  r4()
], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass([
  n4()
], SlCheckbox.prototype, "title", 2);
__decorateClass([
  n4()
], SlCheckbox.prototype, "name", 2);
__decorateClass([
  n4()
], SlCheckbox.prototype, "value", 2);
__decorateClass([
  n4({ reflect: true })
], SlCheckbox.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "checked", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass([
  defaultValue("checked")
], SlCheckbox.prototype, "defaultChecked", 2);
__decorateClass([
  n4({ reflect: true })
], SlCheckbox.prototype, "form", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "required", 2);
__decorateClass([
  n4({ attribute: "help-text" })
], SlCheckbox.prototype, "helpText", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch(["checked", "indeterminate"], { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleStateChange", 1);

// ../settings-component2/dist/stories/inlang-settings.js
var __decorate12 = function(decorators, target, key, desc) {
  var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r5 = (c4 < 3 ? d2(r5) : c4 > 3 ? d2(target, key, r5) : d2(target, key)) || r5;
  return c4 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
};
if (!customElements.get("sl-select"))
  customElements.define("sl-select", SlSelect);
if (!customElements.get("sl-option"))
  customElements.define("sl-option", SlOption);
if (!customElements.get("sl-input"))
  customElements.define("sl-input", SlInput);
if (!customElements.get("sl-button"))
  customElements.define("sl-button", SlButton);
if (!customElements.get("sl-checkbox"))
  customElements.define("sl-checkbox", SlCheckbox);
var InlangSettings = class InlangSettings2 extends h3 {
  constructor() {
    super(...arguments);
    this.settings = {};
    this.installedPlugins = [];
    this._newSettings = void 0;
    this._unsavedChanges = false;
    this.handleInlangProjectChange = (value, property, moduleId) => {
      if (this._newSettings && moduleId) {
        this._newSettings = {
          ...this._newSettings
          // plugin: {
          // 	...this._newSettings.plugin
          // 	[moduleId]: {
          // 		...this._newSettings[moduleId],
          // 		[property]: value,
          // 	},
          // }
        };
      } else if (this._newSettings) {
        this._newSettings = {
          ...this._newSettings,
          [property]: value
        };
      }
      if (JSON.stringify(this.settings) !== JSON.stringify(this._newSettings)) {
        this._unsavedChanges = true;
      } else {
        this._unsavedChanges = false;
      }
    };
    this._revertChanges = () => {
      if (this.settings) {
        this._newSettings = JSON.parse(JSON.stringify(this.settings));
      }
      this._unsavedChanges = false;
    };
    this._saveChanges = () => {
      if (this._newSettings) {
        this.dispatchOnSetSettings(this._newSettings);
        this.settings = JSON.parse(JSON.stringify(this._newSettings));
      }
      this._unsavedChanges = false;
    };
  }
  static {
    this.styles = [
      baseStyling,
      i`
			h2 {
				margin: 0;
				padding-top: 1rem;
			}
			.container {
				position: relative;
				display: flex;
				flex-direction: column;
				gap: 48px;
			}
			.module-container {
				display: flex;
				flex-direction: column;
				gap: 40px;
			}
			.hover-bar-container {
				width: 100%;
				box-sizing: border-box;
				position: sticky;
				bottom: 1rem;
			}
			.hover-bar {
				box-sizing: border-box;
				width: 100%;
				max-width: 500px;
				padding-top: 0.5rem;
				padding-bottom: 0.5rem;
				margin: 0 auto;
				display: flex;
				flex-wrap: wrap;
				justify-content: space-between;
				align-items: center;
				gap: 8px;
				background-color: var(--sl-panel-background-color);
				padding-left: 1rem;
				padding-right: 0.8rem;
				border-radius: 0.5rem;
				border: 1px solid var(--sl-panel-border-color);
				filter: drop-shadow(0 4px 3px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 2px rgb(0 0 0 / 0.06));
				font-weight: 600;
				line-height: 1.5;
				font-size: 14px;
			}
			.hover-bar-text {
				margin: 0;
			}
			.module-link-container {
				display: flex;
				color: var(--sl-input-help-text-color);
				gap: 6px;
				padding-top: 0.5rem;
			}
			.module-link {
				margin: 0;
				font-size: 14px;
				line-height: 1.5;
				flex-grow: 1;
				text-decoration: none;
				color: var(--sl-input-help-text-color);
			}
			.module-link:hover {
				color: var(--sl-color-primary-600);
			}
			.module-type {
				background-color: var(--sl-input-background-color-disabled);
				width: fit-content;
				padding: 0px 6px;
				border-radius: 2px;
				font-size: 14px;
				display: flex;
				align-items: center;
				justify-content: center;
				color: var(--sl-input-color-disabled);
				margin: 0;
				line-height: 1.5;
				flex-grow: 0;
			}
		`
    ];
  }
  dispatchOnSetSettings(settings) {
    const onSetSettings = new CustomEvent("set-settings", {
      detail: {
        argument: settings
      }
    });
    this.dispatchEvent(onSetSettings);
  }
  async firstUpdated() {
    await this.updateComplete;
    if (this.settings) {
      this._newSettings = JSON.parse(JSON.stringify(this.settings));
    }
    overridePrimitiveColors_default();
  }
  get _settingProperties() {
    const _settings = this.settings;
    if (!_settings)
      throw new Error("No inlang settings");
    const generalSchema = { internal: { schema: ProjectSettings.allOf[0] } };
    return generalSchema;
  }
  render() {
    return ke` <div class="container" part="base">
			${Object.entries(this._settingProperties).map(([key, value]) => {
      return value.schema?.properties && this._newSettings ? ke`<div class="module-container" part="module">
							${value.meta && (value.meta?.displayName).en && ke`<div>
								<h2 part="module-title">
									${value.meta && (value.meta?.displayName).en}
								</h2>
								<div class="module-link-container">
									<svg width="24" height="24" fill="none" viewBox="0 0 24 24">
										<path
											fill="currentColor"
											d="M11 17H7c-1.383 0-2.562-.488-3.537-1.463C2.488 14.562 2.001 13.383 2 12c0-1.383.487-2.562 1.463-3.537C4.439 7.488 5.618 7 7 7h4v2H7c-.833 0-1.542.292-2.125.875A2.893 2.893 0 004 12c0 .833.292 1.542.875 2.125A2.893 2.893 0 007 15h4v2zm-3-4v-2h8v2H8zm5 4v-2h4c.833 0 1.542-.292 2.125-.875A2.893 2.893 0 0020 12c0-.833-.292-1.542-.875-2.125A2.893 2.893 0 0017 9h-4V7h4c1.383 0 2.563.488 3.538 1.463.975.975 1.463 2.154 1.462 3.537 0 1.383-.488 2.562-1.463 3.538-.975.976-2.154 1.463-3.537 1.462h-4z"
										></path>
									</svg>
									<div class="module-type">
										${value.meta.id.startsWith("plugin") ? "Plugin" : "Lint Rule"}
									</div>
								</div>
							</div>`}
							${Object.entries(value.schema.properties).map(([property, schema]) => {
        if (property === "$schema" || property === "modules" || property === "languageTags" || property === "sourceLanguageTag")
          return void 0;
        return key === "internal" ? ke`
											<general-input
												exportparts="property, property-title, property-paragraph, option, option-wrapper, button"
												.property=${property}
												.modules=${[]}
												.value=${structuredClone(this._newSettings?.[property])}
												.schema=${schema}
												.handleInlangProjectChange=${this.handleInlangProjectChange}
												.required=${checkRequired_default(value.schema, property)}
											></general-input>
									  ` : ke`
											<general-input
												exportparts="property, property-title, property-paragraph, option, option-wrapper, button"
												.property=${property}
												.value=${// @ts-ignore
        structuredClone(this._newSettings?.[key]?.[property])}
												.schema=${schema}
												.moduleId=${key}
												.handleInlangProjectChange=${this.handleInlangProjectChange}
												.required=${checkRequired_default(value.schema, property)}
											></general-input>
									  `;
      })}
					  </div>` : void 0;
    })}
			${this._unsavedChanges ? ke`<div class="hover-bar-container">
						<div class="hover-bar" part="float">
							<p class="hover-bar-text">Attention, you have unsaved changes.</p>
							<div>
								<sl-button
									exportparts="base:button"
									size="small"
									@click=${() => {
      this._revertChanges();
    }}
									varaint="default"
								>
									Cancel
								</sl-button>
								<sl-button
									size="small"
									@click=${() => {
      this._saveChanges();
    }}
									variant="primary"
								>
									Save Changes
								</sl-button>
							</div>
						</div>
				  </div>` : ke``}
		</div>`;
  }
};
__decorate12([
  n4({ type: Object })
], InlangSettings.prototype, "settings", void 0);
__decorate12([
  n4({ type: Array })
], InlangSettings.prototype, "installedPlugins", void 0);
__decorate12([
  r4()
], InlangSettings.prototype, "_newSettings", void 0);
__decorate12([
  r4()
], InlangSettings.prototype, "_unsavedChanges", void 0);
InlangSettings = __decorate12([
  t2("inlang-settings")
], InlangSettings);
var inlang_settings_default = InlangSettings;
export {
  inlang_settings_default as InlangSettings
};
//! Do not edit this file manually. It is automatically generated based on the contents of the registry.json file.
/*! Bundled license information:

@lit-labs/ssr-dom-shim/lib/element-internals.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/ssr-dom-shim/index.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=settings-component.mjs.map
