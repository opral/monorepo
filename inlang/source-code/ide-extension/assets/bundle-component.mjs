var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod7) => function __require() {
  return mod7 || (0, cb[__getOwnPropNames(cb)[0]])((mod7 = { exports: {} }).exports, mod7), mod7.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod7, isNodeMode, target) => (target = mod7 != null ? __create(__getProtoOf(mod7)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod7 || !mod7.__esModule ? __defProp(target, "default", { value: mod7, enumerable: true }) : target,
  mod7
));

// ../../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a3, b5, str) {
      if (a3 instanceof RegExp)
        a3 = maybeMatch(a3, str);
      if (b5 instanceof RegExp)
        b5 = maybeMatch(b5, str);
      var r6 = range(a3, b5, str);
      return r6 && {
        start: r6[0],
        end: r6[1],
        pre: str.slice(0, r6[0]),
        body: str.slice(r6[0] + a3.length, r6[1]),
        post: str.slice(r6[1] + b5.length)
      };
    }
    function maybeMatch(reg, str) {
      var m7 = str.match(reg);
      return m7 ? m7[0] : null;
    }
    balanced.range = range;
    function range(a3, b5, str) {
      var begs, beg, left, right, result;
      var ai2 = str.indexOf(a3);
      var bi2 = str.indexOf(b5, ai2 + 1);
      var i4 = ai2;
      if (ai2 >= 0 && bi2 > 0) {
        if (a3 === b5) {
          return [ai2, bi2];
        }
        begs = [];
        left = str.length;
        while (i4 >= 0 && !result) {
          if (i4 == ai2) {
            begs.push(i4);
            ai2 = str.indexOf(a3, i4 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi2];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi2;
            }
            bi2 = str.indexOf(b5, i4 + 1);
          }
          i4 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m7 = balanced("{", "}", str);
      if (!m7)
        return str.split(",");
      var pre = m7.pre;
      var body = m7.body;
      var post = m7.post;
      var p5 = pre.split(",");
      p5[p5.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p5[p5.length - 1] += postParts.shift();
        p5.push.apply(p5, postParts);
      }
      parts.push.apply(parts, p5);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i4, y7) {
      return i4 <= y7;
    }
    function gte(i4, y7) {
      return i4 >= y7;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m7 = balanced("{", "}", str);
      if (!m7)
        return [str];
      var pre = m7.pre;
      var post = m7.post.length ? expand2(m7.post, false) : [""];
      if (/\$$/.test(m7.pre)) {
        for (var k6 = 0; k6 < post.length; k6++) {
          var expansion = pre + "{" + m7.body + "}" + post[k6];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m7.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m7.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m7.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m7.post.match(/,.*\}/)) {
            str = m7.pre + "{" + m7.body + escClose + m7.post;
            return expand2(str);
          }
          return [str];
        }
        var n6;
        if (isSequence) {
          n6 = m7.body.split(/\.\./);
        } else {
          n6 = parseCommaParts(m7.body);
          if (n6.length === 1) {
            n6 = expand2(n6[0], false).map(embrace);
            if (n6.length === 1) {
              return post.map(function(p5) {
                return m7.pre + n6[0] + p5;
              });
            }
          }
        }
        var N6;
        if (isSequence) {
          var x6 = numeric(n6[0]);
          var y7 = numeric(n6[1]);
          var width = Math.max(n6[0].length, n6[1].length);
          var incr = n6.length == 3 ? Math.abs(numeric(n6[2])) : 1;
          var test = lte;
          var reverse = y7 < x6;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n6.some(isPadded);
          N6 = [];
          for (var i4 = x6; test(i4, y7); i4 += incr) {
            var c5;
            if (isAlphaSequence) {
              c5 = String.fromCharCode(i4);
              if (c5 === "\\")
                c5 = "";
            } else {
              c5 = String(i4);
              if (pad) {
                var need = width - c5.length;
                if (need > 0) {
                  var z5 = new Array(need + 1).join("0");
                  if (i4 < 0)
                    c5 = "-" + z5 + c5.slice(1);
                  else
                    c5 = z5 + c5;
                }
              }
            }
            N6.push(c5);
          }
        } else {
          N6 = [];
          for (var j5 = 0; j5 < n6.length; j5++) {
            N6.push.apply(N6, expand2(n6[j5], false));
          }
        }
        for (var j5 = 0; j5 < N6.length; j5++) {
          for (var k6 = 0; k6 < post.length; k6++) {
            var expansion = pre + N6[j5] + post[k6];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/typebox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;
    exports.Transform = Symbol.for("TypeBox.Transform");
    exports.Readonly = Symbol.for("TypeBox.Readonly");
    exports.Optional = Symbol.for("TypeBox.Optional");
    exports.Hint = Symbol.for("TypeBox.Hint");
    exports.Kind = Symbol.for("TypeBox.Kind");
    exports.PatternBoolean = "(true|false)";
    exports.PatternNumber = "(0|[1-9][0-9]*)";
    exports.PatternString = "(.*)";
    exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
    exports.PatternNumberExact = `^${exports.PatternNumber}$`;
    exports.PatternStringExact = `^${exports.PatternString}$`;
    var TypeRegistry;
    (function(TypeRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      TypeRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      TypeRegistry2.Clear = Clear;
      function Delete(kind) {
        return map.delete(kind);
      }
      TypeRegistry2.Delete = Delete;
      function Has(kind) {
        return map.has(kind);
      }
      TypeRegistry2.Has = Has;
      function Set2(kind, func) {
        map.set(kind, func);
      }
      TypeRegistry2.Set = Set2;
      function Get(kind) {
        return map.get(kind);
      }
      TypeRegistry2.Get = Get;
    })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
    var TypeBoxError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TypeBoxError = TypeBoxError;
    var FormatRegistry;
    (function(FormatRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      FormatRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      FormatRegistry2.Clear = Clear;
      function Delete(format) {
        return map.delete(format);
      }
      FormatRegistry2.Delete = Delete;
      function Has(format) {
        return map.has(format);
      }
      FormatRegistry2.Has = Has;
      function Set2(format, func) {
        map.set(format, func);
      }
      FormatRegistry2.Set = Set2;
      function Get(format) {
        return map.get(format);
      }
      FormatRegistry2.Get = Get;
    })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
    var ValueGuard;
    (function(ValueGuard2) {
      function IsArray(value) {
        return Array.isArray(value);
      }
      ValueGuard2.IsArray = IsArray;
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      ValueGuard2.IsBigInt = IsBigInt;
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      ValueGuard2.IsBoolean = IsBoolean;
      function IsDate(value) {
        return value instanceof globalThis.Date;
      }
      ValueGuard2.IsDate = IsDate;
      function IsNull(value) {
        return value === null;
      }
      ValueGuard2.IsNull = IsNull;
      function IsNumber(value) {
        return typeof value === "number";
      }
      ValueGuard2.IsNumber = IsNumber;
      function IsObject(value) {
        return typeof value === "object" && value !== null;
      }
      ValueGuard2.IsObject = IsObject;
      function IsString(value) {
        return typeof value === "string";
      }
      ValueGuard2.IsString = IsString;
      function IsUint8Array(value) {
        return value instanceof globalThis.Uint8Array;
      }
      ValueGuard2.IsUint8Array = IsUint8Array;
      function IsUndefined(value) {
        return value === void 0;
      }
      ValueGuard2.IsUndefined = IsUndefined;
    })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
    var TypeGuardUnknownTypeError = class extends TypeBoxError {
    };
    exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var TypeGuard;
    (function(TypeGuard2) {
      function IsPattern(value) {
        try {
          new RegExp(value);
          return true;
        } catch {
          return false;
        }
      }
      function IsControlCharacterFree(value) {
        if (!ValueGuard.IsString(value))
          return false;
        for (let i4 = 0; i4 < value.length; i4++) {
          const code = value.charCodeAt(i4);
          if (code >= 7 && code <= 13 || code === 27 || code === 127) {
            return false;
          }
        }
        return true;
      }
      function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
      }
      function IsOptionalBigInt(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
      }
      function IsOptionalNumber(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
      }
      function IsOptionalBoolean(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
      }
      function IsOptionalString(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
      }
      function IsOptionalPattern(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
      }
      function IsOptionalFormat(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
      }
      function IsOptionalSchema(value) {
        return ValueGuard.IsUndefined(value) || TSchema(value);
      }
      function TAny(schema) {
        return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
      }
      TypeGuard2.TAny = TAny;
      function TArray(schema) {
        return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
      }
      TypeGuard2.TArray = TArray;
      function TAsyncIterator(schema) {
        return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
      }
      TypeGuard2.TAsyncIterator = TAsyncIterator;
      function TBigInt(schema) {
        return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
      }
      TypeGuard2.TBigInt = TBigInt;
      function TBoolean(schema) {
        return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TBoolean = TBoolean;
      function TConstructor(schema) {
        return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
      }
      TypeGuard2.TConstructor = TConstructor;
      function TDate(schema) {
        return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
      }
      TypeGuard2.TDate = TDate;
      function TFunction(schema) {
        return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
      }
      TypeGuard2.TFunction = TFunction;
      function TInteger(schema) {
        return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
      }
      TypeGuard2.TInteger = TInteger;
      function TIntersect(schema) {
        return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
      }
      TypeGuard2.TIntersect = TIntersect;
      function TIterator(schema) {
        return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
      }
      TypeGuard2.TIterator = TIterator;
      function TKindOf(schema, kind) {
        return TKind(schema) && schema[exports.Kind] === kind;
      }
      TypeGuard2.TKindOf = TKindOf;
      function TKind(schema) {
        return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);
      }
      TypeGuard2.TKind = TKind;
      function TLiteralString(schema) {
        return TLiteral(schema) && ValueGuard.IsString(schema.const);
      }
      TypeGuard2.TLiteralString = TLiteralString;
      function TLiteralNumber(schema) {
        return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
      }
      TypeGuard2.TLiteralNumber = TLiteralNumber;
      function TLiteralBoolean(schema) {
        return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
      }
      TypeGuard2.TLiteralBoolean = TLiteralBoolean;
      function TLiteral(schema) {
        return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
      }
      TypeGuard2.TLiteral = TLiteral;
      function TNever(schema) {
        return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
      }
      TypeGuard2.TNever = TNever;
      function TNot(schema) {
        return TKindOf(schema, "Not") && TSchema(schema.not);
      }
      TypeGuard2.TNot = TNot;
      function TNull(schema) {
        return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TNull = TNull;
      function TNumber(schema) {
        return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
      }
      TypeGuard2.TNumber = TNumber;
      function TObject(schema) {
        return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
      }
      TypeGuard2.TObject = TObject;
      function TPromise(schema) {
        return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
      }
      TypeGuard2.TPromise = TPromise;
      function TRecord(schema) {
        return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
          const keys = Object.getOwnPropertyNames(schema2.patternProperties);
          return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys[0]]);
        })(schema);
      }
      TypeGuard2.TRecord = TRecord;
      function TRecursive(schema) {
        return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === "Recursive";
      }
      TypeGuard2.TRecursive = TRecursive;
      function TRef(schema) {
        return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
      }
      TypeGuard2.TRef = TRef;
      function TString(schema) {
        return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
      }
      TypeGuard2.TString = TString;
      function TSymbol(schema) {
        return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TSymbol = TSymbol;
      function TTemplateLiteral(schema) {
        return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
      }
      TypeGuard2.TTemplateLiteral = TTemplateLiteral;
      function TThis(schema) {
        return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
      }
      TypeGuard2.TThis = TThis;
      function TTransform(schema) {
        return ValueGuard.IsObject(schema) && exports.Transform in schema;
      }
      TypeGuard2.TTransform = TTransform;
      function TTuple(schema) {
        return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && // empty
        (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
      }
      TypeGuard2.TTuple = TTuple;
      function TUndefined(schema) {
        return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUndefined = TUndefined;
      function TUnionLiteral(schema) {
        return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
      }
      TypeGuard2.TUnionLiteral = TUnionLiteral;
      function TUnion(schema) {
        return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
      }
      TypeGuard2.TUnion = TUnion;
      function TUint8Array(schema) {
        return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
      }
      TypeGuard2.TUint8Array = TUint8Array;
      function TUnknown(schema) {
        return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUnknown = TUnknown;
      function TUnsafe(schema) {
        return TKindOf(schema, "Unsafe");
      }
      TypeGuard2.TUnsafe = TUnsafe;
      function TVoid(schema) {
        return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TVoid = TVoid;
      function TReadonly(schema) {
        return ValueGuard.IsObject(schema) && schema[exports.Readonly] === "Readonly";
      }
      TypeGuard2.TReadonly = TReadonly;
      function TOptional(schema) {
        return ValueGuard.IsObject(schema) && schema[exports.Optional] === "Optional";
      }
      TypeGuard2.TOptional = TOptional;
      function TSchema(schema) {
        return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
      }
      TypeGuard2.TSchema = TSchema;
    })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
    var ExtendsUndefined;
    (function(ExtendsUndefined2) {
      function Check(schema) {
        return schema[exports.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check(schema2)) : schema[exports.Kind] === "Union" ? schema.anyOf.some((schema2) => Check(schema2)) : schema[exports.Kind] === "Undefined" ? true : schema[exports.Kind] === "Not" ? !Check(schema.not) : false;
      }
      ExtendsUndefined2.Check = Check;
    })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
    var TypeExtendsError = class extends TypeBoxError {
    };
    exports.TypeExtendsError = TypeExtendsError;
    var TypeExtendsResult;
    (function(TypeExtendsResult2) {
      TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
      TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
      TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
    })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
    var TypeExtends;
    (function(TypeExtends2) {
      function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
      }
      function Throw(message) {
        throw new TypeExtendsError(message);
      }
      function IsStructuralRight(right) {
        return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
      }
      function StructuralRight(left, right) {
        return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw("StructuralRight");
      }
      function TAnyRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TAny(left, right) {
        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
      }
      function TArrayRight(left, right) {
        return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TArray(left, right) {
        return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TAsyncIterator(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TBigInt(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TBooleanRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TBoolean(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TConstructor(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TDate(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TFunction(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TIntegerRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TInteger(left, right) {
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
      }
      function TIntersectRight(left, right) {
        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TIntersect(left, right) {
        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TIterator(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TLiteral(left, right) {
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;
      }
      function TNeverRight(left, right) {
        return TypeExtendsResult.False;
      }
      function TNever(left, right) {
        return TypeExtendsResult.True;
      }
      function UnwrapTNot(schema) {
        let [current, depth] = [schema, 0];
        while (true) {
          if (!TypeGuard.TNot(current))
            break;
          current = current.not;
          depth += 1;
        }
        return depth % 2 === 0 ? current : exports.Type.Unknown();
      }
      function TNot(left, right) {
        return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
      }
      function TNull(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TNumberRight(left, right) {
        return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TNumber(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsObjectPropertyCount(schema, count) {
        return Object.getOwnPropertyNames(schema.properties).length === count;
      }
      function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectSymbolLike(schema) {
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
      }
      function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectFunctionLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectArrayLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectPromiseLike(schema) {
        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
      }
      function Property(left, right) {
        return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
      }
      function TObjectRight(left, right) {
        return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
          return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
        })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
          return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        })() : TypeExtendsResult.False;
      }
      function TObject(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
          for (const key of Object.getOwnPropertyNames(right.properties)) {
            if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
              return TypeExtendsResult.False;
            }
            if (TypeGuard.TOptional(right.properties[key])) {
              return TypeExtendsResult.True;
            }
            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        })();
      }
      function TPromise(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
      }
      function RecordKey(schema) {
        return exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() : exports.PatternStringExact in schema.patternProperties ? exports.Type.String() : Throw("Unknown record key pattern");
      }
      function RecordValue(schema) {
        return exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] : exports.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
      }
      function TRecordRight(left, right) {
        const [Key, Value] = [RecordKey(right), RecordValue(right)];
        return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {
          for (const key of Object.getOwnPropertyNames(left.properties)) {
            if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        })() : TypeExtendsResult.False;
      }
      function TRecord(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
      }
      function TStringRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TString(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TSymbol(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TTemplateLiteral(left, right) {
        return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
      }
      function IsArrayOfTuple(left, right) {
        return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
      }
      function TTupleRight(left, right) {
        return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
      }
      function TTuple(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUint8Array(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUndefined(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnionRight(left, right) {
        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnion(left, right) {
        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnknownRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TUnknown(left, right) {
        return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function VoidRight(left, right) {
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TVoid(left, right) {
        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Visit(left, right) {
        return (
          // resolvable
          TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : (
            // standard
            TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`)
          )
        );
      }
      function Extends(left, right) {
        return Visit(left, right);
      }
      TypeExtends2.Extends = Extends;
    })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
    var TypeClone;
    (function(TypeClone2) {
      function ArrayType(value) {
        return value.map((value2) => Visit(value2));
      }
      function DateType(value) {
        return new Date(value.getTime());
      }
      function Uint8ArrayType(value) {
        return new Uint8Array(value);
      }
      function ObjectType(value) {
        const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        return { ...clonedProperties, ...clonedSymbols };
      }
      function Visit(value) {
        return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
      }
      function Rest(schemas) {
        return schemas.map((schema) => Type3(schema));
      }
      TypeClone2.Rest = Rest;
      function Type3(schema, options = {}) {
        return { ...Visit(schema), ...options };
      }
      TypeClone2.Type = Type3;
    })(TypeClone || (exports.TypeClone = TypeClone = {}));
    var IndexedAccessor;
    (function(IndexedAccessor2) {
      function OptionalUnwrap(schema) {
        return schema.map((schema2) => {
          const { [exports.Optional]: _5, ...clone } = TypeClone.Type(schema2);
          return clone;
        });
      }
      function IsIntersectOptional(schema) {
        return schema.every((schema2) => TypeGuard.TOptional(schema2));
      }
      function IsUnionOptional(schema) {
        return schema.some((schema2) => TypeGuard.TOptional(schema2));
      }
      function ResolveIntersect(schema) {
        return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
      }
      function ResolveUnion(schema) {
        return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
      }
      function ResolveOptional(schema) {
        return schema[exports.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports.Kind] === "Union" ? ResolveUnion(schema) : schema;
      }
      function TIntersect(schema, key) {
        const resolved = schema.allOf.reduce((acc, schema2) => {
          const indexed = Visit(schema2, key);
          return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports.Type.Intersect(resolved));
      }
      function TUnion(schema, key) {
        const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
        return ResolveOptional(exports.Type.Union(resolved));
      }
      function TObject(schema, key) {
        const property = schema.properties[key];
        return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
      }
      function TTuple(schema, key) {
        const items = schema.items;
        if (ValueGuard.IsUndefined(items))
          return exports.Type.Never();
        const element = items[key];
        if (ValueGuard.IsUndefined(element))
          return exports.Type.Never();
        return element;
      }
      function Visit(schema, key) {
        return schema[exports.Kind] === "Intersect" ? TIntersect(schema, key) : schema[exports.Kind] === "Union" ? TUnion(schema, key) : schema[exports.Kind] === "Object" ? TObject(schema, key) : schema[exports.Kind] === "Tuple" ? TTuple(schema, key) : exports.Type.Never();
      }
      function Resolve(schema, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema, key.toString()));
        return ResolveOptional(exports.Type.Union(resolved, options));
      }
      IndexedAccessor2.Resolve = Resolve;
    })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
    var Intrinsic;
    (function(Intrinsic2) {
      function Uncapitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toLowerCase()}${rest}`;
      }
      function Capitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toUpperCase()}${rest}`;
      }
      function Uppercase(value) {
        return value.toUpperCase();
      }
      function Lowercase(value) {
        return value.toLowerCase();
      }
      function IntrinsicTemplateLiteral(schema, mode) {
        const expression = TemplateLiteralParser.ParseExact(schema.pattern);
        const finite = TemplateLiteralFinite.Check(expression);
        if (!finite)
          return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
        const strings = [...TemplateLiteralGenerator.Generate(expression)];
        const literals = strings.map((value) => exports.Type.Literal(value));
        const mapped = IntrinsicRest(literals, mode);
        const union = exports.Type.Union(mapped);
        return exports.Type.TemplateLiteral([union]);
      }
      function IntrinsicLiteral(value, mode) {
        return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
      }
      function IntrinsicRest(schema, mode) {
        if (schema.length === 0)
          return [];
        const [L5, ...R7] = schema;
        return [Map2(L5, mode), ...IntrinsicRest(R7, mode)];
      }
      function Visit(schema, mode) {
        return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
      }
      function Map2(schema, mode) {
        return Visit(schema, mode);
      }
      Intrinsic2.Map = Map2;
    })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
    var ObjectMap;
    (function(ObjectMap2) {
      function TIntersect(schema, callback) {
        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function TUnion(schema, callback) {
        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function TObject(schema, callback) {
        return callback(schema);
      }
      function Visit(schema, callback) {
        return schema[exports.Kind] === "Intersect" ? TIntersect(schema, callback) : schema[exports.Kind] === "Union" ? TUnion(schema, callback) : schema[exports.Kind] === "Object" ? TObject(schema, callback) : schema;
      }
      function Map2(schema, callback, options) {
        return { ...Visit(TypeClone.Type(schema), callback), ...options };
      }
      ObjectMap2.Map = Map2;
    })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
    var KeyResolver;
    (function(KeyResolver2) {
      function UnwrapPattern(key) {
        return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
      }
      function TIntersect(schema, options) {
        return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
      }
      function TUnion(schema, options) {
        const sets = schema.anyOf.map((inner) => Visit(inner, options));
        return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
      }
      function TObject(schema, options) {
        return Object.getOwnPropertyNames(schema.properties);
      }
      function TRecord(schema, options) {
        return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
      }
      function Visit(schema, options) {
        return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema, options) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];
      }
      function ResolveKeys(schema, options) {
        return [...new Set(Visit(schema, options))];
      }
      KeyResolver2.ResolveKeys = ResolveKeys;
      function ResolvePattern(schema) {
        const keys = ResolveKeys(schema, { includePatterns: true });
        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern.join("|")})$`;
      }
      KeyResolver2.ResolvePattern = ResolvePattern;
    })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
    var KeyArrayResolverError = class extends TypeBoxError {
    };
    exports.KeyArrayResolverError = KeyArrayResolverError;
    var KeyArrayResolver;
    (function(KeyArrayResolver2) {
      function Resolve(schema) {
        return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
          const expression = TemplateLiteralParser.ParseExact(schema.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
          return [...TemplateLiteralGenerator.Generate(expression)];
        })() : [];
      }
      KeyArrayResolver2.Resolve = Resolve;
    })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
    var UnionResolver;
    (function(UnionResolver2) {
      function* TUnion(union) {
        for (const schema of union.anyOf) {
          if (schema[exports.Kind] === "Union") {
            yield* TUnion(schema);
          } else {
            yield schema;
          }
        }
      }
      function Resolve(union) {
        return exports.Type.Union([...TUnion(union)], { ...union });
      }
      UnionResolver2.Resolve = Resolve;
    })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
    var TemplateLiteralPatternError = class extends TypeBoxError {
    };
    exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
    var TemplateLiteralPattern;
    (function(TemplateLiteralPattern2) {
      function Throw(message) {
        throw new TemplateLiteralPatternError(message);
      }
      function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Visit(schema, acc) {
        return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports.Kind]}'`);
      }
      function Create(kinds) {
        return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
      }
      TemplateLiteralPattern2.Create = Create;
    })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
    var TemplateLiteralResolver;
    (function(TemplateLiteralResolver2) {
      function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
        return exports.Type.Union(literals);
      }
      TemplateLiteralResolver2.Resolve = Resolve;
    })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
    var TemplateLiteralParserError = class extends TypeBoxError {
    };
    exports.TemplateLiteralParserError = TemplateLiteralParserError;
    var TemplateLiteralParser;
    (function(TemplateLiteralParser2) {
      function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
      }
      function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, "(");
      }
      function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ")");
      }
      function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, "|");
      }
      function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
          return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (count === 0 && index !== pattern.length - 1)
            return false;
        }
        return true;
      }
      function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
      }
      function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0)
            return true;
        }
        return false;
      }
      function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            return true;
        }
        return false;
      }
      function Or2(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0) {
            const range2 = pattern.slice(start, index);
            if (range2.length > 0)
              expressions.push(Parse(range2));
            start = index + 1;
          }
        }
        const range = pattern.slice(start);
        if (range.length > 0)
          expressions.push(Parse(range));
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "or", expr: expressions };
      }
      function And(pattern) {
        function Group(value, index) {
          if (!IsOpenParen(value, index))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
          let count = 0;
          for (let scan = index; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
              count += 1;
            if (IsCloseParen(value, scan))
              count -= 1;
            if (count === 0)
              return [index, scan];
          }
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range2(pattern2, index) {
          for (let scan = index; scan < pattern2.length; scan++) {
            if (IsOpenParen(pattern2, scan))
              return [index, scan];
          }
          return [index, pattern2.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index)) {
            const [start, end] = Group(pattern, index);
            const range = pattern.slice(start, end + 1);
            expressions.push(Parse(range));
            index = end;
          } else {
            const [start, end] = Range2(pattern, index);
            const range = pattern.slice(start, end);
            if (range.length > 0)
              expressions.push(Parse(range));
            index = end - 1;
          }
        }
        return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
      }
      function Parse(pattern) {
        return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or2(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
      }
      TemplateLiteralParser2.Parse = Parse;
      function ParseExact(pattern) {
        return Parse(pattern.slice(1, pattern.length - 1));
      }
      TemplateLiteralParser2.ParseExact = ParseExact;
    })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
    var TemplateLiteralFiniteError = class extends TypeBoxError {
    };
    exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
    var TemplateLiteralFinite;
    (function(TemplateLiteralFinite2) {
      function Throw(message) {
        throw new TemplateLiteralFiniteError(message);
      }
      function IsNumber(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
      }
      function IsBoolean(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
      }
      function IsString(expression) {
        return expression.type === "const" && expression.const === ".*";
      }
      function Check(expression) {
        return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
      }
      TemplateLiteralFinite2.Check = Check;
    })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
    var TemplateLiteralGeneratorError = class extends TypeBoxError {
    };
    exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
    var TemplateLiteralGenerator;
    (function(TemplateLiteralGenerator2) {
      function* Reduce(buffer) {
        if (buffer.length === 1)
          return yield* buffer[0];
        for (const left of buffer[0]) {
          for (const right of Reduce(buffer.slice(1))) {
            yield `${left}${right}`;
          }
        }
      }
      function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
      }
      function* Or2(expression) {
        for (const expr of expression.expr)
          yield* Generate(expr);
      }
      function* Const(expression) {
        return yield expression.const;
      }
      function* Generate(expression) {
        return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or2(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
          throw new TemplateLiteralGeneratorError("Unknown expression");
        })();
      }
      TemplateLiteralGenerator2.Generate = Generate;
    })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
    var TemplateLiteralDslParser;
    (function(TemplateLiteralDslParser2) {
      function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, "");
        return trim === "boolean" ? yield exports.Type.Boolean() : trim === "number" ? yield exports.Type.Number() : trim === "bigint" ? yield exports.Type.BigInt() : trim === "string" ? yield exports.Type.String() : yield (() => {
          const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
          return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
        })();
      }
      function* ParseTerminal(template) {
        if (template[1] !== "{") {
          const L5 = exports.Type.Literal("$");
          const R7 = ParseLiteral(template.slice(1));
          return yield* [L5, ...R7];
        }
        for (let i4 = 2; i4 < template.length; i4++) {
          if (template[i4] === "}") {
            const L5 = ParseUnion(template.slice(2, i4));
            const R7 = ParseLiteral(template.slice(i4 + 1));
            return yield* [...L5, ...R7];
          }
        }
        yield exports.Type.Literal(template);
      }
      function* ParseLiteral(template) {
        for (let i4 = 0; i4 < template.length; i4++) {
          if (template[i4] === "$") {
            const L5 = exports.Type.Literal(template.slice(0, i4));
            const R7 = ParseTerminal(template.slice(i4));
            return yield* [L5, ...R7];
          }
        }
        yield exports.Type.Literal(template);
      }
      function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
      }
      TemplateLiteralDslParser2.Parse = Parse;
    })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
    var TransformDecodeBuilder = class {
      constructor(schema) {
        this.schema = schema;
      }
      Decode(decode) {
        return new TransformEncodeBuilder(this.schema, decode);
      }
    };
    exports.TransformDecodeBuilder = TransformDecodeBuilder;
    var TransformEncodeBuilder = class {
      constructor(schema, decode) {
        this.schema = schema;
        this.decode = decode;
      }
      Encode(encode) {
        const schema = TypeClone.Type(this.schema);
        return TypeGuard.TTransform(schema) ? (() => {
          const Encode = (value) => schema[exports.Transform].Encode(encode(value));
          const Decode = (value) => this.decode(schema[exports.Transform].Decode(value));
          const Codec = { Encode, Decode };
          return { ...schema, [exports.Transform]: Codec };
        })() : (() => {
          const Codec = { Decode: this.decode, Encode: encode };
          return { ...schema, [exports.Transform]: Codec };
        })();
      }
    };
    exports.TransformEncodeBuilder = TransformEncodeBuilder;
    var TypeOrdinal = 0;
    var TypeBuilderError = class extends TypeBoxError {
    };
    exports.TypeBuilderError = TypeBuilderError;
    var TypeBuilder = class {
      /** `[Internal]` Creates a schema without `static` and `params` types */
      Create(schema) {
        return schema;
      }
      /** `[Internal]` Throws a TypeBuilder error with the given message */
      Throw(message) {
        throw new TypeBuilderError(message);
      }
      /** `[Internal]` Discards property keys from the given record type */
      Discard(record, keys) {
        return keys.reduce((acc, key) => {
          const { [key]: _5, ...rest } = acc;
          return rest;
        }, record);
      }
      /** `[Json]` Omits compositing symbols from this schema */
      Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
      }
    };
    exports.TypeBuilder = TypeBuilder;
    var JsonTypeBuilder = class extends TypeBuilder {
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Json]` Creates a Readonly and Optional property */
      ReadonlyOptional(schema) {
        return this.Readonly(this.Optional(schema));
      }
      /** `[Json]` Creates a Readonly property */
      Readonly(schema) {
        return { ...TypeClone.Type(schema), [exports.Readonly]: "Readonly" };
      }
      /** `[Json]` Creates an Optional property */
      Optional(schema) {
        return { ...TypeClone.Type(schema), [exports.Optional]: "Optional" };
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Json]` Creates an Any type */
      Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Any" });
      }
      /** `[Json]` Creates an Array type */
      Array(schema, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
      }
      /** `[Json]` Creates a Boolean type */
      Boolean(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
      }
      /** `[Json]` Intrinsic function to Capitalize LiteralString types */
      Capitalize(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
      }
      /** `[Json]` Creates a Composite object type */
      Composite(objects, options) {
        const intersect = exports.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
        return exports.Type.Object(properties, options);
      }
      /** `[Json]` Creates a Enum type */
      Enum(item, options = {}) {
        if (ValueGuard.IsUndefined(item))
          return this.Throw("Enum undefined or empty");
        const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const values2 = [...new Set(values1)];
        const anyOf = values2.map((value) => exports.Type.Literal(value));
        return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
      }
      /** `[Json]` Creates a Conditional type */
      Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
          case TypeExtendsResult.Union:
            return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
          case TypeExtendsResult.True:
            return TypeClone.Type(trueType, options);
          case TypeExtendsResult.False:
            return TypeClone.Type(falseType, options);
        }
      }
      /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
      Exclude(unionType, excludedMembers, options = {}) {
        return TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType) ? (() => {
          const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
        })() : TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType, options);
      }
      /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
      Extract(type, union, options = {}) {
        return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {
          const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
        })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
      }
      /** `[Json]` Returns an Indexed property type for the given keys */
      Index(schema, unresolved, options = {}) {
        return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
          return TypeClone.Type(schema.items, options);
        })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
          const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
          const cloned = items.map((schema2) => TypeClone.Type(schema2));
          return this.Union(cloned, options);
        })() : (() => {
          const keys = KeyArrayResolver.Resolve(unresolved);
          const clone = TypeClone.Type(schema);
          return IndexedAccessor.Resolve(clone, keys, options);
        })();
      }
      /** `[Json]` Creates an Integer type */
      Integer(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
      }
      /** `[Json]` Creates an Intersect type */
      Intersect(allOf, options = {}) {
        if (allOf.length === 0)
          return exports.Type.Never();
        if (allOf.length === 1)
          return TypeClone.Type(allOf[0], options);
        if (allOf.some((schema) => TypeGuard.TTransform(schema)))
          this.Throw("Cannot intersect transform types");
        const objects = allOf.every((schema) => TypeGuard.TObject(schema));
        const cloned = TypeClone.Rest(allOf);
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
        return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
      }
      /** `[Json]` Creates a KeyOf type */
      KeyOf(schema, options = {}) {
        return TypeGuard.TRecord(schema) ? (() => {
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          return pattern === exports.PatternNumberExact ? this.Number(options) : pattern === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
        })() : TypeGuard.TTuple(schema) ? (() => {
          const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
          const literals = items.map((_5, index) => exports.Type.Literal(index.toString()));
          return this.Union(literals, options);
        })() : TypeGuard.TArray(schema) ? (() => {
          return this.Number(options);
        })() : (() => {
          const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
          if (keys.length === 0)
            return this.Never(options);
          const literals = keys.map((key) => this.Literal(key));
          return this.Union(literals, options);
        })();
      }
      /** `[Json]` Creates a Literal type */
      Literal(value, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
      }
      /** `[Json]` Intrinsic function to Lowercase LiteralString types */
      Lowercase(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
      }
      /** `[Json]` Creates a Never type */
      Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
      }
      /** `[Json]` Creates a Not type */
      Not(schema, options) {
        return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema) });
      }
      /** `[Json]` Creates a Null type */
      Null(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
      }
      /** `[Json]` Creates a Number type */
      Number(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
      }
      /** `[Json]` Creates an Object type */
      Object(properties, options = {}) {
        const propertyKeys = Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
        return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
      }
      /** `[Json]` Constructs a type whose keys are omitted from the given type */
      Omit(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
          if (ValueGuard.IsArray(object.required)) {
            object.required = object.required.filter((key) => !keys.includes(key));
            if (object.required.length === 0)
              delete object.required;
          }
          for (const key of Object.getOwnPropertyNames(object.properties)) {
            if (keys.includes(key))
              delete object.properties[key];
          }
          return this.Create(object);
        }, options);
      }
      /** `[Json]` Constructs a type where all properties are optional */
      Partial(schema, options = {}) {
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
          const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
            return { ...acc, [key]: this.Optional(object.properties[key]) };
          }, {});
          return this.Object(
            properties,
            this.Discard(object, ["required"])
            /* object used as options to retain other constraints */
          );
        }, options);
      }
      /** `[Json]` Constructs a type whose keys are picked from the given type */
      Pick(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
          if (ValueGuard.IsArray(object.required)) {
            object.required = object.required.filter((key) => keys.includes(key));
            if (object.required.length === 0)
              delete object.required;
          }
          for (const key of Object.getOwnPropertyNames(object.properties)) {
            if (!keys.includes(key))
              delete object.properties[key];
          }
          return this.Create(object);
        }, options);
      }
      /** `[Json]` Creates a Record type */
      Record(key, schema, options = {}) {
        return TypeGuard.TTemplateLiteral(key) ? (() => {
          const expression = TemplateLiteralParser.ParseExact(key.pattern);
          return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
        })() : TypeGuard.TUnion(key) ? (() => {
          const union = UnionResolver.Resolve(key);
          if (TypeGuard.TUnionLiteral(union)) {
            const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
            return this.Object(properties, { ...options, [exports.Hint]: "Record" });
          } else
            this.Throw("Record key of type union contains non-literal types");
        })() : TypeGuard.TLiteral(key) ? (() => {
          return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
        })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });
        })() : TypeGuard.TString(key) ? (() => {
          const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Type(schema) } });
        })() : this.Never();
      }
      /** `[Json]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        if (ValueGuard.IsUndefined(options.$id))
          options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
      }
      /** `[Json]` Creates a Ref type. */
      Ref(unresolved, options = {}) {
        if (ValueGuard.IsString(unresolved))
          return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
        if (ValueGuard.IsUndefined(unresolved.$id))
          this.Throw("Reference target type must specify an $id");
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
      }
      /** `[Json]` Constructs a type where all properties are required */
      Required(schema, options = {}) {
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
          const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
            return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
          }, {});
          return this.Object(
            properties,
            object
            /* object used as options to retain other constraints  */
          );
        }, options);
      }
      /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
      Rest(schema) {
        return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
      }
      /** `[Json]` Creates a String type */
      String(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
      }
      /** `[Json]` Creates a TemplateLiteral type */
      TemplateLiteral(unresolved, options = {}) {
        const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
        return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
      }
      /** `[Json]` Creates a Transform type */
      Transform(schema) {
        return new TransformDecodeBuilder(schema);
      }
      /** `[Json]` Creates a Tuple type */
      Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = TypeClone.Rest(items);
        const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
        return this.Create(schema);
      }
      /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
      Uncapitalize(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
      }
      /** `[Json]` Creates a Union type */
      Union(union, options = {}) {
        return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
          const anyOf = union;
          if (anyOf.length === 0)
            return this.Never(options);
          if (anyOf.length === 1)
            return this.Create(TypeClone.Type(anyOf[0], options));
          const clonedAnyOf = TypeClone.Rest(anyOf);
          return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
        })();
      }
      /** `[Json]` Creates an Unknown type */
      Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Unknown" });
      }
      /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
      Unsafe(options = {}) {
        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
      }
      /** `[Json]` Intrinsic function to Uppercase LiteralString types */
      Uppercase(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
      }
    };
    exports.JsonTypeBuilder = JsonTypeBuilder;
    var JavaScriptTypeBuilder = class extends JsonTypeBuilder {
      /** `[JavaScript]` Creates a AsyncIterator type */
      AsyncIterator(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
      }
      /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
      Awaited(schema, options = {}) {
        const Unwrap = (rest) => rest.length > 0 ? (() => {
          const [L5, ...R7] = rest;
          return [this.Awaited(L5), ...Unwrap(R7)];
        })() : rest;
        return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
      }
      /** `[JavaScript]` Creates a BigInt type */
      BigInt(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
      }
      /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema, options = {}) {
        return this.Tuple([...schema.parameters], { ...options });
      }
      /** `[JavaScript]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
        return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[JavaScript]` Creates a Date type */
      Date(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
      }
      /** `[JavaScript]` Creates a Function type */
      Function(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
        return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
      InstanceType(schema, options = {}) {
        return TypeClone.Type(schema.returns, options);
      }
      /** `[JavaScript]` Creates an Iterator type */
      Iterator(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
      }
      /** `[JavaScript]` Extracts the Parameters from the given Function type */
      Parameters(schema, options = {}) {
        return this.Tuple(schema.parameters, { ...options });
      }
      /** `[JavaScript]` Creates a Promise type */
      Promise(item, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
      }
      /** `[Extended]` Creates a String type */
      RegExp(unresolved, options = {}) {
        const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
        return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern });
      }
      /**
       * @deprecated Use `Type.RegExp`
       */
      RegEx(regex, options = {}) {
        return this.RegExp(regex, options);
      }
      /** `[JavaScript]` Extracts the ReturnType from the given Function type */
      ReturnType(schema, options = {}) {
        return TypeClone.Type(schema.returns, options);
      }
      /** `[JavaScript]` Creates a Symbol type */
      Symbol(options) {
        return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
      }
      /** `[JavaScript]` Creates a Undefined type */
      Undefined(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
      }
      /** `[JavaScript]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
      }
      /** `[JavaScript]` Creates a Void type */
      Void(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
      }
    };
    exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
    exports.JsonType = new JsonTypeBuilder();
    exports.Type = new JavaScriptTypeBuilder();
  }
});

// ../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/lib/murmurHash3js.js"(exports, module) {
    (function(root, undefined2) {
      "use strict";
      var library2 = {
        "version": "3.0.1",
        "x86": {},
        "x64": {}
      };
      function _x86Multiply(m7, n6) {
        return (m7 & 65535) * n6 + (((m7 >>> 16) * n6 & 65535) << 16);
      }
      function _x86Rotl(m7, n6) {
        return m7 << n6 | m7 >>> 32 - n6;
      }
      function _x86Fmix(h7) {
        h7 ^= h7 >>> 16;
        h7 = _x86Multiply(h7, 2246822507);
        h7 ^= h7 >>> 13;
        h7 = _x86Multiply(h7, 3266489909);
        h7 ^= h7 >>> 16;
        return h7;
      }
      function _x64Add(m7, n6) {
        m7 = [m7[0] >>> 16, m7[0] & 65535, m7[1] >>> 16, m7[1] & 65535];
        n6 = [n6[0] >>> 16, n6[0] & 65535, n6[1] >>> 16, n6[1] & 65535];
        var o5 = [0, 0, 0, 0];
        o5[3] += m7[3] + n6[3];
        o5[2] += o5[3] >>> 16;
        o5[3] &= 65535;
        o5[2] += m7[2] + n6[2];
        o5[1] += o5[2] >>> 16;
        o5[2] &= 65535;
        o5[1] += m7[1] + n6[1];
        o5[0] += o5[1] >>> 16;
        o5[1] &= 65535;
        o5[0] += m7[0] + n6[0];
        o5[0] &= 65535;
        return [o5[0] << 16 | o5[1], o5[2] << 16 | o5[3]];
      }
      function _x64Multiply(m7, n6) {
        m7 = [m7[0] >>> 16, m7[0] & 65535, m7[1] >>> 16, m7[1] & 65535];
        n6 = [n6[0] >>> 16, n6[0] & 65535, n6[1] >>> 16, n6[1] & 65535];
        var o5 = [0, 0, 0, 0];
        o5[3] += m7[3] * n6[3];
        o5[2] += o5[3] >>> 16;
        o5[3] &= 65535;
        o5[2] += m7[2] * n6[3];
        o5[1] += o5[2] >>> 16;
        o5[2] &= 65535;
        o5[2] += m7[3] * n6[2];
        o5[1] += o5[2] >>> 16;
        o5[2] &= 65535;
        o5[1] += m7[1] * n6[3];
        o5[0] += o5[1] >>> 16;
        o5[1] &= 65535;
        o5[1] += m7[2] * n6[2];
        o5[0] += o5[1] >>> 16;
        o5[1] &= 65535;
        o5[1] += m7[3] * n6[1];
        o5[0] += o5[1] >>> 16;
        o5[1] &= 65535;
        o5[0] += m7[0] * n6[3] + m7[1] * n6[2] + m7[2] * n6[1] + m7[3] * n6[0];
        o5[0] &= 65535;
        return [o5[0] << 16 | o5[1], o5[2] << 16 | o5[3]];
      }
      function _x64Rotl(m7, n6) {
        n6 %= 64;
        if (n6 === 32) {
          return [m7[1], m7[0]];
        } else if (n6 < 32) {
          return [m7[0] << n6 | m7[1] >>> 32 - n6, m7[1] << n6 | m7[0] >>> 32 - n6];
        } else {
          n6 -= 32;
          return [m7[1] << n6 | m7[0] >>> 32 - n6, m7[0] << n6 | m7[1] >>> 32 - n6];
        }
      }
      function _x64LeftShift(m7, n6) {
        n6 %= 64;
        if (n6 === 0) {
          return m7;
        } else if (n6 < 32) {
          return [m7[0] << n6 | m7[1] >>> 32 - n6, m7[1] << n6];
        } else {
          return [m7[1] << n6 - 32, 0];
        }
      }
      function _x64Xor(m7, n6) {
        return [m7[0] ^ n6[0], m7[1] ^ n6[1]];
      }
      function _x64Fmix(h7) {
        h7 = _x64Xor(h7, [0, h7[0] >>> 1]);
        h7 = _x64Multiply(h7, [4283543511, 3981806797]);
        h7 = _x64Xor(h7, [0, h7[0] >>> 1]);
        h7 = _x64Multiply(h7, [3301882366, 444984403]);
        h7 = _x64Xor(h7, [0, h7[0] >>> 1]);
        return h7;
      }
      library2.x86.hash32 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 4;
        var bytes = key.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c22 = 461845907;
        for (var i4 = 0; i4 < bytes; i4 = i4 + 4) {
          k1 = key.charCodeAt(i4) & 255 | (key.charCodeAt(i4 + 1) & 255) << 8 | (key.charCodeAt(i4 + 2) & 255) << 16 | (key.charCodeAt(i4 + 3) & 255) << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c22);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(i4 + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(i4 + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(i4) & 255;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
        }
        h1 ^= key.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library2.x86.hash128 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 16;
        var bytes = key.length - remainder;
        var h1 = seed;
        var h22 = seed;
        var h32 = seed;
        var h42 = seed;
        var k1 = 0;
        var k22 = 0;
        var k32 = 0;
        var k42 = 0;
        var c1 = 597399067;
        var c22 = 2869860233;
        var c32 = 951274213;
        var c42 = 2716044179;
        for (var i4 = 0; i4 < bytes; i4 = i4 + 16) {
          k1 = key.charCodeAt(i4) & 255 | (key.charCodeAt(i4 + 1) & 255) << 8 | (key.charCodeAt(i4 + 2) & 255) << 16 | (key.charCodeAt(i4 + 3) & 255) << 24;
          k22 = key.charCodeAt(i4 + 4) & 255 | (key.charCodeAt(i4 + 5) & 255) << 8 | (key.charCodeAt(i4 + 6) & 255) << 16 | (key.charCodeAt(i4 + 7) & 255) << 24;
          k32 = key.charCodeAt(i4 + 8) & 255 | (key.charCodeAt(i4 + 9) & 255) << 8 | (key.charCodeAt(i4 + 10) & 255) << 16 | (key.charCodeAt(i4 + 11) & 255) << 24;
          k42 = key.charCodeAt(i4 + 12) & 255 | (key.charCodeAt(i4 + 13) & 255) << 8 | (key.charCodeAt(i4 + 14) & 255) << 16 | (key.charCodeAt(i4 + 15) & 255) << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c22);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h22;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k22 = _x86Multiply(k22, c22);
          k22 = _x86Rotl(k22, 16);
          k22 = _x86Multiply(k22, c32);
          h22 ^= k22;
          h22 = _x86Rotl(h22, 17);
          h22 += h32;
          h22 = _x86Multiply(h22, 5) + 197830471;
          k32 = _x86Multiply(k32, c32);
          k32 = _x86Rotl(k32, 17);
          k32 = _x86Multiply(k32, c42);
          h32 ^= k32;
          h32 = _x86Rotl(h32, 15);
          h32 += h42;
          h32 = _x86Multiply(h32, 5) + 2530024501;
          k42 = _x86Multiply(k42, c42);
          k42 = _x86Rotl(k42, 18);
          k42 = _x86Multiply(k42, c1);
          h42 ^= k42;
          h42 = _x86Rotl(h42, 13);
          h42 += h1;
          h42 = _x86Multiply(h42, 5) + 850148119;
        }
        k1 = 0;
        k22 = 0;
        k32 = 0;
        k42 = 0;
        switch (remainder) {
          case 15:
            k42 ^= key.charCodeAt(i4 + 14) << 16;
          case 14:
            k42 ^= key.charCodeAt(i4 + 13) << 8;
          case 13:
            k42 ^= key.charCodeAt(i4 + 12);
            k42 = _x86Multiply(k42, c42);
            k42 = _x86Rotl(k42, 18);
            k42 = _x86Multiply(k42, c1);
            h42 ^= k42;
          case 12:
            k32 ^= key.charCodeAt(i4 + 11) << 24;
          case 11:
            k32 ^= key.charCodeAt(i4 + 10) << 16;
          case 10:
            k32 ^= key.charCodeAt(i4 + 9) << 8;
          case 9:
            k32 ^= key.charCodeAt(i4 + 8);
            k32 = _x86Multiply(k32, c32);
            k32 = _x86Rotl(k32, 17);
            k32 = _x86Multiply(k32, c42);
            h32 ^= k32;
          case 8:
            k22 ^= key.charCodeAt(i4 + 7) << 24;
          case 7:
            k22 ^= key.charCodeAt(i4 + 6) << 16;
          case 6:
            k22 ^= key.charCodeAt(i4 + 5) << 8;
          case 5:
            k22 ^= key.charCodeAt(i4 + 4);
            k22 = _x86Multiply(k22, c22);
            k22 = _x86Rotl(k22, 16);
            k22 = _x86Multiply(k22, c32);
            h22 ^= k22;
          case 4:
            k1 ^= key.charCodeAt(i4 + 3) << 24;
          case 3:
            k1 ^= key.charCodeAt(i4 + 2) << 16;
          case 2:
            k1 ^= key.charCodeAt(i4 + 1) << 8;
          case 1:
            k1 ^= key.charCodeAt(i4);
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
        }
        h1 ^= key.length;
        h22 ^= key.length;
        h32 ^= key.length;
        h42 ^= key.length;
        h1 += h22;
        h1 += h32;
        h1 += h42;
        h22 += h1;
        h32 += h1;
        h42 += h1;
        h1 = _x86Fmix(h1);
        h22 = _x86Fmix(h22);
        h32 = _x86Fmix(h32);
        h42 = _x86Fmix(h42);
        h1 += h22;
        h1 += h32;
        h1 += h42;
        h22 += h1;
        h32 += h1;
        h42 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h22 >>> 0).toString(16)).slice(-8) + ("00000000" + (h32 >>> 0).toString(16)).slice(-8) + ("00000000" + (h42 >>> 0).toString(16)).slice(-8);
      };
      library2.x64.hash128 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 16;
        var bytes = key.length - remainder;
        var h1 = [0, seed];
        var h22 = [0, seed];
        var k1 = [0, 0];
        var k22 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c22 = [1291169091, 658871167];
        for (var i4 = 0; i4 < bytes; i4 = i4 + 16) {
          k1 = [key.charCodeAt(i4 + 4) & 255 | (key.charCodeAt(i4 + 5) & 255) << 8 | (key.charCodeAt(i4 + 6) & 255) << 16 | (key.charCodeAt(i4 + 7) & 255) << 24, key.charCodeAt(i4) & 255 | (key.charCodeAt(i4 + 1) & 255) << 8 | (key.charCodeAt(i4 + 2) & 255) << 16 | (key.charCodeAt(i4 + 3) & 255) << 24];
          k22 = [key.charCodeAt(i4 + 12) & 255 | (key.charCodeAt(i4 + 13) & 255) << 8 | (key.charCodeAt(i4 + 14) & 255) << 16 | (key.charCodeAt(i4 + 15) & 255) << 24, key.charCodeAt(i4 + 8) & 255 | (key.charCodeAt(i4 + 9) & 255) << 8 | (key.charCodeAt(i4 + 10) & 255) << 16 | (key.charCodeAt(i4 + 11) & 255) << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c22);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h22);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k22 = _x64Multiply(k22, c22);
          k22 = _x64Rotl(k22, 33);
          k22 = _x64Multiply(k22, c1);
          h22 = _x64Xor(h22, k22);
          h22 = _x64Rotl(h22, 31);
          h22 = _x64Add(h22, h1);
          h22 = _x64Add(_x64Multiply(h22, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k22 = [0, 0];
        switch (remainder) {
          case 15:
            k22 = _x64Xor(k22, _x64LeftShift([0, key.charCodeAt(i4 + 14)], 48));
          case 14:
            k22 = _x64Xor(k22, _x64LeftShift([0, key.charCodeAt(i4 + 13)], 40));
          case 13:
            k22 = _x64Xor(k22, _x64LeftShift([0, key.charCodeAt(i4 + 12)], 32));
          case 12:
            k22 = _x64Xor(k22, _x64LeftShift([0, key.charCodeAt(i4 + 11)], 24));
          case 11:
            k22 = _x64Xor(k22, _x64LeftShift([0, key.charCodeAt(i4 + 10)], 16));
          case 10:
            k22 = _x64Xor(k22, _x64LeftShift([0, key.charCodeAt(i4 + 9)], 8));
          case 9:
            k22 = _x64Xor(k22, [0, key.charCodeAt(i4 + 8)]);
            k22 = _x64Multiply(k22, c22);
            k22 = _x64Rotl(k22, 33);
            k22 = _x64Multiply(k22, c1);
            h22 = _x64Xor(h22, k22);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 7)], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 6)], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 5)], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 4)], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 3)], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 2)], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 1)], 8));
          case 1:
            k1 = _x64Xor(k1, [0, key.charCodeAt(i4)]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c22);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, key.length]);
        h22 = _x64Xor(h22, [0, key.length]);
        h1 = _x64Add(h1, h22);
        h22 = _x64Add(h22, h1);
        h1 = _x64Fmix(h1);
        h22 = _x64Fmix(h22);
        h1 = _x64Add(h1, h22);
        h22 = _x64Add(h22, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = library2;
        }
        exports.murmurHash3 = library2;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library2;
        });
      } else {
        library2._murmurHash3 = root.murmurHash3;
        library2.noConflict = function() {
          root.murmurHash3 = library2._murmurHash3;
          library2._murmurHash3 = undefined2;
          library2.noConflict = undefined2;
          return library2;
        };
        root.murmurHash3 = library2;
      }
    })(exports);
  }
});

// ../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/index.js
var require_murmurhash3js = __commonJS({
  "../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/index.js"(exports, module) {
    module.exports = require_murmurHash3js();
  }
});

// ../../../node_modules/.pnpm/lexical@0.16.1/node_modules/lexical/Lexical.dev.mjs
var Lexical_dev_exports = {};
__export(Lexical_dev_exports, {
  $addUpdateTag: () => $addUpdateTag,
  $applyNodeReplacement: () => $applyNodeReplacement,
  $copyNode: () => $copyNode,
  $createLineBreakNode: () => $createLineBreakNode,
  $createNodeSelection: () => $createNodeSelection,
  $createParagraphNode: () => $createParagraphNode,
  $createPoint: () => $createPoint,
  $createRangeSelection: () => $createRangeSelection,
  $createRangeSelectionFromDom: () => $createRangeSelectionFromDom,
  $createTabNode: () => $createTabNode,
  $createTextNode: () => $createTextNode,
  $getAdjacentNode: () => $getAdjacentNode,
  $getCharacterOffsets: () => $getCharacterOffsets,
  $getEditor: () => $getEditor,
  $getNearestNodeFromDOMNode: () => $getNearestNodeFromDOMNode,
  $getNearestRootOrShadowRoot: () => $getNearestRootOrShadowRoot,
  $getNodeByKey: () => $getNodeByKey,
  $getNodeByKeyOrThrow: () => $getNodeByKeyOrThrow,
  $getPreviousSelection: () => $getPreviousSelection,
  $getRoot: () => $getRoot,
  $getSelection: () => $getSelection,
  $getTextContent: () => $getTextContent,
  $hasAncestor: () => $hasAncestor,
  $hasUpdateTag: () => $hasUpdateTag,
  $insertNodes: () => $insertNodes,
  $isBlockElementNode: () => $isBlockElementNode,
  $isDecoratorNode: () => $isDecoratorNode,
  $isElementNode: () => $isElementNode,
  $isInlineElementOrDecoratorNode: () => $isInlineElementOrDecoratorNode,
  $isLeafNode: () => $isLeafNode,
  $isLineBreakNode: () => $isLineBreakNode,
  $isNodeSelection: () => $isNodeSelection,
  $isParagraphNode: () => $isParagraphNode,
  $isRangeSelection: () => $isRangeSelection,
  $isRootNode: () => $isRootNode,
  $isRootOrShadowRoot: () => $isRootOrShadowRoot,
  $isTabNode: () => $isTabNode,
  $isTextNode: () => $isTextNode,
  $nodesOfType: () => $nodesOfType,
  $normalizeSelection__EXPERIMENTAL: () => $normalizeSelection,
  $parseSerializedNode: () => $parseSerializedNode,
  $selectAll: () => $selectAll,
  $setCompositionKey: () => $setCompositionKey,
  $setSelection: () => $setSelection,
  $splitNode: () => $splitNode,
  ArtificialNode__DO_NOT_USE: () => ArtificialNode__DO_NOT_USE,
  BLUR_COMMAND: () => BLUR_COMMAND,
  CAN_REDO_COMMAND: () => CAN_REDO_COMMAND,
  CAN_UNDO_COMMAND: () => CAN_UNDO_COMMAND,
  CLEAR_EDITOR_COMMAND: () => CLEAR_EDITOR_COMMAND,
  CLEAR_HISTORY_COMMAND: () => CLEAR_HISTORY_COMMAND,
  CLICK_COMMAND: () => CLICK_COMMAND,
  COMMAND_PRIORITY_CRITICAL: () => COMMAND_PRIORITY_CRITICAL,
  COMMAND_PRIORITY_EDITOR: () => COMMAND_PRIORITY_EDITOR,
  COMMAND_PRIORITY_HIGH: () => COMMAND_PRIORITY_HIGH,
  COMMAND_PRIORITY_LOW: () => COMMAND_PRIORITY_LOW,
  COMMAND_PRIORITY_NORMAL: () => COMMAND_PRIORITY_NORMAL,
  CONTROLLED_TEXT_INSERTION_COMMAND: () => CONTROLLED_TEXT_INSERTION_COMMAND,
  COPY_COMMAND: () => COPY_COMMAND,
  CUT_COMMAND: () => CUT_COMMAND,
  DELETE_CHARACTER_COMMAND: () => DELETE_CHARACTER_COMMAND,
  DELETE_LINE_COMMAND: () => DELETE_LINE_COMMAND,
  DELETE_WORD_COMMAND: () => DELETE_WORD_COMMAND,
  DRAGEND_COMMAND: () => DRAGEND_COMMAND,
  DRAGOVER_COMMAND: () => DRAGOVER_COMMAND,
  DRAGSTART_COMMAND: () => DRAGSTART_COMMAND,
  DROP_COMMAND: () => DROP_COMMAND,
  DecoratorNode: () => DecoratorNode,
  ElementNode: () => ElementNode,
  FOCUS_COMMAND: () => FOCUS_COMMAND,
  FORMAT_ELEMENT_COMMAND: () => FORMAT_ELEMENT_COMMAND,
  FORMAT_TEXT_COMMAND: () => FORMAT_TEXT_COMMAND,
  INDENT_CONTENT_COMMAND: () => INDENT_CONTENT_COMMAND,
  INSERT_LINE_BREAK_COMMAND: () => INSERT_LINE_BREAK_COMMAND,
  INSERT_PARAGRAPH_COMMAND: () => INSERT_PARAGRAPH_COMMAND,
  INSERT_TAB_COMMAND: () => INSERT_TAB_COMMAND,
  IS_ALL_FORMATTING: () => IS_ALL_FORMATTING,
  IS_BOLD: () => IS_BOLD,
  IS_CODE: () => IS_CODE,
  IS_HIGHLIGHT: () => IS_HIGHLIGHT,
  IS_ITALIC: () => IS_ITALIC,
  IS_STRIKETHROUGH: () => IS_STRIKETHROUGH,
  IS_SUBSCRIPT: () => IS_SUBSCRIPT,
  IS_SUPERSCRIPT: () => IS_SUPERSCRIPT,
  IS_UNDERLINE: () => IS_UNDERLINE,
  KEY_ARROW_DOWN_COMMAND: () => KEY_ARROW_DOWN_COMMAND,
  KEY_ARROW_LEFT_COMMAND: () => KEY_ARROW_LEFT_COMMAND,
  KEY_ARROW_RIGHT_COMMAND: () => KEY_ARROW_RIGHT_COMMAND,
  KEY_ARROW_UP_COMMAND: () => KEY_ARROW_UP_COMMAND,
  KEY_BACKSPACE_COMMAND: () => KEY_BACKSPACE_COMMAND,
  KEY_DELETE_COMMAND: () => KEY_DELETE_COMMAND,
  KEY_DOWN_COMMAND: () => KEY_DOWN_COMMAND,
  KEY_ENTER_COMMAND: () => KEY_ENTER_COMMAND,
  KEY_ESCAPE_COMMAND: () => KEY_ESCAPE_COMMAND,
  KEY_MODIFIER_COMMAND: () => KEY_MODIFIER_COMMAND,
  KEY_SPACE_COMMAND: () => KEY_SPACE_COMMAND,
  KEY_TAB_COMMAND: () => KEY_TAB_COMMAND,
  LineBreakNode: () => LineBreakNode,
  MOVE_TO_END: () => MOVE_TO_END,
  MOVE_TO_START: () => MOVE_TO_START,
  OUTDENT_CONTENT_COMMAND: () => OUTDENT_CONTENT_COMMAND,
  PASTE_COMMAND: () => PASTE_COMMAND,
  ParagraphNode: () => ParagraphNode,
  REDO_COMMAND: () => REDO_COMMAND,
  REMOVE_TEXT_COMMAND: () => REMOVE_TEXT_COMMAND,
  RootNode: () => RootNode,
  SELECTION_CHANGE_COMMAND: () => SELECTION_CHANGE_COMMAND,
  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,
  SELECT_ALL_COMMAND: () => SELECT_ALL_COMMAND,
  TEXT_TYPE_TO_FORMAT: () => TEXT_TYPE_TO_FORMAT,
  TabNode: () => TabNode,
  TextNode: () => TextNode,
  UNDO_COMMAND: () => UNDO_COMMAND,
  createCommand: () => createCommand,
  createEditor: () => createEditor,
  getNearestEditorFromDOMNode: () => getNearestEditorFromDOMNode,
  isBlockDomNode: () => isBlockDomNode,
  isCurrentlyReadOnlyMode: () => isCurrentlyReadOnlyMode,
  isHTMLAnchorElement: () => isHTMLAnchorElement,
  isHTMLElement: () => isHTMLElement2,
  isInlineDomNode: () => isInlineDomNode,
  isSelectionCapturedInDecoratorInput: () => isSelectionCapturedInDecoratorInput,
  isSelectionWithinEditor: () => isSelectionWithinEditor,
  resetRandomKey: () => resetRandomKey
});
function createCommand(type) {
  return {
    type
  };
}
function normalizeClassNames(...classNames) {
  const rval = [];
  for (const className of classNames) {
    if (className && typeof className === "string") {
      for (const [s3] of className.matchAll(/\S+/g)) {
        rval.push(s3);
      }
    }
  }
  return rval;
}
function getIsProcessingMutations() {
  return isProcessingMutations;
}
function updateTimeStamp(event) {
  lastTextEntryTimeStamp = event.timeStamp;
}
function initTextEntryListener(editor) {
  if (lastTextEntryTimeStamp === 0) {
    getWindow2(editor).addEventListener("textInput", updateTimeStamp, true);
  }
}
function isManagedLineBreak(dom, target, editor) {
  return (
    // @ts-expect-error: internal field
    target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.
    dom[`__lexicalKey_${editor._key}`] !== void 0
  );
}
function getLastSelection(editor) {
  return editor.getEditorState().read(() => {
    const selection = $getSelection();
    return selection !== null ? selection.clone() : null;
  });
}
function $handleTextMutation(target, node, editor) {
  const domSelection = getDOMSelection(editor._window);
  let anchorOffset = null;
  let focusOffset = null;
  if (domSelection !== null && domSelection.anchorNode === target) {
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
  }
  const text = target.nodeValue;
  if (text !== null) {
    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);
  }
}
function shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {
  if ($isRangeSelection(selection)) {
    const anchorNode = selection.anchor.getNode();
    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {
      return false;
    }
  }
  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();
}
function $flushMutations$1(editor, mutations, observer) {
  isProcessingMutations = true;
  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;
  try {
    updateEditor(editor, () => {
      const selection = $getSelection() || getLastSelection(editor);
      const badDOMTargets = /* @__PURE__ */ new Map();
      const rootElement = editor.getRootElement();
      const currentEditorState = editor._editorState;
      const blockCursorElement = editor._blockCursorElement;
      let shouldRevertSelection = false;
      let possibleTextForFirefoxPaste = "";
      for (let i4 = 0; i4 < mutations.length; i4++) {
        const mutation = mutations[i4];
        const type = mutation.type;
        const targetDOM = mutation.target;
        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);
        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {
          continue;
        }
        if (type === "characterData") {
          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {
            $handleTextMutation(
              // nodeType === DOM_TEXT_TYPE is a Text DOM node
              targetDOM,
              targetNode,
              editor
            );
          }
        } else if (type === "childList") {
          shouldRevertSelection = true;
          const addedDOMs = mutation.addedNodes;
          for (let s3 = 0; s3 < addedDOMs.length; s3++) {
            const addedDOM = addedDOMs[s3];
            const node = $getNodeFromDOMNode(addedDOM);
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== "BR" || !isManagedLineBreak(addedDOM, parentDOM, editor))) {
              if (IS_FIREFOX) {
                const possibleText = addedDOM.innerText || addedDOM.nodeValue;
                if (possibleText) {
                  possibleTextForFirefoxPaste += possibleText;
                }
              }
              parentDOM.removeChild(addedDOM);
            }
          }
          const removedDOMs = mutation.removedNodes;
          const removedDOMsLength = removedDOMs.length;
          if (removedDOMsLength > 0) {
            let unremovedBRs = 0;
            for (let s3 = 0; s3 < removedDOMsLength; s3++) {
              const removedDOM = removedDOMs[s3];
              if (removedDOM.nodeName === "BR" && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
                targetDOM.appendChild(removedDOM);
                unremovedBRs++;
              }
            }
            if (removedDOMsLength !== unremovedBRs) {
              if (targetDOM === rootElement) {
                targetNode = internalGetRoot(currentEditorState);
              }
              badDOMTargets.set(targetDOM, targetNode);
            }
          }
        }
      }
      if (badDOMTargets.size > 0) {
        for (const [targetDOM, targetNode] of badDOMTargets) {
          if ($isElementNode(targetNode)) {
            const childKeys = targetNode.getChildrenKeys();
            let currentDOM = targetDOM.firstChild;
            for (let s3 = 0; s3 < childKeys.length; s3++) {
              const key = childKeys[s3];
              const correctDOM = editor.getElementByKey(key);
              if (correctDOM === null) {
                continue;
              }
              if (currentDOM == null) {
                targetDOM.appendChild(correctDOM);
                currentDOM = correctDOM;
              } else if (currentDOM !== correctDOM) {
                targetDOM.replaceChild(correctDOM, currentDOM);
              }
              currentDOM = currentDOM.nextSibling;
            }
          } else if ($isTextNode(targetNode)) {
            targetNode.markDirty();
          }
        }
      }
      const records = observer.takeRecords();
      if (records.length > 0) {
        for (let i4 = 0; i4 < records.length; i4++) {
          const record = records[i4];
          const addedNodes = record.addedNodes;
          const target = record.target;
          for (let s3 = 0; s3 < addedNodes.length; s3++) {
            const addedDOM = addedNodes[s3];
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM.nodeName === "BR" && !isManagedLineBreak(addedDOM, target, editor)) {
              parentDOM.removeChild(addedDOM);
            }
          }
        }
        observer.takeRecords();
      }
      if (selection !== null) {
        if (shouldRevertSelection) {
          selection.dirty = true;
          $setSelection(selection);
        }
        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
          selection.insertRawText(possibleTextForFirefoxPaste);
        }
      }
    });
  } finally {
    isProcessingMutations = false;
  }
}
function $flushRootMutations(editor) {
  const observer = editor._observer;
  if (observer !== null) {
    const mutations = observer.takeRecords();
    $flushMutations$1(editor, mutations, observer);
  }
}
function initMutationObserver(editor) {
  initTextEntryListener(editor);
  editor._observer = new MutationObserver((mutations, observer) => {
    $flushMutations$1(editor, mutations, observer);
  });
}
function $canSimpleTextNodesBeMerged(node1, node2) {
  const node1Mode = node1.__mode;
  const node1Format = node1.__format;
  const node1Style = node1.__style;
  const node2Mode = node2.__mode;
  const node2Format = node2.__format;
  const node2Style = node2.__style;
  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);
}
function $mergeTextNodes(node1, node2) {
  const writableNode1 = node1.mergeWithSibling(node2);
  const normalizedNodes = getActiveEditor()._normalizedNodes;
  normalizedNodes.add(node1.__key);
  normalizedNodes.add(node2.__key);
  return writableNode1;
}
function $normalizeTextNode(textNode) {
  let node = textNode;
  if (node.__text === "" && node.isSimpleText() && !node.isUnmergeable()) {
    node.remove();
    return;
  }
  let previousNode;
  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
    if (previousNode.__text === "") {
      previousNode.remove();
    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {
      node = $mergeTextNodes(previousNode, node);
      break;
    } else {
      break;
    }
  }
  let nextNode;
  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
    if (nextNode.__text === "") {
      nextNode.remove();
    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {
      node = $mergeTextNodes(node, nextNode);
      break;
    } else {
      break;
    }
  }
}
function $normalizeSelection(selection) {
  $normalizePoint(selection.anchor);
  $normalizePoint(selection.focus);
  return selection;
}
function $normalizePoint(point) {
  while (point.type === "element") {
    const node = point.getNode();
    const offset3 = point.offset;
    let nextNode;
    let nextOffsetAtEnd;
    if (offset3 === node.getChildrenSize()) {
      nextNode = node.getChildAtIndex(offset3 - 1);
      nextOffsetAtEnd = true;
    } else {
      nextNode = node.getChildAtIndex(offset3);
      nextOffsetAtEnd = false;
    }
    if ($isTextNode(nextNode)) {
      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, "text");
      break;
    } else if (!$isElementNode(nextNode)) {
      break;
    }
    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, "element");
  }
}
function resetRandomKey() {
  keyCounter = 1;
}
function generateRandomKey() {
  return "" + keyCounter++;
}
function getRegisteredNodeOrThrow(editor, nodeType) {
  const registeredNode = editor._nodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      throw Error(`registeredNode: Type ${nodeType} not found`);
    }
  }
  return registeredNode;
}
function $isSelectionCapturedInDecorator(node) {
  return $isDecoratorNode($getNearestNodeFromDOMNode(node));
}
function isSelectionCapturedInDecoratorInput(anchorDOM) {
  const activeElement = document.activeElement;
  if (activeElement === null) {
    return false;
  }
  const nodeName = activeElement.nodeName;
  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === "INPUT" || nodeName === "TEXTAREA" || activeElement.contentEditable === "true" && // @ts-ignore internal field
  activeElement.__lexicalEditor == null);
}
function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
  const rootElement = editor.getRootElement();
  try {
    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
  } catch (error) {
    return false;
  }
}
function getNearestEditorFromDOMNode(node) {
  let currentNode = node;
  while (currentNode != null) {
    const editor = currentNode.__lexicalEditor;
    if (editor != null) {
      return editor;
    }
    currentNode = getParentElement(currentNode);
  }
  return null;
}
function getTextDirection(text) {
  if (RTL_REGEX.test(text)) {
    return "rtl";
  }
  if (LTR_REGEX.test(text)) {
    return "ltr";
  }
  return null;
}
function $isTokenOrSegmented(node) {
  return node.isToken() || node.isSegmented();
}
function isDOMNodeLexicalTextNode(node) {
  return node.nodeType === DOM_TEXT_TYPE;
}
function getDOMTextNode(element) {
  let node = element;
  while (node != null) {
    if (isDOMNodeLexicalTextNode(node)) {
      return node;
    }
    node = node.firstChild;
  }
  return null;
}
function toggleTextFormatType(format, type, alignWithFormat) {
  const activeFormat = TEXT_TYPE_TO_FORMAT[type];
  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {
    return format;
  }
  let newFormat = format ^ activeFormat;
  if (type === "subscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;
  } else if (type === "superscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;
  }
  return newFormat;
}
function $isLeafNode(node) {
  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);
}
function $setNodeKey(node, existingKey) {
  if (existingKey != null) {
    {
      errorOnNodeKeyConstructorMismatch(node, existingKey);
    }
    node.__key = existingKey;
    return;
  }
  errorOnReadOnly();
  errorOnInfiniteTransforms();
  const editor = getActiveEditor();
  const editorState = getActiveEditorState();
  const key = generateRandomKey();
  editorState._nodeMap.set(key, node);
  if ($isElementNode(node)) {
    editor._dirtyElements.set(key, true);
  } else {
    editor._dirtyLeaves.add(key);
  }
  editor._cloneNotNeeded.add(key);
  editor._dirtyType = HAS_DIRTY_NODES;
  node.__key = key;
}
function errorOnNodeKeyConstructorMismatch(node, existingKey) {
  const editorState = internalGetActiveEditorState();
  if (!editorState) {
    return;
  }
  const existingNode = editorState._nodeMap.get(existingKey);
  if (existingNode && existingNode.constructor !== node.constructor) {
    if (node.constructor.name !== existingNode.constructor.name) {
      {
        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);
      }
    } else {
      {
        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);
      }
    }
  }
}
function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
  let nextParentKey = parentKey;
  while (nextParentKey !== null) {
    if (dirtyElements.has(nextParentKey)) {
      return;
    }
    const node = nodeMap.get(nextParentKey);
    if (node === void 0) {
      break;
    }
    dirtyElements.set(nextParentKey, false);
    nextParentKey = node.__parent;
  }
}
function removeFromParent(node) {
  const oldParent = node.getParent();
  if (oldParent !== null) {
    const writableNode = node.getWritable();
    const writableParent = oldParent.getWritable();
    const prevSibling = node.getPreviousSibling();
    const nextSibling = node.getNextSibling();
    if (prevSibling === null) {
      if (nextSibling !== null) {
        const writableNextSibling = nextSibling.getWritable();
        writableParent.__first = nextSibling.__key;
        writableNextSibling.__prev = null;
      } else {
        writableParent.__first = null;
      }
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      if (nextSibling !== null) {
        const writableNextSibling = nextSibling.getWritable();
        writableNextSibling.__prev = writablePrevSibling.__key;
        writablePrevSibling.__next = writableNextSibling.__key;
      } else {
        writablePrevSibling.__next = null;
      }
      writableNode.__prev = null;
    }
    if (nextSibling === null) {
      if (prevSibling !== null) {
        const writablePrevSibling = prevSibling.getWritable();
        writableParent.__last = prevSibling.__key;
        writablePrevSibling.__next = null;
      } else {
        writableParent.__last = null;
      }
    } else {
      const writableNextSibling = nextSibling.getWritable();
      if (prevSibling !== null) {
        const writablePrevSibling = prevSibling.getWritable();
        writablePrevSibling.__next = writableNextSibling.__key;
        writableNextSibling.__prev = writablePrevSibling.__key;
      } else {
        writableNextSibling.__prev = null;
      }
      writableNode.__next = null;
    }
    writableParent.__size--;
    writableNode.__parent = null;
  }
}
function internalMarkNodeAsDirty(node) {
  errorOnInfiniteTransforms();
  const latest = node.getLatest();
  const parent = latest.__parent;
  const editorState = getActiveEditorState();
  const editor = getActiveEditor();
  const nodeMap = editorState._nodeMap;
  const dirtyElements = editor._dirtyElements;
  if (parent !== null) {
    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
  }
  const key = latest.__key;
  editor._dirtyType = HAS_DIRTY_NODES;
  if ($isElementNode(node)) {
    dirtyElements.set(key, true);
  } else {
    editor._dirtyLeaves.add(key);
  }
}
function internalMarkSiblingsAsDirty(node) {
  const previousNode = node.getPreviousSibling();
  const nextNode = node.getNextSibling();
  if (previousNode !== null) {
    internalMarkNodeAsDirty(previousNode);
  }
  if (nextNode !== null) {
    internalMarkNodeAsDirty(nextNode);
  }
}
function $setCompositionKey(compositionKey) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  const previousCompositionKey = editor._compositionKey;
  if (compositionKey !== previousCompositionKey) {
    editor._compositionKey = compositionKey;
    if (previousCompositionKey !== null) {
      const node = $getNodeByKey(previousCompositionKey);
      if (node !== null) {
        node.getWritable();
      }
    }
    if (compositionKey !== null) {
      const node = $getNodeByKey(compositionKey);
      if (node !== null) {
        node.getWritable();
      }
    }
  }
}
function $getCompositionKey() {
  if (isCurrentlyReadOnlyMode()) {
    return null;
  }
  const editor = getActiveEditor();
  return editor._compositionKey;
}
function $getNodeByKey(key, _editorState) {
  const editorState = _editorState || getActiveEditorState();
  const node = editorState._nodeMap.get(key);
  if (node === void 0) {
    return null;
  }
  return node;
}
function $getNodeFromDOMNode(dom, editorState) {
  const editor = getActiveEditor();
  const key = dom[`__lexicalKey_${editor._key}`];
  if (key !== void 0) {
    return $getNodeByKey(key, editorState);
  }
  return null;
}
function $getNearestNodeFromDOMNode(startingDOM, editorState) {
  let dom = startingDOM;
  while (dom != null) {
    const node = $getNodeFromDOMNode(dom, editorState);
    if (node !== null) {
      return node;
    }
    dom = getParentElement(dom);
  }
  return null;
}
function cloneDecorators(editor) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = Object.assign({}, currentDecorators);
  editor._pendingDecorators = pendingDecorators;
  return pendingDecorators;
}
function getEditorStateTextContent(editorState) {
  return editorState.read(() => $getRoot().getTextContent());
}
function markAllNodesAsDirty(editor, type) {
  updateEditor(editor, () => {
    const editorState = getActiveEditorState();
    if (editorState.isEmpty()) {
      return;
    }
    if (type === "root") {
      $getRoot().markDirty();
      return;
    }
    const nodeMap = editorState._nodeMap;
    for (const [, node] of nodeMap) {
      node.markDirty();
    }
  }, editor._pendingEditorState === null ? {
    tag: "history-merge"
  } : void 0);
}
function $getRoot() {
  return internalGetRoot(getActiveEditorState());
}
function internalGetRoot(editorState) {
  return editorState._nodeMap.get("root");
}
function $setSelection(selection) {
  errorOnReadOnly();
  const editorState = getActiveEditorState();
  if (selection !== null) {
    {
      if (Object.isFrozen(selection)) {
        {
          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
        }
      }
    }
    selection.dirty = true;
    selection.setCachedNodes(null);
  }
  editorState._selection = selection;
}
function $flushMutations() {
  errorOnReadOnly();
  const editor = getActiveEditor();
  $flushRootMutations(editor);
}
function $getNodeFromDOM(dom) {
  const editor = getActiveEditor();
  const nodeKey = getNodeKeyFromDOM(dom, editor);
  if (nodeKey === null) {
    const rootElement = editor.getRootElement();
    if (dom === rootElement) {
      return $getNodeByKey("root");
    }
    return null;
  }
  return $getNodeByKey(nodeKey);
}
function getTextNodeOffset(node, moveSelectionToEnd) {
  return moveSelectionToEnd ? node.getTextContentSize() : 0;
}
function getNodeKeyFromDOM(dom, editor) {
  let node = dom;
  while (node != null) {
    const key = node[`__lexicalKey_${editor._key}`];
    if (key !== void 0) {
      return key;
    }
    node = getParentElement(node);
  }
  return null;
}
function doesContainGrapheme(str) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str);
}
function getEditorsToPropagate(editor) {
  const editorsToPropagate = [];
  let currentEditor = editor;
  while (currentEditor !== null) {
    editorsToPropagate.push(currentEditor);
    currentEditor = currentEditor._parentEditor;
  }
  return editorsToPropagate;
}
function createUID() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function getAnchorTextFromDOM(anchorNode) {
  if (anchorNode.nodeType === DOM_TEXT_TYPE) {
    return anchorNode.nodeValue;
  }
  return null;
}
function $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {
  const domSelection = getDOMSelection(editor._window);
  if (domSelection === null) {
    return;
  }
  const anchorNode = domSelection.anchorNode;
  let {
    anchorOffset,
    focusOffset
  } = domSelection;
  if (anchorNode !== null) {
    let textContent = getAnchorTextFromDOM(anchorNode);
    const node = $getNearestNodeFromDOMNode(anchorNode);
    if (textContent !== null && $isTextNode(node)) {
      if (textContent === COMPOSITION_SUFFIX && data) {
        const offset3 = data.length;
        textContent = data;
        anchorOffset = offset3;
        focusOffset = offset3;
      }
      if (textContent !== null) {
        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);
      }
    }
  }
}
function $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {
  let node = textNode;
  if (node.isAttached() && (compositionEnd || !node.isDirty())) {
    const isComposing = node.isComposing();
    let normalizedTextContent = textContent;
    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {
      normalizedTextContent = textContent.slice(0, -1);
    }
    const prevTextContent = node.getTextContent();
    if (compositionEnd || normalizedTextContent !== prevTextContent) {
      if (normalizedTextContent === "") {
        $setCompositionKey(null);
        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {
          const editor = getActiveEditor();
          setTimeout(() => {
            editor.update(() => {
              if (node.isAttached()) {
                node.remove();
              }
            });
          }, 20);
        } else {
          node.remove();
        }
        return;
      }
      const parent = node.getParent();
      const prevSelection = $getPreviousSelection();
      const prevTextContentSize = node.getTextContentSize();
      const compositionKey = $getCompositionKey();
      const nodeKey = node.getKey();
      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need
      // to clear this input from occurring as that action wasn't permitted.
      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {
        node.markDirty();
        return;
      }
      const selection = $getSelection();
      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {
        node.setTextContent(normalizedTextContent);
        return;
      }
      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);
      if (node.isSegmented()) {
        const originalTextContent = node.getTextContent();
        const replacement = $createTextNode(originalTextContent);
        node.replace(replacement);
        node = replacement;
      }
      node.setTextContent(normalizedTextContent);
    }
  }
}
function $previousSiblingDoesNotAcceptText(node) {
  const previousSibling = node.getPreviousSibling();
  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();
}
function $shouldInsertTextAfterOrBeforeTextNode(selection, node) {
  if (node.isSegmented()) {
    return true;
  }
  if (!selection.isCollapsed()) {
    return false;
  }
  const offset3 = selection.anchor.offset;
  const parent = node.getParentOrThrow();
  const isToken = node.isToken();
  if (offset3 === 0) {
    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);
  } else if (offset3 === node.getTextContentSize()) {
    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;
  } else {
    return false;
  }
}
function isTab(key, altKey, ctrlKey, metaKey) {
  return key === "Tab" && !altKey && !ctrlKey && !metaKey;
}
function isBold(key, altKey, metaKey, ctrlKey) {
  return key.toLowerCase() === "b" && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isItalic(key, altKey, metaKey, ctrlKey) {
  return key.toLowerCase() === "i" && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isUnderline(key, altKey, metaKey, ctrlKey) {
  return key.toLowerCase() === "u" && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isParagraph(key, shiftKey) {
  return isReturn(key) && !shiftKey;
}
function isLineBreak(key, shiftKey) {
  return isReturn(key) && shiftKey;
}
function isOpenLineBreak(key, ctrlKey) {
  return IS_APPLE && ctrlKey && key.toLowerCase() === "o";
}
function isDeleteWordBackward(key, altKey, ctrlKey) {
  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);
}
function isDeleteWordForward(key, altKey, ctrlKey) {
  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);
}
function isDeleteLineBackward(key, metaKey) {
  return IS_APPLE && metaKey && isBackspace(key);
}
function isDeleteLineForward(key, metaKey) {
  return IS_APPLE && metaKey && isDelete(key);
}
function isDeleteBackward(key, altKey, metaKey, ctrlKey) {
  if (IS_APPLE) {
    if (altKey || metaKey) {
      return false;
    }
    return isBackspace(key) || key.toLowerCase() === "h" && ctrlKey;
  }
  if (ctrlKey || altKey || metaKey) {
    return false;
  }
  return isBackspace(key);
}
function isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey) {
  if (IS_APPLE) {
    if (shiftKey || altKey || metaKey) {
      return false;
    }
    return isDelete(key) || key.toLowerCase() === "d" && ctrlKey;
  }
  if (ctrlKey || altKey || metaKey) {
    return false;
  }
  return isDelete(key);
}
function isUndo(key, shiftKey, metaKey, ctrlKey) {
  return key.toLowerCase() === "z" && !shiftKey && controlOrMeta(metaKey, ctrlKey);
}
function isRedo(key, shiftKey, metaKey, ctrlKey) {
  if (IS_APPLE) {
    return key.toLowerCase() === "z" && metaKey && shiftKey;
  }
  return key.toLowerCase() === "y" && ctrlKey || key.toLowerCase() === "z" && ctrlKey && shiftKey;
}
function isCopy(key, shiftKey, metaKey, ctrlKey) {
  if (shiftKey) {
    return false;
  }
  if (key.toLowerCase() === "c") {
    return IS_APPLE ? metaKey : ctrlKey;
  }
  return false;
}
function isCut(key, shiftKey, metaKey, ctrlKey) {
  if (shiftKey) {
    return false;
  }
  if (key.toLowerCase() === "x") {
    return IS_APPLE ? metaKey : ctrlKey;
  }
  return false;
}
function isArrowLeft(key) {
  return key === "ArrowLeft";
}
function isArrowRight(key) {
  return key === "ArrowRight";
}
function isArrowUp(key) {
  return key === "ArrowUp";
}
function isArrowDown(key) {
  return key === "ArrowDown";
}
function isMoveBackward(key, ctrlKey, altKey, metaKey) {
  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;
}
function isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey) {
  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);
}
function isMoveForward(key, ctrlKey, altKey, metaKey) {
  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;
}
function isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey) {
  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);
}
function isMoveUp(key, ctrlKey, metaKey) {
  return isArrowUp(key) && !ctrlKey && !metaKey;
}
function isMoveDown(key, ctrlKey, metaKey) {
  return isArrowDown(key) && !ctrlKey && !metaKey;
}
function isModifier(ctrlKey, shiftKey, altKey, metaKey) {
  return ctrlKey || shiftKey || altKey || metaKey;
}
function isSpace(key) {
  return key === " ";
}
function controlOrMeta(metaKey, ctrlKey) {
  if (IS_APPLE) {
    return metaKey;
  }
  return ctrlKey;
}
function isReturn(key) {
  return key === "Enter";
}
function isBackspace(key) {
  return key === "Backspace";
}
function isEscape(key) {
  return key === "Escape";
}
function isDelete(key) {
  return key === "Delete";
}
function isSelectAll(key, metaKey, ctrlKey) {
  return key.toLowerCase() === "a" && controlOrMeta(metaKey, ctrlKey);
}
function $selectAll() {
  const root = $getRoot();
  const selection = root.select(0, root.getChildrenSize());
  $setSelection($normalizeSelection(selection));
}
function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
  if (classNamesTheme.__lexicalClassNameCache === void 0) {
    classNamesTheme.__lexicalClassNameCache = {};
  }
  const classNamesCache = classNamesTheme.__lexicalClassNameCache;
  const cachedClassNames = classNamesCache[classNameThemeType];
  if (cachedClassNames !== void 0) {
    return cachedClassNames;
  }
  const classNames = classNamesTheme[classNameThemeType];
  if (typeof classNames === "string") {
    const classNamesArr = normalizeClassNames(classNames);
    classNamesCache[classNameThemeType] = classNamesArr;
    return classNamesArr;
  }
  return classNames;
}
function setMutatedNode(mutatedNodes2, registeredNodes, mutationListeners, node, mutation) {
  if (mutationListeners.size === 0) {
    return;
  }
  const nodeType = node.__type;
  const nodeKey = node.__key;
  const registeredNode = registeredNodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      throw Error(`Type ${nodeType} not in registeredNodes`);
    }
  }
  const klass = registeredNode.klass;
  let mutatedNodesByType = mutatedNodes2.get(klass);
  if (mutatedNodesByType === void 0) {
    mutatedNodesByType = /* @__PURE__ */ new Map();
    mutatedNodes2.set(klass, mutatedNodesByType);
  }
  const prevMutation = mutatedNodesByType.get(nodeKey);
  const isMove = prevMutation === "destroyed" && mutation === "created";
  if (prevMutation === void 0 || isMove) {
    mutatedNodesByType.set(nodeKey, isMove ? "updated" : mutation);
  }
}
function $nodesOfType(klass) {
  const editorState = getActiveEditorState();
  const readOnly = editorState._readOnly;
  const klassType = klass.getType();
  const nodes = editorState._nodeMap;
  const nodesOfType = [];
  for (const [, node] of nodes) {
    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {
      nodesOfType.push(node);
    }
  }
  return nodesOfType;
}
function resolveElement(element, isBackward, focusOffset) {
  const parent = element.getParent();
  let offset3 = focusOffset;
  let block = element;
  if (parent !== null) {
    if (isBackward && focusOffset === 0) {
      offset3 = block.getIndexWithinParent();
      block = parent;
    } else if (!isBackward && focusOffset === block.getChildrenSize()) {
      offset3 = block.getIndexWithinParent() + 1;
      block = parent;
    }
  }
  return block.getChildAtIndex(isBackward ? offset3 - 1 : offset3);
}
function $getAdjacentNode(focus, isBackward) {
  const focusOffset = focus.offset;
  if (focus.type === "element") {
    const block = focus.getNode();
    return resolveElement(block, isBackward, focusOffset);
  } else {
    const focusNode = focus.getNode();
    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();
      if (possibleNode === null) {
        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
      }
      return possibleNode;
    }
  }
  return null;
}
function isFirefoxClipboardEvents(editor) {
  const event = getWindow2(editor).event;
  const inputType = event && event.inputType;
  return inputType === "insertFromPaste" || inputType === "insertFromPasteAsQuotation";
}
function dispatchCommand(editor, command, payload) {
  return triggerCommandListeners(editor, command, payload);
}
function $textContentRequiresDoubleLinebreakAtEnd(node) {
  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();
}
function getElementByKeyOrThrow(editor, key) {
  const element = editor._keyToDOMMap.get(key);
  if (element === void 0) {
    {
      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
    }
  }
  return element;
}
function getParentElement(node) {
  const parentElement = node.assignedSlot || node.parentElement;
  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;
}
function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
  const doc = rootElement.ownerDocument;
  const defaultView = doc.defaultView;
  if (defaultView === null) {
    return;
  }
  let {
    top: currentTop,
    bottom: currentBottom
  } = selectionRect;
  let targetTop = 0;
  let targetBottom = 0;
  let element = rootElement;
  while (element !== null) {
    const isBodyElement = element === doc.body;
    if (isBodyElement) {
      targetTop = 0;
      targetBottom = getWindow2(editor).innerHeight;
    } else {
      const targetRect = element.getBoundingClientRect();
      targetTop = targetRect.top;
      targetBottom = targetRect.bottom;
    }
    let diff = 0;
    if (currentTop < targetTop) {
      diff = -(targetTop - currentTop);
    } else if (currentBottom > targetBottom) {
      diff = currentBottom - targetBottom;
    }
    if (diff !== 0) {
      if (isBodyElement) {
        defaultView.scrollBy(0, diff);
      } else {
        const scrollTop = element.scrollTop;
        element.scrollTop += diff;
        const yOffset = element.scrollTop - scrollTop;
        currentTop -= yOffset;
        currentBottom -= yOffset;
      }
    }
    if (isBodyElement) {
      break;
    }
    element = getParentElement(element);
  }
}
function $hasUpdateTag(tag) {
  const editor = getActiveEditor();
  return editor._updateTags.has(tag);
}
function $addUpdateTag(tag) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  editor._updateTags.add(tag);
}
function $maybeMoveChildrenSelectionToParent(parentNode) {
  const selection = $getSelection();
  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {
    return selection;
  }
  const {
    anchor,
    focus
  } = selection;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if ($hasAncestor(anchorNode, parentNode)) {
    anchor.set(parentNode.__key, 0, "element");
  }
  if ($hasAncestor(focusNode, parentNode)) {
    focus.set(parentNode.__key, 0, "element");
  }
  return selection;
}
function $hasAncestor(child, targetNode) {
  let parent = child.getParent();
  while (parent !== null) {
    if (parent.is(targetNode)) {
      return true;
    }
    parent = parent.getParent();
  }
  return false;
}
function getDefaultView(domElem) {
  const ownerDoc = domElem.ownerDocument;
  return ownerDoc && ownerDoc.defaultView || null;
}
function getWindow2(editor) {
  const windowObj = editor._window;
  if (windowObj === null) {
    {
      throw Error(`window object not found`);
    }
  }
  return windowObj;
}
function $isInlineElementOrDecoratorNode(node) {
  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();
}
function $getNearestRootOrShadowRoot(node) {
  let parent = node.getParentOrThrow();
  while (parent !== null) {
    if ($isRootOrShadowRoot(parent)) {
      return parent;
    }
    parent = parent.getParentOrThrow();
  }
  return parent;
}
function $isRootOrShadowRoot(node) {
  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();
}
function $copyNode(node) {
  const copy = node.constructor.clone(node);
  $setNodeKey(copy, null);
  return copy;
}
function $applyNodeReplacement(node) {
  const editor = getActiveEditor();
  const nodeType = node.constructor.getType();
  const registeredNode = editor._nodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
    }
  }
  const replaceFunc = registeredNode.replace;
  if (replaceFunc !== null) {
    const replacementNode = replaceFunc(node);
    if (!(replacementNode instanceof node.constructor)) {
      {
        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);
      }
    }
    return replacementNode;
  }
  return node;
}
function errorOnInsertTextNodeOnRoot(node, insertNode) {
  const parentNode = node.getParent();
  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {
    {
      throw Error(`Only element or decorator nodes can be inserted in to the root node`);
    }
  }
}
function $getNodeByKeyOrThrow(key) {
  const node = $getNodeByKey(key);
  if (node === null) {
    {
      throw Error(`Expected node with key ${key} to exist but it's not in the nodeMap.`);
    }
  }
  return node;
}
function createBlockCursorElement(editorConfig) {
  const theme = editorConfig.theme;
  const element = document.createElement("div");
  element.contentEditable = "false";
  element.setAttribute("data-lexical-cursor", "true");
  let blockCursorTheme = theme.blockCursor;
  if (blockCursorTheme !== void 0) {
    if (typeof blockCursorTheme === "string") {
      const classNamesArr = normalizeClassNames(blockCursorTheme);
      blockCursorTheme = theme.blockCursor = classNamesArr;
    }
    if (blockCursorTheme !== void 0) {
      element.classList.add(...blockCursorTheme);
    }
  }
  return element;
}
function needsBlockCursor(node) {
  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();
}
function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
  rootElement.style.removeProperty("caret-color");
  editor._blockCursorElement = null;
  const parentElement = blockCursorElement.parentElement;
  if (parentElement !== null) {
    parentElement.removeChild(blockCursorElement);
  }
}
function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
  let blockCursorElement = editor._blockCursorElement;
  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === "element" && rootElement.contains(document.activeElement)) {
    const anchor = nextSelection.anchor;
    const elementNode = anchor.getNode();
    const offset3 = anchor.offset;
    const elementNodeSize = elementNode.getChildrenSize();
    let isBlockCursor = false;
    let insertBeforeElement = null;
    if (offset3 === elementNodeSize) {
      const child = elementNode.getChildAtIndex(offset3 - 1);
      if (needsBlockCursor(child)) {
        isBlockCursor = true;
      }
    } else {
      const child = elementNode.getChildAtIndex(offset3);
      if (needsBlockCursor(child)) {
        const sibling = child.getPreviousSibling();
        if (sibling === null || needsBlockCursor(sibling)) {
          isBlockCursor = true;
          insertBeforeElement = editor.getElementByKey(child.__key);
        }
      }
    }
    if (isBlockCursor) {
      const elementDOM = editor.getElementByKey(elementNode.__key);
      if (blockCursorElement === null) {
        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
      }
      rootElement.style.caretColor = "transparent";
      if (insertBeforeElement === null) {
        elementDOM.appendChild(blockCursorElement);
      } else {
        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
      }
      return;
    }
  }
  if (blockCursorElement !== null) {
    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
  }
}
function getDOMSelection(targetWindow) {
  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();
}
function $splitNode(node, offset3) {
  let startNode = node.getChildAtIndex(offset3);
  if (startNode == null) {
    startNode = node;
  }
  if (!!$isRootOrShadowRoot(node)) {
    throw Error(`Can not call $splitNode() on root element`);
  }
  const recurse = (currentNode) => {
    const parent = currentNode.getParentOrThrow();
    const isParentRoot = $isRootOrShadowRoot(parent);
    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);
    if (isParentRoot) {
      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {
        throw Error(`Children of a root must be ElementNode`);
      }
      currentNode.insertAfter(nodeToMove);
      return [currentNode, nodeToMove, nodeToMove];
    } else {
      const [leftTree2, rightTree2, newParent] = recurse(parent);
      const nextSiblings = currentNode.getNextSiblings();
      newParent.append(nodeToMove, ...nextSiblings);
      return [leftTree2, rightTree2, nodeToMove];
    }
  };
  const [leftTree, rightTree] = recurse(startNode);
  return [leftTree, rightTree];
}
function isHTMLAnchorElement(x6) {
  return isHTMLElement2(x6) && x6.tagName === "A";
}
function isHTMLElement2(x6) {
  return x6.nodeType === 1;
}
function isInlineDomNode(node) {
  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return node.nodeName.match(inlineNodes) !== null;
}
function isBlockDomNode(node) {
  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return node.nodeName.match(blockNodes) !== null;
}
function INTERNAL_$isBlock(node) {
  if ($isRootNode(node) || $isDecoratorNode(node) && !node.isInline()) {
    return true;
  }
  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {
    return false;
  }
  const firstChild = node.getFirstChild();
  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();
  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;
}
function $getAncestor(node, predicate) {
  let parent = node;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}
function $getEditor() {
  return getActiveEditor();
}
function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = editor._pendingDecorators;
  let decorators = pendingDecorators || currentDecorators;
  const nodeMap = pendingEditorState._nodeMap;
  let key;
  for (key in decorators) {
    if (!nodeMap.has(key)) {
      if (decorators === currentDecorators) {
        decorators = cloneDecorators(editor);
      }
      delete decorators[key];
    }
  }
}
function $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {
  let child = node.getFirstChild();
  while (child !== null) {
    const childKey = child.__key;
    if (child.__parent === parentKey) {
      if ($isElementNode(child)) {
        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);
      }
      if (!prevNodeMap.has(childKey)) {
        dirtyNodes.delete(childKey);
      }
      nodeMapDelete.push(childKey);
    }
    child = child.getNextSibling();
  }
}
function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
  const prevNodeMap = prevEditorState._nodeMap;
  const nodeMap = editorState._nodeMap;
  const nodeMapDelete = [];
  for (const [nodeKey] of dirtyElements) {
    const node = nodeMap.get(nodeKey);
    if (node !== void 0) {
      if (!node.isAttached()) {
        if ($isElementNode(node)) {
          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);
        }
        if (!prevNodeMap.has(nodeKey)) {
          dirtyElements.delete(nodeKey);
        }
        nodeMapDelete.push(nodeKey);
      }
    }
  }
  for (const nodeKey of nodeMapDelete) {
    nodeMap.delete(nodeKey);
  }
  for (const nodeKey of dirtyLeaves) {
    const node = nodeMap.get(nodeKey);
    if (node !== void 0 && !node.isAttached()) {
      if (!prevNodeMap.has(nodeKey)) {
        dirtyLeaves.delete(nodeKey);
      }
      nodeMap.delete(nodeKey);
    }
  }
}
function destroyNode(key, parentDOM) {
  const node = activePrevNodeMap.get(key);
  if (parentDOM !== null) {
    const dom = getPrevElementByKeyOrThrow(key);
    if (dom.parentNode === parentDOM) {
      parentDOM.removeChild(dom);
    }
  }
  if (!activeNextNodeMap.has(key)) {
    activeEditor$1._keyToDOMMap.delete(key);
  }
  if ($isElementNode(node)) {
    const children = createChildrenArray(node, activePrevNodeMap);
    destroyChildren(children, 0, children.length - 1, null);
  }
  if (node !== void 0) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "destroyed");
  }
}
function destroyChildren(children, _startIndex, endIndex, dom) {
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    const child = children[startIndex];
    if (child !== void 0) {
      destroyNode(child, dom);
    }
  }
}
function setTextAlign(domStyle, value) {
  domStyle.setProperty("text-align", value);
}
function setElementIndent(dom, indent) {
  const indentClassName = activeEditorConfig.theme.indent;
  if (typeof indentClassName === "string") {
    const elementHasClassName = dom.classList.contains(indentClassName);
    if (indent > 0 && !elementHasClassName) {
      dom.classList.add(indentClassName);
    } else if (indent < 1 && elementHasClassName) {
      dom.classList.remove(indentClassName);
    }
  }
  const indentationBaseValue = getComputedStyle(dom).getPropertyValue("--lexical-indent-base-value") || DEFAULT_INDENT_VALUE;
  dom.style.setProperty("padding-inline-start", indent === 0 ? "" : `calc(${indent} * ${indentationBaseValue})`);
}
function setElementFormat(dom, format) {
  const domStyle = dom.style;
  if (format === 0) {
    setTextAlign(domStyle, "");
  } else if (format === IS_ALIGN_LEFT) {
    setTextAlign(domStyle, "left");
  } else if (format === IS_ALIGN_CENTER) {
    setTextAlign(domStyle, "center");
  } else if (format === IS_ALIGN_RIGHT) {
    setTextAlign(domStyle, "right");
  } else if (format === IS_ALIGN_JUSTIFY) {
    setTextAlign(domStyle, "justify");
  } else if (format === IS_ALIGN_START) {
    setTextAlign(domStyle, "start");
  } else if (format === IS_ALIGN_END) {
    setTextAlign(domStyle, "end");
  }
}
function $createNode(key, parentDOM, insertDOM) {
  const node = activeNextNodeMap.get(key);
  if (node === void 0) {
    {
      throw Error(`createNode: node does not exist in nodeMap`);
    }
  }
  const dom = node.createDOM(activeEditorConfig, activeEditor$1);
  storeDOMWithKey(key, dom, activeEditor$1);
  if ($isTextNode(node)) {
    dom.setAttribute("data-lexical-text", "true");
  } else if ($isDecoratorNode(node)) {
    dom.setAttribute("data-lexical-decorator", "true");
  }
  if ($isElementNode(node)) {
    const indent = node.__indent;
    const childrenSize = node.__size;
    if (indent !== 0) {
      setElementIndent(dom, indent);
    }
    if (childrenSize !== 0) {
      const endIndex = childrenSize - 1;
      const children = createChildrenArray(node, activeNextNodeMap);
      $createChildrenWithDirection(children, endIndex, node, dom);
    }
    const format = node.__format;
    if (format !== 0) {
      setElementFormat(dom, format);
    }
    if (!node.isInline()) {
      reconcileElementTerminatingLineBreak(null, node, dom);
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text = node.getTextContent();
    if ($isDecoratorNode(node)) {
      const decorator = node.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key, decorator);
      }
      dom.contentEditable = "false";
    } else if ($isTextNode(node)) {
      if (!node.isDirectionless()) {
        subTreeDirectionedTextContent += text;
      }
    }
    subTreeTextContent += text;
    editorTextContent += text;
  }
  if (parentDOM !== null) {
    if (insertDOM != null) {
      parentDOM.insertBefore(dom, insertDOM);
    } else {
      const possibleLineBreak = parentDOM.__lexicalLineBreak;
      if (possibleLineBreak != null) {
        parentDOM.insertBefore(dom, possibleLineBreak);
      } else {
        parentDOM.appendChild(dom);
      }
    }
  }
  {
    Object.freeze(node);
  }
  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "created");
  return dom;
}
function $createChildrenWithDirection(children, endIndex, element, dom) {
  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;
  subTreeDirectionedTextContent = "";
  $createChildren(children, element, 0, endIndex, dom, null);
  reconcileBlockDirection(element, dom);
  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;
}
function $createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {
  const previousSubTreeTextContent = subTreeTextContent;
  subTreeTextContent = "";
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    $createNode(children[startIndex], dom, insertDOM);
    const node = activeNextNodeMap.get(children[startIndex]);
    if (node !== null && subTreeTextFormat === null && $isTextNode(node)) {
      subTreeTextFormat = node.getFormat();
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  dom.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function isLastChildLineBreakOrDecorator(childKey, nodeMap) {
  const node = nodeMap.get(childKey);
  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();
}
function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {
  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));
  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);
  if (prevLineBreak) {
    if (!nextLineBreak) {
      const element = dom.__lexicalLineBreak;
      if (element != null) {
        dom.removeChild(element);
      }
      dom.__lexicalLineBreak = null;
    }
  } else if (nextLineBreak) {
    const element = document.createElement("br");
    dom.__lexicalLineBreak = element;
    dom.appendChild(element);
  }
}
function reconcileParagraphFormat(element) {
  if ($isParagraphNode(element) && subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {
    element.setTextFormat(subTreeTextFormat);
  }
}
function reconcileBlockDirection(element, dom) {
  const previousSubTreeDirectionTextContent = (
    // @ts-expect-error: internal field
    dom.__lexicalDirTextContent
  );
  const previousDirection = dom.__lexicalDir;
  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {
    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === "";
    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);
    if (direction !== previousDirection) {
      const classList = dom.classList;
      const theme = activeEditorConfig.theme;
      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : void 0;
      let nextDirectionTheme = direction !== null ? theme[direction] : void 0;
      if (previousDirectionTheme !== void 0) {
        if (typeof previousDirectionTheme === "string") {
          const classNamesArr = normalizeClassNames(previousDirectionTheme);
          previousDirectionTheme = theme[previousDirection] = classNamesArr;
        }
        classList.remove(...previousDirectionTheme);
      }
      if (direction === null || hasEmptyDirectionedTextContent && direction === "ltr") {
        dom.removeAttribute("dir");
      } else {
        if (nextDirectionTheme !== void 0) {
          if (typeof nextDirectionTheme === "string") {
            const classNamesArr = normalizeClassNames(nextDirectionTheme);
            nextDirectionTheme = theme[direction] = classNamesArr;
          }
          if (nextDirectionTheme !== void 0) {
            classList.add(...nextDirectionTheme);
          }
        }
        dom.dir = direction;
      }
      if (!activeEditorStateReadOnly) {
        const writableNode = element.getWritable();
        writableNode.__dir = direction;
      }
    }
    activeTextDirection = direction;
    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;
    dom.__lexicalDir = direction;
  }
}
function $reconcileChildrenWithDirection(prevElement, nextElement, dom) {
  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;
  subTreeDirectionedTextContent = "";
  subTreeTextFormat = null;
  $reconcileChildren(prevElement, nextElement, dom);
  reconcileBlockDirection(nextElement, dom);
  reconcileParagraphFormat(nextElement);
  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;
  subTreeTextFormat = null;
}
function createChildrenArray(element, nodeMap) {
  const children = [];
  let nodeKey = element.__first;
  while (nodeKey !== null) {
    const node = nodeMap.get(nodeKey);
    if (node === void 0) {
      {
        throw Error(`createChildrenArray: node does not exist in nodeMap`);
      }
    }
    children.push(nodeKey);
    nodeKey = node.__next;
  }
  return children;
}
function $reconcileChildren(prevElement, nextElement, dom) {
  const previousSubTreeTextContent = subTreeTextContent;
  const prevChildrenSize = prevElement.__size;
  const nextChildrenSize = nextElement.__size;
  subTreeTextContent = "";
  if (prevChildrenSize === 1 && nextChildrenSize === 1) {
    const prevFirstChildKey = prevElement.__first;
    const nextFrstChildKey = nextElement.__first;
    if (prevFirstChildKey === nextFrstChildKey) {
      $reconcileNode(prevFirstChildKey, dom);
    } else {
      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
      const replacementDOM = $createNode(nextFrstChildKey, null, null);
      dom.replaceChild(replacementDOM, lastDOM);
      destroyNode(prevFirstChildKey, null);
    }
    const nextChildNode = activeNextNodeMap.get(nextFrstChildKey);
    if (subTreeTextFormat === null && $isTextNode(nextChildNode)) {
      subTreeTextFormat = nextChildNode.getFormat();
    }
  } else {
    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);
    if (prevChildrenSize === 0) {
      if (nextChildrenSize !== 0) {
        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);
      }
    } else if (nextChildrenSize === 0) {
      if (prevChildrenSize !== 0) {
        const lexicalLineBreak = dom.__lexicalLineBreak;
        const canUseFastPath = lexicalLineBreak == null;
        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);
        if (canUseFastPath) {
          dom.textContent = "";
        }
      }
    } else {
      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  dom.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function $reconcileNode(key, parentDOM) {
  const prevNode = activePrevNodeMap.get(key);
  let nextNode = activeNextNodeMap.get(key);
  if (prevNode === void 0 || nextNode === void 0) {
    {
      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
    }
  }
  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);
  const dom = getElementByKeyOrThrow(activeEditor$1, key);
  if (prevNode === nextNode && !isDirty) {
    if ($isElementNode(prevNode)) {
      const previousSubTreeTextContent = dom.__lexicalTextContent;
      if (previousSubTreeTextContent !== void 0) {
        subTreeTextContent += previousSubTreeTextContent;
        editorTextContent += previousSubTreeTextContent;
      }
      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;
      if (previousSubTreeDirectionTextContent !== void 0) {
        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;
      }
    } else {
      const text = prevNode.getTextContent();
      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {
        subTreeDirectionedTextContent += text;
      }
      editorTextContent += text;
      subTreeTextContent += text;
    }
    return dom;
  }
  if (prevNode !== nextNode && isDirty) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, "updated");
  }
  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {
    const replacementDOM = $createNode(key, null, null);
    if (parentDOM === null) {
      {
        throw Error(`reconcileNode: parentDOM is null`);
      }
    }
    parentDOM.replaceChild(replacementDOM, dom);
    destroyNode(key, null);
    return replacementDOM;
  }
  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {
    const nextIndent = nextNode.__indent;
    if (nextIndent !== prevNode.__indent) {
      setElementIndent(dom, nextIndent);
    }
    const nextFormat = nextNode.__format;
    if (nextFormat !== prevNode.__format) {
      setElementFormat(dom, nextFormat);
    }
    if (isDirty) {
      $reconcileChildrenWithDirection(prevNode, nextNode, dom);
      if (!$isRootNode(nextNode) && !nextNode.isInline()) {
        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);
      }
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text = nextNode.getTextContent();
    if ($isDecoratorNode(nextNode)) {
      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key, decorator);
      }
    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {
      subTreeDirectionedTextContent += text;
    }
    subTreeTextContent += text;
    editorTextContent += text;
  }
  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {
    const nextRootNode = nextNode.getWritable();
    nextRootNode.__cachedText = editorTextContent;
    nextNode = nextRootNode;
  }
  {
    Object.freeze(nextNode);
  }
  return dom;
}
function reconcileDecorator(key, decorator) {
  let pendingDecorators = activeEditor$1._pendingDecorators;
  const currentDecorators = activeEditor$1._decorators;
  if (pendingDecorators === null) {
    if (currentDecorators[key] === decorator) {
      return;
    }
    pendingDecorators = cloneDecorators(activeEditor$1);
  }
  pendingDecorators[key] = decorator;
}
function getFirstChild(element) {
  return element.firstChild;
}
function getNextSibling(element) {
  let nextSibling = element.nextSibling;
  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {
    nextSibling = nextSibling.nextSibling;
  }
  return nextSibling;
}
function $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {
  const prevEndIndex = prevChildrenLength - 1;
  const nextEndIndex = nextChildrenLength - 1;
  let prevChildrenSet;
  let nextChildrenSet;
  let siblingDOM = getFirstChild(dom);
  let prevIndex = 0;
  let nextIndex = 0;
  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {
    const prevKey = prevChildren[prevIndex];
    const nextKey = nextChildren[nextIndex];
    if (prevKey === nextKey) {
      siblingDOM = getNextSibling($reconcileNode(nextKey, dom));
      prevIndex++;
      nextIndex++;
    } else {
      if (prevChildrenSet === void 0) {
        prevChildrenSet = new Set(prevChildren);
      }
      if (nextChildrenSet === void 0) {
        nextChildrenSet = new Set(nextChildren);
      }
      const nextHasPrevKey = nextChildrenSet.has(prevKey);
      const prevHasNextKey = prevChildrenSet.has(nextKey);
      if (!nextHasPrevKey) {
        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
        destroyNode(prevKey, dom);
        prevIndex++;
      } else if (!prevHasNextKey) {
        $createNode(nextKey, dom, siblingDOM);
        nextIndex++;
      } else {
        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);
        if (childDOM === siblingDOM) {
          siblingDOM = getNextSibling($reconcileNode(nextKey, dom));
        } else {
          if (siblingDOM != null) {
            dom.insertBefore(childDOM, siblingDOM);
          } else {
            dom.appendChild(childDOM);
          }
          $reconcileNode(nextKey, dom);
        }
        prevIndex++;
        nextIndex++;
      }
    }
    const node = activeNextNodeMap.get(nextKey);
    if (node !== null && subTreeTextFormat === null && $isTextNode(node)) {
      subTreeTextFormat = node.getFormat();
    }
  }
  const appendNewChildren = prevIndex > prevEndIndex;
  const removeOldChildren = nextIndex > nextEndIndex;
  if (appendNewChildren && !removeOldChildren) {
    const previousNode = nextChildren[nextEndIndex + 1];
    const insertDOM = previousNode === void 0 ? null : activeEditor$1.getElementByKey(previousNode);
    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);
  } else if (removeOldChildren && !appendNewChildren) {
    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);
  }
}
function $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
  subTreeTextContent = "";
  editorTextContent = "";
  subTreeDirectionedTextContent = "";
  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
  activeTextDirection = null;
  activeEditor$1 = editor;
  activeEditorConfig = editor._config;
  activeEditorNodes = editor._nodes;
  activeMutationListeners = activeEditor$1._listeners.mutation;
  activeDirtyElements = dirtyElements;
  activeDirtyLeaves = dirtyLeaves;
  activePrevNodeMap = prevEditorState._nodeMap;
  activeNextNodeMap = nextEditorState._nodeMap;
  activeEditorStateReadOnly = nextEditorState._readOnly;
  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);
  const currentMutatedNodes = /* @__PURE__ */ new Map();
  mutatedNodes = currentMutatedNodes;
  $reconcileNode("root", null);
  activeEditor$1 = void 0;
  activeEditorNodes = void 0;
  activeDirtyElements = void 0;
  activeDirtyLeaves = void 0;
  activePrevNodeMap = void 0;
  activeNextNodeMap = void 0;
  activeEditorConfig = void 0;
  activePrevKeyToDOMMap = void 0;
  mutatedNodes = void 0;
  return currentMutatedNodes;
}
function storeDOMWithKey(key, dom, editor) {
  const keyToDOMMap = editor._keyToDOMMap;
  dom["__lexicalKey_" + editor._key] = key;
  keyToDOMMap.set(key, dom);
}
function getPrevElementByKeyOrThrow(key) {
  const element = activePrevKeyToDOMMap.get(key);
  if (element === void 0) {
    {
      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
    }
  }
  return element;
}
function $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const editor = getActiveEditor();
  const domSelection = getDOMSelection(editor._window);
  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
  const anchorKey = anchor.key;
  const backingAnchorElement = editor.getElementByKey(anchorKey);
  const textLength = text.length;
  return anchorKey !== focus.key || // If we're working with a non-text node.
  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
  // a recent beforeinput event for "textInput". If there has been one in the last
  // 50ms then we proceed as normal. However, if there is not, then this is likely
  // a dangling `input` event caused by execCommand('insertText').
  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.
  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
  // dealing with this in "beforeinput" or where the node has already recently
  // been changed (thus is dirty).
  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
  // of the editor.
  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.
  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);
}
function shouldSkipSelectionChange(domNode, offset3) {
  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset3 !== 0 && offset3 !== domNode.nodeValue.length;
}
function onSelectionChange(domSelection, editor, isActive) {
  const {
    anchorNode: anchorDOM,
    anchorOffset,
    focusNode: focusDOM,
    focusOffset
  } = domSelection;
  if (isSelectionChangeFromDOMUpdate) {
    isSelectionChangeFromDOMUpdate = false;
    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {
      return;
    }
  }
  updateEditor(editor, () => {
    if (!isActive) {
      $setSelection(null);
      return;
    }
    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return;
    }
    const selection = $getSelection();
    if ($isRangeSelection(selection)) {
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      if (selection.isCollapsed()) {
        if (domSelection.type === "Range" && domSelection.anchorNode === domSelection.focusNode) {
          selection.dirty = true;
        }
        const windowEvent = getWindow2(editor).event;
        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;
        const root = $getRoot();
        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === "";
        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
          selection.format = lastFormat;
          selection.style = lastStyle;
        } else {
          if (anchor.type === "text") {
            if (!$isTextNode(anchorNode)) {
              throw Error(`Point.getNode() must return TextNode when type is text`);
            }
            selection.format = anchorNode.getFormat();
            selection.style = anchorNode.getStyle();
          } else if (anchor.type === "element" && !isRootTextContentEmpty) {
            const lastNode = anchor.getNode();
            if (lastNode instanceof ParagraphNode && lastNode.getChildrenSize() === 0) {
              selection.format = lastNode.getTextFormat();
            } else {
              selection.format = 0;
            }
            selection.style = "";
          }
        }
      } else {
        const anchorKey = anchor.key;
        const focus = selection.focus;
        const focusKey = focus.key;
        const nodes = selection.getNodes();
        const nodesLength = nodes.length;
        const isBackward = selection.isBackward();
        const startOffset = isBackward ? focusOffset : anchorOffset;
        const endOffset = isBackward ? anchorOffset : focusOffset;
        const startKey = isBackward ? focusKey : anchorKey;
        const endKey = isBackward ? anchorKey : focusKey;
        let combinedFormat = IS_ALL_FORMATTING;
        let hasTextNodes = false;
        for (let i4 = 0; i4 < nodesLength; i4++) {
          const node = nodes[i4];
          const textContentSize = node.getTextContentSize();
          if ($isTextNode(node) && textContentSize !== 0 && // Exclude empty text nodes at boundaries resulting from user's selection
          !(i4 === 0 && node.__key === startKey && startOffset === textContentSize || i4 === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {
            hasTextNodes = true;
            combinedFormat &= node.getFormat();
            if (combinedFormat === 0) {
              break;
            }
          }
        }
        selection.format = hasTextNodes ? combinedFormat : 0;
      }
    }
    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, void 0);
  });
}
function onClick(event, editor) {
  updateEditor(editor, () => {
    const selection = $getSelection();
    const domSelection = getDOMSelection(editor._window);
    const lastSelection = $getPreviousSelection();
    if (domSelection) {
      if ($isRangeSelection(selection)) {
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        if (anchor.type === "element" && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {
          domSelection.removeAllRanges();
          selection.dirty = true;
        } else if (event.detail === 3 && !selection.isCollapsed()) {
          const focus = selection.focus;
          const focusNode = focus.getNode();
          if (anchorNode !== focusNode) {
            if ($isElementNode(anchorNode)) {
              anchorNode.select(0);
            } else {
              anchorNode.getParentOrThrow().select(0);
            }
          }
        }
      } else if (event.pointerType === "touch") {
        const domAnchorNode = domSelection.anchorNode;
        if (domAnchorNode !== null) {
          const nodeType = domAnchorNode.nodeType;
          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {
            const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);
            $setSelection(newSelection);
          }
        }
      }
    }
    dispatchCommand(editor, CLICK_COMMAND, event);
  });
}
function onPointerDown(event, editor) {
  const target = event.target;
  const pointerType = event.pointerType;
  if (target instanceof Node && pointerType !== "touch") {
    updateEditor(editor, () => {
      if (!$isSelectionCapturedInDecorator(target)) {
        isSelectionChangeFromMouseDown = true;
      }
    });
  }
}
function getTargetRange(event) {
  if (!event.getTargetRanges) {
    return null;
  }
  const targetRanges = event.getTargetRanges();
  if (targetRanges.length === 0) {
    return null;
  }
  return targetRanges[0];
}
function $canRemoveText(anchorNode, focusNode) {
  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();
}
function isPossiblyAndroidKeyPress(timeStamp) {
  return lastKeyCode === "MediaLast" && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
}
function onBeforeInput(event, editor) {
  const inputType = event.inputType;
  const targetRange = getTargetRange(event);
  if (inputType === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
  // as the `paste` event should have triggered, unless the
  // user has dom.event.clipboardevents.enabled disabled in
  // about:config. In that case, we need to process the
  // pasted content in the DOM mutation phase.
  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
    return;
  } else if (inputType === "insertCompositionText") {
    return;
  }
  updateEditor(editor, () => {
    const selection = $getSelection();
    if (inputType === "deleteContentBackward") {
      if (selection === null) {
        const prevSelection = $getPreviousSelection();
        if (!$isRangeSelection(prevSelection)) {
          return;
        }
        $setSelection(prevSelection.clone());
      }
      if ($isRangeSelection(selection)) {
        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;
        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {
          $setCompositionKey(null);
          lastKeyDownTimeStamp = 0;
          setTimeout(() => {
            updateEditor(editor, () => {
              $setCompositionKey(null);
            });
          }, ANDROID_COMPOSITION_LATENCY);
          if ($isRangeSelection(selection)) {
            const anchorNode2 = selection.anchor.getNode();
            anchorNode2.markDirty();
            selection.format = anchorNode2.getFormat();
            if (!$isTextNode(anchorNode2)) {
              throw Error(`Anchor node must be a TextNode`);
            }
            selection.style = anchorNode2.getStyle();
          }
        } else {
          $setCompositionKey(null);
          event.preventDefault();
          const selectedNodeText = selection.anchor.getNode().getTextContent();
          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;
          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode;
          if (!shouldLetBrowserHandleDelete) {
            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
          }
        }
        return;
      }
    }
    if (!$isRangeSelection(selection)) {
      return;
    }
    const data = event.data;
    if (unprocessedBeforeInputData !== null) {
      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);
    }
    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {
      selection.applyDOMRange(targetRange);
    }
    unprocessedBeforeInputData = null;
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if (inputType === "insertText" || inputType === "insertTranspose") {
      if (data === "\n") {
        event.preventDefault();
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
      } else if (data === DOUBLE_LINE_BREAK) {
        event.preventDefault();
        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
      } else if (data == null && event.dataTransfer) {
        const text = event.dataTransfer.getData("text/plain");
        event.preventDefault();
        selection.insertRawText(text);
      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {
        event.preventDefault();
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
      } else {
        unprocessedBeforeInputData = data;
      }
      lastBeforeInputInsertTextTimeStamp = event.timeStamp;
      return;
    }
    event.preventDefault();
    switch (inputType) {
      case "insertFromYank":
      case "insertFromDrop":
      case "insertReplacementText": {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
        break;
      }
      case "insertFromComposition": {
        $setCompositionKey(null);
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
        break;
      }
      case "insertLineBreak": {
        $setCompositionKey(null);
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        break;
      }
      case "insertParagraph": {
        $setCompositionKey(null);
        if (isInsertLineBreak && !IS_IOS) {
          isInsertLineBreak = false;
          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        } else {
          dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
        }
        break;
      }
      case "insertFromPaste":
      case "insertFromPasteAsQuotation": {
        dispatchCommand(editor, PASTE_COMMAND, event);
        break;
      }
      case "deleteByComposition": {
        if ($canRemoveText(anchorNode, focusNode)) {
          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
        }
        break;
      }
      case "deleteByDrag":
      case "deleteByCut": {
        dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
        break;
      }
      case "deleteContent": {
        dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
        break;
      }
      case "deleteWordBackward": {
        dispatchCommand(editor, DELETE_WORD_COMMAND, true);
        break;
      }
      case "deleteWordForward": {
        dispatchCommand(editor, DELETE_WORD_COMMAND, false);
        break;
      }
      case "deleteHardLineBackward":
      case "deleteSoftLineBackward": {
        dispatchCommand(editor, DELETE_LINE_COMMAND, true);
        break;
      }
      case "deleteContentForward":
      case "deleteHardLineForward":
      case "deleteSoftLineForward": {
        dispatchCommand(editor, DELETE_LINE_COMMAND, false);
        break;
      }
      case "formatStrikeThrough": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "strikethrough");
        break;
      }
      case "formatBold": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
        break;
      }
      case "formatItalic": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
        break;
      }
      case "formatUnderline": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
        break;
      }
      case "historyUndo": {
        dispatchCommand(editor, UNDO_COMMAND, void 0);
        break;
      }
      case "historyRedo": {
        dispatchCommand(editor, REDO_COMMAND, void 0);
        break;
      }
    }
  });
}
function onInput(event, editor) {
  event.stopPropagation();
  updateEditor(editor, () => {
    const selection = $getSelection();
    const data = event.data;
    const targetRange = getTargetRange(event);
    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {
      if (isFirefoxEndingComposition) {
        $onCompositionEndImpl(editor, data);
        isFirefoxEndingComposition = false;
      }
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      const domSelection = getDOMSelection(editor._window);
      if (domSelection === null) {
        return;
      }
      const isBackward = selection.isBackward();
      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;
      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;
      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
      }
      const textLength = data.length;
      if (IS_FIREFOX && textLength > 1 && event.inputType === "insertCompositionText" && !editor.isComposing()) {
        selection.anchor.offset -= textLength;
      }
      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {
        lastKeyDownTimeStamp = 0;
        $setCompositionKey(null);
      }
    } else {
      const characterData = data !== null ? data : void 0;
      $updateSelectedTextFromDOM(false, editor, characterData);
      if (isFirefoxEndingComposition) {
        $onCompositionEndImpl(editor, data || void 0);
        isFirefoxEndingComposition = false;
      }
    }
    $flushMutations();
  });
  unprocessedBeforeInputData = null;
}
function onCompositionStart(event, editor) {
  updateEditor(editor, () => {
    const selection = $getSelection();
    if ($isRangeSelection(selection) && !editor.isComposing()) {
      const anchor = selection.anchor;
      const node = selection.anchor.getNode();
      $setCompositionKey(anchor.key);
      if (
        // If it has been 30ms since the last keydown, then we should
        // apply the empty space heuristic. We can't do this for Safari,
        // as the keydown fires after composition start.
        event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
        // need to invoke the empty space heuristic below.
        anchor.type === "element" || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style
      ) {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
      }
    }
  });
}
function $onCompositionEndImpl(editor, data) {
  const compositionKey = editor._compositionKey;
  $setCompositionKey(null);
  if (compositionKey !== null && data != null) {
    if (data === "") {
      const node = $getNodeByKey(compositionKey);
      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));
      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {
        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);
      }
      return;
    }
    if (data[data.length - 1] === "\n") {
      const selection = $getSelection();
      if ($isRangeSelection(selection)) {
        const focus = selection.focus;
        selection.anchor.set(focus.key, focus.offset, focus.type);
        dispatchCommand(editor, KEY_ENTER_COMMAND, null);
        return;
      }
    }
  }
  $updateSelectedTextFromDOM(true, editor, data);
}
function onCompositionEnd(event, editor) {
  if (IS_FIREFOX) {
    isFirefoxEndingComposition = true;
  } else {
    updateEditor(editor, () => {
      $onCompositionEndImpl(editor, event.data);
    });
  }
}
function onKeyDown(event, editor) {
  lastKeyDownTimeStamp = event.timeStamp;
  lastKeyCode = event.key;
  if (editor.isComposing()) {
    return;
  }
  const {
    key,
    shiftKey,
    ctrlKey,
    metaKey,
    altKey
  } = event;
  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {
    return;
  }
  if (key == null) {
    return;
  }
  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, MOVE_TO_END, event);
  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, MOVE_TO_START, event);
  } else if (isMoveUp(key, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
  } else if (isMoveDown(key, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
  } else if (isLineBreak(key, shiftKey)) {
    isInsertLineBreak = true;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isSpace(key)) {
    dispatchCommand(editor, KEY_SPACE_COMMAND, event);
  } else if (isOpenLineBreak(key, ctrlKey)) {
    event.preventDefault();
    isInsertLineBreak = true;
    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
  } else if (isParagraph(key, shiftKey)) {
    isInsertLineBreak = false;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {
    if (isBackspace(key)) {
      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
    }
  } else if (isEscape(key)) {
    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {
    if (isDelete(key)) {
      dispatchCommand(editor, KEY_DELETE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
    }
  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, true);
  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, false);
  } else if (isDeleteLineBackward(key, metaKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, true);
  } else if (isDeleteLineForward(key, metaKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, false);
  } else if (isBold(key, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
  } else if (isTab(key, altKey, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_TAB_COMMAND, event);
  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, UNDO_COMMAND, void 0);
  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, REDO_COMMAND, void 0);
  } else {
    const prevSelection = editor._editorState._selection;
    if ($isNodeSelection(prevSelection)) {
      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, COPY_COMMAND, event);
      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, CUT_COMMAND, event);
      } else if (isSelectAll(key, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, SELECT_ALL_COMMAND, event);
      }
    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {
      event.preventDefault();
      dispatchCommand(editor, SELECT_ALL_COMMAND, event);
    }
  }
  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);
  }
}
function getRootElementRemoveHandles(rootElement) {
  let eventHandles = rootElement.__lexicalEventHandles;
  if (eventHandles === void 0) {
    eventHandles = [];
    rootElement.__lexicalEventHandles = eventHandles;
  }
  return eventHandles;
}
function onDocumentSelectionChange(event) {
  const target = event.target;
  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;
  const domSelection = getDOMSelection(targetWindow);
  if (domSelection === null) {
    return;
  }
  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);
  if (nextActiveEditor === null) {
    return;
  }
  if (isSelectionChangeFromMouseDown) {
    isSelectionChangeFromMouseDown = false;
    updateEditor(nextActiveEditor, () => {
      const lastSelection = $getPreviousSelection();
      const domAnchorNode = domSelection.anchorNode;
      if (domAnchorNode === null) {
        return;
      }
      const nodeType = domAnchorNode.nodeType;
      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {
        return;
      }
      const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);
      $setSelection(newSelection);
    });
  }
  const editors = getEditorsToPropagate(nextActiveEditor);
  const rootEditor = editors[editors.length - 1];
  const rootEditorKey = rootEditor._key;
  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
  const prevActiveEditor = activeNestedEditor || rootEditor;
  if (prevActiveEditor !== nextActiveEditor) {
    onSelectionChange(domSelection, prevActiveEditor, false);
  }
  onSelectionChange(domSelection, nextActiveEditor, true);
  if (nextActiveEditor !== rootEditor) {
    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
  } else if (activeNestedEditor) {
    activeNestedEditorsMap.delete(rootEditorKey);
  }
}
function stopLexicalPropagation(event) {
  event._lexicalHandled = true;
}
function hasStoppedLexicalPropagation(event) {
  const stopped = event._lexicalHandled === true;
  return stopped;
}
function addRootElementEvents(rootElement, editor) {
  const doc = rootElement.ownerDocument;
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (documentRootElementsCount === void 0 || documentRootElementsCount < 1) {
    doc.addEventListener("selectionchange", onDocumentSelectionChange);
  }
  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);
  rootElement.__lexicalEditor = editor;
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i4 = 0; i4 < rootElementEvents.length; i4++) {
    const [eventName, onEvent] = rootElementEvents[i4];
    const eventHandler = typeof onEvent === "function" ? (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      if (editor.isEditable() || eventName === "click") {
        onEvent(event, editor);
      }
    } : (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      const isEditable = editor.isEditable();
      switch (eventName) {
        case "cut":
          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);
        case "copy":
          return dispatchCommand(editor, COPY_COMMAND, event);
        case "paste":
          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);
        case "dragstart":
          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);
        case "dragover":
          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);
        case "dragend":
          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);
        case "focus":
          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);
        case "blur": {
          return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);
        }
        case "drop":
          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);
      }
    };
    rootElement.addEventListener(eventName, eventHandler);
    removeHandles.push(() => {
      rootElement.removeEventListener(eventName, eventHandler);
    });
  }
}
function removeRootElementEvents(rootElement) {
  const doc = rootElement.ownerDocument;
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (!(documentRootElementsCount !== void 0)) {
    throw Error(`Root element not registered`);
  }
  const newCount = documentRootElementsCount - 1;
  if (!(newCount >= 0)) {
    throw Error(`Root element count less than 0`);
  }
  rootElementsRegistered.set(doc, newCount);
  if (newCount === 0) {
    doc.removeEventListener("selectionchange", onDocumentSelectionChange);
  }
  const editor = rootElement.__lexicalEditor;
  if (editor !== null && editor !== void 0) {
    cleanActiveNestedEditorsMap(editor);
    rootElement.__lexicalEditor = null;
  }
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i4 = 0; i4 < removeHandles.length; i4++) {
    removeHandles[i4]();
  }
  rootElement.__lexicalEventHandles = [];
}
function cleanActiveNestedEditorsMap(editor) {
  if (editor._parentEditor !== null) {
    const editors = getEditorsToPropagate(editor);
    const rootEditor = editors[editors.length - 1];
    const rootEditorKey = rootEditor._key;
    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
      activeNestedEditorsMap.delete(rootEditorKey);
    }
  } else {
    activeNestedEditorsMap.delete(editor._key);
  }
}
function markSelectionChangeFromDOMUpdate() {
  isSelectionChangeFromDOMUpdate = true;
}
function markCollapsedSelectionFormat(format, style, offset3, key, timeStamp) {
  collapsedSelectionFormat = [format, style, offset3, key, timeStamp];
}
function $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
  errorOnReadOnly();
  const key = nodeToRemove.__key;
  const parent = nodeToRemove.getParent();
  if (parent === null) {
    return;
  }
  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);
  let selectionMoved = false;
  if ($isRangeSelection(selection) && restoreSelection) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    if (anchor.key === key) {
      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
    if (focus.key === key) {
      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {
    nodeToRemove.selectPrevious();
  }
  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {
    const index = nodeToRemove.getIndexWithinParent();
    removeFromParent(nodeToRemove);
    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);
  } else {
    removeFromParent(nodeToRemove);
  }
  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
    $removeNode(parent, restoreSelection);
  }
  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {
    parent.selectEnd();
  }
}
function errorOnTypeKlassMismatch(type, klass) {
  const registeredNode = getActiveEditor()._nodes.get(type);
  if (registeredNode === void 0) {
    {
      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
    }
  }
  const editorKlass = registeredNode.klass;
  if (editorKlass !== klass) {
    {
      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
    }
  }
}
function insertRangeAfter(node, firstToInsert, lastToInsert) {
  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();
  let current = firstToInsert;
  const nodesToInsert = [firstToInsert];
  while (current !== lastToInsert2) {
    if (!current.getNextSibling()) {
      {
        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);
      }
    }
    current = current.getNextSibling();
    nodesToInsert.push(current);
  }
  let currentNode = node;
  for (const nodeToInsert of nodesToInsert) {
    currentNode = currentNode.insertAfter(nodeToInsert);
  }
}
function $convertLineBreakElement(node) {
  return {
    node: $createLineBreakNode()
  };
}
function $createLineBreakNode() {
  return $applyNodeReplacement(new LineBreakNode());
}
function $isLineBreakNode(node) {
  return node instanceof LineBreakNode;
}
function isOnlyChild(node) {
  const parentElement = node.parentElement;
  if (parentElement !== null) {
    const firstChild = parentElement.firstChild;
    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {
      const lastChild = parentElement.lastChild;
      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {
        return true;
      }
    }
  }
  return false;
}
function isWhitespaceDomTextNode(node) {
  return node.nodeType === DOM_TEXT_TYPE && /^( |\t|\r?\n)+$/.test(node.textContent || "");
}
function getElementOuterTag(node, format) {
  if (format & IS_CODE) {
    return "code";
  }
  if (format & IS_HIGHLIGHT) {
    return "mark";
  }
  if (format & IS_SUBSCRIPT) {
    return "sub";
  }
  if (format & IS_SUPERSCRIPT) {
    return "sup";
  }
  return null;
}
function getElementInnerTag(node, format) {
  if (format & IS_BOLD) {
    return "strong";
  }
  if (format & IS_ITALIC) {
    return "em";
  }
  return "span";
}
function setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {
  const domClassList = dom.classList;
  let classNames = getCachedClassNameArray(textClassNames, "base");
  if (classNames !== void 0) {
    domClassList.add(...classNames);
  }
  classNames = getCachedClassNameArray(textClassNames, "underlineStrikethrough");
  let hasUnderlineStrikethrough = false;
  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;
  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;
  if (classNames !== void 0) {
    if (nextUnderlineStrikethrough) {
      hasUnderlineStrikethrough = true;
      if (!prevUnderlineStrikethrough) {
        domClassList.add(...classNames);
      }
    } else if (prevUnderlineStrikethrough) {
      domClassList.remove(...classNames);
    }
  }
  for (const key in TEXT_TYPE_TO_FORMAT) {
    const format = key;
    const flag = TEXT_TYPE_TO_FORMAT[format];
    classNames = getCachedClassNameArray(textClassNames, key);
    if (classNames !== void 0) {
      if (nextFormat & flag) {
        if (hasUnderlineStrikethrough && (key === "underline" || key === "strikethrough")) {
          if (prevFormat & flag) {
            domClassList.remove(...classNames);
          }
          continue;
        }
        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === "underline" || key === "strikethrough") {
          domClassList.add(...classNames);
        }
      } else if (prevFormat & flag) {
        domClassList.remove(...classNames);
      }
    }
  }
}
function diffComposedText(a3, b5) {
  const aLength = a3.length;
  const bLength = b5.length;
  let left = 0;
  let right = 0;
  while (left < aLength && left < bLength && a3[left] === b5[left]) {
    left++;
  }
  while (right + left < aLength && right + left < bLength && a3[aLength - right - 1] === b5[bLength - right - 1]) {
    right++;
  }
  return [left, aLength - left - right, b5.slice(left, bLength - right)];
}
function setTextContent(nextText, dom, node) {
  const firstChild = dom.firstChild;
  const isComposing = node.isComposing();
  const suffix = isComposing ? COMPOSITION_SUFFIX : "";
  const text = nextText + suffix;
  if (firstChild == null) {
    dom.textContent = text;
  } else {
    const nodeValue = firstChild.nodeValue;
    if (nodeValue !== text) {
      if (isComposing || IS_FIREFOX) {
        const [index, remove, insert] = diffComposedText(nodeValue, text);
        if (remove !== 0) {
          firstChild.deleteData(index, remove);
        }
        firstChild.insertData(index, insert);
      } else {
        firstChild.nodeValue = text;
      }
    }
  }
}
function createTextInnerDOM(innerDOM, node, innerTag, format, text, config2) {
  setTextContent(text, innerDOM, node);
  const theme = config2.theme;
  const textClassNames = theme.text;
  if (textClassNames !== void 0) {
    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);
  }
}
function wrapElementWith(element, tag) {
  const el = document.createElement(tag);
  el.appendChild(element);
  return el;
}
function convertSpanElement(domNode) {
  const span = domNode;
  const style = span.style;
  return {
    forChild: applyTextFormatFromStyle(style),
    node: null
  };
}
function convertBringAttentionToElement(domNode) {
  const b5 = domNode;
  const hasNormalFontWeight = b5.style.fontWeight === "normal";
  return {
    forChild: applyTextFormatFromStyle(b5.style, hasNormalFontWeight ? void 0 : "bold"),
    node: null
  };
}
function isNodePre(node) {
  return node.nodeName === "PRE" || node.nodeType === DOM_ELEMENT_TYPE && node.style !== void 0 && node.style.whiteSpace !== void 0 && node.style.whiteSpace.startsWith("pre");
}
function findParentPreDOMNode(node) {
  let cached;
  let parent = node.parentNode;
  const visited = [node];
  while (parent !== null && (cached = preParentCache.get(parent)) === void 0 && !isNodePre(parent)) {
    visited.push(parent);
    parent = parent.parentNode;
  }
  const resultNode = cached === void 0 ? parent : cached;
  for (let i4 = 0; i4 < visited.length; i4++) {
    preParentCache.set(visited[i4], resultNode);
  }
  return resultNode;
}
function $convertTextDOMNode(domNode) {
  const domNode_ = domNode;
  const parentDom = domNode.parentElement;
  if (!(parentDom !== null)) {
    throw Error(`Expected parentElement of Text not to be null`);
  }
  let textContent = domNode_.textContent || "";
  if (findParentPreDOMNode(domNode_) !== null) {
    const parts = textContent.split(/(\r?\n|\t)/);
    const nodes = [];
    const length = parts.length;
    for (let i4 = 0; i4 < length; i4++) {
      const part = parts[i4];
      if (part === "\n" || part === "\r\n") {
        nodes.push($createLineBreakNode());
      } else if (part === "	") {
        nodes.push($createTabNode());
      } else if (part !== "") {
        nodes.push($createTextNode(part));
      }
    }
    return {
      node: nodes
    };
  }
  textContent = textContent.replace(/\r/g, "").replace(/[ \t\n]+/g, " ");
  if (textContent === "") {
    return {
      node: null
    };
  }
  if (textContent[0] === " ") {
    let previousText = domNode_;
    let isStartOfLine = true;
    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {
      const previousTextContent = previousText.textContent || "";
      if (previousTextContent.length > 0) {
        if (/[ \t\n]$/.test(previousTextContent)) {
          textContent = textContent.slice(1);
        }
        isStartOfLine = false;
        break;
      }
    }
    if (isStartOfLine) {
      textContent = textContent.slice(1);
    }
  }
  if (textContent[textContent.length - 1] === " ") {
    let nextText = domNode_;
    let isEndOfLine = true;
    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {
      const nextTextContent = (nextText.textContent || "").replace(/^( |\t|\r?\n)+/, "");
      if (nextTextContent.length > 0) {
        isEndOfLine = false;
        break;
      }
    }
    if (isEndOfLine) {
      textContent = textContent.slice(0, textContent.length - 1);
    }
  }
  if (textContent === "") {
    return {
      node: null
    };
  }
  return {
    node: $createTextNode(textContent)
  };
}
function findTextInLine(text, forward) {
  let node = text;
  while (true) {
    let sibling;
    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {
      const parentElement = node.parentElement;
      if (parentElement === null) {
        return null;
      }
      node = parentElement;
    }
    node = sibling;
    if (node.nodeType === DOM_ELEMENT_TYPE) {
      const display = node.style.display;
      if (display === "" && !isInlineDomNode(node) || display !== "" && !display.startsWith("inline")) {
        return null;
      }
    }
    let descendant = node;
    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {
      node = descendant;
    }
    if (node.nodeType === DOM_TEXT_TYPE) {
      return node;
    } else if (node.nodeName === "BR") {
      return null;
    }
  }
}
function convertTextFormatElement(domNode) {
  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];
  if (format === void 0) {
    return {
      node: null
    };
  }
  return {
    forChild: applyTextFormatFromStyle(domNode.style, format),
    node: null
  };
}
function $createTextNode(text = "") {
  return $applyNodeReplacement(new TextNode(text));
}
function $isTextNode(node) {
  return node instanceof TextNode;
}
function applyTextFormatFromStyle(style, shouldApply) {
  const fontWeight = style.fontWeight;
  const textDecoration = style.textDecoration.split(" ");
  const hasBoldFontWeight = fontWeight === "700" || fontWeight === "bold";
  const hasLinethroughTextDecoration = textDecoration.includes("line-through");
  const hasItalicFontStyle = style.fontStyle === "italic";
  const hasUnderlineTextDecoration = textDecoration.includes("underline");
  const verticalAlign = style.verticalAlign;
  return (lexicalNode) => {
    if (!$isTextNode(lexicalNode)) {
      return lexicalNode;
    }
    if (hasBoldFontWeight && !lexicalNode.hasFormat("bold")) {
      lexicalNode.toggleFormat("bold");
    }
    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat("strikethrough")) {
      lexicalNode.toggleFormat("strikethrough");
    }
    if (hasItalicFontStyle && !lexicalNode.hasFormat("italic")) {
      lexicalNode.toggleFormat("italic");
    }
    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat("underline")) {
      lexicalNode.toggleFormat("underline");
    }
    if (verticalAlign === "sub" && !lexicalNode.hasFormat("subscript")) {
      lexicalNode.toggleFormat("subscript");
    }
    if (verticalAlign === "super" && !lexicalNode.hasFormat("superscript")) {
      lexicalNode.toggleFormat("superscript");
    }
    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {
      lexicalNode.toggleFormat(shouldApply);
    }
    return lexicalNode;
  };
}
function $createTabNode() {
  return $applyNodeReplacement(new TabNode());
}
function $isTabNode(node) {
  return node instanceof TabNode;
}
function $createPoint(key, offset3, type) {
  return new Point(key, offset3, type);
}
function selectPointOnNode(point, node) {
  let key = node.__key;
  let offset3 = point.offset;
  let type = "element";
  if ($isTextNode(node)) {
    type = "text";
    const textContentLength = node.getTextContentSize();
    if (offset3 > textContentLength) {
      offset3 = textContentLength;
    }
  } else if (!$isElementNode(node)) {
    const nextSibling = node.getNextSibling();
    if ($isTextNode(nextSibling)) {
      key = nextSibling.__key;
      offset3 = 0;
      type = "text";
    } else {
      const parentNode = node.getParent();
      if (parentNode) {
        key = parentNode.__key;
        offset3 = node.getIndexWithinParent() + 1;
      }
    }
  }
  point.set(key, offset3, type);
}
function $moveSelectionPointToEnd(point, node) {
  if ($isElementNode(node)) {
    const lastNode = node.getLastDescendant();
    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
      selectPointOnNode(point, lastNode);
    } else {
      selectPointOnNode(point, node);
    }
  } else {
    selectPointOnNode(point, node);
  }
}
function $transferStartingElementPointToTextPoint(start, end, format, style) {
  const element = start.getNode();
  const placementNode = element.getChildAtIndex(start.offset);
  const textNode = $createTextNode();
  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;
  textNode.setFormat(format);
  textNode.setStyle(style);
  if (placementNode === null) {
    element.append(target);
  } else {
    placementNode.insertBefore(target);
  }
  if (start.is(end)) {
    end.set(textNode.__key, 0, "text");
  }
  start.set(textNode.__key, 0, "text");
}
function $setPointValues(point, key, offset3, type) {
  point.key = key;
  point.offset = offset3;
  point.type = type;
}
function $isRangeSelection(x6) {
  return x6 instanceof RangeSelection;
}
function $isNodeSelection(x6) {
  return x6 instanceof NodeSelection;
}
function getCharacterOffset(point) {
  const offset3 = point.offset;
  if (point.type === "text") {
    return offset3;
  }
  const parent = point.getNode();
  return offset3 === parent.getChildrenSize() ? parent.getTextContent().length : 0;
}
function $getCharacterOffsets(selection) {
  const anchorAndFocus = selection.getStartEndPoints();
  if (anchorAndFocus === null) {
    return [0, 0];
  }
  const [anchor, focus] = anchorAndFocus;
  if (anchor.type === "element" && focus.type === "element" && anchor.key === focus.key && anchor.offset === focus.offset) {
    return [0, 0];
  }
  return [getCharacterOffset(anchor), getCharacterOffset(focus)];
}
function $swapPoints(selection) {
  const focus = selection.focus;
  const anchor = selection.anchor;
  const anchorKey = anchor.key;
  const anchorOffset = anchor.offset;
  const anchorType = anchor.type;
  $setPointValues(anchor, focus.key, focus.offset, focus.type);
  $setPointValues(focus, anchorKey, anchorOffset, anchorType);
  selection._cachedNodes = null;
}
function moveNativeSelection(domSelection, alter, direction, granularity) {
  domSelection.modify(alter, direction, granularity);
}
function $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (anchorNode === focusNode && anchor.type === "text" && focus.type === "text") {
    const anchorOffset = anchor.offset;
    const focusOffset = focus.offset;
    const isBefore = anchorOffset < focusOffset;
    const startOffset = isBefore ? anchorOffset : focusOffset;
    const endOffset = isBefore ? focusOffset : anchorOffset;
    const characterOffset = endOffset - 1;
    if (startOffset !== characterOffset) {
      const text = anchorNode.getTextContent().slice(startOffset, endOffset);
      if (!doesContainGrapheme(text)) {
        if (isBackward) {
          focus.offset = characterOffset;
        } else {
          anchor.offset = characterOffset;
        }
      }
    }
  }
}
function $removeSegment(node, isBackward, offset3) {
  const textNode = node;
  const textContent = textNode.getTextContent();
  const split = textContent.split(/(?=\s)/g);
  const splitLength = split.length;
  let segmentOffset = 0;
  let restoreOffset = 0;
  for (let i4 = 0; i4 < splitLength; i4++) {
    const text = split[i4];
    const isLast = i4 === splitLength - 1;
    restoreOffset = segmentOffset;
    segmentOffset += text.length;
    if (isBackward && segmentOffset === offset3 || segmentOffset > offset3 || isLast) {
      split.splice(i4, 1);
      if (isLast) {
        restoreOffset = void 0;
      }
      break;
    }
  }
  const nextTextContent = split.join("").trim();
  if (nextTextContent === "") {
    textNode.remove();
  } else {
    textNode.setTextContent(nextTextContent);
    textNode.select(restoreOffset, restoreOffset);
  }
}
function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
  const parent = resolvedElement.getParent();
  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
}
function $internalResolveSelectionPoint(dom, offset3, lastPoint, editor) {
  let resolvedOffset = offset3;
  let resolvedNode;
  if (dom.nodeType === DOM_ELEMENT_TYPE) {
    let moveSelectionToEnd = false;
    const childNodes = dom.childNodes;
    const childNodesLength = childNodes.length;
    const blockCursorElement = editor._blockCursorElement;
    if (resolvedOffset === childNodesLength) {
      moveSelectionToEnd = true;
      resolvedOffset = childNodesLength - 1;
    }
    let childDOM = childNodes[resolvedOffset];
    let hasBlockCursor = false;
    if (childDOM === blockCursorElement) {
      childDOM = childNodes[resolvedOffset + 1];
      hasBlockCursor = true;
    } else if (blockCursorElement !== null) {
      const blockCursorElementParent = blockCursorElement.parentNode;
      if (dom === blockCursorElementParent) {
        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);
        if (offset3 > blockCursorOffset) {
          resolvedOffset--;
        }
      }
    }
    resolvedNode = $getNodeFromDOM(childDOM);
    if ($isTextNode(resolvedNode)) {
      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);
    } else {
      let resolvedElement = $getNodeFromDOM(dom);
      if (resolvedElement === null) {
        return null;
      }
      if ($isElementNode(resolvedElement)) {
        resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset);
        let child = resolvedElement.getChildAtIndex(resolvedOffset);
        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();
          if (descendant === null) {
            resolvedElement = child;
          } else {
            child = descendant;
            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();
          }
          resolvedOffset = 0;
        }
        if ($isTextNode(child)) {
          resolvedNode = child;
          resolvedElement = null;
          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);
        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
          resolvedOffset++;
        }
      } else {
        const index = resolvedElement.getIndexWithinParent();
        if (offset3 === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {
          resolvedOffset = index;
        } else {
          resolvedOffset = index + 1;
        }
        resolvedElement = resolvedElement.getParentOrThrow();
      }
      if ($isElementNode(resolvedElement)) {
        return $createPoint(resolvedElement.__key, resolvedOffset, "element");
      }
    }
  } else {
    resolvedNode = $getNodeFromDOM(dom);
  }
  if (!$isTextNode(resolvedNode)) {
    return null;
  }
  return $createPoint(resolvedNode.__key, resolvedOffset, "text");
}
function resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {
  const offset3 = point.offset;
  const node = point.getNode();
  if (offset3 === 0) {
    const prevSibling = node.getPreviousSibling();
    const parent = node.getParent();
    if (!isBackward) {
      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {
        point.key = prevSibling.__key;
        point.offset = prevSibling.getChildrenSize();
        point.type = "element";
      } else if ($isTextNode(prevSibling)) {
        point.key = prevSibling.__key;
        point.offset = prevSibling.getTextContent().length;
      }
    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {
      const parentSibling = parent.getPreviousSibling();
      if ($isTextNode(parentSibling)) {
        point.key = parentSibling.__key;
        point.offset = parentSibling.getTextContent().length;
      }
    }
  } else if (offset3 === node.getTextContent().length) {
    const nextSibling = node.getNextSibling();
    const parent = node.getParent();
    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {
      point.key = nextSibling.__key;
      point.offset = 0;
      point.type = "element";
    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
      const parentSibling = parent.getNextSibling();
      if ($isTextNode(parentSibling)) {
        point.key = parentSibling.__key;
        point.offset = 0;
      }
    }
  }
}
function $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {
  if (anchor.type === "text" && focus.type === "text") {
    const isBackward = anchor.isBefore(focus);
    const isCollapsed = anchor.is(focus);
    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);
    if (isCollapsed) {
      focus.key = anchor.key;
      focus.offset = anchor.offset;
      focus.type = anchor.type;
    }
    const editor = getActiveEditor();
    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {
      const lastAnchor = lastSelection.anchor;
      const lastFocus = lastSelection.focus;
      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);
      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);
    }
  }
}
function $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    return null;
  }
  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);
  if (resolvedAnchorPoint === null) {
    return null;
  }
  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);
  if (resolvedFocusPoint === null) {
    return null;
  }
  if (resolvedAnchorPoint.type === "element" && resolvedFocusPoint.type === "element") {
    const anchorNode = $getNodeFromDOM(anchorDOM);
    const focusNode = $getNodeFromDOM(focusDOM);
    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {
      return null;
    }
  }
  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
  return [resolvedAnchorPoint, resolvedFocusPoint];
}
function $isBlockElementNode(node) {
  return $isElementNode(node) && !node.isInline();
}
function $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
  const editorState = getActiveEditorState();
  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, "");
  selection.dirty = true;
  editorState._selection = selection;
  return selection;
}
function $createRangeSelection() {
  const anchor = $createPoint("root", 0, "element");
  const focus = $createPoint("root", 0, "element");
  return new RangeSelection(anchor, focus, 0, "");
}
function $createNodeSelection() {
  return new NodeSelection(/* @__PURE__ */ new Set());
}
function $internalCreateSelection(editor) {
  const currentEditorState = editor.getEditorState();
  const lastSelection = currentEditorState._selection;
  const domSelection = getDOMSelection(editor._window);
  if ($isRangeSelection(lastSelection) || lastSelection == null) {
    return $internalCreateRangeSelection(lastSelection, domSelection, editor, null);
  }
  return lastSelection.clone();
}
function $createRangeSelectionFromDom(domSelection, editor) {
  return $internalCreateRangeSelection(null, domSelection, editor, null);
}
function $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {
  const windowObj = editor._window;
  if (windowObj === null) {
    return null;
  }
  const windowEvent = event || windowObj.event;
  const eventType = windowEvent ? windowEvent.type : void 0;
  const isSelectionChange = eventType === "selectionchange";
  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === "beforeinput" || eventType === "compositionstart" || eventType === "compositionend" || eventType === "click" && windowEvent && windowEvent.detail === 3 || eventType === "drop" || eventType === void 0);
  let anchorDOM, focusDOM, anchorOffset, focusOffset;
  if (!$isRangeSelection(lastSelection) || useDOMSelection) {
    if (domSelection === null) {
      return null;
    }
    anchorDOM = domSelection.anchorNode;
    focusDOM = domSelection.focusNode;
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return lastSelection.clone();
    }
  } else {
    return lastSelection.clone();
  }
  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);
  if (resolvedSelectionPoints === null) {
    return null;
  }
  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? "" : lastSelection.style);
}
function $getSelection() {
  const editorState = getActiveEditorState();
  return editorState._selection;
}
function $getPreviousSelection() {
  const editor = getActiveEditor();
  return editor._editorState._selection;
}
function $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
    return;
  }
  const parentKey = parentNode.__key;
  if (selection.isCollapsed()) {
    const selectionOffset = anchor.offset;
    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {
      const newSelectionOffset = Math.max(0, selectionOffset + times);
      anchor.set(parentKey, newSelectionOffset, "element");
      focus.set(parentKey, newSelectionOffset, "element");
      $updateSelectionResolveTextNodes(selection);
    }
  } else {
    const isBackward = selection.isBackward();
    const firstPoint = isBackward ? focus : anchor;
    const firstPointNode = firstPoint.getNode();
    const lastPoint = isBackward ? anchor : focus;
    const lastPointNode = lastPoint.getNode();
    if (parentNode.is(firstPointNode)) {
      const firstPointOffset = firstPoint.offset;
      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {
        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), "element");
      }
    }
    if (parentNode.is(lastPointNode)) {
      const lastPointOffset = lastPoint.offset;
      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {
        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), "element");
      }
    }
  }
  $updateSelectionResolveTextNodes(selection);
}
function $updateSelectionResolveTextNodes(selection) {
  const anchor = selection.anchor;
  const anchorOffset = anchor.offset;
  const focus = selection.focus;
  const focusOffset = focus.offset;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (selection.isCollapsed()) {
    if (!$isElementNode(anchorNode)) {
      return;
    }
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
      focus.set(child.__key, newOffset, "text");
    }
    return;
  }
  if ($isElementNode(anchorNode)) {
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
    }
  }
  if ($isElementNode(focusNode)) {
    const childSize = focusNode.getChildrenSize();
    const focusOffsetAtEnd = focusOffset >= childSize;
    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (focusOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      focus.set(child.__key, newOffset, "text");
    }
  }
}
function applySelectionTransforms(nextEditorState, editor) {
  const prevEditorState = editor.getEditorState();
  const prevSelection = prevEditorState._selection;
  const nextSelection = nextEditorState._selection;
  if ($isRangeSelection(nextSelection)) {
    const anchor = nextSelection.anchor;
    const focus = nextSelection.focus;
    let anchorNode;
    if (anchor.type === "text") {
      anchorNode = anchor.getNode();
      anchorNode.selectionTransform(prevSelection, nextSelection);
    }
    if (focus.type === "text") {
      const focusNode = focus.getNode();
      if (anchorNode !== focusNode) {
        focusNode.selectionTransform(prevSelection, nextSelection);
      }
    }
  }
}
function moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {
  let siblingKey = null;
  let offset3 = 0;
  let type = null;
  if (prevSibling !== null) {
    siblingKey = prevSibling.__key;
    if ($isTextNode(prevSibling)) {
      offset3 = prevSibling.getTextContentSize();
      type = "text";
    } else if ($isElementNode(prevSibling)) {
      offset3 = prevSibling.getChildrenSize();
      type = "element";
    }
  } else {
    if (nextSibling !== null) {
      siblingKey = nextSibling.__key;
      if ($isTextNode(nextSibling)) {
        type = "text";
      } else if ($isElementNode(nextSibling)) {
        type = "element";
      }
    }
  }
  if (siblingKey !== null && type !== null) {
    point.set(siblingKey, offset3, type);
  } else {
    offset3 = node.getIndexWithinParent();
    if (offset3 === -1) {
      offset3 = parent.getChildrenSize();
    }
    point.set(parent.__key, offset3, "element");
  }
}
function adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {
  if (point.type === "text") {
    point.key = key;
    if (!isBefore) {
      point.offset += textLength;
    }
  } else if (point.offset > target.getIndexWithinParent()) {
    point.offset -= 1;
  }
}
function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {
  const anchorDOMNode = domSelection.anchorNode;
  const focusDOMNode = domSelection.focusNode;
  const anchorOffset = domSelection.anchorOffset;
  const focusOffset = domSelection.focusOffset;
  const activeElement = document.activeElement;
  if (tags.has("collaboration") && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
    return;
  }
  if (!$isRangeSelection(nextSelection)) {
    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
      domSelection.removeAllRanges();
    }
    return;
  }
  const anchor = nextSelection.anchor;
  const focus = nextSelection.focus;
  const anchorKey = anchor.key;
  const focusKey = focus.key;
  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
  const focusDOM = getElementByKeyOrThrow(editor, focusKey);
  const nextAnchorOffset = anchor.offset;
  const nextFocusOffset = focus.offset;
  const nextFormat = nextSelection.format;
  const nextStyle = nextSelection.style;
  const isCollapsed = nextSelection.isCollapsed();
  let nextAnchorNode = anchorDOM;
  let nextFocusNode = focusDOM;
  let anchorFormatOrStyleChanged = false;
  if (anchor.type === "text") {
    nextAnchorNode = getDOMTextNode(anchorDOM);
    const anchorNode = anchor.getNode();
    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;
  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === "text") {
    anchorFormatOrStyleChanged = true;
  }
  if (focus.type === "text") {
    nextFocusNode = getDOMTextNode(focusDOM);
  }
  if (nextAnchorNode === null || nextFocusNode === null) {
    return;
  }
  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {
    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());
  }
  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
  !(domSelection.type === "Range" && isCollapsed)) {
    if (activeElement === null || !rootElement.contains(activeElement)) {
      rootElement.focus({
        preventScroll: true
      });
    }
    if (anchor.type !== "element") {
      return;
    }
  }
  try {
    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
  } catch (error) {
    {
      console.warn(error);
    }
  }
  if (!tags.has("skip-scroll-into-view") && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === "element" ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;
    if (selectionTarget !== null) {
      let selectionRect;
      if (selectionTarget instanceof Text) {
        const range = document.createRange();
        range.selectNode(selectionTarget);
        selectionRect = range.getBoundingClientRect();
      } else {
        selectionRect = selectionTarget.getBoundingClientRect();
      }
      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
    }
  }
  markSelectionChangeFromDOMUpdate();
}
function $insertNodes(nodes) {
  let selection = $getSelection() || $getPreviousSelection();
  if (selection === null) {
    selection = $getRoot().selectEnd();
  }
  selection.insertNodes(nodes);
}
function $getTextContent() {
  const selection = $getSelection();
  if (selection === null) {
    return "";
  }
  return selection.getTextContent();
}
function $removeTextAndSplitBlock(selection) {
  let selection_ = selection;
  if (!selection.isCollapsed()) {
    selection_.removeText();
  }
  const newSelection = $getSelection();
  if ($isRangeSelection(newSelection)) {
    selection_ = newSelection;
  }
  if (!$isRangeSelection(selection_)) {
    throw Error(`Unexpected dirty selection to be null`);
  }
  const anchor = selection_.anchor;
  let node = anchor.getNode();
  let offset3 = anchor.offset;
  while (!INTERNAL_$isBlock(node)) {
    [node, offset3] = $splitNodeAtPoint(node, offset3);
  }
  return offset3;
}
function $splitNodeAtPoint(node, offset3) {
  const parent = node.getParent();
  if (!parent) {
    const paragraph = $createParagraphNode();
    $getRoot().append(paragraph);
    paragraph.select();
    return [$getRoot(), 0];
  }
  if ($isTextNode(node)) {
    const split = node.splitText(offset3);
    if (split.length === 0) {
      return [parent, node.getIndexWithinParent()];
    }
    const x6 = offset3 === 0 ? 0 : 1;
    const index = split[0].getIndexWithinParent() + x6;
    return [parent, index];
  }
  if (!$isElementNode(node) || offset3 === 0) {
    return [parent, node.getIndexWithinParent()];
  }
  const firstToAppend = node.getChildAtIndex(offset3);
  if (firstToAppend) {
    const insertPoint = new RangeSelection($createPoint(node.__key, offset3, "element"), $createPoint(node.__key, offset3, "element"), 0, "");
    const newElement = node.insertNewAfter(insertPoint);
    if (newElement) {
      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());
    }
  }
  return [parent, node.getIndexWithinParent() + 1];
}
function $wrapInlineNodes(nodes) {
  const virtualRoot = $createParagraphNode();
  let currentBlock = null;
  for (let i4 = 0; i4 < nodes.length; i4++) {
    const node = nodes[i4];
    const isLineBreakNode = $isLineBreakNode(node);
    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {
      if (currentBlock === null) {
        currentBlock = node.createParentElementNode();
        virtualRoot.append(currentBlock);
        if (isLineBreakNode) {
          continue;
        }
      }
      if (currentBlock !== null) {
        currentBlock.append(node);
      }
    } else {
      virtualRoot.append(node);
      currentBlock = null;
    }
  }
  return virtualRoot;
}
function isCurrentlyReadOnlyMode() {
  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
}
function errorOnReadOnly() {
  if (isReadOnlyMode) {
    {
      throw Error(`Cannot use method in read-only mode.`);
    }
  }
}
function errorOnInfiniteTransforms() {
  if (infiniteTransformCount > 99) {
    {
      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
    }
  }
}
function getActiveEditorState() {
  if (activeEditorState === null) {
    {
      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);
    }
  }
  return activeEditorState;
}
function getActiveEditor() {
  if (activeEditor === null) {
    {
      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);
    }
  }
  return activeEditor;
}
function internalGetActiveEditor() {
  return activeEditor;
}
function internalGetActiveEditorState() {
  return activeEditorState;
}
function $applyTransforms(editor, node, transformsCache) {
  const type = node.__type;
  const registeredNode = getRegisteredNodeOrThrow(editor, type);
  let transformsArr = transformsCache.get(type);
  if (transformsArr === void 0) {
    transformsArr = Array.from(registeredNode.transforms);
    transformsCache.set(type, transformsArr);
  }
  const transformsArrLength = transformsArr.length;
  for (let i4 = 0; i4 < transformsArrLength; i4++) {
    transformsArr[i4](node);
    if (!node.isAttached()) {
      break;
    }
  }
}
function $isNodeValidForTransform(node, compositionKey) {
  return node !== void 0 && // We don't want to transform nodes being composed
  node.__key !== compositionKey && node.isAttached();
}
function $normalizeAllDirtyTextNodes(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const nodeMap = editorState._nodeMap;
  for (const nodeKey of dirtyLeaves) {
    const node = nodeMap.get(nodeKey);
    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
      $normalizeTextNode(node);
    }
  }
}
function $applyAllTransforms(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const nodeMap = editorState._nodeMap;
  const compositionKey = $getCompositionKey();
  const transformsCache = /* @__PURE__ */ new Map();
  let untransformedDirtyLeaves = dirtyLeaves;
  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
  let untransformedDirtyElements = dirtyElements;
  let untransformedDirtyElementsLength = untransformedDirtyElements.size;
  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
    if (untransformedDirtyLeavesLength > 0) {
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      for (const nodeKey of untransformedDirtyLeaves) {
        const node = nodeMap.get(nodeKey);
        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
          $normalizeTextNode(node);
        }
        if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
          $applyTransforms(editor, node, transformsCache);
        }
        dirtyLeaves.add(nodeKey);
      }
      untransformedDirtyLeaves = editor._dirtyLeaves;
      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
      if (untransformedDirtyLeavesLength > 0) {
        infiniteTransformCount++;
        continue;
      }
    }
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
      const nodeKey = currentUntransformedDirtyElement[0];
      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];
      if (nodeKey !== "root" && !intentionallyMarkedAsDirty) {
        continue;
      }
      const node = nodeMap.get(nodeKey);
      if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
        $applyTransforms(editor, node, transformsCache);
      }
      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
    }
    untransformedDirtyLeaves = editor._dirtyLeaves;
    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
    untransformedDirtyElements = editor._dirtyElements;
    untransformedDirtyElementsLength = untransformedDirtyElements.size;
    infiniteTransformCount++;
  }
  editor._dirtyLeaves = dirtyLeaves;
  editor._dirtyElements = dirtyElements;
}
function $parseSerializedNode(serializedNode) {
  const internalSerializedNode = serializedNode;
  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
}
function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
  const type = serializedNode.type;
  const registeredNode = registeredNodes.get(type);
  if (registeredNode === void 0) {
    {
      throw Error(`parseEditorState: type "${type}" + not found`);
    }
  }
  const nodeClass = registeredNode.klass;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
    }
  }
  const node = nodeClass.importJSON(serializedNode);
  const children = serializedNode.children;
  if ($isElementNode(node) && Array.isArray(children)) {
    for (let i4 = 0; i4 < children.length; i4++) {
      const serializedJSONChildNode = children[i4];
      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
      node.append(childNode);
    }
  }
  return node;
}
function parseEditorState(serializedEditorState, editor, updateFn) {
  const editorState = createEmptyEditorState();
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previousDirtyElements = editor._dirtyElements;
  const previousDirtyLeaves = editor._dirtyLeaves;
  const previousCloneNotNeeded = editor._cloneNotNeeded;
  const previousDirtyType = editor._dirtyType;
  editor._dirtyElements = /* @__PURE__ */ new Map();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._cloneNotNeeded = /* @__PURE__ */ new Set();
  editor._dirtyType = 0;
  activeEditorState = editorState;
  isReadOnlyMode = false;
  activeEditor = editor;
  try {
    const registeredNodes = editor._nodes;
    const serializedNode = serializedEditorState.root;
    $parseSerializedNodeImpl(serializedNode, registeredNodes);
    if (updateFn) {
      updateFn();
    }
    editorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(editorState);
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
  } finally {
    editor._dirtyElements = previousDirtyElements;
    editor._dirtyLeaves = previousDirtyLeaves;
    editor._cloneNotNeeded = previousCloneNotNeeded;
    editor._dirtyType = previousDirtyType;
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
  return editorState;
}
function readEditorState(editorState, callbackFn) {
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  activeEditorState = editorState;
  isReadOnlyMode = true;
  activeEditor = null;
  try {
    return callbackFn();
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
}
function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
  const nodeMap = pendingEditorState._nodeMap;
  nodeMap.set = () => {
    throw new Error("Cannot call set() on a frozen Lexical node map");
  };
  nodeMap.clear = () => {
    throw new Error("Cannot call clear() on a frozen Lexical node map");
  };
  nodeMap.delete = () => {
    throw new Error("Cannot call delete() on a frozen Lexical node map");
  };
}
function $commitPendingUpdates(editor, recoveryEditorState) {
  const pendingEditorState = editor._pendingEditorState;
  const rootElement = editor._rootElement;
  const shouldSkipDOM = editor._headless || rootElement === null;
  if (pendingEditorState === null) {
    return;
  }
  const currentEditorState = editor._editorState;
  const currentSelection = currentEditorState._selection;
  const pendingSelection = pendingEditorState._selection;
  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  const observer = editor._observer;
  let mutatedNodes2 = null;
  editor._pendingEditorState = null;
  editor._editorState = pendingEditorState;
  if (!shouldSkipDOM && needsUpdate && observer !== null) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    isReadOnlyMode = false;
    editor._updating = true;
    try {
      const dirtyType = editor._dirtyType;
      const dirtyElements2 = editor._dirtyElements;
      const dirtyLeaves2 = editor._dirtyLeaves;
      observer.disconnect();
      mutatedNodes2 = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements2, dirtyLeaves2);
    } catch (error) {
      if (error instanceof Error) {
        editor._onError(error);
      }
      if (!isAttemptingToRecoverFromReconcilerError) {
        resetEditor(editor, null, rootElement, pendingEditorState);
        initMutationObserver(editor);
        editor._dirtyType = FULL_RECONCILE;
        isAttemptingToRecoverFromReconcilerError = true;
        $commitPendingUpdates(editor, currentEditorState);
        isAttemptingToRecoverFromReconcilerError = false;
      } else {
        throw error;
      }
      return;
    } finally {
      observer.observe(rootElement, observerOptions);
      editor._updating = previouslyUpdating;
      activeEditorState = previousActiveEditorState;
      isReadOnlyMode = previousReadOnlyMode;
      activeEditor = previousActiveEditor;
    }
  }
  if (!pendingEditorState._readOnly) {
    pendingEditorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);
      if ($isRangeSelection(pendingSelection)) {
        Object.freeze(pendingSelection.anchor);
        Object.freeze(pendingSelection.focus);
      }
      Object.freeze(pendingSelection);
    }
  }
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const normalizedNodes = editor._normalizedNodes;
  const tags = editor._updateTags;
  const deferred = editor._deferred;
  if (needsUpdate) {
    editor._dirtyType = NO_DIRTY_NODES;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    editor._normalizedNodes = /* @__PURE__ */ new Set();
    editor._updateTags = /* @__PURE__ */ new Set();
  }
  $garbageCollectDetachedDecorators(editor, pendingEditorState);
  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);
  if (editor._editable && // domSelection will be null in headless
  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    try {
      if (observer !== null) {
        observer.disconnect();
      }
      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
        const blockCursorElement = editor._blockCursorElement;
        if (blockCursorElement !== null) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);
      }
      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);
      if (observer !== null) {
        observer.observe(rootElement, observerOptions);
      }
    } finally {
      activeEditor = previousActiveEditor;
      activeEditorState = previousActiveEditorState;
    }
  }
  if (mutatedNodes2 !== null) {
    triggerMutationListeners(editor, mutatedNodes2, tags, dirtyLeaves, currentEditorState);
  }
  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
  }
  const pendingDecorators = editor._pendingDecorators;
  if (pendingDecorators !== null) {
    editor._decorators = pendingDecorators;
    editor._pendingDecorators = null;
    triggerListeners("decorator", editor, true, pendingDecorators);
  }
  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);
  triggerListeners("update", editor, true, {
    dirtyElements,
    dirtyLeaves,
    editorState: pendingEditorState,
    normalizedNodes,
    prevEditorState: recoveryEditorState || currentEditorState,
    tags
  });
  triggerDeferredUpdateCallbacks(editor, deferred);
  $triggerEnqueuedUpdates(editor);
}
function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
  const currentTextContent = getEditorStateTextContent(currentEditorState);
  const latestTextContent = getEditorStateTextContent(pendingEditorState);
  if (currentTextContent !== latestTextContent) {
    triggerListeners("textcontent", editor, true, latestTextContent);
  }
}
function triggerMutationListeners(editor, mutatedNodes2, updateTags, dirtyLeaves, prevEditorState) {
  const listeners = Array.from(editor._listeners.mutation);
  const listenersLength = listeners.length;
  for (let i4 = 0; i4 < listenersLength; i4++) {
    const [listener, klass] = listeners[i4];
    const mutatedNodesByType = mutatedNodes2.get(klass);
    if (mutatedNodesByType !== void 0) {
      listener(mutatedNodesByType, {
        dirtyLeaves,
        prevEditorState,
        updateTags
      });
    }
  }
}
function triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {
  const previouslyUpdating = editor._updating;
  editor._updating = isCurrentlyEnqueuingUpdates;
  try {
    const listeners = Array.from(editor._listeners[type]);
    for (let i4 = 0; i4 < listeners.length; i4++) {
      listeners[i4].apply(null, payload);
    }
  } finally {
    editor._updating = previouslyUpdating;
  }
}
function triggerCommandListeners(editor, type, payload) {
  if (editor._updating === false || activeEditor !== editor) {
    let returnVal = false;
    editor.update(() => {
      returnVal = triggerCommandListeners(editor, type, payload);
    });
    return returnVal;
  }
  const editors = getEditorsToPropagate(editor);
  for (let i4 = 4; i4 >= 0; i4--) {
    for (let e6 = 0; e6 < editors.length; e6++) {
      const currentEditor = editors[e6];
      const commandListeners = currentEditor._commands;
      const listenerInPriorityOrder = commandListeners.get(type);
      if (listenerInPriorityOrder !== void 0) {
        const listenersSet = listenerInPriorityOrder[i4];
        if (listenersSet !== void 0) {
          const listeners = Array.from(listenersSet);
          const listenersLength = listeners.length;
          for (let j5 = 0; j5 < listenersLength; j5++) {
            if (listeners[j5](payload, editor) === true) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
function $triggerEnqueuedUpdates(editor) {
  const queuedUpdates = editor._updates;
  if (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [updateFn, options] = queuedUpdate;
      $beginUpdate(editor, updateFn, options);
    }
  }
}
function triggerDeferredUpdateCallbacks(editor, deferred) {
  editor._deferred = [];
  if (deferred.length !== 0) {
    const previouslyUpdating = editor._updating;
    editor._updating = true;
    try {
      for (let i4 = 0; i4 < deferred.length; i4++) {
        deferred[i4]();
      }
    } finally {
      editor._updating = previouslyUpdating;
    }
  }
}
function processNestedUpdates(editor, initialSkipTransforms) {
  const queuedUpdates = editor._updates;
  let skipTransforms = initialSkipTransforms || false;
  while (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [nextUpdateFn, options] = queuedUpdate;
      let onUpdate;
      let tag;
      if (options !== void 0) {
        onUpdate = options.onUpdate;
        tag = options.tag;
        if (options.skipTransforms) {
          skipTransforms = true;
        }
        if (onUpdate) {
          editor._deferred.push(onUpdate);
        }
        if (tag) {
          editor._updateTags.add(tag);
        }
      }
      nextUpdateFn();
    }
  }
  return skipTransforms;
}
function $beginUpdate(editor, updateFn, options) {
  const updateTags = editor._updateTags;
  let onUpdate;
  let tag;
  let skipTransforms = false;
  let discrete = false;
  if (options !== void 0) {
    onUpdate = options.onUpdate;
    tag = options.tag;
    if (tag != null) {
      updateTags.add(tag);
    }
    skipTransforms = options.skipTransforms || false;
    discrete = options.discrete || false;
  }
  if (onUpdate) {
    editor._deferred.push(onUpdate);
  }
  const currentEditorState = editor._editorState;
  let pendingEditorState = editor._pendingEditorState;
  let editorStateWasCloned = false;
  if (pendingEditorState === null || pendingEditorState._readOnly) {
    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
    editorStateWasCloned = true;
  }
  pendingEditorState._flushSync = discrete;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  activeEditorState = pendingEditorState;
  isReadOnlyMode = false;
  editor._updating = true;
  activeEditor = editor;
  try {
    if (editorStateWasCloned) {
      if (editor._headless) {
        if (currentEditorState._selection !== null) {
          pendingEditorState._selection = currentEditorState._selection.clone();
        }
      } else {
        pendingEditorState._selection = $internalCreateSelection(editor);
      }
    }
    const startingCompositionKey = editor._compositionKey;
    updateFn();
    skipTransforms = processNestedUpdates(editor, skipTransforms);
    applySelectionTransforms(pendingEditorState, editor);
    if (editor._dirtyType !== NO_DIRTY_NODES) {
      if (skipTransforms) {
        $normalizeAllDirtyTextNodes(pendingEditorState, editor);
      } else {
        $applyAllTransforms(pendingEditorState, editor);
      }
      processNestedUpdates(editor);
      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
    }
    const endingCompositionKey = editor._compositionKey;
    if (startingCompositionKey !== endingCompositionKey) {
      pendingEditorState._flushSync = true;
    }
    const pendingSelection = pendingEditorState._selection;
    if ($isRangeSelection(pendingSelection)) {
      const pendingNodeMap = pendingEditorState._nodeMap;
      const anchorKey = pendingSelection.anchor.key;
      const focusKey = pendingSelection.focus.key;
      if (pendingNodeMap.get(anchorKey) === void 0 || pendingNodeMap.get(focusKey) === void 0) {
        {
          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
        }
      }
    } else if ($isNodeSelection(pendingSelection)) {
      if (pendingSelection._nodes.size === 0) {
        pendingEditorState._selection = null;
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
    editor._pendingEditorState = currentEditorState;
    editor._dirtyType = FULL_RECONCILE;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements.clear();
    $commitPendingUpdates(editor);
    return;
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
    editor._updating = previouslyUpdating;
    infiniteTransformCount = 0;
  }
  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);
  if (shouldUpdate) {
    if (pendingEditorState._flushSync) {
      pendingEditorState._flushSync = false;
      $commitPendingUpdates(editor);
    } else if (editorStateWasCloned) {
      scheduleMicroTask(() => {
        $commitPendingUpdates(editor);
      });
    }
  } else {
    pendingEditorState._flushSync = false;
    if (editorStateWasCloned) {
      updateTags.clear();
      editor._deferred = [];
      editor._pendingEditorState = null;
    }
  }
}
function updateEditor(editor, updateFn, options) {
  if (editor._updating) {
    editor._updates.push([updateFn, options]);
  } else {
    $beginUpdate(editor, updateFn, options);
  }
}
function $isElementNode(node) {
  return node instanceof ElementNode;
}
function isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {
  let node = point.getNode();
  while (node) {
    const nodeKey = node.__key;
    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
      return true;
    }
    node = node.getParent();
  }
  return false;
}
function $isDecoratorNode(node) {
  return node instanceof DecoratorNode;
}
function $createRootNode() {
  return new RootNode();
}
function $isRootNode(node) {
  return node instanceof RootNode;
}
function editorStateHasDirtySelection(editorState, editor) {
  const currentSelection = editor.getEditorState()._selection;
  const pendingSelection = editorState._selection;
  if (pendingSelection !== null) {
    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
      return true;
    }
  } else if (currentSelection !== null) {
    return true;
  }
  return false;
}
function cloneEditorState(current) {
  return new EditorState(new Map(current._nodeMap));
}
function createEmptyEditorState() {
  return new EditorState(/* @__PURE__ */ new Map([["root", $createRootNode()]]));
}
function exportNodeToJSON(node) {
  const serializedNode = node.exportJSON();
  const nodeClass = node.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    }
  }
  if ($isElementNode(node)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
    const children = node.getChildren();
    for (let i4 = 0; i4 < children.length; i4++) {
      const child = children[i4];
      const serializedChildNode = exportNodeToJSON(child);
      serializedChildren.push(serializedChildNode);
    }
  }
  return serializedNode;
}
function $convertParagraphElement(element) {
  const node = $createParagraphNode();
  if (element.style) {
    node.setFormat(element.style.textAlign);
    const indent = parseInt(element.style.textIndent, 10) / 20;
    if (indent > 0) {
      node.setIndent(indent);
    }
  }
  return {
    node
  };
}
function $createParagraphNode() {
  return $applyNodeReplacement(new ParagraphNode());
}
function $isParagraphNode(node) {
  return node instanceof ParagraphNode;
}
function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
  const keyNodeMap = editor._keyToDOMMap;
  keyNodeMap.clear();
  editor._editorState = createEmptyEditorState();
  editor._pendingEditorState = pendingEditorState;
  editor._compositionKey = null;
  editor._dirtyType = NO_DIRTY_NODES;
  editor._cloneNotNeeded.clear();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._dirtyElements.clear();
  editor._normalizedNodes = /* @__PURE__ */ new Set();
  editor._updateTags = /* @__PURE__ */ new Set();
  editor._updates = [];
  editor._blockCursorElement = null;
  const observer = editor._observer;
  if (observer !== null) {
    observer.disconnect();
    editor._observer = null;
  }
  if (prevRootElement !== null) {
    prevRootElement.textContent = "";
  }
  if (nextRootElement !== null) {
    nextRootElement.textContent = "";
    keyNodeMap.set("root", nextRootElement);
  }
}
function initializeConversionCache(nodes, additionalConversions) {
  const conversionCache = /* @__PURE__ */ new Map();
  const handledConversions = /* @__PURE__ */ new Set();
  const addConversionsToCache = (map) => {
    Object.keys(map).forEach((key) => {
      let currentCache = conversionCache.get(key);
      if (currentCache === void 0) {
        currentCache = [];
        conversionCache.set(key, currentCache);
      }
      currentCache.push(map[key]);
    });
  };
  nodes.forEach((node) => {
    const importDOM = node.klass.importDOM;
    if (importDOM == null || handledConversions.has(importDOM)) {
      return;
    }
    handledConversions.add(importDOM);
    const map = importDOM.call(node.klass);
    if (map !== null) {
      addConversionsToCache(map);
    }
  });
  if (additionalConversions) {
    addConversionsToCache(additionalConversions);
  }
  return conversionCache;
}
function createEditor(editorConfig) {
  const config2 = editorConfig || {};
  const activeEditor2 = internalGetActiveEditor();
  const theme = config2.theme || {};
  const parentEditor = editorConfig === void 0 ? activeEditor2 : config2.parentEditor || null;
  const disableEvents = config2.disableEvents || false;
  const editorState = createEmptyEditorState();
  const namespace = config2.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
  const initialEditorState = config2.editorState;
  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...config2.nodes || []];
  const {
    onError,
    html
  } = config2;
  const isEditable = config2.editable !== void 0 ? config2.editable : true;
  let registeredNodes;
  if (editorConfig === void 0 && activeEditor2 !== null) {
    registeredNodes = activeEditor2._nodes;
  } else {
    registeredNodes = /* @__PURE__ */ new Map();
    for (let i4 = 0; i4 < nodes.length; i4++) {
      let klass = nodes[i4];
      let replace = null;
      let replaceWithKlass = null;
      if (typeof klass !== "function") {
        const options = klass;
        klass = options.replace;
        replace = options.with;
        replaceWithKlass = options.withKlass || null;
      }
      {
        const nodeType = Object.prototype.hasOwnProperty.call(klass, "getType") && klass.getType();
        const name = klass.name;
        if (replaceWithKlass) {
          if (!(replaceWithKlass.prototype instanceof klass)) {
            throw Error(`${replaceWithKlass.name} doesn't extend the ${name}`);
          }
        }
        if (name !== "RootNode" && nodeType !== "root" && nodeType !== "artificial") {
          const proto = klass.prototype;
          ["getType", "clone"].forEach((method) => {
            if (!klass.hasOwnProperty(method)) {
              console.warn(`${name} must implement static "${method}" method`);
            }
          });
          if (
            // eslint-disable-next-line no-prototype-builtins
            !klass.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
            klass.hasOwnProperty("exportDOM")
          ) {
            console.warn(`${name} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
          }
          if (proto instanceof DecoratorNode) {
            if (!proto.hasOwnProperty("decorate")) {
              console.warn(`${proto.constructor.name} must implement "decorate" method`);
            }
          }
          if (
            // eslint-disable-next-line no-prototype-builtins
            !klass.hasOwnProperty("importJSON")
          ) {
            console.warn(`${name} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
          if (
            // eslint-disable-next-line no-prototype-builtins
            !proto.hasOwnProperty("exportJSON")
          ) {
            console.warn(`${name} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
      }
      const type = klass.getType();
      const transform = klass.transform();
      const transforms = /* @__PURE__ */ new Set();
      if (transform !== null) {
        transforms.add(transform);
      }
      registeredNodes.set(type, {
        exportDOM: html && html.export ? html.export.get(klass) : void 0,
        klass,
        replace,
        replaceWithKlass,
        transforms
      });
    }
  }
  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
    disableEvents,
    namespace,
    theme
  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : void 0), isEditable);
  if (initialEditorState !== void 0) {
    editor._pendingEditorState = initialEditorState;
    editor._dirtyType = FULL_RECONCILE;
  }
  return editor;
}
var SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, CLICK_COMMAND, DELETE_CHARACTER_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, PASTE_COMMAND, REMOVE_TEXT_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, FORMAT_TEXT_COMMAND, UNDO_COMMAND, REDO_COMMAND, KEY_DOWN_COMMAND, KEY_ARROW_RIGHT_COMMAND, MOVE_TO_END, KEY_ARROW_LEFT_COMMAND, MOVE_TO_START, KEY_ARROW_UP_COMMAND, KEY_ARROW_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_SPACE_COMMAND, KEY_BACKSPACE_COMMAND, KEY_ESCAPE_COMMAND, KEY_DELETE_COMMAND, KEY_TAB_COMMAND, INSERT_TAB_COMMAND, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, DROP_COMMAND, FORMAT_ELEMENT_COMMAND, DRAGSTART_COMMAND, DRAGOVER_COMMAND, DRAGEND_COMMAND, COPY_COMMAND, CUT_COMMAND, SELECT_ALL_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, FOCUS_COMMAND, BLUR_COMMAND, KEY_MODIFIER_COMMAND, CAN_USE_DOM, documentMode, IS_APPLE, IS_FIREFOX, CAN_USE_BEFORE_INPUT, IS_SAFARI, IS_IOS, IS_ANDROID, IS_CHROME, IS_ANDROID_CHROME, IS_APPLE_WEBKIT, DOM_ELEMENT_TYPE, DOM_TEXT_TYPE, NO_DIRTY_NODES, HAS_DIRTY_NODES, FULL_RECONCILE, IS_NORMAL, IS_TOKEN, IS_SEGMENTED, IS_BOLD, IS_ITALIC, IS_STRIKETHROUGH, IS_UNDERLINE, IS_CODE, IS_SUBSCRIPT, IS_SUPERSCRIPT, IS_HIGHLIGHT, IS_ALL_FORMATTING, IS_DIRECTIONLESS, IS_UNMERGEABLE, IS_ALIGN_LEFT, IS_ALIGN_CENTER, IS_ALIGN_RIGHT, IS_ALIGN_JUSTIFY, IS_ALIGN_START, IS_ALIGN_END, NON_BREAKING_SPACE, ZERO_WIDTH_SPACE, COMPOSITION_SUFFIX, DOUBLE_LINE_BREAK, COMPOSITION_START_CHAR, RTL, LTR, RTL_REGEX, LTR_REGEX, TEXT_TYPE_TO_FORMAT, DETAIL_TYPE_TO_DETAIL, ELEMENT_TYPE_TO_FORMAT, ELEMENT_FORMAT_TO_TYPE, TEXT_MODE_TO_TYPE, TEXT_TYPE_TO_MODE, TEXT_MUTATION_VARIANCE, isProcessingMutations, lastTextEntryTimeStamp, keyCounter, scheduleMicroTask, subTreeTextContent, subTreeDirectionedTextContent, subTreeTextFormat, editorTextContent, activeEditorConfig, activeEditor$1, activeEditorNodes, treatAllNodesAsDirty, activeEditorStateReadOnly, activeMutationListeners, activeTextDirection, activeDirtyElements, activeDirtyLeaves, activePrevNodeMap, activeNextNodeMap, activePrevKeyToDOMMap, mutatedNodes, DEFAULT_INDENT_VALUE, PASS_THROUGH_COMMAND, ANDROID_COMPOSITION_LATENCY, rootElementEvents, lastKeyDownTimeStamp, lastKeyCode, lastBeforeInputInsertTextTimeStamp, unprocessedBeforeInputData, rootElementsRegistered, isSelectionChangeFromDOMUpdate, isSelectionChangeFromMouseDown, isInsertLineBreak, isFirefoxEndingComposition, collapsedSelectionFormat, activeNestedEditorsMap, LexicalNode, LineBreakNode, TextNode, preParentCache, nodeNameToTextFormat, TabNode, Point, NodeSelection, RangeSelection, activeEditorState, activeEditor, isReadOnlyMode, isAttemptingToRecoverFromReconcilerError, infiniteTransformCount, observerOptions, ElementNode, DecoratorNode, RootNode, EditorState, ArtificialNode__DO_NOT_USE, ParagraphNode, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_CRITICAL, LexicalEditor;
var init_Lexical_dev = __esm({
  "../../../node_modules/.pnpm/lexical@0.16.1/node_modules/lexical/Lexical.dev.mjs"() {
    SELECTION_CHANGE_COMMAND = createCommand("SELECTION_CHANGE_COMMAND");
    SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND");
    CLICK_COMMAND = createCommand("CLICK_COMMAND");
    DELETE_CHARACTER_COMMAND = createCommand("DELETE_CHARACTER_COMMAND");
    INSERT_LINE_BREAK_COMMAND = createCommand("INSERT_LINE_BREAK_COMMAND");
    INSERT_PARAGRAPH_COMMAND = createCommand("INSERT_PARAGRAPH_COMMAND");
    CONTROLLED_TEXT_INSERTION_COMMAND = createCommand("CONTROLLED_TEXT_INSERTION_COMMAND");
    PASTE_COMMAND = createCommand("PASTE_COMMAND");
    REMOVE_TEXT_COMMAND = createCommand("REMOVE_TEXT_COMMAND");
    DELETE_WORD_COMMAND = createCommand("DELETE_WORD_COMMAND");
    DELETE_LINE_COMMAND = createCommand("DELETE_LINE_COMMAND");
    FORMAT_TEXT_COMMAND = createCommand("FORMAT_TEXT_COMMAND");
    UNDO_COMMAND = createCommand("UNDO_COMMAND");
    REDO_COMMAND = createCommand("REDO_COMMAND");
    KEY_DOWN_COMMAND = createCommand("KEYDOWN_COMMAND");
    KEY_ARROW_RIGHT_COMMAND = createCommand("KEY_ARROW_RIGHT_COMMAND");
    MOVE_TO_END = createCommand("MOVE_TO_END");
    KEY_ARROW_LEFT_COMMAND = createCommand("KEY_ARROW_LEFT_COMMAND");
    MOVE_TO_START = createCommand("MOVE_TO_START");
    KEY_ARROW_UP_COMMAND = createCommand("KEY_ARROW_UP_COMMAND");
    KEY_ARROW_DOWN_COMMAND = createCommand("KEY_ARROW_DOWN_COMMAND");
    KEY_ENTER_COMMAND = createCommand("KEY_ENTER_COMMAND");
    KEY_SPACE_COMMAND = createCommand("KEY_SPACE_COMMAND");
    KEY_BACKSPACE_COMMAND = createCommand("KEY_BACKSPACE_COMMAND");
    KEY_ESCAPE_COMMAND = createCommand("KEY_ESCAPE_COMMAND");
    KEY_DELETE_COMMAND = createCommand("KEY_DELETE_COMMAND");
    KEY_TAB_COMMAND = createCommand("KEY_TAB_COMMAND");
    INSERT_TAB_COMMAND = createCommand("INSERT_TAB_COMMAND");
    INDENT_CONTENT_COMMAND = createCommand("INDENT_CONTENT_COMMAND");
    OUTDENT_CONTENT_COMMAND = createCommand("OUTDENT_CONTENT_COMMAND");
    DROP_COMMAND = createCommand("DROP_COMMAND");
    FORMAT_ELEMENT_COMMAND = createCommand("FORMAT_ELEMENT_COMMAND");
    DRAGSTART_COMMAND = createCommand("DRAGSTART_COMMAND");
    DRAGOVER_COMMAND = createCommand("DRAGOVER_COMMAND");
    DRAGEND_COMMAND = createCommand("DRAGEND_COMMAND");
    COPY_COMMAND = createCommand("COPY_COMMAND");
    CUT_COMMAND = createCommand("CUT_COMMAND");
    SELECT_ALL_COMMAND = createCommand("SELECT_ALL_COMMAND");
    CLEAR_EDITOR_COMMAND = createCommand("CLEAR_EDITOR_COMMAND");
    CLEAR_HISTORY_COMMAND = createCommand("CLEAR_HISTORY_COMMAND");
    CAN_REDO_COMMAND = createCommand("CAN_REDO_COMMAND");
    CAN_UNDO_COMMAND = createCommand("CAN_UNDO_COMMAND");
    FOCUS_COMMAND = createCommand("FOCUS_COMMAND");
    BLUR_COMMAND = createCommand("BLUR_COMMAND");
    KEY_MODIFIER_COMMAND = createCommand("KEY_MODIFIER_COMMAND");
    CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
    IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
    IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);
    IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;
    IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
    DOM_ELEMENT_TYPE = 1;
    DOM_TEXT_TYPE = 3;
    NO_DIRTY_NODES = 0;
    HAS_DIRTY_NODES = 1;
    FULL_RECONCILE = 2;
    IS_NORMAL = 0;
    IS_TOKEN = 1;
    IS_SEGMENTED = 2;
    IS_BOLD = 1;
    IS_ITALIC = 1 << 1;
    IS_STRIKETHROUGH = 1 << 2;
    IS_UNDERLINE = 1 << 3;
    IS_CODE = 1 << 4;
    IS_SUBSCRIPT = 1 << 5;
    IS_SUPERSCRIPT = 1 << 6;
    IS_HIGHLIGHT = 1 << 7;
    IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;
    IS_DIRECTIONLESS = 1;
    IS_UNMERGEABLE = 1 << 1;
    IS_ALIGN_LEFT = 1;
    IS_ALIGN_CENTER = 2;
    IS_ALIGN_RIGHT = 3;
    IS_ALIGN_JUSTIFY = 4;
    IS_ALIGN_START = 5;
    IS_ALIGN_END = 6;
    NON_BREAKING_SPACE = "\xA0";
    ZERO_WIDTH_SPACE = "\u200B";
    COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
    DOUBLE_LINE_BREAK = "\n\n";
    COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
    RTL = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
    LTR = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
    RTL_REGEX = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    LTR_REGEX = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    TEXT_TYPE_TO_FORMAT = {
      bold: IS_BOLD,
      code: IS_CODE,
      highlight: IS_HIGHLIGHT,
      italic: IS_ITALIC,
      strikethrough: IS_STRIKETHROUGH,
      subscript: IS_SUBSCRIPT,
      superscript: IS_SUPERSCRIPT,
      underline: IS_UNDERLINE
    };
    DETAIL_TYPE_TO_DETAIL = {
      directionless: IS_DIRECTIONLESS,
      unmergeable: IS_UNMERGEABLE
    };
    ELEMENT_TYPE_TO_FORMAT = {
      center: IS_ALIGN_CENTER,
      end: IS_ALIGN_END,
      justify: IS_ALIGN_JUSTIFY,
      left: IS_ALIGN_LEFT,
      right: IS_ALIGN_RIGHT,
      start: IS_ALIGN_START
    };
    ELEMENT_FORMAT_TO_TYPE = {
      [IS_ALIGN_CENTER]: "center",
      [IS_ALIGN_END]: "end",
      [IS_ALIGN_JUSTIFY]: "justify",
      [IS_ALIGN_LEFT]: "left",
      [IS_ALIGN_RIGHT]: "right",
      [IS_ALIGN_START]: "start"
    };
    TEXT_MODE_TO_TYPE = {
      normal: IS_NORMAL,
      segmented: IS_SEGMENTED,
      token: IS_TOKEN
    };
    TEXT_TYPE_TO_MODE = {
      [IS_NORMAL]: "normal",
      [IS_SEGMENTED]: "segmented",
      [IS_TOKEN]: "token"
    };
    TEXT_MUTATION_VARIANCE = 100;
    isProcessingMutations = false;
    lastTextEntryTimeStamp = 0;
    keyCounter = 1;
    scheduleMicroTask = typeof queueMicrotask === "function" ? queueMicrotask : (fn2) => {
      Promise.resolve().then(fn2);
    };
    subTreeTextContent = "";
    subTreeDirectionedTextContent = "";
    subTreeTextFormat = null;
    editorTextContent = "";
    treatAllNodesAsDirty = false;
    activeEditorStateReadOnly = false;
    activeTextDirection = null;
    DEFAULT_INDENT_VALUE = "40px";
    PASS_THROUGH_COMMAND = Object.freeze({});
    ANDROID_COMPOSITION_LATENCY = 30;
    rootElementEvents = [["keydown", onKeyDown], ["pointerdown", onPointerDown], ["compositionstart", onCompositionStart], ["compositionend", onCompositionEnd], ["input", onInput], ["click", onClick], ["cut", PASS_THROUGH_COMMAND], ["copy", PASS_THROUGH_COMMAND], ["dragstart", PASS_THROUGH_COMMAND], ["dragover", PASS_THROUGH_COMMAND], ["dragend", PASS_THROUGH_COMMAND], ["paste", PASS_THROUGH_COMMAND], ["focus", PASS_THROUGH_COMMAND], ["blur", PASS_THROUGH_COMMAND], ["drop", PASS_THROUGH_COMMAND]];
    if (CAN_USE_BEFORE_INPUT) {
      rootElementEvents.push(["beforeinput", (event, editor) => onBeforeInput(event, editor)]);
    }
    lastKeyDownTimeStamp = 0;
    lastKeyCode = null;
    lastBeforeInputInsertTextTimeStamp = 0;
    unprocessedBeforeInputData = null;
    rootElementsRegistered = /* @__PURE__ */ new WeakMap();
    isSelectionChangeFromDOMUpdate = false;
    isSelectionChangeFromMouseDown = false;
    isInsertLineBreak = false;
    isFirefoxEndingComposition = false;
    collapsedSelectionFormat = [0, "", 0, "root", 0];
    activeNestedEditorsMap = /* @__PURE__ */ new Map();
    LexicalNode = class {
      // Allow us to look up the type including static props
      /** @internal */
      /** @internal */
      //@ts-ignore We set the key in the constructor.
      /** @internal */
      /** @internal */
      /** @internal */
      // Flow doesn't support abstract classes unfortunately, so we can't _force_
      // subclasses of Node to implement statics. All subclasses of Node should have
      // a static getType and clone method though. We define getType and clone here so we can call it
      // on any  Node, and we throw this error by default since the subclass should provide
      // their own implementation.
      /**
       * Returns the string type of this node. Every node must
       * implement this and it MUST BE UNIQUE amongst nodes registered
       * on the editor.
       *
       */
      static getType() {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
        }
      }
      /**
       * Clones this node, creating a new node with a different key
       * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
       * implement this method.
       *
       */
      static clone(_data) {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(key) {
        this.__type = this.constructor.getType();
        this.__parent = null;
        this.__prev = null;
        this.__next = null;
        $setNodeKey(this, key);
        {
          if (this.__type !== "root") {
            errorOnReadOnly();
            errorOnTypeKlassMismatch(this.__type, this.constructor);
          }
        }
      }
      // Getters and Traversers
      /**
       * Returns the string type of this node.
       */
      getType() {
        return this.__type;
      }
      isInline() {
        {
          throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);
        }
      }
      /**
       * Returns true if there is a path between this node and the RootNode, false otherwise.
       * This is a way of determining if the node is "attached" EditorState. Unattached nodes
       * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.
       */
      isAttached() {
        let nodeKey = this.__key;
        while (nodeKey !== null) {
          if (nodeKey === "root") {
            return true;
          }
          const node = $getNodeByKey(nodeKey);
          if (node === null) {
            break;
          }
          nodeKey = node.__parent;
        }
        return false;
      }
      /**
       * Returns true if this node is contained within the provided Selection., false otherwise.
       * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
       * what's included.
       *
       * @param selection - The selection that we want to determine if the node is in.
       */
      isSelected(selection) {
        const targetSelection = selection || $getSelection();
        if (targetSelection == null) {
          return false;
        }
        const isSelected = targetSelection.getNodes().some((n6) => n6.__key === this.__key);
        if ($isTextNode(this)) {
          return isSelected;
        }
        if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === "element" && targetSelection.focus.type === "element" && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {
          return false;
        }
        return isSelected;
      }
      /**
       * Returns this nodes key.
       */
      getKey() {
        return this.__key;
      }
      /**
       * Returns the zero-based index of this node within the parent.
       */
      getIndexWithinParent() {
        const parent = this.getParent();
        if (parent === null) {
          return -1;
        }
        let node = parent.getFirstChild();
        let index = 0;
        while (node !== null) {
          if (this.is(node)) {
            return index;
          }
          index++;
          node = node.getNextSibling();
        }
        return -1;
      }
      /**
       * Returns the parent of this node, or null if none is found.
       */
      getParent() {
        const parent = this.getLatest().__parent;
        if (parent === null) {
          return null;
        }
        return $getNodeByKey(parent);
      }
      /**
       * Returns the parent of this node, or throws if none is found.
       */
      getParentOrThrow() {
        const parent = this.getParent();
        if (parent === null) {
          {
            throw Error(`Expected node ${this.__key} to have a parent.`);
          }
        }
        return parent;
      }
      /**
       * Returns the highest (in the EditorState tree)
       * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
       * for more information on which Elements comprise "roots".
       */
      getTopLevelElement() {
        let node = this;
        while (node !== null) {
          const parent = node.getParent();
          if ($isRootOrShadowRoot(parent)) {
            if (!$isElementNode(node)) {
              throw Error(`Children of root nodes must be elements`);
            }
            return node;
          }
          node = parent;
        }
        return null;
      }
      /**
       * Returns the highest (in the EditorState tree)
       * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
       * for more information on which Elements comprise "roots".
       */
      getTopLevelElementOrThrow() {
        const parent = this.getTopLevelElement();
        if (parent === null) {
          {
            throw Error(`Expected node ${this.__key} to have a top parent element.`);
          }
        }
        return parent;
      }
      /**
       * Returns a list of the every ancestor of this node,
       * all the way up to the RootNode.
       *
       */
      getParents() {
        const parents = [];
        let node = this.getParent();
        while (node !== null) {
          parents.push(node);
          node = node.getParent();
        }
        return parents;
      }
      /**
       * Returns a list of the keys of every ancestor of this node,
       * all the way up to the RootNode.
       *
       */
      getParentKeys() {
        const parents = [];
        let node = this.getParent();
        while (node !== null) {
          parents.push(node.__key);
          node = node.getParent();
        }
        return parents;
      }
      /**
       * Returns the "previous" siblings - that is, the node that comes
       * before this one in the same parent.
       *
       */
      getPreviousSibling() {
        const self2 = this.getLatest();
        const prevKey = self2.__prev;
        return prevKey === null ? null : $getNodeByKey(prevKey);
      }
      /**
       * Returns the "previous" siblings - that is, the nodes that come between
       * this one and the first child of it's parent, inclusive.
       *
       */
      getPreviousSiblings() {
        const siblings = [];
        const parent = this.getParent();
        if (parent === null) {
          return siblings;
        }
        let node = parent.getFirstChild();
        while (node !== null) {
          if (node.is(this)) {
            break;
          }
          siblings.push(node);
          node = node.getNextSibling();
        }
        return siblings;
      }
      /**
       * Returns the "next" siblings - that is, the node that comes
       * after this one in the same parent
       *
       */
      getNextSibling() {
        const self2 = this.getLatest();
        const nextKey = self2.__next;
        return nextKey === null ? null : $getNodeByKey(nextKey);
      }
      /**
       * Returns all "next" siblings - that is, the nodes that come between this
       * one and the last child of it's parent, inclusive.
       *
       */
      getNextSiblings() {
        const siblings = [];
        let node = this.getNextSibling();
        while (node !== null) {
          siblings.push(node);
          node = node.getNextSibling();
        }
        return siblings;
      }
      /**
       * Returns the closest common ancestor of this node and the provided one or null
       * if one cannot be found.
       *
       * @param node - the other node to find the common ancestor of.
       */
      getCommonAncestor(node) {
        const a3 = this.getParents();
        const b5 = node.getParents();
        if ($isElementNode(this)) {
          a3.unshift(this);
        }
        if ($isElementNode(node)) {
          b5.unshift(node);
        }
        const aLength = a3.length;
        const bLength = b5.length;
        if (aLength === 0 || bLength === 0 || a3[aLength - 1] !== b5[bLength - 1]) {
          return null;
        }
        const bSet = new Set(b5);
        for (let i4 = 0; i4 < aLength; i4++) {
          const ancestor = a3[i4];
          if (bSet.has(ancestor)) {
            return ancestor;
          }
        }
        return null;
      }
      /**
       * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
       * Always use this instead of referential equality.
       *
       * @param object - the node to perform the equality comparison on.
       */
      is(object) {
        if (object == null) {
          return false;
        }
        return this.__key === object.__key;
      }
      /**
       * Returns true if this node logical precedes the target node in the editor state.
       *
       * @param targetNode - the node we're testing to see if it's after this one.
       */
      isBefore(targetNode) {
        if (this === targetNode) {
          return false;
        }
        if (targetNode.isParentOf(this)) {
          return true;
        }
        if (this.isParentOf(targetNode)) {
          return false;
        }
        const commonAncestor = this.getCommonAncestor(targetNode);
        let indexA = 0;
        let indexB = 0;
        let node = this;
        while (true) {
          const parent = node.getParentOrThrow();
          if (parent === commonAncestor) {
            indexA = node.getIndexWithinParent();
            break;
          }
          node = parent;
        }
        node = targetNode;
        while (true) {
          const parent = node.getParentOrThrow();
          if (parent === commonAncestor) {
            indexB = node.getIndexWithinParent();
            break;
          }
          node = parent;
        }
        return indexA < indexB;
      }
      /**
       * Returns true if this node is the parent of the target node, false otherwise.
       *
       * @param targetNode - the would-be child node.
       */
      isParentOf(targetNode) {
        const key = this.__key;
        if (key === targetNode.__key) {
          return false;
        }
        let node = targetNode;
        while (node !== null) {
          if (node.__key === key) {
            return true;
          }
          node = node.getParent();
        }
        return false;
      }
      // TO-DO: this function can be simplified a lot
      /**
       * Returns a list of nodes that are between this node and
       * the target node in the EditorState.
       *
       * @param targetNode - the node that marks the other end of the range of nodes to be returned.
       */
      getNodesBetween(targetNode) {
        const isBefore = this.isBefore(targetNode);
        const nodes = [];
        const visited = /* @__PURE__ */ new Set();
        let node = this;
        while (true) {
          if (node === null) {
            break;
          }
          const key = node.__key;
          if (!visited.has(key)) {
            visited.add(key);
            nodes.push(node);
          }
          if (node === targetNode) {
            break;
          }
          const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;
          if (child !== null) {
            node = child;
            continue;
          }
          const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();
          if (nextSibling !== null) {
            node = nextSibling;
            continue;
          }
          const parent = node.getParentOrThrow();
          if (!visited.has(parent.__key)) {
            nodes.push(parent);
          }
          if (parent === targetNode) {
            break;
          }
          let parentSibling = null;
          let ancestor = parent;
          do {
            if (ancestor === null) {
              {
                throw Error(`getNodesBetween: ancestor is null`);
              }
            }
            parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
            ancestor = ancestor.getParent();
            if (ancestor !== null) {
              if (parentSibling === null && !visited.has(ancestor.__key)) {
                nodes.push(ancestor);
              }
            } else {
              break;
            }
          } while (parentSibling === null);
          node = parentSibling;
        }
        if (!isBefore) {
          nodes.reverse();
        }
        return nodes;
      }
      /**
       * Returns true if this node has been marked dirty during this update cycle.
       *
       */
      isDirty() {
        const editor = getActiveEditor();
        const dirtyLeaves = editor._dirtyLeaves;
        return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
      }
      /**
       * Returns the latest version of the node from the active EditorState.
       * This is used to avoid getting values from stale node references.
       *
       */
      getLatest() {
        const latest = $getNodeByKey(this.__key);
        if (latest === null) {
          {
            throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
          }
        }
        return latest;
      }
      /**
       * Returns a mutable version of the node. Will throw an error if
       * called outside of a Lexical Editor {@link LexicalEditor.update} callback.
       *
       */
      getWritable() {
        errorOnReadOnly();
        const editorState = getActiveEditorState();
        const editor = getActiveEditor();
        const nodeMap = editorState._nodeMap;
        const key = this.__key;
        const latestNode = this.getLatest();
        const parent = latestNode.__parent;
        const cloneNotNeeded = editor._cloneNotNeeded;
        const selection = $getSelection();
        if (selection !== null) {
          selection.setCachedNodes(null);
        }
        if (cloneNotNeeded.has(key)) {
          internalMarkNodeAsDirty(latestNode);
          return latestNode;
        }
        const constructor = latestNode.constructor;
        const mutableNode = constructor.clone(latestNode);
        mutableNode.__parent = parent;
        mutableNode.__next = latestNode.__next;
        mutableNode.__prev = latestNode.__prev;
        if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {
          if ($isParagraphNode(latestNode) && $isParagraphNode(mutableNode)) {
            mutableNode.__textFormat = latestNode.__textFormat;
          }
          mutableNode.__first = latestNode.__first;
          mutableNode.__last = latestNode.__last;
          mutableNode.__size = latestNode.__size;
          mutableNode.__indent = latestNode.__indent;
          mutableNode.__format = latestNode.__format;
          mutableNode.__dir = latestNode.__dir;
        } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {
          mutableNode.__format = latestNode.__format;
          mutableNode.__style = latestNode.__style;
          mutableNode.__mode = latestNode.__mode;
          mutableNode.__detail = latestNode.__detail;
        }
        cloneNotNeeded.add(key);
        mutableNode.__key = key;
        internalMarkNodeAsDirty(mutableNode);
        nodeMap.set(key, mutableNode);
        return mutableNode;
      }
      /**
       * Returns the text content of the node. Override this for
       * custom nodes that should have a representation in plain text
       * format (for copy + paste, for example)
       *
       */
      getTextContent() {
        return "";
      }
      /**
       * Returns the length of the string produced by calling getTextContent on this node.
       *
       */
      getTextContentSize() {
        return this.getTextContent().length;
      }
      // View
      /**
       * Called during the reconciliation process to determine which nodes
       * to insert into the DOM for this Lexical Node.
       *
       * This method must return exactly one HTMLElement. Nested elements are not supported.
       *
       * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.
       *
       * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
       * @param _editor - allows access to the editor for context during reconciliation.
       *
       * */
      createDOM(_config, _editor) {
        {
          throw Error(`createDOM: base method not extended`);
        }
      }
      /**
       * Called when a node changes and should update the DOM
       * in whatever way is necessary to make it align with any changes that might
       * have happened during the update.
       *
       * Returning "true" here will cause lexical to unmount and recreate the DOM node
       * (by calling createDOM). You would need to do this if the element tag changes,
       * for instance.
       *
       * */
      updateDOM(_prevNode, _dom, _config) {
        {
          throw Error(`updateDOM: base method not extended`);
        }
      }
      /**
       * Controls how the this node is serialized to HTML. This is important for
       * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
       * in which case the primary transfer format is HTML. It's also important if you're serializing
       * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
       * also use this method to build your own HTML renderer.
       *
       * */
      exportDOM(editor) {
        const element = this.createDOM(editor._config, editor);
        return {
          element
        };
      }
      /**
       * Controls how the this node is serialized to JSON. This is important for
       * copy and paste between Lexical editors sharing the same namespace. It's also important
       * if you're serializing to JSON for persistent storage somewhere.
       * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
       *
       * */
      exportJSON() {
        {
          throw Error(`exportJSON: base method not extended`);
        }
      }
      /**
       * Controls how the this node is deserialized from JSON. This is usually boilerplate,
       * but provides an abstraction between the node implementation and serialized interface that can
       * be important if you ever make breaking changes to a node schema (by adding or removing properties).
       * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
       *
       * */
      static importJSON(_serializedNode) {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
        }
      }
      /**
       * @experimental
       *
       * Registers the returned function as a transform on the node during
       * Editor initialization. Most such use cases should be addressed via
       * the {@link LexicalEditor.registerNodeTransform} API.
       *
       * Experimental - use at your own risk.
       */
      static transform() {
        return null;
      }
      // Setters and mutators
      /**
       * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
       * somewhere, the Lexical garbage collector will eventually clean it up.
       *
       * @param preserveEmptyParent - If falsy, the node's parent will be removed if
       * it's empty after the removal operation. This is the default behavior, subject to
       * other node heuristics such as {@link ElementNode#canBeEmpty}
       * */
      remove(preserveEmptyParent) {
        $removeNode(this, true, preserveEmptyParent);
      }
      /**
       * Replaces this LexicalNode with the provided node, optionally transferring the children
       * of the replaced node to the replacing node.
       *
       * @param replaceWith - The node to replace this one with.
       * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
       * */
      replace(replaceWith, includeChildren) {
        errorOnReadOnly();
        let selection = $getSelection();
        if (selection !== null) {
          selection = selection.clone();
        }
        errorOnInsertTextNodeOnRoot(this, replaceWith);
        const self2 = this.getLatest();
        const toReplaceKey = this.__key;
        const key = replaceWith.__key;
        const writableReplaceWith = replaceWith.getWritable();
        const writableParent = this.getParentOrThrow().getWritable();
        const size3 = writableParent.__size;
        removeFromParent(writableReplaceWith);
        const prevSibling = self2.getPreviousSibling();
        const nextSibling = self2.getNextSibling();
        const prevKey = self2.__prev;
        const nextKey = self2.__next;
        const parentKey = self2.__parent;
        $removeNode(self2, false, true);
        if (prevSibling === null) {
          writableParent.__first = key;
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          writablePrevSibling.__next = key;
        }
        writableReplaceWith.__prev = prevKey;
        if (nextSibling === null) {
          writableParent.__last = key;
        } else {
          const writableNextSibling = nextSibling.getWritable();
          writableNextSibling.__prev = key;
        }
        writableReplaceWith.__next = nextKey;
        writableReplaceWith.__parent = parentKey;
        writableParent.__size = size3;
        if (includeChildren) {
          if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {
            throw Error(`includeChildren should only be true for ElementNodes`);
          }
          this.getChildren().forEach((child) => {
            writableReplaceWith.append(child);
          });
        }
        if ($isRangeSelection(selection)) {
          $setSelection(selection);
          const anchor = selection.anchor;
          const focus = selection.focus;
          if (anchor.key === toReplaceKey) {
            $moveSelectionPointToEnd(anchor, writableReplaceWith);
          }
          if (focus.key === toReplaceKey) {
            $moveSelectionPointToEnd(focus, writableReplaceWith);
          }
        }
        if ($getCompositionKey() === toReplaceKey) {
          $setCompositionKey(key);
        }
        return writableReplaceWith;
      }
      /**
       * Inserts a node after this LexicalNode (as the next sibling).
       *
       * @param nodeToInsert - The node to insert after this one.
       * @param restoreSelection - Whether or not to attempt to resolve the
       * selection to the appropriate place after the operation is complete.
       * */
      insertAfter(nodeToInsert, restoreSelection = true) {
        errorOnReadOnly();
        errorOnInsertTextNodeOnRoot(this, nodeToInsert);
        const writableSelf = this.getWritable();
        const writableNodeToInsert = nodeToInsert.getWritable();
        const oldParent = writableNodeToInsert.getParent();
        const selection = $getSelection();
        let elementAnchorSelectionOnNode = false;
        let elementFocusSelectionOnNode = false;
        if (oldParent !== null) {
          const oldIndex = nodeToInsert.getIndexWithinParent();
          removeFromParent(writableNodeToInsert);
          if ($isRangeSelection(selection)) {
            const oldParentKey = oldParent.__key;
            const anchor = selection.anchor;
            const focus = selection.focus;
            elementAnchorSelectionOnNode = anchor.type === "element" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
            elementFocusSelectionOnNode = focus.type === "element" && focus.key === oldParentKey && focus.offset === oldIndex + 1;
          }
        }
        const nextSibling = this.getNextSibling();
        const writableParent = this.getParentOrThrow().getWritable();
        const insertKey = writableNodeToInsert.__key;
        const nextKey = writableSelf.__next;
        if (nextSibling === null) {
          writableParent.__last = insertKey;
        } else {
          const writableNextSibling = nextSibling.getWritable();
          writableNextSibling.__prev = insertKey;
        }
        writableParent.__size++;
        writableSelf.__next = insertKey;
        writableNodeToInsert.__next = nextKey;
        writableNodeToInsert.__prev = writableSelf.__key;
        writableNodeToInsert.__parent = writableSelf.__parent;
        if (restoreSelection && $isRangeSelection(selection)) {
          const index = this.getIndexWithinParent();
          $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);
          const writableParentKey = writableParent.__key;
          if (elementAnchorSelectionOnNode) {
            selection.anchor.set(writableParentKey, index + 2, "element");
          }
          if (elementFocusSelectionOnNode) {
            selection.focus.set(writableParentKey, index + 2, "element");
          }
        }
        return nodeToInsert;
      }
      /**
       * Inserts a node before this LexicalNode (as the previous sibling).
       *
       * @param nodeToInsert - The node to insert before this one.
       * @param restoreSelection - Whether or not to attempt to resolve the
       * selection to the appropriate place after the operation is complete.
       * */
      insertBefore(nodeToInsert, restoreSelection = true) {
        errorOnReadOnly();
        errorOnInsertTextNodeOnRoot(this, nodeToInsert);
        const writableSelf = this.getWritable();
        const writableNodeToInsert = nodeToInsert.getWritable();
        const insertKey = writableNodeToInsert.__key;
        removeFromParent(writableNodeToInsert);
        const prevSibling = this.getPreviousSibling();
        const writableParent = this.getParentOrThrow().getWritable();
        const prevKey = writableSelf.__prev;
        const index = this.getIndexWithinParent();
        if (prevSibling === null) {
          writableParent.__first = insertKey;
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          writablePrevSibling.__next = insertKey;
        }
        writableParent.__size++;
        writableSelf.__prev = insertKey;
        writableNodeToInsert.__prev = prevKey;
        writableNodeToInsert.__next = writableSelf.__key;
        writableNodeToInsert.__parent = writableSelf.__parent;
        const selection = $getSelection();
        if (restoreSelection && $isRangeSelection(selection)) {
          const parent = this.getParentOrThrow();
          $updateElementSelectionOnCreateDeleteNode(selection, parent, index);
        }
        return nodeToInsert;
      }
      /**
       * Whether or not this node has a required parent. Used during copy + paste operations
       * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
       * a ListNode parent or TextNodes with a ParagraphNode parent.
       *
       * */
      isParentRequired() {
        return false;
      }
      /**
       * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
       *
       * */
      createParentElementNode() {
        return $createParagraphNode();
      }
      selectStart() {
        return this.selectPrevious();
      }
      selectEnd() {
        return this.selectNext(0, 0);
      }
      /**
       * Moves selection to the previous sibling of this node, at the specified offsets.
       *
       * @param anchorOffset - The anchor offset for selection.
       * @param focusOffset -  The focus offset for selection
       * */
      selectPrevious(anchorOffset, focusOffset) {
        errorOnReadOnly();
        const prevSibling = this.getPreviousSibling();
        const parent = this.getParentOrThrow();
        if (prevSibling === null) {
          return parent.select(0, 0);
        }
        if ($isElementNode(prevSibling)) {
          return prevSibling.select();
        } else if (!$isTextNode(prevSibling)) {
          const index = prevSibling.getIndexWithinParent() + 1;
          return parent.select(index, index);
        }
        return prevSibling.select(anchorOffset, focusOffset);
      }
      /**
       * Moves selection to the next sibling of this node, at the specified offsets.
       *
       * @param anchorOffset - The anchor offset for selection.
       * @param focusOffset -  The focus offset for selection
       * */
      selectNext(anchorOffset, focusOffset) {
        errorOnReadOnly();
        const nextSibling = this.getNextSibling();
        const parent = this.getParentOrThrow();
        if (nextSibling === null) {
          return parent.select();
        }
        if ($isElementNode(nextSibling)) {
          return nextSibling.select(0, 0);
        } else if (!$isTextNode(nextSibling)) {
          const index = nextSibling.getIndexWithinParent();
          return parent.select(index, index);
        }
        return nextSibling.select(anchorOffset, focusOffset);
      }
      /**
       * Marks a node dirty, triggering transforms and
       * forcing it to be reconciled during the update cycle.
       *
       * */
      markDirty() {
        this.getWritable();
      }
    };
    LineBreakNode = class _LineBreakNode extends LexicalNode {
      static getType() {
        return "linebreak";
      }
      static clone(node) {
        return new _LineBreakNode(node.__key);
      }
      constructor(key) {
        super(key);
      }
      getTextContent() {
        return "\n";
      }
      createDOM() {
        return document.createElement("br");
      }
      updateDOM() {
        return false;
      }
      static importDOM() {
        return {
          br: (node) => {
            if (isOnlyChild(node)) {
              return null;
            }
            return {
              conversion: $convertLineBreakElement,
              priority: 0
            };
          }
        };
      }
      static importJSON(serializedLineBreakNode) {
        return $createLineBreakNode();
      }
      exportJSON() {
        return {
          type: "linebreak",
          version: 1
        };
      }
    };
    TextNode = class _TextNode extends LexicalNode {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "text";
      }
      static clone(node) {
        return new _TextNode(node.__text, node.__key);
      }
      constructor(text, key) {
        super(key);
        this.__text = text;
        this.__format = 0;
        this.__style = "";
        this.__mode = 0;
        this.__detail = 0;
      }
      /**
       * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
       * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
       *
       * @returns a number representing the format of the text node.
       */
      getFormat() {
        const self2 = this.getLatest();
        return self2.__format;
      }
      /**
       * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
       * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
       * or TextNode.isUnmergeable instead.
       *
       * @returns a number representing the detail of the text node.
       */
      getDetail() {
        const self2 = this.getLatest();
        return self2.__detail;
      }
      /**
       * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
       *
       * @returns TextModeType.
       */
      getMode() {
        const self2 = this.getLatest();
        return TEXT_TYPE_TO_MODE[self2.__mode];
      }
      /**
       * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
       *
       * @returns CSSText-like string of styles applied to the underlying DOM node.
       */
      getStyle() {
        const self2 = this.getLatest();
        return self2.__style;
      }
      /**
       * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
       * with a RangeSelection, but are deleted as a single entity (not invdividually by character).
       *
       * @returns true if the node is in token mode, false otherwise.
       */
      isToken() {
        const self2 = this.getLatest();
        return self2.__mode === IS_TOKEN;
      }
      /**
       *
       * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
       * mutate the TextNode, false otherwise.
       */
      isComposing() {
        return this.__key === $getCompositionKey();
      }
      /**
       * Returns whether or not the node is in "segemented" mode. TextNodes in segemented mode can be navigated through character-by-character
       * with a RangeSelection, but are deleted in space-delimited "segments".
       *
       * @returns true if the node is in segmented mode, false otherwise.
       */
      isSegmented() {
        const self2 = this.getLatest();
        return self2.__mode === IS_SEGMENTED;
      }
      /**
       * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
       *
       * @returns true if the node is directionless, false otherwise.
       */
      isDirectionless() {
        const self2 = this.getLatest();
        return (self2.__detail & IS_DIRECTIONLESS) !== 0;
      }
      /**
       * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
       * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
       *
       * @returns true if the node is unmergeable, false otherwise.
       */
      isUnmergeable() {
        const self2 = this.getLatest();
        return (self2.__detail & IS_UNMERGEABLE) !== 0;
      }
      /**
       * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
       * string values to get the format of a TextNode.
       *
       * @param type - the TextFormatType to check for.
       *
       * @returns true if the node has the provided format, false otherwise.
       */
      hasFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return (this.getFormat() & formatFlag) !== 0;
      }
      /**
       * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
       * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
       *
       * @returns true if the node is simple text, false otherwise.
       */
      isSimpleText() {
        return this.__type === "text" && this.__mode === 0;
      }
      /**
       * Returns the text content of the node as a string.
       *
       * @returns a string representing the text content of the node.
       */
      getTextContent() {
        const self2 = this.getLatest();
        return self2.__text;
      }
      /**
       * Returns the format flags applied to the node as a 32-bit integer.
       *
       * @returns a number representing the TextFormatTypes applied to the node.
       */
      getFormatFlags(type, alignWithFormat) {
        const self2 = this.getLatest();
        const format = self2.__format;
        return toggleTextFormatType(format, type, alignWithFormat);
      }
      /**
       *
       * @returns true if the text node supports font styling, false otherwise.
       */
      canHaveFormat() {
        return true;
      }
      // View
      createDOM(config2, editor) {
        const format = this.__format;
        const outerTag = getElementOuterTag(this, format);
        const innerTag = getElementInnerTag(this, format);
        const tag = outerTag === null ? innerTag : outerTag;
        const dom = document.createElement(tag);
        let innerDOM = dom;
        if (this.hasFormat("code")) {
          dom.setAttribute("spellcheck", "false");
        }
        if (outerTag !== null) {
          innerDOM = document.createElement(innerTag);
          dom.appendChild(innerDOM);
        }
        const text = this.__text;
        createTextInnerDOM(innerDOM, this, innerTag, format, text, config2);
        const style = this.__style;
        if (style !== "") {
          dom.style.cssText = style;
        }
        return dom;
      }
      updateDOM(prevNode, dom, config2) {
        const nextText = this.__text;
        const prevFormat = prevNode.__format;
        const nextFormat = this.__format;
        const prevOuterTag = getElementOuterTag(this, prevFormat);
        const nextOuterTag = getElementOuterTag(this, nextFormat);
        const prevInnerTag = getElementInnerTag(this, prevFormat);
        const nextInnerTag = getElementInnerTag(this, nextFormat);
        const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
        const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;
        if (prevTag !== nextTag) {
          return true;
        }
        if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
          const prevInnerDOM = dom.firstChild;
          if (prevInnerDOM == null) {
            {
              throw Error(`updateDOM: prevInnerDOM is null or undefined`);
            }
          }
          const nextInnerDOM = document.createElement(nextInnerTag);
          createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config2);
          dom.replaceChild(nextInnerDOM, prevInnerDOM);
          return false;
        }
        let innerDOM = dom;
        if (nextOuterTag !== null) {
          if (prevOuterTag !== null) {
            innerDOM = dom.firstChild;
            if (innerDOM == null) {
              {
                throw Error(`updateDOM: innerDOM is null or undefined`);
              }
            }
          }
        }
        setTextContent(nextText, innerDOM, this);
        const theme = config2.theme;
        const textClassNames = theme.text;
        if (textClassNames !== void 0 && prevFormat !== nextFormat) {
          setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
        }
        const prevStyle = prevNode.__style;
        const nextStyle = this.__style;
        if (prevStyle !== nextStyle) {
          dom.style.cssText = nextStyle;
        }
        return false;
      }
      static importDOM() {
        return {
          "#text": () => ({
            conversion: $convertTextDOMNode,
            priority: 0
          }),
          b: () => ({
            conversion: convertBringAttentionToElement,
            priority: 0
          }),
          code: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          em: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          i: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          s: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          span: () => ({
            conversion: convertSpanElement,
            priority: 0
          }),
          strong: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          sub: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          sup: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          u: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        const node = $createTextNode(serializedNode.text);
        node.setFormat(serializedNode.format);
        node.setDetail(serializedNode.detail);
        node.setMode(serializedNode.mode);
        node.setStyle(serializedNode.style);
        return node;
      }
      // This improves Lexical's basic text output in copy+paste plus
      // for headless mode where people might use Lexical to generate
      // HTML content and not have the ability to use CSS classes.
      exportDOM(editor) {
        let {
          element
        } = super.exportDOM(editor);
        if (!(element !== null && isHTMLElement2(element))) {
          throw Error(`Expected TextNode createDOM to always return a HTMLElement`);
        }
        element.style.whiteSpace = "pre-wrap";
        if (this.hasFormat("bold")) {
          element = wrapElementWith(element, "b");
        }
        if (this.hasFormat("italic")) {
          element = wrapElementWith(element, "i");
        }
        if (this.hasFormat("strikethrough")) {
          element = wrapElementWith(element, "s");
        }
        if (this.hasFormat("underline")) {
          element = wrapElementWith(element, "u");
        }
        return {
          element
        };
      }
      exportJSON() {
        return {
          detail: this.getDetail(),
          format: this.getFormat(),
          mode: this.getMode(),
          style: this.getStyle(),
          text: this.getTextContent(),
          type: "text",
          version: 1
        };
      }
      // Mutators
      selectionTransform(prevSelection, nextSelection) {
        return;
      }
      /**
       * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
       * version of the argument can only specify one format and doing so will remove all other formats that
       * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
       *
       * @param format - TextFormatType or 32-bit integer representing the node format.
       *
       * @returns this TextNode.
       * // TODO 0.12 This should just be a `string`.
       */
      setFormat(format) {
        const self2 = this.getWritable();
        self2.__format = typeof format === "string" ? TEXT_TYPE_TO_FORMAT[format] : format;
        return self2;
      }
      /**
       * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
       * version of the argument can only specify one detail value and doing so will remove all other detail values that
       * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
       * or {@link TextNode.toggleUnmergeable}
       *
       * @param detail - TextDetailType or 32-bit integer representing the node detail.
       *
       * @returns this TextNode.
       * // TODO 0.12 This should just be a `string`.
       */
      setDetail(detail) {
        const self2 = this.getWritable();
        self2.__detail = typeof detail === "string" ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
        return self2;
      }
      /**
       * Sets the node style to the provided CSSText-like string. Set this property as you
       * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
       *
       * @param style - CSSText to be applied to the underlying HTMLElement.
       *
       * @returns this TextNode.
       */
      setStyle(style) {
        const self2 = this.getWritable();
        self2.__style = style;
        return self2;
      }
      /**
       * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
       * The subscript and superscript formats are mutually exclusive.
       * Prefer using this method to turn specific formats on and off.
       *
       * @param type - TextFormatType to toggle.
       *
       * @returns this TextNode.
       */
      toggleFormat(type) {
        const format = this.getFormat();
        const newFormat = toggleTextFormatType(format, type, null);
        return this.setFormat(newFormat);
      }
      /**
       * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
       *
       * @returns this TextNode.
       */
      toggleDirectionless() {
        const self2 = this.getWritable();
        self2.__detail ^= IS_DIRECTIONLESS;
        return self2;
      }
      /**
       * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
       *
       * @returns this TextNode.
       */
      toggleUnmergeable() {
        const self2 = this.getWritable();
        self2.__detail ^= IS_UNMERGEABLE;
        return self2;
      }
      /**
       * Sets the mode of the node.
       *
       * @returns this TextNode.
       */
      setMode(type) {
        const mode = TEXT_MODE_TO_TYPE[type];
        if (this.__mode === mode) {
          return this;
        }
        const self2 = this.getWritable();
        self2.__mode = mode;
        return self2;
      }
      /**
       * Sets the text content of the node.
       *
       * @param text - the string to set as the text value of the node.
       *
       * @returns this TextNode.
       */
      setTextContent(text) {
        if (this.__text === text) {
          return this;
        }
        const self2 = this.getWritable();
        self2.__text = text;
        return self2;
      }
      /**
       * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
       *
       * @param _anchorOffset - the offset at which the Selection anchor will be placed.
       * @param _focusOffset - the offset at which the Selection focus will be placed.
       *
       * @returns the new RangeSelection.
       */
      select(_anchorOffset, _focusOffset) {
        errorOnReadOnly();
        let anchorOffset = _anchorOffset;
        let focusOffset = _focusOffset;
        const selection = $getSelection();
        const text = this.getTextContent();
        const key = this.__key;
        if (typeof text === "string") {
          const lastOffset = text.length;
          if (anchorOffset === void 0) {
            anchorOffset = lastOffset;
          }
          if (focusOffset === void 0) {
            focusOffset = lastOffset;
          }
        } else {
          anchorOffset = 0;
          focusOffset = 0;
        }
        if (!$isRangeSelection(selection)) {
          return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "text", "text");
        } else {
          const compositionKey = $getCompositionKey();
          if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {
            $setCompositionKey(key);
          }
          selection.setTextNodeRange(this, anchorOffset, this, focusOffset);
        }
        return selection;
      }
      selectStart() {
        return this.select(0, 0);
      }
      selectEnd() {
        const size3 = this.getTextContentSize();
        return this.select(size3, size3);
      }
      /**
       * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
       * specified. Can optionally calculate a new selection after the operation is complete.
       *
       * @param offset - the offset at which the splice operation should begin.
       * @param delCount - the number of characters to delete, starting from the offset.
       * @param newText - the text to insert into the TextNode at the offset.
       * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
       *
       * @returns this TextNode.
       */
      spliceText(offset3, delCount, newText, moveSelection) {
        const writableSelf = this.getWritable();
        const text = writableSelf.__text;
        const handledTextLength = newText.length;
        let index = offset3;
        if (index < 0) {
          index = handledTextLength + index;
          if (index < 0) {
            index = 0;
          }
        }
        const selection = $getSelection();
        if (moveSelection && $isRangeSelection(selection)) {
          const newOffset = offset3 + handledTextLength;
          selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
        }
        const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);
        writableSelf.__text = updatedText;
        return writableSelf;
      }
      /**
       * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
       * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
       * to insert text into this node. If false, it will insert the text in a new sibling node.
       *
       * @returns true if text can be inserted before the node, false otherwise.
       */
      canInsertTextBefore() {
        return true;
      }
      /**
       * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
       * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
       * to insert text into this node. If false, it will insert the text in a new sibling node.
       *
       * @returns true if text can be inserted after the node, false otherwise.
       */
      canInsertTextAfter() {
        return true;
      }
      /**
       * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
       * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
       *
       * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
       *
       * @returns an Array containing the newly-created TextNodes.
       */
      splitText(...splitOffsets) {
        errorOnReadOnly();
        const self2 = this.getLatest();
        const textContent = self2.getTextContent();
        const key = self2.__key;
        const compositionKey = $getCompositionKey();
        const offsetsSet = new Set(splitOffsets);
        const parts = [];
        const textLength = textContent.length;
        let string = "";
        for (let i4 = 0; i4 < textLength; i4++) {
          if (string !== "" && offsetsSet.has(i4)) {
            parts.push(string);
            string = "";
          }
          string += textContent[i4];
        }
        if (string !== "") {
          parts.push(string);
        }
        const partsLength = parts.length;
        if (partsLength === 0) {
          return [];
        } else if (parts[0] === textContent) {
          return [self2];
        }
        const firstPart = parts[0];
        const parent = self2.getParentOrThrow();
        let writableNode;
        const format = self2.getFormat();
        const style = self2.getStyle();
        const detail = self2.__detail;
        let hasReplacedSelf = false;
        if (self2.isSegmented()) {
          writableNode = $createTextNode(firstPart);
          writableNode.__format = format;
          writableNode.__style = style;
          writableNode.__detail = detail;
          hasReplacedSelf = true;
        } else {
          writableNode = self2.getWritable();
          writableNode.__text = firstPart;
        }
        const selection = $getSelection();
        const splitNodes = [writableNode];
        let textSize = firstPart.length;
        for (let i4 = 1; i4 < partsLength; i4++) {
          const part = parts[i4];
          const partSize = part.length;
          const sibling = $createTextNode(part).getWritable();
          sibling.__format = format;
          sibling.__style = style;
          sibling.__detail = detail;
          const siblingKey = sibling.__key;
          const nextTextSize = textSize + partSize;
          if ($isRangeSelection(selection)) {
            const anchor = selection.anchor;
            const focus = selection.focus;
            if (anchor.key === key && anchor.type === "text" && anchor.offset > textSize && anchor.offset <= nextTextSize) {
              anchor.key = siblingKey;
              anchor.offset -= textSize;
              selection.dirty = true;
            }
            if (focus.key === key && focus.type === "text" && focus.offset > textSize && focus.offset <= nextTextSize) {
              focus.key = siblingKey;
              focus.offset -= textSize;
              selection.dirty = true;
            }
          }
          if (compositionKey === key) {
            $setCompositionKey(siblingKey);
          }
          textSize = nextTextSize;
          splitNodes.push(sibling);
        }
        internalMarkSiblingsAsDirty(this);
        const writableParent = parent.getWritable();
        const insertionIndex = this.getIndexWithinParent();
        if (hasReplacedSelf) {
          writableParent.splice(insertionIndex, 0, splitNodes);
          this.remove();
        } else {
          writableParent.splice(insertionIndex, 1, splitNodes);
        }
        if ($isRangeSelection(selection)) {
          $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);
        }
        return splitNodes;
      }
      /**
       * Merges the target TextNode into this TextNode, removing the target node.
       *
       * @param target - the TextNode to merge into this one.
       *
       * @returns this TextNode.
       */
      mergeWithSibling(target) {
        const isBefore = target === this.getPreviousSibling();
        if (!isBefore && target !== this.getNextSibling()) {
          {
            throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);
          }
        }
        const key = this.__key;
        const targetKey = target.__key;
        const text = this.__text;
        const textLength = text.length;
        const compositionKey = $getCompositionKey();
        if (compositionKey === targetKey) {
          $setCompositionKey(key);
        }
        const selection = $getSelection();
        if ($isRangeSelection(selection)) {
          const anchor = selection.anchor;
          const focus = selection.focus;
          if (anchor !== null && anchor.key === targetKey) {
            adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);
            selection.dirty = true;
          }
          if (focus !== null && focus.key === targetKey) {
            adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);
            selection.dirty = true;
          }
        }
        const targetText = target.__text;
        const newText = isBefore ? targetText + text : text + targetText;
        this.setTextContent(newText);
        const writableSelf = this.getWritable();
        target.remove();
        return writableSelf;
      }
      /**
       * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
       * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
       * node class that you create and replace matched text with should return true from this method.
       *
       * @returns true if the node is to be treated as a "text entity", false otherwise.
       */
      isTextEntity() {
        return false;
      }
    };
    preParentCache = /* @__PURE__ */ new WeakMap();
    nodeNameToTextFormat = {
      code: "code",
      em: "italic",
      i: "italic",
      s: "strikethrough",
      strong: "bold",
      sub: "subscript",
      sup: "superscript",
      u: "underline"
    };
    TabNode = class _TabNode extends TextNode {
      static getType() {
        return "tab";
      }
      static clone(node) {
        const newNode = new _TabNode(node.__key);
        newNode.__text = node.__text;
        newNode.__format = node.__format;
        newNode.__style = node.__style;
        return newNode;
      }
      constructor(key) {
        super("	", key);
        this.__detail = IS_UNMERGEABLE;
      }
      static importDOM() {
        return null;
      }
      static importJSON(serializedTabNode) {
        const node = $createTabNode();
        node.setFormat(serializedTabNode.format);
        node.setStyle(serializedTabNode.style);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          type: "tab",
          version: 1
        };
      }
      setTextContent(_text) {
        {
          throw Error(`TabNode does not support setTextContent`);
        }
      }
      setDetail(_detail) {
        {
          throw Error(`TabNode does not support setDetail`);
        }
      }
      setMode(_type) {
        {
          throw Error(`TabNode does not support setMode`);
        }
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
    };
    Point = class {
      constructor(key, offset3, type) {
        this._selection = null;
        this.key = key;
        this.offset = offset3;
        this.type = type;
      }
      is(point) {
        return this.key === point.key && this.offset === point.offset && this.type === point.type;
      }
      isBefore(b5) {
        let aNode = this.getNode();
        let bNode = b5.getNode();
        const aOffset = this.offset;
        const bOffset = b5.offset;
        if ($isElementNode(aNode)) {
          const aNodeDescendant = aNode.getDescendantByIndex(aOffset);
          aNode = aNodeDescendant != null ? aNodeDescendant : aNode;
        }
        if ($isElementNode(bNode)) {
          const bNodeDescendant = bNode.getDescendantByIndex(bOffset);
          bNode = bNodeDescendant != null ? bNodeDescendant : bNode;
        }
        if (aNode === bNode) {
          return aOffset < bOffset;
        }
        return aNode.isBefore(bNode);
      }
      getNode() {
        const key = this.key;
        const node = $getNodeByKey(key);
        if (node === null) {
          {
            throw Error(`Point.getNode: node not found`);
          }
        }
        return node;
      }
      set(key, offset3, type) {
        const selection = this._selection;
        const oldKey = this.key;
        this.key = key;
        this.offset = offset3;
        this.type = type;
        if (!isCurrentlyReadOnlyMode()) {
          if ($getCompositionKey() === oldKey) {
            $setCompositionKey(key);
          }
          if (selection !== null) {
            selection.setCachedNodes(null);
            selection.dirty = true;
          }
        }
      }
    };
    NodeSelection = class _NodeSelection {
      constructor(objects) {
        this._cachedNodes = null;
        this._nodes = objects;
        this.dirty = false;
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(nodes) {
        this._cachedNodes = nodes;
      }
      is(selection) {
        if (!$isNodeSelection(selection)) {
          return false;
        }
        const a3 = this._nodes;
        const b5 = selection._nodes;
        return a3.size === b5.size && Array.from(a3).every((key) => b5.has(key));
      }
      isCollapsed() {
        return false;
      }
      isBackward() {
        return false;
      }
      getStartEndPoints() {
        return null;
      }
      add(key) {
        this.dirty = true;
        this._nodes.add(key);
        this._cachedNodes = null;
      }
      delete(key) {
        this.dirty = true;
        this._nodes.delete(key);
        this._cachedNodes = null;
      }
      clear() {
        this.dirty = true;
        this._nodes.clear();
        this._cachedNodes = null;
      }
      has(key) {
        return this._nodes.has(key);
      }
      clone() {
        return new _NodeSelection(new Set(this._nodes));
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(text) {
      }
      insertText() {
      }
      insertNodes(nodes) {
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
        let selectionAtEnd;
        if ($isTextNode(lastSelectedNode)) {
          selectionAtEnd = lastSelectedNode.select();
        } else {
          const index = lastSelectedNode.getIndexWithinParent() + 1;
          selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);
        }
        selectionAtEnd.insertNodes(nodes);
        for (let i4 = 0; i4 < selectedNodesLength; i4++) {
          selectedNodes[i4].remove();
        }
      }
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const objects = this._nodes;
        const nodes = [];
        for (const object of objects) {
          const node = $getNodeByKey(object);
          if (node !== null) {
            nodes.push(node);
          }
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      getTextContent() {
        const nodes = this.getNodes();
        let textContent = "";
        for (let i4 = 0; i4 < nodes.length; i4++) {
          textContent += nodes[i4].getTextContent();
        }
        return textContent;
      }
    };
    RangeSelection = class _RangeSelection {
      constructor(anchor, focus, format, style) {
        this.anchor = anchor;
        this.focus = focus;
        anchor._selection = this;
        focus._selection = this;
        this._cachedNodes = null;
        this.format = format;
        this.style = style;
        this.dirty = false;
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(nodes) {
        this._cachedNodes = nodes;
      }
      /**
       * Used to check if the provided selections is equal to this one by value,
       * inluding anchor, focus, format, and style properties.
       * @param selection - the Selection to compare this one to.
       * @returns true if the Selections are equal, false otherwise.
       */
      is(selection) {
        if (!$isRangeSelection(selection)) {
          return false;
        }
        return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;
      }
      /**
       * Returns whether the Selection is "collapsed", meaning the anchor and focus are
       * the same node and have the same offset.
       *
       * @returns true if the Selection is collapsed, false otherwise.
       */
      isCollapsed() {
        return this.anchor.is(this.focus);
      }
      /**
       * Gets all the nodes in the Selection. Uses caching to make it generally suitable
       * for use in hot paths.
       *
       * @returns an Array containing all the nodes in the Selection
       */
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const anchor = this.anchor;
        const focus = this.focus;
        const isBefore = anchor.isBefore(focus);
        const firstPoint = isBefore ? anchor : focus;
        const lastPoint = isBefore ? focus : anchor;
        let firstNode = firstPoint.getNode();
        let lastNode = lastPoint.getNode();
        const startOffset = firstPoint.offset;
        const endOffset = lastPoint.offset;
        if ($isElementNode(firstNode)) {
          const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);
          firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;
        }
        if ($isElementNode(lastNode)) {
          let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);
          if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {
            lastNodeDescendant = lastNodeDescendant.getPreviousSibling();
          }
          lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;
        }
        let nodes;
        if (firstNode.is(lastNode)) {
          if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {
            nodes = [];
          } else {
            nodes = [firstNode];
          }
        } else {
          nodes = firstNode.getNodesBetween(lastNode);
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      /**
       * Sets this Selection to be of type "text" at the provided anchor and focus values.
       *
       * @param anchorNode - the anchor node to set on the Selection
       * @param anchorOffset - the offset to set on the Selection
       * @param focusNode - the focus node to set on the Selection
       * @param focusOffset - the focus offset to set on the Selection
       */
      setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
        $setPointValues(this.anchor, anchorNode.__key, anchorOffset, "text");
        $setPointValues(this.focus, focusNode.__key, focusOffset, "text");
        this._cachedNodes = null;
        this.dirty = true;
      }
      /**
       * Gets the (plain) text content of all the nodes in the selection.
       *
       * @returns a string representing the text content of all the nodes in the Selection
       */
      getTextContent() {
        const nodes = this.getNodes();
        if (nodes.length === 0) {
          return "";
        }
        const firstNode = nodes[0];
        const lastNode = nodes[nodes.length - 1];
        const anchor = this.anchor;
        const focus = this.focus;
        const isBefore = anchor.isBefore(focus);
        const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
        let textContent = "";
        let prevWasElement = true;
        for (let i4 = 0; i4 < nodes.length; i4++) {
          const node = nodes[i4];
          if ($isElementNode(node) && !node.isInline()) {
            if (!prevWasElement) {
              textContent += "\n";
            }
            if (node.isEmpty()) {
              prevWasElement = false;
            } else {
              prevWasElement = true;
            }
          } else {
            prevWasElement = false;
            if ($isTextNode(node)) {
              let text = node.getTextContent();
              if (node === firstNode) {
                if (node === lastNode) {
                  if (anchor.type !== "element" || focus.type !== "element" || focus.offset === anchor.offset) {
                    text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);
                  }
                } else {
                  text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);
                }
              } else if (node === lastNode) {
                text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);
              }
              textContent += text;
            } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {
              textContent += node.getTextContent();
            }
          }
        }
        return textContent;
      }
      /**
       * Attempts to map a DOM selection range onto this Lexical Selection,
       * setting the anchor, focus, and type accordingly
       *
       * @param range a DOM Selection range conforming to the StaticRange interface.
       */
      applyDOMRange(range) {
        const editor = getActiveEditor();
        const currentEditorState = editor.getEditorState();
        const lastSelection = currentEditorState._selection;
        const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);
        if (resolvedSelectionPoints === null) {
          return;
        }
        const [anchorPoint, focusPoint] = resolvedSelectionPoints;
        $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);
        $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);
        this._cachedNodes = null;
      }
      /**
       * Creates a new RangeSelection, copying over all the property values from this one.
       *
       * @returns a new RangeSelection with the same property values as this one.
       */
      clone() {
        const anchor = this.anchor;
        const focus = this.focus;
        const selection = new _RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);
        return selection;
      }
      /**
       * Toggles the provided format on all the TextNodes in the Selection.
       *
       * @param format a string TextFormatType to toggle on the TextNodes in the selection
       */
      toggleFormat(format) {
        this.format = toggleTextFormatType(this.format, format, null);
        this.dirty = true;
      }
      /**
       * Sets the value of the style property on the Selection
       *
       * @param style - the style to set at the value of the style property.
       */
      setStyle(style) {
        this.style = style;
        this.dirty = true;
      }
      /**
       * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
       * has the specified format.
       *
       * @param type the TextFormatType to check for.
       * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
       */
      hasFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return (this.format & formatFlag) !== 0;
      }
      /**
       * Attempts to insert the provided text into the EditorState at the current Selection.
       * converts tabs, newlines, and carriage returns into LexicalNodes.
       *
       * @param text the text to insert into the Selection
       */
      insertRawText(text) {
        const parts = text.split(/(\r?\n|\t)/);
        const nodes = [];
        const length = parts.length;
        for (let i4 = 0; i4 < length; i4++) {
          const part = parts[i4];
          if (part === "\n" || part === "\r\n") {
            nodes.push($createLineBreakNode());
          } else if (part === "	") {
            nodes.push($createTabNode());
          } else {
            nodes.push($createTextNode(part));
          }
        }
        this.insertNodes(nodes);
      }
      /**
       * Attempts to insert the provided text into the EditorState at the current Selection as a new
       * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.
       *
       * @param text the text to insert into the Selection
       */
      insertText(text) {
        const anchor = this.anchor;
        const focus = this.focus;
        const format = this.format;
        const style = this.style;
        let firstPoint = anchor;
        let endPoint = focus;
        if (!this.isCollapsed() && focus.isBefore(anchor)) {
          firstPoint = focus;
          endPoint = anchor;
        }
        if (firstPoint.type === "element") {
          $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);
        }
        const startOffset = firstPoint.offset;
        let endOffset = endPoint.offset;
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        let firstNode = selectedNodes[0];
        if (!$isTextNode(firstNode)) {
          {
            throw Error(`insertText: first node is not a text node`);
          }
        }
        const firstNodeText = firstNode.getTextContent();
        const firstNodeTextLength = firstNodeText.length;
        const firstNodeParent = firstNode.getParentOrThrow();
        const lastIndex = selectedNodesLength - 1;
        let lastNode = selectedNodes[lastIndex];
        if (selectedNodesLength === 1 && endPoint.type === "element") {
          endOffset = firstNodeTextLength;
          endPoint.set(firstPoint.key, endOffset, "text");
        }
        if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
          let nextSibling = firstNode.getNextSibling();
          if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {
            nextSibling = $createTextNode();
            nextSibling.setFormat(format);
            nextSibling.setStyle(style);
            if (!firstNodeParent.canInsertTextAfter()) {
              firstNodeParent.insertAfter(nextSibling);
            } else {
              firstNode.insertAfter(nextSibling);
            }
          }
          nextSibling.select(0, 0);
          firstNode = nextSibling;
          if (text !== "") {
            this.insertText(text);
            return;
          }
        } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
          let prevSibling = firstNode.getPreviousSibling();
          if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {
            prevSibling = $createTextNode();
            prevSibling.setFormat(format);
            if (!firstNodeParent.canInsertTextBefore()) {
              firstNodeParent.insertBefore(prevSibling);
            } else {
              firstNode.insertBefore(prevSibling);
            }
          }
          prevSibling.select();
          firstNode = prevSibling;
          if (text !== "") {
            this.insertText(text);
            return;
          }
        } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
          const textNode = $createTextNode(firstNode.getTextContent());
          textNode.setFormat(format);
          firstNode.replace(textNode);
          firstNode = textNode;
        } else if (!this.isCollapsed() && text !== "") {
          const lastNodeParent = lastNode.getParent();
          if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
            this.insertText("");
            $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
            this.insertText(text);
            return;
          }
        }
        if (selectedNodesLength === 1) {
          if (firstNode.isToken()) {
            const textNode = $createTextNode(text);
            textNode.select();
            firstNode.replace(textNode);
            return;
          }
          const firstNodeFormat = firstNode.getFormat();
          const firstNodeStyle = firstNode.getStyle();
          if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {
            if (firstNode.getTextContent() === "") {
              firstNode.setFormat(format);
              firstNode.setStyle(style);
            } else {
              const textNode = $createTextNode(text);
              textNode.setFormat(format);
              textNode.setStyle(style);
              textNode.select();
              if (startOffset === 0) {
                firstNode.insertBefore(textNode, false);
              } else {
                const [targetNode] = firstNode.splitText(startOffset);
                targetNode.insertAfter(textNode, false);
              }
              if (textNode.isComposing() && this.anchor.type === "text") {
                this.anchor.offset -= text.length;
              }
              return;
            }
          } else if ($isTabNode(firstNode)) {
            const textNode = $createTextNode(text);
            textNode.setFormat(format);
            textNode.setStyle(style);
            textNode.select();
            firstNode.replace(textNode);
            return;
          }
          const delCount = endOffset - startOffset;
          firstNode = firstNode.spliceText(startOffset, delCount, text, true);
          if (firstNode.getTextContent() === "") {
            firstNode.remove();
          } else if (this.anchor.type === "text") {
            if (firstNode.isComposing()) {
              this.anchor.offset -= text.length;
            } else {
              this.format = firstNodeFormat;
              this.style = firstNodeStyle;
            }
          }
        } else {
          const markedNodeKeysForKeep = /* @__PURE__ */ new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);
          const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
          let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();
          let lastElementChild = lastNode;
          if (!firstElement.is(lastElement) && lastElement.isInline()) {
            do {
              lastElementChild = lastElement;
              lastElement = lastElement.getParentOrThrow();
            } while (lastElement.isInline());
          }
          if (endPoint.type === "text" && (endOffset !== 0 || lastNode.getTextContent() === "") || endPoint.type === "element" && lastNode.getIndexWithinParent() < endOffset) {
            if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {
              if (lastNode.isSegmented()) {
                const textNode = $createTextNode(lastNode.getTextContent());
                lastNode.replace(textNode);
                lastNode = textNode;
              }
              if (!$isRootNode(endPoint.getNode()) && endPoint.type === "text") {
                lastNode = lastNode.spliceText(0, endOffset, "");
              }
              markedNodeKeysForKeep.add(lastNode.__key);
            } else {
              const lastNodeParent = lastNode.getParentOrThrow();
              if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
                lastNodeParent.remove();
              } else {
                lastNode.remove();
              }
            }
          } else {
            markedNodeKeysForKeep.add(lastNode.__key);
          }
          const lastNodeChildren = lastElement.getChildren();
          const selectedNodesSet = new Set(selectedNodes);
          const firstAndLastElementsAreEqual = firstElement.is(lastElement);
          const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;
          for (let i4 = lastNodeChildren.length - 1; i4 >= 0; i4--) {
            const lastNodeChild = lastNodeChildren[i4];
            if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
              break;
            }
            if (lastNodeChild.isAttached()) {
              if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
                if (!firstAndLastElementsAreEqual) {
                  insertionTarget.insertAfter(lastNodeChild, false);
                }
              } else {
                lastNodeChild.remove();
              }
            }
          }
          if (!firstAndLastElementsAreEqual) {
            let parent = lastElement;
            let lastRemovedParent = null;
            while (parent !== null) {
              const children = parent.getChildren();
              const childrenLength = children.length;
              if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
                markedNodeKeysForKeep.delete(parent.__key);
                lastRemovedParent = parent;
              }
              parent = parent.getParent();
            }
          }
          if (!firstNode.isToken()) {
            firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);
            if (firstNode.getTextContent() === "") {
              firstNode.remove();
            } else if (firstNode.isComposing() && this.anchor.type === "text") {
              this.anchor.offset -= text.length;
            }
          } else if (startOffset === firstNodeTextLength) {
            firstNode.select();
          } else {
            const textNode = $createTextNode(text);
            textNode.select();
            firstNode.replace(textNode);
          }
          for (let i4 = 1; i4 < selectedNodesLength; i4++) {
            const selectedNode = selectedNodes[i4];
            const key = selectedNode.__key;
            if (!markedNodeKeysForKeep.has(key)) {
              selectedNode.remove();
            }
          }
        }
      }
      /**
       * Removes the text in the Selection, adjusting the EditorState accordingly.
       */
      removeText() {
        this.insertText("");
      }
      /**
       * Applies the provided format to the TextNodes in the Selection, splitting or
       * merging nodes as necessary.
       *
       * @param formatType the format type to apply to the nodes in the Selection.
       */
      formatText(formatType) {
        if (this.isCollapsed()) {
          this.toggleFormat(formatType);
          $setCompositionKey(null);
          return;
        }
        const selectedNodes = this.getNodes();
        const selectedTextNodes = [];
        for (const selectedNode of selectedNodes) {
          if ($isTextNode(selectedNode)) {
            selectedTextNodes.push(selectedNode);
          }
        }
        const selectedTextNodesLength = selectedTextNodes.length;
        if (selectedTextNodesLength === 0) {
          this.toggleFormat(formatType);
          $setCompositionKey(null);
          return;
        }
        const anchor = this.anchor;
        const focus = this.focus;
        const isBackward = this.isBackward();
        const startPoint = isBackward ? focus : anchor;
        const endPoint = isBackward ? anchor : focus;
        let firstIndex = 0;
        let firstNode = selectedTextNodes[0];
        let startOffset = startPoint.type === "element" ? 0 : startPoint.offset;
        if (startPoint.type === "text" && startOffset === firstNode.getTextContentSize()) {
          firstIndex = 1;
          firstNode = selectedTextNodes[1];
          startOffset = 0;
        }
        if (firstNode == null) {
          return;
        }
        const firstNextFormat = firstNode.getFormatFlags(formatType, null);
        const lastIndex = selectedTextNodesLength - 1;
        let lastNode = selectedTextNodes[lastIndex];
        const endOffset = endPoint.type === "text" ? endPoint.offset : lastNode.getTextContentSize();
        if (firstNode.is(lastNode)) {
          if (startOffset === endOffset) {
            return;
          }
          if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
            firstNode.setFormat(firstNextFormat);
          } else {
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            replacement.setFormat(firstNextFormat);
            if (startPoint.type === "text") {
              startPoint.set(replacement.__key, 0, "text");
            }
            if (endPoint.type === "text") {
              endPoint.set(replacement.__key, endOffset - startOffset, "text");
            }
          }
          this.format = firstNextFormat;
          return;
        }
        if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {
          [, firstNode] = firstNode.splitText(startOffset);
          startOffset = 0;
        }
        firstNode.setFormat(firstNextFormat);
        const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);
        if (endOffset > 0) {
          if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {
            [lastNode] = lastNode.splitText(endOffset);
          }
          lastNode.setFormat(lastNextFormat);
        }
        for (let i4 = firstIndex + 1; i4 < lastIndex; i4++) {
          const textNode = selectedTextNodes[i4];
          const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
          textNode.setFormat(nextFormat);
        }
        if (startPoint.type === "text") {
          startPoint.set(firstNode.__key, startOffset, "text");
        }
        if (endPoint.type === "text") {
          endPoint.set(lastNode.__key, endOffset, "text");
        }
        this.format = firstNextFormat | lastNextFormat;
      }
      /**
       * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
       * current Selection according to a set of heuristics that determine how surrounding nodes
       * should be changed, replaced, or moved to accomodate the incoming ones.
       *
       * @param nodes - the nodes to insert
       */
      insertNodes(nodes) {
        if (nodes.length === 0) {
          return;
        }
        if (this.anchor.key === "root") {
          this.insertParagraph();
          const selection = $getSelection();
          if (!$isRangeSelection(selection)) {
            throw Error(`Expected RangeSelection after insertParagraph`);
          }
          return selection.insertNodes(nodes);
        }
        const firstPoint = this.isBackward() ? this.focus : this.anchor;
        const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock);
        const last = nodes[nodes.length - 1];
        if ("__language" in firstBlock && $isElementNode(firstBlock)) {
          if ("__language" in nodes[0]) {
            this.insertText(nodes[0].getTextContent());
          } else {
            const index = $removeTextAndSplitBlock(this);
            firstBlock.splice(index, 0, nodes);
            last.selectEnd();
          }
          return;
        }
        const notInline = (node) => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();
        if (!nodes.some(notInline)) {
          if (!$isElementNode(firstBlock)) {
            throw Error(`Expected 'firstBlock' to be an ElementNode`);
          }
          const index = $removeTextAndSplitBlock(this);
          firstBlock.splice(index, 0, nodes);
          last.selectEnd();
          return;
        }
        const blocksParent = $wrapInlineNodes(nodes);
        const nodeToSelect = blocksParent.getLastDescendant();
        const blocks = blocksParent.getChildren();
        const isLI = (node) => "__value" in node && "__checked" in node;
        const isMergeable = (node) => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || isLI(firstBlock));
        const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();
        const insertedParagraph = shouldInsert ? this.insertParagraph() : null;
        const lastToInsert = blocks[blocks.length - 1];
        let firstToInsert = blocks[0];
        if (isMergeable(firstToInsert)) {
          if (!$isElementNode(firstBlock)) {
            throw Error(`Expected 'firstBlock' to be an ElementNode`);
          }
          firstBlock.append(...firstToInsert.getChildren());
          firstToInsert = blocks[1];
        }
        if (firstToInsert) {
          insertRangeAfter(firstBlock, firstToInsert);
        }
        const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);
        if (insertedParagraph && $isElementNode(lastInsertedBlock) && (isLI(insertedParagraph) || INTERNAL_$isBlock(lastToInsert))) {
          lastInsertedBlock.append(...insertedParagraph.getChildren());
          insertedParagraph.remove();
        }
        if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {
          firstBlock.remove();
        }
        nodeToSelect.selectEnd();
        const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;
        if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {
          lastChild.remove();
        }
      }
      /**
       * Inserts a new ParagraphNode into the EditorState at the current Selection
       *
       * @returns the newly inserted node.
       */
      insertParagraph() {
        if (this.anchor.key === "root") {
          const paragraph = $createParagraphNode();
          $getRoot().splice(this.anchor.offset, 0, [paragraph]);
          paragraph.select();
          return paragraph;
        }
        const index = $removeTextAndSplitBlock(this);
        const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);
        if (!$isElementNode(block)) {
          throw Error(`Expected ancestor to be an ElementNode`);
        }
        const firstToAppend = block.getChildAtIndex(index);
        const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];
        const newBlock = block.insertNewAfter(this, false);
        if (newBlock) {
          newBlock.append(...nodesToInsert);
          newBlock.selectStart();
          return newBlock;
        }
        return null;
      }
      /**
       * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
       * current Selection.
       */
      insertLineBreak(selectStart) {
        const lineBreak = $createLineBreakNode();
        this.insertNodes([lineBreak]);
        if (selectStart) {
          const parent = lineBreak.getParentOrThrow();
          const index = lineBreak.getIndexWithinParent();
          parent.select(index, index);
        }
      }
      /**
       * Extracts the nodes in the Selection, splitting nodes where necessary
       * to get offset-level precision.
       *
       * @returns The nodes in the Selection
       */
      extract() {
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const lastIndex = selectedNodesLength - 1;
        const anchor = this.anchor;
        const focus = this.focus;
        let firstNode = selectedNodes[0];
        let lastNode = selectedNodes[lastIndex];
        const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
        if (selectedNodesLength === 0) {
          return [];
        } else if (selectedNodesLength === 1) {
          if ($isTextNode(firstNode) && !this.isCollapsed()) {
            const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
            const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            return node != null ? [node] : [];
          }
          return [firstNode];
        }
        const isBefore = anchor.isBefore(focus);
        if ($isTextNode(firstNode)) {
          const startOffset = isBefore ? anchorOffset : focusOffset;
          if (startOffset === firstNode.getTextContentSize()) {
            selectedNodes.shift();
          } else if (startOffset !== 0) {
            [, firstNode] = firstNode.splitText(startOffset);
            selectedNodes[0] = firstNode;
          }
        }
        if ($isTextNode(lastNode)) {
          const lastNodeText = lastNode.getTextContent();
          const lastNodeTextLength = lastNodeText.length;
          const endOffset = isBefore ? focusOffset : anchorOffset;
          if (endOffset === 0) {
            selectedNodes.pop();
          } else if (endOffset !== lastNodeTextLength) {
            [lastNode] = lastNode.splitText(endOffset);
            selectedNodes[lastIndex] = lastNode;
          }
        }
        return selectedNodes;
      }
      /**
       * Modifies the Selection according to the parameters and a set of heuristics that account for
       * various node types. Can be used to safely move or extend selection by one logical "unit" without
       * dealing explicitly with all the possible node types.
       *
       * @param alter the type of modification to perform
       * @param isBackward whether or not selection is backwards
       * @param granularity the granularity at which to apply the modification
       */
      modify(alter, isBackward, granularity) {
        const focus = this.focus;
        const anchor = this.anchor;
        const collapse = alter === "move";
        const possibleNode = $getAdjacentNode(focus, isBackward);
        if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
          if (collapse && possibleNode.isKeyboardSelectable()) {
            const nodeSelection = $createNodeSelection();
            nodeSelection.add(possibleNode.__key);
            $setSelection(nodeSelection);
            return;
          }
          const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();
          if (!$isTextNode(sibling)) {
            const parent = possibleNode.getParentOrThrow();
            let offset3;
            let elementKey;
            if ($isElementNode(sibling)) {
              elementKey = sibling.__key;
              offset3 = isBackward ? sibling.getChildrenSize() : 0;
            } else {
              offset3 = possibleNode.getIndexWithinParent();
              elementKey = parent.__key;
              if (!isBackward) {
                offset3++;
              }
            }
            focus.set(elementKey, offset3, "element");
            if (collapse) {
              anchor.set(elementKey, offset3, "element");
            }
            return;
          } else {
            const siblingKey = sibling.__key;
            const offset3 = isBackward ? sibling.getTextContent().length : 0;
            focus.set(siblingKey, offset3, "text");
            if (collapse) {
              anchor.set(siblingKey, offset3, "text");
            }
            return;
          }
        }
        const editor = getActiveEditor();
        const domSelection = getDOMSelection(editor._window);
        if (!domSelection) {
          return;
        }
        const blockCursorElement = editor._blockCursorElement;
        const rootElement = editor._rootElement;
        if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        moveNativeSelection(domSelection, alter, isBackward ? "backward" : "forward", granularity);
        if (domSelection.rangeCount > 0) {
          const range = domSelection.getRangeAt(0);
          const anchorNode = this.anchor.getNode();
          const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
          this.applyDOMRange(range);
          this.dirty = true;
          if (!collapse) {
            const nodes = this.getNodes();
            const validNodes = [];
            let shrinkSelection = false;
            for (let i4 = 0; i4 < nodes.length; i4++) {
              const nextNode = nodes[i4];
              if ($hasAncestor(nextNode, root)) {
                validNodes.push(nextNode);
              } else {
                shrinkSelection = true;
              }
            }
            if (shrinkSelection && validNodes.length > 0) {
              if (isBackward) {
                const firstValidNode = validNodes[0];
                if ($isElementNode(firstValidNode)) {
                  firstValidNode.selectStart();
                } else {
                  firstValidNode.getParentOrThrow().selectStart();
                }
              } else {
                const lastValidNode = validNodes[validNodes.length - 1];
                if ($isElementNode(lastValidNode)) {
                  lastValidNode.selectEnd();
                } else {
                  lastValidNode.getParentOrThrow().selectEnd();
                }
              }
            }
            if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {
              $swapPoints(this);
            }
          }
        }
      }
      /**
       * Helper for handling forward character and word deletion that prevents element nodes
       * like a table, columns layout being destroyed
       *
       * @param anchor the anchor
       * @param anchorNode the anchor node in the selection
       * @param isBackward whether or not selection is backwards
       */
      forwardDeletion(anchor, anchorNode, isBackward) {
        if (!isBackward && // Delete forward handle case
        (anchor.type === "element" && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === "text" && anchor.offset === anchorNode.getTextContentSize())) {
          const parent = anchorNode.getParent();
          const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());
          if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {
            return true;
          }
        }
        return false;
      }
      /**
       * Performs one logical character deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteCharacter(isBackward) {
        const wasCollapsed = this.isCollapsed();
        if (this.isCollapsed()) {
          const anchor = this.anchor;
          let anchorNode = anchor.getNode();
          if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
            return;
          }
          const focus = this.focus;
          const possibleNode = $getAdjacentNode(focus, isBackward);
          if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
            if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {
              anchorNode.remove();
              const nodeSelection = $createNodeSelection();
              nodeSelection.add(possibleNode.__key);
              $setSelection(nodeSelection);
            } else {
              possibleNode.remove();
              const editor = getActiveEditor();
              editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
            }
            return;
          } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {
            anchorNode.remove();
            possibleNode.selectStart();
            return;
          }
          this.modify("extend", isBackward, "character");
          if (!this.isCollapsed()) {
            const focusNode = focus.type === "text" ? focus.getNode() : null;
            anchorNode = anchor.type === "text" ? anchor.getNode() : null;
            if (focusNode !== null && focusNode.isSegmented()) {
              const offset3 = focus.offset;
              const textContentSize = focusNode.getTextContentSize();
              if (focusNode.is(anchorNode) || isBackward && offset3 !== textContentSize || !isBackward && offset3 !== 0) {
                $removeSegment(focusNode, isBackward, offset3);
                return;
              }
            } else if (anchorNode !== null && anchorNode.isSegmented()) {
              const offset3 = anchor.offset;
              const textContentSize = anchorNode.getTextContentSize();
              if (anchorNode.is(focusNode) || isBackward && offset3 !== 0 || !isBackward && offset3 !== textContentSize) {
                $removeSegment(anchorNode, isBackward, offset3);
                return;
              }
            }
            $updateCaretSelectionForUnicodeCharacter(this, isBackward);
          } else if (isBackward && anchor.offset === 0) {
            const element = anchor.type === "element" ? anchor.getNode() : anchor.getNode().getParentOrThrow();
            if (element.collapseAtStart(this)) {
              return;
            }
          }
        }
        this.removeText();
        if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
          const anchorNode = this.anchor.getNode();
          if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {
            anchorNode.collapseAtStart(this);
          }
        }
      }
      /**
       * Performs one logical line deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteLine(isBackward) {
        if (this.isCollapsed()) {
          const anchorIsElement = this.anchor.type === "element";
          if (anchorIsElement) {
            this.insertText(" ");
          }
          this.modify("extend", isBackward, "lineboundary");
          const endPoint = isBackward ? this.focus : this.anchor;
          if (endPoint.offset === 0) {
            this.modify("extend", isBackward, "character");
          }
          if (anchorIsElement) {
            const startPoint = isBackward ? this.anchor : this.focus;
            startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);
          }
        }
        this.removeText();
      }
      /**
       * Performs one logical word deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteWord(isBackward) {
        if (this.isCollapsed()) {
          const anchor = this.anchor;
          const anchorNode = anchor.getNode();
          if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
            return;
          }
          this.modify("extend", isBackward, "word");
        }
        this.removeText();
      }
      /**
       * Returns whether the Selection is "backwards", meaning the focus
       * logically precedes the anchor in the EditorState.
       * @returns true if the Selection is backwards, false otherwise.
       */
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      getStartEndPoints() {
        return [this.anchor, this.focus];
      }
    };
    activeEditorState = null;
    activeEditor = null;
    isReadOnlyMode = false;
    isAttemptingToRecoverFromReconcilerError = false;
    infiniteTransformCount = 0;
    observerOptions = {
      characterData: true,
      childList: true,
      subtree: true
    };
    ElementNode = class extends LexicalNode {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      constructor(key) {
        super(key);
        this.__first = null;
        this.__last = null;
        this.__size = 0;
        this.__format = 0;
        this.__indent = 0;
        this.__dir = null;
      }
      getFormat() {
        const self2 = this.getLatest();
        return self2.__format;
      }
      getFormatType() {
        const format = this.getFormat();
        return ELEMENT_FORMAT_TO_TYPE[format] || "";
      }
      getIndent() {
        const self2 = this.getLatest();
        return self2.__indent;
      }
      getChildren() {
        const children = [];
        let child = this.getFirstChild();
        while (child !== null) {
          children.push(child);
          child = child.getNextSibling();
        }
        return children;
      }
      getChildrenKeys() {
        const children = [];
        let child = this.getFirstChild();
        while (child !== null) {
          children.push(child.__key);
          child = child.getNextSibling();
        }
        return children;
      }
      getChildrenSize() {
        const self2 = this.getLatest();
        return self2.__size;
      }
      isEmpty() {
        return this.getChildrenSize() === 0;
      }
      isDirty() {
        const editor = getActiveEditor();
        const dirtyElements = editor._dirtyElements;
        return dirtyElements !== null && dirtyElements.has(this.__key);
      }
      isLastChild() {
        const self2 = this.getLatest();
        const parentLastChild = this.getParentOrThrow().getLastChild();
        return parentLastChild !== null && parentLastChild.is(self2);
      }
      getAllTextNodes() {
        const textNodes = [];
        let child = this.getFirstChild();
        while (child !== null) {
          if ($isTextNode(child)) {
            textNodes.push(child);
          }
          if ($isElementNode(child)) {
            const subChildrenNodes = child.getAllTextNodes();
            textNodes.push(...subChildrenNodes);
          }
          child = child.getNextSibling();
        }
        return textNodes;
      }
      getFirstDescendant() {
        let node = this.getFirstChild();
        while ($isElementNode(node)) {
          const child = node.getFirstChild();
          if (child === null) {
            break;
          }
          node = child;
        }
        return node;
      }
      getLastDescendant() {
        let node = this.getLastChild();
        while ($isElementNode(node)) {
          const child = node.getLastChild();
          if (child === null) {
            break;
          }
          node = child;
        }
        return node;
      }
      getDescendantByIndex(index) {
        const children = this.getChildren();
        const childrenLength = children.length;
        if (index >= childrenLength) {
          const resolvedNode2 = children[childrenLength - 1];
          return $isElementNode(resolvedNode2) && resolvedNode2.getLastDescendant() || resolvedNode2 || null;
        }
        const resolvedNode = children[index];
        return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
      }
      getFirstChild() {
        const self2 = this.getLatest();
        const firstKey = self2.__first;
        return firstKey === null ? null : $getNodeByKey(firstKey);
      }
      getFirstChildOrThrow() {
        const firstChild = this.getFirstChild();
        if (firstChild === null) {
          {
            throw Error(`Expected node ${this.__key} to have a first child.`);
          }
        }
        return firstChild;
      }
      getLastChild() {
        const self2 = this.getLatest();
        const lastKey = self2.__last;
        return lastKey === null ? null : $getNodeByKey(lastKey);
      }
      getLastChildOrThrow() {
        const lastChild = this.getLastChild();
        if (lastChild === null) {
          {
            throw Error(`Expected node ${this.__key} to have a last child.`);
          }
        }
        return lastChild;
      }
      getChildAtIndex(index) {
        const size3 = this.getChildrenSize();
        let node;
        let i4;
        if (index < size3 / 2) {
          node = this.getFirstChild();
          i4 = 0;
          while (node !== null && i4 <= index) {
            if (i4 === index) {
              return node;
            }
            node = node.getNextSibling();
            i4++;
          }
          return null;
        }
        node = this.getLastChild();
        i4 = size3 - 1;
        while (node !== null && i4 >= index) {
          if (i4 === index) {
            return node;
          }
          node = node.getPreviousSibling();
          i4--;
        }
        return null;
      }
      getTextContent() {
        let textContent = "";
        const children = this.getChildren();
        const childrenLength = children.length;
        for (let i4 = 0; i4 < childrenLength; i4++) {
          const child = children[i4];
          textContent += child.getTextContent();
          if ($isElementNode(child) && i4 !== childrenLength - 1 && !child.isInline()) {
            textContent += DOUBLE_LINE_BREAK;
          }
        }
        return textContent;
      }
      getTextContentSize() {
        let textContentSize = 0;
        const children = this.getChildren();
        const childrenLength = children.length;
        for (let i4 = 0; i4 < childrenLength; i4++) {
          const child = children[i4];
          textContentSize += child.getTextContentSize();
          if ($isElementNode(child) && i4 !== childrenLength - 1 && !child.isInline()) {
            textContentSize += DOUBLE_LINE_BREAK.length;
          }
        }
        return textContentSize;
      }
      getDirection() {
        const self2 = this.getLatest();
        return self2.__dir;
      }
      hasFormat(type) {
        if (type !== "") {
          const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];
          return (this.getFormat() & formatFlag) !== 0;
        }
        return false;
      }
      // Mutators
      select(_anchorOffset, _focusOffset) {
        errorOnReadOnly();
        const selection = $getSelection();
        let anchorOffset = _anchorOffset;
        let focusOffset = _focusOffset;
        const childrenCount = this.getChildrenSize();
        if (!this.canBeEmpty()) {
          if (_anchorOffset === 0 && _focusOffset === 0) {
            const firstChild = this.getFirstChild();
            if ($isTextNode(firstChild) || $isElementNode(firstChild)) {
              return firstChild.select(0, 0);
            }
          } else if ((_anchorOffset === void 0 || _anchorOffset === childrenCount) && (_focusOffset === void 0 || _focusOffset === childrenCount)) {
            const lastChild = this.getLastChild();
            if ($isTextNode(lastChild) || $isElementNode(lastChild)) {
              return lastChild.select();
            }
          }
        }
        if (anchorOffset === void 0) {
          anchorOffset = childrenCount;
        }
        if (focusOffset === void 0) {
          focusOffset = childrenCount;
        }
        const key = this.__key;
        if (!$isRangeSelection(selection)) {
          return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "element", "element");
        } else {
          selection.anchor.set(key, anchorOffset, "element");
          selection.focus.set(key, focusOffset, "element");
          selection.dirty = true;
        }
        return selection;
      }
      selectStart() {
        const firstNode = this.getFirstDescendant();
        return firstNode ? firstNode.selectStart() : this.select();
      }
      selectEnd() {
        const lastNode = this.getLastDescendant();
        return lastNode ? lastNode.selectEnd() : this.select();
      }
      clear() {
        const writableSelf = this.getWritable();
        const children = this.getChildren();
        children.forEach((child) => child.remove());
        return writableSelf;
      }
      append(...nodesToAppend) {
        return this.splice(this.getChildrenSize(), 0, nodesToAppend);
      }
      setDirection(direction) {
        const self2 = this.getWritable();
        self2.__dir = direction;
        return self2;
      }
      setFormat(type) {
        const self2 = this.getWritable();
        self2.__format = type !== "" ? ELEMENT_TYPE_TO_FORMAT[type] : 0;
        return this;
      }
      setIndent(indentLevel) {
        const self2 = this.getWritable();
        self2.__indent = indentLevel;
        return this;
      }
      splice(start, deleteCount, nodesToInsert) {
        const nodesToInsertLength = nodesToInsert.length;
        const oldSize = this.getChildrenSize();
        const writableSelf = this.getWritable();
        const writableSelfKey = writableSelf.__key;
        const nodesToInsertKeys = [];
        const nodesToRemoveKeys = [];
        const nodeAfterRange = this.getChildAtIndex(start + deleteCount);
        let nodeBeforeRange = null;
        let newSize = oldSize - deleteCount + nodesToInsertLength;
        if (start !== 0) {
          if (start === oldSize) {
            nodeBeforeRange = this.getLastChild();
          } else {
            const node = this.getChildAtIndex(start);
            if (node !== null) {
              nodeBeforeRange = node.getPreviousSibling();
            }
          }
        }
        if (deleteCount > 0) {
          let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();
          for (let i4 = 0; i4 < deleteCount; i4++) {
            if (nodeToDelete === null) {
              {
                throw Error(`splice: sibling not found`);
              }
            }
            const nextSibling = nodeToDelete.getNextSibling();
            const nodeKeyToDelete = nodeToDelete.__key;
            const writableNodeToDelete = nodeToDelete.getWritable();
            removeFromParent(writableNodeToDelete);
            nodesToRemoveKeys.push(nodeKeyToDelete);
            nodeToDelete = nextSibling;
          }
        }
        let prevNode = nodeBeforeRange;
        for (let i4 = 0; i4 < nodesToInsertLength; i4++) {
          const nodeToInsert = nodesToInsert[i4];
          if (prevNode !== null && nodeToInsert.is(prevNode)) {
            nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
          }
          const writableNodeToInsert = nodeToInsert.getWritable();
          if (writableNodeToInsert.__parent === writableSelfKey) {
            newSize--;
          }
          removeFromParent(writableNodeToInsert);
          const nodeKeyToInsert = nodeToInsert.__key;
          if (prevNode === null) {
            writableSelf.__first = nodeKeyToInsert;
            writableNodeToInsert.__prev = null;
          } else {
            const writablePrevNode = prevNode.getWritable();
            writablePrevNode.__next = nodeKeyToInsert;
            writableNodeToInsert.__prev = writablePrevNode.__key;
          }
          if (nodeToInsert.__key === writableSelfKey) {
            {
              throw Error(`append: attempting to append self`);
            }
          }
          writableNodeToInsert.__parent = writableSelfKey;
          nodesToInsertKeys.push(nodeKeyToInsert);
          prevNode = nodeToInsert;
        }
        if (start + deleteCount === oldSize) {
          if (prevNode !== null) {
            const writablePrevNode = prevNode.getWritable();
            writablePrevNode.__next = null;
            writableSelf.__last = prevNode.__key;
          }
        } else if (nodeAfterRange !== null) {
          const writableNodeAfterRange = nodeAfterRange.getWritable();
          if (prevNode !== null) {
            const writablePrevNode = prevNode.getWritable();
            writableNodeAfterRange.__prev = prevNode.__key;
            writablePrevNode.__next = nodeAfterRange.__key;
          } else {
            writableNodeAfterRange.__prev = null;
          }
        }
        writableSelf.__size = newSize;
        if (nodesToRemoveKeys.length) {
          const selection = $getSelection();
          if ($isRangeSelection(selection)) {
            const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
            const nodesToInsertKeySet = new Set(nodesToInsertKeys);
            const {
              anchor,
              focus
            } = selection;
            if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
              moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
            }
            if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {
              moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);
            }
            if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {
              this.remove();
            }
          }
        }
        return writableSelf;
      }
      // JSON serialization
      exportJSON() {
        return {
          children: [],
          direction: this.getDirection(),
          format: this.getFormatType(),
          indent: this.getIndent(),
          type: "element",
          version: 1
        };
      }
      // These are intended to be extends for specific element heuristics.
      insertNewAfter(selection, restoreSelection) {
        return null;
      }
      canIndent() {
        return true;
      }
      /*
       * This method controls the behavior of a the node during backwards
       * deletion (i.e., backspace) when selection is at the beginning of
       * the node (offset 0)
       */
      collapseAtStart(selection) {
        return false;
      }
      excludeFromCopy(destination) {
        return false;
      }
      /** @deprecated @internal */
      canReplaceWith(replacement) {
        return true;
      }
      /** @deprecated @internal */
      canInsertAfter(node) {
        return true;
      }
      canBeEmpty() {
        return true;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      isInline() {
        return false;
      }
      // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
      // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
      // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
      // will return the immediate first child underneath TableCellNode instead of RootNode.
      isShadowRoot() {
        return false;
      }
      /** @deprecated @internal */
      canMergeWith(node) {
        return false;
      }
      extractWithChild(child, selection, destination) {
        return false;
      }
    };
    DecoratorNode = class extends LexicalNode {
      constructor(key) {
        super(key);
      }
      /**
       * The returned value is added to the LexicalEditor._decorators
       */
      decorate(editor, config2) {
        {
          throw Error(`decorate: base method not extended`);
        }
      }
      isIsolated() {
        return false;
      }
      isInline() {
        return true;
      }
      isKeyboardSelectable() {
        return true;
      }
    };
    RootNode = class _RootNode extends ElementNode {
      /** @internal */
      static getType() {
        return "root";
      }
      static clone() {
        return new _RootNode();
      }
      constructor() {
        super("root");
        this.__cachedText = null;
      }
      getTopLevelElementOrThrow() {
        {
          throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);
        }
      }
      getTextContent() {
        const cachedText = this.__cachedText;
        if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
          if (cachedText !== null) {
            return cachedText;
          }
        }
        return super.getTextContent();
      }
      remove() {
        {
          throw Error(`remove: cannot be called on root nodes`);
        }
      }
      replace(node) {
        {
          throw Error(`replace: cannot be called on root nodes`);
        }
      }
      insertBefore(nodeToInsert) {
        {
          throw Error(`insertBefore: cannot be called on root nodes`);
        }
      }
      insertAfter(nodeToInsert) {
        {
          throw Error(`insertAfter: cannot be called on root nodes`);
        }
      }
      // View
      updateDOM(prevNode, dom) {
        return false;
      }
      // Mutate
      append(...nodesToAppend) {
        for (let i4 = 0; i4 < nodesToAppend.length; i4++) {
          const node = nodesToAppend[i4];
          if (!$isElementNode(node) && !$isDecoratorNode(node)) {
            {
              throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);
            }
          }
        }
        return super.append(...nodesToAppend);
      }
      static importJSON(serializedNode) {
        const node = $getRoot();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          children: [],
          direction: this.getDirection(),
          format: this.getFormatType(),
          indent: this.getIndent(),
          type: "root",
          version: 1
        };
      }
      collapseAtStart() {
        return true;
      }
    };
    EditorState = class _EditorState {
      constructor(nodeMap, selection) {
        this._nodeMap = nodeMap;
        this._selection = selection || null;
        this._flushSync = false;
        this._readOnly = false;
      }
      isEmpty() {
        return this._nodeMap.size === 1 && this._selection === null;
      }
      read(callbackFn) {
        return readEditorState(this, callbackFn);
      }
      clone(selection) {
        const editorState = new _EditorState(this._nodeMap, selection === void 0 ? this._selection : selection);
        editorState._readOnly = true;
        return editorState;
      }
      toJSON() {
        return readEditorState(this, () => ({
          root: exportNodeToJSON($getRoot())
        }));
      }
    };
    ArtificialNode__DO_NOT_USE = class extends ElementNode {
      static getType() {
        return "artificial";
      }
      createDOM(config2) {
        const dom = document.createElement("div");
        return dom;
      }
    };
    ParagraphNode = class _ParagraphNode extends ElementNode {
      /** @internal */
      constructor(key) {
        super(key);
        this.__textFormat = 0;
      }
      static getType() {
        return "paragraph";
      }
      getTextFormat() {
        const self2 = this.getLatest();
        return self2.__textFormat;
      }
      setTextFormat(type) {
        const self2 = this.getWritable();
        self2.__textFormat = type;
        return self2;
      }
      hasTextFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return (this.getTextFormat() & formatFlag) !== 0;
      }
      static clone(node) {
        return new _ParagraphNode(node.__key);
      }
      // View
      createDOM(config2) {
        const dom = document.createElement("p");
        const classNames = getCachedClassNameArray(config2.theme, "paragraph");
        if (classNames !== void 0) {
          const domClassList = dom.classList;
          domClassList.add(...classNames);
        }
        return dom;
      }
      updateDOM(prevNode, dom, config2) {
        return false;
      }
      static importDOM() {
        return {
          p: (node) => ({
            conversion: $convertParagraphElement,
            priority: 0
          })
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element && isHTMLElement2(element)) {
          if (this.isEmpty()) {
            element.append(document.createElement("br"));
          }
          const formatType = this.getFormatType();
          element.style.textAlign = formatType;
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
          const indent = this.getIndent();
          if (indent > 0) {
            element.style.textIndent = `${indent * 20}px`;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        const node = $createParagraphNode();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        node.setTextFormat(serializedNode.textFormat);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          textFormat: this.getTextFormat(),
          type: "paragraph",
          version: 1
        };
      }
      // Mutation
      insertNewAfter(rangeSelection, restoreSelection) {
        const newElement = $createParagraphNode();
        newElement.setTextFormat(rangeSelection.format);
        const direction = this.getDirection();
        newElement.setDirection(direction);
        newElement.setFormat(this.getFormatType());
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart() {
        const children = this.getChildren();
        if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === "") {
          const nextSibling = this.getNextSibling();
          if (nextSibling !== null) {
            this.selectNext();
            this.remove();
            return true;
          }
          const prevSibling = this.getPreviousSibling();
          if (prevSibling !== null) {
            this.selectPrevious();
            this.remove();
            return true;
          }
        }
        return false;
      }
    };
    COMMAND_PRIORITY_EDITOR = 0;
    COMMAND_PRIORITY_LOW = 1;
    COMMAND_PRIORITY_NORMAL = 2;
    COMMAND_PRIORITY_HIGH = 3;
    COMMAND_PRIORITY_CRITICAL = 4;
    LexicalEditor = class {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      constructor(editorState, parentEditor, nodes, config2, onError, htmlConversions, editable) {
        this._parentEditor = parentEditor;
        this._rootElement = null;
        this._editorState = editorState;
        this._pendingEditorState = null;
        this._compositionKey = null;
        this._deferred = [];
        this._keyToDOMMap = /* @__PURE__ */ new Map();
        this._updates = [];
        this._updating = false;
        this._listeners = {
          decorator: /* @__PURE__ */ new Set(),
          editable: /* @__PURE__ */ new Set(),
          mutation: /* @__PURE__ */ new Map(),
          root: /* @__PURE__ */ new Set(),
          textcontent: /* @__PURE__ */ new Set(),
          update: /* @__PURE__ */ new Set()
        };
        this._commands = /* @__PURE__ */ new Map();
        this._config = config2;
        this._nodes = nodes;
        this._decorators = {};
        this._pendingDecorators = null;
        this._dirtyType = NO_DIRTY_NODES;
        this._cloneNotNeeded = /* @__PURE__ */ new Set();
        this._dirtyLeaves = /* @__PURE__ */ new Set();
        this._dirtyElements = /* @__PURE__ */ new Map();
        this._normalizedNodes = /* @__PURE__ */ new Set();
        this._updateTags = /* @__PURE__ */ new Set();
        this._observer = null;
        this._key = createUID();
        this._onError = onError;
        this._htmlConversions = htmlConversions;
        this._editable = editable;
        this._headless = parentEditor !== null && parentEditor._headless;
        this._window = null;
        this._blockCursorElement = null;
      }
      /**
       *
       * @returns true if the editor is currently in "composition" mode due to receiving input
       * through an IME, or 3P extension, for example. Returns false otherwise.
       */
      isComposing() {
        return this._compositionKey != null;
      }
      /**
       * Registers a listener for Editor update event. Will trigger the provided callback
       * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerUpdateListener(listener) {
        const listenerSetOrMap = this._listeners.update;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for for when the editor changes between editable and non-editable states.
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerEditableListener(listener) {
        const listenerSetOrMap = this._listeners.editable;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when the editor's decorator object changes. The decorator object contains
       * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerDecoratorListener(listener) {
        const listenerSetOrMap = this._listeners.decorator;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when Lexical commits an update to the DOM and the text content of
       * the editor changes from the previous state of the editor. If the text content is the
       * same between updates, no notifications to the listeners will happen.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerTextContentListener(listener) {
        const listenerSetOrMap = this._listeners.textcontent;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when the editor's root DOM element (the content editable
       * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
       *  element. The root listener function is executed directly upon registration and then on
       * any subsequent update.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerRootListener(listener) {
        const listenerSetOrMap = this._listeners.root;
        listener(this._rootElement, null);
        listenerSetOrMap.add(listener);
        return () => {
          listener(null, this._rootElement);
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener that will trigger anytime the provided command
       * is dispatched, subject to priority. Listeners that run at a higher priority can "intercept"
       * commands and prevent them from propagating to other handlers by returning true.
       *
       * Listeners registered at the same priority level will run deterministically in the order of registration.
       *
       * @param command - the command that will trigger the callback.
       * @param listener - the function that will execute when the command is dispatched.
       * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerCommand(command, listener, priority) {
        if (priority === void 0) {
          {
            throw Error(`Listener for type "command" requires a "priority".`);
          }
        }
        const commandsMap = this._commands;
        if (!commandsMap.has(command)) {
          commandsMap.set(command, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
        }
        const listenersInPriorityOrder = commandsMap.get(command);
        if (listenersInPriorityOrder === void 0) {
          {
            throw Error(`registerCommand: Command ${String(command)} not found in command map`);
          }
        }
        const listeners = listenersInPriorityOrder[priority];
        listeners.add(listener);
        return () => {
          listeners.delete(listener);
          if (listenersInPriorityOrder.every((listenersSet) => listenersSet.size === 0)) {
            commandsMap.delete(command);
          }
        };
      }
      /**
       * Registers a listener that will run when a Lexical node of the provided class is
       * mutated. The listener will receive a list of nodes along with the type of mutation
       * that was performed on each: created, destroyed, or updated.
       *
       * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
       * {@link LexicalEditor.getElementByKey} can be used for this.
       *
       * @param klass - The class of the node that you want to listen to mutations on.
       * @param listener - The logic you want to run when the node is mutated.
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerMutationListener(klass, listener) {
        let registeredNode = this._nodes.get(klass.getType());
        if (registeredNode === void 0) {
          {
            throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
          }
        }
        let klassToMutate = klass;
        let replaceKlass = null;
        while (replaceKlass = registeredNode.replaceWithKlass) {
          klassToMutate = replaceKlass;
          registeredNode = this._nodes.get(replaceKlass.getType());
          if (registeredNode === void 0) {
            {
              throw Error(`Node ${replaceKlass.name} has not been registered. Ensure node has been passed to createEditor.`);
            }
          }
        }
        const mutations = this._listeners.mutation;
        mutations.set(listener, klassToMutate);
        return () => {
          mutations.delete(listener);
        };
      }
      /** @internal */
      registerNodeTransformToKlass(klass, listener) {
        const type = klass.getType();
        const registeredNode = this._nodes.get(type);
        if (registeredNode === void 0) {
          {
            throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
          }
        }
        const transforms = registeredNode.transforms;
        transforms.add(listener);
        return registeredNode;
      }
      /**
       * Registers a listener that will run when a Lexical node of the provided class is
       * marked dirty during an update. The listener will continue to run as long as the node
       * is marked dirty. There are no guarantees around the order of transform execution!
       *
       * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
       * @param klass - The class of the node that you want to run transforms on.
       * @param listener - The logic you want to run when the node is updated.
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerNodeTransform(klass, listener) {
        const registeredNode = this.registerNodeTransformToKlass(klass, listener);
        const registeredNodes = [registeredNode];
        const replaceWithKlass = registeredNode.replaceWithKlass;
        if (replaceWithKlass != null) {
          const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);
          registeredNodes.push(registeredReplaceWithNode);
        }
        markAllNodesAsDirty(this, klass.getType());
        return () => {
          registeredNodes.forEach((node) => node.transforms.delete(listener));
        };
      }
      /**
       * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
       * depend on have been registered.
       * @returns True if the editor has registered the provided node type, false otherwise.
       */
      hasNode(node) {
        return this._nodes.has(node.getType());
      }
      /**
       * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
       * depend on have been registered.
       * @returns True if the editor has registered all of the provided node types, false otherwise.
       */
      hasNodes(nodes) {
        return nodes.every(this.hasNode.bind(this));
      }
      /**
       * Dispatches a command of the specified type with the specified payload.
       * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
       * for this type, passing them the provided payload.
       * @param type - the type of command listeners to trigger.
       * @param payload - the data to pass as an argument to the command listeners.
       */
      dispatchCommand(type, payload) {
        return dispatchCommand(this, type, payload);
      }
      /**
       * Gets a map of all decorators in the editor.
       * @returns A mapping of call decorator keys to their decorated content
       */
      getDecorators() {
        return this._decorators;
      }
      /**
       *
       * @returns the current root element of the editor. If you want to register
       * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
       * this reference may not be stable.
       */
      getRootElement() {
        return this._rootElement;
      }
      /**
       * Gets the key of the editor
       * @returns The editor key
       */
      getKey() {
        return this._key;
      }
      /**
       * Imperatively set the root contenteditable element that Lexical listens
       * for events on.
       */
      setRootElement(nextRootElement) {
        const prevRootElement = this._rootElement;
        if (nextRootElement !== prevRootElement) {
          const classNames = getCachedClassNameArray(this._config.theme, "root");
          const pendingEditorState = this._pendingEditorState || this._editorState;
          this._rootElement = nextRootElement;
          resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);
          if (prevRootElement !== null) {
            if (!this._config.disableEvents) {
              removeRootElementEvents(prevRootElement);
            }
            if (classNames != null) {
              prevRootElement.classList.remove(...classNames);
            }
          }
          if (nextRootElement !== null) {
            const windowObj = getDefaultView(nextRootElement);
            const style = nextRootElement.style;
            style.userSelect = "text";
            style.whiteSpace = "pre-wrap";
            style.wordBreak = "break-word";
            nextRootElement.setAttribute("data-lexical-editor", "true");
            this._window = windowObj;
            this._dirtyType = FULL_RECONCILE;
            initMutationObserver(this);
            this._updateTags.add("history-merge");
            $commitPendingUpdates(this);
            if (!this._config.disableEvents) {
              addRootElementEvents(nextRootElement, this);
            }
            if (classNames != null) {
              nextRootElement.classList.add(...classNames);
            }
          } else {
            this._editorState = pendingEditorState;
            this._pendingEditorState = null;
            this._window = null;
          }
          triggerListeners("root", this, false, nextRootElement, prevRootElement);
        }
      }
      /**
       * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
       * @returns the HTMLElement rendered by the LexicalNode associated with the key.
       * @param key - the key of the LexicalNode.
       */
      getElementByKey(key) {
        return this._keyToDOMMap.get(key) || null;
      }
      /**
       * Gets the active editor state.
       * @returns The editor state
       */
      getEditorState() {
        return this._editorState;
      }
      /**
       * Imperatively set the EditorState. Triggers reconciliation like an update.
       * @param editorState - the state to set the editor
       * @param options - options for the update.
       */
      setEditorState(editorState, options) {
        if (editorState.isEmpty()) {
          {
            throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
          }
        }
        $flushRootMutations(this);
        const pendingEditorState = this._pendingEditorState;
        const tags = this._updateTags;
        const tag = options !== void 0 ? options.tag : null;
        if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
          if (tag != null) {
            tags.add(tag);
          }
          $commitPendingUpdates(this);
        }
        this._pendingEditorState = editorState;
        this._dirtyType = FULL_RECONCILE;
        this._dirtyElements.set("root", false);
        this._compositionKey = null;
        if (tag != null) {
          tags.add(tag);
        }
        $commitPendingUpdates(this);
      }
      /**
       * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
       * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
       * deserliazation from JSON stored in a database uses this method.
       * @param maybeStringifiedEditorState
       * @param updateFn
       * @returns
       */
      parseEditorState(maybeStringifiedEditorState, updateFn) {
        const serializedEditorState = typeof maybeStringifiedEditorState === "string" ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
        return parseEditorState(serializedEditorState, this, updateFn);
      }
      /**
       * Executes an update to the editor state. The updateFn callback is the ONLY place
       * where Lexical editor state can be safely mutated.
       * @param updateFn - A function that has access to writable editor state.
       * @param options - A bag of options to control the behavior of the update.
       * @param options.onUpdate - A function to run once the update is complete.
       * Useful for synchronizing updates in some cases.
       * @param options.skipTransforms - Setting this to true will suppress all node
       * transforms for this update cycle.
       * @param options.tag - A tag to identify this update, in an update listener, for instance.
       * Some tags are reserved by the core and control update behavior in different ways.
       * @param options.discrete - If true, prevents this update from being batched, forcing it to
       * run synchronously.
       */
      update(updateFn, options) {
        updateEditor(this, updateFn, options);
      }
      /**
       * Focuses the editor
       * @param callbackFn - A function to run after the editor is focused.
       * @param options - A bag of options
       * @param options.defaultSelection - Where to move selection when the editor is
       * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
       */
      focus(callbackFn, options = {}) {
        const rootElement = this._rootElement;
        if (rootElement !== null) {
          rootElement.setAttribute("autocapitalize", "off");
          updateEditor(this, () => {
            const selection = $getSelection();
            const root = $getRoot();
            if (selection !== null) {
              selection.dirty = true;
            } else if (root.getChildrenSize() !== 0) {
              if (options.defaultSelection === "rootStart") {
                root.selectStart();
              } else {
                root.selectEnd();
              }
            }
          }, {
            onUpdate: () => {
              rootElement.removeAttribute("autocapitalize");
              if (callbackFn) {
                callbackFn();
              }
            },
            tag: "focus"
          });
          if (this._pendingEditorState === null) {
            rootElement.removeAttribute("autocapitalize");
          }
        }
      }
      /**
       * Removes focus from the editor.
       */
      blur() {
        const rootElement = this._rootElement;
        if (rootElement !== null) {
          rootElement.blur();
        }
        const domSelection = getDOMSelection(this._window);
        if (domSelection !== null) {
          domSelection.removeAllRanges();
        }
      }
      /**
       * Returns true if the editor is editable, false otherwise.
       * @returns True if the editor is editable, false otherwise.
       */
      isEditable() {
        return this._editable;
      }
      /**
       * Sets the editable property of the editor. When false, the
       * editor will not listen for user events on the underling contenteditable.
       * @param editable - the value to set the editable mode to.
       */
      setEditable(editable) {
        if (this._editable !== editable) {
          this._editable = editable;
          triggerListeners("editable", this, true, editable);
        }
      }
      /**
       * Returns a JSON-serializable javascript object NOT a JSON string.
       * You still must call JSON.stringify (or something else) to turn the
       * state into a string you can transfer over the wire and store in a database.
       *
       * See {@link LexicalNode.exportJSON}
       *
       * @returns A JSON-serializable javascript object
       */
      toJSON() {
        return {
          editorState: this._editorState.toJSON()
        };
      }
    };
  }
});

// ../../../node_modules/.pnpm/lexical@0.16.1/node_modules/lexical/Lexical.prod.mjs
var Lexical_prod_exports = {};
__export(Lexical_prod_exports, {
  $addUpdateTag: () => en,
  $applyNodeReplacement: () => an,
  $copyNode: () => cn,
  $createLineBreakNode: () => Lr,
  $createNodeSelection: () => Ss,
  $createParagraphNode: () => xi,
  $createPoint: () => is,
  $createRangeSelection: () => Cs,
  $createRangeSelectionFromDom: () => ks,
  $createTabNode: () => ns,
  $createTextNode: () => Zr,
  $getAdjacentNode: () => qe,
  $getCharacterOffsets: () => gs,
  $getEditor: () => Sn,
  $getNearestNodeFromDOMNode: () => Te2,
  $getNearestRootOrShadowRoot: () => on,
  $getNodeByKey: () => xe2,
  $getNodeByKeyOrThrow: () => fn,
  $getPreviousSelection: () => Ns,
  $getRoot: () => ke3,
  $getSelection: () => ws,
  $getTextContent: () => Ls,
  $hasAncestor: () => nn,
  $hasUpdateTag: () => tn,
  $insertNodes: () => Is,
  $isBlockElementNode: () => vs,
  $isDecoratorNode: () => ui,
  $isElementNode: () => li,
  $isInlineElementOrDecoratorNode: () => sn,
  $isLeafNode: () => he,
  $isLineBreakNode: () => Ar,
  $isNodeSelection: () => ds,
  $isParagraphNode: () => vi,
  $isRangeSelection: () => us,
  $isRootNode: () => di,
  $isRootOrShadowRoot: () => ln,
  $isTabNode: () => rs,
  $isTextNode: () => Gr,
  $nodesOfType: () => He,
  $normalizeSelection__EXPERIMENTAL: () => ee,
  $parseSerializedNode: () => Ys,
  $selectAll: () => Ue,
  $setCompositionKey: () => ye,
  $setSelection: () => we,
  $splitNode: () => pn,
  ArtificialNode__DO_NOT_USE: () => pi,
  BLUR_COMMAND: () => V2,
  CAN_REDO_COMMAND: () => K2,
  CAN_UNDO_COMMAND: () => J,
  CLEAR_EDITOR_COMMAND: () => B2,
  CLEAR_HISTORY_COMMAND: () => R2,
  CLICK_COMMAND: () => r5,
  COMMAND_PRIORITY_CRITICAL: () => bi,
  COMMAND_PRIORITY_EDITOR: () => Ti,
  COMMAND_PRIORITY_HIGH: () => ki,
  COMMAND_PRIORITY_LOW: () => Ci,
  COMMAND_PRIORITY_NORMAL: () => Si,
  CONTROLLED_TEXT_INSERTION_COMMAND: () => l2,
  COPY_COMMAND: () => M2,
  CUT_COMMAND: () => z2,
  DELETE_CHARACTER_COMMAND: () => s2,
  DELETE_LINE_COMMAND: () => f4,
  DELETE_WORD_COMMAND: () => u2,
  DRAGEND_COMMAND: () => A,
  DRAGOVER_COMMAND: () => L,
  DRAGSTART_COMMAND: () => I2,
  DROP_COMMAND: () => F2,
  DecoratorNode: () => ai,
  ElementNode: () => oi,
  FOCUS_COMMAND: () => U2,
  FORMAT_ELEMENT_COMMAND: () => O2,
  FORMAT_TEXT_COMMAND: () => d2,
  INDENT_CONTENT_COMMAND: () => P2,
  INSERT_LINE_BREAK_COMMAND: () => i3,
  INSERT_PARAGRAPH_COMMAND: () => o4,
  INSERT_TAB_COMMAND: () => E2,
  IS_ALL_FORMATTING: () => xt,
  IS_BOLD: () => ft,
  IS_CODE: () => _t2,
  IS_HIGHLIGHT: () => mt2,
  IS_ITALIC: () => dt2,
  IS_STRIKETHROUGH: () => ht2,
  IS_SUBSCRIPT: () => pt,
  IS_SUPERSCRIPT: () => yt2,
  IS_UNDERLINE: () => gt2,
  KEY_ARROW_DOWN_COMMAND: () => T2,
  KEY_ARROW_LEFT_COMMAND: () => m3,
  KEY_ARROW_RIGHT_COMMAND: () => p2,
  KEY_ARROW_UP_COMMAND: () => v3,
  KEY_BACKSPACE_COMMAND: () => k2,
  KEY_DELETE_COMMAND: () => w2,
  KEY_DOWN_COMMAND: () => _2,
  KEY_ENTER_COMMAND: () => C,
  KEY_ESCAPE_COMMAND: () => b2,
  KEY_MODIFIER_COMMAND: () => $2,
  KEY_SPACE_COMMAND: () => S3,
  KEY_TAB_COMMAND: () => N2,
  LineBreakNode: () => Or,
  MOVE_TO_END: () => y2,
  MOVE_TO_START: () => x2,
  OUTDENT_CONTENT_COMMAND: () => D2,
  PASTE_COMMAND: () => c4,
  ParagraphNode: () => yi,
  REDO_COMMAND: () => g3,
  REMOVE_TEXT_COMMAND: () => a2,
  RootNode: () => fi,
  SELECTION_CHANGE_COMMAND: () => e5,
  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => n5,
  SELECT_ALL_COMMAND: () => W,
  TEXT_TYPE_TO_FORMAT: () => It,
  TabNode: () => es,
  TextNode: () => Ur,
  UNDO_COMMAND: () => h4,
  createCommand: () => t4,
  createEditor: () => Ni,
  getNearestEditorFromDOMNode: () => ce,
  isBlockDomNode: () => vn,
  isCurrentlyReadOnlyMode: () => Us,
  isHTMLAnchorElement: () => yn,
  isHTMLElement: () => mn,
  isInlineDomNode: () => xn,
  isSelectionCapturedInDecoratorInput: () => oe,
  isSelectionWithinEditor: () => le,
  resetRandomKey: () => se
});
function t4(t5) {
  return {};
}
function Bt(t5) {
  return t5 && t5.__esModule && Object.prototype.hasOwnProperty.call(t5, "default") ? t5.default : t5;
}
function Kt2(...t5) {
  const e6 = [];
  for (const n6 of t5)
    if (n6 && "string" == typeof n6)
      for (const [t6] of n6.matchAll(/\S+/g))
        e6.push(t6);
  return e6;
}
function $t2(t5) {
  Vt = t5.timeStamp;
}
function Ht(t5, e6, n6) {
  return e6.__lexicalLineBreak === t5 || void 0 !== t5[`__lexicalKey_${n6._key}`];
}
function jt(t5, e6, n6) {
  const r6 = _n(n6._window);
  let s3 = null, i4 = null;
  null !== r6 && r6.anchorNode === t5 && (s3 = r6.anchorOffset, i4 = r6.focusOffset);
  const o5 = t5.nodeValue;
  null !== o5 && Le(e6, o5, s3, i4, false);
}
function qt2(t5, e6, n6) {
  if (us(t5)) {
    const e7 = t5.anchor.getNode();
    if (e7.is(n6) && t5.format !== e7.getFormat())
      return false;
  }
  return e6.nodeType === st2 && n6.isAttached();
}
function Qt(t5, e6, n6) {
  Ut = true;
  const r6 = performance.now() - Vt > Jt;
  try {
    ii2(t5, () => {
      const s3 = ws() || function(t6) {
        return t6.getEditorState().read(() => {
          const t7 = ws();
          return null !== t7 ? t7.clone() : null;
        });
      }(t5), i4 = /* @__PURE__ */ new Map(), o5 = t5.getRootElement(), l3 = t5._editorState, c5 = t5._blockCursorElement;
      let a3 = false, u3 = "";
      for (let n7 = 0; n7 < e6.length; n7++) {
        const f6 = e6[n7], d4 = f6.type, h7 = f6.target;
        let g6 = Te2(h7, l3);
        if (!(null === g6 && h7 !== o5 || ui(g6))) {
          if ("characterData" === d4)
            r6 && Gr(g6) && qt2(s3, h7, g6) && jt(h7, g6, t5);
          else if ("childList" === d4) {
            a3 = true;
            const e7 = f6.addedNodes;
            for (let n9 = 0; n9 < e7.length; n9++) {
              const r8 = e7[n9], s4 = ve(r8), i5 = r8.parentNode;
              if (null != i5 && r8 !== c5 && null === s4 && ("BR" !== r8.nodeName || !Ht(r8, i5, t5))) {
                if (Q2) {
                  const t6 = r8.innerText || r8.nodeValue;
                  t6 && (u3 += t6);
                }
                i5.removeChild(r8);
              }
            }
            const n8 = f6.removedNodes, r7 = n8.length;
            if (r7 > 0) {
              let e8 = 0;
              for (let s4 = 0; s4 < r7; s4++) {
                const r8 = n8[s4];
                ("BR" === r8.nodeName && Ht(r8, h7, t5) || c5 === r8) && (h7.appendChild(r8), e8++);
              }
              r7 !== e8 && (h7 === o5 && (g6 = be(l3)), i4.set(h7, g6));
            }
          }
        }
      }
      if (i4.size > 0)
        for (const [e7, n7] of i4)
          if (li(n7)) {
            const r7 = n7.getChildrenKeys();
            let s4 = e7.firstChild;
            for (let n8 = 0; n8 < r7.length; n8++) {
              const i5 = r7[n8], o6 = t5.getElementByKey(i5);
              null !== o6 && (null == s4 ? (e7.appendChild(o6), s4 = o6) : s4 !== o6 && e7.replaceChild(o6, s4), s4 = s4.nextSibling);
            }
          } else
            Gr(n7) && n7.markDirty();
      const f5 = n6.takeRecords();
      if (f5.length > 0) {
        for (let e7 = 0; e7 < f5.length; e7++) {
          const n7 = f5[e7], r7 = n7.addedNodes, s4 = n7.target;
          for (let e8 = 0; e8 < r7.length; e8++) {
            const n8 = r7[e8], i5 = n8.parentNode;
            null == i5 || "BR" !== n8.nodeName || Ht(n8, s4, t5) || i5.removeChild(n8);
          }
        }
        n6.takeRecords();
      }
      null !== s3 && (a3 && (s3.dirty = true, we(s3)), Q2 && Qe(t5) && s3.insertRawText(u3));
    });
  } finally {
    Ut = false;
  }
}
function Xt(t5) {
  const e6 = t5._observer;
  if (null !== e6) {
    Qt(t5, e6.takeRecords(), e6);
  }
}
function Yt(t5) {
  !function(t6) {
    0 === Vt && rn(t6).addEventListener("textInput", $t2, true);
  }(t5), t5._observer = new MutationObserver((e6, n6) => {
    Qt(t5, e6, n6);
  });
}
function Zt2(t5, e6) {
  const n6 = t5.__mode, r6 = t5.__format, s3 = t5.__style, i4 = e6.__mode, o5 = e6.__format, l3 = e6.__style;
  return !(null !== n6 && n6 !== i4 || null !== r6 && r6 !== o5 || null !== s3 && s3 !== l3);
}
function Gt(t5, e6) {
  const n6 = t5.mergeWithSibling(e6), r6 = js()._normalizedNodes;
  return r6.add(t5.__key), r6.add(e6.__key), n6;
}
function te(t5) {
  let e6, n6, r6 = t5;
  if ("" !== r6.__text || !r6.isSimpleText() || r6.isUnmergeable()) {
    for (; null !== (e6 = r6.getPreviousSibling()) && Gr(e6) && e6.isSimpleText() && !e6.isUnmergeable(); ) {
      if ("" !== e6.__text) {
        if (Zt2(e6, r6)) {
          r6 = Gt(e6, r6);
          break;
        }
        break;
      }
      e6.remove();
    }
    for (; null !== (n6 = r6.getNextSibling()) && Gr(n6) && n6.isSimpleText() && !n6.isUnmergeable(); ) {
      if ("" !== n6.__text) {
        if (Zt2(r6, n6)) {
          r6 = Gt(r6, n6);
          break;
        }
        break;
      }
      n6.remove();
    }
  } else
    r6.remove();
}
function ee(t5) {
  return ne(t5.anchor), ne(t5.focus), t5;
}
function ne(t5) {
  for (; "element" === t5.type; ) {
    const e6 = t5.getNode(), n6 = t5.offset;
    let r6, s3;
    if (n6 === e6.getChildrenSize() ? (r6 = e6.getChildAtIndex(n6 - 1), s3 = true) : (r6 = e6.getChildAtIndex(n6), s3 = false), Gr(r6)) {
      t5.set(r6.__key, s3 ? r6.getTextContentSize() : 0, "text");
      break;
    }
    if (!li(r6))
      break;
    t5.set(r6.__key, s3 ? r6.getChildrenSize() : 0, "element");
  }
}
function se() {
  re = 1;
}
function oe(t5) {
  const e6 = document.activeElement;
  if (null === e6)
    return false;
  const n6 = e6.nodeName;
  return ui(Te2(t5)) && ("INPUT" === n6 || "TEXTAREA" === n6 || "true" === e6.contentEditable && null == e6.__lexicalEditor);
}
function le(t5, e6, n6) {
  const r6 = t5.getRootElement();
  try {
    return null !== r6 && r6.contains(e6) && r6.contains(n6) && null !== e6 && !oe(e6) && ce(e6) === t5;
  } catch (t6) {
    return false;
  }
}
function ce(t5) {
  let e6 = t5;
  for (; null != e6; ) {
    const t6 = e6.__lexicalEditor;
    if (null != t6)
      return t6;
    e6 = Ge(e6);
  }
  return null;
}
function ae(t5) {
  return t5.isToken() || t5.isSegmented();
}
function ue(t5) {
  return t5.nodeType === st2;
}
function fe(t5) {
  let e6 = t5;
  for (; null != e6; ) {
    if (ue(e6))
      return e6;
    e6 = e6.firstChild;
  }
  return null;
}
function de(t5, e6, n6) {
  const r6 = It[e6];
  if (null !== n6 && (t5 & r6) == (n6 & r6))
    return t5;
  let s3 = t5 ^ r6;
  return "subscript" === e6 ? s3 &= ~It.superscript : "superscript" === e6 && (s3 &= ~It.subscript), s3;
}
function he(t5) {
  return Gr(t5) || Ar(t5) || ui(t5);
}
function ge(t5, e6) {
  if (null != e6)
    return void (t5.__key = e6);
  Vs(), $s();
  const n6 = js(), r6 = Hs(), s3 = "" + re++;
  r6._nodeMap.set(s3, t5), li(t5) ? n6._dirtyElements.set(s3, true) : n6._dirtyLeaves.add(s3), n6._cloneNotNeeded.add(s3), n6._dirtyType = ot, t5.__key = s3;
}
function _e(t5) {
  const e6 = t5.getParent();
  if (null !== e6) {
    const n6 = t5.getWritable(), r6 = e6.getWritable(), s3 = t5.getPreviousSibling(), i4 = t5.getNextSibling();
    if (null === s3)
      if (null !== i4) {
        const t6 = i4.getWritable();
        r6.__first = i4.__key, t6.__prev = null;
      } else
        r6.__first = null;
    else {
      const t6 = s3.getWritable();
      if (null !== i4) {
        const e7 = i4.getWritable();
        e7.__prev = t6.__key, t6.__next = e7.__key;
      } else
        t6.__next = null;
      n6.__prev = null;
    }
    if (null === i4)
      if (null !== s3) {
        const t6 = s3.getWritable();
        r6.__last = s3.__key, t6.__next = null;
      } else
        r6.__last = null;
    else {
      const t6 = i4.getWritable();
      if (null !== s3) {
        const e7 = s3.getWritable();
        e7.__next = t6.__key, t6.__prev = e7.__key;
      } else
        t6.__prev = null;
      n6.__next = null;
    }
    r6.__size--, n6.__parent = null;
  }
}
function pe(t5) {
  $s();
  const e6 = t5.getLatest(), n6 = e6.__parent, r6 = Hs(), s3 = js(), i4 = r6._nodeMap, o5 = s3._dirtyElements;
  null !== n6 && function(t6, e7, n7) {
    let r7 = t6;
    for (; null !== r7; ) {
      if (n7.has(r7))
        return;
      const t7 = e7.get(r7);
      if (void 0 === t7)
        break;
      n7.set(r7, false), r7 = t7.__parent;
    }
  }(n6, i4, o5);
  const l3 = e6.__key;
  s3._dirtyType = ot, li(t5) ? o5.set(l3, true) : s3._dirtyLeaves.add(l3);
}
function ye(t5) {
  Vs();
  const e6 = js(), n6 = e6._compositionKey;
  if (t5 !== n6) {
    if (e6._compositionKey = t5, null !== n6) {
      const t6 = xe2(n6);
      null !== t6 && t6.getWritable();
    }
    if (null !== t5) {
      const e7 = xe2(t5);
      null !== e7 && e7.getWritable();
    }
  }
}
function me() {
  if (Us())
    return null;
  return js()._compositionKey;
}
function xe2(t5, e6) {
  const n6 = (e6 || Hs())._nodeMap.get(t5);
  return void 0 === n6 ? null : n6;
}
function ve(t5, e6) {
  const n6 = t5[`__lexicalKey_${js()._key}`];
  return void 0 !== n6 ? xe2(n6, e6) : null;
}
function Te2(t5, e6) {
  let n6 = t5;
  for (; null != n6; ) {
    const t6 = ve(n6, e6);
    if (null !== t6)
      return t6;
    n6 = Ge(n6);
  }
  return null;
}
function Ce(t5) {
  const e6 = t5._decorators, n6 = Object.assign({}, e6);
  return t5._pendingDecorators = n6, n6;
}
function Se3(t5) {
  return t5.read(() => ke3().getTextContent());
}
function ke3() {
  return be(Hs());
}
function be(t5) {
  return t5._nodeMap.get("root");
}
function we(t5) {
  Vs();
  const e6 = Hs();
  null !== t5 && (t5.dirty = true, t5.setCachedNodes(null)), e6._selection = t5;
}
function Ne(t5) {
  const e6 = js(), n6 = function(t6, e7) {
    let n7 = t6;
    for (; null != n7; ) {
      const t7 = n7[`__lexicalKey_${e7._key}`];
      if (void 0 !== t7)
        return t7;
      n7 = Ge(n7);
    }
    return null;
  }(t5, e6);
  if (null === n6) {
    return t5 === e6.getRootElement() ? xe2("root") : null;
  }
  return xe2(n6);
}
function Ee2(t5, e6) {
  return e6 ? t5.getTextContentSize() : 0;
}
function Pe(t5) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(t5);
}
function De(t5) {
  const e6 = [];
  let n6 = t5;
  for (; null !== n6; )
    e6.push(n6), n6 = n6._parentEditor;
  return e6;
}
function Fe() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function Oe3(t5) {
  return t5.nodeType === st2 ? t5.nodeValue : null;
}
function Ie(t5, e6, n6) {
  const r6 = _n(e6._window);
  if (null === r6)
    return;
  const s3 = r6.anchorNode;
  let { anchorOffset: i4, focusOffset: o5 } = r6;
  if (null !== s3) {
    let e7 = Oe3(s3);
    const r7 = Te2(s3);
    if (null !== e7 && Gr(r7)) {
      if (e7 === wt2 && n6) {
        const t6 = n6.length;
        e7 = n6, i4 = t6, o5 = t6;
      }
      null !== e7 && Le(r7, e7, i4, o5, t5);
    }
  }
}
function Le(t5, e6, n6, r6, s3) {
  let i4 = t5;
  if (i4.isAttached() && (s3 || !i4.isDirty())) {
    const o5 = i4.isComposing();
    let l3 = e6;
    (o5 || s3) && e6[e6.length - 1] === wt2 && (l3 = e6.slice(0, -1));
    const c5 = i4.getTextContent();
    if (s3 || l3 !== c5) {
      if ("" === l3) {
        if (ye(null), Y2 || Z2 || nt2)
          i4.remove();
        else {
          const t6 = js();
          setTimeout(() => {
            t6.update(() => {
              i4.isAttached() && i4.remove();
            });
          }, 20);
        }
        return;
      }
      const e7 = i4.getParent(), s4 = Ns(), c6 = i4.getTextContentSize(), a3 = me(), u3 = i4.getKey();
      if (i4.isToken() || null !== a3 && u3 === a3 && !o5 || us(s4) && (null !== e7 && !e7.canInsertTextBefore() && 0 === s4.anchor.offset || s4.anchor.key === t5.__key && 0 === s4.anchor.offset && !i4.canInsertTextBefore() && !o5 || s4.focus.key === t5.__key && s4.focus.offset === c6 && !i4.canInsertTextAfter() && !o5))
        return void i4.markDirty();
      const f5 = ws();
      if (!us(f5) || null === n6 || null === r6)
        return void i4.setTextContent(l3);
      if (f5.setTextNodeRange(i4, n6, i4, r6), i4.isSegmented()) {
        const t6 = Zr(i4.getTextContent());
        i4.replace(t6), i4 = t6;
      }
      i4.setTextContent(l3);
    }
  }
}
function Ae(t5, e6) {
  if (e6.isSegmented())
    return true;
  if (!t5.isCollapsed())
    return false;
  const n6 = t5.anchor.offset, r6 = e6.getParentOrThrow(), s3 = e6.isToken();
  return 0 === n6 ? !e6.canInsertTextBefore() || !r6.canInsertTextBefore() && !e6.isComposing() || s3 || function(t6) {
    const e7 = t6.getPreviousSibling();
    return (Gr(e7) || li(e7) && e7.isInline()) && !e7.canInsertTextAfter();
  }(e6) : n6 === e6.getTextContentSize() && (!e6.canInsertTextAfter() || !r6.canInsertTextAfter() && !e6.isComposing() || s3);
}
function Me(t5) {
  return "ArrowLeft" === t5;
}
function ze(t5) {
  return "ArrowRight" === t5;
}
function We(t5, e6) {
  return q2 ? t5 : e6;
}
function Be(t5) {
  return "Enter" === t5;
}
function Re2(t5) {
  return "Backspace" === t5;
}
function Ke(t5) {
  return "Delete" === t5;
}
function Je(t5, e6, n6) {
  return "a" === t5.toLowerCase() && We(e6, n6);
}
function Ue() {
  const t5 = ke3();
  we(ee(t5.select(0, t5.getChildrenSize())));
}
function Ve(t5, e6) {
  void 0 === t5.__lexicalClassNameCache && (t5.__lexicalClassNameCache = {});
  const n6 = t5.__lexicalClassNameCache, r6 = n6[e6];
  if (void 0 !== r6)
    return r6;
  const s3 = t5[e6];
  if ("string" == typeof s3) {
    const t6 = Kt2(s3);
    return n6[e6] = t6, t6;
  }
  return s3;
}
function $e2(t5, e6, n6, r6, s3) {
  if (0 === n6.size)
    return;
  const i4 = r6.__type, o5 = r6.__key, l3 = e6.get(i4);
  void 0 === l3 && Rt2(33, i4);
  const c5 = l3.klass;
  let a3 = t5.get(c5);
  void 0 === a3 && (a3 = /* @__PURE__ */ new Map(), t5.set(c5, a3));
  const u3 = a3.get(o5), f5 = "destroyed" === u3 && "created" === s3;
  (void 0 === u3 || f5) && a3.set(o5, f5 ? "updated" : s3);
}
function He(t5) {
  const e6 = Hs(), n6 = e6._readOnly, r6 = t5.getType(), s3 = e6._nodeMap, i4 = [];
  for (const [, e7] of s3)
    e7 instanceof t5 && e7.__type === r6 && (n6 || e7.isAttached()) && i4.push(e7);
  return i4;
}
function je(t5, e6, n6) {
  const r6 = t5.getParent();
  let s3 = n6, i4 = t5;
  return null !== r6 && (e6 && 0 === n6 ? (s3 = i4.getIndexWithinParent(), i4 = r6) : e6 || n6 !== i4.getChildrenSize() || (s3 = i4.getIndexWithinParent() + 1, i4 = r6)), i4.getChildAtIndex(e6 ? s3 - 1 : s3);
}
function qe(t5, e6) {
  const n6 = t5.offset;
  if ("element" === t5.type) {
    return je(t5.getNode(), e6, n6);
  }
  {
    const r6 = t5.getNode();
    if (e6 && 0 === n6 || !e6 && n6 === r6.getTextContentSize()) {
      const t6 = e6 ? r6.getPreviousSibling() : r6.getNextSibling();
      return null === t6 ? je(r6.getParentOrThrow(), e6, r6.getIndexWithinParent() + (e6 ? 0 : 1)) : t6;
    }
  }
  return null;
}
function Qe(t5) {
  const e6 = rn(t5).event, n6 = e6 && e6.inputType;
  return "insertFromPaste" === n6 || "insertFromPasteAsQuotation" === n6;
}
function Xe(t5, e6, n6) {
  return ni(t5, e6, n6);
}
function Ye(t5) {
  return !di(t5) && !t5.isLastChild() && !t5.isInline();
}
function Ze(t5, e6) {
  const n6 = t5._keyToDOMMap.get(e6);
  return void 0 === n6 && Rt2(75, e6), n6;
}
function Ge(t5) {
  const e6 = t5.assignedSlot || t5.parentElement;
  return null !== e6 && 11 === e6.nodeType ? e6.host : e6;
}
function tn(t5) {
  return js()._updateTags.has(t5);
}
function en(t5) {
  Vs();
  js()._updateTags.add(t5);
}
function nn(t5, e6) {
  let n6 = t5.getParent();
  for (; null !== n6; ) {
    if (n6.is(e6))
      return true;
    n6 = n6.getParent();
  }
  return false;
}
function rn(t5) {
  const e6 = t5._window;
  return null === e6 && Rt2(78), e6;
}
function sn(t5) {
  return li(t5) && t5.isInline() || ui(t5) && t5.isInline();
}
function on(t5) {
  let e6 = t5.getParentOrThrow();
  for (; null !== e6; ) {
    if (ln(e6))
      return e6;
    e6 = e6.getParentOrThrow();
  }
  return e6;
}
function ln(t5) {
  return di(t5) || li(t5) && t5.isShadowRoot();
}
function cn(t5) {
  const e6 = t5.constructor.clone(t5);
  return ge(e6, null), e6;
}
function an(t5) {
  const e6 = js(), n6 = t5.constructor.getType(), r6 = e6._nodes.get(n6);
  void 0 === r6 && Rt2(97);
  const s3 = r6.replace;
  if (null !== s3) {
    const e7 = s3(t5);
    return e7 instanceof t5.constructor || Rt2(98), e7;
  }
  return t5;
}
function un(t5, e6) {
  !di(t5.getParent()) || li(e6) || ui(e6) || Rt2(99);
}
function fn(t5) {
  const e6 = xe2(t5);
  return null === e6 && Rt2(63, t5), e6;
}
function dn(t5) {
  return (ui(t5) || li(t5) && !t5.canBeEmpty()) && !t5.isInline();
}
function hn(t5, e6, n6) {
  n6.style.removeProperty("caret-color"), e6._blockCursorElement = null;
  const r6 = t5.parentElement;
  null !== r6 && r6.removeChild(t5);
}
function gn(t5, e6, n6) {
  let r6 = t5._blockCursorElement;
  if (us(n6) && n6.isCollapsed() && "element" === n6.anchor.type && e6.contains(document.activeElement)) {
    const s3 = n6.anchor, i4 = s3.getNode(), o5 = s3.offset;
    let l3 = false, c5 = null;
    if (o5 === i4.getChildrenSize()) {
      dn(i4.getChildAtIndex(o5 - 1)) && (l3 = true);
    } else {
      const e7 = i4.getChildAtIndex(o5);
      if (dn(e7)) {
        const n7 = e7.getPreviousSibling();
        (null === n7 || dn(n7)) && (l3 = true, c5 = t5.getElementByKey(e7.__key));
      }
    }
    if (l3) {
      const n7 = t5.getElementByKey(i4.__key);
      return null === r6 && (t5._blockCursorElement = r6 = function(t6) {
        const e7 = t6.theme, n8 = document.createElement("div");
        n8.contentEditable = "false", n8.setAttribute("data-lexical-cursor", "true");
        let r7 = e7.blockCursor;
        if (void 0 !== r7) {
          if ("string" == typeof r7) {
            const t7 = Kt2(r7);
            r7 = e7.blockCursor = t7;
          }
          void 0 !== r7 && n8.classList.add(...r7);
        }
        return n8;
      }(t5._config)), e6.style.caretColor = "transparent", void (null === c5 ? n7.appendChild(r6) : n7.insertBefore(r6, c5));
    }
  }
  null !== r6 && hn(r6, t5, e6);
}
function _n(t5) {
  return H ? (t5 || window).getSelection() : null;
}
function pn(t5, e6) {
  let n6 = t5.getChildAtIndex(e6);
  null == n6 && (n6 = t5), ln(t5) && Rt2(102);
  const r6 = (t6) => {
    const e7 = t6.getParentOrThrow(), s4 = ln(e7), i5 = t6 !== n6 || s4 ? cn(t6) : t6;
    if (s4)
      return li(t6) && li(i5) || Rt2(133), t6.insertAfter(i5), [t6, i5, i5];
    {
      const [n7, s5, o5] = r6(e7), l3 = t6.getNextSiblings();
      return o5.append(i5, ...l3), [n7, s5, i5];
    }
  }, [s3, i4] = r6(n6);
  return [s3, i4];
}
function yn(t5) {
  return mn(t5) && "A" === t5.tagName;
}
function mn(t5) {
  return 1 === t5.nodeType;
}
function xn(t5) {
  const e6 = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return null !== t5.nodeName.match(e6);
}
function vn(t5) {
  const e6 = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return null !== t5.nodeName.match(e6);
}
function Tn(t5) {
  if (di(t5) || ui(t5) && !t5.isInline())
    return true;
  if (!li(t5) || ln(t5))
    return false;
  const e6 = t5.getFirstChild(), n6 = null === e6 || Ar(e6) || Gr(e6) || e6.isInline();
  return !t5.isInline() && false !== t5.canBeEmpty() && n6;
}
function Cn(t5, e6) {
  let n6 = t5;
  for (; null !== n6 && null !== n6.getParent() && !e6(n6); )
    n6 = n6.getParentOrThrow();
  return e6(n6) ? n6 : null;
}
function Sn() {
  return js();
}
function kn(t5, e6, n6, r6, s3, i4) {
  let o5 = t5.getFirstChild();
  for (; null !== o5; ) {
    const t6 = o5.__key;
    o5.__parent === e6 && (li(o5) && kn(o5, t6, n6, r6, s3, i4), n6.has(t6) || i4.delete(t6), s3.push(t6)), o5 = o5.getNextSibling();
  }
}
function Jn(t5, e6) {
  const n6 = Fn.get(t5);
  if (null !== e6) {
    const n7 = ir(t5);
    n7.parentNode === e6 && e6.removeChild(n7);
  }
  if (On.has(t5) || wn._keyToDOMMap.delete(t5), li(n6)) {
    const t6 = tr(n6, Fn);
    Un(t6, 0, t6.length - 1, null);
  }
  void 0 !== n6 && $e2(Ln, Nn, En, n6, "destroyed");
}
function Un(t5, e6, n6, r6) {
  let s3 = e6;
  for (; s3 <= n6; ++s3) {
    const e7 = t5[s3];
    void 0 !== e7 && Jn(e7, r6);
  }
}
function Vn(t5, e6) {
  t5.setProperty("text-align", e6);
}
function Hn(t5, e6) {
  const n6 = bn.theme.indent;
  if ("string" == typeof n6) {
    const r7 = t5.classList.contains(n6);
    e6 > 0 && !r7 ? t5.classList.add(n6) : e6 < 1 && r7 && t5.classList.remove(n6);
  }
  const r6 = getComputedStyle(t5).getPropertyValue("--lexical-indent-base-value") || $n;
  t5.style.setProperty("padding-inline-start", 0 === e6 ? "" : `calc(${e6} * ${r6})`);
}
function jn(t5, e6) {
  const n6 = t5.style;
  0 === e6 ? Vn(n6, "") : e6 === vt ? Vn(n6, "left") : e6 === Tt ? Vn(n6, "center") : e6 === Ct ? Vn(n6, "right") : e6 === St ? Vn(n6, "justify") : e6 === kt ? Vn(n6, "start") : e6 === bt2 && Vn(n6, "end");
}
function qn(t5, e6, n6) {
  const r6 = On.get(t5);
  void 0 === r6 && Rt2(60);
  const s3 = r6.createDOM(bn, wn);
  if (function(t6, e7, n7) {
    const r7 = n7._keyToDOMMap;
    e7["__lexicalKey_" + n7._key] = t6, r7.set(t6, e7);
  }(t5, s3, wn), Gr(r6) ? s3.setAttribute("data-lexical-text", "true") : ui(r6) && s3.setAttribute("data-lexical-decorator", "true"), li(r6)) {
    const t6 = r6.__indent, e7 = r6.__size;
    if (0 !== t6 && Hn(s3, t6), 0 !== e7) {
      const t7 = e7 - 1;
      !function(t8, e8, n8, r7) {
        const s4 = Mn;
        Mn = "", Qn(t8, n8, 0, e8, r7, null), Zn(n8, r7), Mn = s4;
      }(tr(r6, On), t7, r6, s3);
    }
    const n7 = r6.__format;
    0 !== n7 && jn(s3, n7), r6.isInline() || Yn(null, r6, s3), Ye(r6) && (An += Nt, Wn += Nt);
  } else {
    const e7 = r6.getTextContent();
    if (ui(r6)) {
      const e8 = r6.decorate(wn, bn);
      null !== e8 && nr(t5, e8), s3.contentEditable = "false";
    } else
      Gr(r6) && (r6.isDirectionless() || (Mn += e7));
    An += e7, Wn += e7;
  }
  if (null !== e6)
    if (null != n6)
      e6.insertBefore(s3, n6);
    else {
      const t6 = e6.__lexicalLineBreak;
      null != t6 ? e6.insertBefore(s3, t6) : e6.appendChild(s3);
    }
  return $e2(Ln, Nn, En, r6, "created"), s3;
}
function Qn(t5, e6, n6, r6, s3, i4) {
  const o5 = An;
  An = "";
  let l3 = n6;
  for (; l3 <= r6; ++l3) {
    qn(t5[l3], s3, i4);
    const e7 = On.get(t5[l3]);
    null !== e7 && null === zn && Gr(e7) && (zn = e7.getFormat());
  }
  Ye(e6) && (An += Nt), s3.__lexicalTextContent = An, An = o5 + An;
}
function Xn(t5, e6) {
  const n6 = e6.get(t5);
  return Ar(n6) || ui(n6) && n6.isInline();
}
function Yn(t5, e6, n6) {
  const r6 = null !== t5 && (0 === t5.__size || Xn(t5.__last, Fn)), s3 = 0 === e6.__size || Xn(e6.__last, On);
  if (r6) {
    if (!s3) {
      const t6 = n6.__lexicalLineBreak;
      null != t6 && n6.removeChild(t6), n6.__lexicalLineBreak = null;
    }
  } else if (s3) {
    const t6 = document.createElement("br");
    n6.__lexicalLineBreak = t6, n6.appendChild(t6);
  }
}
function Zn(t5, e6) {
  const n6 = e6.__lexicalDirTextContent, r6 = e6.__lexicalDir;
  if (n6 !== Mn || r6 !== Kn) {
    const n7 = "" === Mn, i4 = n7 ? Kn : (s3 = Mn, Ft2.test(s3) ? "rtl" : Ot.test(s3) ? "ltr" : null);
    if (i4 !== r6) {
      const s4 = e6.classList, o5 = bn.theme;
      let l3 = null !== r6 ? o5[r6] : void 0, c5 = null !== i4 ? o5[i4] : void 0;
      if (void 0 !== l3) {
        if ("string" == typeof l3) {
          const t6 = Kt2(l3);
          l3 = o5[r6] = t6;
        }
        s4.remove(...l3);
      }
      if (null === i4 || n7 && "ltr" === i4)
        e6.removeAttribute("dir");
      else {
        if (void 0 !== c5) {
          if ("string" == typeof c5) {
            const t6 = Kt2(c5);
            c5 = o5[i4] = t6;
          }
          void 0 !== c5 && s4.add(...c5);
        }
        e6.dir = i4;
      }
      if (!Rn) {
        t5.getWritable().__dir = i4;
      }
    }
    Kn = i4, e6.__lexicalDirTextContent = Mn, e6.__lexicalDir = i4;
  }
  var s3;
}
function Gn(t5, e6, n6) {
  const r6 = Mn;
  var s3;
  Mn = "", zn = null, function(t6, e7, n7) {
    const r7 = An, s4 = t6.__size, i4 = e7.__size;
    if (An = "", 1 === s4 && 1 === i4) {
      const r8 = t6.__first, s5 = e7.__first;
      if (r8 === s5)
        er2(r8, n7);
      else {
        const t7 = ir(r8), e8 = qn(s5, null, null);
        n7.replaceChild(e8, t7), Jn(r8, null);
      }
      const i5 = On.get(s5);
      null === zn && Gr(i5) && (zn = i5.getFormat());
    } else {
      const r8 = tr(t6, Fn), o5 = tr(e7, On);
      if (0 === s4)
        0 !== i4 && Qn(o5, e7, 0, i4 - 1, n7, null);
      else if (0 === i4) {
        if (0 !== s4) {
          const t7 = null == n7.__lexicalLineBreak;
          Un(r8, 0, s4 - 1, t7 ? null : n7), t7 && (n7.textContent = "");
        }
      } else
        !function(t7, e8, n8, r9, s5, i5) {
          const o6 = r9 - 1, l3 = s5 - 1;
          let c5, a3, u3 = (h7 = i5, h7.firstChild), f5 = 0, d4 = 0;
          var h7;
          for (; f5 <= o6 && d4 <= l3; ) {
            const t8 = e8[f5], r10 = n8[d4];
            if (t8 === r10)
              u3 = rr(er2(r10, i5)), f5++, d4++;
            else {
              void 0 === c5 && (c5 = new Set(e8)), void 0 === a3 && (a3 = new Set(n8));
              const s7 = a3.has(t8), o7 = c5.has(r10);
              if (s7)
                if (o7) {
                  const t9 = Ze(wn, r10);
                  t9 === u3 ? u3 = rr(er2(r10, i5)) : (null != u3 ? i5.insertBefore(t9, u3) : i5.appendChild(t9), er2(r10, i5)), f5++, d4++;
                } else
                  qn(r10, i5, u3), d4++;
              else
                u3 = rr(ir(t8)), Jn(t8, i5), f5++;
            }
            const s6 = On.get(r10);
            null !== s6 && null === zn && Gr(s6) && (zn = s6.getFormat());
          }
          const g6 = f5 > o6, _5 = d4 > l3;
          if (g6 && !_5) {
            const e9 = n8[l3 + 1];
            Qn(n8, t7, d4, l3, i5, void 0 === e9 ? null : wn.getElementByKey(e9));
          } else
            _5 && !g6 && Un(e8, f5, o6, i5);
        }(e7, r8, o5, s4, i4, n7);
    }
    Ye(e7) && (An += Nt);
    n7.__lexicalTextContent = An, An = r7 + An;
  }(t5, e6, n6), Zn(e6, n6), vi(s3 = e6) && null != zn && zn !== s3.__textFormat && !Rn && s3.setTextFormat(zn), Mn = r6, zn = null;
}
function tr(t5, e6) {
  const n6 = [];
  let r6 = t5.__first;
  for (; null !== r6; ) {
    const t6 = e6.get(r6);
    void 0 === t6 && Rt2(101), n6.push(r6), r6 = t6.__next;
  }
  return n6;
}
function er2(t5, e6) {
  const n6 = Fn.get(t5);
  let r6 = On.get(t5);
  void 0 !== n6 && void 0 !== r6 || Rt2(61);
  const s3 = Bn || Dn.has(t5) || Pn.has(t5), i4 = Ze(wn, t5);
  if (n6 === r6 && !s3) {
    if (li(n6)) {
      const t6 = i4.__lexicalTextContent;
      void 0 !== t6 && (An += t6, Wn += t6);
      const e7 = i4.__lexicalDirTextContent;
      void 0 !== e7 && (Mn += e7);
    } else {
      const t6 = n6.getTextContent();
      Gr(n6) && !n6.isDirectionless() && (Mn += t6), Wn += t6, An += t6;
    }
    return i4;
  }
  if (n6 !== r6 && s3 && $e2(Ln, Nn, En, r6, "updated"), r6.updateDOM(n6, i4, bn)) {
    const n7 = qn(t5, null, null);
    return null === e6 && Rt2(62), e6.replaceChild(n7, i4), Jn(t5, null), n7;
  }
  if (li(n6) && li(r6)) {
    const t6 = r6.__indent;
    t6 !== n6.__indent && Hn(i4, t6);
    const e7 = r6.__format;
    e7 !== n6.__format && jn(i4, e7), s3 && (Gn(n6, r6, i4), di(r6) || r6.isInline() || Yn(n6, r6, i4)), Ye(r6) && (An += Nt, Wn += Nt);
  } else {
    const e7 = r6.getTextContent();
    if (ui(r6)) {
      const e8 = r6.decorate(wn, bn);
      null !== e8 && nr(t5, e8);
    } else
      Gr(r6) && !r6.isDirectionless() && (Mn += e7);
    An += e7, Wn += e7;
  }
  if (!Rn && di(r6) && r6.__cachedText !== Wn) {
    const t6 = r6.getWritable();
    t6.__cachedText = Wn, r6 = t6;
  }
  return i4;
}
function nr(t5, e6) {
  let n6 = wn._pendingDecorators;
  const r6 = wn._decorators;
  if (null === n6) {
    if (r6[t5] === e6)
      return;
    n6 = Ce(wn);
  }
  n6[t5] = e6;
}
function rr(t5) {
  let e6 = t5.nextSibling;
  return null !== e6 && e6 === wn._blockCursorElement && (e6 = e6.nextSibling), e6;
}
function sr(t5, e6, n6, r6, s3, i4) {
  An = "", Wn = "", Mn = "", Bn = r6 === lt2, Kn = null, wn = n6, bn = n6._config, Nn = n6._nodes, En = wn._listeners.mutation, Pn = s3, Dn = i4, Fn = t5._nodeMap, On = e6._nodeMap, Rn = e6._readOnly, In = new Map(n6._keyToDOMMap);
  const o5 = /* @__PURE__ */ new Map();
  return Ln = o5, er2("root", null), wn = void 0, Nn = void 0, Pn = void 0, Dn = void 0, Fn = void 0, On = void 0, bn = void 0, In = void 0, Ln = void 0, o5;
}
function ir(t5) {
  const e6 = In.get(t5);
  return void 0 === e6 && Rt2(75, t5), e6;
}
function xr(t5, e6, n6, r6, s3) {
  const i4 = t5.anchor, o5 = t5.focus, l3 = i4.getNode(), c5 = js(), a3 = _n(c5._window), u3 = null !== a3 ? a3.anchorNode : null, f5 = i4.key, d4 = c5.getElementByKey(f5), h7 = n6.length;
  return f5 !== o5.key || !Gr(l3) || (!s3 && (!X || fr < r6 + 50) || l3.isDirty() && h7 < 2 || Pe(n6)) && i4.offset !== o5.offset && !l3.isComposing() || ae(l3) || l3.isDirty() && h7 > 1 || (s3 || !X) && null !== d4 && !l3.isComposing() && u3 !== fe(d4) || null !== a3 && null !== e6 && (!e6.collapsed || e6.startContainer !== a3.anchorNode || e6.startOffset !== a3.anchorOffset) || l3.getFormat() !== t5.format || l3.getStyle() !== t5.style || Ae(t5, l3);
}
function vr(t5, e6) {
  return null !== t5 && null !== t5.nodeValue && t5.nodeType === st2 && 0 !== e6 && e6 !== t5.nodeValue.length;
}
function Tr(t5, n6, r6) {
  const { anchorNode: s3, anchorOffset: i4, focusNode: o5, focusOffset: l3 } = t5;
  gr && (gr = false, vr(s3, i4) && vr(o5, l3)) || ii2(n6, () => {
    if (!r6)
      return void we(null);
    if (!le(n6, s3, o5))
      return;
    const c5 = ws();
    if (us(c5)) {
      const e6 = c5.anchor, r7 = e6.getNode();
      if (c5.isCollapsed()) {
        "Range" === t5.type && t5.anchorNode === t5.focusNode && (c5.dirty = true);
        const s4 = rn(n6).event, i5 = s4 ? s4.timeStamp : performance.now(), [o6, l4, a3, u3, f5] = mr, d4 = ke3(), h7 = false === n6.isComposing() && "" === d4.getTextContent();
        if (i5 < f5 + 200 && e6.offset === a3 && e6.key === u3)
          c5.format = o6, c5.style = l4;
        else if ("text" === e6.type)
          Gr(r7) || Rt2(141), c5.format = r7.getFormat(), c5.style = r7.getStyle();
        else if ("element" === e6.type && !h7) {
          const t6 = e6.getNode();
          t6 instanceof yi && 0 === t6.getChildrenSize() ? c5.format = t6.getTextFormat() : c5.format = 0, c5.style = "";
        }
      } else {
        const t6 = e6.key, n7 = c5.focus.key, r8 = c5.getNodes(), s4 = r8.length, o6 = c5.isBackward(), a3 = o6 ? l3 : i4, u3 = o6 ? i4 : l3, f5 = o6 ? n7 : t6, d4 = o6 ? t6 : n7;
        let h7 = xt, g6 = false;
        for (let t7 = 0; t7 < s4; t7++) {
          const e7 = r8[t7], n8 = e7.getTextContentSize();
          if (Gr(e7) && 0 !== n8 && !(0 === t7 && e7.__key === f5 && a3 === n8 || t7 === s4 - 1 && e7.__key === d4 && 0 === u3) && (g6 = true, h7 &= e7.getFormat(), 0 === h7))
            break;
        }
        c5.format = g6 ? h7 : 0;
      }
    }
    Xe(n6, e5, void 0);
  });
}
function Cr(t5) {
  if (!t5.getTargetRanges)
    return null;
  const e6 = t5.getTargetRanges();
  return 0 === e6.length ? null : e6[0];
}
function Sr(t5, e6) {
  const n6 = t5._compositionKey;
  if (ye(null), null !== n6 && null != e6) {
    if ("" === e6) {
      const e7 = xe2(n6), r6 = fe(t5.getElementByKey(n6));
      return void (null !== r6 && null !== r6.nodeValue && Gr(e7) && Le(e7, r6.nodeValue, null, null, true));
    }
    if ("\n" === e6[e6.length - 1]) {
      const e7 = ws();
      if (us(e7)) {
        const n7 = e7.focus;
        return e7.anchor.set(n7.key, n7.offset, n7.type), void Xe(t5, C, null);
      }
    }
  }
  Ie(true, t5, e6);
}
function kr(t5) {
  let e6 = t5.__lexicalEventHandles;
  return void 0 === e6 && (e6 = [], t5.__lexicalEventHandles = e6), e6;
}
function wr(t5) {
  const e6 = t5.target, n6 = _n(null == e6 ? null : 9 === e6.nodeType ? e6.defaultView : e6.ownerDocument.defaultView);
  if (null === n6)
    return;
  const r6 = ce(n6.anchorNode);
  if (null === r6)
    return;
  _r && (_r = false, ii2(r6, () => {
    const e7 = Ns(), s4 = n6.anchorNode;
    if (null === s4)
      return;
    const i5 = s4.nodeType;
    if (i5 !== rt2 && i5 !== st2)
      return;
    we(bs(e7, n6, r6, t5));
  }));
  const s3 = De(r6), i4 = s3[s3.length - 1], o5 = i4._key, l3 = br.get(o5), c5 = l3 || i4;
  c5 !== r6 && Tr(n6, c5, false), Tr(n6, r6, true), r6 !== i4 ? br.set(o5, r6) : l3 && br.delete(o5);
}
function Nr(t5) {
  t5._lexicalHandled = true;
}
function Er(t5) {
  return true === t5._lexicalHandled;
}
function Pr(t5) {
  const e6 = t5.ownerDocument, n6 = hr.get(e6);
  void 0 === n6 && Rt2(162);
  const r6 = n6 - 1;
  r6 >= 0 || Rt2(164), hr.set(e6, r6), 0 === r6 && e6.removeEventListener("selectionchange", wr);
  const s3 = t5.__lexicalEditor;
  null != s3 && (!function(t6) {
    if (null !== t6._parentEditor) {
      const e7 = De(t6), n7 = e7[e7.length - 1]._key;
      br.get(n7) === t6 && br.delete(n7);
    } else
      br.delete(t6._key);
  }(s3), t5.__lexicalEditor = null);
  const i4 = kr(t5);
  for (let t6 = 0; t6 < i4.length; t6++)
    i4[t6]();
  t5.__lexicalEventHandles = [];
}
function Dr(t5, e6, n6) {
  Vs();
  const r6 = t5.__key, s3 = t5.getParent();
  if (null === s3)
    return;
  const i4 = function(t6) {
    const e7 = ws();
    if (!us(e7) || !li(t6))
      return e7;
    const { anchor: n7, focus: r7 } = e7, s4 = n7.getNode(), i5 = r7.getNode();
    return nn(s4, t6) && n7.set(t6.__key, 0, "element"), nn(i5, t6) && r7.set(t6.__key, 0, "element"), e7;
  }(t5);
  let o5 = false;
  if (us(i4) && e6) {
    const e7 = i4.anchor, n7 = i4.focus;
    e7.key === r6 && (Ds(e7, t5, s3, t5.getPreviousSibling(), t5.getNextSibling()), o5 = true), n7.key === r6 && (Ds(n7, t5, s3, t5.getPreviousSibling(), t5.getNextSibling()), o5 = true);
  } else
    ds(i4) && e6 && t5.isSelected() && t5.selectPrevious();
  if (us(i4) && e6 && !o5) {
    const e7 = t5.getIndexWithinParent();
    _e(t5), Es(i4, s3, e7, -1);
  } else
    _e(t5);
  n6 || ln(s3) || s3.canBeEmpty() || !s3.isEmpty() || Dr(s3, e6), e6 && di(s3) && s3.isEmpty() && s3.selectEnd();
}
function Ir(t5) {
  return { node: Lr() };
}
function Lr() {
  return an(new Or());
}
function Ar(t5) {
  return t5 instanceof Or;
}
function Mr(t5) {
  return t5.nodeType === st2 && /^( |\t|\r?\n)+$/.test(t5.textContent || "");
}
function zr(t5, e6) {
  return 16 & e6 ? "code" : e6 & mt2 ? "mark" : 32 & e6 ? "sub" : 64 & e6 ? "sup" : null;
}
function Wr(t5, e6) {
  return 1 & e6 ? "strong" : 2 & e6 ? "em" : "span";
}
function Br(t5, e6, n6, r6, s3) {
  const i4 = r6.classList;
  let o5 = Ve(s3, "base");
  void 0 !== o5 && i4.add(...o5), o5 = Ve(s3, "underlineStrikethrough");
  let l3 = false;
  const c5 = e6 & gt2 && e6 & ht2;
  void 0 !== o5 && (n6 & gt2 && n6 & ht2 ? (l3 = true, c5 || i4.add(...o5)) : c5 && i4.remove(...o5));
  for (const t6 in It) {
    const r7 = It[t6];
    if (o5 = Ve(s3, t6), void 0 !== o5)
      if (n6 & r7) {
        if (l3 && ("underline" === t6 || "strikethrough" === t6)) {
          e6 & r7 && i4.remove(...o5);
          continue;
        }
        e6 & r7 && (!c5 || "underline" !== t6) && "strikethrough" !== t6 || i4.add(...o5);
      } else
        e6 & r7 && i4.remove(...o5);
  }
}
function Rr(t5, e6, n6) {
  const r6 = e6.firstChild, s3 = n6.isComposing(), i4 = t5 + (s3 ? wt2 : "");
  if (null == r6)
    e6.textContent = i4;
  else {
    const t6 = r6.nodeValue;
    if (t6 !== i4)
      if (s3 || Q2) {
        const [e7, n7, s4] = function(t7, e8) {
          const n8 = t7.length, r7 = e8.length;
          let s5 = 0, i5 = 0;
          for (; s5 < n8 && s5 < r7 && t7[s5] === e8[s5]; )
            s5++;
          for (; i5 + s5 < n8 && i5 + s5 < r7 && t7[n8 - i5 - 1] === e8[r7 - i5 - 1]; )
            i5++;
          return [s5, n8 - s5 - i5, e8.slice(s5, r7 - i5)];
        }(t6, i4);
        0 !== n7 && r6.deleteData(e7, n7), r6.insertData(e7, s4);
      } else
        r6.nodeValue = i4;
  }
}
function Kr(t5, e6, n6, r6, s3, i4) {
  Rr(s3, t5, e6);
  const o5 = i4.theme.text;
  void 0 !== o5 && Br(0, 0, r6, t5, o5);
}
function Jr(t5, e6) {
  const n6 = document.createElement(e6);
  return n6.appendChild(t5), n6;
}
function Vr(t5) {
  return { forChild: ts(t5.style), node: null };
}
function $r(t5) {
  const e6 = t5, n6 = "normal" === e6.style.fontWeight;
  return { forChild: ts(e6.style, n6 ? void 0 : "bold"), node: null };
}
function jr(t5) {
  return "PRE" === t5.nodeName || t5.nodeType === rt2 && void 0 !== t5.style && void 0 !== t5.style.whiteSpace && t5.style.whiteSpace.startsWith("pre");
}
function qr(t5) {
  const e6 = t5;
  null === t5.parentElement && Rt2(129);
  let n6 = e6.textContent || "";
  if (null !== function(t6) {
    let e7, n7 = t6.parentNode;
    const r6 = [t6];
    for (; null !== n7 && void 0 === (e7 = Hr.get(n7)) && !jr(n7); )
      r6.push(n7), n7 = n7.parentNode;
    const s3 = void 0 === e7 ? n7 : e7;
    for (let t7 = 0; t7 < r6.length; t7++)
      Hr.set(r6[t7], s3);
    return s3;
  }(e6)) {
    const t6 = n6.split(/(\r?\n|\t)/), e7 = [], r6 = t6.length;
    for (let n7 = 0; n7 < r6; n7++) {
      const r7 = t6[n7];
      "\n" === r7 || "\r\n" === r7 ? e7.push(Lr()) : "	" === r7 ? e7.push(ns()) : "" !== r7 && e7.push(Zr(r7));
    }
    return { node: e7 };
  }
  if (n6 = n6.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), "" === n6)
    return { node: null };
  if (" " === n6[0]) {
    let t6 = e6, r6 = true;
    for (; null !== t6 && null !== (t6 = Qr(t6, false)); ) {
      const e7 = t6.textContent || "";
      if (e7.length > 0) {
        /[ \t\n]$/.test(e7) && (n6 = n6.slice(1)), r6 = false;
        break;
      }
    }
    r6 && (n6 = n6.slice(1));
  }
  if (" " === n6[n6.length - 1]) {
    let t6 = e6, r6 = true;
    for (; null !== t6 && null !== (t6 = Qr(t6, true)); ) {
      if ((t6.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        r6 = false;
        break;
      }
    }
    r6 && (n6 = n6.slice(0, n6.length - 1));
  }
  return "" === n6 ? { node: null } : { node: Zr(n6) };
}
function Qr(t5, e6) {
  let n6 = t5;
  for (; ; ) {
    let t6;
    for (; null === (t6 = e6 ? n6.nextSibling : n6.previousSibling); ) {
      const t7 = n6.parentElement;
      if (null === t7)
        return null;
      n6 = t7;
    }
    if (n6 = t6, n6.nodeType === rt2) {
      const t7 = n6.style.display;
      if ("" === t7 && !xn(n6) || "" !== t7 && !t7.startsWith("inline"))
        return null;
    }
    let r6 = n6;
    for (; null !== (r6 = e6 ? n6.firstChild : n6.lastChild); )
      n6 = r6;
    if (n6.nodeType === st2)
      return n6;
    if ("BR" === n6.nodeName)
      return null;
  }
}
function Yr(t5) {
  const e6 = Xr[t5.nodeName.toLowerCase()];
  return void 0 === e6 ? { node: null } : { forChild: ts(t5.style, e6), node: null };
}
function Zr(t5 = "") {
  return an(new Ur(t5));
}
function Gr(t5) {
  return t5 instanceof Ur;
}
function ts(t5, e6) {
  const n6 = t5.fontWeight, r6 = t5.textDecoration.split(" "), s3 = "700" === n6 || "bold" === n6, i4 = r6.includes("line-through"), o5 = "italic" === t5.fontStyle, l3 = r6.includes("underline"), c5 = t5.verticalAlign;
  return (t6) => Gr(t6) ? (s3 && !t6.hasFormat("bold") && t6.toggleFormat("bold"), i4 && !t6.hasFormat("strikethrough") && t6.toggleFormat("strikethrough"), o5 && !t6.hasFormat("italic") && t6.toggleFormat("italic"), l3 && !t6.hasFormat("underline") && t6.toggleFormat("underline"), "sub" !== c5 || t6.hasFormat("subscript") || t6.toggleFormat("subscript"), "super" !== c5 || t6.hasFormat("superscript") || t6.toggleFormat("superscript"), e6 && !t6.hasFormat(e6) && t6.toggleFormat(e6), t6) : t6;
}
function ns() {
  return an(new es());
}
function rs(t5) {
  return t5 instanceof es;
}
function is(t5, e6, n6) {
  return new ss(t5, e6, n6);
}
function os(t5, e6) {
  let n6 = e6.__key, r6 = t5.offset, s3 = "element";
  if (Gr(e6)) {
    s3 = "text";
    const t6 = e6.getTextContentSize();
    r6 > t6 && (r6 = t6);
  } else if (!li(e6)) {
    const t6 = e6.getNextSibling();
    if (Gr(t6))
      n6 = t6.__key, r6 = 0, s3 = "text";
    else {
      const t7 = e6.getParent();
      t7 && (n6 = t7.__key, r6 = e6.getIndexWithinParent() + 1);
    }
  }
  t5.set(n6, r6, s3);
}
function ls(t5, e6) {
  if (li(e6)) {
    const n6 = e6.getLastDescendant();
    li(n6) || Gr(n6) ? os(t5, n6) : os(t5, e6);
  } else
    os(t5, e6);
}
function cs(t5, e6, n6, r6) {
  t5.key = e6, t5.offset = n6, t5.type = r6;
}
function us(t5) {
  return t5 instanceof fs;
}
function ds(t5) {
  return t5 instanceof as;
}
function hs(t5) {
  const e6 = t5.offset;
  if ("text" === t5.type)
    return e6;
  const n6 = t5.getNode();
  return e6 === n6.getChildrenSize() ? n6.getTextContent().length : 0;
}
function gs(t5) {
  const e6 = t5.getStartEndPoints();
  if (null === e6)
    return [0, 0];
  const [n6, r6] = e6;
  return "element" === n6.type && "element" === r6.type && n6.key === r6.key && n6.offset === r6.offset ? [0, 0] : [hs(n6), hs(r6)];
}
function _s(t5, e6, n6) {
  const r6 = t5, s3 = r6.getTextContent().split(/(?=\s)/g), i4 = s3.length;
  let o5 = 0, l3 = 0;
  for (let t6 = 0; t6 < i4; t6++) {
    const r7 = t6 === i4 - 1;
    if (l3 = o5, o5 += s3[t6].length, e6 && o5 === n6 || o5 > n6 || r7) {
      s3.splice(t6, 1), r7 && (l3 = void 0);
      break;
    }
  }
  const c5 = s3.join("").trim();
  "" === c5 ? r6.remove() : (r6.setTextContent(c5), r6.select(l3, l3));
}
function ps(t5, e6, n6, r6) {
  let s3, i4 = e6;
  if (t5.nodeType === rt2) {
    let o5 = false;
    const l3 = t5.childNodes, c5 = l3.length, a3 = r6._blockCursorElement;
    i4 === c5 && (o5 = true, i4 = c5 - 1);
    let u3 = l3[i4], f5 = false;
    if (u3 === a3)
      u3 = l3[i4 + 1], f5 = true;
    else if (null !== a3) {
      const n7 = a3.parentNode;
      if (t5 === n7) {
        e6 > Array.prototype.indexOf.call(n7.children, a3) && i4--;
      }
    }
    if (s3 = Ne(u3), Gr(s3))
      i4 = Ee2(s3, o5);
    else {
      let r7 = Ne(t5);
      if (null === r7)
        return null;
      if (li(r7)) {
        i4 = Math.min(r7.getChildrenSize(), i4);
        let t6 = r7.getChildAtIndex(i4);
        if (li(t6) && function(t7, e7, n7) {
          const r8 = t7.getParent();
          return null === n7 || null === r8 || !r8.canBeEmpty() || r8 !== n7.getNode();
        }(t6, 0, n6)) {
          const e7 = o5 ? t6.getLastDescendant() : t6.getFirstDescendant();
          null === e7 ? r7 = t6 : (t6 = e7, r7 = li(t6) ? t6 : t6.getParentOrThrow()), i4 = 0;
        }
        Gr(t6) ? (s3 = t6, r7 = null, i4 = Ee2(t6, o5)) : t6 !== r7 && o5 && !f5 && i4++;
      } else {
        const n7 = r7.getIndexWithinParent();
        i4 = 0 === e6 && ui(r7) && Ne(t5) === r7 ? n7 : n7 + 1, r7 = r7.getParentOrThrow();
      }
      if (li(r7))
        return is(r7.__key, i4, "element");
    }
  } else
    s3 = Ne(t5);
  return Gr(s3) ? is(s3.__key, i4, "text") : null;
}
function ys(t5, e6, n6) {
  const r6 = t5.offset, s3 = t5.getNode();
  if (0 === r6) {
    const r7 = s3.getPreviousSibling(), i4 = s3.getParent();
    if (e6) {
      if ((n6 || !e6) && null === r7 && li(i4) && i4.isInline()) {
        const e7 = i4.getPreviousSibling();
        Gr(e7) && (t5.key = e7.__key, t5.offset = e7.getTextContent().length);
      }
    } else
      li(r7) && !n6 && r7.isInline() ? (t5.key = r7.__key, t5.offset = r7.getChildrenSize(), t5.type = "element") : Gr(r7) && (t5.key = r7.__key, t5.offset = r7.getTextContent().length);
  } else if (r6 === s3.getTextContent().length) {
    const r7 = s3.getNextSibling(), i4 = s3.getParent();
    if (e6 && li(r7) && r7.isInline())
      t5.key = r7.__key, t5.offset = 0, t5.type = "element";
    else if ((n6 || e6) && null === r7 && li(i4) && i4.isInline() && !i4.canInsertTextAfter()) {
      const e7 = i4.getNextSibling();
      Gr(e7) && (t5.key = e7.__key, t5.offset = 0);
    }
  }
}
function ms(t5, e6, n6) {
  if ("text" === t5.type && "text" === e6.type) {
    const r6 = t5.isBefore(e6), s3 = t5.is(e6);
    ys(t5, r6, s3), ys(e6, !r6, s3), s3 && (e6.key = t5.key, e6.offset = t5.offset, e6.type = t5.type);
    const i4 = js();
    if (i4.isComposing() && i4._compositionKey !== t5.key && us(n6)) {
      const r7 = n6.anchor, s4 = n6.focus;
      cs(t5, r7.key, r7.offset, r7.type), cs(e6, s4.key, s4.offset, s4.type);
    }
  }
}
function xs(t5, e6, n6, r6, s3, i4) {
  if (null === t5 || null === n6 || !le(s3, t5, n6))
    return null;
  const o5 = ps(t5, e6, us(i4) ? i4.anchor : null, s3);
  if (null === o5)
    return null;
  const l3 = ps(n6, r6, us(i4) ? i4.focus : null, s3);
  if (null === l3)
    return null;
  if ("element" === o5.type && "element" === l3.type) {
    const e7 = Ne(t5), r7 = Ne(n6);
    if (ui(e7) && ui(r7))
      return null;
  }
  return ms(o5, l3, i4), [o5, l3];
}
function vs(t5) {
  return li(t5) && !t5.isInline();
}
function Ts(t5, e6, n6, r6, s3, i4) {
  const o5 = Hs(), l3 = new fs(is(t5, e6, s3), is(n6, r6, i4), 0, "");
  return l3.dirty = true, o5._selection = l3, l3;
}
function Cs() {
  const t5 = is("root", 0, "element"), e6 = is("root", 0, "element");
  return new fs(t5, e6, 0, "");
}
function Ss() {
  return new as(/* @__PURE__ */ new Set());
}
function ks(t5, e6) {
  return bs(null, t5, e6, null);
}
function bs(t5, e6, n6, r6) {
  const s3 = n6._window;
  if (null === s3)
    return null;
  const i4 = r6 || s3.event, o5 = i4 ? i4.type : void 0, l3 = "selectionchange" === o5, c5 = !Ut && (l3 || "beforeinput" === o5 || "compositionstart" === o5 || "compositionend" === o5 || "click" === o5 && i4 && 3 === i4.detail || "drop" === o5 || void 0 === o5);
  let a3, u3, f5, d4;
  if (us(t5) && !c5)
    return t5.clone();
  if (null === e6)
    return null;
  if (a3 = e6.anchorNode, u3 = e6.focusNode, f5 = e6.anchorOffset, d4 = e6.focusOffset, l3 && us(t5) && !le(n6, a3, u3))
    return t5.clone();
  const h7 = xs(a3, f5, u3, d4, n6, t5);
  if (null === h7)
    return null;
  const [g6, _5] = h7;
  return new fs(g6, _5, us(t5) ? t5.format : 0, us(t5) ? t5.style : "");
}
function ws() {
  return Hs()._selection;
}
function Ns() {
  return js()._editorState._selection;
}
function Es(t5, e6, n6, r6 = 1) {
  const s3 = t5.anchor, i4 = t5.focus, o5 = s3.getNode(), l3 = i4.getNode();
  if (!e6.is(o5) && !e6.is(l3))
    return;
  const c5 = e6.__key;
  if (t5.isCollapsed()) {
    const e7 = s3.offset;
    if (n6 <= e7 && r6 > 0 || n6 < e7 && r6 < 0) {
      const n7 = Math.max(0, e7 + r6);
      s3.set(c5, n7, "element"), i4.set(c5, n7, "element"), Ps(t5);
    }
  } else {
    const o6 = t5.isBackward(), l4 = o6 ? i4 : s3, a3 = l4.getNode(), u3 = o6 ? s3 : i4, f5 = u3.getNode();
    if (e6.is(a3)) {
      const t6 = l4.offset;
      (n6 <= t6 && r6 > 0 || n6 < t6 && r6 < 0) && l4.set(c5, Math.max(0, t6 + r6), "element");
    }
    if (e6.is(f5)) {
      const t6 = u3.offset;
      (n6 <= t6 && r6 > 0 || n6 < t6 && r6 < 0) && u3.set(c5, Math.max(0, t6 + r6), "element");
    }
  }
  Ps(t5);
}
function Ps(t5) {
  const e6 = t5.anchor, n6 = e6.offset, r6 = t5.focus, s3 = r6.offset, i4 = e6.getNode(), o5 = r6.getNode();
  if (t5.isCollapsed()) {
    if (!li(i4))
      return;
    const t6 = i4.getChildrenSize(), s4 = n6 >= t6, o6 = s4 ? i4.getChildAtIndex(t6 - 1) : i4.getChildAtIndex(n6);
    if (Gr(o6)) {
      let t7 = 0;
      s4 && (t7 = o6.getTextContentSize()), e6.set(o6.__key, t7, "text"), r6.set(o6.__key, t7, "text");
    }
  } else {
    if (li(i4)) {
      const t6 = i4.getChildrenSize(), r7 = n6 >= t6, s4 = r7 ? i4.getChildAtIndex(t6 - 1) : i4.getChildAtIndex(n6);
      if (Gr(s4)) {
        let t7 = 0;
        r7 && (t7 = s4.getTextContentSize()), e6.set(s4.__key, t7, "text");
      }
    }
    if (li(o5)) {
      const t6 = o5.getChildrenSize(), e7 = s3 >= t6, n7 = e7 ? o5.getChildAtIndex(t6 - 1) : o5.getChildAtIndex(s3);
      if (Gr(n7)) {
        let t7 = 0;
        e7 && (t7 = n7.getTextContentSize()), r6.set(n7.__key, t7, "text");
      }
    }
  }
}
function Ds(t5, e6, n6, r6, s3) {
  let i4 = null, o5 = 0, l3 = null;
  null !== r6 ? (i4 = r6.__key, Gr(r6) ? (o5 = r6.getTextContentSize(), l3 = "text") : li(r6) && (o5 = r6.getChildrenSize(), l3 = "element")) : null !== s3 && (i4 = s3.__key, Gr(s3) ? l3 = "text" : li(s3) && (l3 = "element")), null !== i4 && null !== l3 ? t5.set(i4, o5, l3) : (o5 = e6.getIndexWithinParent(), -1 === o5 && (o5 = n6.getChildrenSize()), t5.set(n6.__key, o5, "element"));
}
function Fs(t5, e6, n6, r6, s3) {
  "text" === t5.type ? (t5.key = n6, e6 || (t5.offset += s3)) : t5.offset > r6.getIndexWithinParent() && (t5.offset -= 1);
}
function Os(t5, e6, n6, r6, s3, i4, o5) {
  const l3 = r6.anchorNode, c5 = r6.focusNode, a3 = r6.anchorOffset, u3 = r6.focusOffset, f5 = document.activeElement;
  if (s3.has("collaboration") && f5 !== i4 || null !== f5 && oe(f5))
    return;
  if (!us(e6))
    return void (null !== t5 && le(n6, l3, c5) && r6.removeAllRanges());
  const d4 = e6.anchor, h7 = e6.focus, g6 = d4.key, _5 = h7.key, p5 = Ze(n6, g6), y7 = Ze(n6, _5), m7 = d4.offset, x6 = h7.offset, v8 = e6.format, T6 = e6.style, C5 = e6.isCollapsed();
  let S8 = p5, k6 = y7, b5 = false;
  if ("text" === d4.type) {
    S8 = fe(p5);
    const t6 = d4.getNode();
    b5 = t6.getFormat() !== v8 || t6.getStyle() !== T6;
  } else
    us(t5) && "text" === t5.anchor.type && (b5 = true);
  var w6, N6, E6, P7, D6;
  if (("text" === h7.type && (k6 = fe(y7)), null !== S8 && null !== k6) && (C5 && (null === t5 || b5 || us(t5) && (t5.format !== v8 || t5.style !== T6)) && (w6 = v8, N6 = T6, E6 = m7, P7 = g6, D6 = performance.now(), mr = [w6, N6, E6, P7, D6]), a3 !== m7 || u3 !== x6 || l3 !== S8 || c5 !== k6 || "Range" === r6.type && C5 || (null !== f5 && i4.contains(f5) || i4.focus({ preventScroll: true }), "element" === d4.type))) {
    try {
      r6.setBaseAndExtent(S8, m7, k6, x6);
    } catch (t6) {
    }
    if (!s3.has("skip-scroll-into-view") && e6.isCollapsed() && null !== i4 && i4 === document.activeElement) {
      const t6 = e6 instanceof fs && "element" === e6.anchor.type ? S8.childNodes[m7] || null : r6.rangeCount > 0 ? r6.getRangeAt(0) : null;
      if (null !== t6) {
        let e7;
        if (t6 instanceof Text) {
          const n7 = document.createRange();
          n7.selectNode(t6), e7 = n7.getBoundingClientRect();
        } else
          e7 = t6.getBoundingClientRect();
        !function(t7, e8, n7) {
          const r7 = n7.ownerDocument, s4 = r7.defaultView;
          if (null === s4)
            return;
          let { top: i5, bottom: o6 } = e8, l4 = 0, c6 = 0, a4 = n7;
          for (; null !== a4; ) {
            const e9 = a4 === r7.body;
            if (e9)
              l4 = 0, c6 = rn(t7).innerHeight;
            else {
              const t8 = a4.getBoundingClientRect();
              l4 = t8.top, c6 = t8.bottom;
            }
            let n8 = 0;
            if (i5 < l4 ? n8 = -(l4 - i5) : o6 > c6 && (n8 = o6 - c6), 0 !== n8)
              if (e9)
                s4.scrollBy(0, n8);
              else {
                const t8 = a4.scrollTop;
                a4.scrollTop += n8;
                const e10 = a4.scrollTop - t8;
                i5 -= e10, o6 -= e10;
              }
            if (e9)
              break;
            a4 = Ge(a4);
          }
        }(n6, e7, i4);
      }
    }
    gr = true;
  }
}
function Is(t5) {
  let e6 = ws() || Ns();
  null === e6 && (e6 = ke3().selectEnd()), e6.insertNodes(t5);
}
function Ls() {
  const t5 = ws();
  return null === t5 ? "" : t5.getTextContent();
}
function As(t5) {
  let e6 = t5;
  t5.isCollapsed() || e6.removeText();
  const n6 = ws();
  us(n6) && (e6 = n6), us(e6) || Rt2(161);
  const r6 = e6.anchor;
  let s3 = r6.getNode(), i4 = r6.offset;
  for (; !Tn(s3); )
    [s3, i4] = Ms(s3, i4);
  return i4;
}
function Ms(t5, e6) {
  const n6 = t5.getParent();
  if (!n6) {
    const t6 = xi();
    return ke3().append(t6), t6.select(), [ke3(), 0];
  }
  if (Gr(t5)) {
    const r7 = t5.splitText(e6);
    if (0 === r7.length)
      return [n6, t5.getIndexWithinParent()];
    const s3 = 0 === e6 ? 0 : 1;
    return [n6, r7[0].getIndexWithinParent() + s3];
  }
  if (!li(t5) || 0 === e6)
    return [n6, t5.getIndexWithinParent()];
  const r6 = t5.getChildAtIndex(e6);
  if (r6) {
    const n7 = new fs(is(t5.__key, e6, "element"), is(t5.__key, e6, "element"), 0, ""), s3 = t5.insertNewAfter(n7);
    s3 && s3.append(r6, ...r6.getNextSiblings());
  }
  return [n6, t5.getIndexWithinParent() + 1];
}
function Us() {
  return Bs || null !== zs && zs._readOnly;
}
function Vs() {
  Bs && Rt2(13);
}
function $s() {
  Ks > 99 && Rt2(14);
}
function Hs() {
  return null === zs && Rt2(15), zs;
}
function js() {
  return null === Ws && Rt2(16), Ws;
}
function qs() {
  return Ws;
}
function Qs(t5, e6, n6) {
  const r6 = e6.__type, s3 = function(t6, e7) {
    const n7 = t6._nodes.get(e7);
    return void 0 === n7 && Rt2(30, e7), n7;
  }(t5, r6);
  let i4 = n6.get(r6);
  void 0 === i4 && (i4 = Array.from(s3.transforms), n6.set(r6, i4));
  const o5 = i4.length;
  for (let t6 = 0; t6 < o5 && (i4[t6](e6), e6.isAttached()); t6++)
    ;
}
function Xs(t5, e6) {
  return void 0 !== t5 && t5.__key !== e6 && t5.isAttached();
}
function Ys(t5) {
  return Zs(t5, js()._nodes);
}
function Zs(t5, e6) {
  const n6 = t5.type, r6 = e6.get(n6);
  void 0 === r6 && Rt2(17, n6);
  const s3 = r6.klass;
  t5.type !== s3.getType() && Rt2(18, s3.name);
  const i4 = s3.importJSON(t5), o5 = t5.children;
  if (li(i4) && Array.isArray(o5))
    for (let t6 = 0; t6 < o5.length; t6++) {
      const n7 = Zs(o5[t6], e6);
      i4.append(n7);
    }
  return i4;
}
function Gs(t5, e6) {
  const n6 = zs, r6 = Bs, s3 = Ws;
  zs = t5, Bs = true, Ws = null;
  try {
    return e6();
  } finally {
    zs = n6, Bs = r6, Ws = s3;
  }
}
function ti(t5, n6) {
  const r6 = t5._pendingEditorState, s3 = t5._rootElement, i4 = t5._headless || null === s3;
  if (null === r6)
    return;
  const o5 = t5._editorState, l3 = o5._selection, c5 = r6._selection, a3 = t5._dirtyType !== it, u3 = zs, f5 = Bs, d4 = Ws, h7 = t5._updating, g6 = t5._observer;
  let _5 = null;
  if (t5._pendingEditorState = null, t5._editorState = r6, !i4 && a3 && null !== g6) {
    Ws = t5, zs = r6, Bs = false, t5._updating = true;
    try {
      const e6 = t5._dirtyType, n7 = t5._dirtyElements, s4 = t5._dirtyLeaves;
      g6.disconnect(), _5 = sr(o5, r6, t5, e6, n7, s4);
    } catch (e6) {
      if (e6 instanceof Error && t5._onError(e6), Rs)
        throw e6;
      return wi(t5, null, s3, r6), Yt(t5), t5._dirtyType = lt2, Rs = true, ti(t5, o5), void (Rs = false);
    } finally {
      g6.observe(s3, Js), t5._updating = h7, zs = u3, Bs = f5, Ws = d4;
    }
  }
  r6._readOnly || (r6._readOnly = true);
  const p5 = t5._dirtyLeaves, y7 = t5._dirtyElements, m7 = t5._normalizedNodes, x6 = t5._updateTags, v8 = t5._deferred;
  a3 && (t5._dirtyType = it, t5._cloneNotNeeded.clear(), t5._dirtyLeaves = /* @__PURE__ */ new Set(), t5._dirtyElements = /* @__PURE__ */ new Map(), t5._normalizedNodes = /* @__PURE__ */ new Set(), t5._updateTags = /* @__PURE__ */ new Set()), function(t6, e6) {
    const n7 = t6._decorators;
    let r7 = t6._pendingDecorators || n7;
    const s4 = e6._nodeMap;
    let i5;
    for (i5 in r7)
      s4.has(i5) || (r7 === n7 && (r7 = Ce(t6)), delete r7[i5]);
  }(t5, r6);
  const T6 = i4 ? null : _n(t5._window);
  if (t5._editable && null !== T6 && (a3 || null === c5 || c5.dirty)) {
    Ws = t5, zs = r6;
    try {
      if (null !== g6 && g6.disconnect(), a3 || null === c5 || c5.dirty) {
        const e6 = t5._blockCursorElement;
        null !== e6 && hn(e6, t5, s3), Os(l3, c5, t5, T6, x6, s3);
      }
      gn(t5, s3, c5), null !== g6 && g6.observe(s3, Js);
    } finally {
      Ws = d4, zs = u3;
    }
  }
  null !== _5 && function(t6, e6, n7, r7, s4) {
    const i5 = Array.from(t6._listeners.mutation), o6 = i5.length;
    for (let t7 = 0; t7 < o6; t7++) {
      const [o7, l4] = i5[t7], c6 = e6.get(l4);
      void 0 !== c6 && o7(c6, { dirtyLeaves: r7, prevEditorState: s4, updateTags: n7 });
    }
  }(t5, _5, x6, p5, o5), us(c5) || null === c5 || null !== l3 && l3.is(c5) || t5.dispatchCommand(e5, void 0);
  const C5 = t5._pendingDecorators;
  null !== C5 && (t5._decorators = C5, t5._pendingDecorators = null, ei("decorator", t5, true, C5)), function(t6, e6, n7) {
    const r7 = Se3(e6), s4 = Se3(n7);
    r7 !== s4 && ei("textcontent", t6, true, s4);
  }(t5, n6 || o5, r6), ei("update", t5, true, { dirtyElements: y7, dirtyLeaves: p5, editorState: r6, normalizedNodes: m7, prevEditorState: n6 || o5, tags: x6 }), function(t6, e6) {
    if (t6._deferred = [], 0 !== e6.length) {
      const n7 = t6._updating;
      t6._updating = true;
      try {
        for (let t7 = 0; t7 < e6.length; t7++)
          e6[t7]();
      } finally {
        t6._updating = n7;
      }
    }
  }(t5, v8), function(t6) {
    const e6 = t6._updates;
    if (0 !== e6.length) {
      const n7 = e6.shift();
      if (n7) {
        const [e7, r7] = n7;
        si2(t6, e7, r7);
      }
    }
  }(t5);
}
function ei(t5, e6, n6, ...r6) {
  const s3 = e6._updating;
  e6._updating = n6;
  try {
    const n7 = Array.from(e6._listeners[t5]);
    for (let t6 = 0; t6 < n7.length; t6++)
      n7[t6].apply(null, r6);
  } finally {
    e6._updating = s3;
  }
}
function ni(t5, e6, n6) {
  if (false === t5._updating || Ws !== t5) {
    let r7 = false;
    return t5.update(() => {
      r7 = ni(t5, e6, n6);
    }), r7;
  }
  const r6 = De(t5);
  for (let s3 = 4; s3 >= 0; s3--)
    for (let i4 = 0; i4 < r6.length; i4++) {
      const o5 = r6[i4]._commands.get(e6);
      if (void 0 !== o5) {
        const e7 = o5[s3];
        if (void 0 !== e7) {
          const r7 = Array.from(e7), s4 = r7.length;
          for (let e8 = 0; e8 < s4; e8++)
            if (true === r7[e8](n6, t5))
              return true;
        }
      }
    }
  return false;
}
function ri(t5, e6) {
  const n6 = t5._updates;
  let r6 = e6 || false;
  for (; 0 !== n6.length; ) {
    const e7 = n6.shift();
    if (e7) {
      const [n7, s3] = e7;
      let i4, o5;
      void 0 !== s3 && (i4 = s3.onUpdate, o5 = s3.tag, s3.skipTransforms && (r6 = true), i4 && t5._deferred.push(i4), o5 && t5._updateTags.add(o5)), n7();
    }
  }
  return r6;
}
function si2(t5, e6, n6) {
  const r6 = t5._updateTags;
  let s3, i4, o5 = false, l3 = false;
  void 0 !== n6 && (s3 = n6.onUpdate, i4 = n6.tag, null != i4 && r6.add(i4), o5 = n6.skipTransforms || false, l3 = n6.discrete || false), s3 && t5._deferred.push(s3);
  const c5 = t5._editorState;
  let a3 = t5._pendingEditorState, u3 = false;
  (null === a3 || a3._readOnly) && (a3 = t5._pendingEditorState = new _i(new Map((a3 || c5)._nodeMap)), u3 = true), a3._flushSync = l3;
  const f5 = zs, d4 = Bs, h7 = Ws, g6 = t5._updating;
  zs = a3, Bs = false, t5._updating = true, Ws = t5;
  try {
    u3 && (t5._headless ? null !== c5._selection && (a3._selection = c5._selection.clone()) : a3._selection = function(t6) {
      const e7 = t6.getEditorState()._selection, n8 = _n(t6._window);
      return us(e7) || null == e7 ? bs(e7, n8, t6, null) : e7.clone();
    }(t5));
    const n7 = t5._compositionKey;
    e6(), o5 = ri(t5, o5), function(t6, e7) {
      const n8 = e7.getEditorState()._selection, r8 = t6._selection;
      if (us(r8)) {
        const t7 = r8.anchor, e8 = r8.focus;
        let s4;
        if ("text" === t7.type && (s4 = t7.getNode(), s4.selectionTransform(n8, r8)), "text" === e8.type) {
          const t8 = e8.getNode();
          s4 !== t8 && t8.selectionTransform(n8, r8);
        }
      }
    }(a3, t5), t5._dirtyType !== it && (o5 ? function(t6, e7) {
      const n8 = e7._dirtyLeaves, r8 = t6._nodeMap;
      for (const t7 of n8) {
        const e8 = r8.get(t7);
        Gr(e8) && e8.isAttached() && e8.isSimpleText() && !e8.isUnmergeable() && te(e8);
      }
    }(a3, t5) : function(t6, e7) {
      const n8 = e7._dirtyLeaves, r8 = e7._dirtyElements, s4 = t6._nodeMap, i5 = me(), o6 = /* @__PURE__ */ new Map();
      let l4 = n8, c6 = l4.size, a4 = r8, u4 = a4.size;
      for (; c6 > 0 || u4 > 0; ) {
        if (c6 > 0) {
          e7._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const t7 of l4) {
            const r9 = s4.get(t7);
            Gr(r9) && r9.isAttached() && r9.isSimpleText() && !r9.isUnmergeable() && te(r9), void 0 !== r9 && Xs(r9, i5) && Qs(e7, r9, o6), n8.add(t7);
          }
          if (l4 = e7._dirtyLeaves, c6 = l4.size, c6 > 0) {
            Ks++;
            continue;
          }
        }
        e7._dirtyLeaves = /* @__PURE__ */ new Set(), e7._dirtyElements = /* @__PURE__ */ new Map();
        for (const t7 of a4) {
          const n9 = t7[0], l5 = t7[1];
          if ("root" !== n9 && !l5)
            continue;
          const c7 = s4.get(n9);
          void 0 !== c7 && Xs(c7, i5) && Qs(e7, c7, o6), r8.set(n9, l5);
        }
        l4 = e7._dirtyLeaves, c6 = l4.size, a4 = e7._dirtyElements, u4 = a4.size, Ks++;
      }
      e7._dirtyLeaves = n8, e7._dirtyElements = r8;
    }(a3, t5), ri(t5), function(t6, e7, n8, r8) {
      const s4 = t6._nodeMap, i5 = e7._nodeMap, o6 = [];
      for (const [t7] of r8) {
        const e8 = i5.get(t7);
        void 0 !== e8 && (e8.isAttached() || (li(e8) && kn(e8, t7, s4, i5, o6, r8), s4.has(t7) || r8.delete(t7), o6.push(t7)));
      }
      for (const t7 of o6)
        i5.delete(t7);
      for (const t7 of n8) {
        const e8 = i5.get(t7);
        void 0 === e8 || e8.isAttached() || (s4.has(t7) || n8.delete(t7), i5.delete(t7));
      }
    }(c5, a3, t5._dirtyLeaves, t5._dirtyElements));
    n7 !== t5._compositionKey && (a3._flushSync = true);
    const r7 = a3._selection;
    if (us(r7)) {
      const t6 = a3._nodeMap, e7 = r7.anchor.key, n8 = r7.focus.key;
      void 0 !== t6.get(e7) && void 0 !== t6.get(n8) || Rt2(19);
    } else
      ds(r7) && 0 === r7._nodes.size && (a3._selection = null);
  } catch (e7) {
    return e7 instanceof Error && t5._onError(e7), t5._pendingEditorState = c5, t5._dirtyType = lt2, t5._cloneNotNeeded.clear(), t5._dirtyLeaves = /* @__PURE__ */ new Set(), t5._dirtyElements.clear(), void ti(t5);
  } finally {
    zs = f5, Bs = d4, Ws = h7, t5._updating = g6, Ks = 0;
  }
  const _5 = t5._dirtyType !== it || function(t6, e7) {
    const n7 = e7.getEditorState()._selection, r7 = t6._selection;
    if (null !== r7) {
      if (r7.dirty || !r7.is(n7))
        return true;
    } else if (null !== n7)
      return true;
    return false;
  }(a3, t5);
  _5 ? a3._flushSync ? (a3._flushSync = false, ti(t5)) : u3 && ie(() => {
    ti(t5);
  }) : (a3._flushSync = false, u3 && (r6.clear(), t5._deferred = [], t5._pendingEditorState = null));
}
function ii2(t5, e6, n6) {
  t5._updating ? t5._updates.push([e6, n6]) : si2(t5, e6, n6);
}
function li(t5) {
  return t5 instanceof oi;
}
function ci(t5, e6, n6) {
  let r6 = t5.getNode();
  for (; r6; ) {
    const t6 = r6.__key;
    if (e6.has(t6) && !n6.has(t6))
      return true;
    r6 = r6.getParent();
  }
  return false;
}
function ui(t5) {
  return t5 instanceof ai;
}
function di(t5) {
  return t5 instanceof fi;
}
function hi() {
  return new _i(/* @__PURE__ */ new Map([["root", new fi()]]));
}
function gi(t5) {
  const e6 = t5.exportJSON(), n6 = t5.constructor;
  if (e6.type !== n6.getType() && Rt2(130, n6.name), li(t5)) {
    const r6 = e6.children;
    Array.isArray(r6) || Rt2(59, n6.name);
    const s3 = t5.getChildren();
    for (let t6 = 0; t6 < s3.length; t6++) {
      const e7 = gi(s3[t6]);
      r6.push(e7);
    }
  }
  return e6;
}
function mi(t5) {
  const e6 = xi();
  if (t5.style) {
    e6.setFormat(t5.style.textAlign);
    const n6 = parseInt(t5.style.textIndent, 10) / 20;
    n6 > 0 && e6.setIndent(n6);
  }
  return { node: e6 };
}
function xi() {
  return an(new yi());
}
function vi(t5) {
  return t5 instanceof yi;
}
function wi(t5, e6, n6, r6) {
  const s3 = t5._keyToDOMMap;
  s3.clear(), t5._editorState = hi(), t5._pendingEditorState = r6, t5._compositionKey = null, t5._dirtyType = it, t5._cloneNotNeeded.clear(), t5._dirtyLeaves = /* @__PURE__ */ new Set(), t5._dirtyElements.clear(), t5._normalizedNodes = /* @__PURE__ */ new Set(), t5._updateTags = /* @__PURE__ */ new Set(), t5._updates = [], t5._blockCursorElement = null;
  const i4 = t5._observer;
  null !== i4 && (i4.disconnect(), t5._observer = null), null !== e6 && (e6.textContent = ""), null !== n6 && (n6.textContent = "", s3.set("root", n6));
}
function Ni(t5) {
  const e6 = t5 || {}, n6 = qs(), r6 = e6.theme || {}, s3 = void 0 === t5 ? n6 : e6.parentEditor || null, i4 = e6.disableEvents || false, o5 = hi(), l3 = e6.namespace || (null !== s3 ? s3._config.namespace : Fe()), c5 = e6.editorState, a3 = [fi, Ur, Or, es, yi, pi, ...e6.nodes || []], { onError: u3, html: f5 } = e6, d4 = void 0 === e6.editable || e6.editable;
  let h7;
  if (void 0 === t5 && null !== n6)
    h7 = n6._nodes;
  else {
    h7 = /* @__PURE__ */ new Map();
    for (let t6 = 0; t6 < a3.length; t6++) {
      let e7 = a3[t6], n7 = null, r7 = null;
      if ("function" != typeof e7) {
        const t7 = e7;
        e7 = t7.replace, n7 = t7.with, r7 = t7.withKlass || null;
      }
      const s4 = e7.getType(), i5 = e7.transform(), o6 = /* @__PURE__ */ new Set();
      null !== i5 && o6.add(i5), h7.set(s4, { exportDOM: f5 && f5.export ? f5.export.get(e7) : void 0, klass: e7, replace: n7, replaceWithKlass: r7, transforms: o6 });
    }
  }
  const g6 = new Ei(o5, s3, h7, { disableEvents: i4, namespace: l3, theme: r6 }, u3 || console.error, function(t6, e7) {
    const n7 = /* @__PURE__ */ new Map(), r7 = /* @__PURE__ */ new Set(), s4 = (t7) => {
      Object.keys(t7).forEach((e8) => {
        let r8 = n7.get(e8);
        void 0 === r8 && (r8 = [], n7.set(e8, r8)), r8.push(t7[e8]);
      });
    };
    return t6.forEach((t7) => {
      const e8 = t7.klass.importDOM;
      if (null == e8 || r7.has(e8))
        return;
      r7.add(e8);
      const n8 = e8.call(t7.klass);
      null !== n8 && s4(n8);
    }), e7 && s4(e7), n7;
  }(h7, f5 ? f5.import : void 0), d4);
  return void 0 !== c5 && (g6._pendingEditorState = c5, g6._dirtyType = lt2), g6;
}
var e5, n5, r5, s2, i3, o4, l2, c4, a2, u2, f4, d2, h4, g3, _2, p2, y2, m3, x2, v3, T2, C, S3, k2, b2, w2, N2, E2, P2, D2, F2, O2, I2, L, A, M2, z2, W, B2, R2, K2, J, U2, V2, $2, H, j2, q2, Q2, X, Y2, Z2, G2, tt, et3, nt2, rt2, st2, it, ot, lt2, ct, at, ut, ft, dt2, ht2, gt2, _t2, pt, yt2, mt2, xt, vt, Tt, Ct, St, kt, bt2, wt2, Nt, Et, Pt, Dt, Ft2, Ot, It, Lt, At, Mt, zt, Wt, Rt2, Jt, Ut, Vt, re, ie, bn, wn, Nn, En, Pn, Dn, Fn, On, In, Ln, An, Mn, zn, Wn, Bn, Rn, Kn, $n, or, lr, cr, ar, ur, fr, dr, hr, gr, _r, pr, yr, mr, br, Fr, Or, Ur, Hr, Xr, es, ss, as, fs, zs, Ws, Bs, Rs, Ks, Js, oi, ai, fi, _i, pi, yi, Ti, Ci, Si, ki, bi, Ei;
var init_Lexical_prod = __esm({
  "../../../node_modules/.pnpm/lexical@0.16.1/node_modules/lexical/Lexical.prod.mjs"() {
    e5 = {};
    n5 = {};
    r5 = {};
    s2 = {};
    i3 = {};
    o4 = {};
    l2 = {};
    c4 = {};
    a2 = {};
    u2 = {};
    f4 = {};
    d2 = {};
    h4 = {};
    g3 = {};
    _2 = {};
    p2 = {};
    y2 = {};
    m3 = {};
    x2 = {};
    v3 = {};
    T2 = {};
    C = {};
    S3 = {};
    k2 = {};
    b2 = {};
    w2 = {};
    N2 = {};
    E2 = {};
    P2 = {};
    D2 = {};
    F2 = {};
    O2 = {};
    I2 = {};
    L = {};
    A = {};
    M2 = {};
    z2 = {};
    W = {};
    B2 = {};
    R2 = {};
    K2 = {};
    J = {};
    U2 = {};
    V2 = {};
    $2 = {};
    H = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
    j2 = H && "documentMode" in document ? document.documentMode : null;
    q2 = H && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    Q2 = H && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    X = !(!H || !("InputEvent" in window) || j2) && "getTargetRanges" in new window.InputEvent("input");
    Y2 = H && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    Z2 = H && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    G2 = H && /Android/.test(navigator.userAgent);
    tt = H && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    et3 = H && G2 && tt;
    nt2 = H && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !tt;
    rt2 = 1;
    st2 = 3;
    it = 0;
    ot = 1;
    lt2 = 2;
    ct = 0;
    at = 1;
    ut = 2;
    ft = 1;
    dt2 = 2;
    ht2 = 4;
    gt2 = 8;
    _t2 = 16;
    pt = 32;
    yt2 = 64;
    mt2 = 128;
    xt = 112 | (3 | ht2 | gt2) | mt2;
    vt = 1;
    Tt = 2;
    Ct = 3;
    St = 4;
    kt = 5;
    bt2 = 6;
    wt2 = Y2 || Z2 || nt2 ? "\xA0" : "\u200B";
    Nt = "\n\n";
    Et = Q2 ? "\xA0" : wt2;
    Pt = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
    Dt = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
    Ft2 = new RegExp("^[^" + Dt + "]*[" + Pt + "]");
    Ot = new RegExp("^[^" + Pt + "]*[" + Dt + "]");
    It = { bold: 1, code: 16, highlight: mt2, italic: 2, strikethrough: ht2, subscript: 32, superscript: 64, underline: gt2 };
    Lt = { directionless: 1, unmergeable: 2 };
    At = { center: Tt, end: bt2, justify: St, left: vt, right: Ct, start: kt };
    Mt = { [Tt]: "center", [bt2]: "end", [St]: "justify", [vt]: "left", [Ct]: "right", [kt]: "start" };
    zt = { normal: 0, segmented: 2, token: 1 };
    Wt = { [ct]: "normal", [ut]: "segmented", [at]: "token" };
    Rt2 = Bt(function(t5) {
      const e6 = new URLSearchParams();
      e6.append("code", t5);
      for (let t6 = 1; t6 < arguments.length; t6++)
        e6.append("v", arguments[t6]);
      throw Error(`Minified Lexical error #${t5}; visit https://lexical.dev/docs/error?${e6} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
    });
    Jt = 100;
    Ut = false;
    Vt = 0;
    re = 1;
    ie = "function" == typeof queueMicrotask ? queueMicrotask : (t5) => {
      Promise.resolve().then(t5);
    };
    An = "";
    Mn = "";
    zn = null;
    Wn = "";
    Bn = false;
    Rn = false;
    Kn = null;
    $n = "40px";
    or = Object.freeze({});
    lr = 30;
    cr = [["keydown", function(t5, e6) {
      if (ar = t5.timeStamp, ur = t5.key, e6.isComposing())
        return;
      const { key: n6, shiftKey: r6, ctrlKey: o5, metaKey: l3, altKey: c5 } = t5;
      if (Xe(e6, _2, t5))
        return;
      if (null == n6)
        return;
      if (function(t6, e7, n7, r7) {
        return ze(t6) && !e7 && !r7 && !n7;
      }(n6, o5, c5, l3))
        Xe(e6, p2, t5);
      else if (function(t6, e7, n7, r7, s3) {
        return ze(t6) && !r7 && !n7 && (e7 || s3);
      }(n6, o5, r6, c5, l3))
        Xe(e6, y2, t5);
      else if (function(t6, e7, n7, r7) {
        return Me(t6) && !e7 && !r7 && !n7;
      }(n6, o5, c5, l3))
        Xe(e6, m3, t5);
      else if (function(t6, e7, n7, r7, s3) {
        return Me(t6) && !r7 && !n7 && (e7 || s3);
      }(n6, o5, r6, c5, l3))
        Xe(e6, x2, t5);
      else if (/* @__PURE__ */ function(t6, e7, n7) {
        return /* @__PURE__ */ function(t7) {
          return "ArrowUp" === t7;
        }(t6) && !e7 && !n7;
      }(n6, o5, l3))
        Xe(e6, v3, t5);
      else if (/* @__PURE__ */ function(t6, e7, n7) {
        return /* @__PURE__ */ function(t7) {
          return "ArrowDown" === t7;
        }(t6) && !e7 && !n7;
      }(n6, o5, l3))
        Xe(e6, T2, t5);
      else if (function(t6, e7) {
        return Be(t6) && e7;
      }(n6, r6))
        pr = true, Xe(e6, C, t5);
      else if (/* @__PURE__ */ function(t6) {
        return " " === t6;
      }(n6))
        Xe(e6, S3, t5);
      else if (function(t6, e7) {
        return q2 && e7 && "o" === t6.toLowerCase();
      }(n6, o5))
        t5.preventDefault(), pr = true, Xe(e6, i3, true);
      else if (function(t6, e7) {
        return Be(t6) && !e7;
      }(n6, r6))
        pr = false, Xe(e6, C, t5);
      else if (function(t6, e7, n7, r7) {
        return q2 ? !e7 && !n7 && (Re2(t6) || "h" === t6.toLowerCase() && r7) : !(r7 || e7 || n7) && Re2(t6);
      }(n6, c5, l3, o5))
        Re2(n6) ? Xe(e6, k2, t5) : (t5.preventDefault(), Xe(e6, s2, true));
      else if (/* @__PURE__ */ function(t6) {
        return "Escape" === t6;
      }(n6))
        Xe(e6, b2, t5);
      else if (function(t6, e7, n7, r7, s3) {
        return q2 ? !(n7 || r7 || s3) && (Ke(t6) || "d" === t6.toLowerCase() && e7) : !(e7 || r7 || s3) && Ke(t6);
      }(n6, o5, r6, c5, l3))
        Ke(n6) ? Xe(e6, w2, t5) : (t5.preventDefault(), Xe(e6, s2, false));
      else if (function(t6, e7, n7) {
        return Re2(t6) && (q2 ? e7 : n7);
      }(n6, c5, o5))
        t5.preventDefault(), Xe(e6, u2, true);
      else if (function(t6, e7, n7) {
        return Ke(t6) && (q2 ? e7 : n7);
      }(n6, c5, o5))
        t5.preventDefault(), Xe(e6, u2, false);
      else if (function(t6, e7) {
        return q2 && e7 && Re2(t6);
      }(n6, l3))
        t5.preventDefault(), Xe(e6, f4, true);
      else if (function(t6, e7) {
        return q2 && e7 && Ke(t6);
      }(n6, l3))
        t5.preventDefault(), Xe(e6, f4, false);
      else if (function(t6, e7, n7, r7) {
        return "b" === t6.toLowerCase() && !e7 && We(n7, r7);
      }(n6, c5, l3, o5))
        t5.preventDefault(), Xe(e6, d2, "bold");
      else if (function(t6, e7, n7, r7) {
        return "u" === t6.toLowerCase() && !e7 && We(n7, r7);
      }(n6, c5, l3, o5))
        t5.preventDefault(), Xe(e6, d2, "underline");
      else if (function(t6, e7, n7, r7) {
        return "i" === t6.toLowerCase() && !e7 && We(n7, r7);
      }(n6, c5, l3, o5))
        t5.preventDefault(), Xe(e6, d2, "italic");
      else if (/* @__PURE__ */ function(t6, e7, n7, r7) {
        return "Tab" === t6 && !e7 && !n7 && !r7;
      }(n6, c5, o5, l3))
        Xe(e6, N2, t5);
      else if (function(t6, e7, n7, r7) {
        return "z" === t6.toLowerCase() && !e7 && We(n7, r7);
      }(n6, r6, l3, o5))
        t5.preventDefault(), Xe(e6, h4, void 0);
      else if (function(t6, e7, n7, r7) {
        return q2 ? "z" === t6.toLowerCase() && n7 && e7 : "y" === t6.toLowerCase() && r7 || "z" === t6.toLowerCase() && r7 && e7;
      }(n6, r6, l3, o5))
        t5.preventDefault(), Xe(e6, g3, void 0);
      else {
        ds(e6._editorState._selection) ? !function(t6, e7, n7, r7) {
          return !e7 && "c" === t6.toLowerCase() && (q2 ? n7 : r7);
        }(n6, r6, l3, o5) ? !function(t6, e7, n7, r7) {
          return !e7 && "x" === t6.toLowerCase() && (q2 ? n7 : r7);
        }(n6, r6, l3, o5) ? Je(n6, l3, o5) && (t5.preventDefault(), Xe(e6, W, t5)) : (t5.preventDefault(), Xe(e6, z2, t5)) : (t5.preventDefault(), Xe(e6, M2, t5)) : !Q2 && Je(n6, l3, o5) && (t5.preventDefault(), Xe(e6, W, t5));
      }
      /* @__PURE__ */ (function(t6, e7, n7, r7) {
        return t6 || e7 || n7 || r7;
      })(o5, r6, c5, l3) && Xe(e6, $2, t5);
    }], ["pointerdown", function(t5, e6) {
      const n6 = t5.target, r6 = t5.pointerType;
      n6 instanceof Node && "touch" !== r6 && ii2(e6, () => {
        ui(Te2(n6)) || (_r = true);
      });
    }], ["compositionstart", function(t5, e6) {
      ii2(e6, () => {
        const n6 = ws();
        if (us(n6) && !e6.isComposing()) {
          const r6 = n6.anchor, s3 = n6.anchor.getNode();
          ye(r6.key), (t5.timeStamp < ar + lr || "element" === r6.type || !n6.isCollapsed() || s3.getFormat() !== n6.format || Gr(s3) && s3.getStyle() !== n6.style) && Xe(e6, l2, Et);
        }
      });
    }], ["compositionend", function(t5, e6) {
      Q2 ? yr = true : ii2(e6, () => {
        Sr(e6, t5.data);
      });
    }], ["input", function(t5, e6) {
      t5.stopPropagation(), ii2(e6, () => {
        const n6 = ws(), r6 = t5.data, s3 = Cr(t5);
        if (null != r6 && us(n6) && xr(n6, s3, r6, t5.timeStamp, false)) {
          yr && (Sr(e6, r6), yr = false);
          const s4 = n6.anchor.getNode(), i4 = _n(e6._window);
          if (null === i4)
            return;
          const o5 = n6.isBackward(), c5 = o5 ? n6.anchor.offset : n6.focus.offset, a3 = o5 ? n6.focus.offset : n6.anchor.offset;
          X && !n6.isCollapsed() && Gr(s4) && null !== i4.anchorNode && s4.getTextContent().slice(0, c5) + r6 + s4.getTextContent().slice(c5 + a3) === Oe3(i4.anchorNode) || Xe(e6, l2, r6);
          const u3 = r6.length;
          Q2 && u3 > 1 && "insertCompositionText" === t5.inputType && !e6.isComposing() && (n6.anchor.offset -= u3), Y2 || Z2 || nt2 || !e6.isComposing() || (ar = 0, ye(null));
        } else {
          Ie(false, e6, null !== r6 ? r6 : void 0), yr && (Sr(e6, r6 || void 0), yr = false);
        }
        Vs(), Xt(js());
      }), dr = null;
    }], ["click", function(t5, e6) {
      ii2(e6, () => {
        const n6 = ws(), s3 = _n(e6._window), i4 = Ns();
        if (s3) {
          if (us(n6)) {
            const e7 = n6.anchor, r6 = e7.getNode();
            if ("element" === e7.type && 0 === e7.offset && n6.isCollapsed() && !di(r6) && 1 === ke3().getChildrenSize() && r6.getTopLevelElementOrThrow().isEmpty() && null !== i4 && n6.is(i4))
              s3.removeAllRanges(), n6.dirty = true;
            else if (3 === t5.detail && !n6.isCollapsed()) {
              r6 !== n6.focus.getNode() && (li(r6) ? r6.select(0) : r6.getParentOrThrow().select(0));
            }
          } else if ("touch" === t5.pointerType) {
            const n7 = s3.anchorNode;
            if (null !== n7) {
              const r6 = n7.nodeType;
              if (r6 === rt2 || r6 === st2) {
                we(bs(i4, s3, e6, t5));
              }
            }
          }
        }
        Xe(e6, r5, t5);
      });
    }], ["cut", or], ["copy", or], ["dragstart", or], ["dragover", or], ["dragend", or], ["paste", or], ["focus", or], ["blur", or], ["drop", or]];
    X && cr.push(["beforeinput", (t5, e6) => function(t6, e7) {
      const n6 = t6.inputType, r6 = Cr(t6);
      if ("deleteCompositionText" === n6 || Q2 && Qe(e7))
        return;
      if ("insertCompositionText" === n6)
        return;
      ii2(e7, () => {
        const _5 = ws();
        if ("deleteContentBackward" === n6) {
          if (null === _5) {
            const t7 = Ns();
            if (!us(t7))
              return;
            we(t7.clone());
          }
          if (us(_5)) {
            const n7 = _5.anchor.key === _5.focus.key;
            if (p5 = t6.timeStamp, "MediaLast" === ur && p5 < ar + lr && e7.isComposing() && n7) {
              if (ye(null), ar = 0, setTimeout(() => {
                ii2(e7, () => {
                  ye(null);
                });
              }, lr), us(_5)) {
                const t7 = _5.anchor.getNode();
                t7.markDirty(), _5.format = t7.getFormat(), Gr(t7) || Rt2(142), _5.style = t7.getStyle();
              }
            } else {
              ye(null), t6.preventDefault();
              const r7 = _5.anchor.getNode().getTextContent(), i4 = 0 === _5.anchor.offset && _5.focus.offset === r7.length;
              et3 && n7 && !i4 || Xe(e7, s2, true);
            }
            return;
          }
        }
        var p5;
        if (!us(_5))
          return;
        const y7 = t6.data;
        null !== dr && Ie(false, e7, dr), _5.dirty && null === dr || !_5.isCollapsed() || di(_5.anchor.getNode()) || null === r6 || _5.applyDOMRange(r6), dr = null;
        const m7 = _5.anchor, x6 = _5.focus, v8 = m7.getNode(), T6 = x6.getNode();
        if ("insertText" !== n6 && "insertTranspose" !== n6)
          switch (t6.preventDefault(), n6) {
            case "insertFromYank":
            case "insertFromDrop":
            case "insertReplacementText":
              Xe(e7, l2, t6);
              break;
            case "insertFromComposition":
              ye(null), Xe(e7, l2, t6);
              break;
            case "insertLineBreak":
              ye(null), Xe(e7, i3, false);
              break;
            case "insertParagraph":
              ye(null), pr && !Z2 ? (pr = false, Xe(e7, i3, false)) : Xe(e7, o4, void 0);
              break;
            case "insertFromPaste":
            case "insertFromPasteAsQuotation":
              Xe(e7, c4, t6);
              break;
            case "deleteByComposition":
              (function(t7, e8) {
                return t7 !== e8 || li(t7) || li(e8) || !t7.isToken() || !e8.isToken();
              })(v8, T6) && Xe(e7, a2, t6);
              break;
            case "deleteByDrag":
            case "deleteByCut":
              Xe(e7, a2, t6);
              break;
            case "deleteContent":
              Xe(e7, s2, false);
              break;
            case "deleteWordBackward":
              Xe(e7, u2, true);
              break;
            case "deleteWordForward":
              Xe(e7, u2, false);
              break;
            case "deleteHardLineBackward":
            case "deleteSoftLineBackward":
              Xe(e7, f4, true);
              break;
            case "deleteContentForward":
            case "deleteHardLineForward":
            case "deleteSoftLineForward":
              Xe(e7, f4, false);
              break;
            case "formatStrikeThrough":
              Xe(e7, d2, "strikethrough");
              break;
            case "formatBold":
              Xe(e7, d2, "bold");
              break;
            case "formatItalic":
              Xe(e7, d2, "italic");
              break;
            case "formatUnderline":
              Xe(e7, d2, "underline");
              break;
            case "historyUndo":
              Xe(e7, h4, void 0);
              break;
            case "historyRedo":
              Xe(e7, g3, void 0);
          }
        else {
          if ("\n" === y7)
            t6.preventDefault(), Xe(e7, i3, false);
          else if (y7 === Nt)
            t6.preventDefault(), Xe(e7, o4, void 0);
          else if (null == y7 && t6.dataTransfer) {
            const e8 = t6.dataTransfer.getData("text/plain");
            t6.preventDefault(), _5.insertRawText(e8);
          } else
            null != y7 && xr(_5, r6, y7, t6.timeStamp, true) ? (t6.preventDefault(), Xe(e7, l2, y7)) : dr = y7;
          fr = t6.timeStamp;
        }
      });
    }(t5, e6)]);
    ar = 0;
    ur = null;
    fr = 0;
    dr = null;
    hr = /* @__PURE__ */ new WeakMap();
    gr = false;
    _r = false;
    pr = false;
    yr = false;
    mr = [0, "", 0, "root", 0];
    br = /* @__PURE__ */ new Map();
    Fr = class {
      static getType() {
        Rt2(64, this.name);
      }
      static clone(t5) {
        Rt2(65, this.name);
      }
      constructor(t5) {
        this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, ge(this, t5);
      }
      getType() {
        return this.__type;
      }
      isInline() {
        Rt2(137, this.constructor.name);
      }
      isAttached() {
        let t5 = this.__key;
        for (; null !== t5; ) {
          if ("root" === t5)
            return true;
          const e6 = xe2(t5);
          if (null === e6)
            break;
          t5 = e6.__parent;
        }
        return false;
      }
      isSelected(t5) {
        const e6 = t5 || ws();
        if (null == e6)
          return false;
        const n6 = e6.getNodes().some((t6) => t6.__key === this.__key);
        return (Gr(this) || !us(e6) || "element" !== e6.anchor.type || "element" !== e6.focus.type || e6.anchor.key !== e6.focus.key || e6.anchor.offset !== e6.focus.offset) && n6;
      }
      getKey() {
        return this.__key;
      }
      getIndexWithinParent() {
        const t5 = this.getParent();
        if (null === t5)
          return -1;
        let e6 = t5.getFirstChild(), n6 = 0;
        for (; null !== e6; ) {
          if (this.is(e6))
            return n6;
          n6++, e6 = e6.getNextSibling();
        }
        return -1;
      }
      getParent() {
        const t5 = this.getLatest().__parent;
        return null === t5 ? null : xe2(t5);
      }
      getParentOrThrow() {
        const t5 = this.getParent();
        return null === t5 && Rt2(66, this.__key), t5;
      }
      getTopLevelElement() {
        let t5 = this;
        for (; null !== t5; ) {
          const e6 = t5.getParent();
          if (ln(e6))
            return li(t5) || Rt2(138), t5;
          t5 = e6;
        }
        return null;
      }
      getTopLevelElementOrThrow() {
        const t5 = this.getTopLevelElement();
        return null === t5 && Rt2(67, this.__key), t5;
      }
      getParents() {
        const t5 = [];
        let e6 = this.getParent();
        for (; null !== e6; )
          t5.push(e6), e6 = e6.getParent();
        return t5;
      }
      getParentKeys() {
        const t5 = [];
        let e6 = this.getParent();
        for (; null !== e6; )
          t5.push(e6.__key), e6 = e6.getParent();
        return t5;
      }
      getPreviousSibling() {
        const t5 = this.getLatest().__prev;
        return null === t5 ? null : xe2(t5);
      }
      getPreviousSiblings() {
        const t5 = [], e6 = this.getParent();
        if (null === e6)
          return t5;
        let n6 = e6.getFirstChild();
        for (; null !== n6 && !n6.is(this); )
          t5.push(n6), n6 = n6.getNextSibling();
        return t5;
      }
      getNextSibling() {
        const t5 = this.getLatest().__next;
        return null === t5 ? null : xe2(t5);
      }
      getNextSiblings() {
        const t5 = [];
        let e6 = this.getNextSibling();
        for (; null !== e6; )
          t5.push(e6), e6 = e6.getNextSibling();
        return t5;
      }
      getCommonAncestor(t5) {
        const e6 = this.getParents(), n6 = t5.getParents();
        li(this) && e6.unshift(this), li(t5) && n6.unshift(t5);
        const r6 = e6.length, s3 = n6.length;
        if (0 === r6 || 0 === s3 || e6[r6 - 1] !== n6[s3 - 1])
          return null;
        const i4 = new Set(n6);
        for (let t6 = 0; t6 < r6; t6++) {
          const n7 = e6[t6];
          if (i4.has(n7))
            return n7;
        }
        return null;
      }
      is(t5) {
        return null != t5 && this.__key === t5.__key;
      }
      isBefore(t5) {
        if (this === t5)
          return false;
        if (t5.isParentOf(this))
          return true;
        if (this.isParentOf(t5))
          return false;
        const e6 = this.getCommonAncestor(t5);
        let n6 = 0, r6 = 0, s3 = this;
        for (; ; ) {
          const t6 = s3.getParentOrThrow();
          if (t6 === e6) {
            n6 = s3.getIndexWithinParent();
            break;
          }
          s3 = t6;
        }
        for (s3 = t5; ; ) {
          const t6 = s3.getParentOrThrow();
          if (t6 === e6) {
            r6 = s3.getIndexWithinParent();
            break;
          }
          s3 = t6;
        }
        return n6 < r6;
      }
      isParentOf(t5) {
        const e6 = this.__key;
        if (e6 === t5.__key)
          return false;
        let n6 = t5;
        for (; null !== n6; ) {
          if (n6.__key === e6)
            return true;
          n6 = n6.getParent();
        }
        return false;
      }
      getNodesBetween(t5) {
        const e6 = this.isBefore(t5), n6 = [], r6 = /* @__PURE__ */ new Set();
        let s3 = this;
        for (; null !== s3; ) {
          const i4 = s3.__key;
          if (r6.has(i4) || (r6.add(i4), n6.push(s3)), s3 === t5)
            break;
          const o5 = li(s3) ? e6 ? s3.getFirstChild() : s3.getLastChild() : null;
          if (null !== o5) {
            s3 = o5;
            continue;
          }
          const l3 = e6 ? s3.getNextSibling() : s3.getPreviousSibling();
          if (null !== l3) {
            s3 = l3;
            continue;
          }
          const c5 = s3.getParentOrThrow();
          if (r6.has(c5.__key) || n6.push(c5), c5 === t5)
            break;
          let a3 = null, u3 = c5;
          do {
            if (null === u3 && Rt2(68), a3 = e6 ? u3.getNextSibling() : u3.getPreviousSibling(), u3 = u3.getParent(), null === u3)
              break;
            null !== a3 || r6.has(u3.__key) || n6.push(u3);
          } while (null === a3);
          s3 = a3;
        }
        return e6 || n6.reverse(), n6;
      }
      isDirty() {
        const t5 = js()._dirtyLeaves;
        return null !== t5 && t5.has(this.__key);
      }
      getLatest() {
        const t5 = xe2(this.__key);
        return null === t5 && Rt2(113), t5;
      }
      getWritable() {
        Vs();
        const t5 = Hs(), e6 = js(), n6 = t5._nodeMap, r6 = this.__key, s3 = this.getLatest(), i4 = s3.__parent, o5 = e6._cloneNotNeeded, l3 = ws();
        if (null !== l3 && l3.setCachedNodes(null), o5.has(r6))
          return pe(s3), s3;
        const c5 = s3.constructor.clone(s3);
        return c5.__parent = i4, c5.__next = s3.__next, c5.__prev = s3.__prev, li(s3) && li(c5) ? (vi(s3) && vi(c5) && (c5.__textFormat = s3.__textFormat), c5.__first = s3.__first, c5.__last = s3.__last, c5.__size = s3.__size, c5.__indent = s3.__indent, c5.__format = s3.__format, c5.__dir = s3.__dir) : Gr(s3) && Gr(c5) && (c5.__format = s3.__format, c5.__style = s3.__style, c5.__mode = s3.__mode, c5.__detail = s3.__detail), o5.add(r6), c5.__key = r6, pe(c5), n6.set(r6, c5), c5;
      }
      getTextContent() {
        return "";
      }
      getTextContentSize() {
        return this.getTextContent().length;
      }
      createDOM(t5, e6) {
        Rt2(70);
      }
      updateDOM(t5, e6, n6) {
        Rt2(71);
      }
      exportDOM(t5) {
        return { element: this.createDOM(t5._config, t5) };
      }
      exportJSON() {
        Rt2(72);
      }
      static importJSON(t5) {
        Rt2(18, this.name);
      }
      static transform() {
        return null;
      }
      remove(t5) {
        Dr(this, true, t5);
      }
      replace(t5, e6) {
        Vs();
        let n6 = ws();
        null !== n6 && (n6 = n6.clone()), un(this, t5);
        const r6 = this.getLatest(), s3 = this.__key, i4 = t5.__key, o5 = t5.getWritable(), l3 = this.getParentOrThrow().getWritable(), c5 = l3.__size;
        _e(o5);
        const a3 = r6.getPreviousSibling(), u3 = r6.getNextSibling(), f5 = r6.__prev, d4 = r6.__next, h7 = r6.__parent;
        if (Dr(r6, false, true), null === a3)
          l3.__first = i4;
        else {
          a3.getWritable().__next = i4;
        }
        if (o5.__prev = f5, null === u3)
          l3.__last = i4;
        else {
          u3.getWritable().__prev = i4;
        }
        if (o5.__next = d4, o5.__parent = h7, l3.__size = c5, e6 && (li(this) && li(o5) || Rt2(139), this.getChildren().forEach((t6) => {
          o5.append(t6);
        })), us(n6)) {
          we(n6);
          const t6 = n6.anchor, e7 = n6.focus;
          t6.key === s3 && ls(t6, o5), e7.key === s3 && ls(e7, o5);
        }
        return me() === s3 && ye(i4), o5;
      }
      insertAfter(t5, e6 = true) {
        Vs(), un(this, t5);
        const n6 = this.getWritable(), r6 = t5.getWritable(), s3 = r6.getParent(), i4 = ws();
        let o5 = false, l3 = false;
        if (null !== s3) {
          const e7 = t5.getIndexWithinParent();
          if (_e(r6), us(i4)) {
            const t6 = s3.__key, n7 = i4.anchor, r7 = i4.focus;
            o5 = "element" === n7.type && n7.key === t6 && n7.offset === e7 + 1, l3 = "element" === r7.type && r7.key === t6 && r7.offset === e7 + 1;
          }
        }
        const c5 = this.getNextSibling(), a3 = this.getParentOrThrow().getWritable(), u3 = r6.__key, f5 = n6.__next;
        if (null === c5)
          a3.__last = u3;
        else {
          c5.getWritable().__prev = u3;
        }
        if (a3.__size++, n6.__next = u3, r6.__next = f5, r6.__prev = n6.__key, r6.__parent = n6.__parent, e6 && us(i4)) {
          const t6 = this.getIndexWithinParent();
          Es(i4, a3, t6 + 1);
          const e7 = a3.__key;
          o5 && i4.anchor.set(e7, t6 + 2, "element"), l3 && i4.focus.set(e7, t6 + 2, "element");
        }
        return t5;
      }
      insertBefore(t5, e6 = true) {
        Vs(), un(this, t5);
        const n6 = this.getWritable(), r6 = t5.getWritable(), s3 = r6.__key;
        _e(r6);
        const i4 = this.getPreviousSibling(), o5 = this.getParentOrThrow().getWritable(), l3 = n6.__prev, c5 = this.getIndexWithinParent();
        if (null === i4)
          o5.__first = s3;
        else {
          i4.getWritable().__next = s3;
        }
        o5.__size++, n6.__prev = s3, r6.__prev = l3, r6.__next = n6.__key, r6.__parent = n6.__parent;
        const a3 = ws();
        if (e6 && us(a3)) {
          Es(a3, this.getParentOrThrow(), c5);
        }
        return t5;
      }
      isParentRequired() {
        return false;
      }
      createParentElementNode() {
        return xi();
      }
      selectStart() {
        return this.selectPrevious();
      }
      selectEnd() {
        return this.selectNext(0, 0);
      }
      selectPrevious(t5, e6) {
        Vs();
        const n6 = this.getPreviousSibling(), r6 = this.getParentOrThrow();
        if (null === n6)
          return r6.select(0, 0);
        if (li(n6))
          return n6.select();
        if (!Gr(n6)) {
          const t6 = n6.getIndexWithinParent() + 1;
          return r6.select(t6, t6);
        }
        return n6.select(t5, e6);
      }
      selectNext(t5, e6) {
        Vs();
        const n6 = this.getNextSibling(), r6 = this.getParentOrThrow();
        if (null === n6)
          return r6.select();
        if (li(n6))
          return n6.select(0, 0);
        if (!Gr(n6)) {
          const t6 = n6.getIndexWithinParent();
          return r6.select(t6, t6);
        }
        return n6.select(t5, e6);
      }
      markDirty() {
        this.getWritable();
      }
    };
    Or = class _Or extends Fr {
      static getType() {
        return "linebreak";
      }
      static clone(t5) {
        return new _Or(t5.__key);
      }
      constructor(t5) {
        super(t5);
      }
      getTextContent() {
        return "\n";
      }
      createDOM() {
        return document.createElement("br");
      }
      updateDOM() {
        return false;
      }
      static importDOM() {
        return { br: (t5) => function(t6) {
          const e6 = t6.parentElement;
          if (null !== e6) {
            const n6 = e6.firstChild;
            if (n6 === t6 || n6.nextSibling === t6 && Mr(n6)) {
              const n7 = e6.lastChild;
              if (n7 === t6 || n7.previousSibling === t6 && Mr(n7))
                return true;
            }
          }
          return false;
        }(t5) ? null : { conversion: Ir, priority: 0 } };
      }
      static importJSON(t5) {
        return Lr();
      }
      exportJSON() {
        return { type: "linebreak", version: 1 };
      }
    };
    Ur = class _Ur extends Fr {
      static getType() {
        return "text";
      }
      static clone(t5) {
        return new _Ur(t5.__text, t5.__key);
      }
      constructor(t5, e6) {
        super(e6), this.__text = t5, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
      }
      getFormat() {
        return this.getLatest().__format;
      }
      getDetail() {
        return this.getLatest().__detail;
      }
      getMode() {
        const t5 = this.getLatest();
        return Wt[t5.__mode];
      }
      getStyle() {
        return this.getLatest().__style;
      }
      isToken() {
        return 1 === this.getLatest().__mode;
      }
      isComposing() {
        return this.__key === me();
      }
      isSegmented() {
        return 2 === this.getLatest().__mode;
      }
      isDirectionless() {
        return !!(1 & this.getLatest().__detail);
      }
      isUnmergeable() {
        return !!(2 & this.getLatest().__detail);
      }
      hasFormat(t5) {
        const e6 = It[t5];
        return !!(this.getFormat() & e6);
      }
      isSimpleText() {
        return "text" === this.__type && 0 === this.__mode;
      }
      getTextContent() {
        return this.getLatest().__text;
      }
      getFormatFlags(t5, e6) {
        return de(this.getLatest().__format, t5, e6);
      }
      canHaveFormat() {
        return true;
      }
      createDOM(t5, e6) {
        const n6 = this.__format, r6 = zr(0, n6), s3 = Wr(0, n6), i4 = null === r6 ? s3 : r6, o5 = document.createElement(i4);
        let l3 = o5;
        this.hasFormat("code") && o5.setAttribute("spellcheck", "false"), null !== r6 && (l3 = document.createElement(s3), o5.appendChild(l3));
        Kr(l3, this, 0, n6, this.__text, t5);
        const c5 = this.__style;
        return "" !== c5 && (o5.style.cssText = c5), o5;
      }
      updateDOM(t5, e6, n6) {
        const r6 = this.__text, s3 = t5.__format, i4 = this.__format, o5 = zr(0, s3), l3 = zr(0, i4), c5 = Wr(0, s3), a3 = Wr(0, i4);
        if ((null === o5 ? c5 : o5) !== (null === l3 ? a3 : l3))
          return true;
        if (o5 === l3 && c5 !== a3) {
          const t6 = e6.firstChild;
          null == t6 && Rt2(48);
          const s4 = document.createElement(a3);
          return Kr(s4, this, 0, i4, r6, n6), e6.replaceChild(s4, t6), false;
        }
        let u3 = e6;
        null !== l3 && null !== o5 && (u3 = e6.firstChild, null == u3 && Rt2(49)), Rr(r6, u3, this);
        const f5 = n6.theme.text;
        void 0 !== f5 && s3 !== i4 && Br(0, s3, i4, u3, f5);
        const d4 = t5.__style, h7 = this.__style;
        return d4 !== h7 && (e6.style.cssText = h7), false;
      }
      static importDOM() {
        return { "#text": () => ({ conversion: qr, priority: 0 }), b: () => ({ conversion: $r, priority: 0 }), code: () => ({ conversion: Yr, priority: 0 }), em: () => ({ conversion: Yr, priority: 0 }), i: () => ({ conversion: Yr, priority: 0 }), s: () => ({ conversion: Yr, priority: 0 }), span: () => ({ conversion: Vr, priority: 0 }), strong: () => ({ conversion: Yr, priority: 0 }), sub: () => ({ conversion: Yr, priority: 0 }), sup: () => ({ conversion: Yr, priority: 0 }), u: () => ({ conversion: Yr, priority: 0 }) };
      }
      static importJSON(t5) {
        const e6 = Zr(t5.text);
        return e6.setFormat(t5.format), e6.setDetail(t5.detail), e6.setMode(t5.mode), e6.setStyle(t5.style), e6;
      }
      exportDOM(t5) {
        let { element: e6 } = super.exportDOM(t5);
        return null !== e6 && mn(e6) || Rt2(132), e6.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (e6 = Jr(e6, "b")), this.hasFormat("italic") && (e6 = Jr(e6, "i")), this.hasFormat("strikethrough") && (e6 = Jr(e6, "s")), this.hasFormat("underline") && (e6 = Jr(e6, "u")), { element: e6 };
      }
      exportJSON() {
        return { detail: this.getDetail(), format: this.getFormat(), mode: this.getMode(), style: this.getStyle(), text: this.getTextContent(), type: "text", version: 1 };
      }
      selectionTransform(t5, e6) {
      }
      setFormat(t5) {
        const e6 = this.getWritable();
        return e6.__format = "string" == typeof t5 ? It[t5] : t5, e6;
      }
      setDetail(t5) {
        const e6 = this.getWritable();
        return e6.__detail = "string" == typeof t5 ? Lt[t5] : t5, e6;
      }
      setStyle(t5) {
        const e6 = this.getWritable();
        return e6.__style = t5, e6;
      }
      toggleFormat(t5) {
        const e6 = de(this.getFormat(), t5, null);
        return this.setFormat(e6);
      }
      toggleDirectionless() {
        const t5 = this.getWritable();
        return t5.__detail ^= 1, t5;
      }
      toggleUnmergeable() {
        const t5 = this.getWritable();
        return t5.__detail ^= 2, t5;
      }
      setMode(t5) {
        const e6 = zt[t5];
        if (this.__mode === e6)
          return this;
        const n6 = this.getWritable();
        return n6.__mode = e6, n6;
      }
      setTextContent(t5) {
        if (this.__text === t5)
          return this;
        const e6 = this.getWritable();
        return e6.__text = t5, e6;
      }
      select(t5, e6) {
        Vs();
        let n6 = t5, r6 = e6;
        const s3 = ws(), i4 = this.getTextContent(), o5 = this.__key;
        if ("string" == typeof i4) {
          const t6 = i4.length;
          void 0 === n6 && (n6 = t6), void 0 === r6 && (r6 = t6);
        } else
          n6 = 0, r6 = 0;
        if (!us(s3))
          return Ts(o5, n6, o5, r6, "text", "text");
        {
          const t6 = me();
          t6 !== s3.anchor.key && t6 !== s3.focus.key || ye(o5), s3.setTextNodeRange(this, n6, this, r6);
        }
        return s3;
      }
      selectStart() {
        return this.select(0, 0);
      }
      selectEnd() {
        const t5 = this.getTextContentSize();
        return this.select(t5, t5);
      }
      spliceText(t5, e6, n6, r6) {
        const s3 = this.getWritable(), i4 = s3.__text, o5 = n6.length;
        let l3 = t5;
        l3 < 0 && (l3 = o5 + l3, l3 < 0 && (l3 = 0));
        const c5 = ws();
        if (r6 && us(c5)) {
          const e7 = t5 + o5;
          c5.setTextNodeRange(s3, e7, s3, e7);
        }
        const a3 = i4.slice(0, l3) + n6 + i4.slice(l3 + e6);
        return s3.__text = a3, s3;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      splitText(...t5) {
        Vs();
        const e6 = this.getLatest(), n6 = e6.getTextContent(), r6 = e6.__key, s3 = me(), i4 = new Set(t5), o5 = [], l3 = n6.length;
        let c5 = "";
        for (let t6 = 0; t6 < l3; t6++)
          "" !== c5 && i4.has(t6) && (o5.push(c5), c5 = ""), c5 += n6[t6];
        "" !== c5 && o5.push(c5);
        const a3 = o5.length;
        if (0 === a3)
          return [];
        if (o5[0] === n6)
          return [e6];
        const u3 = o5[0], f5 = e6.getParentOrThrow();
        let d4;
        const h7 = e6.getFormat(), g6 = e6.getStyle(), _5 = e6.__detail;
        let p5 = false;
        e6.isSegmented() ? (d4 = Zr(u3), d4.__format = h7, d4.__style = g6, d4.__detail = _5, p5 = true) : (d4 = e6.getWritable(), d4.__text = u3);
        const y7 = ws(), m7 = [d4];
        let x6 = u3.length;
        for (let t6 = 1; t6 < a3; t6++) {
          const e7 = o5[t6], n7 = e7.length, i5 = Zr(e7).getWritable();
          i5.__format = h7, i5.__style = g6, i5.__detail = _5;
          const l4 = i5.__key, c6 = x6 + n7;
          if (us(y7)) {
            const t7 = y7.anchor, e8 = y7.focus;
            t7.key === r6 && "text" === t7.type && t7.offset > x6 && t7.offset <= c6 && (t7.key = l4, t7.offset -= x6, y7.dirty = true), e8.key === r6 && "text" === e8.type && e8.offset > x6 && e8.offset <= c6 && (e8.key = l4, e8.offset -= x6, y7.dirty = true);
          }
          s3 === r6 && ye(l4), x6 = c6, m7.push(i5);
        }
        !function(t6) {
          const e7 = t6.getPreviousSibling(), n7 = t6.getNextSibling();
          null !== e7 && pe(e7), null !== n7 && pe(n7);
        }(this);
        const v8 = f5.getWritable(), T6 = this.getIndexWithinParent();
        return p5 ? (v8.splice(T6, 0, m7), this.remove()) : v8.splice(T6, 1, m7), us(y7) && Es(y7, f5, T6, a3 - 1), m7;
      }
      mergeWithSibling(t5) {
        const e6 = t5 === this.getPreviousSibling();
        e6 || t5 === this.getNextSibling() || Rt2(50);
        const n6 = this.__key, r6 = t5.__key, s3 = this.__text, i4 = s3.length;
        me() === r6 && ye(n6);
        const o5 = ws();
        if (us(o5)) {
          const s4 = o5.anchor, l4 = o5.focus;
          null !== s4 && s4.key === r6 && (Fs(s4, e6, n6, t5, i4), o5.dirty = true), null !== l4 && l4.key === r6 && (Fs(l4, e6, n6, t5, i4), o5.dirty = true);
        }
        const l3 = t5.__text, c5 = e6 ? l3 + s3 : s3 + l3;
        this.setTextContent(c5);
        const a3 = this.getWritable();
        return t5.remove(), a3;
      }
      isTextEntity() {
        return false;
      }
    };
    Hr = /* @__PURE__ */ new WeakMap();
    Xr = { code: "code", em: "italic", i: "italic", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
    es = class _es extends Ur {
      static getType() {
        return "tab";
      }
      static clone(t5) {
        const e6 = new _es(t5.__key);
        return e6.__text = t5.__text, e6.__format = t5.__format, e6.__style = t5.__style, e6;
      }
      constructor(t5) {
        super("	", t5), this.__detail = 2;
      }
      static importDOM() {
        return null;
      }
      static importJSON(t5) {
        const e6 = ns();
        return e6.setFormat(t5.format), e6.setStyle(t5.style), e6;
      }
      exportJSON() {
        return { ...super.exportJSON(), type: "tab", version: 1 };
      }
      setTextContent(t5) {
        Rt2(126);
      }
      setDetail(t5) {
        Rt2(127);
      }
      setMode(t5) {
        Rt2(128);
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
    };
    ss = class {
      constructor(t5, e6, n6) {
        this._selection = null, this.key = t5, this.offset = e6, this.type = n6;
      }
      is(t5) {
        return this.key === t5.key && this.offset === t5.offset && this.type === t5.type;
      }
      isBefore(t5) {
        let e6 = this.getNode(), n6 = t5.getNode();
        const r6 = this.offset, s3 = t5.offset;
        if (li(e6)) {
          const t6 = e6.getDescendantByIndex(r6);
          e6 = null != t6 ? t6 : e6;
        }
        if (li(n6)) {
          const t6 = n6.getDescendantByIndex(s3);
          n6 = null != t6 ? t6 : n6;
        }
        return e6 === n6 ? r6 < s3 : e6.isBefore(n6);
      }
      getNode() {
        const t5 = xe2(this.key);
        return null === t5 && Rt2(20), t5;
      }
      set(t5, e6, n6) {
        const r6 = this._selection, s3 = this.key;
        this.key = t5, this.offset = e6, this.type = n6, Us() || (me() === s3 && ye(t5), null !== r6 && (r6.setCachedNodes(null), r6.dirty = true));
      }
    };
    as = class _as {
      constructor(t5) {
        this._cachedNodes = null, this._nodes = t5, this.dirty = false;
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(t5) {
        this._cachedNodes = t5;
      }
      is(t5) {
        if (!ds(t5))
          return false;
        const e6 = this._nodes, n6 = t5._nodes;
        return e6.size === n6.size && Array.from(e6).every((t6) => n6.has(t6));
      }
      isCollapsed() {
        return false;
      }
      isBackward() {
        return false;
      }
      getStartEndPoints() {
        return null;
      }
      add(t5) {
        this.dirty = true, this._nodes.add(t5), this._cachedNodes = null;
      }
      delete(t5) {
        this.dirty = true, this._nodes.delete(t5), this._cachedNodes = null;
      }
      clear() {
        this.dirty = true, this._nodes.clear(), this._cachedNodes = null;
      }
      has(t5) {
        return this._nodes.has(t5);
      }
      clone() {
        return new _as(new Set(this._nodes));
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(t5) {
      }
      insertText() {
      }
      insertNodes(t5) {
        const e6 = this.getNodes(), n6 = e6.length, r6 = e6[n6 - 1];
        let s3;
        if (Gr(r6))
          s3 = r6.select();
        else {
          const t6 = r6.getIndexWithinParent() + 1;
          s3 = r6.getParentOrThrow().select(t6, t6);
        }
        s3.insertNodes(t5);
        for (let t6 = 0; t6 < n6; t6++)
          e6[t6].remove();
      }
      getNodes() {
        const t5 = this._cachedNodes;
        if (null !== t5)
          return t5;
        const e6 = this._nodes, n6 = [];
        for (const t6 of e6) {
          const e7 = xe2(t6);
          null !== e7 && n6.push(e7);
        }
        return Us() || (this._cachedNodes = n6), n6;
      }
      getTextContent() {
        const t5 = this.getNodes();
        let e6 = "";
        for (let n6 = 0; n6 < t5.length; n6++)
          e6 += t5[n6].getTextContent();
        return e6;
      }
    };
    fs = class _fs {
      constructor(t5, e6, n6, r6) {
        this.anchor = t5, this.focus = e6, t5._selection = this, e6._selection = this, this._cachedNodes = null, this.format = n6, this.style = r6, this.dirty = false;
      }
      getCachedNodes() {
        return this._cachedNodes;
      }
      setCachedNodes(t5) {
        this._cachedNodes = t5;
      }
      is(t5) {
        return !!us(t5) && (this.anchor.is(t5.anchor) && this.focus.is(t5.focus) && this.format === t5.format && this.style === t5.style);
      }
      isCollapsed() {
        return this.anchor.is(this.focus);
      }
      getNodes() {
        const t5 = this._cachedNodes;
        if (null !== t5)
          return t5;
        const e6 = this.anchor, n6 = this.focus, r6 = e6.isBefore(n6), s3 = r6 ? e6 : n6, i4 = r6 ? n6 : e6;
        let o5 = s3.getNode(), l3 = i4.getNode();
        const c5 = s3.offset, a3 = i4.offset;
        if (li(o5)) {
          const t6 = o5.getDescendantByIndex(c5);
          o5 = null != t6 ? t6 : o5;
        }
        if (li(l3)) {
          let t6 = l3.getDescendantByIndex(a3);
          null !== t6 && t6 !== o5 && l3.getChildAtIndex(a3) === t6 && (t6 = t6.getPreviousSibling()), l3 = null != t6 ? t6 : l3;
        }
        let u3;
        return u3 = o5.is(l3) ? li(o5) && o5.getChildrenSize() > 0 ? [] : [o5] : o5.getNodesBetween(l3), Us() || (this._cachedNodes = u3), u3;
      }
      setTextNodeRange(t5, e6, n6, r6) {
        cs(this.anchor, t5.__key, e6, "text"), cs(this.focus, n6.__key, r6, "text"), this._cachedNodes = null, this.dirty = true;
      }
      getTextContent() {
        const t5 = this.getNodes();
        if (0 === t5.length)
          return "";
        const e6 = t5[0], n6 = t5[t5.length - 1], r6 = this.anchor, s3 = this.focus, i4 = r6.isBefore(s3), [o5, l3] = gs(this);
        let c5 = "", a3 = true;
        for (let u3 = 0; u3 < t5.length; u3++) {
          const f5 = t5[u3];
          if (li(f5) && !f5.isInline())
            a3 || (c5 += "\n"), a3 = !f5.isEmpty();
          else if (a3 = false, Gr(f5)) {
            let t6 = f5.getTextContent();
            f5 === e6 ? f5 === n6 ? "element" === r6.type && "element" === s3.type && s3.offset !== r6.offset || (t6 = o5 < l3 ? t6.slice(o5, l3) : t6.slice(l3, o5)) : t6 = i4 ? t6.slice(o5) : t6.slice(l3) : f5 === n6 && (t6 = i4 ? t6.slice(0, l3) : t6.slice(0, o5)), c5 += t6;
          } else
            !ui(f5) && !Ar(f5) || f5 === n6 && this.isCollapsed() || (c5 += f5.getTextContent());
        }
        return c5;
      }
      applyDOMRange(t5) {
        const e6 = js(), n6 = e6.getEditorState()._selection, r6 = xs(t5.startContainer, t5.startOffset, t5.endContainer, t5.endOffset, e6, n6);
        if (null === r6)
          return;
        const [s3, i4] = r6;
        cs(this.anchor, s3.key, s3.offset, s3.type), cs(this.focus, i4.key, i4.offset, i4.type), this._cachedNodes = null;
      }
      clone() {
        const t5 = this.anchor, e6 = this.focus;
        return new _fs(is(t5.key, t5.offset, t5.type), is(e6.key, e6.offset, e6.type), this.format, this.style);
      }
      toggleFormat(t5) {
        this.format = de(this.format, t5, null), this.dirty = true;
      }
      setStyle(t5) {
        this.style = t5, this.dirty = true;
      }
      hasFormat(t5) {
        const e6 = It[t5];
        return !!(this.format & e6);
      }
      insertRawText(t5) {
        const e6 = t5.split(/(\r?\n|\t)/), n6 = [], r6 = e6.length;
        for (let t6 = 0; t6 < r6; t6++) {
          const r7 = e6[t6];
          "\n" === r7 || "\r\n" === r7 ? n6.push(Lr()) : "	" === r7 ? n6.push(ns()) : n6.push(Zr(r7));
        }
        this.insertNodes(n6);
      }
      insertText(t5) {
        const e6 = this.anchor, n6 = this.focus, r6 = this.format, s3 = this.style;
        let i4 = e6, o5 = n6;
        !this.isCollapsed() && n6.isBefore(e6) && (i4 = n6, o5 = e6), "element" === i4.type && function(t6, e7, n7, r7) {
          const s4 = t6.getNode(), i5 = s4.getChildAtIndex(t6.offset), o6 = Zr(), l4 = di(s4) ? xi().append(o6) : o6;
          o6.setFormat(n7), o6.setStyle(r7), null === i5 ? s4.append(l4) : i5.insertBefore(l4), t6.is(e7) && e7.set(o6.__key, 0, "text"), t6.set(o6.__key, 0, "text");
        }(i4, o5, r6, s3);
        const l3 = i4.offset;
        let c5 = o5.offset;
        const a3 = this.getNodes(), u3 = a3.length;
        let f5 = a3[0];
        Gr(f5) || Rt2(26);
        const d4 = f5.getTextContent().length, h7 = f5.getParentOrThrow();
        let g6 = a3[u3 - 1];
        if (1 === u3 && "element" === o5.type && (c5 = d4, o5.set(i4.key, c5, "text")), this.isCollapsed() && l3 === d4 && (f5.isSegmented() || f5.isToken() || !f5.canInsertTextAfter() || !h7.canInsertTextAfter() && null === f5.getNextSibling())) {
          let e7 = f5.getNextSibling();
          if (Gr(e7) && e7.canInsertTextBefore() && !ae(e7) || (e7 = Zr(), e7.setFormat(r6), e7.setStyle(s3), h7.canInsertTextAfter() ? f5.insertAfter(e7) : h7.insertAfter(e7)), e7.select(0, 0), f5 = e7, "" !== t5)
            return void this.insertText(t5);
        } else if (this.isCollapsed() && 0 === l3 && (f5.isSegmented() || f5.isToken() || !f5.canInsertTextBefore() || !h7.canInsertTextBefore() && null === f5.getPreviousSibling())) {
          let e7 = f5.getPreviousSibling();
          if (Gr(e7) && !ae(e7) || (e7 = Zr(), e7.setFormat(r6), h7.canInsertTextBefore() ? f5.insertBefore(e7) : h7.insertBefore(e7)), e7.select(), f5 = e7, "" !== t5)
            return void this.insertText(t5);
        } else if (f5.isSegmented() && l3 !== d4) {
          const t6 = Zr(f5.getTextContent());
          t6.setFormat(r6), f5.replace(t6), f5 = t6;
        } else if (!this.isCollapsed() && "" !== t5) {
          const e7 = g6.getParent();
          if (!h7.canInsertTextBefore() || !h7.canInsertTextAfter() || li(e7) && (!e7.canInsertTextBefore() || !e7.canInsertTextAfter()))
            return this.insertText(""), ms(this.anchor, this.focus, null), void this.insertText(t5);
        }
        if (1 === u3) {
          if (f5.isToken()) {
            const e8 = Zr(t5);
            return e8.select(), void f5.replace(e8);
          }
          const e7 = f5.getFormat(), n7 = f5.getStyle();
          if (l3 !== c5 || e7 === r6 && n7 === s3) {
            if (rs(f5)) {
              const e8 = Zr(t5);
              return e8.setFormat(r6), e8.setStyle(s3), e8.select(), void f5.replace(e8);
            }
          } else {
            if ("" !== f5.getTextContent()) {
              const e8 = Zr(t5);
              if (e8.setFormat(r6), e8.setStyle(s3), e8.select(), 0 === l3)
                f5.insertBefore(e8, false);
              else {
                const [t6] = f5.splitText(l3);
                t6.insertAfter(e8, false);
              }
              return void (e8.isComposing() && "text" === this.anchor.type && (this.anchor.offset -= t5.length));
            }
            f5.setFormat(r6), f5.setStyle(s3);
          }
          const i5 = c5 - l3;
          f5 = f5.spliceText(l3, i5, t5, true), "" === f5.getTextContent() ? f5.remove() : "text" === this.anchor.type && (f5.isComposing() ? this.anchor.offset -= t5.length : (this.format = e7, this.style = n7));
        } else {
          const e7 = /* @__PURE__ */ new Set([...f5.getParentKeys(), ...g6.getParentKeys()]), n7 = li(f5) ? f5 : f5.getParentOrThrow();
          let r7 = li(g6) ? g6 : g6.getParentOrThrow(), s4 = g6;
          if (!n7.is(r7) && r7.isInline())
            do {
              s4 = r7, r7 = r7.getParentOrThrow();
            } while (r7.isInline());
          if ("text" === o5.type && (0 !== c5 || "" === g6.getTextContent()) || "element" === o5.type && g6.getIndexWithinParent() < c5)
            if (Gr(g6) && !g6.isToken() && c5 !== g6.getTextContentSize()) {
              if (g6.isSegmented()) {
                const t6 = Zr(g6.getTextContent());
                g6.replace(t6), g6 = t6;
              }
              di(o5.getNode()) || "text" !== o5.type || (g6 = g6.spliceText(0, c5, "")), e7.add(g6.__key);
            } else {
              const t6 = g6.getParentOrThrow();
              t6.canBeEmpty() || 1 !== t6.getChildrenSize() ? g6.remove() : t6.remove();
            }
          else
            e7.add(g6.__key);
          const i5 = r7.getChildren(), h8 = new Set(a3), _5 = n7.is(r7), p5 = n7.isInline() && null === f5.getNextSibling() ? n7 : f5;
          for (let t6 = i5.length - 1; t6 >= 0; t6--) {
            const e8 = i5[t6];
            if (e8.is(f5) || li(e8) && e8.isParentOf(f5))
              break;
            e8.isAttached() && (!h8.has(e8) || e8.is(s4) ? _5 || p5.insertAfter(e8, false) : e8.remove());
          }
          if (!_5) {
            let t6 = r7, n8 = null;
            for (; null !== t6; ) {
              const r8 = t6.getChildren(), s5 = r8.length;
              (0 === s5 || r8[s5 - 1].is(n8)) && (e7.delete(t6.__key), n8 = t6), t6 = t6.getParent();
            }
          }
          if (f5.isToken())
            if (l3 === d4)
              f5.select();
            else {
              const e8 = Zr(t5);
              e8.select(), f5.replace(e8);
            }
          else
            f5 = f5.spliceText(l3, d4 - l3, t5, true), "" === f5.getTextContent() ? f5.remove() : f5.isComposing() && "text" === this.anchor.type && (this.anchor.offset -= t5.length);
          for (let t6 = 1; t6 < u3; t6++) {
            const n8 = a3[t6], r8 = n8.__key;
            e7.has(r8) || n8.remove();
          }
        }
      }
      removeText() {
        this.insertText("");
      }
      formatText(t5) {
        if (this.isCollapsed())
          return this.toggleFormat(t5), void ye(null);
        const e6 = this.getNodes(), n6 = [];
        for (const t6 of e6)
          Gr(t6) && n6.push(t6);
        const r6 = n6.length;
        if (0 === r6)
          return this.toggleFormat(t5), void ye(null);
        const s3 = this.anchor, i4 = this.focus, o5 = this.isBackward(), l3 = o5 ? i4 : s3, c5 = o5 ? s3 : i4;
        let a3 = 0, u3 = n6[0], f5 = "element" === l3.type ? 0 : l3.offset;
        if ("text" === l3.type && f5 === u3.getTextContentSize() && (a3 = 1, u3 = n6[1], f5 = 0), null == u3)
          return;
        const d4 = u3.getFormatFlags(t5, null), h7 = r6 - 1;
        let g6 = n6[h7];
        const _5 = "text" === c5.type ? c5.offset : g6.getTextContentSize();
        if (u3.is(g6)) {
          if (f5 === _5)
            return;
          if (ae(u3) || 0 === f5 && _5 === u3.getTextContentSize())
            u3.setFormat(d4);
          else {
            const t6 = u3.splitText(f5, _5), e7 = 0 === f5 ? t6[0] : t6[1];
            e7.setFormat(d4), "text" === l3.type && l3.set(e7.__key, 0, "text"), "text" === c5.type && c5.set(e7.__key, _5 - f5, "text");
          }
          return void (this.format = d4);
        }
        0 === f5 || ae(u3) || ([, u3] = u3.splitText(f5), f5 = 0), u3.setFormat(d4);
        const p5 = g6.getFormatFlags(t5, d4);
        _5 > 0 && (_5 === g6.getTextContentSize() || ae(g6) || ([g6] = g6.splitText(_5)), g6.setFormat(p5));
        for (let e7 = a3 + 1; e7 < h7; e7++) {
          const r7 = n6[e7], s4 = r7.getFormatFlags(t5, p5);
          r7.setFormat(s4);
        }
        "text" === l3.type && l3.set(u3.__key, f5, "text"), "text" === c5.type && c5.set(g6.__key, _5, "text"), this.format = d4 | p5;
      }
      insertNodes(t5) {
        if (0 === t5.length)
          return;
        if ("root" === this.anchor.key) {
          this.insertParagraph();
          const e7 = ws();
          return us(e7) || Rt2(134), e7.insertNodes(t5);
        }
        const e6 = Cn((this.isBackward() ? this.focus : this.anchor).getNode(), Tn), n6 = t5[t5.length - 1];
        if ("__language" in e6 && li(e6)) {
          if ("__language" in t5[0])
            this.insertText(t5[0].getTextContent());
          else {
            const r7 = As(this);
            e6.splice(r7, 0, t5), n6.selectEnd();
          }
          return;
        }
        if (!t5.some((t6) => (li(t6) || ui(t6)) && !t6.isInline())) {
          li(e6) || Rt2(135);
          const r7 = As(this);
          return e6.splice(r7, 0, t5), void n6.selectEnd();
        }
        const r6 = function(t6) {
          const e7 = xi();
          let n7 = null;
          for (let r7 = 0; r7 < t6.length; r7++) {
            const s4 = t6[r7], i5 = Ar(s4);
            if (i5 || ui(s4) && s4.isInline() || li(s4) && s4.isInline() || Gr(s4) || s4.isParentRequired()) {
              if (null === n7 && (n7 = s4.createParentElementNode(), e7.append(n7), i5))
                continue;
              null !== n7 && n7.append(s4);
            } else
              e7.append(s4), n7 = null;
          }
          return e7;
        }(t5), s3 = r6.getLastDescendant(), i4 = r6.getChildren(), o5 = (t6) => "__value" in t6 && "__checked" in t6, l3 = !li(e6) || !e6.isEmpty() ? this.insertParagraph() : null, c5 = i4[i4.length - 1];
        let a3 = i4[0];
        var u3;
        li(u3 = a3) && Tn(u3) && !u3.isEmpty() && li(e6) && (!e6.isEmpty() || o5(e6)) && (li(e6) || Rt2(135), e6.append(...a3.getChildren()), a3 = i4[1]), a3 && function(t6, e7, n7) {
          const r7 = e7.getParentOrThrow().getLastChild();
          let s4 = e7;
          const i5 = [e7];
          for (; s4 !== r7; )
            s4.getNextSibling() || Rt2(140), s4 = s4.getNextSibling(), i5.push(s4);
          let o6 = t6;
          for (const t7 of i5)
            o6 = o6.insertAfter(t7);
        }(e6, a3);
        const f5 = Cn(s3, Tn);
        l3 && li(f5) && (o5(l3) || Tn(c5)) && (f5.append(...l3.getChildren()), l3.remove()), li(e6) && e6.isEmpty() && e6.remove(), s3.selectEnd();
        const d4 = li(e6) ? e6.getLastChild() : null;
        Ar(d4) && f5 !== e6 && d4.remove();
      }
      insertParagraph() {
        if ("root" === this.anchor.key) {
          const t6 = xi();
          return ke3().splice(this.anchor.offset, 0, [t6]), t6.select(), t6;
        }
        const t5 = As(this), e6 = Cn(this.anchor.getNode(), Tn);
        li(e6) || Rt2(136);
        const n6 = e6.getChildAtIndex(t5), r6 = n6 ? [n6, ...n6.getNextSiblings()] : [], s3 = e6.insertNewAfter(this, false);
        return s3 ? (s3.append(...r6), s3.selectStart(), s3) : null;
      }
      insertLineBreak(t5) {
        const e6 = Lr();
        if (this.insertNodes([e6]), t5) {
          const t6 = e6.getParentOrThrow(), n6 = e6.getIndexWithinParent();
          t6.select(n6, n6);
        }
      }
      extract() {
        const t5 = this.getNodes(), e6 = t5.length, n6 = e6 - 1, r6 = this.anchor, s3 = this.focus;
        let i4 = t5[0], o5 = t5[n6];
        const [l3, c5] = gs(this);
        if (0 === e6)
          return [];
        if (1 === e6) {
          if (Gr(i4) && !this.isCollapsed()) {
            const t6 = l3 > c5 ? c5 : l3, e7 = l3 > c5 ? l3 : c5, n7 = i4.splitText(t6, e7), r7 = 0 === t6 ? n7[0] : n7[1];
            return null != r7 ? [r7] : [];
          }
          return [i4];
        }
        const a3 = r6.isBefore(s3);
        if (Gr(i4)) {
          const e7 = a3 ? l3 : c5;
          e7 === i4.getTextContentSize() ? t5.shift() : 0 !== e7 && ([, i4] = i4.splitText(e7), t5[0] = i4);
        }
        if (Gr(o5)) {
          const e7 = o5.getTextContent().length, r7 = a3 ? c5 : l3;
          0 === r7 ? t5.pop() : r7 !== e7 && ([o5] = o5.splitText(r7), t5[n6] = o5);
        }
        return t5;
      }
      modify(t5, e6, n6) {
        const r6 = this.focus, s3 = this.anchor, i4 = "move" === t5, o5 = qe(r6, e6);
        if (ui(o5) && !o5.isIsolated()) {
          if (i4 && o5.isKeyboardSelectable()) {
            const t7 = Ss();
            return t7.add(o5.__key), void we(t7);
          }
          const t6 = e6 ? o5.getPreviousSibling() : o5.getNextSibling();
          if (Gr(t6)) {
            const n7 = t6.__key, o6 = e6 ? t6.getTextContent().length : 0;
            return r6.set(n7, o6, "text"), void (i4 && s3.set(n7, o6, "text"));
          }
          {
            const n7 = o5.getParentOrThrow();
            let l4, c6;
            return li(t6) ? (c6 = t6.__key, l4 = e6 ? t6.getChildrenSize() : 0) : (l4 = o5.getIndexWithinParent(), c6 = n7.__key, e6 || l4++), r6.set(c6, l4, "element"), void (i4 && s3.set(c6, l4, "element"));
          }
        }
        const l3 = js(), c5 = _n(l3._window);
        if (!c5)
          return;
        const a3 = l3._blockCursorElement, u3 = l3._rootElement;
        if (null === u3 || null === a3 || !li(o5) || o5.isInline() || o5.canBeEmpty() || hn(a3, l3, u3), function(t6, e7, n7, r7) {
          t6.modify(e7, n7, r7);
        }(c5, t5, e6 ? "backward" : "forward", n6), c5.rangeCount > 0) {
          const t6 = c5.getRangeAt(0), n7 = this.anchor.getNode(), r7 = di(n7) ? n7 : on(n7);
          if (this.applyDOMRange(t6), this.dirty = true, !i4) {
            const n8 = this.getNodes(), s4 = [];
            let i5 = false;
            for (let t7 = 0; t7 < n8.length; t7++) {
              const e7 = n8[t7];
              nn(e7, r7) ? s4.push(e7) : i5 = true;
            }
            if (i5 && s4.length > 0)
              if (e6) {
                const t7 = s4[0];
                li(t7) ? t7.selectStart() : t7.getParentOrThrow().selectStart();
              } else {
                const t7 = s4[s4.length - 1];
                li(t7) ? t7.selectEnd() : t7.getParentOrThrow().selectEnd();
              }
            c5.anchorNode === t6.startContainer && c5.anchorOffset === t6.startOffset || function(t7) {
              const e7 = t7.focus, n9 = t7.anchor, r8 = n9.key, s5 = n9.offset, i6 = n9.type;
              cs(n9, e7.key, e7.offset, e7.type), cs(e7, r8, s5, i6), t7._cachedNodes = null;
            }(this);
          }
        }
      }
      forwardDeletion(t5, e6, n6) {
        if (!n6 && ("element" === t5.type && li(e6) && t5.offset === e6.getChildrenSize() || "text" === t5.type && t5.offset === e6.getTextContentSize())) {
          const t6 = e6.getParent(), n7 = e6.getNextSibling() || (null === t6 ? null : t6.getNextSibling());
          if (li(n7) && n7.isShadowRoot())
            return true;
        }
        return false;
      }
      deleteCharacter(t5) {
        const n6 = this.isCollapsed();
        if (this.isCollapsed()) {
          const n7 = this.anchor;
          let r6 = n7.getNode();
          if (this.forwardDeletion(n7, r6, t5))
            return;
          const s3 = this.focus, i4 = qe(s3, t5);
          if (ui(i4) && !i4.isIsolated()) {
            if (i4.isKeyboardSelectable() && li(r6) && 0 === r6.getChildrenSize()) {
              r6.remove();
              const t6 = Ss();
              t6.add(i4.__key), we(t6);
            } else {
              i4.remove();
              js().dispatchCommand(e5, void 0);
            }
            return;
          }
          if (!t5 && li(i4) && li(r6) && r6.isEmpty())
            return r6.remove(), void i4.selectStart();
          if (this.modify("extend", t5, "character"), this.isCollapsed()) {
            if (t5 && 0 === n7.offset) {
              if (("element" === n7.type ? n7.getNode() : n7.getNode().getParentOrThrow()).collapseAtStart(this))
                return;
            }
          } else {
            const e6 = "text" === s3.type ? s3.getNode() : null;
            if (r6 = "text" === n7.type ? n7.getNode() : null, null !== e6 && e6.isSegmented()) {
              const n8 = s3.offset, i5 = e6.getTextContentSize();
              if (e6.is(r6) || t5 && n8 !== i5 || !t5 && 0 !== n8)
                return void _s(e6, t5, n8);
            } else if (null !== r6 && r6.isSegmented()) {
              const s4 = n7.offset, i5 = r6.getTextContentSize();
              if (r6.is(e6) || t5 && 0 !== s4 || !t5 && s4 !== i5)
                return void _s(r6, t5, s4);
            }
            !function(t6, e7) {
              const n8 = t6.anchor, r7 = t6.focus, s4 = n8.getNode(), i5 = r7.getNode();
              if (s4 === i5 && "text" === n8.type && "text" === r7.type) {
                const t7 = n8.offset, i6 = r7.offset, o5 = t7 < i6, l3 = o5 ? t7 : i6, c5 = o5 ? i6 : t7, a3 = c5 - 1;
                if (l3 !== a3) {
                  Pe(s4.getTextContent().slice(l3, c5)) || (e7 ? r7.offset = a3 : n8.offset = a3);
                }
              }
            }(this, t5);
          }
        }
        if (this.removeText(), t5 && !n6 && this.isCollapsed() && "element" === this.anchor.type && 0 === this.anchor.offset) {
          const t6 = this.anchor.getNode();
          t6.isEmpty() && di(t6.getParent()) && 0 === t6.getIndexWithinParent() && t6.collapseAtStart(this);
        }
      }
      deleteLine(t5) {
        if (this.isCollapsed()) {
          const e6 = "element" === this.anchor.type;
          e6 && this.insertText(" "), this.modify("extend", t5, "lineboundary");
          if (0 === (t5 ? this.focus : this.anchor).offset && this.modify("extend", t5, "character"), e6) {
            const e7 = t5 ? this.anchor : this.focus;
            e7.set(e7.key, e7.offset + 1, e7.type);
          }
        }
        this.removeText();
      }
      deleteWord(t5) {
        if (this.isCollapsed()) {
          const e6 = this.anchor, n6 = e6.getNode();
          if (this.forwardDeletion(e6, n6, t5))
            return;
          this.modify("extend", t5, "word");
        }
        this.removeText();
      }
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      getStartEndPoints() {
        return [this.anchor, this.focus];
      }
    };
    zs = null;
    Ws = null;
    Bs = false;
    Rs = false;
    Ks = 0;
    Js = { characterData: true, childList: true, subtree: true };
    oi = class extends Fr {
      constructor(t5) {
        super(t5), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__indent = 0, this.__dir = null;
      }
      getFormat() {
        return this.getLatest().__format;
      }
      getFormatType() {
        const t5 = this.getFormat();
        return Mt[t5] || "";
      }
      getIndent() {
        return this.getLatest().__indent;
      }
      getChildren() {
        const t5 = [];
        let e6 = this.getFirstChild();
        for (; null !== e6; )
          t5.push(e6), e6 = e6.getNextSibling();
        return t5;
      }
      getChildrenKeys() {
        const t5 = [];
        let e6 = this.getFirstChild();
        for (; null !== e6; )
          t5.push(e6.__key), e6 = e6.getNextSibling();
        return t5;
      }
      getChildrenSize() {
        return this.getLatest().__size;
      }
      isEmpty() {
        return 0 === this.getChildrenSize();
      }
      isDirty() {
        const t5 = js()._dirtyElements;
        return null !== t5 && t5.has(this.__key);
      }
      isLastChild() {
        const t5 = this.getLatest(), e6 = this.getParentOrThrow().getLastChild();
        return null !== e6 && e6.is(t5);
      }
      getAllTextNodes() {
        const t5 = [];
        let e6 = this.getFirstChild();
        for (; null !== e6; ) {
          if (Gr(e6) && t5.push(e6), li(e6)) {
            const n6 = e6.getAllTextNodes();
            t5.push(...n6);
          }
          e6 = e6.getNextSibling();
        }
        return t5;
      }
      getFirstDescendant() {
        let t5 = this.getFirstChild();
        for (; li(t5); ) {
          const e6 = t5.getFirstChild();
          if (null === e6)
            break;
          t5 = e6;
        }
        return t5;
      }
      getLastDescendant() {
        let t5 = this.getLastChild();
        for (; li(t5); ) {
          const e6 = t5.getLastChild();
          if (null === e6)
            break;
          t5 = e6;
        }
        return t5;
      }
      getDescendantByIndex(t5) {
        const e6 = this.getChildren(), n6 = e6.length;
        if (t5 >= n6) {
          const t6 = e6[n6 - 1];
          return li(t6) && t6.getLastDescendant() || t6 || null;
        }
        const r6 = e6[t5];
        return li(r6) && r6.getFirstDescendant() || r6 || null;
      }
      getFirstChild() {
        const t5 = this.getLatest().__first;
        return null === t5 ? null : xe2(t5);
      }
      getFirstChildOrThrow() {
        const t5 = this.getFirstChild();
        return null === t5 && Rt2(45, this.__key), t5;
      }
      getLastChild() {
        const t5 = this.getLatest().__last;
        return null === t5 ? null : xe2(t5);
      }
      getLastChildOrThrow() {
        const t5 = this.getLastChild();
        return null === t5 && Rt2(96, this.__key), t5;
      }
      getChildAtIndex(t5) {
        const e6 = this.getChildrenSize();
        let n6, r6;
        if (t5 < e6 / 2) {
          for (n6 = this.getFirstChild(), r6 = 0; null !== n6 && r6 <= t5; ) {
            if (r6 === t5)
              return n6;
            n6 = n6.getNextSibling(), r6++;
          }
          return null;
        }
        for (n6 = this.getLastChild(), r6 = e6 - 1; null !== n6 && r6 >= t5; ) {
          if (r6 === t5)
            return n6;
          n6 = n6.getPreviousSibling(), r6--;
        }
        return null;
      }
      getTextContent() {
        let t5 = "";
        const e6 = this.getChildren(), n6 = e6.length;
        for (let r6 = 0; r6 < n6; r6++) {
          const s3 = e6[r6];
          t5 += s3.getTextContent(), li(s3) && r6 !== n6 - 1 && !s3.isInline() && (t5 += Nt);
        }
        return t5;
      }
      getTextContentSize() {
        let t5 = 0;
        const e6 = this.getChildren(), n6 = e6.length;
        for (let r6 = 0; r6 < n6; r6++) {
          const s3 = e6[r6];
          t5 += s3.getTextContentSize(), li(s3) && r6 !== n6 - 1 && !s3.isInline() && (t5 += Nt.length);
        }
        return t5;
      }
      getDirection() {
        return this.getLatest().__dir;
      }
      hasFormat(t5) {
        if ("" !== t5) {
          const e6 = At[t5];
          return !!(this.getFormat() & e6);
        }
        return false;
      }
      select(t5, e6) {
        Vs();
        const n6 = ws();
        let r6 = t5, s3 = e6;
        const i4 = this.getChildrenSize();
        if (!this.canBeEmpty()) {
          if (0 === t5 && 0 === e6) {
            const t6 = this.getFirstChild();
            if (Gr(t6) || li(t6))
              return t6.select(0, 0);
          } else if (!(void 0 !== t5 && t5 !== i4 || void 0 !== e6 && e6 !== i4)) {
            const t6 = this.getLastChild();
            if (Gr(t6) || li(t6))
              return t6.select();
          }
        }
        void 0 === r6 && (r6 = i4), void 0 === s3 && (s3 = i4);
        const o5 = this.__key;
        return us(n6) ? (n6.anchor.set(o5, r6, "element"), n6.focus.set(o5, s3, "element"), n6.dirty = true, n6) : Ts(o5, r6, o5, s3, "element", "element");
      }
      selectStart() {
        const t5 = this.getFirstDescendant();
        return t5 ? t5.selectStart() : this.select();
      }
      selectEnd() {
        const t5 = this.getLastDescendant();
        return t5 ? t5.selectEnd() : this.select();
      }
      clear() {
        const t5 = this.getWritable();
        return this.getChildren().forEach((t6) => t6.remove()), t5;
      }
      append(...t5) {
        return this.splice(this.getChildrenSize(), 0, t5);
      }
      setDirection(t5) {
        const e6 = this.getWritable();
        return e6.__dir = t5, e6;
      }
      setFormat(t5) {
        return this.getWritable().__format = "" !== t5 ? At[t5] : 0, this;
      }
      setIndent(t5) {
        return this.getWritable().__indent = t5, this;
      }
      splice(t5, e6, n6) {
        const r6 = n6.length, s3 = this.getChildrenSize(), i4 = this.getWritable(), o5 = i4.__key, l3 = [], c5 = [], a3 = this.getChildAtIndex(t5 + e6);
        let u3 = null, f5 = s3 - e6 + r6;
        if (0 !== t5)
          if (t5 === s3)
            u3 = this.getLastChild();
          else {
            const e7 = this.getChildAtIndex(t5);
            null !== e7 && (u3 = e7.getPreviousSibling());
          }
        if (e6 > 0) {
          let t6 = null === u3 ? this.getFirstChild() : u3.getNextSibling();
          for (let n7 = 0; n7 < e6; n7++) {
            null === t6 && Rt2(100);
            const e7 = t6.getNextSibling(), n8 = t6.__key;
            _e(t6.getWritable()), c5.push(n8), t6 = e7;
          }
        }
        let d4 = u3;
        for (let t6 = 0; t6 < r6; t6++) {
          const e7 = n6[t6];
          null !== d4 && e7.is(d4) && (u3 = d4 = d4.getPreviousSibling());
          const r7 = e7.getWritable();
          r7.__parent === o5 && f5--, _e(r7);
          const s4 = e7.__key;
          if (null === d4)
            i4.__first = s4, r7.__prev = null;
          else {
            const t7 = d4.getWritable();
            t7.__next = s4, r7.__prev = t7.__key;
          }
          e7.__key === o5 && Rt2(76), r7.__parent = o5, l3.push(s4), d4 = e7;
        }
        if (t5 + e6 === s3) {
          if (null !== d4) {
            d4.getWritable().__next = null, i4.__last = d4.__key;
          }
        } else if (null !== a3) {
          const t6 = a3.getWritable();
          if (null !== d4) {
            const e7 = d4.getWritable();
            t6.__prev = d4.__key, e7.__next = a3.__key;
          } else
            t6.__prev = null;
        }
        if (i4.__size = f5, c5.length) {
          const t6 = ws();
          if (us(t6)) {
            const e7 = new Set(c5), n7 = new Set(l3), { anchor: r7, focus: s4 } = t6;
            ci(r7, e7, n7) && Ds(r7, r7.getNode(), this, u3, a3), ci(s4, e7, n7) && Ds(s4, s4.getNode(), this, u3, a3), 0 !== f5 || this.canBeEmpty() || ln(this) || this.remove();
          }
        }
        return i4;
      }
      exportJSON() {
        return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "element", version: 1 };
      }
      insertNewAfter(t5, e6) {
        return null;
      }
      canIndent() {
        return true;
      }
      collapseAtStart(t5) {
        return false;
      }
      excludeFromCopy(t5) {
        return false;
      }
      canReplaceWith(t5) {
        return true;
      }
      canInsertAfter(t5) {
        return true;
      }
      canBeEmpty() {
        return true;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      isInline() {
        return false;
      }
      isShadowRoot() {
        return false;
      }
      canMergeWith(t5) {
        return false;
      }
      extractWithChild(t5, e6, n6) {
        return false;
      }
    };
    ai = class extends Fr {
      constructor(t5) {
        super(t5);
      }
      decorate(t5, e6) {
        Rt2(47);
      }
      isIsolated() {
        return false;
      }
      isInline() {
        return true;
      }
      isKeyboardSelectable() {
        return true;
      }
    };
    fi = class _fi extends oi {
      static getType() {
        return "root";
      }
      static clone() {
        return new _fi();
      }
      constructor() {
        super("root"), this.__cachedText = null;
      }
      getTopLevelElementOrThrow() {
        Rt2(51);
      }
      getTextContent() {
        const t5 = this.__cachedText;
        return !Us() && js()._dirtyType !== it || null === t5 ? super.getTextContent() : t5;
      }
      remove() {
        Rt2(52);
      }
      replace(t5) {
        Rt2(53);
      }
      insertBefore(t5) {
        Rt2(54);
      }
      insertAfter(t5) {
        Rt2(55);
      }
      updateDOM(t5, e6) {
        return false;
      }
      append(...t5) {
        for (let e6 = 0; e6 < t5.length; e6++) {
          const n6 = t5[e6];
          li(n6) || ui(n6) || Rt2(56);
        }
        return super.append(...t5);
      }
      static importJSON(t5) {
        const e6 = ke3();
        return e6.setFormat(t5.format), e6.setIndent(t5.indent), e6.setDirection(t5.direction), e6;
      }
      exportJSON() {
        return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "root", version: 1 };
      }
      collapseAtStart() {
        return true;
      }
    };
    _i = class __i {
      constructor(t5, e6) {
        this._nodeMap = t5, this._selection = e6 || null, this._flushSync = false, this._readOnly = false;
      }
      isEmpty() {
        return 1 === this._nodeMap.size && null === this._selection;
      }
      read(t5) {
        return Gs(this, t5);
      }
      clone(t5) {
        const e6 = new __i(this._nodeMap, void 0 === t5 ? this._selection : t5);
        return e6._readOnly = true, e6;
      }
      toJSON() {
        return Gs(this, () => ({ root: gi(ke3()) }));
      }
    };
    pi = class extends oi {
      static getType() {
        return "artificial";
      }
      createDOM(t5) {
        return document.createElement("div");
      }
    };
    yi = class _yi extends oi {
      constructor(t5) {
        super(t5), this.__textFormat = 0;
      }
      static getType() {
        return "paragraph";
      }
      getTextFormat() {
        return this.getLatest().__textFormat;
      }
      setTextFormat(t5) {
        const e6 = this.getWritable();
        return e6.__textFormat = t5, e6;
      }
      hasTextFormat(t5) {
        const e6 = It[t5];
        return !!(this.getTextFormat() & e6);
      }
      static clone(t5) {
        return new _yi(t5.__key);
      }
      createDOM(t5) {
        const e6 = document.createElement("p"), n6 = Ve(t5.theme, "paragraph");
        if (void 0 !== n6) {
          e6.classList.add(...n6);
        }
        return e6;
      }
      updateDOM(t5, e6, n6) {
        return false;
      }
      static importDOM() {
        return { p: (t5) => ({ conversion: mi, priority: 0 }) };
      }
      exportDOM(t5) {
        const { element: e6 } = super.exportDOM(t5);
        if (e6 && mn(e6)) {
          this.isEmpty() && e6.append(document.createElement("br"));
          const t6 = this.getFormatType();
          e6.style.textAlign = t6;
          const n6 = this.getDirection();
          n6 && (e6.dir = n6);
          const r6 = this.getIndent();
          r6 > 0 && (e6.style.textIndent = 20 * r6 + "px");
        }
        return { element: e6 };
      }
      static importJSON(t5) {
        const e6 = xi();
        return e6.setFormat(t5.format), e6.setIndent(t5.indent), e6.setDirection(t5.direction), e6.setTextFormat(t5.textFormat), e6;
      }
      exportJSON() {
        return { ...super.exportJSON(), textFormat: this.getTextFormat(), type: "paragraph", version: 1 };
      }
      insertNewAfter(t5, e6) {
        const n6 = xi();
        n6.setTextFormat(t5.format);
        const r6 = this.getDirection();
        return n6.setDirection(r6), n6.setFormat(this.getFormatType()), this.insertAfter(n6, e6), n6;
      }
      collapseAtStart() {
        const t5 = this.getChildren();
        if (0 === t5.length || Gr(t5[0]) && "" === t5[0].getTextContent().trim()) {
          if (null !== this.getNextSibling())
            return this.selectNext(), this.remove(), true;
          if (null !== this.getPreviousSibling())
            return this.selectPrevious(), this.remove(), true;
        }
        return false;
      }
    };
    Ti = 0;
    Ci = 1;
    Si = 2;
    ki = 3;
    bi = 4;
    Ei = class {
      constructor(t5, e6, n6, r6, s3, i4, o5) {
        this._parentEditor = e6, this._rootElement = null, this._editorState = t5, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = false, this._listeners = { decorator: /* @__PURE__ */ new Set(), editable: /* @__PURE__ */ new Set(), mutation: /* @__PURE__ */ new Map(), root: /* @__PURE__ */ new Set(), textcontent: /* @__PURE__ */ new Set(), update: /* @__PURE__ */ new Set() }, this._commands = /* @__PURE__ */ new Map(), this._config = r6, this._nodes = n6, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = it, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = Fe(), this._onError = s3, this._htmlConversions = i4, this._editable = o5, this._headless = null !== e6 && e6._headless, this._window = null, this._blockCursorElement = null;
      }
      isComposing() {
        return null != this._compositionKey;
      }
      registerUpdateListener(t5) {
        const e6 = this._listeners.update;
        return e6.add(t5), () => {
          e6.delete(t5);
        };
      }
      registerEditableListener(t5) {
        const e6 = this._listeners.editable;
        return e6.add(t5), () => {
          e6.delete(t5);
        };
      }
      registerDecoratorListener(t5) {
        const e6 = this._listeners.decorator;
        return e6.add(t5), () => {
          e6.delete(t5);
        };
      }
      registerTextContentListener(t5) {
        const e6 = this._listeners.textcontent;
        return e6.add(t5), () => {
          e6.delete(t5);
        };
      }
      registerRootListener(t5) {
        const e6 = this._listeners.root;
        return t5(this._rootElement, null), e6.add(t5), () => {
          t5(null, this._rootElement), e6.delete(t5);
        };
      }
      registerCommand(t5, e6, n6) {
        void 0 === n6 && Rt2(35);
        const r6 = this._commands;
        r6.has(t5) || r6.set(t5, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
        const s3 = r6.get(t5);
        void 0 === s3 && Rt2(36, String(t5));
        const i4 = s3[n6];
        return i4.add(e6), () => {
          i4.delete(e6), s3.every((t6) => 0 === t6.size) && r6.delete(t5);
        };
      }
      registerMutationListener(t5, e6) {
        let n6 = this._nodes.get(t5.getType());
        void 0 === n6 && Rt2(37, t5.name);
        let r6 = t5, s3 = null;
        for (; s3 = n6.replaceWithKlass; )
          r6 = s3, n6 = this._nodes.get(s3.getType()), void 0 === n6 && Rt2(37, s3.name);
        const i4 = this._listeners.mutation;
        return i4.set(e6, r6), () => {
          i4.delete(e6);
        };
      }
      registerNodeTransformToKlass(t5, e6) {
        const n6 = t5.getType(), r6 = this._nodes.get(n6);
        void 0 === r6 && Rt2(37, t5.name);
        return r6.transforms.add(e6), r6;
      }
      registerNodeTransform(t5, e6) {
        const n6 = this.registerNodeTransformToKlass(t5, e6), r6 = [n6], s3 = n6.replaceWithKlass;
        if (null != s3) {
          const t6 = this.registerNodeTransformToKlass(s3, e6);
          r6.push(t6);
        }
        var i4, o5;
        return i4 = this, o5 = t5.getType(), ii2(i4, () => {
          const t6 = Hs();
          if (t6.isEmpty())
            return;
          if ("root" === o5)
            return void ke3().markDirty();
          const e7 = t6._nodeMap;
          for (const [, t7] of e7)
            t7.markDirty();
        }, null === i4._pendingEditorState ? { tag: "history-merge" } : void 0), () => {
          r6.forEach((t6) => t6.transforms.delete(e6));
        };
      }
      hasNode(t5) {
        return this._nodes.has(t5.getType());
      }
      hasNodes(t5) {
        return t5.every(this.hasNode.bind(this));
      }
      dispatchCommand(t5, e6) {
        return Xe(this, t5, e6);
      }
      getDecorators() {
        return this._decorators;
      }
      getRootElement() {
        return this._rootElement;
      }
      getKey() {
        return this._key;
      }
      setRootElement(t5) {
        const e6 = this._rootElement;
        if (t5 !== e6) {
          const n6 = Ve(this._config.theme, "root"), r6 = this._pendingEditorState || this._editorState;
          if (this._rootElement = t5, wi(this, e6, t5, r6), null !== e6 && (this._config.disableEvents || Pr(e6), null != n6 && e6.classList.remove(...n6)), null !== t5) {
            const e7 = function(t6) {
              const e8 = t6.ownerDocument;
              return e8 && e8.defaultView || null;
            }(t5), r7 = t5.style;
            r7.userSelect = "text", r7.whiteSpace = "pre-wrap", r7.wordBreak = "break-word", t5.setAttribute("data-lexical-editor", "true"), this._window = e7, this._dirtyType = lt2, Yt(this), this._updateTags.add("history-merge"), ti(this), this._config.disableEvents || function(t6, e8) {
              const n7 = t6.ownerDocument, r8 = hr.get(n7);
              (void 0 === r8 || r8 < 1) && n7.addEventListener("selectionchange", wr), hr.set(n7, (r8 || 0) + 1), t6.__lexicalEditor = e8;
              const s3 = kr(t6);
              for (let n8 = 0; n8 < cr.length; n8++) {
                const [r9, i4] = cr[n8], o5 = "function" == typeof i4 ? (t7) => {
                  Er(t7) || (Nr(t7), (e8.isEditable() || "click" === r9) && i4(t7, e8));
                } : (t7) => {
                  if (Er(t7))
                    return;
                  Nr(t7);
                  const n9 = e8.isEditable();
                  switch (r9) {
                    case "cut":
                      return n9 && Xe(e8, z2, t7);
                    case "copy":
                      return Xe(e8, M2, t7);
                    case "paste":
                      return n9 && Xe(e8, c4, t7);
                    case "dragstart":
                      return n9 && Xe(e8, I2, t7);
                    case "dragover":
                      return n9 && Xe(e8, L, t7);
                    case "dragend":
                      return n9 && Xe(e8, A, t7);
                    case "focus":
                      return n9 && Xe(e8, U2, t7);
                    case "blur":
                      return n9 && Xe(e8, V2, t7);
                    case "drop":
                      return n9 && Xe(e8, F2, t7);
                  }
                };
                t6.addEventListener(r9, o5), s3.push(() => {
                  t6.removeEventListener(r9, o5);
                });
              }
            }(t5, this), null != n6 && t5.classList.add(...n6);
          } else
            this._editorState = r6, this._pendingEditorState = null, this._window = null;
          ei("root", this, false, t5, e6);
        }
      }
      getElementByKey(t5) {
        return this._keyToDOMMap.get(t5) || null;
      }
      getEditorState() {
        return this._editorState;
      }
      setEditorState(t5, e6) {
        t5.isEmpty() && Rt2(38), Xt(this);
        const n6 = this._pendingEditorState, r6 = this._updateTags, s3 = void 0 !== e6 ? e6.tag : null;
        null === n6 || n6.isEmpty() || (null != s3 && r6.add(s3), ti(this)), this._pendingEditorState = t5, this._dirtyType = lt2, this._dirtyElements.set("root", false), this._compositionKey = null, null != s3 && r6.add(s3), ti(this);
      }
      parseEditorState(t5, e6) {
        return function(t6, e7, n6) {
          const r6 = hi(), s3 = zs, i4 = Bs, o5 = Ws, l3 = e7._dirtyElements, c5 = e7._dirtyLeaves, a3 = e7._cloneNotNeeded, u3 = e7._dirtyType;
          e7._dirtyElements = /* @__PURE__ */ new Map(), e7._dirtyLeaves = /* @__PURE__ */ new Set(), e7._cloneNotNeeded = /* @__PURE__ */ new Set(), e7._dirtyType = 0, zs = r6, Bs = false, Ws = e7;
          try {
            const s4 = e7._nodes;
            Zs(t6.root, s4), n6 && n6(), r6._readOnly = true;
          } catch (t7) {
            t7 instanceof Error && e7._onError(t7);
          } finally {
            e7._dirtyElements = l3, e7._dirtyLeaves = c5, e7._cloneNotNeeded = a3, e7._dirtyType = u3, zs = s3, Bs = i4, Ws = o5;
          }
          return r6;
        }("string" == typeof t5 ? JSON.parse(t5) : t5, this, e6);
      }
      update(t5, e6) {
        ii2(this, t5, e6);
      }
      focus(t5, e6 = {}) {
        const n6 = this._rootElement;
        null !== n6 && (n6.setAttribute("autocapitalize", "off"), ii2(this, () => {
          const t6 = ws(), n7 = ke3();
          null !== t6 ? t6.dirty = true : 0 !== n7.getChildrenSize() && ("rootStart" === e6.defaultSelection ? n7.selectStart() : n7.selectEnd());
        }, { onUpdate: () => {
          n6.removeAttribute("autocapitalize"), t5 && t5();
        }, tag: "focus" }), null === this._pendingEditorState && n6.removeAttribute("autocapitalize"));
      }
      blur() {
        const t5 = this._rootElement;
        null !== t5 && t5.blur();
        const e6 = _n(this._window);
        null !== e6 && e6.removeAllRanges();
      }
      isEditable() {
        return this._editable;
      }
      setEditable(t5) {
        this._editable !== t5 && (this._editable = t5, ei("editable", this, true, t5));
      }
      toJSON() {
        return { editorState: this._editorState.toJSON() };
      }
    };
  }
});

// ../../../node_modules/.pnpm/lexical@0.16.1/node_modules/lexical/Lexical.node.mjs
var mod, $addUpdateTag2, $applyNodeReplacement2, $copyNode2, $createLineBreakNode2, $createNodeSelection2, $createParagraphNode2, $createPoint2, $createRangeSelection2, $createRangeSelectionFromDom2, $createTabNode2, $createTextNode2, $getAdjacentNode2, $getCharacterOffsets2, $getEditor2, $getNearestNodeFromDOMNode2, $getNearestRootOrShadowRoot2, $getNodeByKey2, $getNodeByKeyOrThrow2, $getPreviousSelection2, $getRoot2, $getSelection2, $getTextContent2, $hasAncestor2, $hasUpdateTag2, $insertNodes2, $isBlockElementNode2, $isDecoratorNode2, $isElementNode2, $isInlineElementOrDecoratorNode2, $isLeafNode2, $isLineBreakNode2, $isNodeSelection2, $isParagraphNode2, $isRangeSelection2, $isRootNode2, $isRootOrShadowRoot2, $isTabNode2, $isTextNode2, $nodesOfType2, $normalizeSelection__EXPERIMENTAL, $parseSerializedNode2, $selectAll2, $setCompositionKey2, $setSelection2, $splitNode2, ArtificialNode__DO_NOT_USE2, BLUR_COMMAND2, CAN_REDO_COMMAND2, CAN_UNDO_COMMAND2, CLEAR_EDITOR_COMMAND2, CLEAR_HISTORY_COMMAND2, CLICK_COMMAND2, COMMAND_PRIORITY_CRITICAL2, COMMAND_PRIORITY_EDITOR2, COMMAND_PRIORITY_HIGH2, COMMAND_PRIORITY_LOW2, COMMAND_PRIORITY_NORMAL2, CONTROLLED_TEXT_INSERTION_COMMAND2, COPY_COMMAND2, CUT_COMMAND2, DELETE_CHARACTER_COMMAND2, DELETE_LINE_COMMAND2, DELETE_WORD_COMMAND2, DRAGEND_COMMAND2, DRAGOVER_COMMAND2, DRAGSTART_COMMAND2, DROP_COMMAND2, DecoratorNode2, ElementNode2, FOCUS_COMMAND2, FORMAT_ELEMENT_COMMAND2, FORMAT_TEXT_COMMAND2, INDENT_CONTENT_COMMAND2, INSERT_LINE_BREAK_COMMAND2, INSERT_PARAGRAPH_COMMAND2, INSERT_TAB_COMMAND2, IS_ALL_FORMATTING2, IS_BOLD2, IS_CODE2, IS_HIGHLIGHT2, IS_ITALIC2, IS_STRIKETHROUGH2, IS_SUBSCRIPT2, IS_SUPERSCRIPT2, IS_UNDERLINE2, KEY_ARROW_DOWN_COMMAND2, KEY_ARROW_LEFT_COMMAND2, KEY_ARROW_RIGHT_COMMAND2, KEY_ARROW_UP_COMMAND2, KEY_BACKSPACE_COMMAND2, KEY_DELETE_COMMAND2, KEY_DOWN_COMMAND2, KEY_ENTER_COMMAND2, KEY_ESCAPE_COMMAND2, KEY_MODIFIER_COMMAND2, KEY_SPACE_COMMAND2, KEY_TAB_COMMAND2, LineBreakNode2, MOVE_TO_END2, MOVE_TO_START2, OUTDENT_CONTENT_COMMAND2, PASTE_COMMAND2, ParagraphNode2, REDO_COMMAND2, REMOVE_TEXT_COMMAND2, RootNode2, SELECTION_CHANGE_COMMAND2, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, SELECT_ALL_COMMAND2, TEXT_TYPE_TO_FORMAT2, TabNode2, TextNode2, UNDO_COMMAND2, createCommand2, createEditor2, getNearestEditorFromDOMNode2, isBlockDomNode2, isCurrentlyReadOnlyMode2, isHTMLAnchorElement2, isHTMLElement3, isInlineDomNode2, isSelectionCapturedInDecoratorInput2, isSelectionWithinEditor2, resetRandomKey2;
var init_Lexical_node = __esm({
  async "../../../node_modules/.pnpm/lexical@0.16.1/node_modules/lexical/Lexical.node.mjs"() {
    mod = await (process.env.NODE_ENV === "development" ? Promise.resolve().then(() => (init_Lexical_dev(), Lexical_dev_exports)) : Promise.resolve().then(() => (init_Lexical_prod(), Lexical_prod_exports)));
    $addUpdateTag2 = mod.$addUpdateTag;
    $applyNodeReplacement2 = mod.$applyNodeReplacement;
    $copyNode2 = mod.$copyNode;
    $createLineBreakNode2 = mod.$createLineBreakNode;
    $createNodeSelection2 = mod.$createNodeSelection;
    $createParagraphNode2 = mod.$createParagraphNode;
    $createPoint2 = mod.$createPoint;
    $createRangeSelection2 = mod.$createRangeSelection;
    $createRangeSelectionFromDom2 = mod.$createRangeSelectionFromDom;
    $createTabNode2 = mod.$createTabNode;
    $createTextNode2 = mod.$createTextNode;
    $getAdjacentNode2 = mod.$getAdjacentNode;
    $getCharacterOffsets2 = mod.$getCharacterOffsets;
    $getEditor2 = mod.$getEditor;
    $getNearestNodeFromDOMNode2 = mod.$getNearestNodeFromDOMNode;
    $getNearestRootOrShadowRoot2 = mod.$getNearestRootOrShadowRoot;
    $getNodeByKey2 = mod.$getNodeByKey;
    $getNodeByKeyOrThrow2 = mod.$getNodeByKeyOrThrow;
    $getPreviousSelection2 = mod.$getPreviousSelection;
    $getRoot2 = mod.$getRoot;
    $getSelection2 = mod.$getSelection;
    $getTextContent2 = mod.$getTextContent;
    $hasAncestor2 = mod.$hasAncestor;
    $hasUpdateTag2 = mod.$hasUpdateTag;
    $insertNodes2 = mod.$insertNodes;
    $isBlockElementNode2 = mod.$isBlockElementNode;
    $isDecoratorNode2 = mod.$isDecoratorNode;
    $isElementNode2 = mod.$isElementNode;
    $isInlineElementOrDecoratorNode2 = mod.$isInlineElementOrDecoratorNode;
    $isLeafNode2 = mod.$isLeafNode;
    $isLineBreakNode2 = mod.$isLineBreakNode;
    $isNodeSelection2 = mod.$isNodeSelection;
    $isParagraphNode2 = mod.$isParagraphNode;
    $isRangeSelection2 = mod.$isRangeSelection;
    $isRootNode2 = mod.$isRootNode;
    $isRootOrShadowRoot2 = mod.$isRootOrShadowRoot;
    $isTabNode2 = mod.$isTabNode;
    $isTextNode2 = mod.$isTextNode;
    $nodesOfType2 = mod.$nodesOfType;
    $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;
    $parseSerializedNode2 = mod.$parseSerializedNode;
    $selectAll2 = mod.$selectAll;
    $setCompositionKey2 = mod.$setCompositionKey;
    $setSelection2 = mod.$setSelection;
    $splitNode2 = mod.$splitNode;
    ArtificialNode__DO_NOT_USE2 = mod.ArtificialNode__DO_NOT_USE;
    BLUR_COMMAND2 = mod.BLUR_COMMAND;
    CAN_REDO_COMMAND2 = mod.CAN_REDO_COMMAND;
    CAN_UNDO_COMMAND2 = mod.CAN_UNDO_COMMAND;
    CLEAR_EDITOR_COMMAND2 = mod.CLEAR_EDITOR_COMMAND;
    CLEAR_HISTORY_COMMAND2 = mod.CLEAR_HISTORY_COMMAND;
    CLICK_COMMAND2 = mod.CLICK_COMMAND;
    COMMAND_PRIORITY_CRITICAL2 = mod.COMMAND_PRIORITY_CRITICAL;
    COMMAND_PRIORITY_EDITOR2 = mod.COMMAND_PRIORITY_EDITOR;
    COMMAND_PRIORITY_HIGH2 = mod.COMMAND_PRIORITY_HIGH;
    COMMAND_PRIORITY_LOW2 = mod.COMMAND_PRIORITY_LOW;
    COMMAND_PRIORITY_NORMAL2 = mod.COMMAND_PRIORITY_NORMAL;
    CONTROLLED_TEXT_INSERTION_COMMAND2 = mod.CONTROLLED_TEXT_INSERTION_COMMAND;
    COPY_COMMAND2 = mod.COPY_COMMAND;
    CUT_COMMAND2 = mod.CUT_COMMAND;
    DELETE_CHARACTER_COMMAND2 = mod.DELETE_CHARACTER_COMMAND;
    DELETE_LINE_COMMAND2 = mod.DELETE_LINE_COMMAND;
    DELETE_WORD_COMMAND2 = mod.DELETE_WORD_COMMAND;
    DRAGEND_COMMAND2 = mod.DRAGEND_COMMAND;
    DRAGOVER_COMMAND2 = mod.DRAGOVER_COMMAND;
    DRAGSTART_COMMAND2 = mod.DRAGSTART_COMMAND;
    DROP_COMMAND2 = mod.DROP_COMMAND;
    DecoratorNode2 = mod.DecoratorNode;
    ElementNode2 = mod.ElementNode;
    FOCUS_COMMAND2 = mod.FOCUS_COMMAND;
    FORMAT_ELEMENT_COMMAND2 = mod.FORMAT_ELEMENT_COMMAND;
    FORMAT_TEXT_COMMAND2 = mod.FORMAT_TEXT_COMMAND;
    INDENT_CONTENT_COMMAND2 = mod.INDENT_CONTENT_COMMAND;
    INSERT_LINE_BREAK_COMMAND2 = mod.INSERT_LINE_BREAK_COMMAND;
    INSERT_PARAGRAPH_COMMAND2 = mod.INSERT_PARAGRAPH_COMMAND;
    INSERT_TAB_COMMAND2 = mod.INSERT_TAB_COMMAND;
    IS_ALL_FORMATTING2 = mod.IS_ALL_FORMATTING;
    IS_BOLD2 = mod.IS_BOLD;
    IS_CODE2 = mod.IS_CODE;
    IS_HIGHLIGHT2 = mod.IS_HIGHLIGHT;
    IS_ITALIC2 = mod.IS_ITALIC;
    IS_STRIKETHROUGH2 = mod.IS_STRIKETHROUGH;
    IS_SUBSCRIPT2 = mod.IS_SUBSCRIPT;
    IS_SUPERSCRIPT2 = mod.IS_SUPERSCRIPT;
    IS_UNDERLINE2 = mod.IS_UNDERLINE;
    KEY_ARROW_DOWN_COMMAND2 = mod.KEY_ARROW_DOWN_COMMAND;
    KEY_ARROW_LEFT_COMMAND2 = mod.KEY_ARROW_LEFT_COMMAND;
    KEY_ARROW_RIGHT_COMMAND2 = mod.KEY_ARROW_RIGHT_COMMAND;
    KEY_ARROW_UP_COMMAND2 = mod.KEY_ARROW_UP_COMMAND;
    KEY_BACKSPACE_COMMAND2 = mod.KEY_BACKSPACE_COMMAND;
    KEY_DELETE_COMMAND2 = mod.KEY_DELETE_COMMAND;
    KEY_DOWN_COMMAND2 = mod.KEY_DOWN_COMMAND;
    KEY_ENTER_COMMAND2 = mod.KEY_ENTER_COMMAND;
    KEY_ESCAPE_COMMAND2 = mod.KEY_ESCAPE_COMMAND;
    KEY_MODIFIER_COMMAND2 = mod.KEY_MODIFIER_COMMAND;
    KEY_SPACE_COMMAND2 = mod.KEY_SPACE_COMMAND;
    KEY_TAB_COMMAND2 = mod.KEY_TAB_COMMAND;
    LineBreakNode2 = mod.LineBreakNode;
    MOVE_TO_END2 = mod.MOVE_TO_END;
    MOVE_TO_START2 = mod.MOVE_TO_START;
    OUTDENT_CONTENT_COMMAND2 = mod.OUTDENT_CONTENT_COMMAND;
    PASTE_COMMAND2 = mod.PASTE_COMMAND;
    ParagraphNode2 = mod.ParagraphNode;
    REDO_COMMAND2 = mod.REDO_COMMAND;
    REMOVE_TEXT_COMMAND2 = mod.REMOVE_TEXT_COMMAND;
    RootNode2 = mod.RootNode;
    SELECTION_CHANGE_COMMAND2 = mod.SELECTION_CHANGE_COMMAND;
    SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2 = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;
    SELECT_ALL_COMMAND2 = mod.SELECT_ALL_COMMAND;
    TEXT_TYPE_TO_FORMAT2 = mod.TEXT_TYPE_TO_FORMAT;
    TabNode2 = mod.TabNode;
    TextNode2 = mod.TextNode;
    UNDO_COMMAND2 = mod.UNDO_COMMAND;
    createCommand2 = mod.createCommand;
    createEditor2 = mod.createEditor;
    getNearestEditorFromDOMNode2 = mod.getNearestEditorFromDOMNode;
    isBlockDomNode2 = mod.isBlockDomNode;
    isCurrentlyReadOnlyMode2 = mod.isCurrentlyReadOnlyMode;
    isHTMLAnchorElement2 = mod.isHTMLAnchorElement;
    isHTMLElement3 = mod.isHTMLElement;
    isInlineDomNode2 = mod.isInlineDomNode;
    isSelectionCapturedInDecoratorInput2 = mod.isSelectionCapturedInDecoratorInput;
    isSelectionWithinEditor2 = mod.isSelectionWithinEditor;
    resetRandomKey2 = mod.resetRandomKey;
  }
});

// ../../../node_modules/.pnpm/@lexical+selection@0.16.1/node_modules/@lexical/selection/LexicalSelection.dev.mjs
var LexicalSelection_dev_exports = {};
__export(LexicalSelection_dev_exports, {
  $addNodeStyle: () => $addNodeStyle,
  $cloneWithProperties: () => $cloneWithProperties,
  $getSelectionStyleValueForProperty: () => $getSelectionStyleValueForProperty,
  $isAtNodeEnd: () => $isAtNodeEnd,
  $isParentElementRTL: () => $isParentElementRTL,
  $moveCaretSelection: () => $moveCaretSelection,
  $moveCharacter: () => $moveCharacter,
  $patchStyleText: () => $patchStyleText,
  $selectAll: () => $selectAll3,
  $setBlocksType: () => $setBlocksType,
  $shouldOverrideDefaultCharacterSelection: () => $shouldOverrideDefaultCharacterSelection,
  $sliceSelectedTextNodeContent: () => $sliceSelectedTextNodeContent,
  $trimTextContentFromAnchor: () => $trimTextContentFromAnchor,
  $wrapNodes: () => $wrapNodes,
  createDOMRange: () => createDOMRange,
  createRectsFromDOMRange: () => createRectsFromDOMRange,
  getStyleObjectFromCSS: () => getStyleObjectFromCSS,
  trimTextContentFromAnchor: () => trimTextContentFromAnchor
});
function getDOMTextNode2(element) {
  let node = element;
  while (node != null) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node;
    }
    node = node.firstChild;
  }
  return null;
}
function getDOMIndexWithinParent(node) {
  const parent = node.parentNode;
  if (parent == null) {
    throw new Error("Should never happen");
  }
  return [parent, Array.from(parent.childNodes).indexOf(node)];
}
function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
  const anchorKey = anchorNode.getKey();
  const focusKey = focusNode.getKey();
  const range = document.createRange();
  let anchorDOM = editor.getElementByKey(anchorKey);
  let focusDOM = editor.getElementByKey(focusKey);
  let anchorOffset = _anchorOffset;
  let focusOffset = _focusOffset;
  if ($isTextNode2(anchorNode)) {
    anchorDOM = getDOMTextNode2(anchorDOM);
  }
  if ($isTextNode2(focusNode)) {
    focusDOM = getDOMTextNode2(focusDOM);
  }
  if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {
    return null;
  }
  if (anchorDOM.nodeName === "BR") {
    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
  }
  if (focusDOM.nodeName === "BR") {
    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
  }
  const firstChild = anchorDOM.firstChild;
  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === "BR" && anchorOffset === 0 && focusOffset === 0) {
    focusOffset = 1;
  }
  try {
    range.setStart(anchorDOM, anchorOffset);
    range.setEnd(focusDOM, focusOffset);
  } catch (e6) {
    return null;
  }
  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
    range.setStart(focusDOM, focusOffset);
    range.setEnd(anchorDOM, anchorOffset);
  }
  return range;
}
function createRectsFromDOMRange(editor, range) {
  const rootElement = editor.getRootElement();
  if (rootElement === null) {
    return [];
  }
  const rootRect = rootElement.getBoundingClientRect();
  const computedStyle = getComputedStyle(rootElement);
  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
  const selectionRects = Array.from(range.getClientRects());
  let selectionRectsLength = selectionRects.length;
  selectionRects.sort((a3, b5) => {
    const top = a3.top - b5.top;
    if (Math.abs(top) <= 3) {
      return a3.left - b5.left;
    }
    return top;
  });
  let prevRect;
  for (let i4 = 0; i4 < selectionRectsLength; i4++) {
    const selectionRect = selectionRects[i4];
    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;
    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
    if (isOverlappingRect || selectionSpansElement) {
      selectionRects.splice(i4--, 1);
      selectionRectsLength--;
      continue;
    }
    prevRect = selectionRect;
  }
  return selectionRects;
}
function getStyleObjectFromRawCSS(css) {
  const styleObject = {};
  const styles = css.split(";");
  for (const style of styles) {
    if (style !== "") {
      const [key, value] = style.split(/:([^]+)/);
      if (key && value) {
        styleObject[key.trim()] = value.trim();
      }
    }
  }
  return styleObject;
}
function getStyleObjectFromCSS(css) {
  let value = CSS_TO_STYLES.get(css);
  if (value === void 0) {
    value = getStyleObjectFromRawCSS(css);
    CSS_TO_STYLES.set(css, value);
  }
  {
    Object.freeze(value);
  }
  return value;
}
function getCSSFromStyleObject(styles) {
  let css = "";
  for (const style in styles) {
    if (style) {
      css += `${style}: ${styles[style]};`;
    }
  }
  return css;
}
function $updateElementNodeProperties(target, source) {
  target.__first = source.__first;
  target.__last = source.__last;
  target.__size = source.__size;
  target.__format = source.__format;
  target.__indent = source.__indent;
  target.__dir = source.__dir;
  return target;
}
function $updateTextNodeProperties(target, source) {
  target.__format = source.__format;
  target.__style = source.__style;
  target.__mode = source.__mode;
  target.__detail = source.__detail;
  return target;
}
function $updateParagraphNodeProperties(target, source) {
  target.__textFormat = source.__textFormat;
  return target;
}
function $cloneWithProperties(node) {
  const constructor = node.constructor;
  const clone = constructor.clone(node);
  clone.__parent = node.__parent;
  clone.__next = node.__next;
  clone.__prev = node.__prev;
  if ($isElementNode2(node) && $isElementNode2(clone)) {
    return $updateElementNodeProperties(clone, node);
  }
  if ($isTextNode2(node) && $isTextNode2(clone)) {
    return $updateTextNodeProperties(clone, node);
  }
  if ($isParagraphNode2(node) && $isParagraphNode2(clone)) {
    return $updateParagraphNodeProperties(clone, node);
  }
  return clone;
}
function $sliceSelectedTextNodeContent(selection, textNode) {
  const anchorAndFocus = selection.getStartEndPoints();
  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {
    const [anchor, focus] = anchorAndFocus;
    const isBackward = selection.isBackward();
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const isAnchor = textNode.is(anchorNode);
    const isFocus = textNode.is(focusNode);
    if (isAnchor || isFocus) {
      const [anchorOffset, focusOffset] = $getCharacterOffsets2(selection);
      const isSame = anchorNode.is(focusNode);
      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
      const isLast = textNode.is(isBackward ? anchorNode : focusNode);
      let startOffset = 0;
      let endOffset = void 0;
      if (isSame) {
        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
      } else if (isFirst) {
        const offset3 = isBackward ? focusOffset : anchorOffset;
        startOffset = offset3;
        endOffset = void 0;
      } else if (isLast) {
        const offset3 = isBackward ? anchorOffset : focusOffset;
        startOffset = 0;
        endOffset = offset3;
      }
      textNode.__text = textNode.__text.slice(startOffset, endOffset);
      return textNode;
    }
  }
  return textNode;
}
function $isAtNodeEnd(point) {
  if (point.type === "text") {
    return point.offset === point.getNode().getTextContentSize();
  }
  const node = point.getNode();
  if (!$isElementNode2(node)) {
    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);
  }
  return point.offset === node.getChildrenSize();
}
function $trimTextContentFromAnchor(editor, anchor, delCount) {
  let currentNode = anchor.getNode();
  let remaining = delCount;
  if ($isElementNode2(currentNode)) {
    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
    if (descendantNode !== null) {
      currentNode = descendantNode;
    }
  }
  while (remaining > 0 && currentNode !== null) {
    if ($isElementNode2(currentNode)) {
      const lastDescendant = currentNode.getLastDescendant();
      if (lastDescendant !== null) {
        currentNode = lastDescendant;
      }
    }
    let nextNode = currentNode.getPreviousSibling();
    let additionalElementWhitespace = 0;
    if (nextNode === null) {
      let parent = currentNode.getParentOrThrow();
      let parentSibling = parent.getPreviousSibling();
      while (parentSibling === null) {
        parent = parent.getParent();
        if (parent === null) {
          nextNode = null;
          break;
        }
        parentSibling = parent.getPreviousSibling();
      }
      if (parent !== null) {
        additionalElementWhitespace = parent.isInline() ? 0 : 2;
        nextNode = parentSibling;
      }
    }
    let text = currentNode.getTextContent();
    if (text === "" && $isElementNode2(currentNode) && !currentNode.isInline()) {
      text = "\n\n";
    }
    const currentNodeSize = text.length;
    if (!$isTextNode2(currentNode) || remaining >= currentNodeSize) {
      const parent = currentNode.getParent();
      currentNode.remove();
      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode2(parent)) {
        parent.remove();
      }
      remaining -= currentNodeSize + additionalElementWhitespace;
      currentNode = nextNode;
    } else {
      const key = currentNode.getKey();
      const prevTextContent = editor.getEditorState().read(() => {
        const prevNode = $getNodeByKey2(key);
        if ($isTextNode2(prevNode) && prevNode.isSimpleText()) {
          return prevNode.getTextContent();
        }
        return null;
      });
      const offset3 = currentNodeSize - remaining;
      const slicedText = text.slice(0, offset3);
      if (prevTextContent !== null && prevTextContent !== text) {
        const prevSelection = $getPreviousSelection2();
        let target = currentNode;
        if (!currentNode.isSimpleText()) {
          const textNode = $createTextNode2(prevTextContent);
          currentNode.replace(textNode);
          target = textNode;
        } else {
          currentNode.setTextContent(prevTextContent);
        }
        if ($isRangeSelection2(prevSelection) && prevSelection.isCollapsed()) {
          const prevOffset = prevSelection.anchor.offset;
          target.select(prevOffset, prevOffset);
        }
      } else if (currentNode.isSimpleText()) {
        const isSelected = anchor.key === key;
        let anchorOffset = anchor.offset;
        if (anchorOffset < remaining) {
          anchorOffset = currentNodeSize;
        }
        const splitStart = isSelected ? anchorOffset - remaining : 0;
        const splitEnd = isSelected ? anchorOffset : offset3;
        if (isSelected && splitStart === 0) {
          const [excessNode] = currentNode.splitText(splitStart, splitEnd);
          excessNode.remove();
        } else {
          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
          excessNode.remove();
        }
      } else {
        const textNode = $createTextNode2(slicedText);
        currentNode.replace(textNode);
      }
      remaining = 0;
    }
  }
}
function $addNodeStyle(node) {
  const CSSText = node.getStyle();
  const styles = getStyleObjectFromRawCSS(CSSText);
  CSS_TO_STYLES.set(CSSText, styles);
}
function $patchStyle(target, patch) {
  const prevStyles = getStyleObjectFromCSS("getStyle" in target ? target.getStyle() : target.style);
  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {
    if (value instanceof Function) {
      styles[key] = value(prevStyles[key]);
    } else if (value === null) {
      delete styles[key];
    } else {
      styles[key] = value;
    }
    return styles;
  }, {
    ...prevStyles
  });
  const newCSSText = getCSSFromStyleObject(newStyles);
  target.setStyle(newCSSText);
  CSS_TO_STYLES.set(newCSSText, newStyles);
}
function $patchStyleText(selection, patch) {
  const selectedNodes = selection.getNodes();
  const selectedNodesLength = selectedNodes.length;
  const anchorAndFocus = selection.getStartEndPoints();
  if (anchorAndFocus === null) {
    return;
  }
  const [anchor, focus] = anchorAndFocus;
  const lastIndex = selectedNodesLength - 1;
  let firstNode = selectedNodes[0];
  let lastNode = selectedNodes[lastIndex];
  if (selection.isCollapsed() && $isRangeSelection2(selection)) {
    $patchStyle(selection, patch);
    return;
  }
  const firstNodeText = firstNode.getTextContent();
  const firstNodeTextLength = firstNodeText.length;
  const focusOffset = focus.offset;
  let anchorOffset = anchor.offset;
  const isBefore = anchor.isBefore(focus);
  let startOffset = isBefore ? anchorOffset : focusOffset;
  let endOffset = isBefore ? focusOffset : anchorOffset;
  const startType = isBefore ? anchor.type : focus.type;
  const endType = isBefore ? focus.type : anchor.type;
  const endKey = isBefore ? focus.key : anchor.key;
  if ($isTextNode2(firstNode) && startOffset === firstNodeTextLength) {
    const nextSibling = firstNode.getNextSibling();
    if ($isTextNode2(nextSibling)) {
      anchorOffset = 0;
      startOffset = 0;
      firstNode = nextSibling;
    }
  }
  if (selectedNodes.length === 1) {
    if ($isTextNode2(firstNode) && firstNode.canHaveFormat()) {
      startOffset = startType === "element" ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;
      endOffset = endType === "element" ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;
      if (startOffset === endOffset) {
        return;
      }
      if (startOffset === 0 && endOffset === firstNodeTextLength) {
        $patchStyle(firstNode, patch);
        firstNode.select(startOffset, endOffset);
      } else {
        const splitNodes = firstNode.splitText(startOffset, endOffset);
        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
        $patchStyle(replacement, patch);
        replacement.select(0, endOffset - startOffset);
      }
    }
  } else {
    if ($isTextNode2(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {
      if (startOffset !== 0) {
        firstNode = firstNode.splitText(startOffset)[1];
        startOffset = 0;
        if (isBefore) {
          anchor.set(firstNode.getKey(), startOffset, "text");
        } else {
          focus.set(firstNode.getKey(), startOffset, "text");
        }
      }
      $patchStyle(firstNode, patch);
    }
    if ($isTextNode2(lastNode) && lastNode.canHaveFormat()) {
      const lastNodeText = lastNode.getTextContent();
      const lastNodeTextLength = lastNodeText.length;
      if (lastNode.__key !== endKey && endOffset !== 0) {
        endOffset = lastNodeTextLength;
      }
      if (endOffset !== lastNodeTextLength) {
        [lastNode] = lastNode.splitText(endOffset);
      }
      if (endOffset !== 0 || endType === "element") {
        $patchStyle(lastNode, patch);
      }
    }
    for (let i4 = 1; i4 < lastIndex; i4++) {
      const selectedNode = selectedNodes[i4];
      const selectedNodeKey = selectedNode.getKey();
      if ($isTextNode2(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {
        $patchStyle(selectedNode, patch);
      }
    }
  }
}
function $setBlocksType(selection, createElement) {
  if (selection === null) {
    return;
  }
  const anchorAndFocus = selection.getStartEndPoints();
  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
  if (anchor !== null && anchor.key === "root") {
    const element = createElement();
    const root = $getRoot2();
    const firstChild = root.getFirstChild();
    if (firstChild) {
      firstChild.replace(element, true);
    } else {
      root.append(element);
    }
    return;
  }
  const nodes = selection.getNodes();
  const firstSelectedBlock = anchor !== null ? $getAncestor2(anchor.getNode(), INTERNAL_$isBlock2) : false;
  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {
    nodes.push(firstSelectedBlock);
  }
  for (let i4 = 0; i4 < nodes.length; i4++) {
    const node = nodes[i4];
    if (!INTERNAL_$isBlock2(node)) {
      continue;
    }
    if (!$isElementNode2(node)) {
      throw Error(`Expected block node to be an ElementNode`);
    }
    const targetElement = createElement();
    targetElement.setFormat(node.getFormatType());
    targetElement.setIndent(node.getIndent());
    node.replace(targetElement, true);
  }
}
function isPointAttached(point) {
  return point.getNode().isAttached();
}
function $removeParentEmptyElements(startingNode) {
  let node = startingNode;
  while (node !== null && !$isRootOrShadowRoot2(node)) {
    const latest = node.getLatest();
    const parentNode = node.getParent();
    if (latest.getChildrenSize() === 0) {
      node.remove(true);
    }
    node = parentNode;
  }
}
function $wrapNodes(selection, createElement, wrappingElement = null) {
  const anchorAndFocus = selection.getStartEndPoints();
  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
  const nodes = selection.getNodes();
  const nodesLength = nodes.length;
  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === "element" && anchor.getNode().getChildrenSize() === 0)) {
    const target = anchor.type === "text" ? anchor.getNode().getParentOrThrow() : anchor.getNode();
    const children = target.getChildren();
    let element = createElement();
    element.setFormat(target.getFormatType());
    element.setIndent(target.getIndent());
    children.forEach((child) => element.append(child));
    if (wrappingElement) {
      element = wrappingElement.append(element);
    }
    target.replace(element);
    return;
  }
  let topLevelNode = null;
  let descendants = [];
  for (let i4 = 0; i4 < nodesLength; i4++) {
    const node = nodes[i4];
    if ($isRootOrShadowRoot2(node)) {
      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
      descendants = [];
      topLevelNode = node;
    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor2(node, topLevelNode)) {
      descendants.push(node);
    } else {
      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
      descendants = [node];
    }
  }
  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
}
function $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {
  if (nodes.length === 0) {
    return;
  }
  const firstNode = nodes[0];
  const elementMapping = /* @__PURE__ */ new Map();
  const elements = [];
  let target = $isElementNode2(firstNode) ? firstNode : firstNode.getParentOrThrow();
  if (target.isInline()) {
    target = target.getParentOrThrow();
  }
  let targetIsPrevSibling = false;
  while (target !== null) {
    const prevSibling = target.getPreviousSibling();
    if (prevSibling !== null) {
      target = prevSibling;
      targetIsPrevSibling = true;
      break;
    }
    target = target.getParentOrThrow();
    if ($isRootOrShadowRoot2(target)) {
      break;
    }
  }
  const emptyElements = /* @__PURE__ */ new Set();
  for (let i4 = 0; i4 < nodesLength; i4++) {
    const node = nodes[i4];
    if ($isElementNode2(node) && node.getChildrenSize() === 0) {
      emptyElements.add(node.getKey());
    }
  }
  const movedNodes = /* @__PURE__ */ new Set();
  for (let i4 = 0; i4 < nodesLength; i4++) {
    const node = nodes[i4];
    let parent = node.getParent();
    if (parent !== null && parent.isInline()) {
      parent = parent.getParent();
    }
    if (parent !== null && $isLeafNode2(node) && !movedNodes.has(node.getKey())) {
      const parentKey = parent.getKey();
      if (elementMapping.get(parentKey) === void 0) {
        const targetElement = createElement();
        targetElement.setFormat(parent.getFormatType());
        targetElement.setIndent(parent.getIndent());
        elements.push(targetElement);
        elementMapping.set(parentKey, targetElement);
        parent.getChildren().forEach((child) => {
          targetElement.append(child);
          movedNodes.add(child.getKey());
          if ($isElementNode2(child)) {
            child.getChildrenKeys().forEach((key) => movedNodes.add(key));
          }
        });
        $removeParentEmptyElements(parent);
      }
    } else if (emptyElements.has(node.getKey())) {
      if (!$isElementNode2(node)) {
        throw Error(`Expected node in emptyElements to be an ElementNode`);
      }
      const targetElement = createElement();
      targetElement.setFormat(node.getFormatType());
      targetElement.setIndent(node.getIndent());
      elements.push(targetElement);
      node.remove(true);
    }
  }
  if (wrappingElement !== null) {
    for (let i4 = 0; i4 < elements.length; i4++) {
      const element = elements[i4];
      wrappingElement.append(element);
    }
  }
  let lastElement = null;
  if ($isRootOrShadowRoot2(target)) {
    if (targetIsPrevSibling) {
      if (wrappingElement !== null) {
        target.insertAfter(wrappingElement);
      } else {
        for (let i4 = elements.length - 1; i4 >= 0; i4--) {
          const element = elements[i4];
          target.insertAfter(element);
        }
      }
    } else {
      const firstChild = target.getFirstChild();
      if ($isElementNode2(firstChild)) {
        target = firstChild;
      }
      if (firstChild === null) {
        if (wrappingElement) {
          target.append(wrappingElement);
        } else {
          for (let i4 = 0; i4 < elements.length; i4++) {
            const element = elements[i4];
            target.append(element);
            lastElement = element;
          }
        }
      } else {
        if (wrappingElement !== null) {
          firstChild.insertBefore(wrappingElement);
        } else {
          for (let i4 = 0; i4 < elements.length; i4++) {
            const element = elements[i4];
            firstChild.insertBefore(element);
            lastElement = element;
          }
        }
      }
    }
  } else {
    if (wrappingElement) {
      target.insertAfter(wrappingElement);
    } else {
      for (let i4 = elements.length - 1; i4 >= 0; i4--) {
        const element = elements[i4];
        target.insertAfter(element);
        lastElement = element;
      }
    }
  }
  const prevSelection = $getPreviousSelection2();
  if ($isRangeSelection2(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
    $setSelection2(prevSelection.clone());
  } else if (lastElement !== null) {
    lastElement.selectEnd();
  } else {
    selection.dirty = true;
  }
}
function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
  const possibleNode = $getAdjacentNode2(selection.focus, isBackward);
  return $isDecoratorNode2(possibleNode) && !possibleNode.isIsolated() || $isElementNode2(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();
}
function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
  selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
}
function $isParentElementRTL(selection) {
  const anchorNode = selection.anchor.getNode();
  const parent = $isRootNode2(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
  return parent.getDirection() === "rtl";
}
function $moveCharacter(selection, isHoldingShift, isBackward) {
  const isRTL2 = $isParentElementRTL(selection);
  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL2 : isRTL2, "character");
}
function $selectAll3(selection) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const topParent = anchorNode.getTopLevelElementOrThrow();
  const root = topParent.getParentOrThrow();
  let firstNode = root.getFirstDescendant();
  let lastNode = root.getLastDescendant();
  let firstType = "element";
  let lastType = "element";
  let lastOffset = 0;
  if ($isTextNode2(firstNode)) {
    firstType = "text";
  } else if (!$isElementNode2(firstNode) && firstNode !== null) {
    firstNode = firstNode.getParentOrThrow();
  }
  if ($isTextNode2(lastNode)) {
    lastType = "text";
    lastOffset = lastNode.getTextContentSize();
  } else if (!$isElementNode2(lastNode) && lastNode !== null) {
    lastNode = lastNode.getParentOrThrow();
  }
  if (firstNode && lastNode) {
    anchor.set(firstNode.getKey(), 0, firstType);
    focus.set(lastNode.getKey(), lastOffset, lastType);
  }
}
function $getNodeStyleValueForProperty(node, styleProperty, defaultValue2) {
  const css = node.getStyle();
  const styleObject = getStyleObjectFromCSS(css);
  if (styleObject !== null) {
    return styleObject[styleProperty] || defaultValue2;
  }
  return defaultValue2;
}
function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue2 = "") {
  let styleValue = null;
  const nodes = selection.getNodes();
  const anchor = selection.anchor;
  const focus = selection.focus;
  const isBackward = selection.isBackward();
  const endOffset = isBackward ? focus.offset : anchor.offset;
  const endNode = isBackward ? focus.getNode() : anchor.getNode();
  if ($isRangeSelection2(selection) && selection.isCollapsed() && selection.style !== "") {
    const css = selection.style;
    const styleObject = getStyleObjectFromCSS(css);
    if (styleObject !== null && styleProperty in styleObject) {
      return styleObject[styleProperty];
    }
  }
  for (let i4 = 0; i4 < nodes.length; i4++) {
    const node = nodes[i4];
    if (i4 !== 0 && endOffset === 0 && node.is(endNode)) {
      continue;
    }
    if ($isTextNode2(node)) {
      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue2);
      if (styleValue === null) {
        styleValue = nodeStyleValue;
      } else if (styleValue !== nodeStyleValue) {
        styleValue = "";
        break;
      }
    }
  }
  return styleValue === null ? defaultValue2 : styleValue;
}
function INTERNAL_$isBlock2(node) {
  if ($isDecoratorNode2(node)) {
    return false;
  }
  if (!$isElementNode2(node) || $isRootOrShadowRoot2(node)) {
    return false;
  }
  const firstChild = node.getFirstChild();
  const isLeafElement = firstChild === null || $isLineBreakNode2(firstChild) || $isTextNode2(firstChild) || firstChild.isInline();
  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;
}
function $getAncestor2(node, predicate) {
  let parent = node;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}
var CSS_TO_STYLES, trimTextContentFromAnchor;
var init_LexicalSelection_dev = __esm({
  async "../../../node_modules/.pnpm/@lexical+selection@0.16.1/node_modules/@lexical/selection/LexicalSelection.dev.mjs"() {
    await init_Lexical_node();
    CSS_TO_STYLES = /* @__PURE__ */ new Map();
    trimTextContentFromAnchor = $trimTextContentFromAnchor;
  }
});

// ../../../node_modules/.pnpm/@lexical+selection@0.16.1/node_modules/@lexical/selection/LexicalSelection.prod.mjs
var LexicalSelection_prod_exports = {};
__export(LexicalSelection_prod_exports, {
  $addNodeStyle: () => I3,
  $cloneWithProperties: () => P3,
  $getSelectionStyleValueForProperty: () => U3,
  $isAtNodeEnd: () => F3,
  $isParentElementRTL: () => M3,
  $moveCaretSelection: () => D3,
  $moveCharacter: () => H2,
  $patchStyleText: () => B3,
  $selectAll: () => $3,
  $setBlocksType: () => k3,
  $shouldOverrideDefaultCharacterSelection: () => L2,
  $sliceSelectedTextNodeContent: () => E3,
  $trimTextContentFromAnchor: () => K3,
  $wrapNodes: () => R3,
  createDOMRange: () => v5,
  createRectsFromDOMRange: () => C2,
  getStyleObjectFromCSS: () => N3,
  trimTextContentFromAnchor: () => q3
});
function m4(e6) {
  return e6 && e6.__esModule && Object.prototype.hasOwnProperty.call(e6, "default") ? e6.default : e6;
}
function T3(e6) {
  let t5 = e6;
  for (; null != t5; ) {
    if (t5.nodeType === Node.TEXT_NODE)
      return t5;
    t5 = t5.firstChild;
  }
  return null;
}
function S4(e6) {
  const t5 = e6.parentNode;
  if (null == t5)
    throw new Error("Should never happen");
  return [t5, Array.from(t5.childNodes).indexOf(e6)];
}
function v5(t5, n6, o5, l3, r6) {
  const s3 = n6.getKey(), i4 = l3.getKey(), c5 = document.createRange();
  let f5 = t5.getElementByKey(s3), u3 = t5.getElementByKey(i4), a3 = o5, g6 = r6;
  if ($isTextNode2(n6) && (f5 = T3(f5)), $isTextNode2(l3) && (u3 = T3(u3)), void 0 === n6 || void 0 === l3 || null === f5 || null === u3)
    return null;
  "BR" === f5.nodeName && ([f5, a3] = S4(f5)), "BR" === u3.nodeName && ([u3, g6] = S4(u3));
  const d4 = f5.firstChild;
  f5 === u3 && null != d4 && "BR" === d4.nodeName && 0 === a3 && 0 === g6 && (g6 = 1);
  try {
    c5.setStart(f5, a3), c5.setEnd(u3, g6);
  } catch (e6) {
    return null;
  }
  return !c5.collapsed || a3 === g6 && s3 === i4 || (c5.setStart(u3, g6), c5.setEnd(f5, a3)), c5;
}
function C2(e6, t5) {
  const n6 = e6.getRootElement();
  if (null === n6)
    return [];
  const o5 = n6.getBoundingClientRect(), l3 = getComputedStyle(n6), r6 = parseFloat(l3.paddingLeft) + parseFloat(l3.paddingRight), s3 = Array.from(t5.getClientRects());
  let i4, c5 = s3.length;
  s3.sort((e7, t6) => {
    const n7 = e7.top - t6.top;
    return Math.abs(n7) <= 3 ? e7.left - t6.left : n7;
  });
  for (let e7 = 0; e7 < c5; e7++) {
    const t6 = s3[e7], n7 = i4 && i4.top <= t6.top && i4.top + i4.height > t6.top && i4.left + i4.width > t6.left, l4 = t6.width + r6 === o5.width;
    n7 || l4 ? (s3.splice(e7--, 1), c5--) : i4 = t6;
  }
  return s3;
}
function w3(e6) {
  const t5 = {}, n6 = e6.split(";");
  for (const e7 of n6)
    if ("" !== e7) {
      const [n7, o5] = e7.split(/:([^]+)/);
      n7 && o5 && (t5[n7.trim()] = o5.trim());
    }
  return t5;
}
function N3(e6) {
  let t5 = x3.get(e6);
  return void 0 === t5 && (t5 = w3(e6), x3.set(e6, t5)), t5;
}
function P3(o5) {
  const l3 = o5.constructor.clone(o5);
  return l3.__parent = o5.__parent, l3.__next = o5.__next, l3.__prev = o5.__prev, $isElementNode2(o5) && $isElementNode2(l3) ? (s3 = o5, (r6 = l3).__first = s3.__first, r6.__last = s3.__last, r6.__size = s3.__size, r6.__format = s3.__format, r6.__indent = s3.__indent, r6.__dir = s3.__dir, r6) : $isTextNode2(o5) && $isTextNode2(l3) ? function(e6, t5) {
    return e6.__format = t5.__format, e6.__style = t5.__style, e6.__mode = t5.__mode, e6.__detail = t5.__detail, e6;
  }(l3, o5) : $isParagraphNode2(o5) && $isParagraphNode2(l3) ? function(e6, t5) {
    return e6.__textFormat = t5.__textFormat, e6;
  }(l3, o5) : l3;
  var r6, s3;
}
function E3(e6, t5) {
  const n6 = e6.getStartEndPoints();
  if (t5.isSelected(e6) && !t5.isSegmented() && !t5.isToken() && null !== n6) {
    const [l3, r6] = n6, s3 = e6.isBackward(), i4 = l3.getNode(), c5 = r6.getNode(), f5 = t5.is(i4), u3 = t5.is(c5);
    if (f5 || u3) {
      const [n7, l4] = $getCharacterOffsets2(e6), r7 = i4.is(c5), f6 = t5.is(s3 ? c5 : i4), u4 = t5.is(s3 ? i4 : c5);
      let a3, g6 = 0;
      if (r7)
        g6 = n7 > l4 ? l4 : n7, a3 = n7 > l4 ? n7 : l4;
      else if (f6) {
        g6 = s3 ? l4 : n7, a3 = void 0;
      } else if (u4) {
        g6 = 0, a3 = s3 ? n7 : l4;
      }
      return t5.__text = t5.__text.slice(g6, a3), t5;
    }
  }
  return t5;
}
function F3(e6) {
  if ("text" === e6.type)
    return e6.offset === e6.getNode().getTextContentSize();
  const n6 = e6.getNode();
  return $isElementNode2(n6) || y3(177), e6.offset === n6.getChildrenSize();
}
function K3(n6, o5, f5) {
  let u3 = o5.getNode(), a3 = f5;
  if ($isElementNode2(u3)) {
    const e6 = u3.getDescendantByIndex(o5.offset);
    null !== e6 && (u3 = e6);
  }
  for (; a3 > 0 && null !== u3; ) {
    if ($isElementNode2(u3)) {
      const e6 = u3.getLastDescendant();
      null !== e6 && (u3 = e6);
    }
    let f6 = u3.getPreviousSibling(), g6 = 0;
    if (null === f6) {
      let e6 = u3.getParentOrThrow(), t5 = e6.getPreviousSibling();
      for (; null === t5; ) {
        if (e6 = e6.getParent(), null === e6) {
          f6 = null;
          break;
        }
        t5 = e6.getPreviousSibling();
      }
      null !== e6 && (g6 = e6.isInline() ? 0 : 2, f6 = t5);
    }
    let d4 = u3.getTextContent();
    "" === d4 && $isElementNode2(u3) && !u3.isInline() && (d4 = "\n\n");
    const p5 = d4.length;
    if (!$isTextNode2(u3) || a3 >= p5) {
      const e6 = u3.getParent();
      u3.remove(), null == e6 || 0 !== e6.getChildrenSize() || $isRootNode2(e6) || e6.remove(), a3 -= p5 + g6, u3 = f6;
    } else {
      const t5 = u3.getKey(), l3 = n6.getEditorState().read(() => {
        const n7 = $getNodeByKey2(t5);
        return $isTextNode2(n7) && n7.isSimpleText() ? n7.getTextContent() : null;
      }), f7 = p5 - a3, g7 = d4.slice(0, f7);
      if (null !== l3 && l3 !== d4) {
        const e6 = $getPreviousSelection2();
        let t6 = u3;
        if (u3.isSimpleText())
          u3.setTextContent(l3);
        else {
          const e7 = $createTextNode2(l3);
          u3.replace(e7), t6 = e7;
        }
        if ($isRangeSelection2(e6) && e6.isCollapsed()) {
          const n7 = e6.anchor.offset;
          t6.select(n7, n7);
        }
      } else if (u3.isSimpleText()) {
        const e6 = o5.key === t5;
        let n7 = o5.offset;
        n7 < a3 && (n7 = p5);
        const l4 = e6 ? n7 - a3 : 0, r6 = e6 ? n7 : f7;
        if (e6 && 0 === l4) {
          const [e7] = u3.splitText(l4, r6);
          e7.remove();
        } else {
          const [, e7] = u3.splitText(l4, r6);
          e7.remove();
        }
      } else {
        const e6 = $createTextNode2(g7);
        u3.replace(e6);
      }
      a3 = 0;
    }
  }
}
function I3(e6) {
  const t5 = e6.getStyle(), n6 = w3(t5);
  x3.set(t5, n6);
}
function O3(e6, t5) {
  const n6 = N3("getStyle" in e6 ? e6.getStyle() : e6.style), o5 = Object.entries(t5).reduce((e7, [t6, o6]) => (o6 instanceof Function ? e7[t6] = o6(n6[t6]) : null === o6 ? delete e7[t6] : e7[t6] = o6, e7), { ...n6 }), l3 = function(e7) {
    let t6 = "";
    for (const n7 in e7)
      n7 && (t6 += `${n7}: ${e7[n7]};`);
    return t6;
  }(o5);
  e6.setStyle(l3), x3.set(l3, o5);
}
function B3(t5, n6) {
  const o5 = t5.getNodes(), l3 = o5.length, r6 = t5.getStartEndPoints();
  if (null === r6)
    return;
  const [s3, i4] = r6, f5 = l3 - 1;
  let u3 = o5[0], a3 = o5[f5];
  if (t5.isCollapsed() && $isRangeSelection2(t5))
    return void O3(t5, n6);
  const g6 = u3.getTextContent().length, d4 = i4.offset;
  let p5 = s3.offset;
  const h7 = s3.isBefore(i4);
  let _5 = h7 ? p5 : d4, m7 = h7 ? d4 : p5;
  const y7 = h7 ? s3.type : i4.type, x6 = h7 ? i4.type : s3.type, T6 = h7 ? i4.key : s3.key;
  if ($isTextNode2(u3) && _5 === g6) {
    const t6 = u3.getNextSibling();
    $isTextNode2(t6) && (p5 = 0, _5 = 0, u3 = t6);
  }
  if (1 === o5.length) {
    if ($isTextNode2(u3) && u3.canHaveFormat()) {
      if (_5 = "element" === y7 ? 0 : p5 > d4 ? d4 : p5, m7 = "element" === x6 ? g6 : p5 > d4 ? p5 : d4, _5 === m7)
        return;
      if (0 === _5 && m7 === g6)
        O3(u3, n6), u3.select(_5, m7);
      else {
        const e6 = u3.splitText(_5, m7), t6 = 0 === _5 ? e6[0] : e6[1];
        O3(t6, n6), t6.select(0, m7 - _5);
      }
    }
  } else {
    if ($isTextNode2(u3) && _5 < u3.getTextContentSize() && u3.canHaveFormat() && (0 !== _5 && (u3 = u3.splitText(_5)[1], _5 = 0, h7 ? s3.set(u3.getKey(), _5, "text") : i4.set(u3.getKey(), _5, "text")), O3(u3, n6)), $isTextNode2(a3) && a3.canHaveFormat()) {
      const e6 = a3.getTextContent().length;
      a3.__key !== T6 && 0 !== m7 && (m7 = e6), m7 !== e6 && ([a3] = a3.splitText(m7)), 0 === m7 && "element" !== x6 || O3(a3, n6);
    }
    for (let t6 = 1; t6 < f5; t6++) {
      const l4 = o5[t6], r7 = l4.getKey();
      $isTextNode2(l4) && l4.canHaveFormat() && r7 !== u3.getKey() && r7 !== a3.getKey() && !l4.isToken() && O3(l4, n6);
    }
  }
}
function k3(e6, n6) {
  if (null === e6)
    return;
  const o5 = e6.getStartEndPoints(), l3 = o5 ? o5[0] : null;
  if (null !== l3 && "root" === l3.key) {
    const e7 = n6(), t5 = $getRoot2(), o6 = t5.getFirstChild();
    return void (o6 ? o6.replace(e7, true) : t5.append(e7));
  }
  const r6 = e6.getNodes(), s3 = null !== l3 && function(e7, t5) {
    let n7 = e7;
    for (; null !== n7 && null !== n7.getParent() && !t5(n7); )
      n7 = n7.getParentOrThrow();
    return t5(n7) ? n7 : null;
  }(l3.getNode(), X2);
  s3 && -1 === r6.indexOf(s3) && r6.push(s3);
  for (let e7 = 0; e7 < r6.length; e7++) {
    const o6 = r6[e7];
    if (!X2(o6))
      continue;
    $isElementNode2(o6) || y3(178);
    const l4 = n6();
    l4.setFormat(o6.getFormatType()), l4.setIndent(o6.getIndent()), o6.replace(l4, true);
  }
}
function b3(e6) {
  return e6.getNode().isAttached();
}
function z3(e6) {
  let t5 = e6;
  for (; null !== t5 && !$isRootOrShadowRoot2(t5); ) {
    const e7 = t5.getLatest(), n6 = t5.getParent();
    0 === e7.getChildrenSize() && t5.remove(true), t5 = n6;
  }
}
function R3(e6, t5, n6 = null) {
  const o5 = e6.getStartEndPoints(), l3 = o5 ? o5[0] : null, r6 = e6.getNodes(), s3 = r6.length;
  if (null !== l3 && (0 === s3 || 1 === s3 && "element" === l3.type && 0 === l3.getNode().getChildrenSize())) {
    const e7 = "text" === l3.type ? l3.getNode().getParentOrThrow() : l3.getNode(), o6 = e7.getChildren();
    let r7 = t5();
    return r7.setFormat(e7.getFormatType()), r7.setIndent(e7.getIndent()), o6.forEach((e8) => r7.append(e8)), n6 && (r7 = n6.append(r7)), void e7.replace(r7);
  }
  let i4 = null, c5 = [];
  for (let o6 = 0; o6 < s3; o6++) {
    const l4 = r6[o6];
    $isRootOrShadowRoot2(l4) ? (A2(e6, c5, c5.length, t5, n6), c5 = [], i4 = l4) : null === i4 || null !== i4 && $hasAncestor2(l4, i4) ? c5.push(l4) : (A2(e6, c5, c5.length, t5, n6), c5 = [l4]);
  }
  A2(e6, c5, c5.length, t5, n6);
}
function A2(e6, n6, o5, l3, r6 = null) {
  if (0 === n6.length)
    return;
  const i4 = n6[0], f5 = /* @__PURE__ */ new Map(), a3 = [];
  let p5 = $isElementNode2(i4) ? i4 : i4.getParentOrThrow();
  p5.isInline() && (p5 = p5.getParentOrThrow());
  let h7 = false;
  for (; null !== p5; ) {
    const e7 = p5.getPreviousSibling();
    if (null !== e7) {
      p5 = e7, h7 = true;
      break;
    }
    if (p5 = p5.getParentOrThrow(), $isRootOrShadowRoot2(p5))
      break;
  }
  const _5 = /* @__PURE__ */ new Set();
  for (let e7 = 0; e7 < o5; e7++) {
    const o6 = n6[e7];
    $isElementNode2(o6) && 0 === o6.getChildrenSize() && _5.add(o6.getKey());
  }
  const m7 = /* @__PURE__ */ new Set();
  for (let e7 = 0; e7 < o5; e7++) {
    const o6 = n6[e7];
    let r7 = o6.getParent();
    if (null !== r7 && r7.isInline() && (r7 = r7.getParent()), null !== r7 && $isLeafNode2(o6) && !m7.has(o6.getKey())) {
      const e8 = r7.getKey();
      if (void 0 === f5.get(e8)) {
        const n7 = l3();
        n7.setFormat(r7.getFormatType()), n7.setIndent(r7.getIndent()), a3.push(n7), f5.set(e8, n7), r7.getChildren().forEach((e9) => {
          n7.append(e9), m7.add(e9.getKey()), $isElementNode2(e9) && e9.getChildrenKeys().forEach((e10) => m7.add(e10));
        }), z3(r7);
      }
    } else if (_5.has(o6.getKey())) {
      $isElementNode2(o6) || y3(179);
      const e8 = l3();
      e8.setFormat(o6.getFormatType()), e8.setIndent(o6.getIndent()), a3.push(e8), o6.remove(true);
    }
  }
  if (null !== r6)
    for (let e7 = 0; e7 < a3.length; e7++) {
      const t5 = a3[e7];
      r6.append(t5);
    }
  let x6 = null;
  if ($isRootOrShadowRoot2(p5))
    if (h7)
      if (null !== r6)
        p5.insertAfter(r6);
      else
        for (let e7 = a3.length - 1; e7 >= 0; e7--) {
          const t5 = a3[e7];
          p5.insertAfter(t5);
        }
    else {
      const e7 = p5.getFirstChild();
      if ($isElementNode2(e7) && (p5 = e7), null === e7)
        if (r6)
          p5.append(r6);
        else
          for (let e8 = 0; e8 < a3.length; e8++) {
            const t5 = a3[e8];
            p5.append(t5), x6 = t5;
          }
      else if (null !== r6)
        e7.insertBefore(r6);
      else
        for (let t5 = 0; t5 < a3.length; t5++) {
          const n7 = a3[t5];
          e7.insertBefore(n7), x6 = n7;
        }
    }
  else if (r6)
    p5.insertAfter(r6);
  else
    for (let e7 = a3.length - 1; e7 >= 0; e7--) {
      const t5 = a3[e7];
      p5.insertAfter(t5), x6 = t5;
    }
  const T6 = $getPreviousSelection2();
  $isRangeSelection2(T6) && b3(T6.anchor) && b3(T6.focus) ? $setSelection2(T6.clone()) : null !== x6 ? x6.selectEnd() : e6.dirty = true;
}
function L2(e6, n6) {
  const o5 = $getAdjacentNode2(e6.focus, n6);
  return $isDecoratorNode2(o5) && !o5.isIsolated() || $isElementNode2(o5) && !o5.isInline() && !o5.canBeEmpty();
}
function D3(e6, t5, n6, o5) {
  e6.modify(t5 ? "extend" : "move", n6, o5);
}
function M3(e6) {
  const t5 = e6.anchor.getNode();
  return "rtl" === ($isRootNode2(t5) ? t5 : t5.getParentOrThrow()).getDirection();
}
function H2(e6, t5, n6) {
  const o5 = M3(e6);
  D3(e6, t5, n6 ? !o5 : o5, "character");
}
function $3(n6) {
  const o5 = n6.anchor, l3 = n6.focus, r6 = o5.getNode().getTopLevelElementOrThrow().getParentOrThrow();
  let s3 = r6.getFirstDescendant(), i4 = r6.getLastDescendant(), c5 = "element", f5 = "element", u3 = 0;
  $isTextNode2(s3) ? c5 = "text" : $isElementNode2(s3) || null === s3 || (s3 = s3.getParentOrThrow()), $isTextNode2(i4) ? (f5 = "text", u3 = i4.getTextContentSize()) : $isElementNode2(i4) || null === i4 || (i4 = i4.getParentOrThrow()), s3 && i4 && (o5.set(s3.getKey(), 0, c5), l3.set(i4.getKey(), u3, f5));
}
function j3(e6, t5, n6) {
  const o5 = N3(e6.getStyle());
  return null !== o5 && o5[t5] || n6;
}
function U3(t5, n6, o5 = "") {
  let l3 = null;
  const r6 = t5.getNodes(), s3 = t5.anchor, i4 = t5.focus, f5 = t5.isBackward(), u3 = f5 ? i4.offset : s3.offset, a3 = f5 ? i4.getNode() : s3.getNode();
  if ($isRangeSelection2(t5) && t5.isCollapsed() && "" !== t5.style) {
    const e6 = N3(t5.style);
    if (null !== e6 && n6 in e6)
      return e6[n6];
  }
  for (let t6 = 0; t6 < r6.length; t6++) {
    const s4 = r6[t6];
    if ((0 === t6 || 0 !== u3 || !s4.is(a3)) && $isTextNode2(s4)) {
      const e6 = j3(s4, n6, o5);
      if (null === l3)
        l3 = e6;
      else if (l3 !== e6) {
        l3 = "";
        break;
      }
    }
  }
  return null === l3 ? o5 : l3;
}
function X2(n6) {
  if ($isDecoratorNode2(n6))
    return false;
  if (!$isElementNode2(n6) || $isRootOrShadowRoot2(n6))
    return false;
  const o5 = n6.getFirstChild(), l3 = null === o5 || $isLineBreakNode2(o5) || $isTextNode2(o5) || o5.isInline();
  return !n6.isInline() && false !== n6.canBeEmpty() && l3;
}
var y3, x3, q3;
var init_LexicalSelection_prod = __esm({
  async "../../../node_modules/.pnpm/@lexical+selection@0.16.1/node_modules/@lexical/selection/LexicalSelection.prod.mjs"() {
    await init_Lexical_node();
    y3 = m4(function(e6) {
      const t5 = new URLSearchParams();
      t5.append("code", e6);
      for (let e7 = 1; e7 < arguments.length; e7++)
        t5.append("v", arguments[e7]);
      throw Error(`Minified Lexical error #${e6}; visit https://lexical.dev/docs/error?${t5} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
    });
    x3 = /* @__PURE__ */ new Map();
    q3 = K3;
  }
});

// ../../../node_modules/.pnpm/@lexical+selection@0.16.1/node_modules/@lexical/selection/LexicalSelection.node.mjs
var mod2, $addNodeStyle2, $cloneWithProperties2, $getSelectionStyleValueForProperty2, $isAtNodeEnd2, $isParentElementRTL2, $moveCaretSelection2, $moveCharacter2, $patchStyleText2, $selectAll4, $setBlocksType2, $shouldOverrideDefaultCharacterSelection2, $sliceSelectedTextNodeContent2, $trimTextContentFromAnchor2, $wrapNodes2, createDOMRange2, createRectsFromDOMRange2, getStyleObjectFromCSS2, trimTextContentFromAnchor2;
var init_LexicalSelection_node = __esm({
  async "../../../node_modules/.pnpm/@lexical+selection@0.16.1/node_modules/@lexical/selection/LexicalSelection.node.mjs"() {
    mod2 = await (process.env.NODE_ENV === "development" ? init_LexicalSelection_dev().then(() => LexicalSelection_dev_exports) : init_LexicalSelection_prod().then(() => LexicalSelection_prod_exports));
    $addNodeStyle2 = mod2.$addNodeStyle;
    $cloneWithProperties2 = mod2.$cloneWithProperties;
    $getSelectionStyleValueForProperty2 = mod2.$getSelectionStyleValueForProperty;
    $isAtNodeEnd2 = mod2.$isAtNodeEnd;
    $isParentElementRTL2 = mod2.$isParentElementRTL;
    $moveCaretSelection2 = mod2.$moveCaretSelection;
    $moveCharacter2 = mod2.$moveCharacter;
    $patchStyleText2 = mod2.$patchStyleText;
    $selectAll4 = mod2.$selectAll;
    $setBlocksType2 = mod2.$setBlocksType;
    $shouldOverrideDefaultCharacterSelection2 = mod2.$shouldOverrideDefaultCharacterSelection;
    $sliceSelectedTextNodeContent2 = mod2.$sliceSelectedTextNodeContent;
    $trimTextContentFromAnchor2 = mod2.$trimTextContentFromAnchor;
    $wrapNodes2 = mod2.$wrapNodes;
    createDOMRange2 = mod2.createDOMRange;
    createRectsFromDOMRange2 = mod2.createRectsFromDOMRange;
    getStyleObjectFromCSS2 = mod2.getStyleObjectFromCSS;
    trimTextContentFromAnchor2 = mod2.trimTextContentFromAnchor;
  }
});

// ../../../node_modules/.pnpm/@lexical+utils@0.16.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs
var LexicalUtils_dev_exports = {};
__export(LexicalUtils_dev_exports, {
  $dfs: () => $dfs,
  $filter: () => $filter,
  $findMatchingParent: () => $findMatchingParent,
  $getNearestBlockElementAncestorOrThrow: () => $getNearestBlockElementAncestorOrThrow,
  $getNearestNodeOfType: () => $getNearestNodeOfType,
  $getNextRightPreorderNode: () => $getNextRightPreorderNode,
  $insertFirst: () => $insertFirst,
  $insertNodeToNearestRoot: () => $insertNodeToNearestRoot,
  $isEditorIsNestedEditor: () => $isEditorIsNestedEditor,
  $restoreEditorState: () => $restoreEditorState,
  $splitNode: () => $splitNode2,
  $wrapNodeInElement: () => $wrapNodeInElement,
  CAN_USE_BEFORE_INPUT: () => CAN_USE_BEFORE_INPUT2,
  CAN_USE_DOM: () => CAN_USE_DOM2,
  IS_ANDROID: () => IS_ANDROID2,
  IS_ANDROID_CHROME: () => IS_ANDROID_CHROME2,
  IS_APPLE: () => IS_APPLE2,
  IS_APPLE_WEBKIT: () => IS_APPLE_WEBKIT2,
  IS_CHROME: () => IS_CHROME2,
  IS_FIREFOX: () => IS_FIREFOX2,
  IS_IOS: () => IS_IOS2,
  IS_SAFARI: () => IS_SAFARI2,
  addClassNamesToElement: () => addClassNamesToElement,
  calculateZoomLevel: () => calculateZoomLevel,
  isBlockDomNode: () => isBlockDomNode2,
  isHTMLAnchorElement: () => isHTMLAnchorElement2,
  isHTMLElement: () => isHTMLElement3,
  isInlineDomNode: () => isInlineDomNode2,
  isMimeType: () => isMimeType,
  markSelection: () => markSelection,
  mediaFileReader: () => mediaFileReader,
  mergeRegister: () => mergeRegister,
  objectKlassEquals: () => objectKlassEquals,
  positionNodeOnRange: () => positionNodeOnRange,
  registerNestedElementResolver: () => registerNestedElementResolver,
  removeClassNamesFromElement: () => removeClassNamesFromElement
});
function normalizeClassNames2(...classNames) {
  const rval = [];
  for (const className of classNames) {
    if (className && typeof className === "string") {
      for (const [s3] of className.matchAll(/\S+/g)) {
        rval.push(s3);
      }
    }
  }
  return rval;
}
function mergeRegister(...func) {
  return () => {
    for (let i4 = func.length - 1; i4 >= 0; i4--) {
      func[i4]();
    }
    func.length = 0;
  };
}
function px(value) {
  return `${value}px`;
}
function positionNodeOnRange(editor, range, onReposition) {
  let rootDOMNode = null;
  let parentDOMNode = null;
  let observer = null;
  let lastNodes = [];
  const wrapperNode = document.createElement("div");
  function position() {
    if (!(rootDOMNode !== null)) {
      throw Error(`Unexpected null rootDOMNode`);
    }
    if (!(parentDOMNode !== null)) {
      throw Error(`Unexpected null parentDOMNode`);
    }
    const {
      left: rootLeft,
      top: rootTop
    } = rootDOMNode.getBoundingClientRect();
    const parentDOMNode_ = parentDOMNode;
    const rects = createRectsFromDOMRange2(editor, range);
    if (!wrapperNode.isConnected) {
      parentDOMNode_.append(wrapperNode);
    }
    let hasRepositioned = false;
    for (let i4 = 0; i4 < rects.length; i4++) {
      const rect = rects[i4];
      const rectNode = lastNodes[i4] || document.createElement("div");
      const rectNodeStyle = rectNode.style;
      if (rectNodeStyle.position !== "absolute") {
        rectNodeStyle.position = "absolute";
        hasRepositioned = true;
      }
      const left = px(rect.left - rootLeft);
      if (rectNodeStyle.left !== left) {
        rectNodeStyle.left = left;
        hasRepositioned = true;
      }
      const top = px(rect.top - rootTop);
      if (rectNodeStyle.top !== top) {
        rectNode.style.top = top;
        hasRepositioned = true;
      }
      const width = px(rect.width);
      if (rectNodeStyle.width !== width) {
        rectNode.style.width = width;
        hasRepositioned = true;
      }
      const height = px(rect.height);
      if (rectNodeStyle.height !== height) {
        rectNode.style.height = height;
        hasRepositioned = true;
      }
      if (rectNode.parentNode !== wrapperNode) {
        wrapperNode.append(rectNode);
        hasRepositioned = true;
      }
      lastNodes[i4] = rectNode;
    }
    while (lastNodes.length > rects.length) {
      lastNodes.pop();
    }
    if (hasRepositioned) {
      onReposition(lastNodes);
    }
  }
  function stop() {
    parentDOMNode = null;
    rootDOMNode = null;
    if (observer !== null) {
      observer.disconnect();
    }
    observer = null;
    wrapperNode.remove();
    for (const node of lastNodes) {
      node.remove();
    }
    lastNodes = [];
  }
  function restart() {
    const currentRootDOMNode = editor.getRootElement();
    if (currentRootDOMNode === null) {
      return stop();
    }
    const currentParentDOMNode = currentRootDOMNode.parentElement;
    if (!(currentParentDOMNode instanceof HTMLElement)) {
      return stop();
    }
    stop();
    rootDOMNode = currentRootDOMNode;
    parentDOMNode = currentParentDOMNode;
    observer = new MutationObserver((mutations) => {
      const nextRootDOMNode = editor.getRootElement();
      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;
      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {
        return restart();
      }
      for (const mutation of mutations) {
        if (!wrapperNode.contains(mutation.target)) {
          return position();
        }
      }
    });
    observer.observe(currentParentDOMNode, mutationObserverConfig);
    position();
  }
  const removeRootListener = editor.registerRootListener(restart);
  return () => {
    removeRootListener();
    stop();
  };
}
function markSelection(editor, onReposition) {
  let previousAnchorNode = null;
  let previousAnchorOffset = null;
  let previousFocusNode = null;
  let previousFocusOffset = null;
  let removeRangeListener = () => {
  };
  function compute(editorState) {
    editorState.read(() => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        previousAnchorNode = null;
        previousAnchorOffset = null;
        previousFocusNode = null;
        previousFocusOffset = null;
        removeRangeListener();
        removeRangeListener = () => {
        };
        return;
      }
      const {
        anchor,
        focus
      } = selection;
      const currentAnchorNode = anchor.getNode();
      const currentAnchorNodeKey = currentAnchorNode.getKey();
      const currentAnchorOffset = anchor.offset;
      const currentFocusNode = focus.getNode();
      const currentFocusNodeKey = currentFocusNode.getKey();
      const currentFocusOffset = focus.offset;
      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);
      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);
      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof TextNode2) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));
      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof TextNode2) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));
      if (differentAnchorDOM || differentFocusDOM) {
        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());
        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());
        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === "SPAN" && focusHTMLElement.tagName === "SPAN") {
          const range = document.createRange();
          let firstHTMLElement;
          let firstOffset;
          let lastHTMLElement;
          let lastOffset;
          if (focus.isBefore(anchor)) {
            firstHTMLElement = focusHTMLElement;
            firstOffset = focus.offset;
            lastHTMLElement = anchorHTMLElement;
            lastOffset = anchor.offset;
          } else {
            firstHTMLElement = anchorHTMLElement;
            firstOffset = anchor.offset;
            lastHTMLElement = focusHTMLElement;
            lastOffset = focus.offset;
          }
          const firstTextNode = firstHTMLElement.firstChild;
          if (!(firstTextNode !== null)) {
            throw Error(`Expected text node to be first child of span`);
          }
          const lastTextNode = lastHTMLElement.firstChild;
          if (!(lastTextNode !== null)) {
            throw Error(`Expected text node to be first child of span`);
          }
          range.setStart(firstTextNode, firstOffset);
          range.setEnd(lastTextNode, lastOffset);
          removeRangeListener();
          removeRangeListener = positionNodeOnRange(editor, range, (domNodes) => {
            for (const domNode of domNodes) {
              const domNodeStyle = domNode.style;
              if (domNodeStyle.background !== "Highlight") {
                domNodeStyle.background = "Highlight";
              }
              if (domNodeStyle.color !== "HighlightText") {
                domNodeStyle.color = "HighlightText";
              }
              if (domNodeStyle.zIndex !== "-1") {
                domNodeStyle.zIndex = "-1";
              }
              if (domNodeStyle.pointerEvents !== "none") {
                domNodeStyle.pointerEvents = "none";
              }
              if (domNodeStyle.marginTop !== px(-1.5)) {
                domNodeStyle.marginTop = px(-1.5);
              }
              if (domNodeStyle.paddingTop !== px(4)) {
                domNodeStyle.paddingTop = px(4);
              }
              if (domNodeStyle.paddingBottom !== px(0)) {
                domNodeStyle.paddingBottom = px(0);
              }
            }
            if (onReposition !== void 0) {
              onReposition(domNodes);
            }
          });
        }
      }
      previousAnchorNode = currentAnchorNode;
      previousAnchorOffset = currentAnchorOffset;
      previousFocusNode = currentFocusNode;
      previousFocusOffset = currentFocusOffset;
    });
  }
  compute(editor.getEditorState());
  return mergeRegister(editor.registerUpdateListener(({
    editorState
  }) => compute(editorState)), removeRangeListener, () => {
    removeRangeListener();
  });
}
function addClassNamesToElement(element, ...classNames) {
  const classesToAdd = normalizeClassNames2(...classNames);
  if (classesToAdd.length > 0) {
    element.classList.add(...classesToAdd);
  }
}
function removeClassNamesFromElement(element, ...classNames) {
  const classesToRemove = normalizeClassNames2(...classNames);
  if (classesToRemove.length > 0) {
    element.classList.remove(...classesToRemove);
  }
}
function isMimeType(file, acceptableMimeTypes) {
  for (const acceptableType of acceptableMimeTypes) {
    if (file.type.startsWith(acceptableType)) {
      return true;
    }
  }
  return false;
}
function mediaFileReader(files, acceptableMimeTypes) {
  const filesIterator = files[Symbol.iterator]();
  return new Promise((resolve, reject) => {
    const processed = [];
    const handleNextFile = () => {
      const {
        done,
        value: file
      } = filesIterator.next();
      if (done) {
        return resolve(processed);
      }
      const fileReader = new FileReader();
      fileReader.addEventListener("error", reject);
      fileReader.addEventListener("load", () => {
        const result = fileReader.result;
        if (typeof result === "string") {
          processed.push({
            file,
            result
          });
        }
        handleNextFile();
      });
      if (isMimeType(file, acceptableMimeTypes)) {
        fileReader.readAsDataURL(file);
      } else {
        handleNextFile();
      }
    };
    handleNextFile();
  });
}
function $dfs(startingNode, endingNode) {
  const nodes = [];
  const start = (startingNode || $getRoot2()).getLatest();
  const end = endingNode || ($isElementNode2(start) ? start.getLastDescendant() || start : start);
  let node = start;
  let depth = $getDepth(node);
  while (node !== null && !node.is(end)) {
    nodes.push({
      depth,
      node
    });
    if ($isElementNode2(node) && node.getChildrenSize() > 0) {
      node = node.getFirstChild();
      depth++;
    } else {
      let sibling = null;
      while (sibling === null && node !== null) {
        sibling = node.getNextSibling();
        if (sibling === null) {
          node = node.getParent();
          depth--;
        } else {
          node = sibling;
        }
      }
    }
  }
  if (node !== null && node.is(end)) {
    nodes.push({
      depth,
      node
    });
  }
  return nodes;
}
function $getDepth(node) {
  let innerNode = node;
  let depth = 0;
  while ((innerNode = innerNode.getParent()) !== null) {
    depth++;
  }
  return depth;
}
function $getNextRightPreorderNode(startingNode) {
  let node = startingNode;
  if ($isElementNode2(node) && node.getChildrenSize() > 0) {
    node = node.getLastChild();
  } else {
    let sibling = null;
    while (sibling === null && node !== null) {
      sibling = node.getPreviousSibling();
      if (sibling === null) {
        node = node.getParent();
      } else {
        node = sibling;
      }
    }
  }
  return node;
}
function $getNearestNodeOfType(node, klass) {
  let parent = node;
  while (parent != null) {
    if (parent instanceof klass) {
      return parent;
    }
    parent = parent.getParent();
  }
  return null;
}
function $getNearestBlockElementAncestorOrThrow(startNode) {
  const blockNode = $findMatchingParent(startNode, (node) => $isElementNode2(node) && !node.isInline());
  if (!$isElementNode2(blockNode)) {
    {
      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
    }
  }
  return blockNode;
}
function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
  const $isTargetNode = (node) => {
    return node instanceof targetNode;
  };
  const $findMatch = (node) => {
    const children = node.getChildren();
    for (let i4 = 0; i4 < children.length; i4++) {
      const child = children[i4];
      if ($isTargetNode(child)) {
        return null;
      }
    }
    let parentNode = node;
    let childNode = node;
    while (parentNode !== null) {
      childNode = parentNode;
      parentNode = parentNode.getParent();
      if ($isTargetNode(parentNode)) {
        return {
          child: childNode,
          parent: parentNode
        };
      }
    }
    return null;
  };
  const $elementNodeTransform = (node) => {
    const match2 = $findMatch(node);
    if (match2 !== null) {
      const {
        child,
        parent
      } = match2;
      if (child.is(node)) {
        handleOverlap(parent, node);
        const nextSiblings = child.getNextSiblings();
        const nextSiblingsLength = nextSiblings.length;
        parent.insertAfter(child);
        if (nextSiblingsLength !== 0) {
          const newParent = cloneNode(parent);
          child.insertAfter(newParent);
          for (let i4 = 0; i4 < nextSiblingsLength; i4++) {
            newParent.append(nextSiblings[i4]);
          }
        }
        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
          parent.remove();
        }
      }
    }
  };
  return editor.registerNodeTransform(targetNode, $elementNodeTransform);
}
function $restoreEditorState(editor, editorState) {
  const FULL_RECONCILE2 = 2;
  const nodeMap = /* @__PURE__ */ new Map();
  const activeEditorState2 = editor._pendingEditorState;
  for (const [key, node] of editorState._nodeMap) {
    const clone = $cloneWithProperties2(node);
    if ($isTextNode2(clone)) {
      if (!$isTextNode2(node)) {
        throw Error(`Expected node be a TextNode`);
      }
      clone.__text = node.__text;
    }
    nodeMap.set(key, clone);
  }
  if (activeEditorState2) {
    activeEditorState2._nodeMap = nodeMap;
  }
  editor._dirtyType = FULL_RECONCILE2;
  const selection = editorState._selection;
  $setSelection2(selection === null ? null : selection.clone());
}
function $insertNodeToNearestRoot(node) {
  const selection = $getSelection2() || $getPreviousSelection2();
  if ($isRangeSelection2(selection)) {
    const {
      focus
    } = selection;
    const focusNode = focus.getNode();
    const focusOffset = focus.offset;
    if ($isRootOrShadowRoot2(focusNode)) {
      const focusChild = focusNode.getChildAtIndex(focusOffset);
      if (focusChild == null) {
        focusNode.append(node);
      } else {
        focusChild.insertBefore(node);
      }
      node.selectNext();
    } else {
      let splitNode;
      let splitOffset;
      if ($isTextNode2(focusNode)) {
        splitNode = focusNode.getParentOrThrow();
        splitOffset = focusNode.getIndexWithinParent();
        if (focusOffset > 0) {
          splitOffset += 1;
          focusNode.splitText(focusOffset);
        }
      } else {
        splitNode = focusNode;
        splitOffset = focusOffset;
      }
      const [, rightTree] = $splitNode2(splitNode, splitOffset);
      rightTree.insertBefore(node);
      rightTree.selectStart();
    }
  } else {
    if (selection != null) {
      const nodes = selection.getNodes();
      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
    } else {
      const root = $getRoot2();
      root.append(node);
    }
    const paragraphNode = $createParagraphNode2();
    node.insertAfter(paragraphNode);
    paragraphNode.select();
  }
  return node.getLatest();
}
function $wrapNodeInElement(node, createElementNode) {
  const elementNode = createElementNode();
  node.replace(elementNode);
  elementNode.append(node);
  return elementNode;
}
function objectKlassEquals(object, objectClass) {
  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
}
function $filter(nodes, filterFn) {
  const result = [];
  for (let i4 = 0; i4 < nodes.length; i4++) {
    const node = filterFn(nodes[i4]);
    if (node !== null) {
      result.push(node);
    }
  }
  return result;
}
function $insertFirst(parent, node) {
  const firstChild = parent.getFirstChild();
  if (firstChild !== null) {
    firstChild.insertBefore(node);
  } else {
    parent.append(node);
  }
}
function calculateZoomLevel(element) {
  if (IS_FIREFOX2) {
    return 1;
  }
  let zoom = 1;
  while (element) {
    zoom *= Number(window.getComputedStyle(element).getPropertyValue("zoom"));
    element = element.parentElement;
  }
  return zoom;
}
function $isEditorIsNestedEditor(editor) {
  return editor._parentEditor !== null;
}
var CAN_USE_DOM$1, documentMode2, IS_APPLE$1, IS_FIREFOX$1, CAN_USE_BEFORE_INPUT$1, IS_SAFARI$1, IS_IOS$1, IS_ANDROID$1, IS_CHROME$1, IS_ANDROID_CHROME$1, IS_APPLE_WEBKIT$1, mutationObserverConfig, CAN_USE_BEFORE_INPUT2, CAN_USE_DOM2, IS_ANDROID2, IS_ANDROID_CHROME2, IS_APPLE2, IS_APPLE_WEBKIT2, IS_CHROME2, IS_FIREFOX2, IS_IOS2, IS_SAFARI2, $findMatchingParent;
var init_LexicalUtils_dev = __esm({
  async "../../../node_modules/.pnpm/@lexical+utils@0.16.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs"() {
    await init_LexicalSelection_node();
    await init_Lexical_node();
    await init_Lexical_node();
    CAN_USE_DOM$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    documentMode2 = CAN_USE_DOM$1 && "documentMode" in document ? document.documentMode : null;
    IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && "InputEvent" in window && !documentMode2 ? "getTargetRanges" in new window.InputEvent("input") : false;
    IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);
    IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;
    IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;
    mutationObserverConfig = {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    };
    CAN_USE_BEFORE_INPUT2 = CAN_USE_BEFORE_INPUT$1;
    CAN_USE_DOM2 = CAN_USE_DOM$1;
    IS_ANDROID2 = IS_ANDROID$1;
    IS_ANDROID_CHROME2 = IS_ANDROID_CHROME$1;
    IS_APPLE2 = IS_APPLE$1;
    IS_APPLE_WEBKIT2 = IS_APPLE_WEBKIT$1;
    IS_CHROME2 = IS_CHROME$1;
    IS_FIREFOX2 = IS_FIREFOX$1;
    IS_IOS2 = IS_IOS$1;
    IS_SAFARI2 = IS_SAFARI$1;
    $findMatchingParent = (startingNode, findFn) => {
      let curr = startingNode;
      while (curr !== $getRoot2() && curr != null) {
        if (findFn(curr)) {
          return curr;
        }
        curr = curr.getParent();
      }
      return null;
    };
  }
});

// ../../../node_modules/.pnpm/@lexical+utils@0.16.1/node_modules/@lexical/utils/LexicalUtils.prod.mjs
var LexicalUtils_prod_exports = {};
__export(LexicalUtils_prod_exports, {
  $dfs: () => V3,
  $filter: () => ne2,
  $findMatchingParent: () => Q3,
  $getNearestBlockElementAncestorOrThrow: () => J2,
  $getNearestNodeOfType: () => G3,
  $getNextRightPreorderNode: () => q4,
  $insertFirst: () => oe2,
  $insertNodeToNearestRoot: () => Z3,
  $isEditorIsNestedEditor: () => le2,
  $restoreEditorState: () => Y3,
  $splitNode: () => $splitNode2,
  $wrapNodeInElement: () => ee2,
  CAN_USE_BEFORE_INPUT: () => B4,
  CAN_USE_DOM: () => K4,
  IS_ANDROID: () => O4,
  IS_ANDROID_CHROME: () => R4,
  IS_APPLE: () => I4,
  IS_APPLE_WEBKIT: () => D4,
  IS_CHROME: () => H3,
  IS_FIREFOX: () => z4,
  IS_IOS: () => k4,
  IS_SAFARI: () => F4,
  addClassNamesToElement: () => $4,
  calculateZoomLevel: () => re2,
  isBlockDomNode: () => isBlockDomNode2,
  isHTMLAnchorElement: () => isHTMLAnchorElement2,
  isHTMLElement: () => isHTMLElement3,
  isInlineDomNode: () => isInlineDomNode2,
  isMimeType: () => W2,
  markSelection: () => C3,
  mediaFileReader: () => j4,
  mergeRegister: () => b4,
  objectKlassEquals: () => te2,
  positionNodeOnRange: () => M4,
  registerNestedElementResolver: () => X3,
  removeClassNamesFromElement: () => U4
});
function g4(e6) {
  return e6 && e6.__esModule && Object.prototype.hasOwnProperty.call(e6, "default") ? e6.default : e6;
}
function L3(...e6) {
  const t5 = [];
  for (const n6 of e6)
    if (n6 && "string" == typeof n6)
      for (const [e7] of n6.matchAll(/\S+/g))
        t5.push(e7);
  return t5;
}
function b4(...e6) {
  return () => {
    for (let t5 = e6.length - 1; t5 >= 0; t5--)
      e6[t5]();
    e6.length = 0;
  };
}
function T4(e6) {
  return `${e6}px`;
}
function M4(t5, n6, o5) {
  let r6 = null, l3 = null, i4 = null, s3 = [];
  const u3 = document.createElement("div");
  function c5() {
    null === r6 && p3(182), null === l3 && p3(183);
    const { left: i5, top: c6 } = r6.getBoundingClientRect(), f6 = l3, a4 = createRectsFromDOMRange2(t5, n6);
    u3.isConnected || f6.append(u3);
    let d4 = false;
    for (let e6 = 0; e6 < a4.length; e6++) {
      const t6 = a4[e6], n7 = s3[e6] || document.createElement("div"), o6 = n7.style;
      "absolute" !== o6.position && (o6.position = "absolute", d4 = true);
      const r7 = T4(t6.left - i5);
      o6.left !== r7 && (o6.left = r7, d4 = true);
      const l4 = T4(t6.top - c6);
      o6.top !== l4 && (n7.style.top = l4, d4 = true);
      const f7 = T4(t6.width);
      o6.width !== f7 && (n7.style.width = f7, d4 = true);
      const g6 = T4(t6.height);
      o6.height !== g6 && (n7.style.height = g6, d4 = true), n7.parentNode !== u3 && (u3.append(n7), d4 = true), s3[e6] = n7;
    }
    for (; s3.length > a4.length; )
      s3.pop();
    d4 && o5(s3);
  }
  function f5() {
    l3 = null, r6 = null, null !== i4 && i4.disconnect(), i4 = null, u3.remove();
    for (const e6 of s3)
      e6.remove();
    s3 = [];
  }
  const a3 = t5.registerRootListener(function e6() {
    const n7 = t5.getRootElement();
    if (null === n7)
      return f5();
    const o6 = n7.parentElement;
    if (!(o6 instanceof HTMLElement))
      return f5();
    f5(), r6 = n7, l3 = o6, i4 = new MutationObserver((n8) => {
      const o7 = t5.getRootElement(), i5 = o7 && o7.parentElement;
      if (o7 !== r6 || i5 !== l3)
        return e6();
      for (const e7 of n8)
        if (!u3.contains(e7.target))
          return c5();
    }), i4.observe(o6, _3), c5();
  });
  return () => {
    a3(), f5();
  };
}
function C3(e6, t5) {
  let l3 = null, i4 = null, s3 = null, u3 = null, c5 = () => {
  };
  function f5(f6) {
    f6.read(() => {
      const f7 = $getSelection2();
      if (!$isRangeSelection2(f7))
        return l3 = null, i4 = null, s3 = null, u3 = null, c5(), void (c5 = () => {
        });
      const { anchor: a3, focus: d4 } = f7, g6 = a3.getNode(), h7 = g6.getKey(), m7 = a3.offset, v8 = d4.getNode(), y7 = v8.getKey(), w6 = d4.offset, E6 = e6.getElementByKey(h7), x6 = e6.getElementByKey(y7), P7 = null === l3 || null === E6 || m7 !== i4 || h7 !== l3.getKey() || g6 !== l3 && (!(l3 instanceof TextNode2) || g6.updateDOM(l3, E6, e6._config)), S8 = null === s3 || null === x6 || w6 !== u3 || y7 !== s3.getKey() || v8 !== s3 && (!(s3 instanceof TextNode2) || v8.updateDOM(s3, x6, e6._config));
      if (P7 || S8) {
        const n6 = e6.getElementByKey(a3.getNode().getKey()), o5 = e6.getElementByKey(d4.getNode().getKey());
        if (null !== n6 && null !== o5 && "SPAN" === n6.tagName && "SPAN" === o5.tagName) {
          const r6 = document.createRange();
          let l4, i5, s4, u4;
          d4.isBefore(a3) ? (l4 = o5, i5 = d4.offset, s4 = n6, u4 = a3.offset) : (l4 = n6, i5 = a3.offset, s4 = o5, u4 = d4.offset);
          const f8 = l4.firstChild;
          null === f8 && p3(181);
          const g7 = s4.firstChild;
          null === g7 && p3(181), r6.setStart(f8, i5), r6.setEnd(g7, u4), c5(), c5 = M4(e6, r6, (e7) => {
            for (const t6 of e7) {
              const e8 = t6.style;
              "Highlight" !== e8.background && (e8.background = "Highlight"), "HighlightText" !== e8.color && (e8.color = "HighlightText"), "-1" !== e8.zIndex && (e8.zIndex = "-1"), "none" !== e8.pointerEvents && (e8.pointerEvents = "none"), e8.marginTop !== T4(-1.5) && (e8.marginTop = T4(-1.5)), e8.paddingTop !== T4(4) && (e8.paddingTop = T4(4)), e8.paddingBottom !== T4(0) && (e8.paddingBottom = T4(0));
            }
            void 0 !== t5 && t5(e7);
          });
        }
      }
      l3 = g6, i4 = m7, s3 = v8, u3 = w6;
    });
  }
  return f5(e6.getEditorState()), b4(e6.registerUpdateListener(({ editorState: e7 }) => f5(e7)), c5, () => {
    c5();
  });
}
function $4(e6, ...t5) {
  const n6 = L3(...t5);
  n6.length > 0 && e6.classList.add(...n6);
}
function U4(e6, ...t5) {
  const n6 = L3(...t5);
  n6.length > 0 && e6.classList.remove(...n6);
}
function W2(e6, t5) {
  for (const n6 of t5)
    if (e6.type.startsWith(n6))
      return true;
  return false;
}
function j4(e6, t5) {
  const n6 = e6[Symbol.iterator]();
  return new Promise((e7, o5) => {
    const r6 = [], l3 = () => {
      const { done: i4, value: s3 } = n6.next();
      if (i4)
        return e7(r6);
      const u3 = new FileReader();
      u3.addEventListener("error", o5), u3.addEventListener("load", () => {
        const e8 = u3.result;
        "string" == typeof e8 && r6.push({ file: s3, result: e8 }), l3();
      }), W2(s3, t5) ? u3.readAsDataURL(s3) : l3();
    };
    l3();
  });
}
function V3(e6, t5) {
  const n6 = [], o5 = (e6 || $getRoot2()).getLatest(), r6 = t5 || $isElementNode2(o5) && o5.getLastDescendant() || o5;
  let s3 = o5, u3 = function(e7) {
    let t6 = e7, n7 = 0;
    for (; null !== (t6 = t6.getParent()); )
      n7++;
    return n7;
  }(s3);
  for (; null !== s3 && !s3.is(r6); )
    if (n6.push({ depth: u3, node: s3 }), $isElementNode2(s3) && s3.getChildrenSize() > 0)
      s3 = s3.getFirstChild(), u3++;
    else {
      let e7 = null;
      for (; null === e7 && null !== s3; )
        e7 = s3.getNextSibling(), null === e7 ? (s3 = s3.getParent(), u3--) : s3 = e7;
    }
  return null !== s3 && s3.is(r6) && n6.push({ depth: u3, node: s3 }), n6;
}
function q4(e6) {
  let t5 = e6;
  if ($isElementNode2(t5) && t5.getChildrenSize() > 0)
    t5 = t5.getLastChild();
  else {
    let e7 = null;
    for (; null === e7 && null !== t5; )
      e7 = t5.getPreviousSibling(), t5 = null === e7 ? t5.getParent() : e7;
  }
  return t5;
}
function G3(e6, t5) {
  let n6 = e6;
  for (; null != n6; ) {
    if (n6 instanceof t5)
      return n6;
    n6 = n6.getParent();
  }
  return null;
}
function J2(e6) {
  const t5 = Q3(e6, (e7) => $isElementNode2(e7) && !e7.isInline());
  return $isElementNode2(t5) || p3(4, e6.__key), t5;
}
function X3(e6, t5, n6, o5) {
  const r6 = (e7) => e7 instanceof t5;
  return e6.registerNodeTransform(t5, (e7) => {
    const t6 = ((e8) => {
      const t7 = e8.getChildren();
      for (let e9 = 0; e9 < t7.length; e9++) {
        const n8 = t7[e9];
        if (r6(n8))
          return null;
      }
      let n7 = e8, o6 = e8;
      for (; null !== n7; )
        if (o6 = n7, n7 = n7.getParent(), r6(n7))
          return { child: o6, parent: n7 };
      return null;
    })(e7);
    if (null !== t6) {
      const { child: r7, parent: l3 } = t6;
      if (r7.is(e7)) {
        o5(l3, e7);
        const t7 = r7.getNextSiblings(), i4 = t7.length;
        if (l3.insertAfter(r7), 0 !== i4) {
          const e8 = n6(l3);
          r7.insertAfter(e8);
          for (let n7 = 0; n7 < i4; n7++)
            e8.append(t7[n7]);
        }
        l3.canBeEmpty() || 0 !== l3.getChildrenSize() || l3.remove();
      }
    }
  });
}
function Y3(e6, n6) {
  const o5 = /* @__PURE__ */ new Map(), r6 = e6._pendingEditorState;
  for (const [e7, r7] of n6._nodeMap) {
    const n7 = $cloneWithProperties2(r7);
    $isTextNode2(n7) && ($isTextNode2(r7) || p3(180), n7.__text = r7.__text), o5.set(e7, n7);
  }
  r6 && (r6._nodeMap = o5), e6._dirtyType = 2;
  const l3 = n6._selection;
  $setSelection2(null === l3 ? null : l3.clone());
}
function Z3(e6) {
  const t5 = $getSelection2() || $getPreviousSelection2();
  if ($isRangeSelection2(t5)) {
    const { focus: n6 } = t5, o5 = n6.getNode(), r6 = n6.offset;
    if ($isRootOrShadowRoot2(o5)) {
      const t6 = o5.getChildAtIndex(r6);
      null == t6 ? o5.append(e6) : t6.insertBefore(e6), e6.selectNext();
    } else {
      let t6, n7;
      $isTextNode2(o5) ? (t6 = o5.getParentOrThrow(), n7 = o5.getIndexWithinParent(), r6 > 0 && (n7 += 1, o5.splitText(r6))) : (t6 = o5, n7 = r6);
      const [, l3] = $splitNode2(t6, n7);
      l3.insertBefore(e6), l3.selectStart();
    }
  } else {
    if (null != t5) {
      const n7 = t5.getNodes();
      n7[n7.length - 1].getTopLevelElementOrThrow().insertAfter(e6);
    } else {
      $getRoot2().append(e6);
    }
    const n6 = $createParagraphNode2();
    e6.insertAfter(n6), n6.select();
  }
  return e6.getLatest();
}
function ee2(e6, t5) {
  const n6 = t5();
  return e6.replace(n6), n6.append(e6), n6;
}
function te2(e6, t5) {
  return null !== e6 && Object.getPrototypeOf(e6).constructor.name === t5.name;
}
function ne2(e6, t5) {
  const n6 = [];
  for (let o5 = 0; o5 < e6.length; o5++) {
    const r6 = t5(e6[o5]);
    null !== r6 && n6.push(r6);
  }
  return n6;
}
function oe2(e6, t5) {
  const n6 = e6.getFirstChild();
  null !== n6 ? n6.insertBefore(t5) : e6.append(t5);
}
function re2(e6) {
  if (z4)
    return 1;
  let t5 = 1;
  for (; e6; )
    t5 *= Number(window.getComputedStyle(e6).getPropertyValue("zoom")), e6 = e6.parentElement;
  return t5;
}
function le2(e6) {
  return null !== e6._parentEditor;
}
var p3, h5, m5, v6, y4, w4, E4, x4, P4, S5, N4, A3, _3, B4, K4, O4, R4, I4, D4, H3, z4, k4, F4, Q3;
var init_LexicalUtils_prod = __esm({
  async "../../../node_modules/.pnpm/@lexical+utils@0.16.1/node_modules/@lexical/utils/LexicalUtils.prod.mjs"() {
    await init_LexicalSelection_node();
    await init_Lexical_node();
    await init_Lexical_node();
    p3 = g4(function(e6) {
      const t5 = new URLSearchParams();
      t5.append("code", e6);
      for (let e7 = 1; e7 < arguments.length; e7++)
        t5.append("v", arguments[e7]);
      throw Error(`Minified Lexical error #${e6}; visit https://lexical.dev/docs/error?${t5} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
    });
    h5 = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
    m5 = h5 && "documentMode" in document ? document.documentMode : null;
    v6 = h5 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    y4 = h5 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    w4 = !(!h5 || !("InputEvent" in window) || m5) && "getTargetRanges" in new window.InputEvent("input");
    E4 = h5 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    x4 = h5 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    P4 = h5 && /Android/.test(navigator.userAgent);
    S5 = h5 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    N4 = h5 && P4 && S5;
    A3 = h5 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !S5;
    _3 = { attributes: true, characterData: true, childList: true, subtree: true };
    B4 = w4;
    K4 = h5;
    O4 = P4;
    R4 = N4;
    I4 = v6;
    D4 = A3;
    H3 = S5;
    z4 = y4;
    k4 = x4;
    F4 = E4;
    Q3 = (e6, t5) => {
      let n6 = e6;
      for (; n6 !== $getRoot2() && null != n6; ) {
        if (t5(n6))
          return n6;
        n6 = n6.getParent();
      }
      return null;
    };
  }
});

// ../../../node_modules/.pnpm/@lexical+utils@0.16.1/node_modules/@lexical/utils/LexicalUtils.node.mjs
var mod3, $dfs2, $filter2, $findMatchingParent2, $getNearestBlockElementAncestorOrThrow2, $getNearestNodeOfType2, $getNextRightPreorderNode2, $insertFirst2, $insertNodeToNearestRoot2, $isEditorIsNestedEditor2, $restoreEditorState2, $splitNode3, $wrapNodeInElement2, CAN_USE_BEFORE_INPUT3, CAN_USE_DOM3, IS_ANDROID3, IS_ANDROID_CHROME3, IS_APPLE3, IS_APPLE_WEBKIT3, IS_CHROME3, IS_FIREFOX3, IS_IOS3, IS_SAFARI3, addClassNamesToElement2, calculateZoomLevel2, isBlockDomNode3, isHTMLAnchorElement3, isHTMLElement4, isInlineDomNode3, isMimeType2, markSelection2, mediaFileReader2, mergeRegister2, objectKlassEquals2, positionNodeOnRange2, registerNestedElementResolver2, removeClassNamesFromElement2;
var init_LexicalUtils_node = __esm({
  async "../../../node_modules/.pnpm/@lexical+utils@0.16.1/node_modules/@lexical/utils/LexicalUtils.node.mjs"() {
    mod3 = await (process.env.NODE_ENV === "development" ? init_LexicalUtils_dev().then(() => LexicalUtils_dev_exports) : init_LexicalUtils_prod().then(() => LexicalUtils_prod_exports));
    $dfs2 = mod3.$dfs;
    $filter2 = mod3.$filter;
    $findMatchingParent2 = mod3.$findMatchingParent;
    $getNearestBlockElementAncestorOrThrow2 = mod3.$getNearestBlockElementAncestorOrThrow;
    $getNearestNodeOfType2 = mod3.$getNearestNodeOfType;
    $getNextRightPreorderNode2 = mod3.$getNextRightPreorderNode;
    $insertFirst2 = mod3.$insertFirst;
    $insertNodeToNearestRoot2 = mod3.$insertNodeToNearestRoot;
    $isEditorIsNestedEditor2 = mod3.$isEditorIsNestedEditor;
    $restoreEditorState2 = mod3.$restoreEditorState;
    $splitNode3 = mod3.$splitNode;
    $wrapNodeInElement2 = mod3.$wrapNodeInElement;
    CAN_USE_BEFORE_INPUT3 = mod3.CAN_USE_BEFORE_INPUT;
    CAN_USE_DOM3 = mod3.CAN_USE_DOM;
    IS_ANDROID3 = mod3.IS_ANDROID;
    IS_ANDROID_CHROME3 = mod3.IS_ANDROID_CHROME;
    IS_APPLE3 = mod3.IS_APPLE;
    IS_APPLE_WEBKIT3 = mod3.IS_APPLE_WEBKIT;
    IS_CHROME3 = mod3.IS_CHROME;
    IS_FIREFOX3 = mod3.IS_FIREFOX;
    IS_IOS3 = mod3.IS_IOS;
    IS_SAFARI3 = mod3.IS_SAFARI;
    addClassNamesToElement2 = mod3.addClassNamesToElement;
    calculateZoomLevel2 = mod3.calculateZoomLevel;
    isBlockDomNode3 = mod3.isBlockDomNode;
    isHTMLAnchorElement3 = mod3.isHTMLAnchorElement;
    isHTMLElement4 = mod3.isHTMLElement;
    isInlineDomNode3 = mod3.isInlineDomNode;
    isMimeType2 = mod3.isMimeType;
    markSelection2 = mod3.markSelection;
    mediaFileReader2 = mod3.mediaFileReader;
    mergeRegister2 = mod3.mergeRegister;
    objectKlassEquals2 = mod3.objectKlassEquals;
    positionNodeOnRange2 = mod3.positionNodeOnRange;
    registerNestedElementResolver2 = mod3.registerNestedElementResolver;
    removeClassNamesFromElement2 = mod3.removeClassNamesFromElement;
  }
});

// ../../../node_modules/.pnpm/@lexical+html@0.16.1/node_modules/@lexical/html/LexicalHtml.dev.mjs
var LexicalHtml_dev_exports = {};
__export(LexicalHtml_dev_exports, {
  $generateHtmlFromNodes: () => $generateHtmlFromNodes,
  $generateNodesFromDOM: () => $generateNodesFromDOM
});
function $generateNodesFromDOM(editor, dom) {
  const elements = dom.body ? dom.body.childNodes : [];
  let lexicalNodes = [];
  const allArtificialNodes = [];
  for (let i4 = 0; i4 < elements.length; i4++) {
    const element = elements[i4];
    if (!IGNORE_TAGS.has(element.nodeName)) {
      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);
      if (lexicalNode !== null) {
        lexicalNodes = lexicalNodes.concat(lexicalNode);
      }
    }
  }
  $unwrapArtificalNodes(allArtificialNodes);
  return lexicalNodes;
}
function $generateHtmlFromNodes(editor, selection) {
  if (typeof document === "undefined" || typeof window === "undefined" && typeof global.window === "undefined") {
    throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  }
  const container = document.createElement("div");
  const root = $getRoot2();
  const topLevelChildren = root.getChildren();
  for (let i4 = 0; i4 < topLevelChildren.length; i4++) {
    const topLevelNode = topLevelChildren[i4];
    $appendNodesToHTML(editor, topLevelNode, container, selection);
  }
  return container.innerHTML;
}
function $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {
  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
  const shouldExclude = $isElementNode2(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection !== null) {
    let clone = $cloneWithProperties2(currentNode);
    clone = $isTextNode2(clone) && selection !== null ? $sliceSelectedTextNodeContent2(selection, clone) : clone;
    target = clone;
  }
  const children = $isElementNode2(target) ? target.getChildren() : [];
  const registeredNode = editor._nodes.get(target.getType());
  let exportOutput;
  if (registeredNode && registeredNode.exportDOM !== void 0) {
    exportOutput = registeredNode.exportDOM(editor, target);
  } else {
    exportOutput = target.exportDOM(editor);
  }
  const {
    element,
    after
  } = exportOutput;
  if (!element) {
    return false;
  }
  const fragment = document.createDocumentFragment();
  for (let i4 = 0; i4 < children.length; i4++) {
    const childNode = children[i4];
    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);
    if (!shouldInclude && $isElementNode2(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "html")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    if (isHTMLElement4(element)) {
      element.append(fragment);
    }
    parentElement.append(element);
    if (after) {
      const newElement = after.call(target, element);
      if (newElement) {
        element.replaceWith(newElement);
      }
    }
  } else {
    parentElement.append(fragment);
  }
  return shouldInclude;
}
function getConversionFunction(domNode, editor) {
  const {
    nodeName
  } = domNode;
  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
  let currentConversion = null;
  if (cachedConversions !== void 0) {
    for (const cachedConversion of cachedConversions) {
      const domConversion = cachedConversion(domNode);
      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {
        currentConversion = domConversion;
      }
    }
  }
  return currentConversion !== null ? currentConversion.conversion : null;
}
function $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
  let lexicalNodes = [];
  if (IGNORE_TAGS.has(node.nodeName)) {
    return lexicalNodes;
  }
  let currentLexicalNode = null;
  const transformFunction = getConversionFunction(node, editor);
  const transformOutput = transformFunction ? transformFunction(node) : null;
  let postTransform = null;
  if (transformOutput !== null) {
    postTransform = transformOutput.after;
    const transformNodes = transformOutput.node;
    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
    if (currentLexicalNode !== null) {
      for (const [, forChildFunction] of forChildMap) {
        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
        if (!currentLexicalNode) {
          break;
        }
      }
      if (currentLexicalNode) {
        lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
      }
    }
    if (transformOutput.forChild != null) {
      forChildMap.set(node.nodeName, transformOutput.forChild);
    }
  }
  const children = node.childNodes;
  let childLexicalNodes = [];
  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot2(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode2(currentLexicalNode) || hasBlockAncestorLexicalNode;
  for (let i4 = 0; i4 < children.length; i4++) {
    childLexicalNodes.push(...$createNodesFromDOM(children[i4], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));
  }
  if (postTransform != null) {
    childLexicalNodes = postTransform(childLexicalNodes);
  }
  if (isBlockDomNode3(node)) {
    if (!hasBlockAncestorLexicalNodeForChildren) {
      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode2);
    } else {
      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {
        const artificialNode = new ArtificialNode__DO_NOT_USE2();
        allArtificialNodes.push(artificialNode);
        return artificialNode;
      });
    }
  }
  if (currentLexicalNode == null) {
    lexicalNodes = lexicalNodes.concat(childLexicalNodes);
  } else {
    if ($isElementNode2(currentLexicalNode)) {
      currentLexicalNode.append(...childLexicalNodes);
    }
  }
  return lexicalNodes;
}
function wrapContinuousInlines(domNode, nodes, createWrapperFn) {
  const textAlign = domNode.style.textAlign;
  const out = [];
  let continuousInlines = [];
  for (let i4 = 0; i4 < nodes.length; i4++) {
    const node = nodes[i4];
    if ($isBlockElementNode2(node)) {
      if (textAlign && !node.getFormat()) {
        node.setFormat(textAlign);
      }
      out.push(node);
    } else {
      continuousInlines.push(node);
      if (i4 === nodes.length - 1 || i4 < nodes.length - 1 && $isBlockElementNode2(nodes[i4 + 1])) {
        const wrapper = createWrapperFn();
        wrapper.setFormat(textAlign);
        wrapper.append(...continuousInlines);
        out.push(wrapper);
        continuousInlines = [];
      }
    }
  }
  return out;
}
function $unwrapArtificalNodes(allArtificialNodes) {
  for (const node of allArtificialNodes) {
    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE2) {
      node.insertAfter($createLineBreakNode2());
    }
  }
  for (const node of allArtificialNodes) {
    const children = node.getChildren();
    for (const child of children) {
      node.insertBefore(child);
    }
    node.remove();
  }
}
var IGNORE_TAGS;
var init_LexicalHtml_dev = __esm({
  async "../../../node_modules/.pnpm/@lexical+html@0.16.1/node_modules/@lexical/html/LexicalHtml.dev.mjs"() {
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  }
});

// ../../../node_modules/.pnpm/@lexical+html@0.16.1/node_modules/@lexical/html/LexicalHtml.prod.mjs
var LexicalHtml_prod_exports = {};
__export(LexicalHtml_prod_exports, {
  $generateHtmlFromNodes: () => h6,
  $generateNodesFromDOM: () => d3
});
function d3(e6, n6) {
  const t5 = n6.body ? n6.body.childNodes : [];
  let o5 = [];
  const l3 = [];
  for (let n7 = 0; n7 < t5.length; n7++) {
    const r6 = t5[n7];
    if (!m6.has(r6.nodeName)) {
      const n8 = g5(r6, e6, l3, false);
      null !== n8 && (o5 = o5.concat(n8));
    }
  }
  return function(e7) {
    for (const n7 of e7)
      n7.getNextSibling() instanceof ArtificialNode__DO_NOT_USE2 && n7.insertAfter($createLineBreakNode2());
    for (const n7 of e7) {
      const e8 = n7.getChildren();
      for (const t6 of e8)
        n7.insertBefore(t6);
      n7.remove();
    }
  }(l3), o5;
}
function h6(e6, n6) {
  if ("undefined" == typeof document || "undefined" == typeof window && void 0 === global.window)
    throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  const t5 = document.createElement("div"), o5 = $getRoot2().getChildren();
  for (let l3 = 0; l3 < o5.length; l3++) {
    p4(e6, o5[l3], t5, n6);
  }
  return t5.innerHTML;
}
function p4(o5, l3, s3, c5 = null) {
  let u3 = null === c5 || l3.isSelected(c5);
  const f5 = $isElementNode2(l3) && l3.excludeFromCopy("html");
  let a3 = l3;
  if (null !== c5) {
    let t5 = $cloneWithProperties2(l3);
    t5 = $isTextNode2(t5) && null !== c5 ? $sliceSelectedTextNodeContent2(c5, t5) : t5, a3 = t5;
  }
  const d4 = $isElementNode2(a3) ? a3.getChildren() : [], h7 = o5._nodes.get(a3.getType());
  let m7;
  m7 = h7 && void 0 !== h7.exportDOM ? h7.exportDOM(o5, a3) : a3.exportDOM(o5);
  const { element: g6, after: y7 } = m7;
  if (!g6)
    return false;
  const w6 = document.createDocumentFragment();
  for (let e6 = 0; e6 < d4.length; e6++) {
    const n6 = d4[e6], t5 = p4(o5, n6, w6, c5);
    !u3 && $isElementNode2(l3) && t5 && l3.extractWithChild(n6, c5, "html") && (u3 = true);
  }
  if (u3 && !f5) {
    if (isHTMLElement4(g6) && g6.append(w6), s3.append(g6), y7) {
      const e6 = y7.call(a3, g6);
      e6 && g6.replaceWith(e6);
    }
  } else
    s3.append(w6);
  return u3;
}
function g5(e6, n6, t5, l3, i4 = /* @__PURE__ */ new Map(), f5) {
  let d4 = [];
  if (m6.has(e6.nodeName))
    return d4;
  let h7 = null;
  const p5 = function(e7, n7) {
    const { nodeName: t6 } = e7, o5 = n7._htmlConversions.get(t6.toLowerCase());
    let l4 = null;
    if (void 0 !== o5)
      for (const n8 of o5) {
        const t7 = n8(e7);
        null !== t7 && (null === l4 || (l4.priority || 0) < (t7.priority || 0)) && (l4 = t7);
      }
    return null !== l4 ? l4.conversion : null;
  }(e6, n6), w6 = p5 ? p5(e6) : null;
  let x6 = null;
  if (null !== w6) {
    x6 = w6.after;
    const n7 = w6.node;
    if (h7 = Array.isArray(n7) ? n7[n7.length - 1] : n7, null !== h7) {
      for (const [, e7] of i4)
        if (h7 = e7(h7, f5), !h7)
          break;
      h7 && d4.push(...Array.isArray(n7) ? n7 : [h7]);
    }
    null != w6.forChild && i4.set(e6.nodeName, w6.forChild);
  }
  const C5 = e6.childNodes;
  let N6 = [];
  const b5 = (null == h7 || !$isRootOrShadowRoot2(h7)) && (null != h7 && $isBlockElementNode2(h7) || l3);
  for (let e7 = 0; e7 < C5.length; e7++)
    N6.push(...g5(C5[e7], n6, t5, b5, new Map(i4), h7));
  return null != x6 && (N6 = x6(N6)), isBlockDomNode3(e6) && (N6 = y5(e6, N6, b5 ? () => {
    const e7 = new ArtificialNode__DO_NOT_USE2();
    return t5.push(e7), e7;
  } : $createParagraphNode2)), null == h7 ? d4 = d4.concat(N6) : $isElementNode2(h7) && h7.append(...N6), d4;
}
function y5(e6, n6, t5) {
  const o5 = e6.style.textAlign, l3 = [];
  let r6 = [];
  for (let e7 = 0; e7 < n6.length; e7++) {
    const i4 = n6[e7];
    if ($isBlockElementNode2(i4))
      o5 && !i4.getFormat() && i4.setFormat(o5), l3.push(i4);
    else if (r6.push(i4), e7 === n6.length - 1 || e7 < n6.length - 1 && $isBlockElementNode2(n6[e7 + 1])) {
      const e8 = t5();
      e8.setFormat(o5), e8.append(...r6), l3.push(e8), r6 = [];
    }
  }
  return l3;
}
var m6;
var init_LexicalHtml_prod = __esm({
  async "../../../node_modules/.pnpm/@lexical+html@0.16.1/node_modules/@lexical/html/LexicalHtml.prod.mjs"() {
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    m6 = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  }
});

// ../../../node_modules/.pnpm/@lexical+html@0.16.1/node_modules/@lexical/html/LexicalHtml.node.mjs
var mod4, $generateHtmlFromNodes2, $generateNodesFromDOM2;
var init_LexicalHtml_node = __esm({
  async "../../../node_modules/.pnpm/@lexical+html@0.16.1/node_modules/@lexical/html/LexicalHtml.node.mjs"() {
    mod4 = await (process.env.NODE_ENV === "development" ? init_LexicalHtml_dev().then(() => LexicalHtml_dev_exports) : init_LexicalHtml_prod().then(() => LexicalHtml_prod_exports));
    $generateHtmlFromNodes2 = mod4.$generateHtmlFromNodes;
    $generateNodesFromDOM2 = mod4.$generateNodesFromDOM;
  }
});

// ../../../node_modules/.pnpm/@lexical+clipboard@0.16.1/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs
var LexicalClipboard_dev_exports = {};
__export(LexicalClipboard_dev_exports, {
  $generateJSONFromSelectedNodes: () => $generateJSONFromSelectedNodes,
  $generateNodesFromSerializedNodes: () => $generateNodesFromSerializedNodes,
  $getHtmlContent: () => $getHtmlContent,
  $getLexicalContent: () => $getLexicalContent,
  $insertDataTransferForPlainText: () => $insertDataTransferForPlainText,
  $insertDataTransferForRichText: () => $insertDataTransferForRichText,
  $insertGeneratedNodes: () => $insertGeneratedNodes,
  copyToClipboard: () => copyToClipboard
});
function $getHtmlContent(editor) {
  const selection = $getSelection2();
  if (selection == null) {
    {
      throw Error(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection2(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    return "";
  }
  return $generateHtmlFromNodes2(editor, selection);
}
function $getLexicalContent(editor) {
  const selection = $getSelection2();
  if (selection == null) {
    {
      throw Error(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection2(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    return null;
  }
  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));
}
function $insertDataTransferForPlainText(dataTransfer, selection) {
  const text = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
  if (text != null) {
    selection.insertRawText(text);
  }
}
function $insertDataTransferForRichText(dataTransfer, selection, editor) {
  const lexicalString = dataTransfer.getData("application/x-lexical-editor");
  if (lexicalString) {
    try {
      const payload = JSON.parse(lexicalString);
      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
        const nodes = $generateNodesFromSerializedNodes(payload.nodes);
        return $insertGeneratedNodes(editor, nodes, selection);
      }
    } catch (_unused) {
    }
  }
  const htmlString = dataTransfer.getData("text/html");
  if (htmlString) {
    try {
      const parser2 = new DOMParser();
      const dom = parser2.parseFromString(htmlString, "text/html");
      const nodes = $generateNodesFromDOM2(editor, dom);
      return $insertGeneratedNodes(editor, nodes, selection);
    } catch (_unused2) {
    }
  }
  const text = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
  if (text != null) {
    if ($isRangeSelection2(selection)) {
      const parts = text.split(/(\r?\n|\t)/);
      if (parts[parts.length - 1] === "") {
        parts.pop();
      }
      for (let i4 = 0; i4 < parts.length; i4++) {
        const currentSelection = $getSelection2();
        if ($isRangeSelection2(currentSelection)) {
          const part = parts[i4];
          if (part === "\n" || part === "\r\n") {
            currentSelection.insertParagraph();
          } else if (part === "	") {
            currentSelection.insertNodes([$createTabNode2()]);
          } else {
            currentSelection.insertText(part);
          }
        }
      }
    } else {
      selection.insertRawText(text);
    }
  }
}
function $insertGeneratedNodes(editor, nodes, selection) {
  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, {
    nodes,
    selection
  })) {
    selection.insertNodes(nodes);
  }
  return;
}
function exportNodeToJSON2(node) {
  const serializedNode = node.exportJSON();
  const nodeClass = node.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
    }
  }
  if ($isElementNode2(node)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
  }
  return serializedNode;
}
function $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {
  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
  const shouldExclude = $isElementNode2(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection !== null) {
    let clone = $cloneWithProperties2(currentNode);
    clone = $isTextNode2(clone) && selection !== null ? $sliceSelectedTextNodeContent2(selection, clone) : clone;
    target = clone;
  }
  const children = $isElementNode2(target) ? target.getChildren() : [];
  const serializedNode = exportNodeToJSON2(target);
  if ($isTextNode2(target)) {
    const text = target.__text;
    if (text.length > 0) {
      serializedNode.text = text;
    } else {
      shouldInclude = false;
    }
  }
  for (let i4 = 0; i4 < children.length; i4++) {
    const childNode = children[i4];
    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);
    if (!shouldInclude && $isElementNode2(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "clone")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    targetArray.push(serializedNode);
  } else if (Array.isArray(serializedNode.children)) {
    for (let i4 = 0; i4 < serializedNode.children.length; i4++) {
      const serializedChildNode = serializedNode.children[i4];
      targetArray.push(serializedChildNode);
    }
  }
  return shouldInclude;
}
function $generateJSONFromSelectedNodes(editor, selection) {
  const nodes = [];
  const root = $getRoot2();
  const topLevelChildren = root.getChildren();
  for (let i4 = 0; i4 < topLevelChildren.length; i4++) {
    const topLevelNode = topLevelChildren[i4];
    $appendNodesToJSON(editor, selection, topLevelNode, nodes);
  }
  return {
    namespace: editor._config.namespace,
    nodes
  };
}
function $generateNodesFromSerializedNodes(serializedNodes) {
  const nodes = [];
  for (let i4 = 0; i4 < serializedNodes.length; i4++) {
    const serializedNode = serializedNodes[i4];
    const node = $parseSerializedNode2(serializedNode);
    if ($isTextNode2(node)) {
      $addNodeStyle2(node);
    }
    nodes.push(node);
  }
  return nodes;
}
async function copyToClipboard(editor, event) {
  if (clipboardEventTimeout !== null) {
    return false;
  }
  if (event !== null) {
    return new Promise((resolve, reject) => {
      editor.update(() => {
        resolve($copyToClipboardEvent(editor, event));
      });
    });
  }
  const rootElement = editor.getRootElement();
  const windowDocument = editor._window == null ? window.document : editor._window.document;
  const domSelection = getDOMSelection2(editor._window);
  if (rootElement === null || domSelection === null) {
    return false;
  }
  const element = windowDocument.createElement("span");
  element.style.cssText = "position: fixed; top: -1000px;";
  element.append(windowDocument.createTextNode("#"));
  rootElement.append(element);
  const range = new Range();
  range.setStart(element, 0);
  range.setEnd(element, 1);
  domSelection.removeAllRanges();
  domSelection.addRange(range);
  return new Promise((resolve, reject) => {
    const removeListener = editor.registerCommand(COPY_COMMAND2, (secondEvent) => {
      if (objectKlassEquals2(secondEvent, ClipboardEvent)) {
        removeListener();
        if (clipboardEventTimeout !== null) {
          window.clearTimeout(clipboardEventTimeout);
          clipboardEventTimeout = null;
        }
        resolve($copyToClipboardEvent(editor, secondEvent));
      }
      return true;
    }, COMMAND_PRIORITY_CRITICAL2);
    clipboardEventTimeout = window.setTimeout(() => {
      removeListener();
      clipboardEventTimeout = null;
      resolve(false);
    }, EVENT_LATENCY);
    windowDocument.execCommand("copy");
    element.remove();
  });
}
function $copyToClipboardEvent(editor, event) {
  const domSelection = getDOMSelection2(editor._window);
  if (!domSelection) {
    return false;
  }
  const anchorDOM = domSelection.anchorNode;
  const focusDOM = domSelection.focusNode;
  if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor2(editor, anchorDOM, focusDOM)) {
    return false;
  }
  event.preventDefault();
  const clipboardData = event.clipboardData;
  const selection = $getSelection2();
  if (clipboardData === null || selection === null) {
    return false;
  }
  const htmlString = $getHtmlContent(editor);
  const lexicalString = $getLexicalContent(editor);
  let plainString = "";
  if (selection !== null) {
    plainString = selection.getTextContent();
  }
  if (htmlString !== null) {
    clipboardData.setData("text/html", htmlString);
  }
  if (lexicalString !== null) {
    clipboardData.setData("application/x-lexical-editor", lexicalString);
  }
  clipboardData.setData("text/plain", plainString);
  return true;
}
var CAN_USE_DOM4, getDOMSelection2, EVENT_LATENCY, clipboardEventTimeout;
var init_LexicalClipboard_dev = __esm({
  async "../../../node_modules/.pnpm/@lexical+clipboard@0.16.1/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs"() {
    await init_LexicalHtml_node();
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    CAN_USE_DOM4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    getDOMSelection2 = (targetWindow) => CAN_USE_DOM4 ? (targetWindow || window).getSelection() : null;
    EVENT_LATENCY = 50;
    clipboardEventTimeout = null;
  }
});

// ../../../node_modules/.pnpm/@lexical+clipboard@0.16.1/node_modules/@lexical/clipboard/LexicalClipboard.prod.mjs
var LexicalClipboard_prod_exports = {};
__export(LexicalClipboard_prod_exports, {
  $generateJSONFromSelectedNodes: () => A4,
  $generateNodesFromSerializedNodes: () => R5,
  $getHtmlContent: () => D5,
  $getLexicalContent: () => C4,
  $insertDataTransferForPlainText: () => N5,
  $insertDataTransferForRichText: () => _4,
  $insertGeneratedNodes: () => T5,
  copyToClipboard: () => O5
});
function x5(t5) {
  return t5 && t5.__esModule && Object.prototype.hasOwnProperty.call(t5, "default") ? t5.default : t5;
}
function D5(e6) {
  const n6 = $getSelection2();
  return null == n6 && w5(166), $isRangeSelection2(n6) && n6.isCollapsed() || 0 === n6.getNodes().length ? "" : $generateHtmlFromNodes2(e6, n6);
}
function C4(t5) {
  const e6 = $getSelection2();
  return null == e6 && w5(166), $isRangeSelection2(e6) && e6.isCollapsed() || 0 === e6.getNodes().length ? null : JSON.stringify(A4(t5, e6));
}
function N5(t5, e6) {
  const n6 = t5.getData("text/plain") || t5.getData("text/uri-list");
  null != n6 && e6.insertRawText(n6);
}
function _4(t5, n6, o5) {
  const l3 = t5.getData("application/x-lexical-editor");
  if (l3)
    try {
      const t6 = JSON.parse(l3);
      if (t6.namespace === o5._config.namespace && Array.isArray(t6.nodes)) {
        return T5(o5, R5(t6.nodes), n6);
      }
    } catch (t6) {
    }
  const r6 = t5.getData("text/html");
  if (r6)
    try {
      const t6 = new DOMParser().parseFromString(r6, "text/html");
      return T5(o5, $generateNodesFromDOM2(o5, t6), n6);
    } catch (t6) {
    }
  const c5 = t5.getData("text/plain") || t5.getData("text/uri-list");
  if (null != c5)
    if ($isRangeSelection2(n6)) {
      const t6 = c5.split(/(\r?\n|\t)/);
      "" === t6[t6.length - 1] && t6.pop();
      for (let e6 = 0; e6 < t6.length; e6++) {
        const n7 = $getSelection2();
        if ($isRangeSelection2(n7)) {
          const o6 = t6[e6];
          "\n" === o6 || "\r\n" === o6 ? n7.insertParagraph() : "	" === o6 ? n7.insertNodes([$createTabNode2()]) : n7.insertText(o6);
        }
      }
    } else
      n6.insertRawText(c5);
}
function T5(t5, e6, n6) {
  t5.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, { nodes: e6, selection: n6 }) || n6.insertNodes(e6);
}
function S6(t5, e6, n6, r6 = []) {
  let i4 = null === e6 || n6.isSelected(e6);
  const s3 = $isElementNode2(n6) && n6.excludeFromCopy("html");
  let a3 = n6;
  if (null !== e6) {
    let t6 = $cloneWithProperties2(n6);
    t6 = $isTextNode2(t6) && null !== e6 ? $sliceSelectedTextNodeContent2(e6, t6) : t6, a3 = t6;
  }
  const c5 = $isElementNode2(a3) ? a3.getChildren() : [], u3 = function(t6) {
    const e7 = t6.exportJSON(), n7 = t6.constructor;
    if (e7.type !== n7.getType() && w5(58, n7.name), $isElementNode2(t6)) {
      const t7 = e7.children;
      Array.isArray(t7) || w5(59, n7.name);
    }
    return e7;
  }(a3);
  if ($isTextNode2(a3)) {
    const t6 = a3.__text;
    t6.length > 0 ? u3.text = t6 : i4 = false;
  }
  for (let o5 = 0; o5 < c5.length; o5++) {
    const l3 = c5[o5], r7 = S6(t5, e6, l3, u3.children);
    !i4 && $isElementNode2(n6) && r7 && n6.extractWithChild(l3, e6, "clone") && (i4 = true);
  }
  if (i4 && !s3)
    r6.push(u3);
  else if (Array.isArray(u3.children))
    for (let t6 = 0; t6 < u3.children.length; t6++) {
      const e7 = u3.children[t6];
      r6.push(e7);
    }
  return i4;
}
function A4(t5, e6) {
  const n6 = [], o5 = $getRoot2().getChildren();
  for (let l3 = 0; l3 < o5.length; l3++) {
    S6(t5, e6, o5[l3], n6);
  }
  return { namespace: t5._config.namespace, nodes: n6 };
}
function R5(t5) {
  const e6 = [];
  for (let o5 = 0; o5 < t5.length; o5++) {
    const l3 = t5[o5], r6 = $parseSerializedNode2(l3);
    $isTextNode2(r6) && $addNodeStyle2(r6), e6.push(r6);
  }
  return e6;
}
async function O5(t5, e6) {
  if (null !== E5)
    return false;
  if (null !== e6)
    return new Promise((n7, o6) => {
      t5.update(() => {
        n7(P5(t5, e6));
      });
    });
  const n6 = t5.getRootElement(), o5 = null == t5._window ? window.document : t5._window.document, l3 = v7(t5._window);
  if (null === n6 || null === l3)
    return false;
  const i4 = o5.createElement("span");
  i4.style.cssText = "position: fixed; top: -1000px;", i4.append(o5.createTextNode("#")), n6.append(i4);
  const s3 = new Range();
  return s3.setStart(i4, 0), s3.setEnd(i4, 1), l3.removeAllRanges(), l3.addRange(s3), new Promise((e7, n7) => {
    const l4 = t5.registerCommand(COPY_COMMAND2, (n8) => (objectKlassEquals2(n8, ClipboardEvent) && (l4(), null !== E5 && (window.clearTimeout(E5), E5 = null), e7(P5(t5, n8))), true), COMMAND_PRIORITY_CRITICAL2);
    E5 = window.setTimeout(() => {
      l4(), E5 = null, e7(false);
    }, 50), o5.execCommand("copy"), i4.remove();
  });
}
function P5(t5, e6) {
  const n6 = v7(t5._window);
  if (!n6)
    return false;
  const o5 = n6.anchorNode, l3 = n6.focusNode;
  if (null !== o5 && null !== l3 && !isSelectionWithinEditor2(t5, o5, l3))
    return false;
  e6.preventDefault();
  const r6 = e6.clipboardData, s3 = $getSelection2();
  if (null === r6 || null === s3)
    return false;
  const a3 = D5(t5), c5 = C4(t5);
  let u3 = "";
  return null !== s3 && (u3 = s3.getTextContent()), null !== a3 && r6.setData("text/html", a3), null !== c5 && r6.setData("application/x-lexical-editor", c5), r6.setData("text/plain", u3), true;
}
var w5, y6, v7, E5;
var init_LexicalClipboard_prod = __esm({
  async "../../../node_modules/.pnpm/@lexical+clipboard@0.16.1/node_modules/@lexical/clipboard/LexicalClipboard.prod.mjs"() {
    await init_LexicalHtml_node();
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    w5 = x5(function(t5) {
      const e6 = new URLSearchParams();
      e6.append("code", t5);
      for (let t6 = 1; t6 < arguments.length; t6++)
        e6.append("v", arguments[t6]);
      throw Error(`Minified Lexical error #${t5}; visit https://lexical.dev/docs/error?${e6} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
    });
    y6 = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
    v7 = (t5) => y6 ? (t5 || window).getSelection() : null;
    E5 = null;
  }
});

// ../../../node_modules/.pnpm/@lexical+clipboard@0.16.1/node_modules/@lexical/clipboard/LexicalClipboard.node.mjs
var mod5, $generateJSONFromSelectedNodes2, $generateNodesFromSerializedNodes2, $getHtmlContent2, $getLexicalContent2, $insertDataTransferForPlainText2, $insertDataTransferForRichText2, $insertGeneratedNodes2, copyToClipboard2;
var init_LexicalClipboard_node = __esm({
  async "../../../node_modules/.pnpm/@lexical+clipboard@0.16.1/node_modules/@lexical/clipboard/LexicalClipboard.node.mjs"() {
    mod5 = await (process.env.NODE_ENV === "development" ? init_LexicalClipboard_dev().then(() => LexicalClipboard_dev_exports) : init_LexicalClipboard_prod().then(() => LexicalClipboard_prod_exports));
    $generateJSONFromSelectedNodes2 = mod5.$generateJSONFromSelectedNodes;
    $generateNodesFromSerializedNodes2 = mod5.$generateNodesFromSerializedNodes;
    $getHtmlContent2 = mod5.$getHtmlContent;
    $getLexicalContent2 = mod5.$getLexicalContent;
    $insertDataTransferForPlainText2 = mod5.$insertDataTransferForPlainText;
    $insertDataTransferForRichText2 = mod5.$insertDataTransferForRichText;
    $insertGeneratedNodes2 = mod5.$insertGeneratedNodes;
    copyToClipboard2 = mod5.copyToClipboard;
  }
});

// ../../../node_modules/.pnpm/@lexical+plain-text@0.16.1/node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs
var LexicalPlainText_dev_exports = {};
__export(LexicalPlainText_dev_exports, {
  registerPlainText: () => registerPlainText
});
function onCopyForPlainText(event, editor) {
  editor.update(() => {
    if (event !== null) {
      const clipboardData = objectKlassEquals2(event, KeyboardEvent) ? null : event.clipboardData;
      const selection = $getSelection2();
      if (selection !== null && clipboardData != null) {
        event.preventDefault();
        const htmlString = $getHtmlContent2(editor);
        if (htmlString !== null) {
          clipboardData.setData("text/html", htmlString);
        }
        clipboardData.setData("text/plain", selection.getTextContent());
      }
    }
  });
}
function onPasteForPlainText(event, editor) {
  event.preventDefault();
  editor.update(() => {
    const selection = $getSelection2();
    const {
      clipboardData
    } = event;
    if (clipboardData != null && $isRangeSelection2(selection)) {
      $insertDataTransferForPlainText2(clipboardData, selection);
    }
  }, {
    tag: "paste"
  });
}
function onCutForPlainText(event, editor) {
  onCopyForPlainText(event, editor);
  editor.update(() => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      selection.removeText();
    }
  });
}
function registerPlainText(editor) {
  const removeListener = mergeRegister2(editor.registerCommand(DELETE_CHARACTER_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.deleteCharacter(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_WORD_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.deleteWord(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_LINE_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.deleteLine(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (eventOrText) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    if (typeof eventOrText === "string") {
      selection.insertText(eventOrText);
    } else {
      const dataTransfer = eventOrText.dataTransfer;
      if (dataTransfer != null) {
        $insertDataTransferForPlainText2(dataTransfer, selection);
      } else {
        const data = eventOrText.data;
        if (data) {
          selection.insertText(data);
        }
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(REMOVE_TEXT_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.removeText();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_LINE_BREAK_COMMAND2, (selectStart) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.insertLineBreak(selectStart);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.insertLineBreak();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, (payload) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const event = payload;
    const isHoldingShift = event.shiftKey;
    if ($shouldOverrideDefaultCharacterSelection2(selection, true)) {
      event.preventDefault();
      $moveCharacter2(selection, isHoldingShift, true);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND2, (payload) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const event = payload;
    const isHoldingShift = event.shiftKey;
    if ($shouldOverrideDefaultCharacterSelection2(selection, false)) {
      event.preventDefault();
      $moveCharacter2(selection, isHoldingShift, false);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_BACKSPACE_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, true);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_DELETE_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, false);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ENTER_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    if (event !== null) {
      if ((IS_IOS4 || IS_SAFARI4 || IS_APPLE_WEBKIT4) && CAN_USE_BEFORE_INPUT4) {
        return false;
      }
      event.preventDefault();
    }
    return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND2, false);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(SELECT_ALL_COMMAND2, () => {
    $selectAll2();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(COPY_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    onCopyForPlainText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CUT_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    onCutForPlainText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(PASTE_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    onPasteForPlainText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DROP_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    event.preventDefault();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DRAGSTART_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    event.preventDefault();
    return true;
  }, COMMAND_PRIORITY_EDITOR2));
  return removeListener;
}
var CAN_USE_DOM5, documentMode3, CAN_USE_BEFORE_INPUT4, IS_SAFARI4, IS_IOS4, IS_CHROME4, IS_APPLE_WEBKIT4;
var init_LexicalPlainText_dev = __esm({
  async "../../../node_modules/.pnpm/@lexical+plain-text@0.16.1/node_modules/@lexical/plain-text/LexicalPlainText.dev.mjs"() {
    await init_LexicalClipboard_node();
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    CAN_USE_DOM5 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    documentMode3 = CAN_USE_DOM5 && "documentMode" in document ? document.documentMode : null;
    CAN_USE_BEFORE_INPUT4 = CAN_USE_DOM5 && "InputEvent" in window && !documentMode3 ? "getTargetRanges" in new window.InputEvent("input") : false;
    IS_SAFARI4 = CAN_USE_DOM5 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    IS_IOS4 = CAN_USE_DOM5 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    IS_CHROME4 = CAN_USE_DOM5 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    IS_APPLE_WEBKIT4 = CAN_USE_DOM5 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME4;
  }
});

// ../../../node_modules/.pnpm/@lexical+plain-text@0.16.1/node_modules/@lexical/plain-text/LexicalPlainText.prod.mjs
var LexicalPlainText_prod_exports = {};
__export(LexicalPlainText_prod_exports, {
  registerPlainText: () => R6
});
function W3(e6, n6) {
  n6.update(() => {
    if (null !== e6) {
      const r6 = objectKlassEquals2(e6, KeyboardEvent) ? null : e6.clipboardData, o5 = $getSelection2();
      if (null !== o5 && null != r6) {
        e6.preventDefault();
        const i4 = $getHtmlContent2(n6);
        null !== i4 && r6.setData("text/html", i4), r6.setData("text/plain", o5.getTextContent());
      }
    }
  });
}
function R6(t5) {
  return mergeRegister2(t5.registerCommand(DELETE_CHARACTER_COMMAND2, (e6) => {
    const t6 = $getSelection2();
    return !!$isRangeSelection2(t6) && (t6.deleteCharacter(e6), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(DELETE_WORD_COMMAND2, (e6) => {
    const t6 = $getSelection2();
    return !!$isRangeSelection2(t6) && (t6.deleteWord(e6), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(DELETE_LINE_COMMAND2, (e6) => {
    const t6 = $getSelection2();
    return !!$isRangeSelection2(t6) && (t6.deleteLine(e6), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (t6) => {
    const n6 = $getSelection2();
    if (!$isRangeSelection2(n6))
      return false;
    if ("string" == typeof t6)
      n6.insertText(t6);
    else {
      const r6 = t6.dataTransfer;
      if (null != r6)
        $insertDataTransferForPlainText2(r6, n6);
      else {
        const e6 = t6.data;
        e6 && n6.insertText(e6);
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(REMOVE_TEXT_COMMAND2, () => {
    const e6 = $getSelection2();
    return !!$isRangeSelection2(e6) && (e6.removeText(), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(INSERT_LINE_BREAK_COMMAND2, (e6) => {
    const t6 = $getSelection2();
    return !!$isRangeSelection2(t6) && (t6.insertLineBreak(e6), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
    const e6 = $getSelection2();
    return !!$isRangeSelection2(e6) && (e6.insertLineBreak(), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(KEY_ARROW_LEFT_COMMAND2, (e6) => {
    const t6 = $getSelection2();
    if (!$isRangeSelection2(t6))
      return false;
    const o5 = e6, i4 = o5.shiftKey;
    return !!$shouldOverrideDefaultCharacterSelection2(t6, true) && (o5.preventDefault(), $moveCharacter2(t6, i4, true), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(KEY_ARROW_RIGHT_COMMAND2, (e6) => {
    const t6 = $getSelection2();
    if (!$isRangeSelection2(t6))
      return false;
    const o5 = e6, i4 = o5.shiftKey;
    return !!$shouldOverrideDefaultCharacterSelection2(t6, false) && (o5.preventDefault(), $moveCharacter2(t6, i4, false), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(KEY_BACKSPACE_COMMAND2, (e6) => {
    const n6 = $getSelection2();
    return !!$isRangeSelection2(n6) && (e6.preventDefault(), t5.dispatchCommand(DELETE_CHARACTER_COMMAND2, true));
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(KEY_DELETE_COMMAND2, (e6) => {
    const n6 = $getSelection2();
    return !!$isRangeSelection2(n6) && (e6.preventDefault(), t5.dispatchCommand(DELETE_CHARACTER_COMMAND2, false));
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(KEY_ENTER_COMMAND2, (e6) => {
    const n6 = $getSelection2();
    if (!$isRangeSelection2(n6))
      return false;
    if (null !== e6) {
      if ((k5 || S7 || I5) && P6)
        return false;
      e6.preventDefault();
    }
    return t5.dispatchCommand(INSERT_LINE_BREAK_COMMAND2, false);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(SELECT_ALL_COMMAND2, () => ($selectAll2(), true), COMMAND_PRIORITY_EDITOR2), t5.registerCommand(COPY_COMMAND2, (e6) => {
    const n6 = $getSelection2();
    return !!$isRangeSelection2(n6) && (W3(e6, t5), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(CUT_COMMAND2, (e6) => {
    const n6 = $getSelection2();
    return !!$isRangeSelection2(n6) && (function(e7, t6) {
      W3(e7, t6), t6.update(() => {
        const e8 = $getSelection2();
        $isRangeSelection2(e8) && e8.removeText();
      });
    }(e6, t5), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(PASTE_COMMAND2, (n6) => {
    const r6 = $getSelection2();
    return !!$isRangeSelection2(r6) && (function(t6, n7) {
      t6.preventDefault(), n7.update(() => {
        const n8 = $getSelection2(), { clipboardData: r7 } = t6;
        null != r7 && $isRangeSelection2(n8) && $insertDataTransferForPlainText2(r7, n8);
      }, { tag: "paste" });
    }(n6, t5), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(DROP_COMMAND2, (e6) => {
    const t6 = $getSelection2();
    return !!$isRangeSelection2(t6) && (e6.preventDefault(), true);
  }, COMMAND_PRIORITY_EDITOR2), t5.registerCommand(DRAGSTART_COMMAND2, (e6) => {
    const t6 = $getSelection2();
    return !!$isRangeSelection2(t6) && (e6.preventDefault(), true);
  }, COMMAND_PRIORITY_EDITOR2));
}
var L4, M5, P6, S7, k5, B5, I5;
var init_LexicalPlainText_prod = __esm({
  async "../../../node_modules/.pnpm/@lexical+plain-text@0.16.1/node_modules/@lexical/plain-text/LexicalPlainText.prod.mjs"() {
    await init_LexicalClipboard_node();
    await init_LexicalSelection_node();
    await init_LexicalUtils_node();
    await init_Lexical_node();
    L4 = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
    M5 = L4 && "documentMode" in document ? document.documentMode : null;
    P6 = !(!L4 || !("InputEvent" in window) || M5) && "getTargetRanges" in new window.InputEvent("input");
    S7 = L4 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    k5 = L4 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    B5 = L4 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    I5 = L4 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !B5;
  }
});

// ../../../node_modules/.pnpm/@lit-labs+ssr-dom-shim@1.2.1/node_modules/@lit-labs/ssr-dom-shim/lib/element-internals.js
var ElementInternalsShim = class ElementInternals {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(_host) {
    this.ariaAtomic = "";
    this.ariaAutoComplete = "";
    this.ariaBrailleLabel = "";
    this.ariaBrailleRoleDescription = "";
    this.ariaBusy = "";
    this.ariaChecked = "";
    this.ariaColCount = "";
    this.ariaColIndex = "";
    this.ariaColSpan = "";
    this.ariaCurrent = "";
    this.ariaDescription = "";
    this.ariaDisabled = "";
    this.ariaExpanded = "";
    this.ariaHasPopup = "";
    this.ariaHidden = "";
    this.ariaInvalid = "";
    this.ariaKeyShortcuts = "";
    this.ariaLabel = "";
    this.ariaLevel = "";
    this.ariaLive = "";
    this.ariaModal = "";
    this.ariaMultiLine = "";
    this.ariaMultiSelectable = "";
    this.ariaOrientation = "";
    this.ariaPlaceholder = "";
    this.ariaPosInSet = "";
    this.ariaPressed = "";
    this.ariaReadOnly = "";
    this.ariaRequired = "";
    this.ariaRoleDescription = "";
    this.ariaRowCount = "";
    this.ariaRowIndex = "";
    this.ariaRowSpan = "";
    this.ariaSelected = "";
    this.ariaSetSize = "";
    this.ariaSort = "";
    this.ariaValueMax = "";
    this.ariaValueMin = "";
    this.ariaValueNow = "";
    this.ariaValueText = "";
    this.role = "";
    this.form = null;
    this.labels = [];
    this.states = /* @__PURE__ */ new Set();
    this.validationMessage = "";
    this.validity = {};
    this.willValidate = true;
    this.__host = _host;
  }
  checkValidity() {
    console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true.");
    return true;
  }
  reportValidity() {
    return true;
  }
  setFormValue() {
  }
  setValidity() {
  }
};

// ../../../node_modules/.pnpm/@lit-labs+ssr-dom-shim@1.2.1/node_modules/@lit-labs/ssr-dom-shim/index.js
var attributes = /* @__PURE__ */ new WeakMap();
var attributesForElement = (element) => {
  let attrs = attributes.get(element);
  if (attrs === void 0) {
    attributes.set(element, attrs = /* @__PURE__ */ new Map());
  }
  return attrs;
};
var ElementShim = class Element2 {
  constructor() {
    this.__shadowRootMode = null;
    this.__shadowRoot = null;
    this.__internals = null;
  }
  get attributes() {
    return Array.from(attributesForElement(this)).map(([name, value]) => ({
      name,
      value
    }));
  }
  get shadowRoot() {
    if (this.__shadowRootMode === "closed") {
      return null;
    }
    return this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    return this.localName?.toUpperCase();
  }
  setAttribute(name, value) {
    attributesForElement(this).set(name, String(value));
  }
  removeAttribute(name) {
    attributesForElement(this).delete(name);
  }
  toggleAttribute(name, force) {
    if (this.hasAttribute(name)) {
      if (force === void 0 || !force) {
        this.removeAttribute(name);
        return false;
      }
    } else {
      if (force === void 0 || force) {
        this.setAttribute(name, "");
        return true;
      } else {
        return false;
      }
    }
    return true;
  }
  hasAttribute(name) {
    return attributesForElement(this).has(name);
  }
  attachShadow(init) {
    const shadowRoot = { host: this };
    this.__shadowRootMode = init.mode;
    if (init && init.mode === "open") {
      this.__shadowRoot = shadowRoot;
    }
    return shadowRoot;
  }
  attachInternals() {
    if (this.__internals !== null) {
      throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);
    }
    const internals = new ElementInternalsShim(this);
    this.__internals = internals;
    return internals;
  }
  getAttribute(name) {
    const value = attributesForElement(this).get(name);
    return value ?? null;
  }
};
var HTMLElementShim = class HTMLElement2 extends ElementShim {
};
var HTMLElementShimWithRealType = HTMLElementShim;
var CustomElementRegistryShim = class CustomElementRegistry {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map();
  }
  define(name, ctor) {
    if (this.__definitions.has(name)) {
      if (process.env.NODE_ENV === "development") {
        console.warn(`'CustomElementRegistry' already has "${name}" defined. This may have been caused by live reload or hot module replacement in which case it can be safely ignored.
Make sure to test your application with a production build as repeat registrations will throw in production.`);
      } else {
        throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${name}" has already been used with this registry`);
      }
    }
    ctor.__localName = name;
    this.__definitions.set(name, {
      ctor,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: ctor.observedAttributes ?? []
    });
  }
  get(name) {
    const definition = this.__definitions.get(name);
    return definition?.ctor;
  }
};
var CustomElementRegistryShimWithRealType = CustomElementRegistryShim;
var customElements2 = new CustomElementRegistryShimWithRealType();

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/css-tag.js
var t = globalThis;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t5, e6, o5) {
    if (this._$cssResult$ = true, o5 !== s)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t5, this.t = e6;
  }
  get styleSheet() {
    let t5 = this.o;
    const s3 = this.t;
    if (e && void 0 === t5) {
      const e6 = void 0 !== s3 && 1 === s3.length;
      e6 && (t5 = o.get(s3)), void 0 === t5 && ((this.o = t5 = new CSSStyleSheet()).replaceSync(this.cssText), e6 && o.set(s3, t5));
    }
    return t5;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t5) => new n("string" == typeof t5 ? t5 : t5 + "", void 0, s);
var i = (t5, ...e6) => {
  const o5 = 1 === t5.length ? t5[0] : e6.reduce((e7, s3, o6) => e7 + ((t6) => {
    if (true === t6._$cssResult$)
      return t6.cssText;
    if ("number" == typeof t6)
      return t6;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t6 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s3) + t5[o6 + 1], t5[0]);
  return new n(o5, t5, s);
};
var S = (s3, o5) => {
  if (e)
    s3.adoptedStyleSheets = o5.map((t5) => t5 instanceof CSSStyleSheet ? t5 : t5.styleSheet);
  else
    for (const e6 of o5) {
      const o6 = document.createElement("style"), n6 = t.litNonce;
      void 0 !== n6 && o6.setAttribute("nonce", n6), o6.textContent = e6.cssText, s3.appendChild(o6);
    }
};
var c = e || void 0 === t.CSSStyleSheet ? (t5) => t5 : (t5) => t5 instanceof CSSStyleSheet ? ((t6) => {
  let e6 = "";
  for (const s3 of t6.cssRules)
    e6 += s3.cssText;
  return r(e6);
})(t5) : t5;

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/reactive-element.js
var { is: r2, defineProperty: h, getOwnPropertyDescriptor: o2, getOwnPropertyNames: n2, getOwnPropertySymbols: a, getPrototypeOf: c2 } = Object;
var l = globalThis;
l.customElements ??= customElements2;
var p = l.trustedTypes;
var d = p ? p.emptyScript : "";
var u = l.reactiveElementPolyfillSupport;
var f = (t5, s3) => t5;
var b = { toAttribute(t5, s3) {
  switch (s3) {
    case Boolean:
      t5 = t5 ? d : null;
      break;
    case Object:
    case Array:
      t5 = null == t5 ? t5 : JSON.stringify(t5);
  }
  return t5;
}, fromAttribute(t5, s3) {
  let i4 = t5;
  switch (s3) {
    case Boolean:
      i4 = null !== t5;
      break;
    case Number:
      i4 = null === t5 ? null : Number(t5);
      break;
    case Object:
    case Array:
      try {
        i4 = JSON.parse(t5);
      } catch (t6) {
        i4 = null;
      }
  }
  return i4;
} };
var y = (t5, s3) => !r2(t5, s3);
var m = { attribute: true, type: String, converter: b, reflect: false, hasChanged: y };
Symbol.metadata ??= Symbol("metadata"), l.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var g = class extends (globalThis.HTMLElement ?? HTMLElementShimWithRealType) {
  static addInitializer(t5) {
    this._$Ei(), (this.l ??= []).push(t5);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t5, s3 = m) {
    if (s3.state && (s3.attribute = false), this._$Ei(), this.elementProperties.set(t5, s3), !s3.noAccessor) {
      const i4 = Symbol(), e6 = this.getPropertyDescriptor(t5, i4, s3);
      void 0 !== e6 && h(this.prototype, t5, e6);
    }
  }
  static getPropertyDescriptor(t5, s3, i4) {
    const { get: e6, set: r6 } = o2(this.prototype, t5) ?? { get() {
      return this[s3];
    }, set(t6) {
      this[s3] = t6;
    } };
    return { get() {
      return e6?.call(this);
    }, set(s4) {
      const h7 = e6?.call(this);
      r6.call(this, s4), this.requestUpdate(t5, h7, i4);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t5) {
    return this.elementProperties.get(t5) ?? m;
  }
  static _$Ei() {
    if (this.hasOwnProperty(f("elementProperties")))
      return;
    const t5 = c2(this);
    t5.finalize(), void 0 !== t5.l && (this.l = [...t5.l]), this.elementProperties = new Map(t5.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(f("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(f("properties"))) {
      const t6 = this.properties, s3 = [...n2(t6), ...a(t6)];
      for (const i4 of s3)
        this.createProperty(i4, t6[i4]);
    }
    const t5 = this[Symbol.metadata];
    if (null !== t5) {
      const s3 = litPropertyMetadata.get(t5);
      if (void 0 !== s3)
        for (const [t6, i4] of s3)
          this.elementProperties.set(t6, i4);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t6, s3] of this.elementProperties) {
      const i4 = this._$Eu(t6, s3);
      void 0 !== i4 && this._$Eh.set(i4, t6);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t5) {
    const s3 = [];
    if (Array.isArray(t5)) {
      const e6 = new Set(t5.flat(1 / 0).reverse());
      for (const t6 of e6)
        s3.unshift(c(t6));
    } else
      void 0 !== t5 && s3.push(c(t5));
    return s3;
  }
  static _$Eu(t5, s3) {
    const i4 = s3.attribute;
    return false === i4 ? void 0 : "string" == typeof i4 ? i4 : "string" == typeof t5 ? t5.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t5) => this.enableUpdating = t5), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t5) => t5(this));
  }
  addController(t5) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t5), void 0 !== this.renderRoot && this.isConnected && t5.hostConnected?.();
  }
  removeController(t5) {
    this._$EO?.delete(t5);
  }
  _$E_() {
    const t5 = /* @__PURE__ */ new Map(), s3 = this.constructor.elementProperties;
    for (const i4 of s3.keys())
      this.hasOwnProperty(i4) && (t5.set(i4, this[i4]), delete this[i4]);
    t5.size > 0 && (this._$Ep = t5);
  }
  createRenderRoot() {
    const t5 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t5, this.constructor.elementStyles), t5;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t5) => t5.hostConnected?.());
  }
  enableUpdating(t5) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t5) => t5.hostDisconnected?.());
  }
  attributeChangedCallback(t5, s3, i4) {
    this._$AK(t5, i4);
  }
  _$EC(t5, s3) {
    const i4 = this.constructor.elementProperties.get(t5), e6 = this.constructor._$Eu(t5, i4);
    if (void 0 !== e6 && true === i4.reflect) {
      const r6 = (void 0 !== i4.converter?.toAttribute ? i4.converter : b).toAttribute(s3, i4.type);
      this._$Em = t5, null == r6 ? this.removeAttribute(e6) : this.setAttribute(e6, r6), this._$Em = null;
    }
  }
  _$AK(t5, s3) {
    const i4 = this.constructor, e6 = i4._$Eh.get(t5);
    if (void 0 !== e6 && this._$Em !== e6) {
      const t6 = i4.getPropertyOptions(e6), r6 = "function" == typeof t6.converter ? { fromAttribute: t6.converter } : void 0 !== t6.converter?.fromAttribute ? t6.converter : b;
      this._$Em = e6, this[e6] = r6.fromAttribute(s3, t6.type), this._$Em = null;
    }
  }
  requestUpdate(t5, s3, i4) {
    if (void 0 !== t5) {
      if (i4 ??= this.constructor.getPropertyOptions(t5), !(i4.hasChanged ?? y)(this[t5], s3))
        return;
      this.P(t5, s3, i4);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t5, s3, i4) {
    this._$AL.has(t5) || this._$AL.set(t5, s3), true === i4.reflect && this._$Em !== t5 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t5);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t6) {
      Promise.reject(t6);
    }
    const t5 = this.scheduleUpdate();
    return null != t5 && await t5, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t7, s4] of this._$Ep)
          this[t7] = s4;
        this._$Ep = void 0;
      }
      const t6 = this.constructor.elementProperties;
      if (t6.size > 0)
        for (const [s4, i4] of t6)
          true !== i4.wrapped || this._$AL.has(s4) || void 0 === this[s4] || this.P(s4, this[s4], i4);
    }
    let t5 = false;
    const s3 = this._$AL;
    try {
      t5 = this.shouldUpdate(s3), t5 ? (this.willUpdate(s3), this._$EO?.forEach((t6) => t6.hostUpdate?.()), this.update(s3)) : this._$EU();
    } catch (s4) {
      throw t5 = false, this._$EU(), s4;
    }
    t5 && this._$AE(s3);
  }
  willUpdate(t5) {
  }
  _$AE(t5) {
    this._$EO?.forEach((t6) => t6.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t5)), this.updated(t5);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t5) {
    return true;
  }
  update(t5) {
    this._$Ej &&= this._$Ej.forEach((t6) => this._$EC(t6, this[t6])), this._$EU();
  }
  updated(t5) {
  }
  firstUpdated(t5) {
  }
};
g.elementStyles = [], g.shadowRootOptions = { mode: "open" }, g[f("elementProperties")] = /* @__PURE__ */ new Map(), g[f("finalized")] = /* @__PURE__ */ new Map(), u?.({ ReactiveElement: g }), (l.reactiveElementVersions ??= []).push("2.0.4");

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/lit-html.js
var n3 = globalThis;
var c3 = n3.trustedTypes;
var h2 = c3 ? c3.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
var f2 = "$lit$";
var v2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m2 = "?" + v2;
var _ = `<${m2}>`;
var w = void 0 === n3.document ? { createTreeWalker: () => ({}) } : document;
var lt = () => w.createComment("");
var st = (t5) => null === t5 || "object" != typeof t5 && "function" != typeof t5;
var g2 = Array.isArray;
var $ = (t5) => g2(t5) || "function" == typeof t5?.[Symbol.iterator];
var x = "[ 	\n\f\r]";
var T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E = /-->/g;
var k = />/g;
var O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S2 = /'/g;
var j = /"/g;
var M = /^(?:script|style|textarea|title)$/i;
var P = (t5) => (i4, ...s3) => ({ _$litType$: t5, strings: i4, values: s3 });
var ke = P(1);
var Oe = P(2);
var Se = P(3);
var R = Symbol.for("lit-noChange");
var D = Symbol.for("lit-nothing");
var V = /* @__PURE__ */ new WeakMap();
var I = w.createTreeWalker(w, 129);
function N(t5, i4) {
  if (!g2(t5) || !t5.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== h2 ? h2.createHTML(i4) : i4;
}
var U = (t5, i4) => {
  const s3 = t5.length - 1, e6 = [];
  let h7, o5 = 2 === i4 ? "<svg>" : 3 === i4 ? "<math>" : "", n6 = T;
  for (let i5 = 0; i5 < s3; i5++) {
    const s4 = t5[i5];
    let r6, l3, c5 = -1, a3 = 0;
    for (; a3 < s4.length && (n6.lastIndex = a3, l3 = n6.exec(s4), null !== l3); )
      a3 = n6.lastIndex, n6 === T ? "!--" === l3[1] ? n6 = E : void 0 !== l3[1] ? n6 = k : void 0 !== l3[2] ? (M.test(l3[2]) && (h7 = RegExp("</" + l3[2], "g")), n6 = O) : void 0 !== l3[3] && (n6 = O) : n6 === O ? ">" === l3[0] ? (n6 = h7 ?? T, c5 = -1) : void 0 === l3[1] ? c5 = -2 : (c5 = n6.lastIndex - l3[2].length, r6 = l3[1], n6 = void 0 === l3[3] ? O : '"' === l3[3] ? j : S2) : n6 === j || n6 === S2 ? n6 = O : n6 === E || n6 === k ? n6 = T : (n6 = O, h7 = void 0);
    const u3 = n6 === O && t5[i5 + 1].startsWith("/>") ? " " : "";
    o5 += n6 === T ? s4 + _ : c5 >= 0 ? (e6.push(r6), s4.slice(0, c5) + f2 + s4.slice(c5) + v2 + u3) : s4 + v2 + (-2 === c5 ? i5 : u3);
  }
  return [N(t5, o5 + (t5[s3] || "<?>") + (2 === i4 ? "</svg>" : 3 === i4 ? "</math>" : "")), e6];
};
var B = class _B {
  constructor({ strings: t5, _$litType$: i4 }, s3) {
    let e6;
    this.parts = [];
    let h7 = 0, o5 = 0;
    const n6 = t5.length - 1, r6 = this.parts, [l3, a3] = U(t5, i4);
    if (this.el = _B.createElement(l3, s3), I.currentNode = this.el.content, 2 === i4 || 3 === i4) {
      const t6 = this.el.content.firstChild;
      t6.replaceWith(...t6.childNodes);
    }
    for (; null !== (e6 = I.nextNode()) && r6.length < n6; ) {
      if (1 === e6.nodeType) {
        if (e6.hasAttributes())
          for (const t6 of e6.getAttributeNames())
            if (t6.endsWith(f2)) {
              const i5 = a3[o5++], s4 = e6.getAttribute(t6).split(v2), n7 = /([.?@])?(.*)/.exec(i5);
              r6.push({ type: 1, index: h7, name: n7[2], strings: s4, ctor: "." === n7[1] ? Y : "?" === n7[1] ? Z : "@" === n7[1] ? q : G }), e6.removeAttribute(t6);
            } else
              t6.startsWith(v2) && (r6.push({ type: 6, index: h7 }), e6.removeAttribute(t6));
        if (M.test(e6.tagName)) {
          const t6 = e6.textContent.split(v2), i5 = t6.length - 1;
          if (i5 > 0) {
            e6.textContent = c3 ? c3.emptyScript : "";
            for (let s4 = 0; s4 < i5; s4++)
              e6.append(t6[s4], lt()), I.nextNode(), r6.push({ type: 2, index: ++h7 });
            e6.append(t6[i5], lt());
          }
        }
      } else if (8 === e6.nodeType)
        if (e6.data === m2)
          r6.push({ type: 2, index: h7 });
        else {
          let t6 = -1;
          for (; -1 !== (t6 = e6.data.indexOf(v2, t6 + 1)); )
            r6.push({ type: 7, index: h7 }), t6 += v2.length - 1;
        }
      h7++;
    }
  }
  static createElement(t5, i4) {
    const s3 = w.createElement("template");
    return s3.innerHTML = t5, s3;
  }
};
function z(t5, i4, s3 = t5, e6) {
  if (i4 === R)
    return i4;
  let h7 = void 0 !== e6 ? s3.o?.[e6] : s3.l;
  const o5 = st(i4) ? void 0 : i4._$litDirective$;
  return h7?.constructor !== o5 && (h7?._$AO?.(false), void 0 === o5 ? h7 = void 0 : (h7 = new o5(t5), h7._$AT(t5, s3, e6)), void 0 !== e6 ? (s3.o ??= [])[e6] = h7 : s3.l = h7), void 0 !== h7 && (i4 = z(t5, h7._$AS(t5, i4.values), h7, e6)), i4;
}
var F = class {
  constructor(t5, i4) {
    this._$AV = [], this._$AN = void 0, this._$AD = t5, this._$AM = i4;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t5) {
    const { el: { content: i4 }, parts: s3 } = this._$AD, e6 = (t5?.creationScope ?? w).importNode(i4, true);
    I.currentNode = e6;
    let h7 = I.nextNode(), o5 = 0, n6 = 0, r6 = s3[0];
    for (; void 0 !== r6; ) {
      if (o5 === r6.index) {
        let i5;
        2 === r6.type ? i5 = new et(h7, h7.nextSibling, this, t5) : 1 === r6.type ? i5 = new r6.ctor(h7, r6.name, r6.strings, this, t5) : 6 === r6.type && (i5 = new K(h7, this, t5)), this._$AV.push(i5), r6 = s3[++n6];
      }
      o5 !== r6?.index && (h7 = I.nextNode(), o5++);
    }
    return I.currentNode = w, e6;
  }
  p(t5) {
    let i4 = 0;
    for (const s3 of this._$AV)
      void 0 !== s3 && (void 0 !== s3.strings ? (s3._$AI(t5, s3, i4), i4 += s3.strings.length - 2) : s3._$AI(t5[i4])), i4++;
  }
};
var et = class _et {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t5, i4, s3, e6) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t5, this._$AB = i4, this._$AM = s3, this.options = e6, this.v = e6?.isConnected ?? true;
  }
  get parentNode() {
    let t5 = this._$AA.parentNode;
    const i4 = this._$AM;
    return void 0 !== i4 && 11 === t5?.nodeType && (t5 = i4.parentNode), t5;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t5, i4 = this) {
    t5 = z(this, t5, i4), st(t5) ? t5 === D || null == t5 || "" === t5 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t5 !== this._$AH && t5 !== R && this._(t5) : void 0 !== t5._$litType$ ? this.$(t5) : void 0 !== t5.nodeType ? this.T(t5) : $(t5) ? this.k(t5) : this._(t5);
  }
  O(t5) {
    return this._$AA.parentNode.insertBefore(t5, this._$AB);
  }
  T(t5) {
    this._$AH !== t5 && (this._$AR(), this._$AH = this.O(t5));
  }
  _(t5) {
    this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = t5 : this.T(w.createTextNode(t5)), this._$AH = t5;
  }
  $(t5) {
    const { values: i4, _$litType$: s3 } = t5, e6 = "number" == typeof s3 ? this._$AC(t5) : (void 0 === s3.el && (s3.el = B.createElement(N(s3.h, s3.h[0]), this.options)), s3);
    if (this._$AH?._$AD === e6)
      this._$AH.p(i4);
    else {
      const t6 = new F(e6, this), s4 = t6.u(this.options);
      t6.p(i4), this.T(s4), this._$AH = t6;
    }
  }
  _$AC(t5) {
    let i4 = V.get(t5.strings);
    return void 0 === i4 && V.set(t5.strings, i4 = new B(t5)), i4;
  }
  k(t5) {
    g2(this._$AH) || (this._$AH = [], this._$AR());
    const i4 = this._$AH;
    let s3, e6 = 0;
    for (const h7 of t5)
      e6 === i4.length ? i4.push(s3 = new _et(this.O(lt()), this.O(lt()), this, this.options)) : s3 = i4[e6], s3._$AI(h7), e6++;
    e6 < i4.length && (this._$AR(s3 && s3._$AB.nextSibling, e6), i4.length = e6);
  }
  _$AR(t5 = this._$AA.nextSibling, i4) {
    for (this._$AP?.(false, true, i4); t5 && t5 !== this._$AB; ) {
      const i5 = t5.nextSibling;
      t5.remove(), t5 = i5;
    }
  }
  setConnected(t5) {
    void 0 === this._$AM && (this.v = t5, this._$AP?.(t5));
  }
};
var G = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t5, i4, s3, e6, h7) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t5, this.name = i4, this._$AM = e6, this.options = h7, s3.length > 2 || "" !== s3[0] || "" !== s3[1] ? (this._$AH = Array(s3.length - 1).fill(new String()), this.strings = s3) : this._$AH = D;
  }
  _$AI(t5, i4 = this, s3, e6) {
    const h7 = this.strings;
    let o5 = false;
    if (void 0 === h7)
      t5 = z(this, t5, i4, 0), o5 = !st(t5) || t5 !== this._$AH && t5 !== R, o5 && (this._$AH = t5);
    else {
      const e7 = t5;
      let n6, r6;
      for (t5 = h7[0], n6 = 0; n6 < h7.length - 1; n6++)
        r6 = z(this, e7[s3 + n6], i4, n6), r6 === R && (r6 = this._$AH[n6]), o5 ||= !st(r6) || r6 !== this._$AH[n6], r6 === D ? t5 = D : t5 !== D && (t5 += (r6 ?? "") + h7[n6 + 1]), this._$AH[n6] = r6;
    }
    o5 && !e6 && this.j(t5);
  }
  j(t5) {
    t5 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t5 ?? "");
  }
};
var Y = class extends G {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t5) {
    this.element[this.name] = t5 === D ? void 0 : t5;
  }
};
var Z = class extends G {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t5) {
    this.element.toggleAttribute(this.name, !!t5 && t5 !== D);
  }
};
var q = class extends G {
  constructor(t5, i4, s3, e6, h7) {
    super(t5, i4, s3, e6, h7), this.type = 5;
  }
  _$AI(t5, i4 = this) {
    if ((t5 = z(this, t5, i4, 0) ?? D) === R)
      return;
    const s3 = this._$AH, e6 = t5 === D && s3 !== D || t5.capture !== s3.capture || t5.once !== s3.once || t5.passive !== s3.passive, h7 = t5 !== D && (s3 === D || e6);
    e6 && this.element.removeEventListener(this.name, this, s3), h7 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
  }
  handleEvent(t5) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t5) : this._$AH.handleEvent(t5);
  }
};
var K = class {
  constructor(t5, i4, s3) {
    this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s3;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t5) {
    z(this, t5);
  }
};
var si = { M: f2, P: v2, A: m2, C: 1, L: U, R: F, D: $, V: z, I: et, H: G, N: Z, U: q, B: Y, F: K };
var Re = n3.litHtmlPolyfillSupport;
Re?.(B, et), (n3.litHtmlVersions ??= []).push("3.2.0");
var Q = (t5, i4, s3) => {
  const e6 = s3?.renderBefore ?? i4;
  let h7 = e6._$litPart$;
  if (void 0 === h7) {
    const t6 = s3?.renderBefore ?? null;
    e6._$litPart$ = h7 = new et(i4.insertBefore(lt(), t6), t6, void 0, s3 ?? {});
  }
  return h7._$AI(t5), h7;
};

// ../../../node_modules/.pnpm/lit-element@4.1.0/node_modules/lit-element/lit-element.js
var h3 = class extends g {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t5 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t5.firstChild, t5;
  }
  update(t5) {
    const e6 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t5), this.o = Q(e6, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R;
  }
};
h3._$litElement$ = true, h3["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h3 });
var f3 = globalThis.litElementPolyfillSupport;
f3?.({ LitElement: h3 });
(globalThis.litElementVersions ??= []).push("4.1.0");

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/custom-element.js
var t2 = (t5) => (e6, o5) => {
  void 0 !== o5 ? o5.addInitializer(() => {
    customElements.define(t5, e6);
  }) : customElements.define(t5, e6);
};

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/property.js
var o3 = { attribute: true, type: String, converter: b, reflect: false, hasChanged: y };
var r3 = (t5 = o3, e6, r6) => {
  const { kind: n6, metadata: i4 } = r6;
  let s3 = globalThis.litPropertyMetadata.get(i4);
  if (void 0 === s3 && globalThis.litPropertyMetadata.set(i4, s3 = /* @__PURE__ */ new Map()), s3.set(r6.name, t5), "accessor" === n6) {
    const { name: o5 } = r6;
    return { set(r7) {
      const n7 = e6.get.call(this);
      e6.set.call(this, r7), this.requestUpdate(o5, n7, t5);
    }, init(e7) {
      return void 0 !== e7 && this.P(o5, void 0, t5), e7;
    } };
  }
  if ("setter" === n6) {
    const { name: o5 } = r6;
    return function(r7) {
      const n7 = this[o5];
      e6.call(this, r7), this.requestUpdate(o5, n7, t5);
    };
  }
  throw Error("Unsupported decorator location: " + n6);
};
function n4(t5) {
  return (e6, o5) => "object" == typeof o5 ? r3(t5, e6, o5) : ((t6, e7, o6) => {
    const r6 = e7.hasOwnProperty(o6);
    return e7.constructor.createProperty(o6, r6 ? { ...t6, wrapped: true } : t6), r6 ? Object.getOwnPropertyDescriptor(e7, o6) : void 0;
  })(t5, e6, o5);
}

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/state.js
function r4(r6) {
  return n4({ ...r6, state: true, attribute: false });
}

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/base.js
var e2 = (e6, t5, c5) => (c5.configurable = true, c5.enumerable = true, Reflect.decorate && "object" != typeof t5 && Object.defineProperty(e6, t5, c5), c5);

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/node/decorators/query.js
function e3(e6, r6) {
  return (n6, s3, i4) => {
    const o5 = (t5) => t5.renderRoot?.querySelector(e6) ?? null;
    if (r6) {
      const { get: e7, set: r7 } = "object" == typeof s3 ? n6 : i4 ?? (() => {
        const t5 = Symbol();
        return { get() {
          return this[t5];
        }, set(e8) {
          this[t5] = e8;
        } };
      })();
      return e2(n6, s3, { get() {
        let t5 = e7.call(this);
        return void 0 === t5 && (t5 = o5(this), (null !== t5 || this.hasUpdated) && r7.call(this, t5)), t5;
      } });
    }
    return e2(n6, s3, { get() {
      return o5(this);
    } });
  };
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/limit.js
var limit_default = (x6, low = 0, high = 1) => {
  return min(max(low, x6), high);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/clip_rgb.js
var clip_rgb_default = (rgb2) => {
  rgb2._clipped = false;
  rgb2._unclipped = rgb2.slice(0);
  for (let i4 = 0; i4 <= 3; i4++) {
    if (i4 < 3) {
      if (rgb2[i4] < 0 || rgb2[i4] > 255)
        rgb2._clipped = true;
      rgb2[i4] = limit_default(rgb2[i4], 0, 255);
    } else if (i4 === 3) {
      rgb2[i4] = limit_default(rgb2[i4], 0, 1);
    }
  }
  return rgb2;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/type.js
var classToType = {};
for (let name of [
  "Boolean",
  "Number",
  "String",
  "Function",
  "Array",
  "Date",
  "RegExp",
  "Undefined",
  "Null"
]) {
  classToType[`[object ${name}]`] = name.toLowerCase();
}
function type_default(obj) {
  return classToType[Object.prototype.toString.call(obj)] || "object";
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/unpack.js
var unpack_default = (args, keyOrder = null) => {
  if (args.length >= 3)
    return Array.prototype.slice.call(args);
  if (type_default(args[0]) == "object" && keyOrder) {
    return keyOrder.split("").filter((k6) => args[0][k6] !== void 0).map((k6) => args[0][k6]);
  }
  return args[0];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/last.js
var last_default = (args) => {
  if (args.length < 2)
    return null;
  const l3 = args.length - 1;
  if (type_default(args[l3]) == "string")
    return args[l3].toLowerCase();
  return null;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/index.js
var { PI, min, max } = Math;
var TWOPI = PI * 2;
var PITHIRD = PI / 3;
var DEG2RAD = PI / 180;
var RAD2DEG = 180 / PI;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/input.js
var input_default = {
  format: {},
  autodetect: []
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/Color.js
var Color = class {
  constructor(...args) {
    const me2 = this;
    if (type_default(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
      return args[0];
    }
    let mode = last_default(args);
    let autodetect = false;
    if (!mode) {
      autodetect = true;
      if (!input_default.sorted) {
        input_default.autodetect = input_default.autodetect.sort((a3, b5) => b5.p - a3.p);
        input_default.sorted = true;
      }
      for (let chk of input_default.autodetect) {
        mode = chk.test(...args);
        if (mode)
          break;
      }
    }
    if (input_default.format[mode]) {
      const rgb2 = input_default.format[mode].apply(
        null,
        autodetect ? args : args.slice(0, -1)
      );
      me2._rgb = clip_rgb_default(rgb2);
    } else {
      throw new Error("unknown format: " + args);
    }
    if (me2._rgb.length === 3)
      me2._rgb.push(1);
  }
  toString() {
    if (type_default(this.hex) == "function")
      return this.hex();
    return `[${this._rgb.join(",")}]`;
  }
};
var Color_default = Color;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/version.js
var version = "2.6.0";

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/chroma.js
var chroma = (...args) => {
  return new chroma.Color(...args);
};
chroma.Color = Color_default;
chroma.version = version;
var chroma_default = chroma;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/cmyk2rgb.js
var cmyk2rgb = (...args) => {
  args = unpack_default(args, "cmyk");
  const [c5, m7, y7, k6] = args;
  const alpha = args.length > 4 ? args[4] : 1;
  if (k6 === 1)
    return [0, 0, 0, alpha];
  return [
    c5 >= 1 ? 0 : 255 * (1 - c5) * (1 - k6),
    // r
    m7 >= 1 ? 0 : 255 * (1 - m7) * (1 - k6),
    // g
    y7 >= 1 ? 0 : 255 * (1 - y7) * (1 - k6),
    // b
    alpha
  ];
};
var cmyk2rgb_default = cmyk2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/rgb2cmyk.js
var { max: max2 } = Math;
var rgb2cmyk = (...args) => {
  let [r6, g6, b5] = unpack_default(args, "rgb");
  r6 = r6 / 255;
  g6 = g6 / 255;
  b5 = b5 / 255;
  const k6 = 1 - max2(r6, max2(g6, b5));
  const f5 = k6 < 1 ? 1 / (1 - k6) : 0;
  const c5 = (1 - r6 - k6) * f5;
  const m7 = (1 - g6 - k6) * f5;
  const y7 = (1 - b5 - k6) * f5;
  return [c5, m7, y7, k6];
};
var rgb2cmyk_default = rgb2cmyk;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/index.js
Color_default.prototype.cmyk = function() {
  return rgb2cmyk_default(this._rgb);
};
chroma_default.cmyk = (...args) => new Color_default(...args, "cmyk");
input_default.format.cmyk = cmyk2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "cmyk");
    if (type_default(args) === "array" && args.length === 4) {
      return "cmyk";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/hsl2css.js
var rnd = (a3) => Math.round(a3 * 100) / 100;
var hsl2css = (...args) => {
  const hsla = unpack_default(args, "hsla");
  let mode = last_default(args) || "lsa";
  hsla[0] = rnd(hsla[0] || 0);
  hsla[1] = rnd(hsla[1] * 100) + "%";
  hsla[2] = rnd(hsla[2] * 100) + "%";
  if (mode === "hsla" || hsla.length > 3 && hsla[3] < 1) {
    hsla[3] = hsla.length > 3 ? hsla[3] : 1;
    mode = "hsla";
  } else {
    hsla.length = 3;
  }
  return `${mode}(${hsla.join(",")})`;
};
var hsl2css_default = hsl2css;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/rgb2hsl.js
var rgb2hsl = (...args) => {
  args = unpack_default(args, "rgba");
  let [r6, g6, b5] = args;
  r6 /= 255;
  g6 /= 255;
  b5 /= 255;
  const minRgb = min(r6, g6, b5);
  const maxRgb = max(r6, g6, b5);
  const l3 = (maxRgb + minRgb) / 2;
  let s3, h7;
  if (maxRgb === minRgb) {
    s3 = 0;
    h7 = Number.NaN;
  } else {
    s3 = l3 < 0.5 ? (maxRgb - minRgb) / (maxRgb + minRgb) : (maxRgb - minRgb) / (2 - maxRgb - minRgb);
  }
  if (r6 == maxRgb)
    h7 = (g6 - b5) / (maxRgb - minRgb);
  else if (g6 == maxRgb)
    h7 = 2 + (b5 - r6) / (maxRgb - minRgb);
  else if (b5 == maxRgb)
    h7 = 4 + (r6 - g6) / (maxRgb - minRgb);
  h7 *= 60;
  if (h7 < 0)
    h7 += 360;
  if (args.length > 3 && args[3] !== void 0)
    return [h7, s3, l3, args[3]];
  return [h7, s3, l3];
};
var rgb2hsl_default = rgb2hsl;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/rgb2css.js
var { round } = Math;
var rgb2css = (...args) => {
  const rgba = unpack_default(args, "rgba");
  let mode = last_default(args) || "rgb";
  if (mode.substr(0, 3) == "hsl") {
    return hsl2css_default(rgb2hsl_default(rgba), mode);
  }
  rgba[0] = round(rgba[0]);
  rgba[1] = round(rgba[1]);
  rgba[2] = round(rgba[2]);
  if (mode === "rgba" || rgba.length > 3 && rgba[3] < 1) {
    rgba[3] = rgba.length > 3 ? rgba[3] : 1;
    mode = "rgba";
  }
  return `${mode}(${rgba.slice(0, mode === "rgb" ? 3 : 4).join(",")})`;
};
var rgb2css_default = rgb2css;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/hsl2rgb.js
var { round: round2 } = Math;
var hsl2rgb = (...args) => {
  args = unpack_default(args, "hsl");
  const [h7, s3, l3] = args;
  let r6, g6, b5;
  if (s3 === 0) {
    r6 = g6 = b5 = l3 * 255;
  } else {
    const t32 = [0, 0, 0];
    const c5 = [0, 0, 0];
    const t22 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
    const t1 = 2 * l3 - t22;
    const h_ = h7 / 360;
    t32[0] = h_ + 1 / 3;
    t32[1] = h_;
    t32[2] = h_ - 1 / 3;
    for (let i4 = 0; i4 < 3; i4++) {
      if (t32[i4] < 0)
        t32[i4] += 1;
      if (t32[i4] > 1)
        t32[i4] -= 1;
      if (6 * t32[i4] < 1)
        c5[i4] = t1 + (t22 - t1) * 6 * t32[i4];
      else if (2 * t32[i4] < 1)
        c5[i4] = t22;
      else if (3 * t32[i4] < 2)
        c5[i4] = t1 + (t22 - t1) * (2 / 3 - t32[i4]) * 6;
      else
        c5[i4] = t1;
    }
    [r6, g6, b5] = [round2(c5[0] * 255), round2(c5[1] * 255), round2(c5[2] * 255)];
  }
  if (args.length > 3) {
    return [r6, g6, b5, args[3]];
  }
  return [r6, g6, b5, 1];
};
var hsl2rgb_default = hsl2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/css2rgb.js
var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
var { round: round3 } = Math;
var css2rgb = (css) => {
  css = css.toLowerCase().trim();
  let m7;
  if (input_default.format.named) {
    try {
      return input_default.format.named(css);
    } catch (e6) {
    }
  }
  if (m7 = css.match(RE_RGB)) {
    const rgb2 = m7.slice(1, 4);
    for (let i4 = 0; i4 < 3; i4++) {
      rgb2[i4] = +rgb2[i4];
    }
    rgb2[3] = 1;
    return rgb2;
  }
  if (m7 = css.match(RE_RGBA)) {
    const rgb2 = m7.slice(1, 5);
    for (let i4 = 0; i4 < 4; i4++) {
      rgb2[i4] = +rgb2[i4];
    }
    return rgb2;
  }
  if (m7 = css.match(RE_RGB_PCT)) {
    const rgb2 = m7.slice(1, 4);
    for (let i4 = 0; i4 < 3; i4++) {
      rgb2[i4] = round3(rgb2[i4] * 2.55);
    }
    rgb2[3] = 1;
    return rgb2;
  }
  if (m7 = css.match(RE_RGBA_PCT)) {
    const rgb2 = m7.slice(1, 5);
    for (let i4 = 0; i4 < 3; i4++) {
      rgb2[i4] = round3(rgb2[i4] * 2.55);
    }
    rgb2[3] = +rgb2[3];
    return rgb2;
  }
  if (m7 = css.match(RE_HSL)) {
    const hsl2 = m7.slice(1, 4);
    hsl2[1] *= 0.01;
    hsl2[2] *= 0.01;
    const rgb2 = hsl2rgb_default(hsl2);
    rgb2[3] = 1;
    return rgb2;
  }
  if (m7 = css.match(RE_HSLA)) {
    const hsl2 = m7.slice(1, 4);
    hsl2[1] *= 0.01;
    hsl2[2] *= 0.01;
    const rgb2 = hsl2rgb_default(hsl2);
    rgb2[3] = +m7[4];
    return rgb2;
  }
};
css2rgb.test = (s3) => {
  return RE_RGB.test(s3) || RE_RGBA.test(s3) || RE_RGB_PCT.test(s3) || RE_RGBA_PCT.test(s3) || RE_HSL.test(s3) || RE_HSLA.test(s3);
};
var css2rgb_default = css2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/index.js
Color_default.prototype.css = function(mode) {
  return rgb2css_default(this._rgb, mode);
};
chroma_default.css = (...args) => new Color_default(...args, "css");
input_default.format.css = css2rgb_default;
input_default.autodetect.push({
  p: 5,
  test: (h7, ...rest) => {
    if (!rest.length && type_default(h7) === "string" && css2rgb_default.test(h7)) {
      return "css";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/gl/index.js
input_default.format.gl = (...args) => {
  const rgb2 = unpack_default(args, "rgba");
  rgb2[0] *= 255;
  rgb2[1] *= 255;
  rgb2[2] *= 255;
  return rgb2;
};
chroma_default.gl = (...args) => new Color_default(...args, "gl");
Color_default.prototype.gl = function() {
  const rgb2 = this._rgb;
  return [rgb2[0] / 255, rgb2[1] / 255, rgb2[2] / 255, rgb2[3]];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/hcg2rgb.js
var { floor } = Math;
var hcg2rgb = (...args) => {
  args = unpack_default(args, "hcg");
  let [h7, c5, _g] = args;
  let r6, g6, b5;
  _g = _g * 255;
  const _c = c5 * 255;
  if (c5 === 0) {
    r6 = g6 = b5 = _g;
  } else {
    if (h7 === 360)
      h7 = 0;
    if (h7 > 360)
      h7 -= 360;
    if (h7 < 0)
      h7 += 360;
    h7 /= 60;
    const i4 = floor(h7);
    const f5 = h7 - i4;
    const p5 = _g * (1 - c5);
    const q5 = p5 + _c * (1 - f5);
    const t5 = p5 + _c * f5;
    const v8 = p5 + _c;
    switch (i4) {
      case 0:
        [r6, g6, b5] = [v8, t5, p5];
        break;
      case 1:
        [r6, g6, b5] = [q5, v8, p5];
        break;
      case 2:
        [r6, g6, b5] = [p5, v8, t5];
        break;
      case 3:
        [r6, g6, b5] = [p5, q5, v8];
        break;
      case 4:
        [r6, g6, b5] = [t5, p5, v8];
        break;
      case 5:
        [r6, g6, b5] = [v8, p5, q5];
        break;
    }
  }
  return [r6, g6, b5, args.length > 3 ? args[3] : 1];
};
var hcg2rgb_default = hcg2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/rgb2hcg.js
var rgb2hcg = (...args) => {
  const [r6, g6, b5] = unpack_default(args, "rgb");
  const minRgb = min(r6, g6, b5);
  const maxRgb = max(r6, g6, b5);
  const delta = maxRgb - minRgb;
  const c5 = delta * 100 / 255;
  const _g = minRgb / (255 - delta) * 100;
  let h7;
  if (delta === 0) {
    h7 = Number.NaN;
  } else {
    if (r6 === maxRgb)
      h7 = (g6 - b5) / delta;
    if (g6 === maxRgb)
      h7 = 2 + (b5 - r6) / delta;
    if (b5 === maxRgb)
      h7 = 4 + (r6 - g6) / delta;
    h7 *= 60;
    if (h7 < 0)
      h7 += 360;
  }
  return [h7, c5, _g];
};
var rgb2hcg_default = rgb2hcg;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/index.js
Color_default.prototype.hcg = function() {
  return rgb2hcg_default(this._rgb);
};
chroma_default.hcg = (...args) => new Color_default(...args, "hcg");
input_default.format.hcg = hcg2rgb_default;
input_default.autodetect.push({
  p: 1,
  test: (...args) => {
    args = unpack_default(args, "hcg");
    if (type_default(args) === "array" && args.length === 3) {
      return "hcg";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/hex2rgb.js
var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
var hex2rgb = (hex) => {
  if (hex.match(RE_HEX)) {
    if (hex.length === 4 || hex.length === 7) {
      hex = hex.substr(1);
    }
    if (hex.length === 3) {
      hex = hex.split("");
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    const u3 = parseInt(hex, 16);
    const r6 = u3 >> 16;
    const g6 = u3 >> 8 & 255;
    const b5 = u3 & 255;
    return [r6, g6, b5, 1];
  }
  if (hex.match(RE_HEXA)) {
    if (hex.length === 5 || hex.length === 9) {
      hex = hex.substr(1);
    }
    if (hex.length === 4) {
      hex = hex.split("");
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    const u3 = parseInt(hex, 16);
    const r6 = u3 >> 24 & 255;
    const g6 = u3 >> 16 & 255;
    const b5 = u3 >> 8 & 255;
    const a3 = Math.round((u3 & 255) / 255 * 100) / 100;
    return [r6, g6, b5, a3];
  }
  throw new Error(`unknown hex color: ${hex}`);
};
var hex2rgb_default = hex2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/rgb2hex.js
var { round: round4 } = Math;
var rgb2hex = (...args) => {
  let [r6, g6, b5, a3] = unpack_default(args, "rgba");
  let mode = last_default(args) || "auto";
  if (a3 === void 0)
    a3 = 1;
  if (mode === "auto") {
    mode = a3 < 1 ? "rgba" : "rgb";
  }
  r6 = round4(r6);
  g6 = round4(g6);
  b5 = round4(b5);
  const u3 = r6 << 16 | g6 << 8 | b5;
  let str = "000000" + u3.toString(16);
  str = str.substr(str.length - 6);
  let hxa = "0" + round4(a3 * 255).toString(16);
  hxa = hxa.substr(hxa.length - 2);
  switch (mode.toLowerCase()) {
    case "rgba":
      return `#${str}${hxa}`;
    case "argb":
      return `#${hxa}${str}`;
    default:
      return `#${str}`;
  }
};
var rgb2hex_default = rgb2hex;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/index.js
Color_default.prototype.hex = function(mode) {
  return rgb2hex_default(this._rgb, mode);
};
chroma_default.hex = (...args) => new Color_default(...args, "hex");
input_default.format.hex = hex2rgb_default;
input_default.autodetect.push({
  p: 4,
  test: (h7, ...rest) => {
    if (!rest.length && type_default(h7) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h7.length) >= 0) {
      return "hex";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/hsi2rgb.js
var { cos } = Math;
var hsi2rgb = (...args) => {
  args = unpack_default(args, "hsi");
  let [h7, s3, i4] = args;
  let r6, g6, b5;
  if (isNaN(h7))
    h7 = 0;
  if (isNaN(s3))
    s3 = 0;
  if (h7 > 360)
    h7 -= 360;
  if (h7 < 0)
    h7 += 360;
  h7 /= 360;
  if (h7 < 1 / 3) {
    b5 = (1 - s3) / 3;
    r6 = (1 + s3 * cos(TWOPI * h7) / cos(PITHIRD - TWOPI * h7)) / 3;
    g6 = 1 - (b5 + r6);
  } else if (h7 < 2 / 3) {
    h7 -= 1 / 3;
    r6 = (1 - s3) / 3;
    g6 = (1 + s3 * cos(TWOPI * h7) / cos(PITHIRD - TWOPI * h7)) / 3;
    b5 = 1 - (r6 + g6);
  } else {
    h7 -= 2 / 3;
    g6 = (1 - s3) / 3;
    b5 = (1 + s3 * cos(TWOPI * h7) / cos(PITHIRD - TWOPI * h7)) / 3;
    r6 = 1 - (g6 + b5);
  }
  r6 = limit_default(i4 * r6 * 3);
  g6 = limit_default(i4 * g6 * 3);
  b5 = limit_default(i4 * b5 * 3);
  return [r6 * 255, g6 * 255, b5 * 255, args.length > 3 ? args[3] : 1];
};
var hsi2rgb_default = hsi2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/rgb2hsi.js
var { min: min2, sqrt, acos } = Math;
var rgb2hsi = (...args) => {
  let [r6, g6, b5] = unpack_default(args, "rgb");
  r6 /= 255;
  g6 /= 255;
  b5 /= 255;
  let h7;
  const min_ = min2(r6, g6, b5);
  const i4 = (r6 + g6 + b5) / 3;
  const s3 = i4 > 0 ? 1 - min_ / i4 : 0;
  if (s3 === 0) {
    h7 = NaN;
  } else {
    h7 = (r6 - g6 + (r6 - b5)) / 2;
    h7 /= sqrt((r6 - g6) * (r6 - g6) + (r6 - b5) * (g6 - b5));
    h7 = acos(h7);
    if (b5 > g6) {
      h7 = TWOPI - h7;
    }
    h7 /= TWOPI;
  }
  return [h7 * 360, s3, i4];
};
var rgb2hsi_default = rgb2hsi;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/index.js
Color_default.prototype.hsi = function() {
  return rgb2hsi_default(this._rgb);
};
chroma_default.hsi = (...args) => new Color_default(...args, "hsi");
input_default.format.hsi = hsi2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsi");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsi";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/index.js
Color_default.prototype.hsl = function() {
  return rgb2hsl_default(this._rgb);
};
chroma_default.hsl = (...args) => new Color_default(...args, "hsl");
input_default.format.hsl = hsl2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsl");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsl";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/hsv2rgb.js
var { floor: floor2 } = Math;
var hsv2rgb = (...args) => {
  args = unpack_default(args, "hsv");
  let [h7, s3, v8] = args;
  let r6, g6, b5;
  v8 *= 255;
  if (s3 === 0) {
    r6 = g6 = b5 = v8;
  } else {
    if (h7 === 360)
      h7 = 0;
    if (h7 > 360)
      h7 -= 360;
    if (h7 < 0)
      h7 += 360;
    h7 /= 60;
    const i4 = floor2(h7);
    const f5 = h7 - i4;
    const p5 = v8 * (1 - s3);
    const q5 = v8 * (1 - s3 * f5);
    const t5 = v8 * (1 - s3 * (1 - f5));
    switch (i4) {
      case 0:
        [r6, g6, b5] = [v8, t5, p5];
        break;
      case 1:
        [r6, g6, b5] = [q5, v8, p5];
        break;
      case 2:
        [r6, g6, b5] = [p5, v8, t5];
        break;
      case 3:
        [r6, g6, b5] = [p5, q5, v8];
        break;
      case 4:
        [r6, g6, b5] = [t5, p5, v8];
        break;
      case 5:
        [r6, g6, b5] = [v8, p5, q5];
        break;
    }
  }
  return [r6, g6, b5, args.length > 3 ? args[3] : 1];
};
var hsv2rgb_default = hsv2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/rgb2hsv.js
var { min: min3, max: max3 } = Math;
var rgb2hsl2 = (...args) => {
  args = unpack_default(args, "rgb");
  let [r6, g6, b5] = args;
  const min_ = min3(r6, g6, b5);
  const max_ = max3(r6, g6, b5);
  const delta = max_ - min_;
  let h7, s3, v8;
  v8 = max_ / 255;
  if (max_ === 0) {
    h7 = Number.NaN;
    s3 = 0;
  } else {
    s3 = delta / max_;
    if (r6 === max_)
      h7 = (g6 - b5) / delta;
    if (g6 === max_)
      h7 = 2 + (b5 - r6) / delta;
    if (b5 === max_)
      h7 = 4 + (r6 - g6) / delta;
    h7 *= 60;
    if (h7 < 0)
      h7 += 360;
  }
  return [h7, s3, v8];
};
var rgb2hsv_default = rgb2hsl2;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/index.js
Color_default.prototype.hsv = function() {
  return rgb2hsv_default(this._rgb);
};
chroma_default.hsv = (...args) => new Color_default(...args, "hsv");
input_default.format.hsv = hsv2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsv");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsv";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/lab-constants.js
var lab_constants_default = {
  // Corresponds roughly to RGB brighter/darker
  Kn: 18,
  // D65 standard referent
  Xn: 0.95047,
  Yn: 1,
  Zn: 1.08883,
  t0: 0.137931034,
  // 4 / 29
  t1: 0.206896552,
  // 6 / 29
  t2: 0.12841855,
  // 3 * t1 * t1
  t3: 8856452e-9
  // t1 * t1 * t1
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/lab2rgb.js
var { pow } = Math;
var lab2rgb = (...args) => {
  args = unpack_default(args, "lab");
  const [l3, a3, b5] = args;
  let x6, y7, z5, r6, g6, b_;
  y7 = (l3 + 16) / 116;
  x6 = isNaN(a3) ? y7 : y7 + a3 / 500;
  z5 = isNaN(b5) ? y7 : y7 - b5 / 200;
  y7 = lab_constants_default.Yn * lab_xyz(y7);
  x6 = lab_constants_default.Xn * lab_xyz(x6);
  z5 = lab_constants_default.Zn * lab_xyz(z5);
  r6 = xyz_rgb(3.2404542 * x6 - 1.5371385 * y7 - 0.4985314 * z5);
  g6 = xyz_rgb(-0.969266 * x6 + 1.8760108 * y7 + 0.041556 * z5);
  b_ = xyz_rgb(0.0556434 * x6 - 0.2040259 * y7 + 1.0572252 * z5);
  return [r6, g6, b_, args.length > 3 ? args[3] : 1];
};
var xyz_rgb = (r6) => {
  return 255 * (r6 <= 304e-5 ? 12.92 * r6 : 1.055 * pow(r6, 1 / 2.4) - 0.055);
};
var lab_xyz = (t5) => {
  return t5 > lab_constants_default.t1 ? t5 * t5 * t5 : lab_constants_default.t2 * (t5 - lab_constants_default.t0);
};
var lab2rgb_default = lab2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/rgb2lab.js
var { pow: pow2 } = Math;
var rgb2lab = (...args) => {
  const [r6, g6, b5] = unpack_default(args, "rgb");
  const [x6, y7, z5] = rgb2xyz(r6, g6, b5);
  const l3 = 116 * y7 - 16;
  return [l3 < 0 ? 0 : l3, 500 * (x6 - y7), 200 * (y7 - z5)];
};
var rgb_xyz = (r6) => {
  if ((r6 /= 255) <= 0.04045)
    return r6 / 12.92;
  return pow2((r6 + 0.055) / 1.055, 2.4);
};
var xyz_lab = (t5) => {
  if (t5 > lab_constants_default.t3)
    return pow2(t5, 1 / 3);
  return t5 / lab_constants_default.t2 + lab_constants_default.t0;
};
var rgb2xyz = (r6, g6, b5) => {
  r6 = rgb_xyz(r6);
  g6 = rgb_xyz(g6);
  b5 = rgb_xyz(b5);
  const x6 = xyz_lab(
    (0.4124564 * r6 + 0.3575761 * g6 + 0.1804375 * b5) / lab_constants_default.Xn
  );
  const y7 = xyz_lab(
    (0.2126729 * r6 + 0.7151522 * g6 + 0.072175 * b5) / lab_constants_default.Yn
  );
  const z5 = xyz_lab(
    (0.0193339 * r6 + 0.119192 * g6 + 0.9503041 * b5) / lab_constants_default.Zn
  );
  return [x6, y7, z5];
};
var rgb2lab_default = rgb2lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/index.js
Color_default.prototype.lab = function() {
  return rgb2lab_default(this._rgb);
};
chroma_default.lab = (...args) => new Color_default(...args, "lab");
input_default.format.lab = lab2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "lab");
    if (type_default(args) === "array" && args.length === 3) {
      return "lab";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lch2lab.js
var { sin, cos: cos2 } = Math;
var lch2lab = (...args) => {
  let [l3, c5, h7] = unpack_default(args, "lch");
  if (isNaN(h7))
    h7 = 0;
  h7 = h7 * DEG2RAD;
  return [l3, cos2(h7) * c5, sin(h7) * c5];
};
var lch2lab_default = lch2lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lch2rgb.js
var lch2rgb = (...args) => {
  args = unpack_default(args, "lch");
  const [l3, c5, h7] = args;
  const [L5, a3, b_] = lch2lab_default(l3, c5, h7);
  const [r6, g6, b5] = lab2rgb_default(L5, a3, b_);
  return [r6, g6, b5, args.length > 3 ? args[3] : 1];
};
var lch2rgb_default = lch2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/hcl2rgb.js
var hcl2rgb = (...args) => {
  const hcl = unpack_default(args, "hcl").reverse();
  return lch2rgb_default(...hcl);
};
var hcl2rgb_default = hcl2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lab2lch.js
var { sqrt: sqrt2, atan2, round: round5 } = Math;
var lab2lch = (...args) => {
  const [l3, a3, b5] = unpack_default(args, "lab");
  const c5 = sqrt2(a3 * a3 + b5 * b5);
  let h7 = (atan2(b5, a3) * RAD2DEG + 360) % 360;
  if (round5(c5 * 1e4) === 0)
    h7 = Number.NaN;
  return [l3, c5, h7];
};
var lab2lch_default = lab2lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/rgb2lch.js
var rgb2lch = (...args) => {
  const [r6, g6, b5] = unpack_default(args, "rgb");
  const [l3, a3, b_] = rgb2lab_default(r6, g6, b5);
  return lab2lch_default(l3, a3, b_);
};
var rgb2lch_default = rgb2lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/index.js
Color_default.prototype.lch = function() {
  return rgb2lch_default(this._rgb);
};
Color_default.prototype.hcl = function() {
  return rgb2lch_default(this._rgb).reverse();
};
chroma_default.lch = (...args) => new Color_default(...args, "lch");
chroma_default.hcl = (...args) => new Color_default(...args, "hcl");
input_default.format.lch = lch2rgb_default;
input_default.format.hcl = hcl2rgb_default;
["lch", "hcl"].forEach(
  (m7) => input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, m7);
      if (type_default(args) === "array" && args.length === 3) {
        return m7;
      }
    }
  })
);

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/colors/w3cx11.js
var w3cx11 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
var w3cx11_default = w3cx11;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/named/index.js
Color_default.prototype.name = function() {
  const hex = rgb2hex_default(this._rgb, "rgb");
  for (let n6 of Object.keys(w3cx11_default)) {
    if (w3cx11_default[n6] === hex)
      return n6.toLowerCase();
  }
  return hex;
};
input_default.format.named = (name) => {
  name = name.toLowerCase();
  if (w3cx11_default[name])
    return hex2rgb_default(w3cx11_default[name]);
  throw new Error("unknown color name: " + name);
};
input_default.autodetect.push({
  p: 5,
  test: (h7, ...rest) => {
    if (!rest.length && type_default(h7) === "string" && w3cx11_default[h7.toLowerCase()]) {
      return "named";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/num2rgb.js
var num2rgb = (num2) => {
  if (type_default(num2) == "number" && num2 >= 0 && num2 <= 16777215) {
    const r6 = num2 >> 16;
    const g6 = num2 >> 8 & 255;
    const b5 = num2 & 255;
    return [r6, g6, b5, 1];
  }
  throw new Error("unknown num color: " + num2);
};
var num2rgb_default = num2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/rgb2num.js
var rgb2num = (...args) => {
  const [r6, g6, b5] = unpack_default(args, "rgb");
  return (r6 << 16) + (g6 << 8) + b5;
};
var rgb2num_default = rgb2num;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/index.js
Color_default.prototype.num = function() {
  return rgb2num_default(this._rgb);
};
chroma_default.num = (...args) => new Color_default(...args, "num");
input_default.format.num = num2rgb_default;
input_default.autodetect.push({
  p: 5,
  test: (...args) => {
    if (args.length === 1 && type_default(args[0]) === "number" && args[0] >= 0 && args[0] <= 16777215) {
      return "num";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/rgb/index.js
var { round: round6 } = Math;
Color_default.prototype.rgb = function(rnd2 = true) {
  if (rnd2 === false)
    return this._rgb.slice(0, 3);
  return this._rgb.slice(0, 3).map(round6);
};
Color_default.prototype.rgba = function(rnd2 = true) {
  return this._rgb.slice(0, 4).map((v8, i4) => {
    return i4 < 3 ? rnd2 === false ? v8 : round6(v8) : v8;
  });
};
chroma_default.rgb = (...args) => new Color_default(...args, "rgb");
input_default.format.rgb = (...args) => {
  const rgba = unpack_default(args, "rgba");
  if (rgba[3] === void 0)
    rgba[3] = 1;
  return rgba;
};
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "rgba");
    if (type_default(args) === "array" && (args.length === 3 || args.length === 4 && type_default(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
      return "rgb";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/temperature2rgb.js
var { log } = Math;
var temperature2rgb = (kelvin) => {
  const temp = kelvin / 100;
  let r6, g6, b5;
  if (temp < 66) {
    r6 = 255;
    g6 = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g6 = temp - 2) + 104.49216199393888 * log(g6);
    b5 = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b5 = temp - 10) + 115.67994401066147 * log(b5);
  } else {
    r6 = 351.97690566805693 + 0.114206453784165 * (r6 = temp - 55) - 40.25366309332127 * log(r6);
    g6 = 325.4494125711974 + 0.07943456536662342 * (g6 = temp - 50) - 28.0852963507957 * log(g6);
    b5 = 255;
  }
  return [r6, g6, b5, 1];
};
var temperature2rgb_default = temperature2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/rgb2temperature.js
var { round: round7 } = Math;
var rgb2temperature = (...args) => {
  const rgb2 = unpack_default(args, "rgb");
  const r6 = rgb2[0], b5 = rgb2[2];
  let minTemp = 1e3;
  let maxTemp = 4e4;
  const eps = 0.4;
  let temp;
  while (maxTemp - minTemp > eps) {
    temp = (maxTemp + minTemp) * 0.5;
    const rgb3 = temperature2rgb_default(temp);
    if (rgb3[2] / rgb3[0] >= b5 / r6) {
      maxTemp = temp;
    } else {
      minTemp = temp;
    }
  }
  return round7(temp);
};
var rgb2temperature_default = rgb2temperature;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/index.js
Color_default.prototype.temp = Color_default.prototype.kelvin = Color_default.prototype.temperature = function() {
  return rgb2temperature_default(this._rgb);
};
chroma_default.temp = chroma_default.kelvin = chroma_default.temperature = (...args) => new Color_default(...args, "temp");
input_default.format.temp = input_default.format.kelvin = input_default.format.temperature = temperature2rgb_default;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/oklab2rgb.js
var { pow: pow3, sign } = Math;
var oklab2rgb = (...args) => {
  args = unpack_default(args, "lab");
  const [L5, a3, b5] = args;
  const l3 = pow3(L5 + 0.3963377774 * a3 + 0.2158037573 * b5, 3);
  const m7 = pow3(L5 - 0.1055613458 * a3 - 0.0638541728 * b5, 3);
  const s3 = pow3(L5 - 0.0894841775 * a3 - 1.291485548 * b5, 3);
  return [
    255 * lrgb2rgb(4.0767416621 * l3 - 3.3077115913 * m7 + 0.2309699292 * s3),
    255 * lrgb2rgb(-1.2684380046 * l3 + 2.6097574011 * m7 - 0.3413193965 * s3),
    255 * lrgb2rgb(-0.0041960863 * l3 - 0.7034186147 * m7 + 1.707614701 * s3),
    args.length > 3 ? args[3] : 1
  ];
};
var oklab2rgb_default = oklab2rgb;
function lrgb2rgb(c5) {
  const abs3 = Math.abs(c5);
  if (abs3 > 31308e-7) {
    return (sign(c5) || 1) * (1.055 * pow3(abs3, 1 / 2.4) - 0.055);
  }
  return c5 * 12.92;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/rgb2oklab.js
var { cbrt, pow: pow4, sign: sign2 } = Math;
var rgb2oklab = (...args) => {
  const [r6, g6, b5] = unpack_default(args, "rgb");
  const [lr2, lg, lb] = [
    rgb2lrgb(r6 / 255),
    rgb2lrgb(g6 / 255),
    rgb2lrgb(b5 / 255)
  ];
  const l3 = cbrt(0.4122214708 * lr2 + 0.5363325363 * lg + 0.0514459929 * lb);
  const m7 = cbrt(0.2119034982 * lr2 + 0.6806995451 * lg + 0.1073969566 * lb);
  const s3 = cbrt(0.0883024619 * lr2 + 0.2817188376 * lg + 0.6299787005 * lb);
  return [
    0.2104542553 * l3 + 0.793617785 * m7 - 0.0040720468 * s3,
    1.9779984951 * l3 - 2.428592205 * m7 + 0.4505937099 * s3,
    0.0259040371 * l3 + 0.7827717662 * m7 - 0.808675766 * s3
  ];
};
var rgb2oklab_default = rgb2oklab;
function rgb2lrgb(c5) {
  const abs3 = Math.abs(c5);
  if (abs3 < 0.04045) {
    return c5 / 12.92;
  }
  return (sign2(c5) || 1) * pow4((abs3 + 0.055) / 1.055, 2.4);
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/index.js
Color_default.prototype.oklab = function() {
  return rgb2oklab_default(this._rgb);
};
chroma_default.oklab = (...args) => new Color_default(...args, "oklab");
input_default.format.oklab = oklab2rgb_default;
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "oklab");
    if (type_default(args) === "array" && args.length === 3) {
      return "oklab";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/oklch2rgb.js
var oklch2rgb = (...args) => {
  args = unpack_default(args, "lch");
  const [l3, c5, h7] = args;
  const [L5, a3, b_] = lch2lab_default(l3, c5, h7);
  const [r6, g6, b5] = oklab2rgb_default(L5, a3, b_);
  return [r6, g6, b5, args.length > 3 ? args[3] : 1];
};
var oklch2rgb_default = oklch2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/rgb2oklch.js
var rgb2oklch = (...args) => {
  const [r6, g6, b5] = unpack_default(args, "rgb");
  const [l3, a3, b_] = rgb2oklab_default(r6, g6, b5);
  return lab2lch_default(l3, a3, b_);
};
var rgb2oklch_default = rgb2oklch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/index.js
Color_default.prototype.oklch = function() {
  return rgb2oklch_default(this._rgb);
};
chroma_default.oklch = (...args) => new Color_default(...args, "oklch");
input_default.format.oklch = oklch2rgb_default;
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "oklch");
    if (type_default(args) === "array" && args.length === 3) {
      return "oklch";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/alpha.js
Color_default.prototype.alpha = function(a3, mutate = false) {
  if (a3 !== void 0 && type_default(a3) === "number") {
    if (mutate) {
      this._rgb[3] = a3;
      return this;
    }
    return new Color_default([this._rgb[0], this._rgb[1], this._rgb[2], a3], "rgb");
  }
  return this._rgb[3];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/clipped.js
Color_default.prototype.clipped = function() {
  return this._rgb._clipped || false;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/darken.js
Color_default.prototype.darken = function(amount = 1) {
  const me2 = this;
  const lab2 = me2.lab();
  lab2[0] -= lab_constants_default.Kn * amount;
  return new Color_default(lab2, "lab").alpha(me2.alpha(), true);
};
Color_default.prototype.brighten = function(amount = 1) {
  return this.darken(-amount);
};
Color_default.prototype.darker = Color_default.prototype.darken;
Color_default.prototype.brighter = Color_default.prototype.brighten;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/get.js
Color_default.prototype.get = function(mc) {
  const [mode, channel] = mc.split(".");
  const src = this[mode]();
  if (channel) {
    const i4 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
    if (i4 > -1)
      return src[i4];
    throw new Error(`unknown channel ${channel} in mode ${mode}`);
  } else {
    return src;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/luminance.js
var { pow: pow5 } = Math;
var EPS = 1e-7;
var MAX_ITER = 20;
Color_default.prototype.luminance = function(lum, mode = "rgb") {
  if (lum !== void 0 && type_default(lum) === "number") {
    if (lum === 0) {
      return new Color_default([0, 0, 0, this._rgb[3]], "rgb");
    }
    if (lum === 1) {
      return new Color_default([255, 255, 255, this._rgb[3]], "rgb");
    }
    let cur_lum = this.luminance();
    let max_iter = MAX_ITER;
    const test = (low, high) => {
      const mid = low.interpolate(high, 0.5, mode);
      const lm = mid.luminance();
      if (Math.abs(lum - lm) < EPS || !max_iter--) {
        return mid;
      }
      return lm > lum ? test(low, mid) : test(mid, high);
    };
    const rgb2 = (cur_lum > lum ? test(new Color_default([0, 0, 0]), this) : test(this, new Color_default([255, 255, 255]))).rgb();
    return new Color_default([...rgb2, this._rgb[3]]);
  }
  return rgb2luminance(...this._rgb.slice(0, 3));
};
var rgb2luminance = (r6, g6, b5) => {
  r6 = luminance_x(r6);
  g6 = luminance_x(g6);
  b5 = luminance_x(b5);
  return 0.2126 * r6 + 0.7152 * g6 + 0.0722 * b5;
};
var luminance_x = (x6) => {
  x6 /= 255;
  return x6 <= 0.03928 ? x6 / 12.92 : pow5((x6 + 0.055) / 1.055, 2.4);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/index.js
var interpolator_default = {};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/mix.js
var mix_default = (col1, col2, f5 = 0.5, ...rest) => {
  let mode = rest[0] || "lrgb";
  if (!interpolator_default[mode] && !rest.length) {
    mode = Object.keys(interpolator_default)[0];
  }
  if (!interpolator_default[mode]) {
    throw new Error(`interpolation mode ${mode} is not defined`);
  }
  if (type_default(col1) !== "object")
    col1 = new Color_default(col1);
  if (type_default(col2) !== "object")
    col2 = new Color_default(col2);
  return interpolator_default[mode](col1, col2, f5).alpha(
    col1.alpha() + f5 * (col2.alpha() - col1.alpha())
  );
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/mix.js
Color_default.prototype.mix = Color_default.prototype.interpolate = function(col2, f5 = 0.5, ...rest) {
  return mix_default(this, col2, f5, ...rest);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/premultiply.js
Color_default.prototype.premultiply = function(mutate = false) {
  const rgb2 = this._rgb;
  const a3 = rgb2[3];
  if (mutate) {
    this._rgb = [rgb2[0] * a3, rgb2[1] * a3, rgb2[2] * a3, a3];
    return this;
  } else {
    return new Color_default([rgb2[0] * a3, rgb2[1] * a3, rgb2[2] * a3, a3], "rgb");
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/saturate.js
Color_default.prototype.saturate = function(amount = 1) {
  const me2 = this;
  const lch2 = me2.lch();
  lch2[1] += lab_constants_default.Kn * amount;
  if (lch2[1] < 0)
    lch2[1] = 0;
  return new Color_default(lch2, "lch").alpha(me2.alpha(), true);
};
Color_default.prototype.desaturate = function(amount = 1) {
  return this.saturate(-amount);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/set.js
Color_default.prototype.set = function(mc, value, mutate = false) {
  const [mode, channel] = mc.split(".");
  const src = this[mode]();
  if (channel) {
    const i4 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
    if (i4 > -1) {
      if (type_default(value) == "string") {
        switch (value.charAt(0)) {
          case "+":
            src[i4] += +value;
            break;
          case "-":
            src[i4] += +value;
            break;
          case "*":
            src[i4] *= +value.substr(1);
            break;
          case "/":
            src[i4] /= +value.substr(1);
            break;
          default:
            src[i4] = +value;
        }
      } else if (type_default(value) === "number") {
        src[i4] = value;
      } else {
        throw new Error(`unsupported value for Color.set`);
      }
      const out = new Color_default(src, mode);
      if (mutate) {
        this._rgb = out._rgb;
        return this;
      }
      return out;
    }
    throw new Error(`unknown channel ${channel} in mode ${mode}`);
  } else {
    return src;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/shade.js
Color_default.prototype.tint = function(f5 = 0.5, ...rest) {
  return mix_default(this, "white", f5, ...rest);
};
Color_default.prototype.shade = function(f5 = 0.5, ...rest) {
  return mix_default(this, "black", f5, ...rest);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/rgb.js
var rgb = (col1, col2, f5) => {
  const xyz0 = col1._rgb;
  const xyz1 = col2._rgb;
  return new Color_default(
    xyz0[0] + f5 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f5 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f5 * (xyz1[2] - xyz0[2]),
    "rgb"
  );
};
interpolator_default.rgb = rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lrgb.js
var { sqrt: sqrt3, pow: pow6 } = Math;
var lrgb = (col1, col2, f5) => {
  const [x1, y1, z1] = col1._rgb;
  const [x22, y22, z22] = col2._rgb;
  return new Color_default(
    sqrt3(pow6(x1, 2) * (1 - f5) + pow6(x22, 2) * f5),
    sqrt3(pow6(y1, 2) * (1 - f5) + pow6(y22, 2) * f5),
    sqrt3(pow6(z1, 2) * (1 - f5) + pow6(z22, 2) * f5),
    "rgb"
  );
};
interpolator_default.lrgb = lrgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lab.js
var lab = (col1, col2, f5) => {
  const xyz0 = col1.lab();
  const xyz1 = col2.lab();
  return new Color_default(
    xyz0[0] + f5 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f5 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f5 * (xyz1[2] - xyz0[2]),
    "lab"
  );
};
interpolator_default.lab = lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/_hsx.js
var hsx_default = (col1, col2, f5, m7) => {
  let xyz0, xyz1;
  if (m7 === "hsl") {
    xyz0 = col1.hsl();
    xyz1 = col2.hsl();
  } else if (m7 === "hsv") {
    xyz0 = col1.hsv();
    xyz1 = col2.hsv();
  } else if (m7 === "hcg") {
    xyz0 = col1.hcg();
    xyz1 = col2.hcg();
  } else if (m7 === "hsi") {
    xyz0 = col1.hsi();
    xyz1 = col2.hsi();
  } else if (m7 === "lch" || m7 === "hcl") {
    m7 = "hcl";
    xyz0 = col1.hcl();
    xyz1 = col2.hcl();
  } else if (m7 === "oklch") {
    xyz0 = col1.oklch().reverse();
    xyz1 = col2.oklch().reverse();
  }
  let hue0, hue1, sat0, sat1, lbv0, lbv1;
  if (m7.substr(0, 1) === "h" || m7 === "oklch") {
    [hue0, sat0, lbv0] = xyz0;
    [hue1, sat1, lbv1] = xyz1;
  }
  let sat, hue, lbv, dh;
  if (!isNaN(hue0) && !isNaN(hue1)) {
    if (hue1 > hue0 && hue1 - hue0 > 180) {
      dh = hue1 - (hue0 + 360);
    } else if (hue1 < hue0 && hue0 - hue1 > 180) {
      dh = hue1 + 360 - hue0;
    } else {
      dh = hue1 - hue0;
    }
    hue = hue0 + f5 * dh;
  } else if (!isNaN(hue0)) {
    hue = hue0;
    if ((lbv1 == 1 || lbv1 == 0) && m7 != "hsv")
      sat = sat0;
  } else if (!isNaN(hue1)) {
    hue = hue1;
    if ((lbv0 == 1 || lbv0 == 0) && m7 != "hsv")
      sat = sat1;
  } else {
    hue = Number.NaN;
  }
  if (sat === void 0)
    sat = sat0 + f5 * (sat1 - sat0);
  lbv = lbv0 + f5 * (lbv1 - lbv0);
  return m7 === "oklch" ? new Color_default([lbv, sat, hue], m7) : new Color_default([hue, sat, lbv], m7);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lch.js
var lch = (col1, col2, f5) => {
  return hsx_default(col1, col2, f5, "lch");
};
interpolator_default.lch = lch;
interpolator_default.hcl = lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/num.js
var num = (col1, col2, f5) => {
  const c1 = col1.num();
  const c22 = col2.num();
  return new Color_default(c1 + f5 * (c22 - c1), "num");
};
interpolator_default.num = num;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hcg.js
var hcg = (col1, col2, f5) => {
  return hsx_default(col1, col2, f5, "hcg");
};
interpolator_default.hcg = hcg;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsi.js
var hsi = (col1, col2, f5) => {
  return hsx_default(col1, col2, f5, "hsi");
};
interpolator_default.hsi = hsi;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsl.js
var hsl = (col1, col2, f5) => {
  return hsx_default(col1, col2, f5, "hsl");
};
interpolator_default.hsl = hsl;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsv.js
var hsv = (col1, col2, f5) => {
  return hsx_default(col1, col2, f5, "hsv");
};
interpolator_default.hsv = hsv;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/oklab.js
var oklab = (col1, col2, f5) => {
  const xyz0 = col1.oklab();
  const xyz1 = col2.oklab();
  return new Color_default(
    xyz0[0] + f5 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f5 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f5 * (xyz1[2] - xyz0[2]),
    "oklab"
  );
};
interpolator_default.oklab = oklab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/oklch.js
var oklch = (col1, col2, f5) => {
  return hsx_default(col1, col2, f5, "oklch");
};
interpolator_default.oklch = oklch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/average.js
var { pow: pow7, sqrt: sqrt4, PI: PI2, cos: cos3, sin: sin2, atan2: atan22 } = Math;
var average_default = (colors, mode = "lrgb", weights = null) => {
  const l3 = colors.length;
  if (!weights)
    weights = Array.from(new Array(l3)).map(() => 1);
  const k6 = l3 / weights.reduce(function(a3, b5) {
    return a3 + b5;
  });
  weights.forEach((w6, i4) => {
    weights[i4] *= k6;
  });
  colors = colors.map((c5) => new Color_default(c5));
  if (mode === "lrgb") {
    return _average_lrgb(colors, weights);
  }
  const first = colors.shift();
  const xyz = first.get(mode);
  const cnt = [];
  let dx = 0;
  let dy = 0;
  for (let i4 = 0; i4 < xyz.length; i4++) {
    xyz[i4] = (xyz[i4] || 0) * weights[0];
    cnt.push(isNaN(xyz[i4]) ? 0 : weights[0]);
    if (mode.charAt(i4) === "h" && !isNaN(xyz[i4])) {
      const A5 = xyz[i4] / 180 * PI2;
      dx += cos3(A5) * weights[0];
      dy += sin2(A5) * weights[0];
    }
  }
  let alpha = first.alpha() * weights[0];
  colors.forEach((c5, ci2) => {
    const xyz2 = c5.get(mode);
    alpha += c5.alpha() * weights[ci2 + 1];
    for (let i4 = 0; i4 < xyz.length; i4++) {
      if (!isNaN(xyz2[i4])) {
        cnt[i4] += weights[ci2 + 1];
        if (mode.charAt(i4) === "h") {
          const A5 = xyz2[i4] / 180 * PI2;
          dx += cos3(A5) * weights[ci2 + 1];
          dy += sin2(A5) * weights[ci2 + 1];
        } else {
          xyz[i4] += xyz2[i4] * weights[ci2 + 1];
        }
      }
    }
  });
  for (let i4 = 0; i4 < xyz.length; i4++) {
    if (mode.charAt(i4) === "h") {
      let A5 = atan22(dy / cnt[i4], dx / cnt[i4]) / PI2 * 180;
      while (A5 < 0)
        A5 += 360;
      while (A5 >= 360)
        A5 -= 360;
      xyz[i4] = A5;
    } else {
      xyz[i4] = xyz[i4] / cnt[i4];
    }
  }
  alpha /= l3;
  return new Color_default(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
};
var _average_lrgb = (colors, weights) => {
  const l3 = colors.length;
  const xyz = [0, 0, 0, 0];
  for (let i4 = 0; i4 < colors.length; i4++) {
    const col = colors[i4];
    const f5 = weights[i4] / l3;
    const rgb2 = col._rgb;
    xyz[0] += pow7(rgb2[0], 2) * f5;
    xyz[1] += pow7(rgb2[1], 2) * f5;
    xyz[2] += pow7(rgb2[2], 2) * f5;
    xyz[3] += rgb2[3] * f5;
  }
  xyz[0] = sqrt4(xyz[0]);
  xyz[1] = sqrt4(xyz[1]);
  xyz[2] = sqrt4(xyz[2]);
  if (xyz[3] > 0.9999999)
    xyz[3] = 1;
  return new Color_default(clip_rgb_default(xyz));
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/scale.js
var { pow: pow8 } = Math;
function scale_default(colors) {
  let _mode = "rgb";
  let _nacol = chroma_default("#ccc");
  let _spread = 0;
  let _domain = [0, 1];
  let _pos = [];
  let _padding = [0, 0];
  let _classes = false;
  let _colors = [];
  let _out = false;
  let _min = 0;
  let _max = 1;
  let _correctLightness = false;
  let _colorCache = {};
  let _useCache = true;
  let _gamma = 1;
  const setColors = function(colors2) {
    colors2 = colors2 || ["#fff", "#000"];
    if (colors2 && type_default(colors2) === "string" && chroma_default.brewer && chroma_default.brewer[colors2.toLowerCase()]) {
      colors2 = chroma_default.brewer[colors2.toLowerCase()];
    }
    if (type_default(colors2) === "array") {
      if (colors2.length === 1) {
        colors2 = [colors2[0], colors2[0]];
      }
      colors2 = colors2.slice(0);
      for (let c5 = 0; c5 < colors2.length; c5++) {
        colors2[c5] = chroma_default(colors2[c5]);
      }
      _pos.length = 0;
      for (let c5 = 0; c5 < colors2.length; c5++) {
        _pos.push(c5 / (colors2.length - 1));
      }
    }
    resetCache();
    return _colors = colors2;
  };
  const getClass = function(value) {
    if (_classes != null) {
      const n6 = _classes.length - 1;
      let i4 = 0;
      while (i4 < n6 && value >= _classes[i4]) {
        i4++;
      }
      return i4 - 1;
    }
    return 0;
  };
  let tMapLightness = (t5) => t5;
  let tMapDomain = (t5) => t5;
  const getColor2 = function(val, bypassMap) {
    let col, t5;
    if (bypassMap == null) {
      bypassMap = false;
    }
    if (isNaN(val) || val === null) {
      return _nacol;
    }
    if (!bypassMap) {
      if (_classes && _classes.length > 2) {
        const c5 = getClass(val);
        t5 = c5 / (_classes.length - 2);
      } else if (_max !== _min) {
        t5 = (val - _min) / (_max - _min);
      } else {
        t5 = 1;
      }
    } else {
      t5 = val;
    }
    t5 = tMapDomain(t5);
    if (!bypassMap) {
      t5 = tMapLightness(t5);
    }
    if (_gamma !== 1) {
      t5 = pow8(t5, _gamma);
    }
    t5 = _padding[0] + t5 * (1 - _padding[0] - _padding[1]);
    t5 = limit_default(t5, 0, 1);
    const k6 = Math.floor(t5 * 1e4);
    if (_useCache && _colorCache[k6]) {
      col = _colorCache[k6];
    } else {
      if (type_default(_colors) === "array") {
        for (let i4 = 0; i4 < _pos.length; i4++) {
          const p5 = _pos[i4];
          if (t5 <= p5) {
            col = _colors[i4];
            break;
          }
          if (t5 >= p5 && i4 === _pos.length - 1) {
            col = _colors[i4];
            break;
          }
          if (t5 > p5 && t5 < _pos[i4 + 1]) {
            t5 = (t5 - p5) / (_pos[i4 + 1] - p5);
            col = chroma_default.interpolate(
              _colors[i4],
              _colors[i4 + 1],
              t5,
              _mode
            );
            break;
          }
        }
      } else if (type_default(_colors) === "function") {
        col = _colors(t5);
      }
      if (_useCache) {
        _colorCache[k6] = col;
      }
    }
    return col;
  };
  var resetCache = () => _colorCache = {};
  setColors(colors);
  const f5 = function(v8) {
    const c5 = chroma_default(getColor2(v8));
    if (_out && c5[_out]) {
      return c5[_out]();
    } else {
      return c5;
    }
  };
  f5.classes = function(classes) {
    if (classes != null) {
      if (type_default(classes) === "array") {
        _classes = classes;
        _domain = [classes[0], classes[classes.length - 1]];
      } else {
        const d4 = chroma_default.analyze(_domain);
        if (classes === 0) {
          _classes = [d4.min, d4.max];
        } else {
          _classes = chroma_default.limits(d4, "e", classes);
        }
      }
      return f5;
    }
    return _classes;
  };
  f5.domain = function(domain) {
    if (!arguments.length) {
      return _domain;
    }
    _min = domain[0];
    _max = domain[domain.length - 1];
    _pos = [];
    const k6 = _colors.length;
    if (domain.length === k6 && _min !== _max) {
      for (let d4 of Array.from(domain)) {
        _pos.push((d4 - _min) / (_max - _min));
      }
    } else {
      for (let c5 = 0; c5 < k6; c5++) {
        _pos.push(c5 / (k6 - 1));
      }
      if (domain.length > 2) {
        const tOut = domain.map((d4, i4) => i4 / (domain.length - 1));
        const tBreaks = domain.map((d4) => (d4 - _min) / (_max - _min));
        if (!tBreaks.every((val, i4) => tOut[i4] === val)) {
          tMapDomain = (t5) => {
            if (t5 <= 0 || t5 >= 1)
              return t5;
            let i4 = 0;
            while (t5 >= tBreaks[i4 + 1])
              i4++;
            const f6 = (t5 - tBreaks[i4]) / (tBreaks[i4 + 1] - tBreaks[i4]);
            const out = tOut[i4] + f6 * (tOut[i4 + 1] - tOut[i4]);
            return out;
          };
        }
      }
    }
    _domain = [_min, _max];
    return f5;
  };
  f5.mode = function(_m) {
    if (!arguments.length) {
      return _mode;
    }
    _mode = _m;
    resetCache();
    return f5;
  };
  f5.range = function(colors2, _pos2) {
    setColors(colors2, _pos2);
    return f5;
  };
  f5.out = function(_o) {
    _out = _o;
    return f5;
  };
  f5.spread = function(val) {
    if (!arguments.length) {
      return _spread;
    }
    _spread = val;
    return f5;
  };
  f5.correctLightness = function(v8) {
    if (v8 == null) {
      v8 = true;
    }
    _correctLightness = v8;
    resetCache();
    if (_correctLightness) {
      tMapLightness = function(t5) {
        const L0 = getColor2(0, true).lab()[0];
        const L1 = getColor2(1, true).lab()[0];
        const pol = L0 > L1;
        let L_actual = getColor2(t5, true).lab()[0];
        const L_ideal = L0 + (L1 - L0) * t5;
        let L_diff = L_actual - L_ideal;
        let t0 = 0;
        let t1 = 1;
        let max_iter = 20;
        while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
          (function() {
            if (pol) {
              L_diff *= -1;
            }
            if (L_diff < 0) {
              t0 = t5;
              t5 += (t1 - t5) * 0.5;
            } else {
              t1 = t5;
              t5 += (t0 - t5) * 0.5;
            }
            L_actual = getColor2(t5, true).lab()[0];
            return L_diff = L_actual - L_ideal;
          })();
        }
        return t5;
      };
    } else {
      tMapLightness = (t5) => t5;
    }
    return f5;
  };
  f5.padding = function(p5) {
    if (p5 != null) {
      if (type_default(p5) === "number") {
        p5 = [p5, p5];
      }
      _padding = p5;
      return f5;
    } else {
      return _padding;
    }
  };
  f5.colors = function(numColors, out) {
    if (arguments.length < 2) {
      out = "hex";
    }
    let result = [];
    if (arguments.length === 0) {
      result = _colors.slice(0);
    } else if (numColors === 1) {
      result = [f5(0.5)];
    } else if (numColors > 1) {
      const dm = _domain[0];
      const dd = _domain[1] - dm;
      result = __range__(0, numColors, false).map(
        (i4) => f5(dm + i4 / (numColors - 1) * dd)
      );
    } else {
      colors = [];
      let samples = [];
      if (_classes && _classes.length > 2) {
        for (let i4 = 1, end = _classes.length, asc = 1 <= end; asc ? i4 < end : i4 > end; asc ? i4++ : i4--) {
          samples.push((_classes[i4 - 1] + _classes[i4]) * 0.5);
        }
      } else {
        samples = _domain;
      }
      result = samples.map((v8) => f5(v8));
    }
    if (chroma_default[out]) {
      result = result.map((c5) => c5[out]());
    }
    return result;
  };
  f5.cache = function(c5) {
    if (c5 != null) {
      _useCache = c5;
      return f5;
    } else {
      return _useCache;
    }
  };
  f5.gamma = function(g6) {
    if (g6 != null) {
      _gamma = g6;
      return f5;
    } else {
      return _gamma;
    }
  };
  f5.nodata = function(d4) {
    if (d4 != null) {
      _nacol = chroma_default(d4);
      return f5;
    } else {
      return _nacol;
    }
  };
  return f5;
}
function __range__(left, right, inclusive) {
  let range = [];
  let ascending = left < right;
  let end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i4 = left; ascending ? i4 < end : i4 > end; ascending ? i4++ : i4--) {
    range.push(i4);
  }
  return range;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/bezier.js
var binom_row = function(n6) {
  let row = [1, 1];
  for (let i4 = 1; i4 < n6; i4++) {
    let newrow = [1];
    for (let j5 = 1; j5 <= row.length; j5++) {
      newrow[j5] = (row[j5] || 0) + row[j5 - 1];
    }
    row = newrow;
  }
  return row;
};
var bezier = function(colors) {
  let I6, lab0, lab1, lab2;
  colors = colors.map((c5) => new Color_default(c5));
  if (colors.length === 2) {
    [lab0, lab1] = colors.map((c5) => c5.lab());
    I6 = function(t5) {
      const lab3 = [0, 1, 2].map((i4) => lab0[i4] + t5 * (lab1[i4] - lab0[i4]));
      return new Color_default(lab3, "lab");
    };
  } else if (colors.length === 3) {
    [lab0, lab1, lab2] = colors.map((c5) => c5.lab());
    I6 = function(t5) {
      const lab3 = [0, 1, 2].map(
        (i4) => (1 - t5) * (1 - t5) * lab0[i4] + 2 * (1 - t5) * t5 * lab1[i4] + t5 * t5 * lab2[i4]
      );
      return new Color_default(lab3, "lab");
    };
  } else if (colors.length === 4) {
    let lab3;
    [lab0, lab1, lab2, lab3] = colors.map((c5) => c5.lab());
    I6 = function(t5) {
      const lab4 = [0, 1, 2].map(
        (i4) => (1 - t5) * (1 - t5) * (1 - t5) * lab0[i4] + 3 * (1 - t5) * (1 - t5) * t5 * lab1[i4] + 3 * (1 - t5) * t5 * t5 * lab2[i4] + t5 * t5 * t5 * lab3[i4]
      );
      return new Color_default(lab4, "lab");
    };
  } else if (colors.length >= 5) {
    let labs, row, n6;
    labs = colors.map((c5) => c5.lab());
    n6 = colors.length - 1;
    row = binom_row(n6);
    I6 = function(t5) {
      const u3 = 1 - t5;
      const lab3 = [0, 1, 2].map(
        (i4) => labs.reduce(
          (sum, el, j5) => sum + row[j5] * u3 ** (n6 - j5) * t5 ** j5 * el[i4],
          0
        )
      );
      return new Color_default(lab3, "lab");
    };
  } else {
    throw new RangeError("No point in running bezier with only one color.");
  }
  return I6;
};
var bezier_default = (colors) => {
  const f5 = bezier(colors);
  f5.scale = () => scale_default(f5);
  return f5;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/blend.js
var blend = (bottom, top, mode) => {
  if (!blend[mode]) {
    throw new Error("unknown blend mode " + mode);
  }
  return blend[mode](bottom, top);
};
var blend_f = (f5) => (bottom, top) => {
  const c0 = chroma_default(top).rgb();
  const c1 = chroma_default(bottom).rgb();
  return chroma_default.rgb(f5(c0, c1));
};
var each = (f5) => (c0, c1) => {
  const out = [];
  out[0] = f5(c0[0], c1[0]);
  out[1] = f5(c0[1], c1[1]);
  out[2] = f5(c0[2], c1[2]);
  return out;
};
var normal = (a3) => a3;
var multiply = (a3, b5) => a3 * b5 / 255;
var darken = (a3, b5) => a3 > b5 ? b5 : a3;
var lighten = (a3, b5) => a3 > b5 ? a3 : b5;
var screen = (a3, b5) => 255 * (1 - (1 - a3 / 255) * (1 - b5 / 255));
var overlay = (a3, b5) => b5 < 128 ? 2 * a3 * b5 / 255 : 255 * (1 - 2 * (1 - a3 / 255) * (1 - b5 / 255));
var burn = (a3, b5) => 255 * (1 - (1 - b5 / 255) / (a3 / 255));
var dodge = (a3, b5) => {
  if (a3 === 255)
    return 255;
  a3 = 255 * (b5 / 255) / (1 - a3 / 255);
  return a3 > 255 ? 255 : a3;
};
blend.normal = blend_f(each(normal));
blend.multiply = blend_f(each(multiply));
blend.screen = blend_f(each(screen));
blend.overlay = blend_f(each(overlay));
blend.darken = blend_f(each(darken));
blend.lighten = blend_f(each(lighten));
blend.dodge = blend_f(each(dodge));
blend.burn = blend_f(each(burn));
var blend_default = blend;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/cubehelix.js
var { pow: pow9, sin: sin3, cos: cos4 } = Math;
function cubehelix_default(start = 300, rotations = -1.5, hue = 1, gamma = 1, lightness = [0, 1]) {
  let dh = 0, dl;
  if (type_default(lightness) === "array") {
    dl = lightness[1] - lightness[0];
  } else {
    dl = 0;
    lightness = [lightness, lightness];
  }
  const f5 = function(fract) {
    const a3 = TWOPI * ((start + 120) / 360 + rotations * fract);
    const l3 = pow9(lightness[0] + dl * fract, gamma);
    const h7 = dh !== 0 ? hue[0] + fract * dh : hue;
    const amp = h7 * l3 * (1 - l3) / 2;
    const cos_a = cos4(a3);
    const sin_a = sin3(a3);
    const r6 = l3 + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
    const g6 = l3 + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
    const b5 = l3 + amp * (1.97294 * cos_a);
    return chroma_default(clip_rgb_default([r6 * 255, g6 * 255, b5 * 255, 1]));
  };
  f5.start = function(s3) {
    if (s3 == null) {
      return start;
    }
    start = s3;
    return f5;
  };
  f5.rotations = function(r6) {
    if (r6 == null) {
      return rotations;
    }
    rotations = r6;
    return f5;
  };
  f5.gamma = function(g6) {
    if (g6 == null) {
      return gamma;
    }
    gamma = g6;
    return f5;
  };
  f5.hue = function(h7) {
    if (h7 == null) {
      return hue;
    }
    hue = h7;
    if (type_default(hue) === "array") {
      dh = hue[1] - hue[0];
      if (dh === 0) {
        hue = hue[1];
      }
    } else {
      dh = 0;
    }
    return f5;
  };
  f5.lightness = function(h7) {
    if (h7 == null) {
      return lightness;
    }
    if (type_default(h7) === "array") {
      lightness = h7;
      dl = h7[1] - h7[0];
    } else {
      lightness = [h7, h7];
      dl = 0;
    }
    return f5;
  };
  f5.scale = () => chroma_default.scale(f5);
  f5.hue(hue);
  return f5;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/random.js
var digits = "0123456789abcdef";
var { floor: floor3, random } = Math;
var random_default = () => {
  let code = "#";
  for (let i4 = 0; i4 < 6; i4++) {
    code += digits.charAt(floor3(random() * 16));
  }
  return new Color_default(code, "hex");
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/analyze.js
var { log: log2, pow: pow10, floor: floor4, abs } = Math;
function analyze(data, key = null) {
  const r6 = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  if (type_default(data) === "object") {
    data = Object.values(data);
  }
  data.forEach((val) => {
    if (key && type_default(val) === "object")
      val = val[key];
    if (val !== void 0 && val !== null && !isNaN(val)) {
      r6.values.push(val);
      r6.sum += val;
      if (val < r6.min)
        r6.min = val;
      if (val > r6.max)
        r6.max = val;
      r6.count += 1;
    }
  });
  r6.domain = [r6.min, r6.max];
  r6.limits = (mode, num2) => limits(r6, mode, num2);
  return r6;
}
function limits(data, mode = "equal", num2 = 7) {
  if (type_default(data) == "array") {
    data = analyze(data);
  }
  const { min: min6, max: max6 } = data;
  const values = data.values.sort((a3, b5) => a3 - b5);
  if (num2 === 1) {
    return [min6, max6];
  }
  const limits2 = [];
  if (mode.substr(0, 1) === "c") {
    limits2.push(min6);
    limits2.push(max6);
  }
  if (mode.substr(0, 1) === "e") {
    limits2.push(min6);
    for (let i4 = 1; i4 < num2; i4++) {
      limits2.push(min6 + i4 / num2 * (max6 - min6));
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "l") {
    if (min6 <= 0) {
      throw new Error(
        "Logarithmic scales are only possible for values > 0"
      );
    }
    const min_log = Math.LOG10E * log2(min6);
    const max_log = Math.LOG10E * log2(max6);
    limits2.push(min6);
    for (let i4 = 1; i4 < num2; i4++) {
      limits2.push(pow10(10, min_log + i4 / num2 * (max_log - min_log)));
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "q") {
    limits2.push(min6);
    for (let i4 = 1; i4 < num2; i4++) {
      const p5 = (values.length - 1) * i4 / num2;
      const pb = floor4(p5);
      if (pb === p5) {
        limits2.push(values[pb]);
      } else {
        const pr2 = p5 - pb;
        limits2.push(values[pb] * (1 - pr2) + values[pb + 1] * pr2);
      }
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "k") {
    let cluster;
    const n6 = values.length;
    const assignments = new Array(n6);
    const clusterSizes = new Array(num2);
    let repeat = true;
    let nb_iters = 0;
    let centroids = null;
    centroids = [];
    centroids.push(min6);
    for (let i4 = 1; i4 < num2; i4++) {
      centroids.push(min6 + i4 / num2 * (max6 - min6));
    }
    centroids.push(max6);
    while (repeat) {
      for (let j5 = 0; j5 < num2; j5++) {
        clusterSizes[j5] = 0;
      }
      for (let i4 = 0; i4 < n6; i4++) {
        const value = values[i4];
        let mindist = Number.MAX_VALUE;
        let best;
        for (let j5 = 0; j5 < num2; j5++) {
          const dist = abs(centroids[j5] - value);
          if (dist < mindist) {
            mindist = dist;
            best = j5;
          }
          clusterSizes[best]++;
          assignments[i4] = best;
        }
      }
      const newCentroids = new Array(num2);
      for (let j5 = 0; j5 < num2; j5++) {
        newCentroids[j5] = null;
      }
      for (let i4 = 0; i4 < n6; i4++) {
        cluster = assignments[i4];
        if (newCentroids[cluster] === null) {
          newCentroids[cluster] = values[i4];
        } else {
          newCentroids[cluster] += values[i4];
        }
      }
      for (let j5 = 0; j5 < num2; j5++) {
        newCentroids[j5] *= 1 / clusterSizes[j5];
      }
      repeat = false;
      for (let j5 = 0; j5 < num2; j5++) {
        if (newCentroids[j5] !== centroids[j5]) {
          repeat = true;
          break;
        }
      }
      centroids = newCentroids;
      nb_iters++;
      if (nb_iters > 200) {
        repeat = false;
      }
    }
    const kClusters = {};
    for (let j5 = 0; j5 < num2; j5++) {
      kClusters[j5] = [];
    }
    for (let i4 = 0; i4 < n6; i4++) {
      cluster = assignments[i4];
      kClusters[cluster].push(values[i4]);
    }
    let tmpKMeansBreaks = [];
    for (let j5 = 0; j5 < num2; j5++) {
      tmpKMeansBreaks.push(kClusters[j5][0]);
      tmpKMeansBreaks.push(kClusters[j5][kClusters[j5].length - 1]);
    }
    tmpKMeansBreaks = tmpKMeansBreaks.sort((a3, b5) => a3 - b5);
    limits2.push(tmpKMeansBreaks[0]);
    for (let i4 = 1; i4 < tmpKMeansBreaks.length; i4 += 2) {
      const v8 = tmpKMeansBreaks[i4];
      if (!isNaN(v8) && limits2.indexOf(v8) === -1) {
        limits2.push(v8);
      }
    }
  }
  return limits2;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/contrast.js
var contrast_default = (a3, b5) => {
  a3 = new Color_default(a3);
  b5 = new Color_default(b5);
  const l1 = a3.luminance();
  const l22 = b5.luminance();
  return l1 > l22 ? (l1 + 0.05) / (l22 + 0.05) : (l22 + 0.05) / (l1 + 0.05);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/delta-e.js
var { sqrt: sqrt5, pow: pow11, min: min4, max: max4, atan2: atan23, abs: abs2, cos: cos5, sin: sin4, exp, PI: PI3 } = Math;
function delta_e_default(a3, b5, Kl = 1, Kc = 1, Kh = 1) {
  var rad2deg = function(rad) {
    return 360 * rad / (2 * PI3);
  };
  var deg2rad = function(deg) {
    return 2 * PI3 * deg / 360;
  };
  a3 = new Color_default(a3);
  b5 = new Color_default(b5);
  const [L1, a1, b1] = Array.from(a3.lab());
  const [L22, a22, b22] = Array.from(b5.lab());
  const avgL = (L1 + L22) / 2;
  const C1 = sqrt5(pow11(a1, 2) + pow11(b1, 2));
  const C22 = sqrt5(pow11(a22, 2) + pow11(b22, 2));
  const avgC = (C1 + C22) / 2;
  const G4 = 0.5 * (1 - sqrt5(pow11(avgC, 7) / (pow11(avgC, 7) + pow11(25, 7))));
  const a1p = a1 * (1 + G4);
  const a2p = a22 * (1 + G4);
  const C1p = sqrt5(pow11(a1p, 2) + pow11(b1, 2));
  const C2p = sqrt5(pow11(a2p, 2) + pow11(b22, 2));
  const avgCp = (C1p + C2p) / 2;
  const arctan1 = rad2deg(atan23(b1, a1p));
  const arctan2 = rad2deg(atan23(b22, a2p));
  const h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
  const h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
  const avgHp = abs2(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
  const T6 = 1 - 0.17 * cos5(deg2rad(avgHp - 30)) + 0.24 * cos5(deg2rad(2 * avgHp)) + 0.32 * cos5(deg2rad(3 * avgHp + 6)) - 0.2 * cos5(deg2rad(4 * avgHp - 63));
  let deltaHp = h2p - h1p;
  deltaHp = abs2(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
  deltaHp = 2 * sqrt5(C1p * C2p) * sin4(deg2rad(deltaHp) / 2);
  const deltaL = L22 - L1;
  const deltaCp = C2p - C1p;
  const sl = 1 + 0.015 * pow11(avgL - 50, 2) / sqrt5(20 + pow11(avgL - 50, 2));
  const sc = 1 + 0.045 * avgCp;
  const sh = 1 + 0.015 * avgCp * T6;
  const deltaTheta = 30 * exp(-pow11((avgHp - 275) / 25, 2));
  const Rc = 2 * sqrt5(pow11(avgCp, 7) / (pow11(avgCp, 7) + pow11(25, 7)));
  const Rt3 = -Rc * sin4(2 * deg2rad(deltaTheta));
  const result = sqrt5(
    pow11(deltaL / (Kl * sl), 2) + pow11(deltaCp / (Kc * sc), 2) + pow11(deltaHp / (Kh * sh), 2) + Rt3 * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))
  );
  return max4(0, min4(100, result));
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/distance.js
function distance_default(a3, b5, mode = "lab") {
  a3 = new Color_default(a3);
  b5 = new Color_default(b5);
  const l1 = a3.get(mode);
  const l22 = b5.get(mode);
  let sum_sq = 0;
  for (let i4 in l1) {
    const d4 = (l1[i4] || 0) - (l22[i4] || 0);
    sum_sq += d4 * d4;
  }
  return Math.sqrt(sum_sq);
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/valid.js
var valid_default = (...args) => {
  try {
    new Color_default(...args);
    return true;
  } catch (e6) {
    return false;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/scales.js
var scales_default = {
  cool() {
    return scale_default([chroma_default.hsl(180, 1, 0.9), chroma_default.hsl(250, 0.7, 0.4)]);
  },
  hot() {
    return scale_default(["#000", "#f00", "#ff0", "#fff"], [0, 0.25, 0.75, 1]).mode(
      "rgb"
    );
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/colors/colorbrewer.js
var colorbrewer = {
  // sequential
  OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
  PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
  BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
  Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
  BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
  YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
  YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
  Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
  RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
  Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
  YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
  Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
  GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
  Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
  YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
  PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
  Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
  PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
  Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
  // diverging
  Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
  RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
  RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
  PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
  PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
  RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
  BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
  RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
  PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
  // qualitative
  Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
  Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
  Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
  Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
  Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
  Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
  Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
  Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
};
for (let key of Object.keys(colorbrewer)) {
  colorbrewer[key.toLowerCase()] = colorbrewer[key];
}
var colorbrewer_default = colorbrewer;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/index.js
Object.assign(chroma_default, {
  average: average_default,
  bezier: bezier_default,
  blend: blend_default,
  cubehelix: cubehelix_default,
  mix: mix_default,
  interpolate: mix_default,
  random: random_default,
  scale: scale_default,
  analyze,
  contrast: contrast_default,
  deltaE: delta_e_default,
  distance: distance_default,
  limits,
  valid: valid_default,
  scales: scales_default,
  input: input_default,
  colors: w3cx11_default,
  brewer: colorbrewer_default
});
var chroma_js_default = chroma_default;

// ../bundle-component/dist/helper/overridePrimitiveColors.js
var overridePrimitiveColors = () => {
  const inlangMessageBundle = document.querySelector("inlang-message-bundle");
  if (!inlangMessageBundle)
    return void 0;
  const primitives = ["primary", "success", "warning", "danger", "neutral"];
  for (const primitive of primitives) {
    const unformattedColor = window.getComputedStyle(inlangMessageBundle).getPropertyValue(`--inlang-color-${primitive}`).trim();
    if (unformattedColor !== "") {
      const colorShades = getPalette(unformattedColor);
      appendCSSProperties(colorShades, primitive, inlangMessageBundle);
    }
  }
};
var appendCSSProperties = (colorShades, primitive, element) => {
  let textContent = Object.entries(colorShades).map(([index, shade]) => `--sl-color-${primitive}-${index}: ${shade} !important;`).join("\n");
  textContent = ":host { " + textContent + " }";
  const shadowRoot = element.shadowRoot || element.attachShadow({ mode: "open" });
  const style = document.createElement("style");
  style.textContent = textContent;
  shadowRoot.appendChild(style);
};
var getColor = (unformattedColor) => chroma_js_default(unformattedColor);
var getPalette = (unformattedColor) => {
  const color = getColor(unformattedColor);
  const colors = chroma_js_default.scale(["white", color, "black"]).domain([0, 0.6, 1]).mode("lrgb");
  const palette = {};
  palette[50] = colors(0.05).hex();
  for (let i4 = 0.1; i4 < 0.9; i4 += 0.1) {
    palette[Math.round(i4 * 1e3)] = colors(i4).hex();
  }
  palette[950] = colors(0.95).hex();
  return palette;
};
var overridePrimitiveColors_default = overridePrimitiveColors;

// ../../../node_modules/.pnpm/@eliaspourquoi+sqlite-node-wasm@3.46.0-build2/node_modules/@eliaspourquoi/sqlite-node-wasm/sqlite-wasm/jswasm/sqlite3-bundler-friendly.mjs
var sqlite3InitModule = (() => {
  var _scriptDir = import.meta.url;
  return function(config2) {
    var sqlite3InitModule2 = config2 || {};
    var Module = typeof sqlite3InitModule2 != "undefined" ? sqlite3InitModule2 : {};
    var readyPromiseResolve, readyPromiseReject;
    Module["ready"] = new Promise(function(resolve, reject) {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    const sqlite3InitModuleState = globalThis.sqlite3InitModuleState || Object.assign(/* @__PURE__ */ Object.create(null), {
      debugModule: () => {
      }
    });
    delete globalThis.sqlite3InitModuleState;
    sqlite3InitModuleState.debugModule(
      "globalThis.location =",
      globalThis.location
    );
    const xNameOfInstantiateWasm = false ? "instantiateWasm" : "emscripten-bug-17951";
    Module[xNameOfInstantiateWasm] = function callee2(imports, onSuccess) {
      imports.env.foo = function() {
      };
      const uri = Module.locateFile(
        callee2.uri,
        "undefined" === typeof scriptDirectory ? "" : scriptDirectory
      );
      sqlite3InitModuleState.debugModule("instantiateWasm() uri =", uri);
      const wfetch = () => fetch(uri, { credentials: "same-origin" });
      const loadWasm = WebAssembly.instantiateStreaming ? async () => {
        return WebAssembly.instantiateStreaming(wfetch(), imports).then(
          (arg) => onSuccess(arg.instance, arg.module)
        );
      } : async () => {
        return wfetch().then((response) => response.arrayBuffer()).then((bytes) => WebAssembly.instantiate(bytes, imports)).then((arg) => onSuccess(arg.instance, arg.module));
      };
      loadWasm();
      return {};
    };
    Module[xNameOfInstantiateWasm].uri = "sqlite3.wasm";
    var moduleOverrides = Object.assign({}, Module);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
    var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
    var scriptDirectory = "";
    function locateFile(path2) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path2, scriptDirectory);
      }
      return scriptDirectory + path2;
    }
    var read_, readAsync, readBinary, setWindowTitle;
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }
      if (scriptDirectory.indexOf("blob:") !== 0) {
        scriptDirectory = scriptDirectory.substr(
          0,
          scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
        );
      } else {
        scriptDirectory = "";
      }
      {
        read_ = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.send(null);
          return xhr.responseText;
        };
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }
        readAsync = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = () => {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }
      setWindowTitle = (title) => document.title = title;
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.warn.bind(console);
    Object.assign(Module, moduleOverrides);
    moduleOverrides = null;
    if (Module["arguments"])
      arguments_ = Module["arguments"];
    if (Module["thisProgram"])
      thisProgram = Module["thisProgram"];
    if (Module["quit"])
      quit_ = Module["quit"];
    var STACK_ALIGN = 16;
    var POINTER_SIZE = 4;
    function getNativeTypeSize(type) {
      switch (type) {
        case "i1":
        case "i8":
        case "u8":
          return 1;
        case "i16":
        case "u16":
          return 2;
        case "i32":
        case "u32":
          return 4;
        case "i64":
        case "u64":
          return 8;
        case "float":
          return 4;
        case "double":
          return 8;
        default: {
          if (type[type.length - 1] === "*") {
            return POINTER_SIZE;
          }
          if (type[0] === "i") {
            const bits = Number(type.substr(1));
            assert(
              bits % 8 === 0,
              "getNativeTypeSize invalid bits " + bits + ", type " + type
            );
            return bits / 8;
          }
          return 0;
        }
      }
    }
    var wasmBinary2;
    if (Module["wasmBinary"])
      wasmBinary2 = Module["wasmBinary"];
    var noExitRuntime = Module["noExitRuntime"] || true;
    if (typeof WebAssembly != "object") {
      abort("no native wasm support detected");
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u22 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u22;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u22 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(
            55296 | ch >> 10,
            56320 | ch & 1023
          );
        }
      }
      return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }
    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i4 = 0; i4 < str.length; ++i4) {
        var u3 = str.charCodeAt(i4);
        if (u3 >= 55296 && u3 <= 57343) {
          var u1 = str.charCodeAt(++i4);
          u3 = 65536 + ((u3 & 1023) << 10) | u1 & 1023;
        }
        if (u3 <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u3;
        } else if (u3 <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u3 >> 6;
          heap[outIdx++] = 128 | u3 & 63;
        } else if (u3 <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u3 >> 12;
          heap[outIdx++] = 128 | u3 >> 6 & 63;
          heap[outIdx++] = 128 | u3 & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          heap[outIdx++] = 240 | u3 >> 18;
          heap[outIdx++] = 128 | u3 >> 12 & 63;
          heap[outIdx++] = 128 | u3 >> 6 & 63;
          heap[outIdx++] = 128 | u3 & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i4 = 0; i4 < str.length; ++i4) {
        var c5 = str.charCodeAt(i4);
        if (c5 <= 127) {
          len++;
        } else if (c5 <= 2047) {
          len += 2;
        } else if (c5 >= 55296 && c5 <= 57343) {
          len += 4;
          ++i4;
        } else {
          len += 3;
        }
      }
      return len;
    }
    var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    function updateMemoryViews() {
      var b5 = wasmMemory.buffer;
      Module["HEAP8"] = HEAP8 = new Int8Array(b5);
      Module["HEAP16"] = HEAP16 = new Int16Array(b5);
      Module["HEAP32"] = HEAP32 = new Int32Array(b5);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b5);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b5);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b5);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(b5);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(b5);
      Module["HEAP64"] = HEAP64 = new BigInt64Array(b5);
      Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b5);
    }
    var STACK_SIZE = 524288;
    var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
    if (Module["wasmMemory"]) {
      wasmMemory = Module["wasmMemory"];
    } else {
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_MEMORY / 65536,
        maximum: 2147483648 / 65536
      });
    }
    updateMemoryViews();
    INITIAL_MEMORY = wasmMemory.buffer.byteLength;
    var wasmTable;
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATEXIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function keepRuntimeAlive() {
      return noExitRuntime;
    }
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function")
          Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      if (!Module["noFSInit"] && !FS.init.initialized)
        FS.init();
      FS.ignorePermissions = false;
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function")
          Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnExit(cb) {
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    function addRunDependency(id) {
      runDependencies++;
      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
    }
    function removeRunDependency(id) {
      runDependencies--;
      if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      if (Module["onAbort"]) {
        Module["onAbort"](what);
      }
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      what += ". Build with -sASSERTIONS for more info.";
      var e6 = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e6);
      throw e6;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }
    function isFileURI(filename) {
      return filename.startsWith("file://");
    }
    var wasmBinaryFile;
    if (Module["locateFile"]) {
      wasmBinaryFile = "sqlite3.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
    } else {
      wasmBinaryFile = new URL("sqlite3.wasm", import.meta.url).href;
    }
    function getBinary(file) {
      try {
        if (file == wasmBinaryFile && wasmBinary2) {
          return new Uint8Array(wasmBinary2);
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw "both async and sync fetching of the wasm failed";
      } catch (err2) {
        abort(err2);
      }
    }
    function getBinaryPromise() {
      if (!wasmBinary2 && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
        if (typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(function() {
            return getBinary(wasmBinaryFile);
          });
        }
      }
      return Promise.resolve().then(function() {
        return getBinary(wasmBinaryFile);
      });
    }
    function createWasm() {
      var info = {
        env: asmLibraryArg,
        wasi_snapshot_preview1: asmLibraryArg
      };
      function receiveInstance(instance, module) {
        var exports2 = instance.exports;
        Module["asm"] = exports2;
        wasmTable = Module["asm"]["__indirect_function_table"];
        addOnInit(Module["asm"]["__wasm_call_ctors"]);
        removeRunDependency("wasm-instantiate");
      }
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"]);
      }
      function instantiateArrayBuffer(receiver) {
        return getBinaryPromise().then(function(binary) {
          return WebAssembly.instantiate(binary, info);
        }).then(function(instance) {
          return instance;
        }).then(receiver, function(reason) {
          err("failed to asynchronously prepare wasm: " + reason);
          abort(reason);
        });
      }
      function instantiateAsync() {
        if (!wasmBinary2 && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(
            function(response) {
              var result = WebAssembly.instantiateStreaming(response, info);
              return result.then(receiveInstantiationResult, function(reason) {
                err("wasm streaming compile failed: " + reason);
                err("falling back to ArrayBuffer instantiation");
                return instantiateArrayBuffer(receiveInstantiationResult);
              });
            }
          );
        } else {
          return instantiateArrayBuffer(receiveInstantiationResult);
        }
      }
      if (Module["instantiateWasm"]) {
        try {
          var exports = Module["instantiateWasm"](info, receiveInstance);
          return exports;
        } catch (e6) {
          err("Module.instantiateWasm callback failed with error: " + e6);
          readyPromiseReject(e6);
        }
      }
      instantiateAsync().catch(readyPromiseReject);
      return {};
    }
    var tempDouble;
    var tempI64;
    var ASM_CONSTS = {};
    function ExitStatus(status) {
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    }
    function getValue(ptr, type = "i8") {
      if (type.endsWith("*"))
        type = "*";
      switch (type) {
        case "i1":
          return HEAP8[ptr >> 0];
        case "i8":
          return HEAP8[ptr >> 0];
        case "i16":
          return HEAP16[ptr >> 1];
        case "i32":
          return HEAP32[ptr >> 2];
        case "i64":
          return HEAP64[ptr >> 3];
        case "float":
          return HEAPF32[ptr >> 2];
        case "double":
          return HEAPF64[ptr >> 3];
        case "*":
          return HEAPU32[ptr >> 2];
        default:
          abort("invalid type for getValue: " + type);
      }
      return null;
    }
    function setValue(ptr, value, type = "i8") {
      if (type.endsWith("*"))
        type = "*";
      switch (type) {
        case "i1":
          HEAP8[ptr >> 0] = value;
          break;
        case "i8":
          HEAP8[ptr >> 0] = value;
          break;
        case "i16":
          HEAP16[ptr >> 1] = value;
          break;
        case "i32":
          HEAP32[ptr >> 2] = value;
          break;
        case "i64":
          tempI64 = [
            value >>> 0,
            (tempDouble = value, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
              +Math.floor(tempDouble / 4294967296),
              4294967295
            ) | 0) >>> 0 : ~~+Math.ceil(
              (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
            ) >>> 0 : 0)
          ], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
          break;
        case "float":
          HEAPF32[ptr >> 2] = value;
          break;
        case "double":
          HEAPF64[ptr >> 3] = value;
          break;
        case "*":
          HEAPU32[ptr >> 2] = value;
          break;
        default:
          abort("invalid type for setValue: " + type);
      }
    }
    var PATH = {
      isAbs: (path2) => path2.charAt(0) === "/",
      splitPath: (filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
      normalizeArray: (parts, allowAboveRoot) => {
        var up = 0;
        for (var i4 = parts.length - 1; i4 >= 0; i4--) {
          var last = parts[i4];
          if (last === ".") {
            parts.splice(i4, 1);
          } else if (last === "..") {
            parts.splice(i4, 1);
            up++;
          } else if (up) {
            parts.splice(i4, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      },
      normalize: (path2) => {
        var isAbsolute = PATH.isAbs(path2), trailingSlash = path2.substr(-1) === "/";
        path2 = PATH.normalizeArray(
          path2.split("/").filter((p5) => !!p5),
          !isAbsolute
        ).join("/");
        if (!path2 && !isAbsolute) {
          path2 = ".";
        }
        if (path2 && trailingSlash) {
          path2 += "/";
        }
        return (isAbsolute ? "/" : "") + path2;
      },
      dirname: (path2) => {
        var result = PATH.splitPath(path2), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
      basename: (path2) => {
        if (path2 === "/")
          return "/";
        path2 = PATH.normalize(path2);
        path2 = path2.replace(/\/$/, "");
        var lastSlash = path2.lastIndexOf("/");
        if (lastSlash === -1)
          return path2;
        return path2.substr(lastSlash + 1);
      },
      join: function() {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join("/"));
      },
      join2: (l3, r6) => {
        return PATH.normalize(l3 + "/" + r6);
      }
    };
    function getRandomDevice() {
      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
        var randomBuffer = new Uint8Array(1);
        return () => {
          crypto.getRandomValues(randomBuffer);
          return randomBuffer[0];
        };
      } else
        return () => abort("randomDevice");
    }
    var PATH_FS = {
      resolve: function() {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i4 = arguments.length - 1; i4 >= -1 && !resolvedAbsolute; i4--) {
          var path2 = i4 >= 0 ? arguments[i4] : FS.cwd();
          if (typeof path2 != "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path2) {
            return "";
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path2);
        }
        resolvedPath = PATH.normalizeArray(
          resolvedPath.split("/").filter((p5) => !!p5),
          !resolvedAbsolute
        ).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      },
      relative: (from, to2) => {
        from = PATH_FS.resolve(from).substr(1);
        to2 = PATH_FS.resolve(to2).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== "")
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== "")
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split("/"));
        var toParts = trim(to2.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i4 = 0; i4 < length; i4++) {
          if (fromParts[i4] !== toParts[i4]) {
            samePartsLength = i4;
            break;
          }
        }
        var outputParts = [];
        for (var i4 = samePartsLength; i4 < fromParts.length; i4++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      }
    };
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(
        stringy,
        u8array,
        0,
        u8array.length
      );
      if (dontAddNull)
        u8array.length = numBytesWritten;
      return u8array;
    }
    var TTY = {
      ttys: [],
      init: function() {
      },
      shutdown: function() {
      },
      register: function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
        close: function(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        fsync: function(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
        read: function(stream, buffer, offset3, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i4 = 0; i4 < length; i4++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e6) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer[offset3 + i4] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
        write: function(stream, buffer, offset3, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i4 = 0; i4 < length; i4++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset3 + i4]);
            }
          } catch (e6) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i4;
        }
      },
      default_tty_ops: {
        get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },
        put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        },
        fsync: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      },
      default_tty1_ops: {
        put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        },
        fsync: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }
      }
    };
    function zeroMemory(address, size3) {
      HEAPU8.fill(0, address, address + size3);
      return address;
    }
    function alignMemory(size3, alignment) {
      return Math.ceil(size3 / alignment) * alignment;
    }
    function mmapAlloc(size3) {
      size3 = alignMemory(size3, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size3);
      if (!ptr)
        return 0;
      return zeroMemory(ptr, size3);
    }
    var MEMFS = {
      ops_table: null,
      mount: function(mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0);
      },
      createNode: function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
      getFileDataAsTypedArray: function(node) {
        if (!node.contents)
          return new Uint8Array(0);
        if (node.contents.subarray)
          return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      },
      expandFileStorage: function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity)
          return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(
          newCapacity,
          prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0
        );
        if (prevCapacity != 0)
          newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0)
          node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      },
      resizeFileStorage: function(node, newSize) {
        if (node.usedBytes == newSize)
          return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(
              oldContents.subarray(0, Math.min(newSize, node.usedBytes))
            );
          }
          node.usedBytes = newSize;
        }
      },
      node_ops: {
        getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
        setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup: function(parent, name) {
          throw FS.genericErrors[44];
        },
        mknod: function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
        rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e6) {
            }
            if (new_node) {
              for (var i4 in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },
        unlink: function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        rmdir: function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i4 in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
        readdir: function(node) {
          var entries = [".", ".."];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },
        symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        },
        readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }
      },
      stream_ops: {
        read: function(stream, buffer, offset3, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size3 = Math.min(stream.node.usedBytes - position, length);
          if (size3 > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size3), offset3);
          } else {
            for (var i4 = 0; i4 < size3; i4++)
              buffer[offset3 + i4] = contents[position + i4];
          }
          return size3;
        },
        write: function(stream, buffer, offset3, length, position, canOwn) {
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset3, offset3 + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer.slice(offset3, offset3 + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(
                buffer.subarray(offset3, offset3 + length),
                position
              );
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray) {
            node.contents.set(
              buffer.subarray(offset3, offset3 + length),
              position
            );
          } else {
            for (var i4 = 0; i4 < length; i4++) {
              node.contents[position + i4] = buffer[offset3 + i4];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
        llseek: function(stream, offset3, whence) {
          var position = offset3;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
        allocate: function(stream, offset3, length) {
          MEMFS.expandFileStorage(stream.node, offset3 + length);
          stream.node.usedBytes = Math.max(
            stream.node.usedBytes,
            offset3 + length
          );
        },
        mmap: function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(
                  contents,
                  position,
                  position + length
                );
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr, allocated };
        },
        msync: function(stream, buffer, offset3, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset3, false);
          return 0;
        }
      }
    };
    function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
      readAsync(
        url,
        (arrayBuffer) => {
          assert(
            arrayBuffer,
            'Loading data file "' + url + '" failed (no arrayBuffer).'
          );
          onload(new Uint8Array(arrayBuffer));
          if (dep)
            removeRunDependency(dep);
        },
        (event) => {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        }
      );
      if (dep)
        addRunDependency(dep);
    }
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: "/",
      initialized: false,
      ignorePermissions: true,
      ErrnoError: null,
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      lookupPath: (path2, opts = {}) => {
        path2 = PATH_FS.resolve(path2);
        if (!path2)
          return { path: "", node: null };
        var defaults2 = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults2, opts);
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts = path2.split("/").filter((p5) => !!p5);
        var current = FS.root;
        var current_path = "/";
        for (var i4 = 0; i4 < parts.length; i4++) {
          var islast = i4 === parts.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts[i4]);
          current_path = PATH.join2(current_path, parts[i4]);
          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, {
                recurse_count: opts.recurse_count + 1
              });
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return { path: current_path, node: current };
      },
      getPath: (node) => {
        var path2;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path2)
              return mount;
            return mount[mount.length - 1] !== "/" ? mount + "/" + path2 : mount + path2;
          }
          path2 = path2 ? node.name + "/" + path2 : node.name;
          node = node.parent;
        }
      },
      hashName: (parentid, name) => {
        var hash = 0;
        for (var i4 = 0; i4 < name.length; i4++) {
          hash = (hash << 5) - hash + name.charCodeAt(i4) | 0;
        }
        return (parentid + hash >>> 0) % FS.nameTable.length;
      },
      hashAddNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode: (node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
      lookupNode: (parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        return FS.lookup(parent, name);
      },
      createNode: (parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node;
      },
      destroyNode: (node) => {
        FS.hashRemoveNode(node);
      },
      isRoot: (node) => {
        return node === node.parent;
      },
      isMountpoint: (node) => {
        return !!node.mounted;
      },
      isFile: (mode) => {
        return (mode & 61440) === 32768;
      },
      isDir: (mode) => {
        return (mode & 61440) === 16384;
      },
      isLink: (mode) => {
        return (mode & 61440) === 40960;
      },
      isChrdev: (mode) => {
        return (mode & 61440) === 8192;
      },
      isBlkdev: (mode) => {
        return (mode & 61440) === 24576;
      },
      isFIFO: (mode) => {
        return (mode & 61440) === 4096;
      },
      isSocket: (mode) => {
        return (mode & 49152) === 49152;
      },
      flagModes: { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 },
      modeStringToFlags: (str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == "undefined") {
          throw new Error("Unknown file open mode: " + str);
        }
        return flags;
      },
      flagsToPermissionString: (flag) => {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
          perms += "w";
        }
        return perms;
      },
      nodePermissions: (node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.includes("r") && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes("w") && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes("x") && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
      mayLookup: (dir) => {
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode)
          return errCode;
        if (!dir.node_ops.lookup)
          return 2;
        return 0;
      },
      mayCreate: (dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e6) {
        }
        return FS.nodePermissions(dir, "wx");
      },
      mayDelete: (dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e6) {
          return e6.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
      mayOpen: (node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
      MAX_OPEN_FDS: 4096,
      nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
      getStream: (fd) => FS.streams[fd],
      createStream: (stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = function() {
            this.shared = {};
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() {
                return this.node;
              },
              set: function(val) {
                this.node = val;
              }
            },
            isRead: {
              get: function() {
                return (this.flags & 2097155) !== 1;
              }
            },
            isWrite: {
              get: function() {
                return (this.flags & 2097155) !== 0;
              }
            },
            isAppend: {
              get: function() {
                return this.flags & 1024;
              }
            },
            flags: {
              get: function() {
                return this.shared.flags;
              },
              set: function(val) {
                this.shared.flags = val;
              }
            },
            position: {
              get: function() {
                return this.shared.position;
              },
              set: function(val) {
                this.shared.position = val;
              }
            }
          });
        }
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
      closeStream: (fd) => {
        FS.streams[fd] = null;
      },
      chrdev_stream_ops: {
        open: (stream) => {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },
        llseek: () => {
          throw new FS.ErrnoError(70);
        }
      },
      major: (dev) => dev >> 8,
      minor: (dev) => dev & 255,
      makedev: (ma, mi2) => ma << 8 | mi2,
      registerDevice: (dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: (dev) => FS.devices[dev],
      getMounts: (mount) => {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m7 = check.pop();
          mounts.push(m7);
          check.push.apply(check, m7.mounts);
        }
        return mounts;
      },
      syncfs: (populate, callback) => {
        if (typeof populate == "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err(
            "warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work"
          );
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount: (type, opts, mountpoint) => {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      },
      unmount: (mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
      lookup: (parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },
      mknod: (path2, mode, dev) => {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path2);
        if (!name || name === "." || name === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
      create: (path2, mode) => {
        mode = mode !== void 0 ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path2, mode, 0);
      },
      mkdir: (path2, mode) => {
        mode = mode !== void 0 ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path2, mode, 0);
      },
      mkdirTree: (path2, mode) => {
        var dirs = path2.split("/");
        var d4 = "";
        for (var i4 = 0; i4 < dirs.length; ++i4) {
          if (!dirs[i4])
            continue;
          d4 += "/" + dirs[i4];
          try {
            FS.mkdir(d4, mode);
          } catch (e6) {
            if (e6.errno != 20)
              throw e6;
          }
        }
      },
      mkdev: (path2, mode, dev) => {
        if (typeof dev == "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path2, mode, dev);
      },
      symlink: (oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
      rename: (old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
        if (!old_dir || !new_dir)
          throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e6) {
        }
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e6) {
          throw e6;
        } finally {
          FS.hashAddNode(old_node);
        }
      },
      rmdir: (path2) => {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path2);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
      readdir: (path2) => {
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
      unlink: (path2) => {
        var lookup = FS.lookupPath(path2, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path2);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
      readlink: (path2) => {
        var lookup = FS.lookupPath(path2);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(
          FS.getPath(link.parent),
          link.node_ops.readlink(link)
        );
      },
      stat: (path2, dontFollow) => {
        var lookup = FS.lookupPath(path2, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
      lstat: (path2) => {
        return FS.stat(path2, true);
      },
      chmod: (path2, mode, dontFollow) => {
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: mode & 4095 | node.mode & ~4095,
          timestamp: Date.now()
        });
      },
      lchmod: (path2, mode) => {
        FS.chmod(path2, mode, true);
      },
      fchmod: (fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },
      chown: (path2, uid, gid, dontFollow) => {
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
        });
      },
      lchown: (path2, uid, gid) => {
        FS.chown(path2, uid, gid, true);
      },
      fchown: (fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },
      truncate: (path2, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path2 == "string") {
          var lookup = FS.lookupPath(path2, { follow: true });
          node = lookup.node;
        } else {
          node = path2;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
      ftruncate: (fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
      utime: (path2, atime, mtime) => {
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },
      open: (path2, flags, mode) => {
        if (path2 === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == "string" ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == "undefined" ? 438 : mode;
        if (flags & 64) {
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path2 == "object") {
          node = path2;
        } else {
          path2 = PATH.normalize(path2);
          try {
            var lookup = FS.lookupPath(path2, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e6) {
          }
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path2, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags & 512 && !created) {
          FS.truncate(node, 0);
        }
        flags &= ~(128 | 512 | 131072);
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          ungotten: [],
          error: false
        });
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module["logReadFiles"] && !(flags & 1)) {
          if (!FS.readFiles)
            FS.readFiles = {};
          if (!(path2 in FS.readFiles)) {
            FS.readFiles[path2] = 1;
          }
        }
        return stream;
      },
      close: (stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents)
          stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e6) {
          throw e6;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed: (stream) => {
        return stream.fd === null;
      },
      llseek: (stream, offset3, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset3, whence);
        stream.ungotten = [];
        return stream.position;
      },
      read: (stream, buffer, offset3, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(
          stream,
          buffer,
          offset3,
          length,
          position
        );
        if (!seeking)
          stream.position += bytesRead;
        return bytesRead;
      },
      write: (stream, buffer, offset3, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(
          stream,
          buffer,
          offset3,
          length,
          position,
          canOwn
        );
        if (!seeking)
          stream.position += bytesWritten;
        return bytesWritten;
      },
      allocate: (stream, offset3, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset3 < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset3, length);
      },
      mmap: (stream, length, position, prot, flags) => {
        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
      msync: (stream, buffer, offset3, length, mmapFlags) => {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(
          stream,
          buffer,
          offset3,
          length,
          mmapFlags
        );
      },
      munmap: (stream) => 0,
      ioctl: (stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
      readFile: (path2, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path2, opts.flags);
        var stat = FS.stat(path2);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
      writeFile: (path2, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path2, opts.flags, opts.mode);
        if (typeof data == "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream);
      },
      cwd: () => FS.currentPath,
      chdir: (path2) => {
        var lookup = FS.lookupPath(path2, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories: () => {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      },
      createDefaultDevices: () => {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset3, length, pos) => length
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var random_device = getRandomDevice();
        FS.createDevice("/dev", "random", random_device);
        FS.createDevice("/dev", "urandom", random_device);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      },
      createSpecialDirectories: () => {
        FS.mkdir("/proc");
        var proc_self = FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount(
          {
            mount: () => {
              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
              node.node_ops = {
                lookup: (parent, name) => {
                  var fd = +name;
                  var stream = FS.getStream(fd);
                  if (!stream)
                    throw new FS.ErrnoError(8);
                  var ret = {
                    parent: null,
                    mount: { mountpoint: "fake" },
                    node_ops: { readlink: () => stream.path }
                  };
                  ret.parent = ret;
                  return ret;
                }
              };
              return node;
            }
          },
          {},
          "/proc/self/fd"
        );
      },
      createStandardStreams: () => {
        if (Module["stdin"]) {
          FS.createDevice("/dev", "stdin", Module["stdin"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (Module["stdout"]) {
          FS.createDevice("/dev", "stdout", null, Module["stdout"]);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (Module["stderr"]) {
          FS.createDevice("/dev", "stderr", null, Module["stderr"]);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        var stdin = FS.open("/dev/stdin", 0);
        var stdout = FS.open("/dev/stdout", 1);
        var stderr = FS.open("/dev/stderr", 1);
      },
      ensureErrnoError: () => {
        if (FS.ErrnoError)
          return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function(errno2) {
            this.errno = errno2;
          };
          this.setErrno(errno);
          this.message = "FS error";
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = "<generic error, no stack>";
        });
      },
      staticInit: () => {
        FS.ensureErrnoError();
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {
          MEMFS
        };
      },
      init: (input, output, error) => {
        FS.init.initialized = true;
        FS.ensureErrnoError();
        Module["stdin"] = input || Module["stdin"];
        Module["stdout"] = output || Module["stdout"];
        Module["stderr"] = error || Module["stderr"];
        FS.createStandardStreams();
      },
      quit: () => {
        FS.init.initialized = false;
        for (var i4 = 0; i4 < FS.streams.length; i4++) {
          var stream = FS.streams[i4];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
      getMode: (canRead, canWrite) => {
        var mode = 0;
        if (canRead)
          mode |= 292 | 73;
        if (canWrite)
          mode |= 146;
        return mode;
      },
      findObject: (path2, dontResolveLastLink) => {
        var ret = FS.analyzePath(path2, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
      analyzePath: (path2, dontResolveLastLink) => {
        try {
          var lookup = FS.lookupPath(path2, { follow: !dontResolveLastLink });
          path2 = lookup.path;
        } catch (e6) {
        }
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path2, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path2);
          lookup = FS.lookupPath(path2, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e6) {
          ret.error = e6.errno;
        }
        return ret;
      },
      createPath: (parent, path2, canRead, canWrite) => {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        var parts = path2.split("/").reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part)
            continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e6) {
          }
          parent = current;
        }
        return current;
      },
      createFile: (parent, name, properties, canRead, canWrite) => {
        var path2 = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path2, mode);
      },
      createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
        var path2 = name;
        if (parent) {
          parent = typeof parent == "string" ? parent : FS.getPath(parent);
          path2 = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path2, mode);
        if (data) {
          if (typeof data == "string") {
            var arr = new Array(data.length);
            for (var i4 = 0, len = data.length; i4 < len; ++i4)
              arr[i4] = data.charCodeAt(i4);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },
      createDevice: (parent, name, input, output) => {
        var path2 = PATH.join2(
          typeof parent == "string" ? parent : FS.getPath(parent),
          name
        );
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major)
          FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset3, length, pos) => {
            var bytesRead = 0;
            for (var i4 = 0; i4 < length; i4++) {
              var result;
              try {
                result = input();
              } catch (e6) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer[offset3 + i4] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset3, length, pos) => {
            for (var i4 = 0; i4 < length; i4++) {
              try {
                output(buffer[offset3 + i4]);
              } catch (e6) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i4;
          }
        });
        return FS.mkdev(path2, mode, dev);
      },
      forceLoadFile: (obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
          return true;
        if (typeof XMLHttpRequest != "undefined") {
          throw new Error(
            "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
          );
        } else if (read_) {
          try {
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e6) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error("Cannot load without read() or XMLHttpRequest.");
        }
      },
      createLazyFile: (parent, name, url, canRead, canWrite) => {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
            throw new Error(
              "Couldn't load " + url + ". Status: " + xhr.status
            );
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing)
            chunkSize = datalength;
          var doXHR = (from, to2) => {
            if (from > to2)
              throw new Error(
                "invalid range (" + from + ", " + to2 + ") or no bytes requested!"
              );
            if (to2 > datalength - 1)
              throw new Error(
                "only " + datalength + " bytes available! programmer error!"
              );
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url, false);
            if (datalength !== chunkSize)
              xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to2);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
              throw new Error(
                "Couldn't load " + url + ". Status: " + xhr2.status
              );
            if (xhr2.response !== void 0) {
              return new Uint8Array(xhr2.response || []);
            }
            return intArrayFromString(xhr2.responseText || "", true);
          };
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined")
              throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out(
              "LazyFiles on gzip forces download of the whole file when length is accessed"
            );
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != "undefined") {
          if (!ENVIRONMENT_IS_WORKER)
            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url };
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {
          usedBytes: {
            get: function() {
              return this.contents.length;
            }
          }
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn2 = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn2.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset3, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size3 = Math.min(contents.length - position, length);
          if (contents.slice) {
            for (var i4 = 0; i4 < size3; i4++) {
              buffer[offset3 + i4] = contents[position + i4];
            }
          } else {
            for (var i4 = 0; i4 < size3; i4++) {
              buffer[offset3 + i4] = contents.get(position + i4);
            }
          }
          return size3;
        }
        stream_ops.read = (stream, buffer, offset3, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset3, length, position);
        };
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
      createPreloadedFile: (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency("cp " + fullname);
        function processData(byteArray) {
          function finish(byteArray2) {
            if (preFinish)
              preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(
                parent,
                name,
                byteArray2,
                canRead,
                canWrite,
                canOwn
              );
            }
            if (onload)
              onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror)
              onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == "string") {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },
      indexedDB: () => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },
      DB_NAME: () => {
        return "EM_FS_" + window.location.pathname;
      },
      DB_VERSION: 20,
      DB_STORE_NAME: "FILE_DATA",
      saveFilesToDB: (paths, onload, onerror) => {
        onload = onload || (() => {
        });
        onerror = onerror || (() => {
        });
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e6) {
          return onerror(e6);
        }
        openRequest.onupgradeneeded = () => {
          out("creating db");
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0)
              onload();
            else
              onerror();
          }
          paths.forEach((path2) => {
            var putRequest = files.put(
              FS.analyzePath(path2).object.contents,
              path2
            );
            putRequest.onsuccess = () => {
              ok++;
              if (ok + fail == total)
                finish();
            };
            putRequest.onerror = () => {
              fail++;
              if (ok + fail == total)
                finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
      loadFilesFromDB: (paths, onload, onerror) => {
        onload = onload || (() => {
        });
        onerror = onerror || (() => {
        });
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e6) {
          return onerror(e6);
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
          } catch (e6) {
            onerror(e6);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0)
              onload();
            else
              onerror();
          }
          paths.forEach((path2) => {
            var getRequest = files.get(path2);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path2).exists) {
                FS.unlink(path2);
              }
              FS.createDataFile(
                PATH.dirname(path2),
                PATH.basename(path2),
                getRequest.result,
                true,
                true,
                true
              );
              ok++;
              if (ok + fail == total)
                finish();
            };
            getRequest.onerror = () => {
              fail++;
              if (ok + fail == total)
                finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      calculateAt: function(dirfd, path2, allowEmpty) {
        if (PATH.isAbs(path2)) {
          return path2;
        }
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path2.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
          }
          return dir;
        }
        return PATH.join2(dir, path2);
      },
      doStat: function(func, path2, buf) {
        try {
          var stat = func(path2);
        } catch (e6) {
          if (e6 && e6.node && PATH.normalize(path2) !== PATH.normalize(FS.getPath(e6.node))) {
            return -54;
          }
          throw e6;
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 8 >> 2] = stat.ino;
        HEAP32[buf + 12 >> 2] = stat.mode;
        HEAPU32[buf + 16 >> 2] = stat.nlink;
        HEAP32[buf + 20 >> 2] = stat.uid;
        HEAP32[buf + 24 >> 2] = stat.gid;
        HEAP32[buf + 28 >> 2] = stat.rdev;
        tempI64 = [
          stat.size >>> 0,
          (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
        HEAP32[buf + 48 >> 2] = 4096;
        HEAP32[buf + 52 >> 2] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        tempI64 = [
          Math.floor(atime / 1e3) >>> 0,
          (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
        HEAPU32[buf + 64 >> 2] = atime % 1e3 * 1e3;
        tempI64 = [
          Math.floor(mtime / 1e3) >>> 0,
          (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
        HEAPU32[buf + 80 >> 2] = mtime % 1e3 * 1e3;
        tempI64 = [
          Math.floor(ctime / 1e3) >>> 0,
          (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
        HEAPU32[buf + 96 >> 2] = ctime % 1e3 * 1e3;
        tempI64 = [
          stat.ino >>> 0,
          (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[buf + 104 >> 2] = tempI64[0], HEAP32[buf + 108 >> 2] = tempI64[1];
        return 0;
      },
      doMsync: function(addr, stream, len, flags, offset3) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset3, len, flags);
      },
      varargs: void 0,
      get: function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret;
      },
      getStr: function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
      getStreamFromFD: function(fd) {
        var stream = FS.getStream(fd);
        if (!stream)
          throw new FS.ErrnoError(8);
        return stream;
      }
    };
    function ___syscall_chmod(path2, mode) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.chmod(path2, mode);
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_faccessat(dirfd, path2, amode, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (amode & ~7) {
          return -28;
        }
        var lookup = FS.lookupPath(path2, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = "";
        if (amode & 4)
          perms += "r";
        if (amode & 2)
          perms += "w";
        if (amode & 1)
          perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_fchmod(fd, mode) {
      try {
        FS.fchmod(fd, mode);
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_fchown32(fd, owner, group) {
      try {
        FS.fchown(fd, owner, group);
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function setErrNo(value) {
      HEAP32[___errno_location() >> 2] = value;
      return value;
    }
    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = SYSCALLS.get();
            if (arg < 0) {
              return -28;
            }
            var newStream;
            newStream = FS.createStream(stream, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream.flags;
          case 4: {
            var arg = SYSCALLS.get();
            stream.flags |= arg;
            return 0;
          }
          case 5: {
            var arg = SYSCALLS.get();
            var offset3 = 0;
            HEAP16[arg + offset3 >> 1] = 2;
            return 0;
          }
          case 6:
          case 7:
            return 0;
          case 16:
          case 8:
            return -28;
          case 9:
            setErrNo(28);
            return -1;
          default: {
            return -28;
          }
        }
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_fstat64(fd, buf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    var MAX_INT53 = 9007199254740992;
    var MIN_INT53 = -9007199254740992;
    function bigintToI53Checked(num2) {
      return num2 < MIN_INT53 || num2 > MAX_INT53 ? NaN : Number(num2);
    }
    function ___syscall_ftruncate64(fd, length) {
      try {
        length = bigintToI53Checked(length);
        if (isNaN(length))
          return -61;
        FS.ftruncate(fd, length);
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_getcwd(buf, size3) {
      try {
        if (size3 === 0)
          return -28;
        var cwd = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
        if (size3 < cwdLengthInBytes)
          return -68;
        stringToUTF8(cwd, buf, size3);
        return cwdLengthInBytes;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_ioctl(fd, op, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        switch (op) {
          case 21509:
          case 21505: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
          case 21506:
          case 21507:
          case 21508: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21519: {
            if (!stream.tty)
              return -59;
            var argp = SYSCALLS.get();
            HEAP32[argp >> 2] = 0;
            return 0;
          }
          case 21520: {
            if (!stream.tty)
              return -59;
            return -28;
          }
          case 21531: {
            var argp = SYSCALLS.get();
            return FS.ioctl(stream, op, argp);
          }
          case 21523: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          case 21524: {
            if (!stream.tty)
              return -59;
            return 0;
          }
          default:
            return -28;
        }
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_lstat64(path2, buf) {
      try {
        path2 = SYSCALLS.getStr(path2);
        return SYSCALLS.doStat(FS.lstat, path2, buf);
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_mkdirat(dirfd, path2, mode) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        path2 = PATH.normalize(path2);
        if (path2[path2.length - 1] === "/")
          path2 = path2.substr(0, path2.length - 1);
        FS.mkdir(path2, mode, 0);
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_newfstatat(dirfd, path2, buf, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        var nofollow = flags & 256;
        var allowEmpty = flags & 4096;
        flags = flags & ~6400;
        path2 = SYSCALLS.calculateAt(dirfd, path2, allowEmpty);
        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path2, buf);
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_openat(dirfd, path2, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        var mode = varargs ? SYSCALLS.get() : 0;
        return FS.open(path2, flags, mode).fd;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_readlinkat(dirfd, path2, buf, bufsize) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (bufsize <= 0)
          return -28;
        var ret = FS.readlink(path2);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_rmdir(path2) {
      try {
        path2 = SYSCALLS.getStr(path2);
        FS.rmdir(path2);
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_stat64(path2, buf) {
      try {
        path2 = SYSCALLS.getStr(path2);
        return SYSCALLS.doStat(FS.stat, path2, buf);
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function ___syscall_unlinkat(dirfd, path2, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2);
        if (flags === 0) {
          FS.unlink(path2);
        } else if (flags === 512) {
          FS.rmdir(path2);
        } else {
          abort("Invalid flags passed to unlinkat");
        }
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function readI53FromI64(ptr) {
      return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
    }
    function ___syscall_utimensat(dirfd, path2, times, flags) {
      try {
        path2 = SYSCALLS.getStr(path2);
        path2 = SYSCALLS.calculateAt(dirfd, path2, true);
        if (!times) {
          var atime = Date.now();
          var mtime = atime;
        } else {
          var seconds = readI53FromI64(times);
          var nanoseconds = HEAP32[times + 8 >> 2];
          atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
          times += 16;
          seconds = readI53FromI64(times);
          nanoseconds = HEAP32[times + 8 >> 2];
          mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
        }
        FS.utime(path2, atime, mtime);
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    var nowIsMonotonic = true;
    function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }
    function __isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var __MONTH_DAYS_LEAP_CUMULATIVE = [
      0,
      31,
      60,
      91,
      121,
      152,
      182,
      213,
      244,
      274,
      305,
      335
    ];
    var __MONTH_DAYS_REGULAR_CUMULATIVE = [
      0,
      31,
      59,
      90,
      120,
      151,
      181,
      212,
      243,
      273,
      304,
      334
    ];
    function __yday_from_date(date) {
      var isLeapYear = __isLeapYear(date.getFullYear());
      var monthDaysCumulative = isLeapYear ? __MONTH_DAYS_LEAP_CUMULATIVE : __MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
      return yday;
    }
    function __localtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time) * 1e3);
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date.getHours();
      HEAP32[tmPtr + 12 >> 2] = date.getDate();
      HEAP32[tmPtr + 16 >> 2] = date.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date.getDay();
      var yday = __yday_from_date(date) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[tmPtr + 32 >> 2] = dst;
    }
    function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var res = FS.mmap(stream, len, off, prot, flags);
        var ptr = res.ptr;
        HEAP32[allocated >> 2] = res.allocated;
        HEAPU32[addr >> 2] = ptr;
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function __munmap_js(addr, len, prot, flags, fd, offset3) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, flags, offset3);
        }
        FS.munmap(stream);
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return -e6.errno;
      }
    }
    function allocateUTF8(str) {
      var size3 = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size3);
      if (ret)
        stringToUTF8Array(str, HEAP8, ret, size3);
      return ret;
    }
    function __tzset_js(timezone, daylight, tzname) {
      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
      function extractZone(date) {
        var match2 = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match2 ? match2[1] : "GMT";
      }
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        HEAPU32[tzname >> 2] = winterNamePtr;
        HEAPU32[tzname + 4 >> 2] = summerNamePtr;
      } else {
        HEAPU32[tzname >> 2] = summerNamePtr;
        HEAPU32[tzname + 4 >> 2] = winterNamePtr;
      }
    }
    function _emscripten_date_now() {
      return Date.now();
    }
    var _emscripten_get_now;
    _emscripten_get_now = () => performance.now();
    function getHeapMax() {
      return 2147483648;
    }
    function emscripten_realloc_buffer(size3) {
      var b5 = wasmMemory.buffer;
      try {
        wasmMemory.grow(size3 - b5.byteLength + 65535 >>> 16);
        updateMemoryViews();
        return 1;
      } catch (e6) {
      }
    }
    function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      let alignUp = (x6, multiple) => x6 + (multiple - x6 % multiple) % multiple;
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(
          overGrownHeapSize,
          requestedSize + 100663296
        );
        var newSize = Math.min(
          maxHeapSize,
          alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)
        );
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }
    var ENV = {};
    function getExecutableName() {
      return thisProgram || "./this.program";
    }
    function getEnvStrings() {
      if (!getEnvStrings.strings) {
        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
        var env = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: lang,
          _: getExecutableName()
        };
        for (var x6 in ENV) {
          if (ENV[x6] === void 0)
            delete env[x6];
          else
            env[x6] = ENV[x6];
        }
        var strings = [];
        for (var x6 in env) {
          strings.push(x6 + "=" + env[x6]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
    function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i4 = 0; i4 < str.length; ++i4) {
        HEAP8[buffer++ >> 0] = str.charCodeAt(i4);
      }
      if (!dontAddNull)
        HEAP8[buffer >> 0] = 0;
    }
    function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i4) {
        var ptr = environ_buf + bufSize;
        HEAPU32[__environ + i4 * 4 >> 2] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }
    function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    }
    function _fd_close(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream);
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return e6.errno;
      }
    }
    function _fd_fdstat_get(fd, pbuf) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
        HEAP8[pbuf >> 0] = type;
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return e6.errno;
      }
    }
    function doReadv(stream, iov, iovcnt, offset3) {
      var ret = 0;
      for (var i4 = 0; i4 < iovcnt; i4++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset3);
        if (curr < 0)
          return -1;
        ret += curr;
        if (curr < len)
          break;
        if (typeof offset3 !== "undefined") {
          offset3 += curr;
        }
      }
      return ret;
    }
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num2 = doReadv(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return e6.errno;
      }
    }
    function _fd_seek(fd, offset3, whence, newOffset) {
      try {
        offset3 = bigintToI53Checked(offset3);
        if (isNaN(offset3))
          return 61;
        var stream = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream, offset3, whence);
        tempI64 = [
          stream.position >>> 0,
          (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(
            +Math.floor(tempDouble / 4294967296),
            4294967295
          ) | 0) >>> 0 : ~~+Math.ceil(
            (tempDouble - +(~~tempDouble >>> 0)) / 4294967296
          ) >>> 0 : 0)
        ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
        if (stream.getdents && offset3 === 0 && whence === 0)
          stream.getdents = null;
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return e6.errno;
      }
    }
    function _fd_sync(fd) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        if (stream.stream_ops && stream.stream_ops.fsync) {
          return stream.stream_ops.fsync(stream);
        }
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return e6.errno;
      }
    }
    function doWritev(stream, iov, iovcnt, offset3) {
      var ret = 0;
      for (var i4 = 0; i4 < iovcnt; i4++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset3);
        if (curr < 0)
          return -1;
        ret += curr;
        if (typeof offset3 !== "undefined") {
          offset3 += curr;
        }
      }
      return ret;
    }
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream = SYSCALLS.getStreamFromFD(fd);
        var num2 = doWritev(stream, iov, iovcnt);
        HEAPU32[pnum >> 2] = num2;
        return 0;
      } catch (e6) {
        if (typeof FS == "undefined" || !(e6 instanceof FS.ErrnoError))
          throw e6;
        return e6.errno;
      }
    }
    var FSNode = function(parent, name, mode, rdev) {
      if (!parent) {
        parent = this;
      }
      this.parent = parent;
      this.mount = parent.mount;
      this.mounted = null;
      this.id = FS.nextInode++;
      this.name = name;
      this.mode = mode;
      this.node_ops = {};
      this.stream_ops = {};
      this.rdev = rdev;
    };
    var readMode = 292 | 73;
    var writeMode = 146;
    Object.defineProperties(FSNode.prototype, {
      read: {
        get: function() {
          return (this.mode & readMode) === readMode;
        },
        set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        }
      },
      write: {
        get: function() {
          return (this.mode & writeMode) === writeMode;
        },
        set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        }
      },
      isFolder: {
        get: function() {
          return FS.isDir(this.mode);
        }
      },
      isDevice: {
        get: function() {
          return FS.isChrdev(this.mode);
        }
      }
    });
    FS.FSNode = FSNode;
    FS.staticInit();
    var ASSERTIONS = false;
    var asmLibraryArg = {
      __syscall_chmod: ___syscall_chmod,
      __syscall_faccessat: ___syscall_faccessat,
      __syscall_fchmod: ___syscall_fchmod,
      __syscall_fchown32: ___syscall_fchown32,
      __syscall_fcntl64: ___syscall_fcntl64,
      __syscall_fstat64: ___syscall_fstat64,
      __syscall_ftruncate64: ___syscall_ftruncate64,
      __syscall_getcwd: ___syscall_getcwd,
      __syscall_ioctl: ___syscall_ioctl,
      __syscall_lstat64: ___syscall_lstat64,
      __syscall_mkdirat: ___syscall_mkdirat,
      __syscall_newfstatat: ___syscall_newfstatat,
      __syscall_openat: ___syscall_openat,
      __syscall_readlinkat: ___syscall_readlinkat,
      __syscall_rmdir: ___syscall_rmdir,
      __syscall_stat64: ___syscall_stat64,
      __syscall_unlinkat: ___syscall_unlinkat,
      __syscall_utimensat: ___syscall_utimensat,
      _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
      _localtime_js: __localtime_js,
      _mmap_js: __mmap_js,
      _munmap_js: __munmap_js,
      _tzset_js: __tzset_js,
      emscripten_date_now: _emscripten_date_now,
      emscripten_get_now: _emscripten_get_now,
      emscripten_resize_heap: _emscripten_resize_heap,
      environ_get: _environ_get,
      environ_sizes_get: _environ_sizes_get,
      fd_close: _fd_close,
      fd_fdstat_get: _fd_fdstat_get,
      fd_read: _fd_read,
      fd_seek: _fd_seek,
      fd_sync: _fd_sync,
      fd_write: _fd_write,
      memory: wasmMemory
    };
    var asm = createWasm();
    var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
      return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
    };
    var _sqlite3_status64 = Module["_sqlite3_status64"] = function() {
      return (_sqlite3_status64 = Module["_sqlite3_status64"] = Module["asm"]["sqlite3_status64"]).apply(null, arguments);
    };
    var _sqlite3_status = Module["_sqlite3_status"] = function() {
      return (_sqlite3_status = Module["_sqlite3_status"] = Module["asm"]["sqlite3_status"]).apply(null, arguments);
    };
    var _sqlite3_db_status = Module["_sqlite3_db_status"] = function() {
      return (_sqlite3_db_status = Module["_sqlite3_db_status"] = Module["asm"]["sqlite3_db_status"]).apply(null, arguments);
    };
    var _sqlite3_msize = Module["_sqlite3_msize"] = function() {
      return (_sqlite3_msize = Module["_sqlite3_msize"] = Module["asm"]["sqlite3_msize"]).apply(null, arguments);
    };
    var _sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = function() {
      return (_sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = Module["asm"]["sqlite3_vfs_find"]).apply(null, arguments);
    };
    var _sqlite3_initialize = Module["_sqlite3_initialize"] = function() {
      return (_sqlite3_initialize = Module["_sqlite3_initialize"] = Module["asm"]["sqlite3_initialize"]).apply(null, arguments);
    };
    var _sqlite3_malloc = Module["_sqlite3_malloc"] = function() {
      return (_sqlite3_malloc = Module["_sqlite3_malloc"] = Module["asm"]["sqlite3_malloc"]).apply(null, arguments);
    };
    var _sqlite3_free = Module["_sqlite3_free"] = function() {
      return (_sqlite3_free = Module["_sqlite3_free"] = Module["asm"]["sqlite3_free"]).apply(null, arguments);
    };
    var _sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = function() {
      return (_sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = Module["asm"]["sqlite3_vfs_register"]).apply(null, arguments);
    };
    var _sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = function() {
      return (_sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = Module["asm"]["sqlite3_vfs_unregister"]).apply(null, arguments);
    };
    var _sqlite3_malloc64 = Module["_sqlite3_malloc64"] = function() {
      return (_sqlite3_malloc64 = Module["_sqlite3_malloc64"] = Module["asm"]["sqlite3_malloc64"]).apply(null, arguments);
    };
    var _sqlite3_realloc = Module["_sqlite3_realloc"] = function() {
      return (_sqlite3_realloc = Module["_sqlite3_realloc"] = Module["asm"]["sqlite3_realloc"]).apply(null, arguments);
    };
    var _sqlite3_realloc64 = Module["_sqlite3_realloc64"] = function() {
      return (_sqlite3_realloc64 = Module["_sqlite3_realloc64"] = Module["asm"]["sqlite3_realloc64"]).apply(null, arguments);
    };
    var _sqlite3_value_text = Module["_sqlite3_value_text"] = function() {
      return (_sqlite3_value_text = Module["_sqlite3_value_text"] = Module["asm"]["sqlite3_value_text"]).apply(null, arguments);
    };
    var _sqlite3_randomness = Module["_sqlite3_randomness"] = function() {
      return (_sqlite3_randomness = Module["_sqlite3_randomness"] = Module["asm"]["sqlite3_randomness"]).apply(null, arguments);
    };
    var _sqlite3_stricmp = Module["_sqlite3_stricmp"] = function() {
      return (_sqlite3_stricmp = Module["_sqlite3_stricmp"] = Module["asm"]["sqlite3_stricmp"]).apply(null, arguments);
    };
    var _sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = function() {
      return (_sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = Module["asm"]["sqlite3_strnicmp"]).apply(null, arguments);
    };
    var _sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = function() {
      return (_sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = Module["asm"]["sqlite3_uri_parameter"]).apply(null, arguments);
    };
    var ___errno_location = Module["___errno_location"] = function() {
      return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
    };
    var _sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = function() {
      return (_sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = Module["asm"]["sqlite3_uri_boolean"]).apply(null, arguments);
    };
    var _sqlite3_serialize = Module["_sqlite3_serialize"] = function() {
      return (_sqlite3_serialize = Module["_sqlite3_serialize"] = Module["asm"]["sqlite3_serialize"]).apply(null, arguments);
    };
    var _sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = function() {
      return (_sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = Module["asm"]["sqlite3_prepare_v2"]).apply(null, arguments);
    };
    var _sqlite3_step = Module["_sqlite3_step"] = function() {
      return (_sqlite3_step = Module["_sqlite3_step"] = Module["asm"]["sqlite3_step"]).apply(null, arguments);
    };
    var _sqlite3_column_int64 = Module["_sqlite3_column_int64"] = function() {
      return (_sqlite3_column_int64 = Module["_sqlite3_column_int64"] = Module["asm"]["sqlite3_column_int64"]).apply(null, arguments);
    };
    var _sqlite3_reset = Module["_sqlite3_reset"] = function() {
      return (_sqlite3_reset = Module["_sqlite3_reset"] = Module["asm"]["sqlite3_reset"]).apply(null, arguments);
    };
    var _sqlite3_exec = Module["_sqlite3_exec"] = function() {
      return (_sqlite3_exec = Module["_sqlite3_exec"] = Module["asm"]["sqlite3_exec"]).apply(null, arguments);
    };
    var _sqlite3_column_int = Module["_sqlite3_column_int"] = function() {
      return (_sqlite3_column_int = Module["_sqlite3_column_int"] = Module["asm"]["sqlite3_column_int"]).apply(null, arguments);
    };
    var _sqlite3_finalize = Module["_sqlite3_finalize"] = function() {
      return (_sqlite3_finalize = Module["_sqlite3_finalize"] = Module["asm"]["sqlite3_finalize"]).apply(null, arguments);
    };
    var _sqlite3_file_control = Module["_sqlite3_file_control"] = function() {
      return (_sqlite3_file_control = Module["_sqlite3_file_control"] = Module["asm"]["sqlite3_file_control"]).apply(null, arguments);
    };
    var _sqlite3_column_name = Module["_sqlite3_column_name"] = function() {
      return (_sqlite3_column_name = Module["_sqlite3_column_name"] = Module["asm"]["sqlite3_column_name"]).apply(null, arguments);
    };
    var _sqlite3_column_text = Module["_sqlite3_column_text"] = function() {
      return (_sqlite3_column_text = Module["_sqlite3_column_text"] = Module["asm"]["sqlite3_column_text"]).apply(null, arguments);
    };
    var _sqlite3_column_type = Module["_sqlite3_column_type"] = function() {
      return (_sqlite3_column_type = Module["_sqlite3_column_type"] = Module["asm"]["sqlite3_column_type"]).apply(null, arguments);
    };
    var _sqlite3_errmsg = Module["_sqlite3_errmsg"] = function() {
      return (_sqlite3_errmsg = Module["_sqlite3_errmsg"] = Module["asm"]["sqlite3_errmsg"]).apply(null, arguments);
    };
    var _sqlite3_deserialize = Module["_sqlite3_deserialize"] = function() {
      return (_sqlite3_deserialize = Module["_sqlite3_deserialize"] = Module["asm"]["sqlite3_deserialize"]).apply(null, arguments);
    };
    var _sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = function() {
      return (_sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = Module["asm"]["sqlite3_clear_bindings"]).apply(null, arguments);
    };
    var _sqlite3_value_blob = Module["_sqlite3_value_blob"] = function() {
      return (_sqlite3_value_blob = Module["_sqlite3_value_blob"] = Module["asm"]["sqlite3_value_blob"]).apply(null, arguments);
    };
    var _sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = function() {
      return (_sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = Module["asm"]["sqlite3_value_bytes"]).apply(null, arguments);
    };
    var _sqlite3_value_double = Module["_sqlite3_value_double"] = function() {
      return (_sqlite3_value_double = Module["_sqlite3_value_double"] = Module["asm"]["sqlite3_value_double"]).apply(null, arguments);
    };
    var _sqlite3_value_int = Module["_sqlite3_value_int"] = function() {
      return (_sqlite3_value_int = Module["_sqlite3_value_int"] = Module["asm"]["sqlite3_value_int"]).apply(null, arguments);
    };
    var _sqlite3_value_int64 = Module["_sqlite3_value_int64"] = function() {
      return (_sqlite3_value_int64 = Module["_sqlite3_value_int64"] = Module["asm"]["sqlite3_value_int64"]).apply(null, arguments);
    };
    var _sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = function() {
      return (_sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = Module["asm"]["sqlite3_value_subtype"]).apply(null, arguments);
    };
    var _sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = function() {
      return (_sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = Module["asm"]["sqlite3_value_pointer"]).apply(null, arguments);
    };
    var _sqlite3_value_type = Module["_sqlite3_value_type"] = function() {
      return (_sqlite3_value_type = Module["_sqlite3_value_type"] = Module["asm"]["sqlite3_value_type"]).apply(null, arguments);
    };
    var _sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = function() {
      return (_sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = Module["asm"]["sqlite3_value_nochange"]).apply(null, arguments);
    };
    var _sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = function() {
      return (_sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = Module["asm"]["sqlite3_value_frombind"]).apply(null, arguments);
    };
    var _sqlite3_value_dup = Module["_sqlite3_value_dup"] = function() {
      return (_sqlite3_value_dup = Module["_sqlite3_value_dup"] = Module["asm"]["sqlite3_value_dup"]).apply(null, arguments);
    };
    var _sqlite3_value_free = Module["_sqlite3_value_free"] = function() {
      return (_sqlite3_value_free = Module["_sqlite3_value_free"] = Module["asm"]["sqlite3_value_free"]).apply(null, arguments);
    };
    var _sqlite3_result_blob = Module["_sqlite3_result_blob"] = function() {
      return (_sqlite3_result_blob = Module["_sqlite3_result_blob"] = Module["asm"]["sqlite3_result_blob"]).apply(null, arguments);
    };
    var _sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = function() {
      return (_sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = Module["asm"]["sqlite3_result_error_toobig"]).apply(null, arguments);
    };
    var _sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = function() {
      return (_sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = Module["asm"]["sqlite3_result_error_nomem"]).apply(null, arguments);
    };
    var _sqlite3_result_double = Module["_sqlite3_result_double"] = function() {
      return (_sqlite3_result_double = Module["_sqlite3_result_double"] = Module["asm"]["sqlite3_result_double"]).apply(null, arguments);
    };
    var _sqlite3_result_error = Module["_sqlite3_result_error"] = function() {
      return (_sqlite3_result_error = Module["_sqlite3_result_error"] = Module["asm"]["sqlite3_result_error"]).apply(null, arguments);
    };
    var _sqlite3_result_int = Module["_sqlite3_result_int"] = function() {
      return (_sqlite3_result_int = Module["_sqlite3_result_int"] = Module["asm"]["sqlite3_result_int"]).apply(null, arguments);
    };
    var _sqlite3_result_int64 = Module["_sqlite3_result_int64"] = function() {
      return (_sqlite3_result_int64 = Module["_sqlite3_result_int64"] = Module["asm"]["sqlite3_result_int64"]).apply(null, arguments);
    };
    var _sqlite3_result_null = Module["_sqlite3_result_null"] = function() {
      return (_sqlite3_result_null = Module["_sqlite3_result_null"] = Module["asm"]["sqlite3_result_null"]).apply(null, arguments);
    };
    var _sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = function() {
      return (_sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = Module["asm"]["sqlite3_result_pointer"]).apply(null, arguments);
    };
    var _sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = function() {
      return (_sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = Module["asm"]["sqlite3_result_subtype"]).apply(null, arguments);
    };
    var _sqlite3_result_text = Module["_sqlite3_result_text"] = function() {
      return (_sqlite3_result_text = Module["_sqlite3_result_text"] = Module["asm"]["sqlite3_result_text"]).apply(null, arguments);
    };
    var _sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = function() {
      return (_sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = Module["asm"]["sqlite3_result_zeroblob"]).apply(null, arguments);
    };
    var _sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = function() {
      return (_sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = Module["asm"]["sqlite3_result_zeroblob64"]).apply(null, arguments);
    };
    var _sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = function() {
      return (_sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = Module["asm"]["sqlite3_result_error_code"]).apply(null, arguments);
    };
    var _sqlite3_user_data = Module["_sqlite3_user_data"] = function() {
      return (_sqlite3_user_data = Module["_sqlite3_user_data"] = Module["asm"]["sqlite3_user_data"]).apply(null, arguments);
    };
    var _sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = function() {
      return (_sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = Module["asm"]["sqlite3_context_db_handle"]).apply(null, arguments);
    };
    var _sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = function() {
      return (_sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = Module["asm"]["sqlite3_vtab_nochange"]).apply(null, arguments);
    };
    var _sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = function() {
      return (_sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = Module["asm"]["sqlite3_vtab_in_first"]).apply(null, arguments);
    };
    var _sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = function() {
      return (_sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = Module["asm"]["sqlite3_vtab_in_next"]).apply(null, arguments);
    };
    var _sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = function() {
      return (_sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = Module["asm"]["sqlite3_aggregate_context"]).apply(null, arguments);
    };
    var _sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = function() {
      return (_sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = Module["asm"]["sqlite3_get_auxdata"]).apply(null, arguments);
    };
    var _sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = function() {
      return (_sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = Module["asm"]["sqlite3_set_auxdata"]).apply(null, arguments);
    };
    var _sqlite3_column_count = Module["_sqlite3_column_count"] = function() {
      return (_sqlite3_column_count = Module["_sqlite3_column_count"] = Module["asm"]["sqlite3_column_count"]).apply(null, arguments);
    };
    var _sqlite3_data_count = Module["_sqlite3_data_count"] = function() {
      return (_sqlite3_data_count = Module["_sqlite3_data_count"] = Module["asm"]["sqlite3_data_count"]).apply(null, arguments);
    };
    var _sqlite3_column_blob = Module["_sqlite3_column_blob"] = function() {
      return (_sqlite3_column_blob = Module["_sqlite3_column_blob"] = Module["asm"]["sqlite3_column_blob"]).apply(null, arguments);
    };
    var _sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = function() {
      return (_sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = Module["asm"]["sqlite3_column_bytes"]).apply(null, arguments);
    };
    var _sqlite3_column_double = Module["_sqlite3_column_double"] = function() {
      return (_sqlite3_column_double = Module["_sqlite3_column_double"] = Module["asm"]["sqlite3_column_double"]).apply(null, arguments);
    };
    var _sqlite3_column_value = Module["_sqlite3_column_value"] = function() {
      return (_sqlite3_column_value = Module["_sqlite3_column_value"] = Module["asm"]["sqlite3_column_value"]).apply(null, arguments);
    };
    var _sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = function() {
      return (_sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = Module["asm"]["sqlite3_bind_blob"]).apply(null, arguments);
    };
    var _sqlite3_bind_double = Module["_sqlite3_bind_double"] = function() {
      return (_sqlite3_bind_double = Module["_sqlite3_bind_double"] = Module["asm"]["sqlite3_bind_double"]).apply(null, arguments);
    };
    var _sqlite3_bind_int = Module["_sqlite3_bind_int"] = function() {
      return (_sqlite3_bind_int = Module["_sqlite3_bind_int"] = Module["asm"]["sqlite3_bind_int"]).apply(null, arguments);
    };
    var _sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = function() {
      return (_sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = Module["asm"]["sqlite3_bind_int64"]).apply(null, arguments);
    };
    var _sqlite3_bind_null = Module["_sqlite3_bind_null"] = function() {
      return (_sqlite3_bind_null = Module["_sqlite3_bind_null"] = Module["asm"]["sqlite3_bind_null"]).apply(null, arguments);
    };
    var _sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = function() {
      return (_sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = Module["asm"]["sqlite3_bind_pointer"]).apply(null, arguments);
    };
    var _sqlite3_bind_text = Module["_sqlite3_bind_text"] = function() {
      return (_sqlite3_bind_text = Module["_sqlite3_bind_text"] = Module["asm"]["sqlite3_bind_text"]).apply(null, arguments);
    };
    var _sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = function() {
      return (_sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = Module["asm"]["sqlite3_bind_parameter_count"]).apply(null, arguments);
    };
    var _sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = function() {
      return (_sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = Module["asm"]["sqlite3_bind_parameter_index"]).apply(null, arguments);
    };
    var _sqlite3_db_handle = Module["_sqlite3_db_handle"] = function() {
      return (_sqlite3_db_handle = Module["_sqlite3_db_handle"] = Module["asm"]["sqlite3_db_handle"]).apply(null, arguments);
    };
    var _sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = function() {
      return (_sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = Module["asm"]["sqlite3_stmt_readonly"]).apply(null, arguments);
    };
    var _sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = function() {
      return (_sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = Module["asm"]["sqlite3_stmt_isexplain"]).apply(null, arguments);
    };
    var _sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = function() {
      return (_sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = Module["asm"]["sqlite3_stmt_status"]).apply(null, arguments);
    };
    var _sqlite3_sql = Module["_sqlite3_sql"] = function() {
      return (_sqlite3_sql = Module["_sqlite3_sql"] = Module["asm"]["sqlite3_sql"]).apply(null, arguments);
    };
    var _sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = function() {
      return (_sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = Module["asm"]["sqlite3_expanded_sql"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = function() {
      return (_sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = Module["asm"]["sqlite3_preupdate_old"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = function() {
      return (_sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = Module["asm"]["sqlite3_preupdate_count"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = function() {
      return (_sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = Module["asm"]["sqlite3_preupdate_depth"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = function() {
      return (_sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = Module["asm"]["sqlite3_preupdate_blobwrite"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = function() {
      return (_sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = Module["asm"]["sqlite3_preupdate_new"]).apply(null, arguments);
    };
    var _sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = function() {
      return (_sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = Module["asm"]["sqlite3_value_numeric_type"]).apply(null, arguments);
    };
    var _sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = function() {
      return (_sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = Module["asm"]["sqlite3_set_authorizer"]).apply(null, arguments);
    };
    var _sqlite3_strglob = Module["_sqlite3_strglob"] = function() {
      return (_sqlite3_strglob = Module["_sqlite3_strglob"] = Module["asm"]["sqlite3_strglob"]).apply(null, arguments);
    };
    var _sqlite3_strlike = Module["_sqlite3_strlike"] = function() {
      return (_sqlite3_strlike = Module["_sqlite3_strlike"] = Module["asm"]["sqlite3_strlike"]).apply(null, arguments);
    };
    var _sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = function() {
      return (_sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = Module["asm"]["sqlite3_auto_extension"]).apply(null, arguments);
    };
    var _sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = function() {
      return (_sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = Module["asm"]["sqlite3_cancel_auto_extension"]).apply(null, arguments);
    };
    var _sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = function() {
      return (_sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = Module["asm"]["sqlite3_reset_auto_extension"]).apply(null, arguments);
    };
    var _sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = function() {
      return (_sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = Module["asm"]["sqlite3_prepare_v3"]).apply(null, arguments);
    };
    var _sqlite3_create_module = Module["_sqlite3_create_module"] = function() {
      return (_sqlite3_create_module = Module["_sqlite3_create_module"] = Module["asm"]["sqlite3_create_module"]).apply(null, arguments);
    };
    var _sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = function() {
      return (_sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = Module["asm"]["sqlite3_create_module_v2"]).apply(null, arguments);
    };
    var _sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = function() {
      return (_sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = Module["asm"]["sqlite3_drop_modules"]).apply(null, arguments);
    };
    var _sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = function() {
      return (_sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = Module["asm"]["sqlite3_declare_vtab"]).apply(null, arguments);
    };
    var _sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = function() {
      return (_sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = Module["asm"]["sqlite3_vtab_on_conflict"]).apply(null, arguments);
    };
    var _sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = function() {
      return (_sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = Module["asm"]["sqlite3_vtab_collation"]).apply(null, arguments);
    };
    var _sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = function() {
      return (_sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = Module["asm"]["sqlite3_vtab_in"]).apply(null, arguments);
    };
    var _sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = function() {
      return (_sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = Module["asm"]["sqlite3_vtab_rhs_value"]).apply(null, arguments);
    };
    var _sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = function() {
      return (_sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = Module["asm"]["sqlite3_vtab_distinct"]).apply(null, arguments);
    };
    var _sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = function() {
      return (_sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = Module["asm"]["sqlite3_keyword_name"]).apply(null, arguments);
    };
    var _sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = function() {
      return (_sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = Module["asm"]["sqlite3_keyword_count"]).apply(null, arguments);
    };
    var _sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = function() {
      return (_sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = Module["asm"]["sqlite3_keyword_check"]).apply(null, arguments);
    };
    var _sqlite3_complete = Module["_sqlite3_complete"] = function() {
      return (_sqlite3_complete = Module["_sqlite3_complete"] = Module["asm"]["sqlite3_complete"]).apply(null, arguments);
    };
    var _sqlite3_libversion = Module["_sqlite3_libversion"] = function() {
      return (_sqlite3_libversion = Module["_sqlite3_libversion"] = Module["asm"]["sqlite3_libversion"]).apply(null, arguments);
    };
    var _sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = function() {
      return (_sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = Module["asm"]["sqlite3_libversion_number"]).apply(null, arguments);
    };
    var _sqlite3_shutdown = Module["_sqlite3_shutdown"] = function() {
      return (_sqlite3_shutdown = Module["_sqlite3_shutdown"] = Module["asm"]["sqlite3_shutdown"]).apply(null, arguments);
    };
    var _sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = function() {
      return (_sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = Module["asm"]["sqlite3_last_insert_rowid"]).apply(null, arguments);
    };
    var _sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = function() {
      return (_sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = Module["asm"]["sqlite3_set_last_insert_rowid"]).apply(null, arguments);
    };
    var _sqlite3_changes64 = Module["_sqlite3_changes64"] = function() {
      return (_sqlite3_changes64 = Module["_sqlite3_changes64"] = Module["asm"]["sqlite3_changes64"]).apply(null, arguments);
    };
    var _sqlite3_changes = Module["_sqlite3_changes"] = function() {
      return (_sqlite3_changes = Module["_sqlite3_changes"] = Module["asm"]["sqlite3_changes"]).apply(null, arguments);
    };
    var _sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = function() {
      return (_sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = Module["asm"]["sqlite3_total_changes64"]).apply(null, arguments);
    };
    var _sqlite3_total_changes = Module["_sqlite3_total_changes"] = function() {
      return (_sqlite3_total_changes = Module["_sqlite3_total_changes"] = Module["asm"]["sqlite3_total_changes"]).apply(null, arguments);
    };
    var _sqlite3_txn_state = Module["_sqlite3_txn_state"] = function() {
      return (_sqlite3_txn_state = Module["_sqlite3_txn_state"] = Module["asm"]["sqlite3_txn_state"]).apply(null, arguments);
    };
    var _sqlite3_close_v2 = Module["_sqlite3_close_v2"] = function() {
      return (_sqlite3_close_v2 = Module["_sqlite3_close_v2"] = Module["asm"]["sqlite3_close_v2"]).apply(null, arguments);
    };
    var _sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = function() {
      return (_sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = Module["asm"]["sqlite3_busy_handler"]).apply(null, arguments);
    };
    var _sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = function() {
      return (_sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = Module["asm"]["sqlite3_progress_handler"]).apply(null, arguments);
    };
    var _sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = function() {
      return (_sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = Module["asm"]["sqlite3_busy_timeout"]).apply(null, arguments);
    };
    var _sqlite3_create_function = Module["_sqlite3_create_function"] = function() {
      return (_sqlite3_create_function = Module["_sqlite3_create_function"] = Module["asm"]["sqlite3_create_function"]).apply(null, arguments);
    };
    var _sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = function() {
      return (_sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = Module["asm"]["sqlite3_create_function_v2"]).apply(null, arguments);
    };
    var _sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = function() {
      return (_sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = Module["asm"]["sqlite3_create_window_function"]).apply(null, arguments);
    };
    var _sqlite3_overload_function = Module["_sqlite3_overload_function"] = function() {
      return (_sqlite3_overload_function = Module["_sqlite3_overload_function"] = Module["asm"]["sqlite3_overload_function"]).apply(null, arguments);
    };
    var _sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = function() {
      return (_sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = Module["asm"]["sqlite3_trace_v2"]).apply(null, arguments);
    };
    var _sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = function() {
      return (_sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = Module["asm"]["sqlite3_commit_hook"]).apply(null, arguments);
    };
    var _sqlite3_update_hook = Module["_sqlite3_update_hook"] = function() {
      return (_sqlite3_update_hook = Module["_sqlite3_update_hook"] = Module["asm"]["sqlite3_update_hook"]).apply(null, arguments);
    };
    var _sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = function() {
      return (_sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = Module["asm"]["sqlite3_rollback_hook"]).apply(null, arguments);
    };
    var _sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = function() {
      return (_sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = Module["asm"]["sqlite3_preupdate_hook"]).apply(null, arguments);
    };
    var _sqlite3_error_offset = Module["_sqlite3_error_offset"] = function() {
      return (_sqlite3_error_offset = Module["_sqlite3_error_offset"] = Module["asm"]["sqlite3_error_offset"]).apply(null, arguments);
    };
    var _sqlite3_errcode = Module["_sqlite3_errcode"] = function() {
      return (_sqlite3_errcode = Module["_sqlite3_errcode"] = Module["asm"]["sqlite3_errcode"]).apply(null, arguments);
    };
    var _sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = function() {
      return (_sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = Module["asm"]["sqlite3_extended_errcode"]).apply(null, arguments);
    };
    var _sqlite3_errstr = Module["_sqlite3_errstr"] = function() {
      return (_sqlite3_errstr = Module["_sqlite3_errstr"] = Module["asm"]["sqlite3_errstr"]).apply(null, arguments);
    };
    var _sqlite3_limit = Module["_sqlite3_limit"] = function() {
      return (_sqlite3_limit = Module["_sqlite3_limit"] = Module["asm"]["sqlite3_limit"]).apply(null, arguments);
    };
    var _sqlite3_open = Module["_sqlite3_open"] = function() {
      return (_sqlite3_open = Module["_sqlite3_open"] = Module["asm"]["sqlite3_open"]).apply(null, arguments);
    };
    var _sqlite3_open_v2 = Module["_sqlite3_open_v2"] = function() {
      return (_sqlite3_open_v2 = Module["_sqlite3_open_v2"] = Module["asm"]["sqlite3_open_v2"]).apply(null, arguments);
    };
    var _sqlite3_create_collation = Module["_sqlite3_create_collation"] = function() {
      return (_sqlite3_create_collation = Module["_sqlite3_create_collation"] = Module["asm"]["sqlite3_create_collation"]).apply(null, arguments);
    };
    var _sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = function() {
      return (_sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = Module["asm"]["sqlite3_create_collation_v2"]).apply(null, arguments);
    };
    var _sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = function() {
      return (_sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = Module["asm"]["sqlite3_collation_needed"]).apply(null, arguments);
    };
    var _sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = function() {
      return (_sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = Module["asm"]["sqlite3_get_autocommit"]).apply(null, arguments);
    };
    var _sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = function() {
      return (_sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = Module["asm"]["sqlite3_table_column_metadata"]).apply(null, arguments);
    };
    var _sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = function() {
      return (_sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = Module["asm"]["sqlite3_extended_result_codes"]).apply(null, arguments);
    };
    var _sqlite3_uri_key = Module["_sqlite3_uri_key"] = function() {
      return (_sqlite3_uri_key = Module["_sqlite3_uri_key"] = Module["asm"]["sqlite3_uri_key"]).apply(null, arguments);
    };
    var _sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = function() {
      return (_sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = Module["asm"]["sqlite3_uri_int64"]).apply(null, arguments);
    };
    var _sqlite3_db_name = Module["_sqlite3_db_name"] = function() {
      return (_sqlite3_db_name = Module["_sqlite3_db_name"] = Module["asm"]["sqlite3_db_name"]).apply(null, arguments);
    };
    var _sqlite3_db_filename = Module["_sqlite3_db_filename"] = function() {
      return (_sqlite3_db_filename = Module["_sqlite3_db_filename"] = Module["asm"]["sqlite3_db_filename"]).apply(null, arguments);
    };
    var _sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = function() {
      return (_sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = Module["asm"]["sqlite3_compileoption_used"]).apply(null, arguments);
    };
    var _sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = function() {
      return (_sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = Module["asm"]["sqlite3_compileoption_get"]).apply(null, arguments);
    };
    var _sqlite3session_diff = Module["_sqlite3session_diff"] = function() {
      return (_sqlite3session_diff = Module["_sqlite3session_diff"] = Module["asm"]["sqlite3session_diff"]).apply(null, arguments);
    };
    var _sqlite3session_attach = Module["_sqlite3session_attach"] = function() {
      return (_sqlite3session_attach = Module["_sqlite3session_attach"] = Module["asm"]["sqlite3session_attach"]).apply(null, arguments);
    };
    var _sqlite3session_create = Module["_sqlite3session_create"] = function() {
      return (_sqlite3session_create = Module["_sqlite3session_create"] = Module["asm"]["sqlite3session_create"]).apply(null, arguments);
    };
    var _sqlite3session_delete = Module["_sqlite3session_delete"] = function() {
      return (_sqlite3session_delete = Module["_sqlite3session_delete"] = Module["asm"]["sqlite3session_delete"]).apply(null, arguments);
    };
    var _sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = function() {
      return (_sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = Module["asm"]["sqlite3session_table_filter"]).apply(null, arguments);
    };
    var _sqlite3session_changeset = Module["_sqlite3session_changeset"] = function() {
      return (_sqlite3session_changeset = Module["_sqlite3session_changeset"] = Module["asm"]["sqlite3session_changeset"]).apply(null, arguments);
    };
    var _sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = function() {
      return (_sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = Module["asm"]["sqlite3session_changeset_strm"]).apply(null, arguments);
    };
    var _sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = function() {
      return (_sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = Module["asm"]["sqlite3session_patchset_strm"]).apply(null, arguments);
    };
    var _sqlite3session_patchset = Module["_sqlite3session_patchset"] = function() {
      return (_sqlite3session_patchset = Module["_sqlite3session_patchset"] = Module["asm"]["sqlite3session_patchset"]).apply(null, arguments);
    };
    var _sqlite3session_enable = Module["_sqlite3session_enable"] = function() {
      return (_sqlite3session_enable = Module["_sqlite3session_enable"] = Module["asm"]["sqlite3session_enable"]).apply(null, arguments);
    };
    var _sqlite3session_indirect = Module["_sqlite3session_indirect"] = function() {
      return (_sqlite3session_indirect = Module["_sqlite3session_indirect"] = Module["asm"]["sqlite3session_indirect"]).apply(null, arguments);
    };
    var _sqlite3session_isempty = Module["_sqlite3session_isempty"] = function() {
      return (_sqlite3session_isempty = Module["_sqlite3session_isempty"] = Module["asm"]["sqlite3session_isempty"]).apply(null, arguments);
    };
    var _sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = function() {
      return (_sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = Module["asm"]["sqlite3session_memory_used"]).apply(null, arguments);
    };
    var _sqlite3session_object_config = Module["_sqlite3session_object_config"] = function() {
      return (_sqlite3session_object_config = Module["_sqlite3session_object_config"] = Module["asm"]["sqlite3session_object_config"]).apply(null, arguments);
    };
    var _sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = function() {
      return (_sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = Module["asm"]["sqlite3session_changeset_size"]).apply(null, arguments);
    };
    var _sqlite3changeset_start = Module["_sqlite3changeset_start"] = function() {
      return (_sqlite3changeset_start = Module["_sqlite3changeset_start"] = Module["asm"]["sqlite3changeset_start"]).apply(null, arguments);
    };
    var _sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = function() {
      return (_sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = Module["asm"]["sqlite3changeset_start_v2"]).apply(null, arguments);
    };
    var _sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = function() {
      return (_sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = Module["asm"]["sqlite3changeset_start_strm"]).apply(null, arguments);
    };
    var _sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = function() {
      return (_sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = Module["asm"]["sqlite3changeset_start_v2_strm"]).apply(null, arguments);
    };
    var _sqlite3changeset_next = Module["_sqlite3changeset_next"] = function() {
      return (_sqlite3changeset_next = Module["_sqlite3changeset_next"] = Module["asm"]["sqlite3changeset_next"]).apply(null, arguments);
    };
    var _sqlite3changeset_op = Module["_sqlite3changeset_op"] = function() {
      return (_sqlite3changeset_op = Module["_sqlite3changeset_op"] = Module["asm"]["sqlite3changeset_op"]).apply(null, arguments);
    };
    var _sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = function() {
      return (_sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = Module["asm"]["sqlite3changeset_pk"]).apply(null, arguments);
    };
    var _sqlite3changeset_old = Module["_sqlite3changeset_old"] = function() {
      return (_sqlite3changeset_old = Module["_sqlite3changeset_old"] = Module["asm"]["sqlite3changeset_old"]).apply(null, arguments);
    };
    var _sqlite3changeset_new = Module["_sqlite3changeset_new"] = function() {
      return (_sqlite3changeset_new = Module["_sqlite3changeset_new"] = Module["asm"]["sqlite3changeset_new"]).apply(null, arguments);
    };
    var _sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = function() {
      return (_sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = Module["asm"]["sqlite3changeset_conflict"]).apply(null, arguments);
    };
    var _sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = function() {
      return (_sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = Module["asm"]["sqlite3changeset_fk_conflicts"]).apply(null, arguments);
    };
    var _sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = function() {
      return (_sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = Module["asm"]["sqlite3changeset_finalize"]).apply(null, arguments);
    };
    var _sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = function() {
      return (_sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = Module["asm"]["sqlite3changeset_invert"]).apply(null, arguments);
    };
    var _sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = function() {
      return (_sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = Module["asm"]["sqlite3changeset_invert_strm"]).apply(null, arguments);
    };
    var _sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = function() {
      return (_sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = Module["asm"]["sqlite3changeset_apply_v2"]).apply(null, arguments);
    };
    var _sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = function() {
      return (_sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = Module["asm"]["sqlite3changeset_apply"]).apply(null, arguments);
    };
    var _sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = function() {
      return (_sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = Module["asm"]["sqlite3changeset_apply_v2_strm"]).apply(null, arguments);
    };
    var _sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = function() {
      return (_sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = Module["asm"]["sqlite3changeset_apply_strm"]).apply(null, arguments);
    };
    var _sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = function() {
      return (_sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = Module["asm"]["sqlite3changegroup_new"]).apply(null, arguments);
    };
    var _sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = function() {
      return (_sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = Module["asm"]["sqlite3changegroup_add"]).apply(null, arguments);
    };
    var _sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = function() {
      return (_sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = Module["asm"]["sqlite3changegroup_output"]).apply(null, arguments);
    };
    var _sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = function() {
      return (_sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = Module["asm"]["sqlite3changegroup_add_strm"]).apply(null, arguments);
    };
    var _sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = function() {
      return (_sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = Module["asm"]["sqlite3changegroup_output_strm"]).apply(null, arguments);
    };
    var _sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = function() {
      return (_sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = Module["asm"]["sqlite3changegroup_delete"]).apply(null, arguments);
    };
    var _sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = function() {
      return (_sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = Module["asm"]["sqlite3changeset_concat"]).apply(null, arguments);
    };
    var _sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = function() {
      return (_sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = Module["asm"]["sqlite3changeset_concat_strm"]).apply(null, arguments);
    };
    var _sqlite3session_config = Module["_sqlite3session_config"] = function() {
      return (_sqlite3session_config = Module["_sqlite3session_config"] = Module["asm"]["sqlite3session_config"]).apply(null, arguments);
    };
    var _sqlite3_sourceid = Module["_sqlite3_sourceid"] = function() {
      return (_sqlite3_sourceid = Module["_sqlite3_sourceid"] = Module["asm"]["sqlite3_sourceid"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_ptr = Module["_sqlite3__wasm_pstack_ptr"] = function() {
      return (_sqlite3__wasm_pstack_ptr = Module["_sqlite3__wasm_pstack_ptr"] = Module["asm"]["sqlite3__wasm_pstack_ptr"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_restore = Module["_sqlite3__wasm_pstack_restore"] = function() {
      return (_sqlite3__wasm_pstack_restore = Module["_sqlite3__wasm_pstack_restore"] = Module["asm"]["sqlite3__wasm_pstack_restore"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_alloc = Module["_sqlite3__wasm_pstack_alloc"] = function() {
      return (_sqlite3__wasm_pstack_alloc = Module["_sqlite3__wasm_pstack_alloc"] = Module["asm"]["sqlite3__wasm_pstack_alloc"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_remaining = Module["_sqlite3__wasm_pstack_remaining"] = function() {
      return (_sqlite3__wasm_pstack_remaining = Module["_sqlite3__wasm_pstack_remaining"] = Module["asm"]["sqlite3__wasm_pstack_remaining"]).apply(null, arguments);
    };
    var _sqlite3__wasm_pstack_quota = Module["_sqlite3__wasm_pstack_quota"] = function() {
      return (_sqlite3__wasm_pstack_quota = Module["_sqlite3__wasm_pstack_quota"] = Module["asm"]["sqlite3__wasm_pstack_quota"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_error = Module["_sqlite3__wasm_db_error"] = function() {
      return (_sqlite3__wasm_db_error = Module["_sqlite3__wasm_db_error"] = Module["asm"]["sqlite3__wasm_db_error"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_struct = Module["_sqlite3__wasm_test_struct"] = function() {
      return (_sqlite3__wasm_test_struct = Module["_sqlite3__wasm_test_struct"] = Module["asm"]["sqlite3__wasm_test_struct"]).apply(null, arguments);
    };
    var _sqlite3__wasm_enum_json = Module["_sqlite3__wasm_enum_json"] = function() {
      return (_sqlite3__wasm_enum_json = Module["_sqlite3__wasm_enum_json"] = Module["asm"]["sqlite3__wasm_enum_json"]).apply(null, arguments);
    };
    var _sqlite3__wasm_vfs_unlink = Module["_sqlite3__wasm_vfs_unlink"] = function() {
      return (_sqlite3__wasm_vfs_unlink = Module["_sqlite3__wasm_vfs_unlink"] = Module["asm"]["sqlite3__wasm_vfs_unlink"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_vfs = Module["_sqlite3__wasm_db_vfs"] = function() {
      return (_sqlite3__wasm_db_vfs = Module["_sqlite3__wasm_db_vfs"] = Module["asm"]["sqlite3__wasm_db_vfs"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_reset = Module["_sqlite3__wasm_db_reset"] = function() {
      return (_sqlite3__wasm_db_reset = Module["_sqlite3__wasm_db_reset"] = Module["asm"]["sqlite3__wasm_db_reset"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_export_chunked = Module["_sqlite3__wasm_db_export_chunked"] = function() {
      return (_sqlite3__wasm_db_export_chunked = Module["_sqlite3__wasm_db_export_chunked"] = Module["asm"]["sqlite3__wasm_db_export_chunked"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_db_serialize = Module["_sqlite3__wasm_db_serialize"] = function() {
      return (_sqlite3__wasm_db_serialize = Module["_sqlite3__wasm_db_serialize"] = Module["asm"]["sqlite3__wasm_db_serialize"]).apply(null, arguments);
    };
    var _sqlite3__wasm_vfs_create_file = Module["_sqlite3__wasm_vfs_create_file"] = function() {
      return (_sqlite3__wasm_vfs_create_file = Module["_sqlite3__wasm_vfs_create_file"] = Module["asm"]["sqlite3__wasm_vfs_create_file"]).apply(null, arguments);
    };
    var _sqlite3__wasm_posix_create_file = Module["_sqlite3__wasm_posix_create_file"] = function() {
      return (_sqlite3__wasm_posix_create_file = Module["_sqlite3__wasm_posix_create_file"] = Module["asm"]["sqlite3__wasm_posix_create_file"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = function() {
      return (_sqlite3__wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3__wasm_kvvfsMakeKeyOnPstack"] = Module["asm"]["sqlite3__wasm_kvvfsMakeKeyOnPstack"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_kvvfs_methods = Module["_sqlite3__wasm_kvvfs_methods"] = function() {
      return (_sqlite3__wasm_kvvfs_methods = Module["_sqlite3__wasm_kvvfs_methods"] = Module["asm"]["sqlite3__wasm_kvvfs_methods"]).apply(null, arguments);
    };
    var _sqlite3__wasm_vtab_config = Module["_sqlite3__wasm_vtab_config"] = function() {
      return (_sqlite3__wasm_vtab_config = Module["_sqlite3__wasm_vtab_config"] = Module["asm"]["sqlite3__wasm_vtab_config"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_config_ip = Module["_sqlite3__wasm_db_config_ip"] = function() {
      return (_sqlite3__wasm_db_config_ip = Module["_sqlite3__wasm_db_config_ip"] = Module["asm"]["sqlite3__wasm_db_config_ip"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_config_pii = Module["_sqlite3__wasm_db_config_pii"] = function() {
      return (_sqlite3__wasm_db_config_pii = Module["_sqlite3__wasm_db_config_pii"] = Module["asm"]["sqlite3__wasm_db_config_pii"]).apply(null, arguments);
    };
    var _sqlite3__wasm_db_config_s = Module["_sqlite3__wasm_db_config_s"] = function() {
      return (_sqlite3__wasm_db_config_s = Module["_sqlite3__wasm_db_config_s"] = Module["asm"]["sqlite3__wasm_db_config_s"]).apply(null, arguments);
    };
    var _sqlite3__wasm_config_i = Module["_sqlite3__wasm_config_i"] = function() {
      return (_sqlite3__wasm_config_i = Module["_sqlite3__wasm_config_i"] = Module["asm"]["sqlite3__wasm_config_i"]).apply(null, arguments);
    };
    var _sqlite3__wasm_config_ii = Module["_sqlite3__wasm_config_ii"] = function() {
      return (_sqlite3__wasm_config_ii = Module["_sqlite3__wasm_config_ii"] = Module["asm"]["sqlite3__wasm_config_ii"]).apply(null, arguments);
    };
    var _sqlite3__wasm_config_j = Module["_sqlite3__wasm_config_j"] = function() {
      return (_sqlite3__wasm_config_j = Module["_sqlite3__wasm_config_j"] = Module["asm"]["sqlite3__wasm_config_j"]).apply(null, arguments);
    };
    var _sqlite3__wasm_qfmt_token = Module["_sqlite3__wasm_qfmt_token"] = function() {
      return (_sqlite3__wasm_qfmt_token = Module["_sqlite3__wasm_qfmt_token"] = Module["asm"]["sqlite3__wasm_qfmt_token"]).apply(null, arguments);
    };
    var _sqlite3__wasm_init_wasmfs = Module["_sqlite3__wasm_init_wasmfs"] = function() {
      return (_sqlite3__wasm_init_wasmfs = Module["_sqlite3__wasm_init_wasmfs"] = Module["asm"]["sqlite3__wasm_init_wasmfs"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_intptr = Module["_sqlite3__wasm_test_intptr"] = function() {
      return (_sqlite3__wasm_test_intptr = Module["_sqlite3__wasm_test_intptr"] = Module["asm"]["sqlite3__wasm_test_intptr"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_voidptr = Module["_sqlite3__wasm_test_voidptr"] = function() {
      return (_sqlite3__wasm_test_voidptr = Module["_sqlite3__wasm_test_voidptr"] = Module["asm"]["sqlite3__wasm_test_voidptr"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_int64_max = Module["_sqlite3__wasm_test_int64_max"] = function() {
      return (_sqlite3__wasm_test_int64_max = Module["_sqlite3__wasm_test_int64_max"] = Module["asm"]["sqlite3__wasm_test_int64_max"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_int64_min = Module["_sqlite3__wasm_test_int64_min"] = function() {
      return (_sqlite3__wasm_test_int64_min = Module["_sqlite3__wasm_test_int64_min"] = Module["asm"]["sqlite3__wasm_test_int64_min"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_int64_times2 = Module["_sqlite3__wasm_test_int64_times2"] = function() {
      return (_sqlite3__wasm_test_int64_times2 = Module["_sqlite3__wasm_test_int64_times2"] = Module["asm"]["sqlite3__wasm_test_int64_times2"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_test_int64_minmax = Module["_sqlite3__wasm_test_int64_minmax"] = function() {
      return (_sqlite3__wasm_test_int64_minmax = Module["_sqlite3__wasm_test_int64_minmax"] = Module["asm"]["sqlite3__wasm_test_int64_minmax"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_test_int64ptr = Module["_sqlite3__wasm_test_int64ptr"] = function() {
      return (_sqlite3__wasm_test_int64ptr = Module["_sqlite3__wasm_test_int64ptr"] = Module["asm"]["sqlite3__wasm_test_int64ptr"]).apply(null, arguments);
    };
    var _sqlite3__wasm_test_stack_overflow = Module["_sqlite3__wasm_test_stack_overflow"] = function() {
      return (_sqlite3__wasm_test_stack_overflow = Module["_sqlite3__wasm_test_stack_overflow"] = Module["asm"]["sqlite3__wasm_test_stack_overflow"]).apply(
        null,
        arguments
      );
    };
    var _sqlite3__wasm_test_str_hello = Module["_sqlite3__wasm_test_str_hello"] = function() {
      return (_sqlite3__wasm_test_str_hello = Module["_sqlite3__wasm_test_str_hello"] = Module["asm"]["sqlite3__wasm_test_str_hello"]).apply(null, arguments);
    };
    var _sqlite3__wasm_SQLTester_strglob = Module["_sqlite3__wasm_SQLTester_strglob"] = function() {
      return (_sqlite3__wasm_SQLTester_strglob = Module["_sqlite3__wasm_SQLTester_strglob"] = Module["asm"]["sqlite3__wasm_SQLTester_strglob"]).apply(
        null,
        arguments
      );
    };
    var _malloc = Module["_malloc"] = function() {
      return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(
        null,
        arguments
      );
    };
    var _free = Module["_free"] = function() {
      return (_free = Module["_free"] = Module["asm"]["free"]).apply(
        null,
        arguments
      );
    };
    var _realloc = Module["_realloc"] = function() {
      return (_realloc = Module["_realloc"] = Module["asm"]["realloc"]).apply(
        null,
        arguments
      );
    };
    var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
      return (_emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = Module["asm"]["emscripten_builtin_memalign"]).apply(null, arguments);
    };
    var stackSave = Module["stackSave"] = function() {
      return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
    };
    var stackRestore = Module["stackRestore"] = function() {
      return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
    };
    var stackAlloc = Module["stackAlloc"] = function() {
      return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
    };
    Module["wasmMemory"] = wasmMemory;
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function run(args) {
      args = args || arguments_;
      if (runDependencies > 0) {
        return;
      }
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun)
          return;
        calledRun = true;
        Module["calledRun"] = true;
        if (ABORT)
          return;
        initRuntime();
        readyPromiseResolve(Module);
        if (Module["onRuntimeInitialized"])
          Module["onRuntimeInitialized"]();
        postRun();
      }
      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(function() {
          setTimeout(function() {
            Module["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function")
        Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }
    run();
    if (!Module.postRun)
      Module.postRun = [];
    Module.postRun.push(function(Module2) {
      "use strict";
      "use strict";
      globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(apiConfig = globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig) {
        if (sqlite3ApiBootstrap.sqlite3) {
          (sqlite3ApiBootstrap.sqlite3.config || console).warn(
            "sqlite3ApiBootstrap() called multiple times.",
            "Config and external initializers are ignored on calls after the first."
          );
          return sqlite3ApiBootstrap.sqlite3;
        }
        const config3 = Object.assign(
          /* @__PURE__ */ Object.create(null),
          {
            exports: void 0,
            memory: void 0,
            bigIntEnabled: (() => {
              if ("undefined" !== typeof Module2) {
                if (!!Module2.HEAPU64)
                  return true;
              }
              return !!globalThis.BigInt64Array;
            })(),
            debug: console.debug.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console),
            log: console.log.bind(console),
            wasmfsOpfsDir: "/opfs",
            useStdAlloc: false
          },
          apiConfig || {}
        );
        Object.assign(
          config3,
          {
            allocExportName: config3.useStdAlloc ? "malloc" : "sqlite3_malloc",
            deallocExportName: config3.useStdAlloc ? "free" : "sqlite3_free",
            reallocExportName: config3.useStdAlloc ? "realloc" : "sqlite3_realloc"
          },
          config3
        );
        ["exports", "memory", "wasmfsOpfsDir"].forEach((k6) => {
          if ("function" === typeof config3[k6]) {
            config3[k6] = config3[k6]();
          }
        });
        delete globalThis.sqlite3ApiConfig;
        delete sqlite3ApiBootstrap.defaultConfig;
        const capi = /* @__PURE__ */ Object.create(null);
        const wasm = /* @__PURE__ */ Object.create(null);
        const __rcStr = (rc) => {
          return capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc) || "Unknown result code #" + rc;
        };
        const __isInt = (n6) => "number" === typeof n6 && n6 === (n6 | 0);
        class SQLite3Error extends Error {
          constructor(...args) {
            let rc;
            if (args.length) {
              if (__isInt(args[0])) {
                rc = args[0];
                if (1 === args.length) {
                  super(__rcStr(args[0]));
                } else {
                  const rcStr = __rcStr(rc);
                  if ("object" === typeof args[1]) {
                    super(rcStr, args[1]);
                  } else {
                    args[0] = rcStr + ":";
                    super(args.join(" "));
                  }
                }
              } else {
                if (2 === args.length && "object" === typeof args[1]) {
                  super(...args);
                } else {
                  super(args.join(" "));
                }
              }
            }
            this.resultCode = rc || capi.SQLITE_ERROR;
            this.name = "SQLite3Error";
          }
        }
        SQLite3Error.toss = (...args) => {
          throw new SQLite3Error(...args);
        };
        const toss3 = SQLite3Error.toss;
        if (config3.wasmfsOpfsDir && !/^\/[^/]+$/.test(config3.wasmfsOpfsDir)) {
          toss3(
            "config.wasmfsOpfsDir must be falsy or in the form '/dir-name'."
          );
        }
        const isInt32 = (n6) => {
          return "bigint" !== typeof n6 && !!(n6 === (n6 | 0) && n6 <= 2147483647 && n6 >= -2147483648);
        };
        const bigIntFits64 = function f5(b5) {
          if (!f5._max) {
            f5._max = BigInt("0x7fffffffffffffff");
            f5._min = ~f5._max;
          }
          return b5 >= f5._min && b5 <= f5._max;
        };
        const bigIntFits32 = (b5) => b5 >= -0x7fffffffn - 1n && b5 <= 0x7fffffffn;
        const bigIntFitsDouble = function f5(b5) {
          if (!f5._min) {
            f5._min = Number.MIN_SAFE_INTEGER;
            f5._max = Number.MAX_SAFE_INTEGER;
          }
          return b5 >= f5._min && b5 <= f5._max;
        };
        const isTypedArray = (v8) => {
          return v8 && v8.constructor && isInt32(v8.constructor.BYTES_PER_ELEMENT) ? v8 : false;
        };
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const isSharedTypedArray = (aTypedArray) => aTypedArray.buffer instanceof __SAB;
        const typedArrayPart = (aTypedArray, begin, end) => {
          return isSharedTypedArray(aTypedArray) ? aTypedArray.slice(begin, end) : aTypedArray.subarray(begin, end);
        };
        const isBindableTypedArray = (v8) => {
          return v8 && (v8 instanceof Uint8Array || v8 instanceof Int8Array || v8 instanceof ArrayBuffer);
        };
        const isSQLableTypedArray = (v8) => {
          return v8 && (v8 instanceof Uint8Array || v8 instanceof Int8Array || v8 instanceof ArrayBuffer);
        };
        const affirmBindableTypedArray = (v8) => {
          return isBindableTypedArray(v8) || toss3("Value is not of a supported TypedArray type.");
        };
        const utf8Decoder = new TextDecoder("utf-8");
        const typedArrayToString = function(typedArray, begin, end) {
          return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));
        };
        const flexibleString = function(v8) {
          if (isSQLableTypedArray(v8)) {
            return typedArrayToString(
              v8 instanceof ArrayBuffer ? new Uint8Array(v8) : v8
            );
          } else if (Array.isArray(v8))
            return v8.join("");
          else if (wasm.isPtr(v8))
            v8 = wasm.cstrToJs(v8);
          return v8;
        };
        class WasmAllocError extends Error {
          constructor(...args) {
            if (2 === args.length && "object" === typeof args[1]) {
              super(...args);
            } else if (args.length) {
              super(args.join(" "));
            } else {
              super("Allocation failed.");
            }
            this.resultCode = capi.SQLITE_NOMEM;
            this.name = "WasmAllocError";
          }
        }
        WasmAllocError.toss = (...args) => {
          throw new WasmAllocError(...args);
        };
        Object.assign(capi, {
          sqlite3_bind_blob: void 0,
          sqlite3_bind_text: void 0,
          sqlite3_create_function_v2: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) => {
          },
          sqlite3_create_function: (pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) => {
          },
          sqlite3_create_window_function: (pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) => {
          },
          sqlite3_prepare_v3: (dbPtr, sql, sqlByteLen, prepFlags, stmtPtrPtr, strPtrPtr) => {
          },
          sqlite3_prepare_v2: (dbPtr, sql, sqlByteLen, stmtPtrPtr, strPtrPtr) => {
          },
          sqlite3_exec: (pDb2, sql, callback, pVoid, pErrMsg) => {
          },
          sqlite3_randomness: (n6, outPtr) => {
          }
        });
        const util = {
          affirmBindableTypedArray,
          flexibleString,
          bigIntFits32,
          bigIntFits64,
          bigIntFitsDouble,
          isBindableTypedArray,
          isInt32,
          isSQLableTypedArray,
          isTypedArray,
          typedArrayToString,
          isUIThread: () => globalThis.window === globalThis && !!globalThis.document,
          isSharedTypedArray,
          toss: function(...args) {
            throw new Error(args.join(" "));
          },
          toss3,
          typedArrayPart,
          affirmDbHeader: function(bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            const header = "SQLite format 3";
            if (header.length > bytes.byteLength) {
              toss3("Input does not contain an SQLite3 database header.");
            }
            for (let i4 = 0; i4 < header.length; ++i4) {
              if (header.charCodeAt(i4) !== bytes[i4]) {
                toss3("Input does not contain an SQLite3 database header.");
              }
            }
          },
          affirmIsDb: function(bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            const n6 = bytes.byteLength;
            if (n6 < 512 || n6 % 512 !== 0) {
              toss3("Byte array size", n6, "is invalid for an SQLite3 db.");
            }
            util.affirmDbHeader(bytes);
          }
        };
        Object.assign(wasm, {
          ptrSizeof: config3.wasmPtrSizeof || 4,
          ptrIR: config3.wasmPtrIR || "i32",
          bigIntEnabled: !!config3.bigIntEnabled,
          exports: config3.exports || toss3("Missing API config.exports (WASM module exports)."),
          memory: config3.memory || config3.exports["memory"] || toss3(
            "API config object requires a WebAssembly.Memory object",
            "in either config.exports.memory (exported)",
            "or config.memory (imported)."
          ),
          alloc: void 0,
          realloc: void 0,
          dealloc: void 0
        });
        wasm.allocFromTypedArray = function(srcTypedArray) {
          if (srcTypedArray instanceof ArrayBuffer) {
            srcTypedArray = new Uint8Array(srcTypedArray);
          }
          affirmBindableTypedArray(srcTypedArray);
          const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
          wasm.heapForSize(srcTypedArray.constructor).set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);
          return pRet;
        };
        {
          const keyAlloc = config3.allocExportName, keyDealloc = config3.deallocExportName, keyRealloc = config3.reallocExportName;
          for (const key of [keyAlloc, keyDealloc, keyRealloc]) {
            const f5 = wasm.exports[key];
            if (!(f5 instanceof Function))
              toss3("Missing required exports[", key, "] function.");
          }
          wasm.alloc = function f5(n6) {
            return f5.impl(n6) || WasmAllocError.toss("Failed to allocate", n6, " bytes.");
          };
          wasm.alloc.impl = wasm.exports[keyAlloc];
          wasm.realloc = function f5(m7, n6) {
            const m22 = f5.impl(m7, n6);
            return n6 ? m22 || WasmAllocError.toss("Failed to reallocate", n6, " bytes.") : 0;
          };
          wasm.realloc.impl = wasm.exports[keyRealloc];
          wasm.dealloc = wasm.exports[keyDealloc];
        }
        wasm.compileOptionUsed = function f5(optName) {
          if (!arguments.length) {
            if (f5._result)
              return f5._result;
            else if (!f5._opt) {
              f5._rx = /^([^=]+)=(.+)/;
              f5._rxInt = /^-?\d+$/;
              f5._opt = function(opt, rv) {
                const m7 = f5._rx.exec(opt);
                rv[0] = m7 ? m7[1] : opt;
                rv[1] = m7 ? f5._rxInt.test(m7[2]) ? +m7[2] : m7[2] : true;
              };
            }
            const rc = {}, ov = [0, 0];
            let i4 = 0, k6;
            while (k6 = capi.sqlite3_compileoption_get(i4++)) {
              f5._opt(k6, ov);
              rc[ov[0]] = ov[1];
            }
            return f5._result = rc;
          } else if (Array.isArray(optName)) {
            const rc = {};
            optName.forEach((v8) => {
              rc[v8] = capi.sqlite3_compileoption_used(v8);
            });
            return rc;
          } else if ("object" === typeof optName) {
            Object.keys(optName).forEach((k6) => {
              optName[k6] = capi.sqlite3_compileoption_used(k6);
            });
            return optName;
          }
          return "string" === typeof optName ? !!capi.sqlite3_compileoption_used(optName) : false;
        };
        wasm.pstack = Object.assign(/* @__PURE__ */ Object.create(null), {
          restore: wasm.exports.sqlite3__wasm_pstack_restore,
          alloc: function(n6) {
            if ("string" === typeof n6 && !(n6 = wasm.sizeofIR(n6))) {
              WasmAllocError.toss(
                "Invalid value for pstack.alloc(",
                arguments[0],
                ")"
              );
            }
            return wasm.exports.sqlite3__wasm_pstack_alloc(n6) || WasmAllocError.toss(
              "Could not allocate",
              n6,
              "bytes from the pstack."
            );
          },
          allocChunks: function(n6, sz) {
            if ("string" === typeof sz && !(sz = wasm.sizeofIR(sz))) {
              WasmAllocError.toss(
                "Invalid size value for allocChunks(",
                arguments[1],
                ")"
              );
            }
            const mem = wasm.pstack.alloc(n6 * sz);
            const rc = [];
            let i4 = 0, offset3 = 0;
            for (; i4 < n6; ++i4, offset3 += sz)
              rc.push(mem + offset3);
            return rc;
          },
          allocPtr: (n6 = 1, safePtrSize = true) => {
            return 1 === n6 ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof) : wasm.pstack.allocChunks(n6, safePtrSize ? 8 : wasm.ptrSizeof);
          },
          call: function(f5) {
            const stackPos = wasm.pstack.pointer;
            try {
              return f5(sqlite3);
            } finally {
              wasm.pstack.restore(stackPos);
            }
          }
        });
        Object.defineProperties(wasm.pstack, {
          pointer: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_ptr
          },
          quota: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_quota
          },
          remaining: {
            configurable: false,
            iterable: true,
            writeable: false,
            get: wasm.exports.sqlite3__wasm_pstack_remaining
          }
        });
        capi.sqlite3_randomness = (...args) => {
          if (1 === args.length && util.isTypedArray(args[0]) && 1 === args[0].BYTES_PER_ELEMENT) {
            const ta = args[0];
            if (0 === ta.byteLength) {
              wasm.exports.sqlite3_randomness(0, 0);
              return ta;
            }
            const stack = wasm.pstack.pointer;
            try {
              let n6 = ta.byteLength, offset3 = 0;
              const r6 = wasm.exports.sqlite3_randomness;
              const heap = wasm.heap8u();
              const nAlloc = n6 < 512 ? n6 : 512;
              const ptr = wasm.pstack.alloc(nAlloc);
              do {
                const j5 = n6 > nAlloc ? nAlloc : n6;
                r6(j5, ptr);
                ta.set(typedArrayPart(heap, ptr, ptr + j5), offset3);
                n6 -= j5;
                offset3 += j5;
              } while (n6 > 0);
            } catch (e6) {
              console.error(
                "Highly unexpected (and ignored!) exception in sqlite3_randomness():",
                e6
              );
            } finally {
              wasm.pstack.restore(stack);
            }
            return ta;
          }
          wasm.exports.sqlite3_randomness(...args);
        };
        let __wasmfsOpfsDir = void 0;
        capi.sqlite3_wasmfs_opfs_dir = function() {
          if (void 0 !== __wasmfsOpfsDir)
            return __wasmfsOpfsDir;
          const pdir = config3.wasmfsOpfsDir;
          if (!pdir || !globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle) {
            return __wasmfsOpfsDir = "";
          }
          try {
            if (pdir && 0 === wasm.xCallWrapped(
              "sqlite3__wasm_init_wasmfs",
              "i32",
              ["string"],
              pdir
            )) {
              return __wasmfsOpfsDir = pdir;
            } else {
              return __wasmfsOpfsDir = "";
            }
          } catch (e6) {
            return __wasmfsOpfsDir = "";
          }
        };
        capi.sqlite3_wasmfs_filename_is_persistent = function(name) {
          const p5 = capi.sqlite3_wasmfs_opfs_dir();
          return p5 && name ? name.startsWith(p5 + "/") : false;
        };
        capi.sqlite3_js_db_uses_vfs = function(pDb2, vfsName, dbName = 0) {
          try {
            const pK = capi.sqlite3_vfs_find(vfsName);
            if (!pK)
              return false;
            else if (!pDb2) {
              return pK === capi.sqlite3_vfs_find(0) ? pK : false;
            } else {
              return pK === capi.sqlite3_js_db_vfs(pDb2, dbName) ? pK : false;
            }
          } catch (e6) {
            return false;
          }
        };
        capi.sqlite3_js_vfs_list = function() {
          const rc = [];
          let pVfs = capi.sqlite3_vfs_find(0);
          while (pVfs) {
            const oVfs = new capi.sqlite3_vfs(pVfs);
            rc.push(wasm.cstrToJs(oVfs.$zName));
            pVfs = oVfs.$pNext;
            oVfs.dispose();
          }
          return rc;
        };
        capi.sqlite3_js_db_export = function(pDb2, schema = 0) {
          pDb2 = wasm.xWrap.testConvertArg("sqlite3*", pDb2);
          if (!pDb2)
            toss3("Invalid sqlite3* argument.");
          if (!wasm.bigIntEnabled)
            toss3("BigInt64 support is not enabled.");
          const scope = wasm.scopedAllocPush();
          let pOut;
          try {
            const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
            const ppOut = pSize + 8;
            const zSchema = schema ? wasm.isPtr(schema) ? schema : wasm.scopedAllocCString("" + schema) : 0;
            let rc = wasm.exports.sqlite3__wasm_db_serialize(
              pDb2,
              zSchema,
              ppOut,
              pSize,
              0
            );
            if (rc) {
              toss3(
                "Database serialization failed with code",
                sqlite3.capi.sqlite3_js_rc_str(rc)
              );
            }
            pOut = wasm.peekPtr(ppOut);
            const nOut = wasm.peek(pSize, "i64");
            rc = nOut ? wasm.heap8u().slice(pOut, pOut + Number(nOut)) : new Uint8Array();
            return rc;
          } finally {
            if (pOut)
              wasm.exports.sqlite3_free(pOut);
            wasm.scopedAllocPop(scope);
          }
        };
        capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) => util.sqlite3__wasm_db_vfs(dbPointer, dbName);
        capi.sqlite3_js_aggregate_context = (pCtx, n6) => {
          return capi.sqlite3_aggregate_context(pCtx, n6) || (n6 ? WasmAllocError.toss(
            "Cannot allocate",
            n6,
            "bytes for sqlite3_aggregate_context()"
          ) : 0);
        };
        capi.sqlite3_js_posix_create_file = function(filename, data, dataLen) {
          let pData;
          if (data && wasm.isPtr(data)) {
            pData = data;
          } else if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
            pData = wasm.allocFromTypedArray(data);
            if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {
              dataLen = data.byteLength;
            }
          } else {
            SQLite3Error.toss(
              "Invalid 2nd argument for sqlite3_js_posix_create_file()."
            );
          }
          try {
            if (!util.isInt32(dataLen) || dataLen < 0) {
              SQLite3Error.toss(
                "Invalid 3rd argument for sqlite3_js_posix_create_file()."
              );
            }
            const rc = util.sqlite3__wasm_posix_create_file(
              filename,
              pData,
              dataLen
            );
            if (rc)
              SQLite3Error.toss(
                "Creation of file failed with sqlite3 result code",
                capi.sqlite3_js_rc_str(rc)
              );
          } finally {
            wasm.dealloc(pData);
          }
        };
        capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen) {
          config3.warn(
            "sqlite3_js_vfs_create_file() is deprecated and",
            "should be avoided because it can lead to C-level crashes.",
            "See its documentation for alternative options."
          );
          let pData;
          if (data) {
            if (wasm.isPtr(data)) {
              pData = data;
            } else if (data instanceof ArrayBuffer) {
              data = new Uint8Array(data);
            }
            if (data instanceof Uint8Array) {
              pData = wasm.allocFromTypedArray(data);
              if (arguments.length < 4 || !util.isInt32(dataLen) || dataLen < 0) {
                dataLen = data.byteLength;
              }
            } else {
              SQLite3Error.toss(
                "Invalid 3rd argument type for sqlite3_js_vfs_create_file()."
              );
            }
          } else {
            pData = 0;
          }
          if (!util.isInt32(dataLen) || dataLen < 0) {
            wasm.dealloc(pData);
            SQLite3Error.toss(
              "Invalid 4th argument for sqlite3_js_vfs_create_file()."
            );
          }
          try {
            const rc = util.sqlite3__wasm_vfs_create_file(
              vfs,
              filename,
              pData,
              dataLen
            );
            if (rc)
              SQLite3Error.toss(
                "Creation of file failed with sqlite3 result code",
                capi.sqlite3_js_rc_str(rc)
              );
          } finally {
            wasm.dealloc(pData);
          }
        };
        capi.sqlite3_js_sql_to_string = (sql) => {
          if ("string" === typeof sql) {
            return sql;
          }
          const x6 = flexibleString(v);
          return x6 === v ? void 0 : x6;
        };
        if (util.isUIThread()) {
          const __kvvfsInfo = function(which) {
            const rc = /* @__PURE__ */ Object.create(null);
            rc.prefix = "kvvfs-" + which;
            rc.stores = [];
            if ("session" === which || "" === which)
              rc.stores.push(globalThis.sessionStorage);
            if ("local" === which || "" === which)
              rc.stores.push(globalThis.localStorage);
            return rc;
          };
          capi.sqlite3_js_kvvfs_clear = function(which = "") {
            let rc = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s3) => {
              const toRm = [];
              let i4;
              for (i4 = 0; i4 < s3.length; ++i4) {
                const k6 = s3.key(i4);
                if (k6.startsWith(kvinfo.prefix))
                  toRm.push(k6);
              }
              toRm.forEach((kk) => s3.removeItem(kk));
              rc += toRm.length;
            });
            return rc;
          };
          capi.sqlite3_js_kvvfs_size = function(which = "") {
            let sz = 0;
            const kvinfo = __kvvfsInfo(which);
            kvinfo.stores.forEach((s3) => {
              let i4;
              for (i4 = 0; i4 < s3.length; ++i4) {
                const k6 = s3.key(i4);
                if (k6.startsWith(kvinfo.prefix)) {
                  sz += k6.length;
                  sz += s3.getItem(k6).length;
                }
              }
            });
            return sz * 2;
          };
        }
        capi.sqlite3_db_config = function(pDb2, op, ...args) {
          if (!this.s) {
            this.s = wasm.xWrap("sqlite3__wasm_db_config_s", "int", [
              "sqlite3*",
              "int",
              "string:static"
            ]);
            this.pii = wasm.xWrap("sqlite3__wasm_db_config_pii", "int", [
              "sqlite3*",
              "int",
              "*",
              "int",
              "int"
            ]);
            this.ip = wasm.xWrap("sqlite3__wasm_db_config_ip", "int", [
              "sqlite3*",
              "int",
              "int",
              "*"
            ]);
          }
          switch (op) {
            case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
            case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
            case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
            case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
            case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
            case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
            case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
            case capi.SQLITE_DBCONFIG_RESET_DATABASE:
            case capi.SQLITE_DBCONFIG_DEFENSIVE:
            case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
            case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
            case capi.SQLITE_DBCONFIG_DQS_DML:
            case capi.SQLITE_DBCONFIG_DQS_DDL:
            case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
            case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
            case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
            case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
            case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
              return this.ip(pDb2, op, args[0], args[1] || 0);
            case capi.SQLITE_DBCONFIG_LOOKASIDE:
              return this.pii(pDb2, op, args[0], args[1], args[2]);
            case capi.SQLITE_DBCONFIG_MAINDBNAME:
              return this.s(pDb2, op, args[0]);
            default:
              return capi.SQLITE_MISUSE;
          }
        }.bind(/* @__PURE__ */ Object.create(null));
        capi.sqlite3_value_to_js = function(pVal, throwIfCannotConvert = true) {
          let arg;
          const valType = capi.sqlite3_value_type(pVal);
          switch (valType) {
            case capi.SQLITE_INTEGER:
              if (wasm.bigIntEnabled) {
                arg = capi.sqlite3_value_int64(pVal);
                if (util.bigIntFitsDouble(arg))
                  arg = Number(arg);
              } else
                arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_FLOAT:
              arg = capi.sqlite3_value_double(pVal);
              break;
            case capi.SQLITE_TEXT:
              arg = capi.sqlite3_value_text(pVal);
              break;
            case capi.SQLITE_BLOB: {
              const n6 = capi.sqlite3_value_bytes(pVal);
              const pBlob = capi.sqlite3_value_blob(pVal);
              if (n6 && !pBlob)
                sqlite3.WasmAllocError.toss(
                  "Cannot allocate memory for blob argument of",
                  n6,
                  "byte(s)"
                );
              arg = n6 ? wasm.heap8u().slice(pBlob, pBlob + Number(n6)) : null;
              break;
            }
            case capi.SQLITE_NULL:
              arg = null;
              break;
            default:
              if (throwIfCannotConvert) {
                toss3(
                  capi.SQLITE_MISMATCH,
                  "Unhandled sqlite3_value_type():",
                  valType
                );
              }
              arg = void 0;
          }
          return arg;
        };
        capi.sqlite3_values_to_js = function(argc, pArgv, throwIfCannotConvert = true) {
          let i4;
          const tgt = [];
          for (i4 = 0; i4 < argc; ++i4) {
            tgt.push(
              capi.sqlite3_value_to_js(
                wasm.peekPtr(pArgv + wasm.ptrSizeof * i4),
                throwIfCannotConvert
              )
            );
          }
          return tgt;
        };
        capi.sqlite3_result_error_js = function(pCtx, e6) {
          if (e6 instanceof WasmAllocError) {
            capi.sqlite3_result_error_nomem(pCtx);
          } else {
            capi.sqlite3_result_error(pCtx, "" + e6, -1);
          }
        };
        capi.sqlite3_result_js = function(pCtx, val) {
          if (val instanceof Error) {
            capi.sqlite3_result_error_js(pCtx, val);
            return;
          }
          try {
            switch (typeof val) {
              case "undefined":
                break;
              case "boolean":
                capi.sqlite3_result_int(pCtx, val ? 1 : 0);
                break;
              case "bigint":
                if (util.bigIntFits32(val)) {
                  capi.sqlite3_result_int(pCtx, Number(val));
                } else if (util.bigIntFitsDouble(val)) {
                  capi.sqlite3_result_double(pCtx, Number(val));
                } else if (wasm.bigIntEnabled) {
                  if (util.bigIntFits64(val))
                    capi.sqlite3_result_int64(pCtx, val);
                  else
                    toss3(
                      "BigInt value",
                      val.toString(),
                      "is too BigInt for int64."
                    );
                } else {
                  toss3("BigInt value", val.toString(), "is too BigInt.");
                }
                break;
              case "number": {
                let f5;
                if (util.isInt32(val)) {
                  f5 = capi.sqlite3_result_int;
                } else if (wasm.bigIntEnabled && Number.isInteger(val) && util.bigIntFits64(BigInt(val))) {
                  f5 = capi.sqlite3_result_int64;
                } else {
                  f5 = capi.sqlite3_result_double;
                }
                f5(pCtx, val);
                break;
              }
              case "string": {
                const [p5, n6] = wasm.allocCString(val, true);
                capi.sqlite3_result_text(pCtx, p5, n6, capi.SQLITE_WASM_DEALLOC);
                break;
              }
              case "object":
                if (null === val) {
                  capi.sqlite3_result_null(pCtx);
                  break;
                } else if (util.isBindableTypedArray(val)) {
                  const pBlob = wasm.allocFromTypedArray(val);
                  capi.sqlite3_result_blob(
                    pCtx,
                    pBlob,
                    val.byteLength,
                    capi.SQLITE_WASM_DEALLOC
                  );
                  break;
                }
              default:
                toss3(
                  "Don't not how to handle this UDF result value:",
                  typeof val,
                  val
                );
            }
          } catch (e6) {
            capi.sqlite3_result_error_js(pCtx, e6);
          }
        };
        capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert = true) {
          const v8 = capi.sqlite3_column_value(pStmt, iCol);
          return 0 === v8 ? void 0 : capi.sqlite3_value_to_js(v8, throwIfCannotConvert);
        };
        const __newOldValue = function(pObj, iCol, impl) {
          impl = capi[impl];
          if (!this.ptr)
            this.ptr = wasm.allocPtr();
          else
            wasm.pokePtr(this.ptr, 0);
          const rc = impl(pObj, iCol, this.ptr);
          if (rc)
            return SQLite3Error.toss(
              rc,
              arguments[2] + "() failed with code " + rc
            );
          const pv = wasm.peekPtr(this.ptr);
          return pv ? capi.sqlite3_value_to_js(pv, true) : void 0;
        }.bind(/* @__PURE__ */ Object.create(null));
        capi.sqlite3_preupdate_new_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_new");
        capi.sqlite3_preupdate_old_js = (pDb2, iCol) => __newOldValue(pDb2, iCol, "sqlite3_preupdate_old");
        capi.sqlite3changeset_new_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_new");
        capi.sqlite3changeset_old_js = (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol, "sqlite3changeset_old");
        const sqlite3 = {
          WasmAllocError,
          SQLite3Error,
          capi,
          util,
          wasm,
          config: config3,
          version: /* @__PURE__ */ Object.create(null),
          client: void 0,
          asyncPostInit: async function ff() {
            if (ff.isReady instanceof Promise)
              return ff.isReady;
            let lia = sqlite3ApiBootstrap.initializersAsync;
            delete sqlite3ApiBootstrap.initializersAsync;
            const postInit = async () => {
              if (!sqlite3.__isUnderTest) {
                delete sqlite3.util;
                delete sqlite3.StructBinder;
              }
              return sqlite3;
            };
            const catcher = (e6) => {
              config3.error("an async sqlite3 initializer failed:", e6);
              throw e6;
            };
            if (!lia || !lia.length) {
              return ff.isReady = postInit().catch(catcher);
            }
            lia = lia.map((f5) => {
              return f5 instanceof Function ? async (x6) => f5(sqlite3) : f5;
            });
            lia.push(postInit);
            let p5 = Promise.resolve(sqlite3);
            while (lia.length)
              p5 = p5.then(lia.shift());
            return ff.isReady = p5.catch(catcher);
          },
          scriptInfo: void 0
        };
        try {
          sqlite3ApiBootstrap.initializers.forEach((f5) => {
            f5(sqlite3);
          });
        } catch (e6) {
          console.error("sqlite3 bootstrap initializer threw:", e6);
          throw e6;
        }
        delete sqlite3ApiBootstrap.initializers;
        sqlite3ApiBootstrap.sqlite3 = sqlite3;
        return sqlite3;
      };
      globalThis.sqlite3ApiBootstrap.initializers = [];
      globalThis.sqlite3ApiBootstrap.initializersAsync = [];
      globalThis.sqlite3ApiBootstrap.defaultConfig = /* @__PURE__ */ Object.create(null);
      globalThis.sqlite3ApiBootstrap.sqlite3 = void 0;
      globalThis.WhWasmUtilInstaller = function(target) {
        "use strict";
        if (void 0 === target.bigIntEnabled) {
          target.bigIntEnabled = !!globalThis["BigInt64Array"];
        }
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        if (!target.exports) {
          Object.defineProperty(target, "exports", {
            enumerable: true,
            configurable: true,
            get: () => target.instance && target.instance.exports
          });
        }
        const ptrIR = target.pointerIR || "i32";
        const ptrSizeof = target.ptrSizeof = "i32" === ptrIR ? 4 : "i64" === ptrIR ? 8 : toss("Unhandled ptrSizeof:", ptrIR);
        const cache = /* @__PURE__ */ Object.create(null);
        cache.heapSize = 0;
        cache.memory = null;
        cache.freeFuncIndexes = [];
        cache.scopedAlloc = [];
        cache.utf8Decoder = new TextDecoder();
        cache.utf8Encoder = new TextEncoder("utf-8");
        target.sizeofIR = (n6) => {
          switch (n6) {
            case "i8":
              return 1;
            case "i16":
              return 2;
            case "i32":
            case "f32":
            case "float":
              return 4;
            case "i64":
            case "f64":
            case "double":
              return 8;
            case "*":
              return ptrSizeof;
            default:
              return ("" + n6).endsWith("*") ? ptrSizeof : void 0;
          }
        };
        const heapWrappers = function() {
          if (!cache.memory) {
            cache.memory = target.memory instanceof WebAssembly.Memory ? target.memory : target.exports.memory;
          } else if (cache.heapSize === cache.memory.buffer.byteLength) {
            return cache;
          }
          const b5 = cache.memory.buffer;
          cache.HEAP8 = new Int8Array(b5);
          cache.HEAP8U = new Uint8Array(b5);
          cache.HEAP16 = new Int16Array(b5);
          cache.HEAP16U = new Uint16Array(b5);
          cache.HEAP32 = new Int32Array(b5);
          cache.HEAP32U = new Uint32Array(b5);
          if (target.bigIntEnabled) {
            cache.HEAP64 = new BigInt64Array(b5);
            cache.HEAP64U = new BigUint64Array(b5);
          }
          cache.HEAP32F = new Float32Array(b5);
          cache.HEAP64F = new Float64Array(b5);
          cache.heapSize = b5.byteLength;
          return cache;
        };
        target.heap8 = () => heapWrappers().HEAP8;
        target.heap8u = () => heapWrappers().HEAP8U;
        target.heap16 = () => heapWrappers().HEAP16;
        target.heap16u = () => heapWrappers().HEAP16U;
        target.heap32 = () => heapWrappers().HEAP32;
        target.heap32u = () => heapWrappers().HEAP32U;
        target.heapForSize = function(n6, unsigned = true) {
          let ctor;
          const c5 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          switch (n6) {
            case Int8Array:
              return c5.HEAP8;
            case Uint8Array:
              return c5.HEAP8U;
            case Int16Array:
              return c5.HEAP16;
            case Uint16Array:
              return c5.HEAP16U;
            case Int32Array:
              return c5.HEAP32;
            case Uint32Array:
              return c5.HEAP32U;
            case 8:
              return unsigned ? c5.HEAP8U : c5.HEAP8;
            case 16:
              return unsigned ? c5.HEAP16U : c5.HEAP16;
            case 32:
              return unsigned ? c5.HEAP32U : c5.HEAP32;
            case 64:
              if (c5.HEAP64)
                return unsigned ? c5.HEAP64U : c5.HEAP64;
              break;
            default:
              if (target.bigIntEnabled) {
                if (n6 === globalThis["BigUint64Array"])
                  return c5.HEAP64U;
                else if (n6 === globalThis["BigInt64Array"])
                  return c5.HEAP64;
                break;
              }
          }
          toss(
            "Invalid heapForSize() size: expecting 8, 16, 32,",
            "or (if BigInt is enabled) 64."
          );
        };
        target.functionTable = function() {
          return target.exports.__indirect_function_table;
        };
        target.functionEntry = function(fptr) {
          const ft2 = target.functionTable();
          return fptr < ft2.length ? ft2.get(fptr) : void 0;
        };
        target.jsFuncToWasm = function f5(func, sig) {
          if (!f5._) {
            f5._ = {
              sigTypes: Object.assign(/* @__PURE__ */ Object.create(null), {
                i: "i32",
                p: "i32",
                P: "i32",
                s: "i32",
                j: "i64",
                f: "f32",
                d: "f64"
              }),
              typeCodes: Object.assign(/* @__PURE__ */ Object.create(null), {
                f64: 124,
                f32: 125,
                i64: 126,
                i32: 127
              }),
              uleb128Encode: function(tgt, method, n6) {
                if (n6 < 128)
                  tgt[method](n6);
                else
                  tgt[method](n6 % 128 | 128, n6 >> 7);
              },
              rxJSig: /^(\w)\((\w*)\)$/,
              sigParams: function(sig2) {
                const m7 = f5._.rxJSig.exec(sig2);
                return m7 ? m7[2] : sig2.substr(1);
              },
              letterType: (x6) => f5._.sigTypes[x6] || toss("Invalid signature letter:", x6),
              pushSigType: (dest, letter) => dest.push(f5._.typeCodes[f5._.letterType(letter)])
            };
          }
          if ("string" === typeof func) {
            const x6 = sig;
            sig = func;
            func = x6;
          }
          const sigParams = f5._.sigParams(sig);
          const wasmCode = [1, 96];
          f5._.uleb128Encode(wasmCode, "push", sigParams.length);
          for (const x6 of sigParams)
            f5._.pushSigType(wasmCode, x6);
          if ("v" === sig[0])
            wasmCode.push(0);
          else {
            wasmCode.push(1);
            f5._.pushSigType(wasmCode, sig[0]);
          }
          f5._.uleb128Encode(wasmCode, "unshift", wasmCode.length);
          wasmCode.unshift(
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1
          );
          wasmCode.push(
            2,
            7,
            1,
            1,
            101,
            1,
            102,
            0,
            0,
            7,
            5,
            1,
            1,
            102,
            0,
            0
          );
          return new WebAssembly.Instance(
            new WebAssembly.Module(new Uint8Array(wasmCode)),
            {
              e: { f: func }
            }
          ).exports["f"];
        };
        const __installFunction = function f5(func, sig, scoped) {
          if (scoped && !cache.scopedAlloc.length) {
            toss("No scopedAllocPush() scope is active.");
          }
          if ("string" === typeof func) {
            const x6 = sig;
            sig = func;
            func = x6;
          }
          if ("string" !== typeof sig || !(func instanceof Function)) {
            toss(
              "Invalid arguments: expecting (function,signature) or (signature,function)."
            );
          }
          const ft2 = target.functionTable();
          const oldLen = ft2.length;
          let ptr;
          while (cache.freeFuncIndexes.length) {
            ptr = cache.freeFuncIndexes.pop();
            if (ft2.get(ptr)) {
              ptr = null;
              continue;
            } else {
              break;
            }
          }
          if (!ptr) {
            ptr = oldLen;
            ft2.grow(1);
          }
          try {
            ft2.set(ptr, func);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
            return ptr;
          } catch (e6) {
            if (!(e6 instanceof TypeError)) {
              if (ptr === oldLen)
                cache.freeFuncIndexes.push(oldLen);
              throw e6;
            }
          }
          try {
            const fptr = target.jsFuncToWasm(func, sig);
            ft2.set(ptr, fptr);
            if (scoped) {
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
            }
          } catch (e6) {
            if (ptr === oldLen)
              cache.freeFuncIndexes.push(oldLen);
            throw e6;
          }
          return ptr;
        };
        target.installFunction = (func, sig) => __installFunction(func, sig, false);
        target.scopedInstallFunction = (func, sig) => __installFunction(func, sig, true);
        target.uninstallFunction = function(ptr) {
          if (!ptr && 0 !== ptr)
            return void 0;
          const fi2 = cache.freeFuncIndexes;
          const ft2 = target.functionTable();
          fi2.push(ptr);
          const rc = ft2.get(ptr);
          ft2.set(ptr, null);
          return rc;
        };
        target.peek = function f5(ptr, type = "i8") {
          if (type.endsWith("*"))
            type = ptrIR;
          const c5 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          const list = Array.isArray(ptr) ? [] : void 0;
          let rc;
          do {
            if (list)
              ptr = arguments[0].shift();
            switch (type) {
              case "i1":
              case "i8":
                rc = c5.HEAP8[ptr >> 0];
                break;
              case "i16":
                rc = c5.HEAP16[ptr >> 1];
                break;
              case "i32":
                rc = c5.HEAP32[ptr >> 2];
                break;
              case "float":
              case "f32":
                rc = c5.HEAP32F[ptr >> 2];
                break;
              case "double":
              case "f64":
                rc = Number(c5.HEAP64F[ptr >> 3]);
                break;
              case "i64":
                if (target.bigIntEnabled) {
                  rc = BigInt(c5.HEAP64[ptr >> 3]);
                  break;
                }
              default:
                toss("Invalid type for peek():", type);
            }
            if (list)
              list.push(rc);
          } while (list && arguments[0].length);
          return list || rc;
        };
        target.poke = function(ptr, value, type = "i8") {
          if (type.endsWith("*"))
            type = ptrIR;
          const c5 = cache.memory && cache.heapSize === cache.memory.buffer.byteLength ? cache : heapWrappers();
          for (const p5 of Array.isArray(ptr) ? ptr : [ptr]) {
            switch (type) {
              case "i1":
              case "i8":
                c5.HEAP8[p5 >> 0] = value;
                continue;
              case "i16":
                c5.HEAP16[p5 >> 1] = value;
                continue;
              case "i32":
                c5.HEAP32[p5 >> 2] = value;
                continue;
              case "float":
              case "f32":
                c5.HEAP32F[p5 >> 2] = value;
                continue;
              case "double":
              case "f64":
                c5.HEAP64F[p5 >> 3] = value;
                continue;
              case "i64":
                if (c5.HEAP64) {
                  c5.HEAP64[p5 >> 3] = BigInt(value);
                  continue;
                }
              default:
                toss("Invalid type for poke(): " + type);
            }
          }
          return this;
        };
        target.peekPtr = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);
        target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);
        target.peek8 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i8");
        target.poke8 = (ptr, value) => target.poke(ptr, value, "i8");
        target.peek16 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i16");
        target.poke16 = (ptr, value) => target.poke(ptr, value, "i16");
        target.peek32 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i32");
        target.poke32 = (ptr, value) => target.poke(ptr, value, "i32");
        target.peek64 = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "i64");
        target.poke64 = (ptr, value) => target.poke(ptr, value, "i64");
        target.peek32f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f32");
        target.poke32f = (ptr, value) => target.poke(ptr, value, "f32");
        target.peek64f = (...ptr) => target.peek(1 === ptr.length ? ptr[0] : ptr, "f64");
        target.poke64f = (ptr, value) => target.poke(ptr, value, "f64");
        target.getMemValue = target.peek;
        target.getPtrValue = target.peekPtr;
        target.setMemValue = target.poke;
        target.setPtrValue = target.pokePtr;
        target.isPtr32 = (ptr) => "number" === typeof ptr && ptr === (ptr | 0) && ptr >= 0;
        target.isPtr = target.isPtr32;
        target.cstrlen = function(ptr) {
          if (!ptr || !target.isPtr(ptr))
            return null;
          const h7 = heapWrappers().HEAP8U;
          let pos = ptr;
          for (; h7[pos] !== 0; ++pos) {
          }
          return pos - ptr;
        };
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const __utf8Decode = function(arrayBuffer, begin, end) {
          return cache.utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
          );
        };
        target.cstrToJs = function(ptr) {
          const n6 = target.cstrlen(ptr);
          return n6 ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n6) : null === n6 ? n6 : "";
        };
        target.jstrlen = function(str) {
          if ("string" !== typeof str)
            return null;
          const n6 = str.length;
          let len = 0;
          for (let i4 = 0; i4 < n6; ++i4) {
            let u3 = str.charCodeAt(i4);
            if (u3 >= 55296 && u3 <= 57343) {
              u3 = 65536 + ((u3 & 1023) << 10) | str.charCodeAt(++i4) & 1023;
            }
            if (u3 <= 127)
              ++len;
            else if (u3 <= 2047)
              len += 2;
            else if (u3 <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        };
        target.jstrcpy = function(jstr, tgt, offset3 = 0, maxBytes = -1, addNul = true) {
          if (!tgt || !(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array)) {
            toss("jstrcpy() target must be an Int8Array or Uint8Array.");
          }
          if (maxBytes < 0)
            maxBytes = tgt.length - offset3;
          if (!(maxBytes > 0) || !(offset3 >= 0))
            return 0;
          let i4 = 0, max6 = jstr.length;
          const begin = offset3, end = offset3 + maxBytes - (addNul ? 1 : 0);
          for (; i4 < max6 && offset3 < end; ++i4) {
            let u3 = jstr.charCodeAt(i4);
            if (u3 >= 55296 && u3 <= 57343) {
              u3 = 65536 + ((u3 & 1023) << 10) | jstr.charCodeAt(++i4) & 1023;
            }
            if (u3 <= 127) {
              if (offset3 >= end)
                break;
              tgt[offset3++] = u3;
            } else if (u3 <= 2047) {
              if (offset3 + 1 >= end)
                break;
              tgt[offset3++] = 192 | u3 >> 6;
              tgt[offset3++] = 128 | u3 & 63;
            } else if (u3 <= 65535) {
              if (offset3 + 2 >= end)
                break;
              tgt[offset3++] = 224 | u3 >> 12;
              tgt[offset3++] = 128 | u3 >> 6 & 63;
              tgt[offset3++] = 128 | u3 & 63;
            } else {
              if (offset3 + 3 >= end)
                break;
              tgt[offset3++] = 240 | u3 >> 18;
              tgt[offset3++] = 128 | u3 >> 12 & 63;
              tgt[offset3++] = 128 | u3 >> 6 & 63;
              tgt[offset3++] = 128 | u3 & 63;
            }
          }
          if (addNul)
            tgt[offset3++] = 0;
          return offset3 - begin;
        };
        target.cstrncpy = function(tgtPtr, srcPtr, n6) {
          if (!tgtPtr || !srcPtr)
            toss("cstrncpy() does not accept NULL strings.");
          if (n6 < 0)
            n6 = target.cstrlen(strPtr) + 1;
          else if (!(n6 > 0))
            return 0;
          const heap = target.heap8u();
          let i4 = 0, ch;
          for (; i4 < n6 && (ch = heap[srcPtr + i4]); ++i4) {
            heap[tgtPtr + i4] = ch;
          }
          if (i4 < n6)
            heap[tgtPtr + i4++] = 0;
          return i4;
        };
        target.jstrToUintArray = (str, addNul = false) => {
          return cache.utf8Encoder.encode(addNul ? str + "\0" : str);
        };
        const __affirmAlloc = (obj, funcName) => {
          if (!(obj.alloc instanceof Function) || !(obj.dealloc instanceof Function)) {
            toss(
              "Object is missing alloc() and/or dealloc() function(s)",
              "required by",
              funcName + "()."
            );
          }
        };
        const __allocCStr = function(jstr, returnWithLength, allocator, funcName) {
          __affirmAlloc(target, funcName);
          if ("string" !== typeof jstr)
            return null;
          if (0) {
            const n6 = target.jstrlen(jstr), ptr = allocator(n6 + 1);
            target.jstrcpy(jstr, target.heap8u(), ptr, n6 + 1, true);
            return returnWithLength ? [ptr, n6] : ptr;
          } else {
            const u3 = cache.utf8Encoder.encode(jstr), ptr = allocator(u3.length + 1), heap = heapWrappers().HEAP8U;
            heap.set(u3, ptr);
            heap[ptr + u3.length] = 0;
            return returnWithLength ? [ptr, u3.length] : ptr;
          }
        };
        target.allocCString = (jstr, returnWithLength = false) => __allocCStr(jstr, returnWithLength, target.alloc, "allocCString()");
        target.scopedAllocPush = function() {
          __affirmAlloc(target, "scopedAllocPush");
          const a3 = [];
          cache.scopedAlloc.push(a3);
          return a3;
        };
        target.scopedAllocPop = function(state) {
          __affirmAlloc(target, "scopedAllocPop");
          const n6 = arguments.length ? cache.scopedAlloc.indexOf(state) : cache.scopedAlloc.length - 1;
          if (n6 < 0)
            toss("Invalid state object for scopedAllocPop().");
          if (0 === arguments.length)
            state = cache.scopedAlloc[n6];
          cache.scopedAlloc.splice(n6, 1);
          for (let p5; p5 = state.pop(); ) {
            if (target.functionEntry(p5)) {
              target.uninstallFunction(p5);
            } else
              target.dealloc(p5);
          }
        };
        target.scopedAlloc = function(n6) {
          if (!cache.scopedAlloc.length) {
            toss("No scopedAllocPush() scope is active.");
          }
          const p5 = target.alloc(n6);
          cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p5);
          return p5;
        };
        Object.defineProperty(target.scopedAlloc, "level", {
          configurable: false,
          enumerable: false,
          get: () => cache.scopedAlloc.length,
          set: () => toss("The 'active' property is read-only.")
        });
        target.scopedAllocCString = (jstr, returnWithLength = false) => __allocCStr(
          jstr,
          returnWithLength,
          target.scopedAlloc,
          "scopedAllocCString()"
        );
        const __allocMainArgv = function(isScoped, list) {
          const pList = target[isScoped ? "scopedAlloc" : "alloc"](
            (list.length + 1) * target.ptrSizeof
          );
          let i4 = 0;
          list.forEach((e6) => {
            target.pokePtr(
              pList + target.ptrSizeof * i4++,
              target[isScoped ? "scopedAllocCString" : "allocCString"]("" + e6)
            );
          });
          target.pokePtr(pList + target.ptrSizeof * i4, 0);
          return pList;
        };
        target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);
        target.allocMainArgv = (list) => __allocMainArgv(false, list);
        target.cArgvToJs = (argc, pArgv) => {
          const list = [];
          for (let i4 = 0; i4 < argc; ++i4) {
            const arg = target.peekPtr(pArgv + target.ptrSizeof * i4);
            list.push(arg ? target.cstrToJs(arg) : null);
          }
          return list;
        };
        target.scopedAllocCall = function(func) {
          target.scopedAllocPush();
          try {
            return func();
          } finally {
            target.scopedAllocPop();
          }
        };
        const __allocPtr = function(howMany, safePtrSize, method) {
          __affirmAlloc(target, method);
          const pIr = safePtrSize ? "i64" : ptrIR;
          let m7 = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
          target.poke(m7, 0, pIr);
          if (1 === howMany) {
            return m7;
          }
          const a3 = [m7];
          for (let i4 = 1; i4 < howMany; ++i4) {
            m7 += safePtrSize ? 8 : ptrSizeof;
            a3[i4] = m7;
            target.poke(m7, 0, pIr);
          }
          return a3;
        };
        target.allocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "alloc");
        target.scopedAllocPtr = (howMany = 1, safePtrSize = true) => __allocPtr(howMany, safePtrSize, "scopedAlloc");
        target.xGet = function(name) {
          return target.exports[name] || toss("Cannot find exported symbol:", name);
        };
        const __argcMismatch = (f5, n6) => toss(f5 + "() requires", n6, "argument(s).");
        target.xCall = function(fname, ...args) {
          const f5 = fname instanceof Function ? fname : target.xGet(fname);
          if (!(f5 instanceof Function))
            toss("Exported symbol", fname, "is not a function.");
          if (f5.length !== args.length)
            __argcMismatch(f5 === fname ? f5.name : fname, f5.length);
          return 2 === arguments.length && Array.isArray(arguments[1]) ? f5.apply(null, arguments[1]) : f5.apply(null, args);
        };
        cache.xWrap = /* @__PURE__ */ Object.create(null);
        cache.xWrap.convert = /* @__PURE__ */ Object.create(null);
        cache.xWrap.convert.arg = /* @__PURE__ */ new Map();
        cache.xWrap.convert.result = /* @__PURE__ */ new Map();
        const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;
        if (target.bigIntEnabled) {
          xArg.set("i64", (i4) => BigInt(i4));
        }
        const __xArgPtr = "i32" === ptrIR ? (i4) => i4 | 0 : (i4) => BigInt(i4) | BigInt(0);
        xArg.set("i32", __xArgPtr).set("i16", (i4) => (i4 | 0) & 65535).set("i8", (i4) => (i4 | 0) & 255).set("f32", (i4) => Number(i4).valueOf()).set("float", xArg.get("f32")).set("f64", xArg.get("f32")).set("double", xArg.get("f64")).set("int", xArg.get("i32")).set("null", (i4) => i4).set(null, xArg.get("null")).set("**", __xArgPtr).set("*", __xArgPtr);
        xResult.set("*", __xArgPtr).set("pointer", __xArgPtr).set("number", (v8) => Number(v8)).set("void", (v8) => void 0).set("null", (v8) => v8).set(null, xResult.get("null"));
        {
          const copyToResult = [
            "i8",
            "i16",
            "i32",
            "int",
            "f32",
            "float",
            "f64",
            "double"
          ];
          if (target.bigIntEnabled)
            copyToResult.push("i64");
          const adaptPtr = xArg.get(ptrIR);
          for (const t5 of copyToResult) {
            xArg.set(t5 + "*", adaptPtr);
            xResult.set(t5 + "*", adaptPtr);
            xResult.set(t5, xArg.get(t5) || toss("Missing arg converter:", t5));
          }
        }
        const __xArgString = function(v8) {
          if ("string" === typeof v8)
            return target.scopedAllocCString(v8);
          return v8 ? __xArgPtr(v8) : null;
        };
        xArg.set("string", __xArgString).set("utf8", __xArgString).set("pointer", __xArgString);
        xResult.set("string", (i4) => target.cstrToJs(i4)).set("utf8", xResult.get("string")).set("string:dealloc", (i4) => {
          try {
            return i4 ? target.cstrToJs(i4) : null;
          } finally {
            target.dealloc(i4);
          }
        }).set("utf8:dealloc", xResult.get("string:dealloc")).set("json", (i4) => JSON.parse(target.cstrToJs(i4))).set("json:dealloc", (i4) => {
          try {
            return i4 ? JSON.parse(target.cstrToJs(i4)) : null;
          } finally {
            target.dealloc(i4);
          }
        });
        const AbstractArgAdapter = class {
          constructor(opt) {
            this.name = opt.name || "unnamed adapter";
          }
          convertArg(v8, argv, argIndex) {
            toss("AbstractArgAdapter must be subclassed.");
          }
        };
        xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
          constructor(opt) {
            super(opt);
            if (xArg.FuncPtrAdapter.warnOnUse) {
              console.warn(
                "xArg.FuncPtrAdapter is an internal-only API",
                "and is not intended to be invoked from",
                "client-level code. Invoked with:",
                opt
              );
            }
            this.name = opt.name || "unnamed";
            this.signature = opt.signature;
            if (opt.contextKey instanceof Function) {
              this.contextKey = opt.contextKey;
              if (!opt.bindScope)
                opt.bindScope = "context";
            }
            this.bindScope = opt.bindScope || toss(
              "FuncPtrAdapter options requires a bindScope (explicit or implied)."
            );
            if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {
              toss(
                "Invalid options.bindScope (" + opt.bindMod + ") for FuncPtrAdapter. Expecting one of: (" + FuncPtrAdapter.bindScopes.join(", ") + ")"
              );
            }
            this.isTransient = "transient" === this.bindScope;
            this.isContext = "context" === this.bindScope;
            this.isPermanent = "permanent" === this.bindScope;
            this.singleton = "singleton" === this.bindScope ? [] : void 0;
            this.callProxy = opt.callProxy instanceof Function ? opt.callProxy : void 0;
          }
          contextKey(argv, argIndex) {
            return this;
          }
          contextMap(key) {
            const cm = this.__cmap || (this.__cmap = /* @__PURE__ */ new Map());
            let rc = cm.get(key);
            if (void 0 === rc)
              cm.set(key, rc = []);
            return rc;
          }
          convertArg(v8, argv, argIndex) {
            let pair = this.singleton;
            if (!pair && this.isContext) {
              pair = this.contextMap(this.contextKey(argv, argIndex));
            }
            if (pair && pair[0] === v8)
              return pair[1];
            if (v8 instanceof Function) {
              if (this.callProxy)
                v8 = this.callProxy(v8);
              const fp = __installFunction(v8, this.signature, this.isTransient);
              if (FuncPtrAdapter.debugFuncInstall) {
                FuncPtrAdapter.debugOut(
                  "FuncPtrAdapter installed",
                  this,
                  this.contextKey(argv, argIndex),
                  "@" + fp,
                  v8
                );
              }
              if (pair) {
                if (pair[1]) {
                  if (FuncPtrAdapter.debugFuncInstall) {
                    FuncPtrAdapter.debugOut(
                      "FuncPtrAdapter uninstalling",
                      this,
                      this.contextKey(argv, argIndex),
                      "@" + pair[1],
                      v8
                    );
                  }
                  try {
                    cache.scopedAlloc[cache.scopedAlloc.length - 1].push(
                      pair[1]
                    );
                  } catch (e6) {
                  }
                }
                pair[0] = v8;
                pair[1] = fp;
              }
              return fp;
            } else if (target.isPtr(v8) || null === v8 || void 0 === v8) {
              if (pair && pair[1] && pair[1] !== v8) {
                if (FuncPtrAdapter.debugFuncInstall) {
                  FuncPtrAdapter.debugOut(
                    "FuncPtrAdapter uninstalling",
                    this,
                    this.contextKey(argv, argIndex),
                    "@" + pair[1],
                    v8
                  );
                }
                try {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);
                } catch (e6) {
                }
                pair[0] = pair[1] = v8 | 0;
              }
              return v8 || 0;
            } else {
              throw new TypeError(
                "Invalid FuncPtrAdapter argument type. Expecting a function pointer or a " + (this.name ? this.name + " " : "") + "function matching signature " + this.signature + "."
              );
            }
          }
        };
        xArg.FuncPtrAdapter.warnOnUse = false;
        xArg.FuncPtrAdapter.debugFuncInstall = false;
        xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);
        xArg.FuncPtrAdapter.bindScopes = [
          "transient",
          "context",
          "singleton",
          "permanent"
        ];
        const __xArgAdapterCheck = (t5) => xArg.get(t5) || toss("Argument adapter not found:", t5);
        const __xResultAdapterCheck = (t5) => xResult.get(t5) || toss("Result adapter not found:", t5);
        cache.xWrap.convertArg = (t5, ...args) => __xArgAdapterCheck(t5)(...args);
        cache.xWrap.convertArgNoCheck = (t5, ...args) => xArg.get(t5)(...args);
        cache.xWrap.convertResult = (t5, v8) => null === t5 ? v8 : t5 ? __xResultAdapterCheck(t5)(v8) : void 0;
        cache.xWrap.convertResultNoCheck = (t5, v8) => null === t5 ? v8 : t5 ? xResult.get(t5)(v8) : void 0;
        target.xWrap = function(fArg, resultType, ...argTypes) {
          if (3 === arguments.length && Array.isArray(arguments[2])) {
            argTypes = arguments[2];
          }
          if (target.isPtr(fArg)) {
            fArg = target.functionEntry(fArg) || toss("Function pointer not found in WASM function table.");
          }
          const fIsFunc = fArg instanceof Function;
          const xf = fIsFunc ? fArg : target.xGet(fArg);
          if (fIsFunc)
            fArg = xf.name || "unnamed function";
          if (argTypes.length !== xf.length)
            __argcMismatch(fArg, xf.length);
          if (null === resultType && 0 === xf.length) {
            return xf;
          }
          if (void 0 !== resultType && null !== resultType)
            __xResultAdapterCheck(resultType);
          for (const t5 of argTypes) {
            if (t5 instanceof AbstractArgAdapter)
              xArg.set(t5, (...args) => t5.convertArg(...args));
            else
              __xArgAdapterCheck(t5);
          }
          const cxw = cache.xWrap;
          if (0 === xf.length) {
            return (...args) => args.length ? __argcMismatch(fArg, xf.length) : cxw.convertResult(resultType, xf.call(null));
          }
          return function(...args) {
            if (args.length !== xf.length)
              __argcMismatch(fArg, xf.length);
            const scope = target.scopedAllocPush();
            try {
              let i4 = 0;
              for (; i4 < args.length; ++i4)
                args[i4] = cxw.convertArgNoCheck(argTypes[i4], args[i4], args, i4);
              return cxw.convertResultNoCheck(resultType, xf.apply(null, args));
            } finally {
              target.scopedAllocPop(scope);
            }
          };
        };
        const __xAdapter = function(func, argc, typeName, adapter, modeName, xcvPart) {
          if ("string" === typeof typeName) {
            if (1 === argc)
              return xcvPart.get(typeName);
            else if (2 === argc) {
              if (!adapter) {
                delete xcvPart.get(typeName);
                return func;
              } else if (!(adapter instanceof Function)) {
                toss(modeName, "requires a function argument.");
              }
              xcvPart.set(typeName, adapter);
              return func;
            }
          }
          toss("Invalid arguments to", modeName);
        };
        target.xWrap.resultAdapter = function f5(typeName, adapter) {
          return __xAdapter(
            f5,
            arguments.length,
            typeName,
            adapter,
            "resultAdapter()",
            xResult
          );
        };
        target.xWrap.argAdapter = function f5(typeName, adapter) {
          return __xAdapter(
            f5,
            arguments.length,
            typeName,
            adapter,
            "argAdapter()",
            xArg
          );
        };
        target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;
        target.xCallWrapped = function(fArg, resultType, argTypes, ...args) {
          if (Array.isArray(arguments[3]))
            args = arguments[3];
          return target.xWrap(fArg, resultType, argTypes || []).apply(null, args || []);
        };
        target.xWrap.testConvertArg = cache.xWrap.convertArg;
        target.xWrap.testConvertResult = cache.xWrap.convertResult;
        return target;
      };
      globalThis.WhWasmUtilInstaller.yawl = function(config3) {
        const wfetch = () => fetch(config3.uri, { credentials: "same-origin" });
        const wui = this;
        const finalThen = function(arg) {
          if (config3.wasmUtilTarget) {
            const toss = (...args) => {
              throw new Error(args.join(" "));
            };
            const tgt = config3.wasmUtilTarget;
            tgt.module = arg.module;
            tgt.instance = arg.instance;
            if (!tgt.instance.exports.memory) {
              tgt.memory = config3.imports && config3.imports.env && config3.imports.env.memory || toss("Missing 'memory' object!");
            }
            if (!tgt.alloc && arg.instance.exports.malloc) {
              const exports = arg.instance.exports;
              tgt.alloc = function(n6) {
                return exports.malloc(n6) || toss("Allocation of", n6, "bytes failed.");
              };
              tgt.dealloc = function(m7) {
                exports.free(m7);
              };
            }
            wui(tgt);
          }
          if (config3.onload)
            config3.onload(arg, config3);
          return arg;
        };
        const loadWasm = WebAssembly.instantiateStreaming ? function loadWasmStreaming() {
          return WebAssembly.instantiateStreaming(
            wfetch(),
            config3.imports || {}
          ).then(finalThen);
        } : function loadWasmOldSchool() {
          return wfetch().then((response) => response.arrayBuffer()).then(
            (bytes) => WebAssembly.instantiate(bytes, config3.imports || {})
          ).then(finalThen);
        };
        return loadWasm;
      }.bind(globalThis.WhWasmUtilInstaller);
      "use strict";
      globalThis.Jaccwabyt = function StructBinderFactory(config3) {
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        if (!(config3.heap instanceof WebAssembly.Memory) && !(config3.heap instanceof Function)) {
          toss(
            "config.heap must be WebAssembly.Memory instance or a function."
          );
        }
        ["alloc", "dealloc"].forEach(function(k6) {
          config3[k6] instanceof Function || toss("Config option '" + k6 + "' must be a function.");
        });
        const SBF = StructBinderFactory;
        const heap = config3.heap instanceof Function ? config3.heap : () => new Uint8Array(config3.heap.buffer), alloc = config3.alloc, dealloc = config3.dealloc, log3 = config3.log || console.log.bind(console), memberPrefix = config3.memberPrefix || "", memberSuffix = config3.memberSuffix || "", bigIntEnabled = void 0 === config3.bigIntEnabled ? !!globalThis["BigInt64Array"] : !!config3.bigIntEnabled, BigInt2 = globalThis["BigInt"], BigInt64Array2 = globalThis["BigInt64Array"], ptrSizeof = config3.ptrSizeof || 4, ptrIR = config3.ptrIR || "i32";
        if (!SBF.debugFlags) {
          SBF.__makeDebugFlags = function(deriveFrom = null) {
            if (deriveFrom && deriveFrom.__flags)
              deriveFrom = deriveFrom.__flags;
            const f5 = function f6(flags) {
              if (0 === arguments.length) {
                return f6.__flags;
              }
              if (flags < 0) {
                delete f6.__flags.getter;
                delete f6.__flags.setter;
                delete f6.__flags.alloc;
                delete f6.__flags.dealloc;
              } else {
                f6.__flags.getter = 0 !== (1 & flags);
                f6.__flags.setter = 0 !== (2 & flags);
                f6.__flags.alloc = 0 !== (4 & flags);
                f6.__flags.dealloc = 0 !== (8 & flags);
              }
              return f6._flags;
            };
            Object.defineProperty(f5, "__flags", {
              iterable: false,
              writable: false,
              value: Object.create(deriveFrom)
            });
            if (!deriveFrom)
              f5(0);
            return f5;
          };
          SBF.debugFlags = SBF.__makeDebugFlags();
        }
        const isLittleEndian = function() {
          const buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] === 256;
        }();
        const isFuncSig = (s3) => "(" === s3[1];
        const isPtrSig = (s3) => "p" === s3 || "P" === s3;
        const isAutoPtrSig = (s3) => "P" === s3;
        const sigLetter = (s3) => isFuncSig(s3) ? "p" : s3[0];
        const sigIR = function(s3) {
          switch (sigLetter(s3)) {
            case "c":
            case "C":
              return "i8";
            case "i":
              return "i32";
            case "p":
            case "P":
            case "s":
              return ptrIR;
            case "j":
              return "i64";
            case "f":
              return "float";
            case "d":
              return "double";
          }
          toss("Unhandled signature IR:", s3);
        };
        const affirmBigIntArray = BigInt64Array2 ? () => true : () => toss("BigInt64Array is not available.");
        const sigDVGetter = function(s3) {
          switch (sigLetter(s3)) {
            case "p":
            case "P":
            case "s": {
              switch (ptrSizeof) {
                case 4:
                  return "getInt32";
                case 8:
                  return affirmBigIntArray() && "getBigInt64";
              }
              break;
            }
            case "i":
              return "getInt32";
            case "c":
              return "getInt8";
            case "C":
              return "getUint8";
            case "j":
              return affirmBigIntArray() && "getBigInt64";
            case "f":
              return "getFloat32";
            case "d":
              return "getFloat64";
          }
          toss("Unhandled DataView getter for signature:", s3);
        };
        const sigDVSetter = function(s3) {
          switch (sigLetter(s3)) {
            case "p":
            case "P":
            case "s": {
              switch (ptrSizeof) {
                case 4:
                  return "setInt32";
                case 8:
                  return affirmBigIntArray() && "setBigInt64";
              }
              break;
            }
            case "i":
              return "setInt32";
            case "c":
              return "setInt8";
            case "C":
              return "setUint8";
            case "j":
              return affirmBigIntArray() && "setBigInt64";
            case "f":
              return "setFloat32";
            case "d":
              return "setFloat64";
          }
          toss("Unhandled DataView setter for signature:", s3);
        };
        const sigDVSetWrapper = function(s3) {
          switch (sigLetter(s3)) {
            case "i":
            case "f":
            case "c":
            case "C":
            case "d":
              return Number;
            case "j":
              return affirmBigIntArray() && BigInt2;
            case "p":
            case "P":
            case "s":
              switch (ptrSizeof) {
                case 4:
                  return Number;
                case 8:
                  return affirmBigIntArray() && BigInt2;
              }
              break;
          }
          toss("Unhandled DataView set wrapper for signature:", s3);
        };
        const sPropName = (s3, k6) => s3 + "::" + k6;
        const __propThrowOnSet = function(structName, propName) {
          return () => toss(sPropName(structName, propName), "is read-only.");
        };
        const __instancePointerMap = /* @__PURE__ */ new WeakMap();
        const xPtrPropName = "(pointer-is-external)";
        const __freeStruct = function(ctor, obj, m7) {
          if (!m7)
            m7 = __instancePointerMap.get(obj);
          if (m7) {
            __instancePointerMap.delete(obj);
            if (Array.isArray(obj.ondispose)) {
              let x6;
              while (x6 = obj.ondispose.shift()) {
                try {
                  if (x6 instanceof Function)
                    x6.call(obj);
                  else if (x6 instanceof StructType)
                    x6.dispose();
                  else if ("number" === typeof x6)
                    dealloc(x6);
                } catch (e6) {
                  console.warn(
                    "ondispose() for",
                    ctor.structName,
                    "@",
                    m7,
                    "threw. NOT propagating it.",
                    e6
                  );
                }
              }
            } else if (obj.ondispose instanceof Function) {
              try {
                obj.ondispose();
              } catch (e6) {
                console.warn(
                  "ondispose() for",
                  ctor.structName,
                  "@",
                  m7,
                  "threw. NOT propagating it.",
                  e6
                );
              }
            }
            delete obj.ondispose;
            if (ctor.debugFlags.__flags.dealloc) {
              log3(
                "debug.dealloc:",
                obj[xPtrPropName] ? "EXTERNAL" : "",
                ctor.structName,
                "instance:",
                ctor.structInfo.sizeof,
                "bytes @" + m7
              );
            }
            if (!obj[xPtrPropName])
              dealloc(m7);
          }
        };
        const rop = (v8) => {
          return {
            configurable: false,
            writable: false,
            iterable: false,
            value: v8
          };
        };
        const __allocStruct = function(ctor, obj, m7) {
          let fill = !m7;
          if (m7)
            Object.defineProperty(obj, xPtrPropName, rop(m7));
          else {
            m7 = alloc(ctor.structInfo.sizeof);
            if (!m7)
              toss("Allocation of", ctor.structName, "structure failed.");
          }
          try {
            if (ctor.debugFlags.__flags.alloc) {
              log3(
                "debug.alloc:",
                fill ? "" : "EXTERNAL",
                ctor.structName,
                "instance:",
                ctor.structInfo.sizeof,
                "bytes @" + m7
              );
            }
            if (fill)
              heap().fill(0, m7, m7 + ctor.structInfo.sizeof);
            __instancePointerMap.set(obj, m7);
          } catch (e6) {
            __freeStruct(ctor, obj, m7);
            throw e6;
          }
        };
        const __memoryDump = function() {
          const p5 = this.pointer;
          return p5 ? new Uint8Array(heap().slice(p5, p5 + this.structInfo.sizeof)) : null;
        };
        const __memberKey = (k6) => memberPrefix + k6 + memberSuffix;
        const __memberKeyProp = rop(__memberKey);
        const __lookupMember = function(structInfo, memberName, tossIfNotFound = true) {
          let m7 = structInfo.members[memberName];
          if (!m7 && (memberPrefix || memberSuffix)) {
            for (const v8 of Object.values(structInfo.members)) {
              if (v8.key === memberName) {
                m7 = v8;
                break;
              }
            }
            if (!m7 && tossIfNotFound) {
              toss(
                sPropName(structInfo.name, memberName),
                "is not a mapped struct member."
              );
            }
          }
          return m7;
        };
        const __memberSignature = function f5(obj, memberName, emscriptenFormat = false) {
          if (!f5._)
            f5._ = (x6) => x6.replace(/[^vipPsjrdcC]/g, "").replace(/[pPscC]/g, "i");
          const m7 = __lookupMember(obj.structInfo, memberName, true);
          return emscriptenFormat ? f5._(m7.signature) : m7.signature;
        };
        const __ptrPropDescriptor = {
          configurable: false,
          enumerable: false,
          get: function() {
            return __instancePointerMap.get(this);
          },
          set: () => toss("Cannot assign the 'pointer' property of a struct.")
        };
        const __structMemberKeys = rop(function() {
          const a3 = [];
          for (const k6 of Object.keys(this.structInfo.members)) {
            a3.push(this.memberKey(k6));
          }
          return a3;
        });
        const __utf8Decoder = new TextDecoder("utf-8");
        const __utf8Encoder = new TextEncoder();
        const __SAB = "undefined" === typeof SharedArrayBuffer ? function() {
        } : SharedArrayBuffer;
        const __utf8Decode = function(arrayBuffer, begin, end) {
          return __utf8Decoder.decode(
            arrayBuffer.buffer instanceof __SAB ? arrayBuffer.slice(begin, end) : arrayBuffer.subarray(begin, end)
          );
        };
        const __memberIsString = function(obj, memberName, tossIfNotFound = false) {
          const m7 = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
          return m7 && 1 === m7.signature.length && "s" === m7.signature[0] ? m7 : false;
        };
        const __affirmCStringSignature = function(member) {
          if ("s" === member.signature)
            return;
          toss(
            "Invalid member type signature for C-string value:",
            JSON.stringify(member)
          );
        };
        const __memberToJsString = function f5(obj, memberName) {
          const m7 = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m7);
          const addr = obj[m7.key];
          if (!addr)
            return null;
          let pos = addr;
          const mem = heap();
          for (; mem[pos] !== 0; ++pos) {
          }
          return addr === pos ? "" : __utf8Decode(mem, addr, pos);
        };
        const __addOnDispose = function(obj, ...v8) {
          if (obj.ondispose) {
            if (!Array.isArray(obj.ondispose)) {
              obj.ondispose = [obj.ondispose];
            }
          } else {
            obj.ondispose = [];
          }
          obj.ondispose.push(...v8);
        };
        const __allocCString = function(str) {
          const u3 = __utf8Encoder.encode(str);
          const mem = alloc(u3.length + 1);
          if (!mem)
            toss("Allocation error while duplicating string:", str);
          const h7 = heap();
          h7.set(u3, mem);
          h7[mem + u3.length] = 0;
          return mem;
        };
        const __setMemberCString = function(obj, memberName, str) {
          const m7 = __lookupMember(obj.structInfo, memberName, true);
          __affirmCStringSignature(m7);
          const mem = __allocCString(str);
          obj[m7.key] = mem;
          __addOnDispose(obj, mem);
          return obj;
        };
        const StructType = function ctor(structName, structInfo) {
          if (arguments[2] !== rop) {
            toss(
              "Do not call the StructType constructor",
              "from client-level code."
            );
          }
          Object.defineProperties(this, {
            structName: rop(structName),
            structInfo: rop(structInfo)
          });
        };
        StructType.prototype = Object.create(null, {
          dispose: rop(function() {
            __freeStruct(this.constructor, this);
          }),
          lookupMember: rop(function(memberName, tossIfNotFound = true) {
            return __lookupMember(this.structInfo, memberName, tossIfNotFound);
          }),
          memberToJsString: rop(function(memberName) {
            return __memberToJsString(this, memberName);
          }),
          memberIsString: rop(function(memberName, tossIfNotFound = true) {
            return __memberIsString(this, memberName, tossIfNotFound);
          }),
          memberKey: __memberKeyProp,
          memberKeys: __structMemberKeys,
          memberSignature: rop(function(memberName, emscriptenFormat = false) {
            return __memberSignature(this, memberName, emscriptenFormat);
          }),
          memoryDump: rop(__memoryDump),
          pointer: __ptrPropDescriptor,
          setMemberCString: rop(function(memberName, str) {
            return __setMemberCString(this, memberName, str);
          })
        });
        Object.assign(StructType.prototype, {
          addOnDispose: function(...v8) {
            __addOnDispose(this, ...v8);
            return this;
          }
        });
        Object.defineProperties(StructType, {
          allocCString: rop(__allocCString),
          isA: rop((v8) => v8 instanceof StructType),
          hasExternalPointer: rop(
            (v8) => v8 instanceof StructType && !!v8[xPtrPropName]
          ),
          memberKey: __memberKeyProp
        });
        const isNumericValue = (v8) => Number.isFinite(v8) || v8 instanceof (BigInt2 || Number);
        const makeMemberWrapper = function f5(ctor, name, descr) {
          if (!f5._) {
            f5._ = { getters: {}, setters: {}, sw: {} };
            const a3 = ["i", "c", "C", "p", "P", "s", "f", "d", "v()"];
            if (bigIntEnabled)
              a3.push("j");
            a3.forEach(function(v8) {
              f5._.getters[v8] = sigDVGetter(v8);
              f5._.setters[v8] = sigDVSetter(v8);
              f5._.sw[v8] = sigDVSetWrapper(v8);
            });
            const rxSig1 = /^[ipPsjfdcC]$/, rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
            f5.sigCheck = function(obj, name2, key2, sig) {
              if (Object.prototype.hasOwnProperty.call(obj, key2)) {
                toss(obj.structName, "already has a property named", key2 + ".");
              }
              rxSig1.test(sig) || rxSig2.test(sig) || toss(
                "Malformed signature for",
                sPropName(obj.structName, name2) + ":",
                sig
              );
            };
          }
          const key = ctor.memberKey(name);
          f5.sigCheck(ctor.prototype, name, key, descr.signature);
          descr.key = key;
          descr.name = name;
          const sigGlyph = sigLetter(descr.signature);
          const xPropName = sPropName(ctor.prototype.structName, key);
          const dbg = ctor.prototype.debugFlags.__flags;
          const prop = /* @__PURE__ */ Object.create(null);
          prop.configurable = false;
          prop.enumerable = false;
          prop.get = function() {
            if (dbg.getter) {
              log3(
                "debug.getter:",
                f5._.getters[sigGlyph],
                "for",
                sigIR(sigGlyph),
                xPropName,
                "@",
                this.pointer,
                "+",
                descr.offset,
                "sz",
                descr.sizeof
              );
            }
            let rc = new DataView(
              heap().buffer,
              this.pointer + descr.offset,
              descr.sizeof
            )[f5._.getters[sigGlyph]](0, isLittleEndian);
            if (dbg.getter)
              log3("debug.getter:", xPropName, "result =", rc);
            return rc;
          };
          if (descr.readOnly) {
            prop.set = __propThrowOnSet(ctor.prototype.structName, key);
          } else {
            prop.set = function(v8) {
              if (dbg.setter) {
                log3(
                  "debug.setter:",
                  f5._.setters[sigGlyph],
                  "for",
                  sigIR(sigGlyph),
                  xPropName,
                  "@",
                  this.pointer,
                  "+",
                  descr.offset,
                  "sz",
                  descr.sizeof,
                  v8
                );
              }
              if (!this.pointer) {
                toss("Cannot set struct property on disposed instance.");
              }
              if (null === v8)
                v8 = 0;
              else
                while (!isNumericValue(v8)) {
                  if (isAutoPtrSig(descr.signature) && v8 instanceof StructType) {
                    v8 = v8.pointer || 0;
                    if (dbg.setter)
                      log3("debug.setter:", xPropName, "resolved to", v8);
                    break;
                  }
                  toss("Invalid value for pointer-type", xPropName + ".");
                }
              new DataView(
                heap().buffer,
                this.pointer + descr.offset,
                descr.sizeof
              )[f5._.setters[sigGlyph]](0, f5._.sw[sigGlyph](v8), isLittleEndian);
            };
          }
          Object.defineProperty(ctor.prototype, key, prop);
        };
        const StructBinder = function StructBinder2(structName, structInfo) {
          if (1 === arguments.length) {
            structInfo = structName;
            structName = structInfo.name;
          } else if (!structInfo.name) {
            structInfo.name = structName;
          }
          if (!structName)
            toss("Struct name is required.");
          let lastMember = false;
          Object.keys(structInfo.members).forEach((k6) => {
            const m7 = structInfo.members[k6];
            if (!m7.sizeof)
              toss(structName, "member", k6, "is missing sizeof.");
            else if (m7.sizeof === 1) {
              m7.signature === "c" || m7.signature === "C" || toss(
                "Unexpected sizeof==1 member",
                sPropName(structInfo.name, k6),
                "with signature",
                m7.signature
              );
            } else {
              if (0 !== m7.sizeof % 4) {
                console.warn(
                  "Invalid struct member description =",
                  m7,
                  "from",
                  structInfo
                );
                toss(
                  structName,
                  "member",
                  k6,
                  "sizeof is not aligned. sizeof=" + m7.sizeof
                );
              }
              if (0 !== m7.offset % 4) {
                console.warn(
                  "Invalid struct member description =",
                  m7,
                  "from",
                  structInfo
                );
                toss(
                  structName,
                  "member",
                  k6,
                  "offset is not aligned. offset=" + m7.offset
                );
              }
            }
            if (!lastMember || lastMember.offset < m7.offset)
              lastMember = m7;
          });
          if (!lastMember)
            toss("No member property descriptions found.");
          else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {
            toss(
              "Invalid struct config:",
              structName,
              "max member offset (" + lastMember.offset + ") ",
              "extends past end of struct (sizeof=" + structInfo.sizeof + ")."
            );
          }
          const debugFlags = rop(SBF.__makeDebugFlags(StructBinder2.debugFlags));
          const StructCtor = function StructCtor2(externalMemory) {
            if (!(this instanceof StructCtor2)) {
              toss(
                "The",
                structName,
                "constructor may only be called via 'new'."
              );
            } else if (arguments.length) {
              if (externalMemory !== (externalMemory | 0) || externalMemory <= 0) {
                toss("Invalid pointer value for", structName, "constructor.");
              }
              __allocStruct(StructCtor2, this, externalMemory);
            } else {
              __allocStruct(StructCtor2, this);
            }
          };
          Object.defineProperties(StructCtor, {
            debugFlags,
            isA: rop((v8) => v8 instanceof StructCtor),
            memberKey: __memberKeyProp,
            memberKeys: __structMemberKeys,
            methodInfoForKey: rop(function(mKey) {
            }),
            structInfo: rop(structInfo),
            structName: rop(structName)
          });
          StructCtor.prototype = new StructType(structName, structInfo, rop);
          Object.defineProperties(StructCtor.prototype, {
            debugFlags,
            constructor: rop(StructCtor)
          });
          Object.keys(structInfo.members).forEach(
            (name) => makeMemberWrapper(StructCtor, name, structInfo.members[name])
          );
          return StructCtor;
        };
        StructBinder.StructType = StructType;
        StructBinder.config = config3;
        StructBinder.allocCString = __allocCString;
        if (!StructBinder.debugFlags) {
          StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
        }
        return StructBinder;
      };
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        "use strict";
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        const toss3 = sqlite3.SQLite3Error.toss;
        const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
        globalThis.WhWasmUtilInstaller(wasm);
        delete globalThis.WhWasmUtilInstaller;
        if (0) {
          const dealloc = wasm.exports[sqlite3.config.deallocExportName];
          const nFunc = wasm.functionTable().length;
          let i4;
          for (i4 = 0; i4 < nFunc; ++i4) {
            const e6 = wasm.functionEntry(i4);
            if (dealloc === e6) {
              capi.SQLITE_WASM_DEALLOC = i4;
              break;
            }
          }
          if (dealloc !== wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              "Internal error: cannot find function pointer for SQLITE_WASM_DEALLOC."
            );
          }
        }
        wasm.bindingSignatures = [
          ["sqlite3_aggregate_context", "void*", "sqlite3_context*", "int"],
          ["sqlite3_bind_double", "int", "sqlite3_stmt*", "int", "f64"],
          ["sqlite3_bind_int", "int", "sqlite3_stmt*", "int", "int"],
          ["sqlite3_bind_null", void 0, "sqlite3_stmt*", "int"],
          ["sqlite3_bind_parameter_count", "int", "sqlite3_stmt*"],
          ["sqlite3_bind_parameter_index", "int", "sqlite3_stmt*", "string"],
          [
            "sqlite3_bind_pointer",
            "int",
            "sqlite3_stmt*",
            "int",
            "*",
            "string:static",
            "*"
          ],
          [
            "sqlite3_busy_handler",
            "int",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                signature: "i(pi)",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_busy_timeout", "int", "sqlite3*", "int"],
          ["sqlite3_changes", "int", "sqlite3*"],
          ["sqlite3_clear_bindings", "int", "sqlite3_stmt*"],
          ["sqlite3_collation_needed", "int", "sqlite3*", "*", "*"],
          ["sqlite3_column_blob", "*", "sqlite3_stmt*", "int"],
          ["sqlite3_column_bytes", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_count", "int", "sqlite3_stmt*"],
          ["sqlite3_column_double", "f64", "sqlite3_stmt*", "int"],
          ["sqlite3_column_int", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_name", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_text", "string", "sqlite3_stmt*", "int"],
          ["sqlite3_column_type", "int", "sqlite3_stmt*", "int"],
          ["sqlite3_column_value", "sqlite3_value*", "sqlite3_stmt*", "int"],
          [
            "sqlite3_commit_hook",
            "void*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_commit_hook",
                signature: "i(p)",
                contextKey: (argv) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_compileoption_get", "string", "int"],
          ["sqlite3_compileoption_used", "int", "string"],
          ["sqlite3_complete", "int", "string:flexible"],
          ["sqlite3_context_db_handle", "sqlite3*", "sqlite3_context*"],
          ["sqlite3_data_count", "int", "sqlite3_stmt*"],
          ["sqlite3_db_filename", "string", "sqlite3*", "string"],
          ["sqlite3_db_handle", "sqlite3*", "sqlite3_stmt*"],
          ["sqlite3_db_name", "string", "sqlite3*", "int"],
          ["sqlite3_db_status", "int", "sqlite3*", "int", "*", "*", "int"],
          ["sqlite3_errcode", "int", "sqlite3*"],
          ["sqlite3_errmsg", "string", "sqlite3*"],
          ["sqlite3_error_offset", "int", "sqlite3*"],
          ["sqlite3_errstr", "string", "int"],
          [
            "sqlite3_exec",
            "int",
            [
              "sqlite3*",
              "string:flexible",
              new wasm.xWrap.FuncPtrAdapter({
                signature: "i(pipp)",
                bindScope: "transient",
                callProxy: (callback) => {
                  let aNames;
                  return (pVoid, nCols, pColVals, pColNames) => {
                    try {
                      const aVals = wasm.cArgvToJs(nCols, pColVals);
                      if (!aNames)
                        aNames = wasm.cArgvToJs(nCols, pColNames);
                      return callback(aVals, aNames) | 0;
                    } catch (e6) {
                      return e6.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }
              }),
              "*",
              "**"
            ]
          ],
          ["sqlite3_expanded_sql", "string", "sqlite3_stmt*"],
          ["sqlite3_extended_errcode", "int", "sqlite3*"],
          ["sqlite3_extended_result_codes", "int", "sqlite3*", "int"],
          ["sqlite3_file_control", "int", "sqlite3*", "string", "int", "*"],
          ["sqlite3_finalize", "int", "sqlite3_stmt*"],
          ["sqlite3_free", void 0, "*"],
          ["sqlite3_get_autocommit", "int", "sqlite3*"],
          ["sqlite3_get_auxdata", "*", "sqlite3_context*", "int"],
          ["sqlite3_initialize", void 0],
          ["sqlite3_keyword_count", "int"],
          ["sqlite3_keyword_name", "int", ["int", "**", "*"]],
          ["sqlite3_keyword_check", "int", ["string", "int"]],
          ["sqlite3_libversion", "string"],
          ["sqlite3_libversion_number", "int"],
          ["sqlite3_limit", "int", ["sqlite3*", "int", "int"]],
          ["sqlite3_malloc", "*", "int"],
          ["sqlite3_open", "int", "string", "*"],
          ["sqlite3_open_v2", "int", "string", "*", "int", "string"],
          [
            "sqlite3_progress_handler",
            void 0,
            [
              "sqlite3*",
              "int",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xProgressHandler",
                signature: "i(p)",
                bindScope: "context",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_realloc", "*", "*", "int"],
          ["sqlite3_reset", "int", "sqlite3_stmt*"],
          [
            "sqlite3_result_blob",
            void 0,
            "sqlite3_context*",
            "*",
            "int",
            "*"
          ],
          ["sqlite3_result_double", void 0, "sqlite3_context*", "f64"],
          [
            "sqlite3_result_error",
            void 0,
            "sqlite3_context*",
            "string",
            "int"
          ],
          ["sqlite3_result_error_code", void 0, "sqlite3_context*", "int"],
          ["sqlite3_result_error_nomem", void 0, "sqlite3_context*"],
          ["sqlite3_result_error_toobig", void 0, "sqlite3_context*"],
          ["sqlite3_result_int", void 0, "sqlite3_context*", "int"],
          ["sqlite3_result_null", void 0, "sqlite3_context*"],
          [
            "sqlite3_result_pointer",
            void 0,
            "sqlite3_context*",
            "*",
            "string:static",
            "*"
          ],
          ["sqlite3_result_subtype", void 0, "sqlite3_value*", "int"],
          [
            "sqlite3_result_text",
            void 0,
            "sqlite3_context*",
            "string",
            "int",
            "*"
          ],
          ["sqlite3_result_zeroblob", void 0, "sqlite3_context*", "int"],
          [
            "sqlite3_rollback_hook",
            "void*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_rollback_hook",
                signature: "v(p)",
                contextKey: (argv) => argv[0]
              }),
              "*"
            ]
          ],
          [
            "sqlite3_set_authorizer",
            "int",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_set_authorizer::xAuth",
                signature: "i(pissss)",
                contextKey: (argv, argIndex) => argv[0],
                callProxy: (callback) => {
                  return (pV, iCode, s0, s1, s22, s3) => {
                    try {
                      s0 = s0 && wasm.cstrToJs(s0);
                      s1 = s1 && wasm.cstrToJs(s1);
                      s22 = s22 && wasm.cstrToJs(s22);
                      s3 = s3 && wasm.cstrToJs(s3);
                      return callback(pV, iCode, s0, s1, s22, s3) || 0;
                    } catch (e6) {
                      return e6.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                }
              }),
              "*"
            ]
          ],
          [
            "sqlite3_set_auxdata",
            void 0,
            [
              "sqlite3_context*",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroyAuxData",
                signature: "v(*)",
                contextKey: (argv, argIndex) => argv[0]
              })
            ]
          ],
          ["sqlite3_shutdown", void 0],
          ["sqlite3_sourceid", "string"],
          ["sqlite3_sql", "string", "sqlite3_stmt*"],
          ["sqlite3_status", "int", "int", "*", "*", "int"],
          ["sqlite3_step", "int", "sqlite3_stmt*"],
          ["sqlite3_stmt_isexplain", "int", ["sqlite3_stmt*"]],
          ["sqlite3_stmt_readonly", "int", ["sqlite3_stmt*"]],
          ["sqlite3_stmt_status", "int", "sqlite3_stmt*", "int", "int"],
          ["sqlite3_strglob", "int", "string", "string"],
          ["sqlite3_stricmp", "int", "string", "string"],
          ["sqlite3_strlike", "int", "string", "string", "int"],
          ["sqlite3_strnicmp", "int", "string", "string", "int"],
          [
            "sqlite3_table_column_metadata",
            "int",
            "sqlite3*",
            "string",
            "string",
            "string",
            "**",
            "**",
            "*",
            "*",
            "*"
          ],
          ["sqlite3_total_changes", "int", "sqlite3*"],
          [
            "sqlite3_trace_v2",
            "int",
            [
              "sqlite3*",
              "int",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_trace_v2::callback",
                signature: "i(ippp)",
                contextKey: (argv, argIndex) => argv[0]
              }),
              "*"
            ]
          ],
          ["sqlite3_txn_state", "int", ["sqlite3*", "string"]],
          ["sqlite3_uri_boolean", "int", "sqlite3_filename", "string", "int"],
          ["sqlite3_uri_key", "string", "sqlite3_filename", "int"],
          ["sqlite3_uri_parameter", "string", "sqlite3_filename", "string"],
          ["sqlite3_user_data", "void*", "sqlite3_context*"],
          ["sqlite3_value_blob", "*", "sqlite3_value*"],
          ["sqlite3_value_bytes", "int", "sqlite3_value*"],
          ["sqlite3_value_double", "f64", "sqlite3_value*"],
          ["sqlite3_value_dup", "sqlite3_value*", "sqlite3_value*"],
          ["sqlite3_value_free", void 0, "sqlite3_value*"],
          ["sqlite3_value_frombind", "int", "sqlite3_value*"],
          ["sqlite3_value_int", "int", "sqlite3_value*"],
          ["sqlite3_value_nochange", "int", "sqlite3_value*"],
          ["sqlite3_value_numeric_type", "int", "sqlite3_value*"],
          ["sqlite3_value_pointer", "*", "sqlite3_value*", "string:static"],
          ["sqlite3_value_subtype", "int", "sqlite3_value*"],
          ["sqlite3_value_text", "string", "sqlite3_value*"],
          ["sqlite3_value_type", "int", "sqlite3_value*"],
          ["sqlite3_vfs_find", "*", "string"],
          ["sqlite3_vfs_register", "int", "sqlite3_vfs*", "int"],
          ["sqlite3_vfs_unregister", "int", "sqlite3_vfs*"]
        ];
        if (false) {
          wasm.bindingSignatures.push([
            "sqlite3_normalized_sql",
            "string",
            "sqlite3_stmt*"
          ]);
        }
        wasm.bindingSignatures.int64 = [
          ["sqlite3_bind_int64", "int", ["sqlite3_stmt*", "int", "i64"]],
          ["sqlite3_changes64", "i64", ["sqlite3*"]],
          ["sqlite3_column_int64", "i64", ["sqlite3_stmt*", "int"]],
          [
            "sqlite3_create_module",
            "int",
            ["sqlite3*", "string", "sqlite3_module*", "*"]
          ],
          [
            "sqlite3_create_module_v2",
            "int",
            ["sqlite3*", "string", "sqlite3_module*", "*", "*"]
          ],
          ["sqlite3_declare_vtab", "int", ["sqlite3*", "string:flexible"]],
          [
            "sqlite3_deserialize",
            "int",
            "sqlite3*",
            "string",
            "*",
            "i64",
            "i64",
            "int"
          ],
          ["sqlite3_drop_modules", "int", ["sqlite3*", "**"]],
          ["sqlite3_last_insert_rowid", "i64", ["sqlite3*"]],
          ["sqlite3_malloc64", "*", "i64"],
          ["sqlite3_msize", "i64", "*"],
          ["sqlite3_overload_function", "int", ["sqlite3*", "string", "int"]],
          ["sqlite3_preupdate_blobwrite", "int", "sqlite3*"],
          ["sqlite3_preupdate_count", "int", "sqlite3*"],
          ["sqlite3_preupdate_depth", "int", "sqlite3*"],
          [
            "sqlite3_preupdate_hook",
            "*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_preupdate_hook",
                signature: "v(ppippjj)",
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p5, db, op, zDb, zTbl, iKey1, iKey2) => {
                    callback(
                      p5,
                      db,
                      op,
                      wasm.cstrToJs(zDb),
                      wasm.cstrToJs(zTbl),
                      iKey1,
                      iKey2
                    );
                  };
                }
              }),
              "*"
            ]
          ],
          ["sqlite3_preupdate_new", "int", ["sqlite3*", "int", "**"]],
          ["sqlite3_preupdate_old", "int", ["sqlite3*", "int", "**"]],
          ["sqlite3_realloc64", "*", "*", "i64"],
          ["sqlite3_result_int64", void 0, "*", "i64"],
          ["sqlite3_result_zeroblob64", "int", "*", "i64"],
          ["sqlite3_serialize", "*", "sqlite3*", "string", "*", "int"],
          ["sqlite3_set_last_insert_rowid", void 0, ["sqlite3*", "i64"]],
          ["sqlite3_status64", "int", "int", "*", "*", "int"],
          ["sqlite3_total_changes64", "i64", ["sqlite3*"]],
          [
            "sqlite3_update_hook",
            "*",
            [
              "sqlite3*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "sqlite3_update_hook",
                signature: "v(iippj)",
                contextKey: (argv) => argv[0],
                callProxy: (callback) => {
                  return (p5, op, z0, z1, rowid) => {
                    callback(
                      p5,
                      op,
                      wasm.cstrToJs(z0),
                      wasm.cstrToJs(z1),
                      rowid
                    );
                  };
                }
              }),
              "*"
            ]
          ],
          ["sqlite3_uri_int64", "i64", ["sqlite3_filename", "string", "i64"]],
          ["sqlite3_value_int64", "i64", "sqlite3_value*"],
          ["sqlite3_vtab_collation", "string", "sqlite3_index_info*", "int"],
          ["sqlite3_vtab_distinct", "int", "sqlite3_index_info*"],
          ["sqlite3_vtab_in", "int", "sqlite3_index_info*", "int", "int"],
          ["sqlite3_vtab_in_first", "int", "sqlite3_value*", "**"],
          ["sqlite3_vtab_in_next", "int", "sqlite3_value*", "**"],
          ["sqlite3_vtab_nochange", "int", "sqlite3_context*"],
          ["sqlite3_vtab_on_conflict", "int", "sqlite3*"],
          ["sqlite3_vtab_rhs_value", "int", "sqlite3_index_info*", "int", "**"]
        ];
        if (wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add) {
          const __ipsProxy = {
            signature: "i(ps)",
            callProxy: (callback) => {
              return (p5, s3) => {
                try {
                  return callback(p5, wasm.cstrToJs(s3)) | 0;
                } catch (e6) {
                  return e6.resultCode || capi.SQLITE_ERROR;
                }
              };
            }
          };
          wasm.bindingSignatures.int64.push(
            ...[
              [
                "sqlite3changegroup_add",
                "int",
                ["sqlite3_changegroup*", "int", "void*"]
              ],
              [
                "sqlite3changegroup_add_strm",
                "int",
                [
                  "sqlite3_changegroup*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changegroup_delete",
                void 0,
                ["sqlite3_changegroup*"]
              ],
              ["sqlite3changegroup_new", "int", ["**"]],
              [
                "sqlite3changegroup_output",
                "int",
                ["sqlite3_changegroup*", "int*", "**"]
              ],
              [
                "sqlite3changegroup_output_strm",
                "int",
                [
                  "sqlite3_changegroup*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply",
                "int",
                [
                  "sqlite3*",
                  "int",
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply_strm",
                "int",
                [
                  "sqlite3*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_apply_v2",
                "int",
                [
                  "sqlite3*",
                  "int",
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "**",
                  "int*",
                  "int"
                ]
              ],
              [
                "sqlite3changeset_apply_v2_strm",
                "int",
                [
                  "sqlite3*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    bindScope: "transient",
                    ...__ipsProxy
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xConflict",
                    signature: "i(pip)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "**",
                  "int*",
                  "int"
                ]
              ],
              [
                "sqlite3changeset_concat",
                "int",
                ["int", "void*", "int", "void*", "int*", "**"]
              ],
              [
                "sqlite3changeset_concat_strm",
                "int",
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInputA",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInputB",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_conflict",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              ["sqlite3changeset_finalize", "int", ["sqlite3_changeset_iter*"]],
              [
                "sqlite3changeset_fk_conflicts",
                "int",
                ["sqlite3_changeset_iter*", "int*"]
              ],
              [
                "sqlite3changeset_invert",
                "int",
                ["int", "void*", "int*", "**"]
              ],
              [
                "sqlite3changeset_invert_strm",
                "int",
                [
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppi)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3changeset_new",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              ["sqlite3changeset_next", "int", ["sqlite3_changeset_iter*"]],
              [
                "sqlite3changeset_old",
                "int",
                ["sqlite3_changeset_iter*", "int", "**"]
              ],
              [
                "sqlite3changeset_op",
                "int",
                ["sqlite3_changeset_iter*", "**", "int*", "int*", "int*"]
              ],
              [
                "sqlite3changeset_pk",
                "int",
                ["sqlite3_changeset_iter*", "**", "int*"]
              ],
              ["sqlite3changeset_start", "int", ["**", "int", "*"]],
              [
                "sqlite3changeset_start_strm",
                "int",
                [
                  "**",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              ["sqlite3changeset_start_v2", "int", ["**", "int", "*", "int"]],
              [
                "sqlite3changeset_start_v2_strm",
                "int",
                [
                  "**",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xInput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*",
                  "int"
                ]
              ],
              ["sqlite3session_attach", "int", ["sqlite3_session*", "string"]],
              [
                "sqlite3session_changeset",
                "int",
                ["sqlite3_session*", "int*", "**"]
              ],
              ["sqlite3session_changeset_size", "i64", ["sqlite3_session*"]],
              [
                "sqlite3session_changeset_strm",
                "int",
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              ["sqlite3session_config", "int", ["int", "void*"]],
              ["sqlite3session_create", "int", ["sqlite3*", "string", "**"]],
              [
                "sqlite3session_diff",
                "int",
                ["sqlite3_session*", "string", "string", "**"]
              ],
              ["sqlite3session_enable", "int", ["sqlite3_session*", "int"]],
              ["sqlite3session_indirect", "int", ["sqlite3_session*", "int"]],
              ["sqlite3session_isempty", "int", ["sqlite3_session*"]],
              ["sqlite3session_memory_used", "i64", ["sqlite3_session*"]],
              [
                "sqlite3session_object_config",
                "int",
                ["sqlite3_session*", "int", "void*"]
              ],
              [
                "sqlite3session_patchset",
                "int",
                ["sqlite3_session*", "*", "**"]
              ],
              [
                "sqlite3session_patchset_strm",
                "int",
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xOutput",
                    signature: "i(ppp)",
                    bindScope: "transient"
                  }),
                  "void*"
                ]
              ],
              [
                "sqlite3session_table_filter",
                void 0,
                [
                  "sqlite3_session*",
                  new wasm.xWrap.FuncPtrAdapter({
                    name: "xFilter",
                    ...__ipsProxy,
                    contextKey: (argv, argIndex) => argv[0]
                  }),
                  "*"
                ]
              ]
            ]
          );
        }
        wasm.bindingSignatures.wasmInternal = [
          ["sqlite3__wasm_db_reset", "int", "sqlite3*"],
          ["sqlite3__wasm_db_vfs", "sqlite3_vfs*", "sqlite3*", "string"],
          [
            "sqlite3__wasm_vfs_create_file",
            "int",
            "sqlite3_vfs*",
            "string",
            "*",
            "int"
          ],
          ["sqlite3__wasm_posix_create_file", "int", "string", "*", "int"],
          ["sqlite3__wasm_vfs_unlink", "int", "sqlite3_vfs*", "string"],
          ["sqlite3__wasm_qfmt_token", "string:dealloc", "string", "int"]
        ];
        sqlite3.StructBinder = globalThis.Jaccwabyt({
          heap: 0 ? wasm.memory : wasm.heap8u,
          alloc: wasm.alloc,
          dealloc: wasm.dealloc,
          bigIntEnabled: wasm.bigIntEnabled,
          memberPrefix: "$"
        });
        delete globalThis.Jaccwabyt;
        {
          const __xString = wasm.xWrap.argAdapter("string");
          wasm.xWrap.argAdapter(
            "string:flexible",
            (v8) => __xString(util.flexibleString(v8))
          );
          wasm.xWrap.argAdapter(
            "string:static",
            function(v8) {
              if (wasm.isPtr(v8))
                return v8;
              v8 = "" + v8;
              let rc = this[v8];
              return rc || (this[v8] = wasm.allocCString(v8));
            }.bind(/* @__PURE__ */ Object.create(null))
          );
          const __xArgPtr = wasm.xWrap.argAdapter("*");
          const nilType = function() {
          };
          wasm.xWrap.argAdapter("sqlite3_filename", __xArgPtr)(
            "sqlite3_context*",
            __xArgPtr
          )("sqlite3_value*", __xArgPtr)("void*", __xArgPtr)(
            "sqlite3_changegroup*",
            __xArgPtr
          )("sqlite3_changeset_iter*", __xArgPtr)(
            "sqlite3_session*",
            __xArgPtr
          )(
            "sqlite3_stmt*",
            (v8) => __xArgPtr(
              v8 instanceof (sqlite3?.oo1?.Stmt || nilType) ? v8.pointer : v8
            )
          )(
            "sqlite3*",
            (v8) => __xArgPtr(
              v8 instanceof (sqlite3?.oo1?.DB || nilType) ? v8.pointer : v8
            )
          )(
            "sqlite3_index_info*",
            (v8) => __xArgPtr(
              v8 instanceof (capi.sqlite3_index_info || nilType) ? v8.pointer : v8
            )
          )(
            "sqlite3_module*",
            (v8) => __xArgPtr(
              v8 instanceof (capi.sqlite3_module || nilType) ? v8.pointer : v8
            )
          )("sqlite3_vfs*", (v8) => {
            if ("string" === typeof v8) {
              return capi.sqlite3_vfs_find(v8) || sqlite3.SQLite3Error.toss(
                capi.SQLITE_NOTFOUND,
                "Unknown sqlite3_vfs name:",
                v8
              );
            }
            return __xArgPtr(
              v8 instanceof (capi.sqlite3_vfs || nilType) ? v8.pointer : v8
            );
          });
          const __xRcPtr = wasm.xWrap.resultAdapter("*");
          wasm.xWrap.resultAdapter("sqlite3*", __xRcPtr)(
            "sqlite3_context*",
            __xRcPtr
          )("sqlite3_stmt*", __xRcPtr)("sqlite3_value*", __xRcPtr)(
            "sqlite3_vfs*",
            __xRcPtr
          )("void*", __xRcPtr);
          if (0 === wasm.exports.sqlite3_step.length) {
            wasm.xWrap.doArgcCheck = false;
            sqlite3.config.warn(
              "Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks."
            );
          }
          for (const e6 of wasm.bindingSignatures) {
            capi[e6[0]] = wasm.xWrap.apply(null, e6);
          }
          for (const e6 of wasm.bindingSignatures.wasmInternal) {
            util[e6[0]] = wasm.xWrap.apply(null, e6);
          }
          const fI64Disabled = function(fname) {
            return () => toss(
              fname + "() is unavailable due to lack",
              "of BigInt support in this build."
            );
          };
          for (const e6 of wasm.bindingSignatures.int64) {
            capi[e6[0]] = wasm.bigIntEnabled ? wasm.xWrap.apply(null, e6) : fI64Disabled(e6[0]);
          }
          delete wasm.bindingSignatures;
          if (wasm.exports.sqlite3__wasm_db_error) {
            const __db_err = wasm.xWrap(
              "sqlite3__wasm_db_error",
              "int",
              "sqlite3*",
              "int",
              "string"
            );
            util.sqlite3__wasm_db_error = function(pDb2, resultCode, message) {
              if (resultCode instanceof sqlite3.WasmAllocError) {
                resultCode = capi.SQLITE_NOMEM;
                message = 0;
              } else if (resultCode instanceof Error) {
                message = message || "" + resultCode;
                resultCode = resultCode.resultCode || capi.SQLITE_ERROR;
              }
              return pDb2 ? __db_err(pDb2, resultCode, message) : resultCode;
            };
          } else {
            util.sqlite3__wasm_db_error = function(pDb2, errCode, msg) {
              console.warn(
                "sqlite3__wasm_db_error() is not exported.",
                arguments
              );
              return errCode;
            };
          }
        }
        {
          const cJson = wasm.xCall("sqlite3__wasm_enum_json");
          if (!cJson) {
            toss(
              "Maintenance required: increase sqlite3__wasm_enum_json()'s",
              "static buffer size!"
            );
          }
          wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));
          const defineGroups = [
            "access",
            "authorizer",
            "blobFinalizers",
            "changeset",
            "config",
            "dataTypes",
            "dbConfig",
            "dbStatus",
            "encodings",
            "fcntl",
            "flock",
            "ioCap",
            "limits",
            "openFlags",
            "prepareFlags",
            "resultCodes",
            "sqlite3Status",
            "stmtStatus",
            "syncFlags",
            "trace",
            "txnState",
            "udfFlags",
            "version"
          ];
          if (wasm.bigIntEnabled) {
            defineGroups.push("serialize", "session", "vtab");
          }
          for (const t5 of defineGroups) {
            for (const e6 of Object.entries(wasm.ctype[t5])) {
              capi[e6[0]] = e6[1];
            }
          }
          if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
            toss(
              "Internal error: cannot resolve exported function",
              "entry SQLITE_WASM_DEALLOC (==" + capi.SQLITE_WASM_DEALLOC + ")."
            );
          }
          const __rcMap = /* @__PURE__ */ Object.create(null);
          for (const t5 of ["resultCodes"]) {
            for (const e6 of Object.entries(wasm.ctype[t5])) {
              __rcMap[e6[1]] = e6[0];
            }
          }
          capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];
          const notThese = Object.assign(/* @__PURE__ */ Object.create(null), {
            WasmTestStruct: true,
            sqlite3_kvvfs_methods: !util.isUIThread(),
            sqlite3_index_info: !wasm.bigIntEnabled,
            sqlite3_index_constraint: !wasm.bigIntEnabled,
            sqlite3_index_orderby: !wasm.bigIntEnabled,
            sqlite3_index_constraint_usage: !wasm.bigIntEnabled
          });
          for (const s3 of wasm.ctype.structs) {
            if (!notThese[s3.name]) {
              capi[s3.name] = sqlite3.StructBinder(s3);
            }
          }
          if (capi.sqlite3_index_info) {
            for (const k6 of [
              "sqlite3_index_constraint",
              "sqlite3_index_orderby",
              "sqlite3_index_constraint_usage"
            ]) {
              capi.sqlite3_index_info[k6] = capi[k6];
              delete capi[k6];
            }
            capi.sqlite3_vtab_config = wasm.xWrap(
              "sqlite3__wasm_vtab_config",
              "int",
              ["sqlite3*", "int", "int"]
            );
          }
        }
        const __dbArgcMismatch = (pDb2, f5, n6) => {
          return util.sqlite3__wasm_db_error(
            pDb2,
            capi.SQLITE_MISUSE,
            f5 + "() requires " + n6 + " argument" + (1 === n6 ? "" : "s") + "."
          );
        };
        const __errEncoding = (pDb2) => {
          return util.sqlite3__wasm_db_error(
            pDb2,
            capi.SQLITE_FORMAT,
            "SQLITE_UTF8 is the only supported encoding."
          );
        };
        const __argPDb = (pDb2) => wasm.xWrap.argAdapter("sqlite3*")(pDb2);
        const __argStr = (str) => wasm.isPtr(str) ? wasm.cstrToJs(str) : str;
        const __dbCleanupMap = function(pDb2, mode) {
          pDb2 = __argPDb(pDb2);
          let m7 = this.dbMap.get(pDb2);
          if (!mode) {
            this.dbMap.delete(pDb2);
            return m7;
          } else if (!m7 && mode > 0) {
            this.dbMap.set(pDb2, m7 = /* @__PURE__ */ Object.create(null));
          }
          return m7;
        }.bind(
          Object.assign(/* @__PURE__ */ Object.create(null), {
            dbMap: /* @__PURE__ */ new Map()
          })
        );
        __dbCleanupMap.addCollation = function(pDb2, name) {
          const m7 = __dbCleanupMap(pDb2, 1);
          if (!m7.collation)
            m7.collation = /* @__PURE__ */ new Set();
          m7.collation.add(__argStr(name).toLowerCase());
        };
        __dbCleanupMap._addUDF = function(pDb2, name, arity, map) {
          name = __argStr(name).toLowerCase();
          let u3 = map.get(name);
          if (!u3)
            map.set(name, u3 = /* @__PURE__ */ new Set());
          u3.add(arity < 0 ? -1 : arity);
        };
        __dbCleanupMap.addFunction = function(pDb2, name, arity) {
          const m7 = __dbCleanupMap(pDb2, 1);
          if (!m7.udf)
            m7.udf = /* @__PURE__ */ new Map();
          this._addUDF(pDb2, name, arity, m7.udf);
        };
        __dbCleanupMap.addWindowFunc = function(pDb2, name, arity) {
          const m7 = __dbCleanupMap(pDb2, 1);
          if (!m7.wudf)
            m7.wudf = /* @__PURE__ */ new Map();
          this._addUDF(pDb2, name, arity, m7.wudf);
        };
        __dbCleanupMap.cleanup = function(pDb2) {
          pDb2 = __argPDb(pDb2);
          const closeArgs = [pDb2];
          for (const name of [
            "sqlite3_busy_handler",
            "sqlite3_commit_hook",
            "sqlite3_preupdate_hook",
            "sqlite3_progress_handler",
            "sqlite3_rollback_hook",
            "sqlite3_set_authorizer",
            "sqlite3_trace_v2",
            "sqlite3_update_hook"
          ]) {
            const x6 = wasm.exports[name];
            closeArgs.length = x6.length;
            try {
              capi[name](...closeArgs);
            } catch (e6) {
              console.warn(
                "close-time call of",
                name + "(",
                closeArgs,
                ") threw:",
                e6
              );
            }
          }
          const m7 = __dbCleanupMap(pDb2, 0);
          if (!m7)
            return;
          if (m7.collation) {
            for (const name of m7.collation) {
              try {
                capi.sqlite3_create_collation_v2(
                  pDb2,
                  name,
                  capi.SQLITE_UTF8,
                  0,
                  0,
                  0
                );
              } catch (e6) {
              }
            }
            delete m7.collation;
          }
          let i4;
          for (i4 = 0; i4 < 2; ++i4) {
            const fmap = i4 ? m7.wudf : m7.udf;
            if (!fmap)
              continue;
            const func = i4 ? capi.sqlite3_create_window_function : capi.sqlite3_create_function_v2;
            for (const e6 of fmap) {
              const name = e6[0], arities = e6[1];
              const fargs = [pDb2, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
              if (i4)
                fargs.push(0);
              for (const arity of arities) {
                try {
                  fargs[2] = arity;
                  func.apply(null, fargs);
                } catch (e7) {
                }
              }
              arities.clear();
            }
            fmap.clear();
          }
          delete m7.udf;
          delete m7.wudf;
        };
        {
          const __sqlite3CloseV2 = wasm.xWrap(
            "sqlite3_close_v2",
            "int",
            "sqlite3*"
          );
          capi.sqlite3_close_v2 = function(pDb2) {
            if (1 !== arguments.length)
              return __dbArgcMismatch(pDb2, "sqlite3_close_v2", 1);
            if (pDb2) {
              try {
                __dbCleanupMap.cleanup(pDb2);
              } catch (e6) {
              }
            }
            return __sqlite3CloseV2(pDb2);
          };
        }
        if (capi.sqlite3session_table_filter) {
          const __sqlite3SessionDelete = wasm.xWrap(
            "sqlite3session_delete",
            void 0,
            ["sqlite3_session*"]
          );
          capi.sqlite3session_delete = function(pSession) {
            if (1 !== arguments.length) {
              return __dbArgcMismatch(pDb, "sqlite3session_delete", 1);
            } else if (pSession) {
              capi.sqlite3session_table_filter(pSession, 0, 0);
            }
            __sqlite3SessionDelete(pSession);
          };
        }
        {
          const contextKey = (argv, argIndex) => {
            return "argv[" + argIndex + "]:" + argv[0] + ":" + wasm.cstrToJs(argv[1]).toLowerCase();
          };
          const __sqlite3CreateCollationV2 = wasm.xWrap(
            "sqlite3_create_collation_v2",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xCompare",
                signature: "i(pipip)",
                contextKey
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                signature: "v(p)",
                contextKey
              })
            ]
          );
          capi.sqlite3_create_collation_v2 = function(pDb2, zName, eTextRep, pArg, xCompare, xDestroy) {
            if (6 !== arguments.length)
              return __dbArgcMismatch(pDb2, "sqlite3_create_collation_v2", 6);
            else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateCollationV2(
                pDb2,
                zName,
                eTextRep,
                pArg,
                xCompare,
                xDestroy
              );
              if (0 === rc && xCompare instanceof Function) {
                __dbCleanupMap.addCollation(pDb2, zName);
              }
              return rc;
            } catch (e6) {
              return util.sqlite3__wasm_db_error(pDb2, e6);
            }
          };
          capi.sqlite3_create_collation = (pDb2, zName, eTextRep, pArg, xCompare) => {
            return 5 === arguments.length ? capi.sqlite3_create_collation_v2(
              pDb2,
              zName,
              eTextRep,
              pArg,
              xCompare,
              0
            ) : __dbArgcMismatch(pDb2, "sqlite3_create_collation", 5);
          };
        }
        {
          const contextKey = function(argv, argIndex) {
            return argv[0] + ":" + (argv[2] < 0 ? -1 : argv[2]) + ":" + argIndex + ":" + wasm.cstrToJs(argv[1]).toLowerCase();
          };
          const __cfProxy = Object.assign(/* @__PURE__ */ Object.create(null), {
            xInverseAndStep: {
              signature: "v(pip)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));
                  } catch (e6) {
                    capi.sqlite3_result_error_js(pCtx, e6);
                  }
                };
              }
            },
            xFinalAndValue: {
              signature: "v(p)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx) => {
                  try {
                    capi.sqlite3_result_js(pCtx, callback(pCtx));
                  } catch (e6) {
                    capi.sqlite3_result_error_js(pCtx, e6);
                  }
                };
              }
            },
            xFunc: {
              signature: "v(pip)",
              contextKey,
              callProxy: (callback) => {
                return (pCtx, argc, pArgv) => {
                  try {
                    capi.sqlite3_result_js(
                      pCtx,
                      callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))
                    );
                  } catch (e6) {
                    capi.sqlite3_result_error_js(pCtx, e6);
                  }
                };
              }
            },
            xDestroy: {
              signature: "v(p)",
              contextKey,
              callProxy: (callback) => {
                return (pVoid) => {
                  try {
                    callback(pVoid);
                  } catch (e6) {
                    console.error("UDF xDestroy method threw:", e6);
                  }
                };
              }
            }
          });
          const __sqlite3CreateFunction = wasm.xWrap(
            "sqlite3_create_function_v2",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFunc",
                ...__cfProxy.xFunc
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xStep",
                ...__cfProxy.xInverseAndStep
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFinal",
                ...__cfProxy.xFinalAndValue
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                ...__cfProxy.xDestroy
              })
            ]
          );
          const __sqlite3CreateWindowFunction = wasm.xWrap(
            "sqlite3_create_window_function",
            "int",
            [
              "sqlite3*",
              "string",
              "int",
              "int",
              "*",
              new wasm.xWrap.FuncPtrAdapter({
                name: "xStep",
                ...__cfProxy.xInverseAndStep
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xFinal",
                ...__cfProxy.xFinalAndValue
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xValue",
                ...__cfProxy.xFinalAndValue
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xInverse",
                ...__cfProxy.xInverseAndStep
              }),
              new wasm.xWrap.FuncPtrAdapter({
                name: "xDestroy",
                ...__cfProxy.xDestroy
              })
            ]
          );
          capi.sqlite3_create_function_v2 = function f5(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal, xDestroy) {
            if (f5.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb2,
                "sqlite3_create_function_v2",
                f5.length
              );
            } else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateFunction(
                pDb2,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
                xDestroy
              );
              if (0 === rc && (xFunc instanceof Function || xStep instanceof Function || xFinal instanceof Function || xDestroy instanceof Function)) {
                __dbCleanupMap.addFunction(pDb2, funcName, nArg);
              }
              return rc;
            } catch (e6) {
              console.error("sqlite3_create_function_v2() setup threw:", e6);
              return util.sqlite3__wasm_db_error(
                pDb2,
                e6,
                "Creation of UDF threw: " + e6
              );
            }
          };
          capi.sqlite3_create_function = function f5(pDb2, funcName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
            return f5.length === arguments.length ? capi.sqlite3_create_function_v2(
              pDb2,
              funcName,
              nArg,
              eTextRep,
              pApp,
              xFunc,
              xStep,
              xFinal,
              0
            ) : __dbArgcMismatch(pDb2, "sqlite3_create_function", f5.length);
          };
          capi.sqlite3_create_window_function = function f5(pDb2, funcName, nArg, eTextRep, pApp, xStep, xFinal, xValue, xInverse, xDestroy) {
            if (f5.length !== arguments.length) {
              return __dbArgcMismatch(
                pDb2,
                "sqlite3_create_window_function",
                f5.length
              );
            } else if (0 === (eTextRep & 15)) {
              eTextRep |= capi.SQLITE_UTF8;
            } else if (capi.SQLITE_UTF8 !== (eTextRep & 15)) {
              return __errEncoding(pDb2);
            }
            try {
              const rc = __sqlite3CreateWindowFunction(
                pDb2,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy
              );
              if (0 === rc && (xStep instanceof Function || xFinal instanceof Function || xValue instanceof Function || xInverse instanceof Function || xDestroy instanceof Function)) {
                __dbCleanupMap.addWindowFunc(pDb2, funcName, nArg);
              }
              return rc;
            } catch (e6) {
              console.error("sqlite3_create_window_function() setup threw:", e6);
              return util.sqlite3__wasm_db_error(
                pDb2,
                e6,
                "Creation of UDF threw: " + e6
              );
            }
          };
          capi.sqlite3_create_function_v2.udfSetResult = capi.sqlite3_create_function.udfSetResult = capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;
          capi.sqlite3_create_function_v2.udfConvertArgs = capi.sqlite3_create_function.udfConvertArgs = capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;
          capi.sqlite3_create_function_v2.udfSetError = capi.sqlite3_create_function.udfSetError = capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;
        }
        {
          const __flexiString = (v8, n6) => {
            if ("string" === typeof v8) {
              n6 = -1;
            } else if (util.isSQLableTypedArray(v8)) {
              n6 = v8.byteLength;
              v8 = util.typedArrayToString(
                v8 instanceof ArrayBuffer ? new Uint8Array(v8) : v8
              );
            } else if (Array.isArray(v8)) {
              v8 = v8.join("");
              n6 = -1;
            }
            return [v8, n6];
          };
          const __prepare = {
            basic: wasm.xWrap("sqlite3_prepare_v3", "int", [
              "sqlite3*",
              "string",
              "int",
              "int",
              "**",
              "**"
            ]),
            full: wasm.xWrap("sqlite3_prepare_v3", "int", [
              "sqlite3*",
              "*",
              "int",
              "int",
              "**",
              "**"
            ])
          };
          capi.sqlite3_prepare_v3 = function f5(pDb2, sql, sqlLen, prepFlags, ppStmt, pzTail) {
            if (f5.length !== arguments.length) {
              return __dbArgcMismatch(pDb2, "sqlite3_prepare_v3", f5.length);
            }
            const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
            switch (typeof xSql) {
              case "string":
                return __prepare.basic(
                  pDb2,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  null
                );
              case "number":
                return __prepare.full(
                  pDb2,
                  xSql,
                  xSqlLen,
                  prepFlags,
                  ppStmt,
                  pzTail
                );
              default:
                return util.sqlite3__wasm_db_error(
                  pDb2,
                  capi.SQLITE_MISUSE,
                  "Invalid SQL argument type for sqlite3_prepare_v2/v3()."
                );
            }
          };
          capi.sqlite3_prepare_v2 = function f5(pDb2, sql, sqlLen, ppStmt, pzTail) {
            return f5.length === arguments.length ? capi.sqlite3_prepare_v3(pDb2, sql, sqlLen, 0, ppStmt, pzTail) : __dbArgcMismatch(pDb2, "sqlite3_prepare_v2", f5.length);
          };
        }
        {
          const __bindText = wasm.xWrap("sqlite3_bind_text", "int", [
            "sqlite3_stmt*",
            "int",
            "string",
            "int",
            "*"
          ]);
          const __bindBlob = wasm.xWrap("sqlite3_bind_blob", "int", [
            "sqlite3_stmt*",
            "int",
            "*",
            "int",
            "*"
          ]);
          capi.sqlite3_bind_text = function f5(pStmt, iCol, text, nText, xDestroy) {
            if (f5.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                "sqlite3_bind_text",
                f5.length
              );
            } else if (wasm.isPtr(text) || null === text) {
              return __bindText(pStmt, iCol, text, nText, xDestroy);
            } else if (text instanceof ArrayBuffer) {
              text = new Uint8Array(text);
            } else if (Array.isArray(pMem)) {
              text = pMem.join("");
            }
            let p5, n6;
            try {
              if (util.isSQLableTypedArray(text)) {
                p5 = wasm.allocFromTypedArray(text);
                n6 = text.byteLength;
              } else if ("string" === typeof text) {
                [p5, n6] = wasm.allocCString(text);
              } else {
                return util.sqlite3__wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  "Invalid 3rd argument type for sqlite3_bind_text()."
                );
              }
              return __bindText(pStmt, iCol, p5, n6, capi.SQLITE_WASM_DEALLOC);
            } catch (e6) {
              wasm.dealloc(p5);
              return util.sqlite3__wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e6
              );
            }
          };
          capi.sqlite3_bind_blob = function f5(pStmt, iCol, pMem2, nMem, xDestroy) {
            if (f5.length !== arguments.length) {
              return __dbArgcMismatch(
                capi.sqlite3_db_handle(pStmt),
                "sqlite3_bind_blob",
                f5.length
              );
            } else if (wasm.isPtr(pMem2) || null === pMem2) {
              return __bindBlob(pStmt, iCol, pMem2, nMem, xDestroy);
            } else if (pMem2 instanceof ArrayBuffer) {
              pMem2 = new Uint8Array(pMem2);
            } else if (Array.isArray(pMem2)) {
              pMem2 = pMem2.join("");
            }
            let p5, n6;
            try {
              if (util.isBindableTypedArray(pMem2)) {
                p5 = wasm.allocFromTypedArray(pMem2);
                n6 = nMem >= 0 ? nMem : pMem2.byteLength;
              } else if ("string" === typeof pMem2) {
                [p5, n6] = wasm.allocCString(pMem2);
              } else {
                return util.sqlite3__wasm_db_error(
                  capi.sqlite3_db_handle(pStmt),
                  capi.SQLITE_MISUSE,
                  "Invalid 3rd argument type for sqlite3_bind_blob()."
                );
              }
              return __bindBlob(pStmt, iCol, p5, n6, capi.SQLITE_WASM_DEALLOC);
            } catch (e6) {
              wasm.dealloc(p5);
              return util.sqlite3__wasm_db_error(
                capi.sqlite3_db_handle(pStmt),
                e6
              );
            }
          };
        }
        {
          capi.sqlite3_config = function(op, ...args) {
            if (arguments.length < 2)
              return capi.SQLITE_MISUSE;
            switch (op) {
              case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:
              case capi.SQLITE_CONFIG_MEMSTATUS:
              case capi.SQLITE_CONFIG_SMALL_MALLOC:
              case capi.SQLITE_CONFIG_SORTERREF_SIZE:
              case capi.SQLITE_CONFIG_STMTJRNL_SPILL:
              case capi.SQLITE_CONFIG_URI:
                return wasm.exports.sqlite3__wasm_config_i(op, args[0]);
              case capi.SQLITE_CONFIG_LOOKASIDE:
                return wasm.exports.sqlite3__wasm_config_ii(
                  op,
                  args[0],
                  args[1]
                );
              case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:
                return wasm.exports.sqlite3__wasm_config_j(op, args[0]);
              case capi.SQLITE_CONFIG_GETMALLOC:
              case capi.SQLITE_CONFIG_GETMUTEX:
              case capi.SQLITE_CONFIG_GETPCACHE2:
              case capi.SQLITE_CONFIG_GETPCACHE:
              case capi.SQLITE_CONFIG_HEAP:
              case capi.SQLITE_CONFIG_LOG:
              case capi.SQLITE_CONFIG_MALLOC:
              case capi.SQLITE_CONFIG_MMAP_SIZE:
              case capi.SQLITE_CONFIG_MULTITHREAD:
              case capi.SQLITE_CONFIG_MUTEX:
              case capi.SQLITE_CONFIG_PAGECACHE:
              case capi.SQLITE_CONFIG_PCACHE2:
              case capi.SQLITE_CONFIG_PCACHE:
              case capi.SQLITE_CONFIG_PCACHE_HDRSZ:
              case capi.SQLITE_CONFIG_PMASZ:
              case capi.SQLITE_CONFIG_SERIALIZED:
              case capi.SQLITE_CONFIG_SINGLETHREAD:
              case capi.SQLITE_CONFIG_SQLLOG:
              case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:
              default:
                return capi.SQLITE_NOTFOUND;
            }
          };
        }
        {
          const __autoExtFptr = /* @__PURE__ */ new Set();
          capi.sqlite3_auto_extension = function(fPtr) {
            if (fPtr instanceof Function) {
              fPtr = wasm.installFunction("i(ppp)", fPtr);
            } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {
              return capi.SQLITE_MISUSE;
            }
            const rc = wasm.exports.sqlite3_auto_extension(fPtr);
            if (fPtr !== arguments[0]) {
              if (0 === rc)
                __autoExtFptr.add(fPtr);
              else
                wasm.uninstallFunction(fPtr);
            }
            return rc;
          };
          capi.sqlite3_cancel_auto_extension = function(fPtr) {
            if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr))
              return 0;
            return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
          };
          capi.sqlite3_reset_auto_extension = function() {
            wasm.exports.sqlite3_reset_auto_extension();
            for (const fp of __autoExtFptr)
              wasm.uninstallFunction(fp);
            __autoExtFptr.clear();
          };
        }
        const pKvvfs = capi.sqlite3_vfs_find("kvvfs");
        if (pKvvfs) {
          if (util.isUIThread()) {
            const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
              wasm.exports.sqlite3__wasm_kvvfs_methods()
            );
            delete capi.sqlite3_kvvfs_methods;
            const kvvfsMakeKey = wasm.exports.sqlite3__wasm_kvvfsMakeKeyOnPstack, pstack = wasm.pstack;
            const kvvfsStorage = (zClass) => 115 === wasm.peek(zClass) ? sessionStorage : localStorage;
            const kvvfsImpls = {
              xRead: (zClass, zKey, zBuf, nBuf) => {
                const stack = pstack.pointer, astack = wasm.scopedAllocPush();
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return -3;
                  const jKey = wasm.cstrToJs(zXKey);
                  const jV = kvvfsStorage(zClass).getItem(jKey);
                  if (!jV)
                    return -1;
                  const nV = jV.length;
                  if (nBuf <= 0)
                    return nV;
                  else if (1 === nBuf) {
                    wasm.poke(zBuf, 0);
                    return nV;
                  }
                  const zV = wasm.scopedAllocCString(jV);
                  if (nBuf > nV + 1)
                    nBuf = nV + 1;
                  wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
                  wasm.poke(zBuf + nBuf - 1, 0);
                  return nBuf - 1;
                } catch (e6) {
                  console.error("kvstorageRead()", e6);
                  return -2;
                } finally {
                  pstack.restore(stack);
                  wasm.scopedAllocPop(astack);
                }
              },
              xWrite: (zClass, zKey, zData) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return 1;
                  const jKey = wasm.cstrToJs(zXKey);
                  kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
                  return 0;
                } catch (e6) {
                  console.error("kvstorageWrite()", e6);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              },
              xDelete: (zClass, zKey) => {
                const stack = pstack.pointer;
                try {
                  const zXKey = kvvfsMakeKey(zClass, zKey);
                  if (!zXKey)
                    return 1;
                  kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
                  return 0;
                } catch (e6) {
                  console.error("kvstorageDelete()", e6);
                  return capi.SQLITE_IOERR;
                } finally {
                  pstack.restore(stack);
                }
              }
            };
            for (const k6 of Object.keys(kvvfsImpls)) {
              kvvfsMethods[kvvfsMethods.memberKey(k6)] = wasm.installFunction(
                kvvfsMethods.memberSignature(k6),
                kvvfsImpls[k6]
              );
            }
          } else {
            capi.sqlite3_vfs_unregister(pKvvfs);
          }
        }
        wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
        const StructBinder = sqlite3.StructBinder;
        const installMethod = function callee2(tgt, name, func, applyArgcCheck = callee2.installMethodArgcCheck) {
          if (!(tgt instanceof StructBinder.StructType)) {
            toss("Usage error: target object is-not-a StructType.");
          } else if (!(func instanceof Function) && !wasm.isPtr(func)) {
            toss("Usage errror: expecting a Function or WASM pointer to one.");
          }
          if (1 === arguments.length) {
            return (n6, f5) => callee2(tgt, n6, f5, applyArgcCheck);
          }
          if (!callee2.argcProxy) {
            callee2.argcProxy = function(tgt2, funcName, func2, sig) {
              return function(...args) {
                if (func2.length !== arguments.length) {
                  toss(
                    "Argument mismatch for",
                    tgt2.structInfo.name + "::" + funcName + ": Native signature is:",
                    sig
                  );
                }
                return func2.apply(this, args);
              };
            };
            callee2.removeFuncList = function() {
              if (this.ondispose.__removeFuncList) {
                this.ondispose.__removeFuncList.forEach((v8, ndx) => {
                  if ("number" === typeof v8) {
                    try {
                      wasm.uninstallFunction(v8);
                    } catch (e6) {
                    }
                  }
                });
                delete this.ondispose.__removeFuncList;
              }
            };
          }
          const sigN = tgt.memberSignature(name);
          if (sigN.length < 2) {
            toss(
              "Member",
              name,
              "does not have a function pointer signature:",
              sigN
            );
          }
          const memKey = tgt.memberKey(name);
          const fProxy = applyArgcCheck && !wasm.isPtr(func) ? callee2.argcProxy(tgt, memKey, func, sigN) : func;
          if (wasm.isPtr(fProxy)) {
            if (fProxy && !wasm.functionEntry(fProxy)) {
              toss("Pointer", fProxy, "is not a WASM function table entry.");
            }
            tgt[memKey] = fProxy;
          } else {
            const pFunc = wasm.installFunction(
              fProxy,
              tgt.memberSignature(name, true)
            );
            tgt[memKey] = pFunc;
            if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {
              tgt.addOnDispose(
                "ondispose.__removeFuncList handler",
                callee2.removeFuncList
              );
              tgt.ondispose.__removeFuncList = [];
            }
            tgt.ondispose.__removeFuncList.push(memKey, pFunc);
          }
          return (n6, f5) => callee2(tgt, n6, f5, applyArgcCheck);
        };
        installMethod.installMethodArgcCheck = false;
        const installMethods = function(structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
          const seen = /* @__PURE__ */ new Map();
          for (const k6 of Object.keys(methods)) {
            const m7 = methods[k6];
            const prior = seen.get(m7);
            if (prior) {
              const mkey = structInstance.memberKey(k6);
              structInstance[mkey] = structInstance[structInstance.memberKey(prior)];
            } else {
              installMethod(structInstance, k6, m7, applyArgcCheck);
              seen.set(m7, k6);
            }
          }
          return structInstance;
        };
        StructBinder.StructType.prototype.installMethod = function callee2(name, func, applyArgcCheck = installMethod.installMethodArgcCheck) {
          return arguments.length < 3 && name && "object" === typeof name ? installMethods(this, ...arguments) : installMethod(this, ...arguments);
        };
        StructBinder.StructType.prototype.installMethods = function(methods, applyArgcCheck = installMethod.installMethodArgcCheck) {
          return installMethods(this, methods, applyArgcCheck);
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        sqlite3.version = {
          libVersion: "3.46.0",
          libVersionNumber: 3046e3,
          sourceId: "2024-05-23 13:25:27 96c92aba00c8375bc32fafcdf12429c58bd8aabfcadab6683e35bbb9cdebf19e",
          downloadVersion: 346e4
        };
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const toss = (...args) => {
          throw new Error(args.join(" "));
        };
        const toss3 = (...args) => {
          throw new sqlite3.SQLite3Error(...args);
        };
        const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
        const __ptrMap = /* @__PURE__ */ new WeakMap();
        const __stmtMap = /* @__PURE__ */ new WeakMap();
        const getOwnOption = (opts, p5, dflt) => {
          const d4 = Object.getOwnPropertyDescriptor(opts, p5);
          return d4 ? d4.value : dflt;
        };
        const checkSqlite3Rc = function(dbPtr, sqliteResultCode) {
          if (sqliteResultCode) {
            if (dbPtr instanceof DB)
              dbPtr = dbPtr.pointer;
            toss3(
              sqliteResultCode,
              "sqlite3 result code",
              sqliteResultCode + ":",
              dbPtr ? capi.sqlite3_errmsg(dbPtr) : capi.sqlite3_errstr(sqliteResultCode)
            );
          }
          return arguments[0];
        };
        const __dbTraceToConsole = wasm.installFunction(
          "i(ippp)",
          function(t5, c5, p5, x6) {
            if (capi.SQLITE_TRACE_STMT === t5) {
              console.log(
                "SQL TRACE #" + ++this.counter + " via sqlite3@" + c5 + ":",
                wasm.cstrToJs(x6)
              );
            }
          }.bind({ counter: 0 })
        );
        const __vfsPostOpenSql = /* @__PURE__ */ Object.create(null);
        const dbCtorHelper = function ctor(...args) {
          if (!ctor._name2vfs) {
            ctor._name2vfs = /* @__PURE__ */ Object.create(null);
            const isWorkerThread = "function" === typeof importScripts ? (n6) => toss3(
              "The VFS for",
              n6,
              "is only available in the main window thread."
            ) : false;
            ctor._name2vfs[":localStorage:"] = {
              vfs: "kvvfs",
              filename: isWorkerThread || (() => "local")
            };
            ctor._name2vfs[":sessionStorage:"] = {
              vfs: "kvvfs",
              filename: isWorkerThread || (() => "session")
            };
          }
          const opt = ctor.normalizeArgs(...args);
          let fn2 = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;
          if ("string" !== typeof fn2 && "number" !== typeof fn2 || "string" !== typeof flagsStr || vfsName && "string" !== typeof vfsName && "number" !== typeof vfsName) {
            sqlite3.config.error("Invalid DB ctor args", opt, arguments);
            toss3("Invalid arguments for DB constructor.");
          }
          let fnJs = "number" === typeof fn2 ? wasm.cstrToJs(fn2) : fn2;
          const vfsCheck = ctor._name2vfs[fnJs];
          if (vfsCheck) {
            vfsName = vfsCheck.vfs;
            fn2 = fnJs = vfsCheck.filename(fnJs);
          }
          let pDb2, oflags = 0;
          if (flagsStr.indexOf("c") >= 0) {
            oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
          }
          if (flagsStr.indexOf("w") >= 0)
            oflags |= capi.SQLITE_OPEN_READWRITE;
          if (0 === oflags)
            oflags |= capi.SQLITE_OPEN_READONLY;
          oflags |= capi.SQLITE_OPEN_EXRESCODE;
          const stack = wasm.pstack.pointer;
          try {
            const pPtr = wasm.pstack.allocPtr();
            let rc = capi.sqlite3_open_v2(fn2, pPtr, oflags, vfsName || 0);
            pDb2 = wasm.peekPtr(pPtr);
            checkSqlite3Rc(pDb2, rc);
            capi.sqlite3_extended_result_codes(pDb2, 1);
            if (flagsStr.indexOf("t") >= 0) {
              capi.sqlite3_trace_v2(
                pDb2,
                capi.SQLITE_TRACE_STMT,
                __dbTraceToConsole,
                pDb2
              );
            }
          } catch (e6) {
            if (pDb2)
              capi.sqlite3_close_v2(pDb2);
            throw e6;
          } finally {
            wasm.pstack.restore(stack);
          }
          this.filename = fnJs;
          __ptrMap.set(this, pDb2);
          __stmtMap.set(this, /* @__PURE__ */ Object.create(null));
          try {
            const pVfs = capi.sqlite3_js_db_vfs(pDb2) || toss3("Internal error: cannot get VFS for new db handle.");
            const postInitSql = __vfsPostOpenSql[pVfs];
            if (postInitSql) {
              if (postInitSql instanceof Function) {
                postInitSql(this, sqlite3);
              } else {
                checkSqlite3Rc(
                  pDb2,
                  capi.sqlite3_exec(pDb2, postInitSql, 0, 0, 0)
                );
              }
            }
          } catch (e6) {
            this.close();
            throw e6;
          }
        };
        dbCtorHelper.setVfsPostOpenSql = function(pVfs, sql) {
          __vfsPostOpenSql[pVfs] = sql;
        };
        dbCtorHelper.normalizeArgs = function(filename = ":memory:", flags = "c", vfs = null) {
          const arg = {};
          if (1 === arguments.length && arguments[0] && "object" === typeof arguments[0]) {
            Object.assign(arg, arguments[0]);
            if (void 0 === arg.flags)
              arg.flags = "c";
            if (void 0 === arg.vfs)
              arg.vfs = null;
            if (void 0 === arg.filename)
              arg.filename = ":memory:";
          } else {
            arg.filename = filename;
            arg.flags = flags;
            arg.vfs = vfs;
          }
          return arg;
        };
        const DB = function(...args) {
          dbCtorHelper.apply(this, args);
        };
        DB.dbCtorHelper = dbCtorHelper;
        const BindTypes = {
          null: 1,
          number: 2,
          string: 3,
          boolean: 4,
          blob: 5
        };
        BindTypes["undefined"] == BindTypes.null;
        if (wasm.bigIntEnabled) {
          BindTypes.bigint = BindTypes.number;
        }
        const Stmt = function() {
          if (BindTypes !== arguments[2]) {
            toss3(
              capi.SQLITE_MISUSE,
              "Do not call the Stmt constructor directly. Use DB.prepare()."
            );
          }
          this.db = arguments[0];
          __ptrMap.set(this, arguments[1]);
          this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
        };
        const affirmDbOpen = function(db) {
          if (!db.pointer)
            toss3("DB has been closed.");
          return db;
        };
        const affirmColIndex = function(stmt, ndx) {
          if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {
            toss3("Column index", ndx, "is out of range.");
          }
          return stmt;
        };
        const parseExecArgs = function(db, args) {
          const out2 = /* @__PURE__ */ Object.create(null);
          out2.opt = /* @__PURE__ */ Object.create(null);
          switch (args.length) {
            case 1:
              if ("string" === typeof args[0] || util.isSQLableTypedArray(args[0])) {
                out2.sql = args[0];
              } else if (Array.isArray(args[0])) {
                out2.sql = args[0];
              } else if (args[0] && "object" === typeof args[0]) {
                out2.opt = args[0];
                out2.sql = out2.opt.sql;
              }
              break;
            case 2:
              out2.sql = args[0];
              out2.opt = args[1];
              break;
            default:
              toss3("Invalid argument count for exec().");
          }
          out2.sql = util.flexibleString(out2.sql);
          if ("string" !== typeof out2.sql) {
            toss3("Missing SQL argument or unsupported SQL value type.");
          }
          const opt = out2.opt;
          switch (opt.returnValue) {
            case "resultRows":
              if (!opt.resultRows)
                opt.resultRows = [];
              out2.returnVal = () => opt.resultRows;
              break;
            case "saveSql":
              if (!opt.saveSql)
                opt.saveSql = [];
              out2.returnVal = () => opt.saveSql;
              break;
            case void 0:
            case "this":
              out2.returnVal = () => db;
              break;
            default:
              toss3("Invalid returnValue value:", opt.returnValue);
          }
          if (!opt.callback && !opt.returnValue && void 0 !== opt.rowMode) {
            if (!opt.resultRows)
              opt.resultRows = [];
            out2.returnVal = () => opt.resultRows;
          }
          if (opt.callback || opt.resultRows) {
            switch (void 0 === opt.rowMode ? "array" : opt.rowMode) {
              case "object":
                out2.cbArg = (stmt, cache) => {
                  if (!cache.columnNames)
                    cache.columnNames = stmt.getColumnNames([]);
                  const row = stmt.get([]);
                  const rv = /* @__PURE__ */ Object.create(null);
                  for (const i4 in cache.columnNames)
                    rv[cache.columnNames[i4]] = row[i4];
                  return rv;
                };
                break;
              case "array":
                out2.cbArg = (stmt) => stmt.get([]);
                break;
              case "stmt":
                if (Array.isArray(opt.resultRows)) {
                  toss3(
                    "exec(): invalid rowMode for a resultRows array: must",
                    "be one of 'array', 'object',",
                    "a result column number, or column name reference."
                  );
                }
                out2.cbArg = (stmt) => stmt;
                break;
              default:
                if (util.isInt32(opt.rowMode)) {
                  out2.cbArg = (stmt) => stmt.get(opt.rowMode);
                  break;
                } else if ("string" === typeof opt.rowMode && opt.rowMode.length > 1 && "$" === opt.rowMode[0]) {
                  const $colName = opt.rowMode.substr(1);
                  out2.cbArg = (stmt) => {
                    const rc = stmt.get(/* @__PURE__ */ Object.create(null))[$colName];
                    return void 0 === rc ? toss3(
                      capi.SQLITE_NOTFOUND,
                      "exec(): unknown result column:",
                      $colName
                    ) : rc;
                  };
                  break;
                }
                toss3("Invalid rowMode:", opt.rowMode);
            }
          }
          return out2;
        };
        const __selectFirstRow = (db, sql, bind, ...getArgs) => {
          const stmt = db.prepare(sql);
          try {
            const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : void 0;
            stmt.reset();
            return rc;
          } finally {
            stmt.finalize();
          }
        };
        const __selectAll = (db, sql, bind, rowMode) => db.exec({
          sql,
          bind,
          rowMode,
          returnValue: "resultRows"
        });
        DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);
        DB.prototype = {
          isOpen: function() {
            return !!this.pointer;
          },
          affirmOpen: function() {
            return affirmDbOpen(this);
          },
          close: function() {
            if (this.pointer) {
              if (this.onclose && this.onclose.before instanceof Function) {
                try {
                  this.onclose.before(this);
                } catch (e6) {
                }
              }
              const pDb2 = this.pointer;
              Object.keys(__stmtMap.get(this)).forEach((k6, s3) => {
                if (s3 && s3.pointer) {
                  try {
                    s3.finalize();
                  } catch (e6) {
                  }
                }
              });
              __ptrMap.delete(this);
              __stmtMap.delete(this);
              capi.sqlite3_close_v2(pDb2);
              if (this.onclose && this.onclose.after instanceof Function) {
                try {
                  this.onclose.after(this);
                } catch (e6) {
                }
              }
              delete this.filename;
            }
          },
          changes: function(total = false, sixtyFour = false) {
            const p5 = affirmDbOpen(this).pointer;
            if (total) {
              return sixtyFour ? capi.sqlite3_total_changes64(p5) : capi.sqlite3_total_changes(p5);
            } else {
              return sixtyFour ? capi.sqlite3_changes64(p5) : capi.sqlite3_changes(p5);
            }
          },
          dbFilename: function(dbName = "main") {
            return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
          },
          dbName: function(dbNumber = 0) {
            return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
          },
          dbVfsName: function(dbName = 0) {
            let rc;
            const pVfs = capi.sqlite3_js_db_vfs(
              affirmDbOpen(this).pointer,
              dbName
            );
            if (pVfs) {
              const v8 = new capi.sqlite3_vfs(pVfs);
              try {
                rc = wasm.cstrToJs(v8.$zName);
              } finally {
                v8.dispose();
              }
            }
            return rc;
          },
          prepare: function(sql) {
            affirmDbOpen(this);
            const stack = wasm.pstack.pointer;
            let ppStmt, pStmt;
            try {
              ppStmt = wasm.pstack.alloc(8);
              DB.checkRc(
                this,
                capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null)
              );
              pStmt = wasm.peekPtr(ppStmt);
            } finally {
              wasm.pstack.restore(stack);
            }
            if (!pStmt)
              toss3("Cannot prepare empty SQL.");
            const stmt = new Stmt(this, pStmt, BindTypes);
            __stmtMap.get(this)[pStmt] = stmt;
            return stmt;
          },
          exec: function() {
            affirmDbOpen(this);
            const arg = parseExecArgs(this, arguments);
            if (!arg.sql) {
              return toss3("exec() requires an SQL string.");
            }
            const opt = arg.opt;
            const callback = opt.callback;
            const resultRows = Array.isArray(opt.resultRows) ? opt.resultRows : void 0;
            let stmt;
            let bind = opt.bind;
            let evalFirstResult = !!(arg.cbArg || opt.columnNames || resultRows);
            const stack = wasm.scopedAllocPush();
            const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : void 0;
            try {
              const isTA = util.isSQLableTypedArray(arg.sql);
              let sqlByteLen = isTA ? arg.sql.byteLength : wasm.jstrlen(arg.sql);
              const ppStmt = wasm.scopedAlloc(
                2 * wasm.ptrSizeof + (sqlByteLen + 1)
              );
              const pzTail = ppStmt + wasm.ptrSizeof;
              let pSql = pzTail + wasm.ptrSizeof;
              const pSqlEnd = pSql + sqlByteLen;
              if (isTA)
                wasm.heap8().set(arg.sql, pSql);
              else
                wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
              wasm.poke(pSql + sqlByteLen, 0);
              while (pSql && wasm.peek(pSql, "i8")) {
                wasm.pokePtr([ppStmt, pzTail], 0);
                DB.checkRc(
                  this,
                  capi.sqlite3_prepare_v3(
                    this.pointer,
                    pSql,
                    sqlByteLen,
                    0,
                    ppStmt,
                    pzTail
                  )
                );
                const pStmt = wasm.peekPtr(ppStmt);
                pSql = wasm.peekPtr(pzTail);
                sqlByteLen = pSqlEnd - pSql;
                if (!pStmt)
                  continue;
                if (saveSql)
                  saveSql.push(capi.sqlite3_sql(pStmt).trim());
                stmt = new Stmt(this, pStmt, BindTypes);
                if (bind && stmt.parameterCount) {
                  stmt.bind(bind);
                  bind = null;
                }
                if (evalFirstResult && stmt.columnCount) {
                  let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;
                  evalFirstResult = false;
                  if (arg.cbArg || resultRows) {
                    const cbArgCache = /* @__PURE__ */ Object.create(null);
                    for (; stmt.step(); stmt._lockedByExec = false) {
                      if (0 === gotColNames++) {
                        stmt.getColumnNames(
                          cbArgCache.columnNames = opt.columnNames || []
                        );
                      }
                      stmt._lockedByExec = true;
                      const row = arg.cbArg(stmt, cbArgCache);
                      if (resultRows)
                        resultRows.push(row);
                      if (callback && false === callback.call(opt, row, stmt)) {
                        break;
                      }
                    }
                    stmt._lockedByExec = false;
                  }
                  if (0 === gotColNames) {
                    stmt.getColumnNames(opt.columnNames);
                  }
                } else {
                  stmt.step();
                }
                stmt.reset().finalize();
                stmt = null;
              }
            } finally {
              wasm.scopedAllocPop(stack);
              if (stmt) {
                delete stmt._lockedByExec;
                stmt.finalize();
              }
            }
            return arg.returnVal();
          },
          createFunction: function f5(name, xFunc, opt) {
            const isFunc = (f6) => f6 instanceof Function;
            switch (arguments.length) {
              case 1:
                opt = name;
                name = opt.name;
                xFunc = opt.xFunc || 0;
                break;
              case 2:
                if (!isFunc(xFunc)) {
                  opt = xFunc;
                  xFunc = opt.xFunc || 0;
                }
                break;
              case 3:
                break;
              default:
                break;
            }
            if (!opt)
              opt = {};
            if ("string" !== typeof name) {
              toss3("Invalid arguments: missing function name.");
            }
            let xStep = opt.xStep || 0;
            let xFinal = opt.xFinal || 0;
            const xValue = opt.xValue || 0;
            const xInverse = opt.xInverse || 0;
            let isWindow = void 0;
            if (isFunc(xFunc)) {
              isWindow = false;
              if (isFunc(xStep) || isFunc(xFinal)) {
                toss3("Ambiguous arguments: scalar or aggregate?");
              }
              xStep = xFinal = null;
            } else if (isFunc(xStep)) {
              if (!isFunc(xFinal)) {
                toss3("Missing xFinal() callback for aggregate or window UDF.");
              }
              xFunc = null;
            } else if (isFunc(xFinal)) {
              toss3("Missing xStep() callback for aggregate or window UDF.");
            } else {
              toss3("Missing function-type properties.");
            }
            if (false === isWindow) {
              if (isFunc(xValue) || isFunc(xInverse)) {
                toss3(
                  "xValue and xInverse are not permitted for non-window UDFs."
                );
              }
            } else if (isFunc(xValue)) {
              if (!isFunc(xInverse)) {
                toss3("xInverse must be provided if xValue is.");
              }
              isWindow = true;
            } else if (isFunc(xInverse)) {
              toss3("xValue must be provided if xInverse is.");
            }
            const pApp = opt.pApp;
            if (void 0 !== pApp && null !== pApp && ("number" !== typeof pApp || !util.isInt32(pApp))) {
              toss3(
                "Invalid value for pApp property. Must be a legal WASM pointer value."
              );
            }
            const xDestroy = opt.xDestroy || 0;
            if (xDestroy && !isFunc(xDestroy)) {
              toss3("xDestroy property must be a function.");
            }
            let fFlags = 0;
            if (getOwnOption(opt, "deterministic"))
              fFlags |= capi.SQLITE_DETERMINISTIC;
            if (getOwnOption(opt, "directOnly"))
              fFlags |= capi.SQLITE_DIRECTONLY;
            if (getOwnOption(opt, "innocuous"))
              fFlags |= capi.SQLITE_INNOCUOUS;
            name = name.toLowerCase();
            const xArity = xFunc || xStep;
            const arity = getOwnOption(opt, "arity");
            const arityArg = "number" === typeof arity ? arity : xArity.length ? xArity.length - 1 : 0;
            let rc;
            if (isWindow) {
              rc = capi.sqlite3_create_window_function(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy
              );
            } else {
              rc = capi.sqlite3_create_function_v2(
                this.pointer,
                name,
                arityArg,
                capi.SQLITE_UTF8 | fFlags,
                pApp || 0,
                xFunc,
                xStep,
                xFinal,
                xDestroy
              );
            }
            DB.checkRc(this, rc);
            return this;
          },
          selectValue: function(sql, bind, asType) {
            return __selectFirstRow(this, sql, bind, 0, asType);
          },
          selectValues: function(sql, bind, asType) {
            const stmt = this.prepare(sql), rc = [];
            try {
              stmt.bind(bind);
              while (stmt.step())
                rc.push(stmt.get(0, asType));
              stmt.reset();
            } finally {
              stmt.finalize();
            }
            return rc;
          },
          selectArray: function(sql, bind) {
            return __selectFirstRow(this, sql, bind, []);
          },
          selectObject: function(sql, bind) {
            return __selectFirstRow(this, sql, bind, {});
          },
          selectArrays: function(sql, bind) {
            return __selectAll(this, sql, bind, "array");
          },
          selectObjects: function(sql, bind) {
            return __selectAll(this, sql, bind, "object");
          },
          openStatementCount: function() {
            return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
          },
          transaction: function(callback) {
            let opener = "BEGIN";
            if (arguments.length > 1) {
              if (/[^a-zA-Z]/.test(arguments[0])) {
                toss3(
                  capi.SQLITE_MISUSE,
                  "Invalid argument for BEGIN qualifier."
                );
              }
              opener += " " + arguments[0];
              callback = arguments[1];
            }
            affirmDbOpen(this).exec(opener);
            try {
              const rc = callback(this);
              this.exec("COMMIT");
              return rc;
            } catch (e6) {
              this.exec("ROLLBACK");
              throw e6;
            }
          },
          savepoint: function(callback) {
            affirmDbOpen(this).exec("SAVEPOINT oo1");
            try {
              const rc = callback(this);
              this.exec("RELEASE oo1");
              return rc;
            } catch (e6) {
              this.exec("ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1");
              throw e6;
            }
          },
          checkRc: function(resultCode) {
            return checkSqlite3Rc(this, resultCode);
          }
        };
        const affirmStmtOpen = function(stmt) {
          if (!stmt.pointer)
            toss3("Stmt has been closed.");
          return stmt;
        };
        const isSupportedBindType = function(v8) {
          let t5 = BindTypes[null === v8 || void 0 === v8 ? "null" : typeof v8];
          switch (t5) {
            case BindTypes.boolean:
            case BindTypes.null:
            case BindTypes.number:
            case BindTypes.string:
              return t5;
            case BindTypes.bigint:
              if (wasm.bigIntEnabled)
                return t5;
            default:
              return util.isBindableTypedArray(v8) ? BindTypes.blob : void 0;
          }
        };
        const affirmSupportedBindType = function(v8) {
          return isSupportedBindType(v8) || toss3("Unsupported bind() argument type:", typeof v8);
        };
        const affirmParamIndex = function(stmt, key) {
          const n6 = "number" === typeof key ? key : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
          if (0 === n6 || !util.isInt32(n6)) {
            toss3("Invalid bind() parameter name: " + key);
          } else if (n6 < 1 || n6 > stmt.parameterCount)
            toss3("Bind index", key, "is out of range.");
          return n6;
        };
        const affirmNotLockedByExec = function(stmt, currentOpName) {
          if (stmt._lockedByExec) {
            toss3(
              "Operation is illegal when statement is locked:",
              currentOpName
            );
          }
          return stmt;
        };
        const bindOne = function f5(stmt, ndx, bindType, val) {
          affirmNotLockedByExec(affirmStmtOpen(stmt), "bind()");
          if (!f5._) {
            f5._tooBigInt = (v8) => toss3(
              "BigInt value is too big to store without precision loss:",
              v8
            );
            f5._ = {
              string: function(stmt2, ndx2, val2, asBlob) {
                const [pStr, n6] = wasm.allocCString(val2, true);
                const f6 = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;
                return f6(stmt2.pointer, ndx2, pStr, n6, capi.SQLITE_WASM_DEALLOC);
              }
            };
          }
          affirmSupportedBindType(val);
          ndx = affirmParamIndex(stmt, ndx);
          let rc = 0;
          switch (null === val || void 0 === val ? BindTypes.null : bindType) {
            case BindTypes.null:
              rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
              break;
            case BindTypes.string:
              rc = f5._.string(stmt, ndx, val, false);
              break;
            case BindTypes.number: {
              let m7;
              if (util.isInt32(val))
                m7 = capi.sqlite3_bind_int;
              else if ("bigint" === typeof val) {
                if (!util.bigIntFits64(val)) {
                  f5._tooBigInt(val);
                } else if (wasm.bigIntEnabled) {
                  m7 = capi.sqlite3_bind_int64;
                } else if (util.bigIntFitsDouble(val)) {
                  val = Number(val);
                  m7 = capi.sqlite3_bind_double;
                } else {
                  f5._tooBigInt(val);
                }
              } else {
                val = Number(val);
                if (wasm.bigIntEnabled && Number.isInteger(val)) {
                  m7 = capi.sqlite3_bind_int64;
                } else {
                  m7 = capi.sqlite3_bind_double;
                }
              }
              rc = m7(stmt.pointer, ndx, val);
              break;
            }
            case BindTypes.boolean:
              rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
              break;
            case BindTypes.blob: {
              if ("string" === typeof val) {
                rc = f5._.string(stmt, ndx, val, true);
                break;
              } else if (val instanceof ArrayBuffer) {
                val = new Uint8Array(val);
              } else if (!util.isBindableTypedArray(val)) {
                toss3(
                  "Binding a value as a blob requires",
                  "that it be a string, Uint8Array, Int8Array, or ArrayBuffer."
                );
              }
              const pBlob = wasm.alloc(val.byteLength || 1);
              wasm.heap8().set(val.byteLength ? val : [0], pBlob);
              rc = capi.sqlite3_bind_blob(
                stmt.pointer,
                ndx,
                pBlob,
                val.byteLength,
                capi.SQLITE_WASM_DEALLOC
              );
              break;
            }
            default:
              sqlite3.config.warn("Unsupported bind() argument type:", val);
              toss3("Unsupported bind() argument type: " + typeof val);
          }
          if (rc)
            DB.checkRc(stmt.db.pointer, rc);
          stmt._mayGet = false;
          return stmt;
        };
        Stmt.prototype = {
          finalize: function() {
            if (this.pointer) {
              affirmNotLockedByExec(this, "finalize()");
              const rc = capi.sqlite3_finalize(this.pointer);
              delete __stmtMap.get(this.db)[this.pointer];
              __ptrMap.delete(this);
              delete this._mayGet;
              delete this.parameterCount;
              delete this._lockedByExec;
              delete this.db;
              return rc;
            }
          },
          clearBindings: function() {
            affirmNotLockedByExec(affirmStmtOpen(this), "clearBindings()");
            capi.sqlite3_clear_bindings(this.pointer);
            this._mayGet = false;
            return this;
          },
          reset: function(alsoClearBinds) {
            affirmNotLockedByExec(this, "reset()");
            if (alsoClearBinds)
              this.clearBindings();
            const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
            this._mayGet = false;
            checkSqlite3Rc(this.db, rc);
            return this;
          },
          bind: function() {
            affirmStmtOpen(this);
            let ndx, arg;
            switch (arguments.length) {
              case 1:
                ndx = 1;
                arg = arguments[0];
                break;
              case 2:
                ndx = arguments[0];
                arg = arguments[1];
                break;
              default:
                toss3("Invalid bind() arguments.");
            }
            if (void 0 === arg) {
              return this;
            } else if (!this.parameterCount) {
              toss3("This statement has no bindable parameters.");
            }
            this._mayGet = false;
            if (null === arg) {
              return bindOne(this, ndx, BindTypes.null, arg);
            } else if (Array.isArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  "When binding an array, an index argument is not permitted."
                );
              }
              arg.forEach(
                (v8, i4) => bindOne(this, i4 + 1, affirmSupportedBindType(v8), v8)
              );
              return this;
            } else if (arg instanceof ArrayBuffer) {
              arg = new Uint8Array(arg);
            }
            if ("object" === typeof arg && !util.isBindableTypedArray(arg)) {
              if (1 !== arguments.length) {
                toss3(
                  "When binding an object, an index argument is not permitted."
                );
              }
              Object.keys(arg).forEach(
                (k6) => bindOne(this, k6, affirmSupportedBindType(arg[k6]), arg[k6])
              );
              return this;
            } else {
              return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
            }
            toss3("Should not reach this point.");
          },
          bindAsBlob: function(ndx, arg) {
            affirmStmtOpen(this);
            if (1 === arguments.length) {
              arg = ndx;
              ndx = 1;
            }
            const t5 = affirmSupportedBindType(arg);
            if (BindTypes.string !== t5 && BindTypes.blob !== t5 && BindTypes.null !== t5) {
              toss3("Invalid value type for bindAsBlob()");
            }
            return bindOne(this, ndx, BindTypes.blob, arg);
          },
          step: function() {
            affirmNotLockedByExec(this, "step()");
            const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
            switch (rc) {
              case capi.SQLITE_DONE:
                return this._mayGet = false;
              case capi.SQLITE_ROW:
                return this._mayGet = true;
              default:
                this._mayGet = false;
                sqlite3.config.warn(
                  "sqlite3_step() rc=",
                  rc,
                  capi.sqlite3_js_rc_str(rc),
                  "SQL =",
                  capi.sqlite3_sql(this.pointer)
                );
                DB.checkRc(this.db.pointer, rc);
            }
          },
          stepReset: function() {
            this.step();
            return this.reset();
          },
          stepFinalize: function() {
            try {
              const rc = this.step();
              this.reset();
              return rc;
            } finally {
              try {
                this.finalize();
              } catch (e6) {
              }
            }
          },
          get: function(ndx, asType) {
            if (!affirmStmtOpen(this)._mayGet) {
              toss3("Stmt.step() has not (recently) returned true.");
            }
            if (Array.isArray(ndx)) {
              let i4 = 0;
              const n6 = this.columnCount;
              while (i4 < n6) {
                ndx[i4] = this.get(i4++);
              }
              return ndx;
            } else if (ndx && "object" === typeof ndx) {
              let i4 = 0;
              const n6 = this.columnCount;
              while (i4 < n6) {
                ndx[capi.sqlite3_column_name(this.pointer, i4)] = this.get(i4++);
              }
              return ndx;
            }
            affirmColIndex(this, ndx);
            switch (void 0 === asType ? capi.sqlite3_column_type(this.pointer, ndx) : asType) {
              case capi.SQLITE_NULL:
                return null;
              case capi.SQLITE_INTEGER: {
                if (wasm.bigIntEnabled) {
                  const rc = capi.sqlite3_column_int64(this.pointer, ndx);
                  if (rc >= Number.MIN_SAFE_INTEGER && rc <= Number.MAX_SAFE_INTEGER) {
                    return Number(rc).valueOf();
                  }
                  return rc;
                } else {
                  const rc = capi.sqlite3_column_double(this.pointer, ndx);
                  if (rc > Number.MAX_SAFE_INTEGER || rc < Number.MIN_SAFE_INTEGER) {
                    toss3(
                      "Integer is out of range for JS integer range: " + rc
                    );
                  }
                  return util.isInt32(rc) ? rc | 0 : rc;
                }
              }
              case capi.SQLITE_FLOAT:
                return capi.sqlite3_column_double(this.pointer, ndx);
              case capi.SQLITE_TEXT:
                return capi.sqlite3_column_text(this.pointer, ndx);
              case capi.SQLITE_BLOB: {
                const n6 = capi.sqlite3_column_bytes(this.pointer, ndx), ptr = capi.sqlite3_column_blob(this.pointer, ndx), rc = new Uint8Array(n6);
                if (n6)
                  rc.set(wasm.heap8u().slice(ptr, ptr + n6), 0);
                if (n6 && this.db._blobXfer instanceof Array) {
                  this.db._blobXfer.push(rc.buffer);
                }
                return rc;
              }
              default:
                toss3(
                  "Don't know how to translate",
                  "type of result column #" + ndx + "."
                );
            }
            toss3("Not reached.");
          },
          getInt: function(ndx) {
            return this.get(ndx, capi.SQLITE_INTEGER);
          },
          getFloat: function(ndx) {
            return this.get(ndx, capi.SQLITE_FLOAT);
          },
          getString: function(ndx) {
            return this.get(ndx, capi.SQLITE_TEXT);
          },
          getBlob: function(ndx) {
            return this.get(ndx, capi.SQLITE_BLOB);
          },
          getJSON: function(ndx) {
            const s3 = this.get(ndx, capi.SQLITE_STRING);
            return null === s3 ? s3 : JSON.parse(s3);
          },
          getColumnName: function(ndx) {
            return capi.sqlite3_column_name(
              affirmColIndex(affirmStmtOpen(this), ndx).pointer,
              ndx
            );
          },
          getColumnNames: function(tgt = []) {
            affirmColIndex(affirmStmtOpen(this), 0);
            const n6 = this.columnCount;
            for (let i4 = 0; i4 < n6; ++i4) {
              tgt.push(capi.sqlite3_column_name(this.pointer, i4));
            }
            return tgt;
          },
          getParamIndex: function(name) {
            return affirmStmtOpen(this).parameterCount ? capi.sqlite3_bind_parameter_index(this.pointer, name) : void 0;
          }
        };
        {
          const prop = {
            enumerable: true,
            get: function() {
              return __ptrMap.get(this);
            },
            set: () => toss3("The pointer property is read-only.")
          };
          Object.defineProperty(Stmt.prototype, "pointer", prop);
          Object.defineProperty(DB.prototype, "pointer", prop);
        }
        Object.defineProperty(Stmt.prototype, "columnCount", {
          enumerable: false,
          get: function() {
            return capi.sqlite3_column_count(this.pointer);
          },
          set: () => toss3("The columnCount property is read-only.")
        });
        sqlite3.oo1 = {
          DB,
          Stmt
        };
        if (util.isUIThread()) {
          sqlite3.oo1.JsStorageDb = function(storageName = "session") {
            const opt = dbCtorHelper.normalizeArgs(...arguments);
            storageName = opt.filename;
            if ("session" !== storageName && "local" !== storageName) {
              toss3("JsStorageDb db name must be one of 'session' or 'local'.");
            }
            opt.vfs = "kvvfs";
            dbCtorHelper.call(this, opt);
          };
          const jdb = sqlite3.oo1.JsStorageDb;
          jdb.prototype = Object.create(DB.prototype);
          jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;
          jdb.prototype.clearStorage = function() {
            return jdb.clearStorage(affirmDbOpen(this).filename);
          };
          jdb.storageSize = capi.sqlite3_js_kvvfs_size;
          jdb.prototype.storageSize = function() {
            return jdb.storageSize(affirmDbOpen(this).filename);
          };
        }
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const util = sqlite3.util;
        sqlite3.initWorker1API = function() {
          "use strict";
          const toss = (...args) => {
            throw new Error(args.join(" "));
          };
          if (!(globalThis.WorkerGlobalScope instanceof Function)) {
            toss("initWorker1API() must be run from a Worker thread.");
          }
          const sqlite32 = this.sqlite3 || toss("Missing this.sqlite3 object.");
          const DB = sqlite32.oo1.DB;
          const getDbId = function(db) {
            let id = wState.idMap.get(db);
            if (id)
              return id;
            id = "db#" + ++wState.idSeq + "@" + db.pointer;
            wState.idMap.set(db, id);
            return id;
          };
          const wState = {
            dbList: [],
            idSeq: 0,
            idMap: /* @__PURE__ */ new WeakMap(),
            xfer: [],
            open: function(opt) {
              const db = new DB(opt);
              this.dbs[getDbId(db)] = db;
              if (this.dbList.indexOf(db) < 0)
                this.dbList.push(db);
              return db;
            },
            close: function(db, alsoUnlink) {
              if (db) {
                delete this.dbs[getDbId(db)];
                const filename = db.filename;
                const pVfs = util.sqlite3__wasm_db_vfs(db.pointer, 0);
                db.close();
                const ddNdx = this.dbList.indexOf(db);
                if (ddNdx >= 0)
                  this.dbList.splice(ddNdx, 1);
                if (alsoUnlink && filename && pVfs) {
                  util.sqlite3__wasm_vfs_unlink(pVfs, filename);
                }
              }
            },
            post: function(msg, xferList) {
              if (xferList && xferList.length) {
                globalThis.postMessage(msg, Array.from(xferList));
                xferList.length = 0;
              } else {
                globalThis.postMessage(msg);
              }
            },
            dbs: /* @__PURE__ */ Object.create(null),
            getDb: function(id, require2 = true) {
              return this.dbs[id] || (require2 ? toss("Unknown (or closed) DB ID:", id) : void 0);
            }
          };
          const affirmDbOpen = function(db = wState.dbList[0]) {
            return db && db.pointer ? db : toss("DB is not opened.");
          };
          const getMsgDb = function(msgData, affirmExists = true) {
            const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];
            return affirmExists ? affirmDbOpen(db) : db;
          };
          const getDefaultDbId = function() {
            return wState.dbList[0] && getDbId(wState.dbList[0]);
          };
          const isSpecialDbFilename = (n6) => {
            return "" === n6 || ":" === n6[0];
          };
          const wMsgHandler = {
            open: function(ev) {
              const oargs = /* @__PURE__ */ Object.create(null), args = ev.args || /* @__PURE__ */ Object.create(null);
              if (args.simulateError) {
                toss("Throwing because of simulateError flag.");
              }
              const rc = /* @__PURE__ */ Object.create(null);
              oargs.vfs = args.vfs;
              oargs.filename = args.filename || "";
              const db = wState.open(oargs);
              rc.filename = db.filename;
              rc.persistent = !!sqlite32.capi.sqlite3_js_db_uses_vfs(
                db.pointer,
                "opfs"
              );
              rc.dbId = getDbId(db);
              rc.vfs = db.dbVfsName();
              return rc;
            },
            close: function(ev) {
              const db = getMsgDb(ev, false);
              const response = {
                filename: db && db.filename
              };
              if (db) {
                const doUnlink = ev.args && "object" === typeof ev.args ? !!ev.args.unlink : false;
                wState.close(db, doUnlink);
              }
              return response;
            },
            exec: function(ev) {
              const rc = "string" === typeof ev.args ? { sql: ev.args } : ev.args || /* @__PURE__ */ Object.create(null);
              if ("stmt" === rc.rowMode) {
                toss(
                  "Invalid rowMode for 'exec': stmt mode",
                  "does not work in the Worker API."
                );
              } else if (!rc.sql) {
                toss("'exec' requires input SQL.");
              }
              const db = getMsgDb(ev);
              if (rc.callback || Array.isArray(rc.resultRows)) {
                db._blobXfer = wState.xfer;
              }
              const theCallback = rc.callback;
              let rowNumber = 0;
              const hadColNames = !!rc.columnNames;
              if ("string" === typeof theCallback) {
                if (!hadColNames)
                  rc.columnNames = [];
                rc.callback = function(row, stmt) {
                  wState.post(
                    {
                      type: theCallback,
                      columnNames: rc.columnNames,
                      rowNumber: ++rowNumber,
                      row
                    },
                    wState.xfer
                  );
                };
              }
              try {
                const changeCount = !!rc.countChanges ? db.changes(true, 64 === rc.countChanges) : void 0;
                db.exec(rc);
                if (void 0 !== changeCount) {
                  rc.changeCount = db.changes(true, 64 === rc.countChanges) - changeCount;
                }
                if (rc.callback instanceof Function) {
                  rc.callback = theCallback;
                  wState.post({
                    type: theCallback,
                    columnNames: rc.columnNames,
                    rowNumber: null,
                    row: void 0
                  });
                }
              } finally {
                delete db._blobXfer;
                if (rc.callback)
                  rc.callback = theCallback;
              }
              return rc;
            },
            "config-get": function() {
              const rc = /* @__PURE__ */ Object.create(null), src = sqlite32.config;
              ["bigIntEnabled"].forEach(function(k6) {
                if (Object.getOwnPropertyDescriptor(src, k6))
                  rc[k6] = src[k6];
              });
              rc.version = sqlite32.version;
              rc.vfsList = sqlite32.capi.sqlite3_js_vfs_list();
              rc.opfsEnabled = !!sqlite32.opfs;
              return rc;
            },
            export: function(ev) {
              const db = getMsgDb(ev);
              const response = {
                byteArray: sqlite32.capi.sqlite3_js_db_export(db.pointer),
                filename: db.filename,
                mimetype: "application/x-sqlite3"
              };
              wState.xfer.push(response.byteArray.buffer);
              return response;
            },
            toss: function(ev) {
              toss("Testing worker exception");
            },
            "opfs-tree": async function(ev) {
              if (!sqlite32.opfs)
                toss("OPFS support is unavailable.");
              const response = await sqlite32.opfs.treeList();
              return response;
            }
          };
          globalThis.onmessage = async function(ev) {
            ev = ev.data;
            let result, dbId = ev.dbId, evType = ev.type;
            const arrivalTime = performance.now();
            try {
              if (wMsgHandler.hasOwnProperty(evType) && wMsgHandler[evType] instanceof Function) {
                result = await wMsgHandler[evType](ev);
              } else {
                toss("Unknown db worker message type:", ev.type);
              }
            } catch (err2) {
              evType = "error";
              result = {
                operation: ev.type,
                message: err2.message,
                errorClass: err2.name,
                input: ev
              };
              if (err2.stack) {
                result.stack = "string" === typeof err2.stack ? err2.stack.split(/\n\s*/) : err2.stack;
              }
              if (0)
                sqlite32.config.warn(
                  "Worker is propagating an exception to main thread.",
                  "Reporting it _here_ for the stack trace:",
                  err2,
                  result
                );
            }
            if (!dbId) {
              dbId = result.dbId || getDefaultDbId();
            }
            wState.post(
              {
                type: evType,
                dbId,
                messageId: ev.messageId,
                workerReceivedTime: arrivalTime,
                workerRespondTime: performance.now(),
                departureTime: ev.departureTime,
                result
              },
              wState.xfer
            );
          };
          globalThis.postMessage({
            type: "sqlite3-api",
            result: "worker1-ready"
          });
        }.bind({ sqlite3 });
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const wasm = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
        const vfs = /* @__PURE__ */ Object.create(null);
        sqlite3.vfs = vfs;
        capi.sqlite3_vfs.prototype.registerVfs = function(asDefault = false) {
          if (!(this instanceof sqlite3.capi.sqlite3_vfs)) {
            toss("Expecting a sqlite3_vfs-type argument.");
          }
          const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
          if (rc) {
            toss("sqlite3_vfs_register(", this, ") failed with rc", rc);
          }
          if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {
            toss(
              "BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS",
              this
            );
          }
          return this;
        };
        vfs.installVfs = function(opt) {
          let count = 0;
          const propList = ["io", "vfs"];
          for (const key of propList) {
            const o5 = opt[key];
            if (o5) {
              ++count;
              o5.struct.installMethods(o5.methods, !!o5.applyArgcCheck);
              if ("vfs" === key) {
                if (!o5.struct.$zName && "string" === typeof o5.name) {
                  o5.struct.addOnDispose(
                    o5.struct.$zName = wasm.allocCString(o5.name)
                  );
                }
                o5.struct.registerVfs(!!o5.asDefault);
              }
            }
          }
          if (!count)
            toss(
              "Misuse: installVfs() options object requires at least",
              "one of:",
              propList
            );
          return this;
        };
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const wasm = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
        const vtab = /* @__PURE__ */ Object.create(null);
        sqlite3.vtab = vtab;
        const sii = capi.sqlite3_index_info;
        sii.prototype.nthConstraint = function(n6, asPtr = false) {
          if (n6 < 0 || n6 >= this.$nConstraint)
            return false;
          const ptr = this.$aConstraint + sii.sqlite3_index_constraint.structInfo.sizeof * n6;
          return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
        };
        sii.prototype.nthConstraintUsage = function(n6, asPtr = false) {
          if (n6 < 0 || n6 >= this.$nConstraint)
            return false;
          const ptr = this.$aConstraintUsage + sii.sqlite3_index_constraint_usage.structInfo.sizeof * n6;
          return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
        };
        sii.prototype.nthOrderBy = function(n6, asPtr = false) {
          if (n6 < 0 || n6 >= this.$nOrderBy)
            return false;
          const ptr = this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n6;
          return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
        };
        const __xWrapFactory = function(methodName, StructType) {
          return function(ptr, removeMapping = false) {
            if (0 === arguments.length)
              ptr = new StructType();
            if (ptr instanceof StructType) {
              this.set(ptr.pointer, ptr);
              return ptr;
            } else if (!wasm.isPtr(ptr)) {
              sqlite3.SQLite3Error.toss(
                "Invalid argument to",
                methodName + "()"
              );
            }
            let rc = this.get(ptr);
            if (removeMapping)
              this.delete(ptr);
            return rc;
          }.bind(/* @__PURE__ */ new Map());
        };
        const StructPtrMapper = function(name, StructType) {
          const __xWrap = __xWrapFactory(name, StructType);
          return Object.assign(/* @__PURE__ */ Object.create(null), {
            StructType,
            create: (ppOut) => {
              const rc = __xWrap();
              wasm.pokePtr(ppOut, rc.pointer);
              return rc;
            },
            get: (pCObj) => __xWrap(pCObj),
            unget: (pCObj) => __xWrap(pCObj, true),
            dispose: (pCObj) => {
              const o5 = __xWrap(pCObj, true);
              if (o5)
                o5.dispose();
            }
          });
        };
        vtab.xVtab = StructPtrMapper("xVtab", capi.sqlite3_vtab);
        vtab.xCursor = StructPtrMapper("xCursor", capi.sqlite3_vtab_cursor);
        vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);
        vtab.xError = function f5(methodName, err2, defaultRc) {
          if (f5.errorReporter instanceof Function) {
            try {
              f5.errorReporter(
                "sqlite3_module::" + methodName + "(): " + err2.message
              );
            } catch (e6) {
            }
          }
          let rc;
          if (err2 instanceof sqlite3.WasmAllocError)
            rc = capi.SQLITE_NOMEM;
          else if (arguments.length > 2)
            rc = defaultRc;
          else if (err2 instanceof sqlite3.SQLite3Error)
            rc = err2.resultCode;
          return rc || capi.SQLITE_ERROR;
        };
        vtab.xError.errorReporter = 1 ? console.error.bind(console) : false;
        vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, "i64");
        vtab.setupModule = function(opt) {
          let createdMod = false;
          const mod7 = this instanceof capi.sqlite3_module ? this : opt.struct || (createdMod = new capi.sqlite3_module());
          try {
            const methods = opt.methods || toss("Missing 'methods' object.");
            for (const e6 of Object.entries({
              xConnect: "xCreate",
              xDisconnect: "xDestroy"
            })) {
              const k6 = e6[0], v8 = e6[1];
              if (true === methods[k6])
                methods[k6] = methods[v8];
              else if (true === methods[v8])
                methods[v8] = methods[k6];
            }
            if (opt.catchExceptions) {
              const fwrap = function(methodName, func) {
                if (["xConnect", "xCreate"].indexOf(methodName) >= 0) {
                  return function(pDb2, pAux, argc, argv, ppVtab, pzErr) {
                    try {
                      return func(...arguments) || 0;
                    } catch (e6) {
                      if (!(e6 instanceof sqlite3.WasmAllocError)) {
                        wasm.dealloc(wasm.peekPtr(pzErr));
                        wasm.pokePtr(pzErr, wasm.allocCString(e6.message));
                      }
                      return vtab.xError(methodName, e6);
                    }
                  };
                } else {
                  return function(...args) {
                    try {
                      return func(...args) || 0;
                    } catch (e6) {
                      return vtab.xError(methodName, e6);
                    }
                  };
                }
              };
              const mnames = [
                "xCreate",
                "xConnect",
                "xBestIndex",
                "xDisconnect",
                "xDestroy",
                "xOpen",
                "xClose",
                "xFilter",
                "xNext",
                "xEof",
                "xColumn",
                "xRowid",
                "xUpdate",
                "xBegin",
                "xSync",
                "xCommit",
                "xRollback",
                "xFindFunction",
                "xRename",
                "xSavepoint",
                "xRelease",
                "xRollbackTo",
                "xShadowName"
              ];
              const remethods = /* @__PURE__ */ Object.create(null);
              for (const k6 of mnames) {
                const m7 = methods[k6];
                if (!(m7 instanceof Function))
                  continue;
                else if ("xConnect" === k6 && methods.xCreate === m7) {
                  remethods[k6] = methods.xCreate;
                } else if ("xCreate" === k6 && methods.xConnect === m7) {
                  remethods[k6] = methods.xConnect;
                } else {
                  remethods[k6] = fwrap(k6, m7);
                }
              }
              mod7.installMethods(remethods, false);
            } else {
              mod7.installMethods(methods, !!opt.applyArgcCheck);
            }
            if (0 === mod7.$iVersion) {
              let v8;
              if ("number" === typeof opt.iVersion)
                v8 = opt.iVersion;
              else if (mod7.$xShadowName)
                v8 = 3;
              else if (mod7.$xSavePoint || mod7.$xRelease || mod7.$xRollbackTo)
                v8 = 2;
              else
                v8 = 1;
              mod7.$iVersion = v8;
            }
          } catch (e6) {
            if (createdMod)
              createdMod.dispose();
            throw e6;
          }
          return mod7;
        };
        capi.sqlite3_module.prototype.setupModule = function(opt) {
          return vtab.setupModule.call(this, opt);
        };
      });
      "use strict";
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        const installOpfsVfs = function callee2(options) {
          if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {
            return Promise.reject(
              new Error(
                "Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. The server must emit the COOP/COEP response headers to enable those. See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep"
              )
            );
          } else if ("undefined" === typeof WorkerGlobalScope) {
            return Promise.reject(
              new Error(
                "The OPFS sqlite3_vfs cannot run in the main thread because it requires Atomics.wait()."
              )
            );
          } else if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !navigator?.storage?.getDirectory) {
            return Promise.reject(new Error("Missing required OPFS APIs."));
          }
          if (!options || "object" !== typeof options) {
            options = /* @__PURE__ */ Object.create(null);
          }
          const urlParams = new URL(globalThis.location.href).searchParams;
          if (urlParams.has("opfs-disable")) {
            return Promise.resolve(sqlite3);
          }
          if (void 0 === options.verbose) {
            options.verbose = urlParams.has("opfs-verbose") ? +urlParams.get("opfs-verbose") || 2 : 1;
          }
          if (void 0 === options.sanityChecks) {
            options.sanityChecks = urlParams.has("opfs-sanity-check");
          }
          if (void 0 === options.proxyUri) {
            options.proxyUri = callee2.defaultProxyUri;
          }
          if ("function" === typeof options.proxyUri) {
            options.proxyUri = options.proxyUri();
          }
          const thePromise = new Promise(function(promiseResolve_, promiseReject_) {
            const loggers = [
              sqlite3.config.error,
              sqlite3.config.warn,
              sqlite3.config.log
            ];
            const logImpl = (level, ...args) => {
              if (options.verbose > level)
                loggers[level]("OPFS syncer:", ...args);
            };
            const log3 = (...args) => logImpl(2, ...args);
            const warn = (...args) => logImpl(1, ...args);
            const error = (...args) => logImpl(0, ...args);
            const toss = sqlite3.util.toss;
            const capi = sqlite3.capi;
            const util = sqlite3.util;
            const wasm = sqlite3.wasm;
            const sqlite3_vfs = capi.sqlite3_vfs;
            const sqlite3_file = capi.sqlite3_file;
            const sqlite3_io_methods = capi.sqlite3_io_methods;
            const opfsUtil = /* @__PURE__ */ Object.create(null);
            const thisThreadHasOPFS = () => {
              return globalThis.FileSystemHandle && globalThis.FileSystemDirectoryHandle && globalThis.FileSystemFileHandle && globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle && navigator?.storage?.getDirectory;
            };
            opfsUtil.metrics = {
              dump: function() {
                let k6, n6 = 0, t5 = 0, w6 = 0;
                for (k6 in state.opIds) {
                  const m7 = metrics[k6];
                  n6 += m7.count;
                  t5 += m7.time;
                  w6 += m7.wait;
                  m7.avgTime = m7.count && m7.time ? m7.time / m7.count : 0;
                  m7.avgWait = m7.count && m7.wait ? m7.wait / m7.count : 0;
                }
                sqlite3.config.log(
                  globalThis.location.href,
                  "metrics for",
                  globalThis.location.href,
                  ":",
                  metrics,
                  "\nTotal of",
                  n6,
                  "op(s) for",
                  t5,
                  "ms (incl. " + w6 + " ms of waiting on the async side)"
                );
                sqlite3.config.log("Serialization metrics:", metrics.s11n);
                W4.postMessage({ type: "opfs-async-metrics" });
              },
              reset: function() {
                let k6;
                const r6 = (m7) => m7.count = m7.time = m7.wait = 0;
                for (k6 in state.opIds) {
                  r6(metrics[k6] = /* @__PURE__ */ Object.create(null));
                }
                let s3 = metrics.s11n = /* @__PURE__ */ Object.create(null);
                s3 = s3.serialize = /* @__PURE__ */ Object.create(null);
                s3.count = s3.time = 0;
                s3 = metrics.s11n.deserialize = /* @__PURE__ */ Object.create(null);
                s3.count = s3.time = 0;
              }
            };
            const opfsIoMethods = new sqlite3_io_methods();
            const opfsVfs = new sqlite3_vfs().addOnDispose(
              () => opfsIoMethods.dispose()
            );
            let promiseWasRejected = void 0;
            const promiseReject = (err2) => {
              promiseWasRejected = true;
              opfsVfs.dispose();
              return promiseReject_(err2);
            };
            const promiseResolve = () => {
              promiseWasRejected = false;
              return promiseResolve_(sqlite3);
            };
            const W4 = new Worker(
              new URL("sqlite3-opfs-async-proxy.js", import.meta.url)
            );
            setTimeout(() => {
              if (void 0 === promiseWasRejected) {
                promiseReject(
                  new Error(
                    "Timeout while waiting for OPFS async proxy worker."
                  )
                );
              }
            }, 4e3);
            W4._originalOnError = W4.onerror;
            W4.onerror = function(err2) {
              error("Error initializing OPFS asyncer:", err2);
              promiseReject(
                new Error(
                  "Loading OPFS async Worker failed for unknown reasons."
                )
              );
            };
            const pDVfs = capi.sqlite3_vfs_find(null);
            const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;
            opfsIoMethods.$iVersion = 1;
            opfsVfs.$iVersion = 2;
            opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
            opfsVfs.$mxPathname = 1024;
            opfsVfs.$zName = wasm.allocCString("opfs");
            opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;
            opfsVfs.addOnDispose(
              "$zName",
              opfsVfs.$zName,
              "cleanup default VFS wrapper",
              () => dVfs ? dVfs.dispose() : null
            );
            const state = /* @__PURE__ */ Object.create(null);
            state.verbose = options.verbose;
            state.littleEndian = (() => {
              const buffer = new ArrayBuffer(2);
              new DataView(buffer).setInt16(0, 256, true);
              return new Int16Array(buffer)[0] === 256;
            })();
            state.asyncIdleWaitTime = 150;
            state.asyncS11nExceptions = 1;
            state.fileBufferSize = 1024 * 64;
            state.sabS11nOffset = state.fileBufferSize;
            state.sabS11nSize = opfsVfs.$mxPathname * 2;
            state.sabIO = new SharedArrayBuffer(
              state.fileBufferSize + state.sabS11nSize
            );
            state.opIds = /* @__PURE__ */ Object.create(null);
            const metrics = /* @__PURE__ */ Object.create(null);
            {
              let i4 = 0;
              state.opIds.whichOp = i4++;
              state.opIds.rc = i4++;
              state.opIds.xAccess = i4++;
              state.opIds.xClose = i4++;
              state.opIds.xDelete = i4++;
              state.opIds.xDeleteNoWait = i4++;
              state.opIds.xFileSize = i4++;
              state.opIds.xLock = i4++;
              state.opIds.xOpen = i4++;
              state.opIds.xRead = i4++;
              state.opIds.xSleep = i4++;
              state.opIds.xSync = i4++;
              state.opIds.xTruncate = i4++;
              state.opIds.xUnlock = i4++;
              state.opIds.xWrite = i4++;
              state.opIds.mkdir = i4++;
              state.opIds["opfs-async-metrics"] = i4++;
              state.opIds["opfs-async-shutdown"] = i4++;
              state.opIds.retry = i4++;
              state.sabOP = new SharedArrayBuffer(i4 * 4);
              opfsUtil.metrics.reset();
            }
            state.sq3Codes = /* @__PURE__ */ Object.create(null);
            [
              "SQLITE_ACCESS_EXISTS",
              "SQLITE_ACCESS_READWRITE",
              "SQLITE_BUSY",
              "SQLITE_ERROR",
              "SQLITE_IOERR",
              "SQLITE_IOERR_ACCESS",
              "SQLITE_IOERR_CLOSE",
              "SQLITE_IOERR_DELETE",
              "SQLITE_IOERR_FSYNC",
              "SQLITE_IOERR_LOCK",
              "SQLITE_IOERR_READ",
              "SQLITE_IOERR_SHORT_READ",
              "SQLITE_IOERR_TRUNCATE",
              "SQLITE_IOERR_UNLOCK",
              "SQLITE_IOERR_WRITE",
              "SQLITE_LOCK_EXCLUSIVE",
              "SQLITE_LOCK_NONE",
              "SQLITE_LOCK_PENDING",
              "SQLITE_LOCK_RESERVED",
              "SQLITE_LOCK_SHARED",
              "SQLITE_LOCKED",
              "SQLITE_MISUSE",
              "SQLITE_NOTFOUND",
              "SQLITE_OPEN_CREATE",
              "SQLITE_OPEN_DELETEONCLOSE",
              "SQLITE_OPEN_MAIN_DB",
              "SQLITE_OPEN_READONLY"
            ].forEach((k6) => {
              if (void 0 === (state.sq3Codes[k6] = capi[k6])) {
                toss("Maintenance required: not found:", k6);
              }
            });
            state.opfsFlags = Object.assign(/* @__PURE__ */ Object.create(null), {
              OPFS_UNLOCK_ASAP: 1,
              OPFS_UNLINK_BEFORE_OPEN: 2,
              defaultUnlockAsap: false
            });
            const opRun = (op, ...args) => {
              const opNdx = state.opIds[op] || toss("Invalid op ID:", op);
              state.s11n.serialize(...args);
              Atomics.store(state.sabOPView, state.opIds.rc, -1);
              Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
              Atomics.notify(state.sabOPView, state.opIds.whichOp);
              const t5 = performance.now();
              Atomics.wait(state.sabOPView, state.opIds.rc, -1);
              const rc = Atomics.load(state.sabOPView, state.opIds.rc);
              metrics[op].wait += performance.now() - t5;
              if (rc && state.asyncS11nExceptions) {
                const err2 = state.s11n.deserialize();
                if (err2)
                  error(op + "() async error:", ...err2);
              }
              return rc;
            };
            opfsUtil.debug = {
              asyncShutdown: () => {
                warn(
                  "Shutting down OPFS async listener. The OPFS VFS will no longer work."
                );
                opRun("opfs-async-shutdown");
              },
              asyncRestart: () => {
                warn(
                  "Attempting to restart OPFS VFS async listener. Might work, might not."
                );
                W4.postMessage({ type: "opfs-async-restart" });
              }
            };
            const initS11n = () => {
              if (state.s11n)
                return state.s11n;
              const textDecoder = new TextDecoder(), textEncoder = new TextEncoder("utf-8"), viewU8 = new Uint8Array(
                state.sabIO,
                state.sabS11nOffset,
                state.sabS11nSize
              ), viewDV = new DataView(
                state.sabIO,
                state.sabS11nOffset,
                state.sabS11nSize
              );
              state.s11n = /* @__PURE__ */ Object.create(null);
              const TypeIds = /* @__PURE__ */ Object.create(null);
              TypeIds.number = {
                id: 1,
                size: 8,
                getter: "getFloat64",
                setter: "setFloat64"
              };
              TypeIds.bigint = {
                id: 2,
                size: 8,
                getter: "getBigInt64",
                setter: "setBigInt64"
              };
              TypeIds.boolean = {
                id: 3,
                size: 4,
                getter: "getInt32",
                setter: "setInt32"
              };
              TypeIds.string = { id: 4 };
              const getTypeId = (v8) => TypeIds[typeof v8] || toss(
                "Maintenance required: this value type cannot be serialized.",
                v8
              );
              const getTypeIdById = (tid) => {
                switch (tid) {
                  case TypeIds.number.id:
                    return TypeIds.number;
                  case TypeIds.bigint.id:
                    return TypeIds.bigint;
                  case TypeIds.boolean.id:
                    return TypeIds.boolean;
                  case TypeIds.string.id:
                    return TypeIds.string;
                  default:
                    toss("Invalid type ID:", tid);
                }
              };
              state.s11n.deserialize = function(clear = false) {
                ++metrics.s11n.deserialize.count;
                const t5 = performance.now();
                const argc = viewU8[0];
                const rc = argc ? [] : null;
                if (argc) {
                  const typeIds = [];
                  let offset3 = 1, i4, n6, v8;
                  for (i4 = 0; i4 < argc; ++i4, ++offset3) {
                    typeIds.push(getTypeIdById(viewU8[offset3]));
                  }
                  for (i4 = 0; i4 < argc; ++i4) {
                    const t6 = typeIds[i4];
                    if (t6.getter) {
                      v8 = viewDV[t6.getter](offset3, state.littleEndian);
                      offset3 += t6.size;
                    } else {
                      n6 = viewDV.getInt32(offset3, state.littleEndian);
                      offset3 += 4;
                      v8 = textDecoder.decode(viewU8.slice(offset3, offset3 + n6));
                      offset3 += n6;
                    }
                    rc.push(v8);
                  }
                }
                if (clear)
                  viewU8[0] = 0;
                metrics.s11n.deserialize.time += performance.now() - t5;
                return rc;
              };
              state.s11n.serialize = function(...args) {
                const t5 = performance.now();
                ++metrics.s11n.serialize.count;
                if (args.length) {
                  const typeIds = [];
                  let i4 = 0, offset3 = 1;
                  viewU8[0] = args.length & 255;
                  for (; i4 < args.length; ++i4, ++offset3) {
                    typeIds.push(getTypeId(args[i4]));
                    viewU8[offset3] = typeIds[i4].id;
                  }
                  for (i4 = 0; i4 < args.length; ++i4) {
                    const t6 = typeIds[i4];
                    if (t6.setter) {
                      viewDV[t6.setter](offset3, args[i4], state.littleEndian);
                      offset3 += t6.size;
                    } else {
                      const s3 = textEncoder.encode(args[i4]);
                      viewDV.setInt32(offset3, s3.byteLength, state.littleEndian);
                      offset3 += 4;
                      viewU8.set(s3, offset3);
                      offset3 += s3.byteLength;
                    }
                  }
                } else {
                  viewU8[0] = 0;
                }
                metrics.s11n.serialize.time += performance.now() - t5;
              };
              return state.s11n;
            };
            const randomFilename = function f5(len = 16) {
              if (!f5._chars) {
                f5._chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012346789";
                f5._n = f5._chars.length;
              }
              const a3 = [];
              let i4 = 0;
              for (; i4 < len; ++i4) {
                const ndx = Math.random() * (f5._n * 64) % f5._n | 0;
                a3[i4] = f5._chars[ndx];
              }
              return a3.join("");
            };
            const __openFiles = /* @__PURE__ */ Object.create(null);
            const opTimer = /* @__PURE__ */ Object.create(null);
            opTimer.op = void 0;
            opTimer.start = void 0;
            const mTimeStart = (op) => {
              opTimer.start = performance.now();
              opTimer.op = op;
              ++metrics[op].count;
            };
            const mTimeEnd = () => metrics[opTimer.op].time += performance.now() - opTimer.start;
            const ioSyncWrappers = {
              xCheckReservedLock: function(pFile, pOut) {
                const f5 = __openFiles[pFile];
                wasm.poke(pOut, f5.lockType ? 1 : 0, "i32");
                return 0;
              },
              xClose: function(pFile) {
                mTimeStart("xClose");
                let rc = 0;
                const f5 = __openFiles[pFile];
                if (f5) {
                  delete __openFiles[pFile];
                  rc = opRun("xClose", pFile);
                  if (f5.sq3File)
                    f5.sq3File.dispose();
                }
                mTimeEnd();
                return rc;
              },
              xDeviceCharacteristics: function(pFile) {
                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
              },
              xFileControl: function(pFile, opId, pArg) {
                return capi.SQLITE_NOTFOUND;
              },
              xFileSize: function(pFile, pSz64) {
                mTimeStart("xFileSize");
                let rc = opRun("xFileSize", pFile);
                if (0 == rc) {
                  try {
                    const sz = state.s11n.deserialize()[0];
                    wasm.poke(pSz64, sz, "i64");
                  } catch (e6) {
                    error("Unexpected error reading xFileSize() result:", e6);
                    rc = state.sq3Codes.SQLITE_IOERR;
                  }
                }
                mTimeEnd();
                return rc;
              },
              xLock: function(pFile, lockType) {
                mTimeStart("xLock");
                const f5 = __openFiles[pFile];
                let rc = 0;
                if (!f5.lockType) {
                  rc = opRun("xLock", pFile, lockType);
                  if (0 === rc)
                    f5.lockType = lockType;
                } else {
                  f5.lockType = lockType;
                }
                mTimeEnd();
                return rc;
              },
              xRead: function(pFile, pDest, n6, offset64) {
                mTimeStart("xRead");
                const f5 = __openFiles[pFile];
                let rc;
                try {
                  rc = opRun("xRead", pFile, n6, Number(offset64));
                  if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {
                    wasm.heap8u().set(f5.sabView.subarray(0, n6), pDest);
                  }
                } catch (e6) {
                  error("xRead(", arguments, ") failed:", e6, f5);
                  rc = capi.SQLITE_IOERR_READ;
                }
                mTimeEnd();
                return rc;
              },
              xSync: function(pFile, flags) {
                mTimeStart("xSync");
                ++metrics.xSync.count;
                const rc = opRun("xSync", pFile, flags);
                mTimeEnd();
                return rc;
              },
              xTruncate: function(pFile, sz64) {
                mTimeStart("xTruncate");
                const rc = opRun("xTruncate", pFile, Number(sz64));
                mTimeEnd();
                return rc;
              },
              xUnlock: function(pFile, lockType) {
                mTimeStart("xUnlock");
                const f5 = __openFiles[pFile];
                let rc = 0;
                if (capi.SQLITE_LOCK_NONE === lockType && f5.lockType) {
                  rc = opRun("xUnlock", pFile, lockType);
                }
                if (0 === rc)
                  f5.lockType = lockType;
                mTimeEnd();
                return rc;
              },
              xWrite: function(pFile, pSrc, n6, offset64) {
                mTimeStart("xWrite");
                const f5 = __openFiles[pFile];
                let rc;
                try {
                  f5.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n6));
                  rc = opRun("xWrite", pFile, n6, Number(offset64));
                } catch (e6) {
                  error("xWrite(", arguments, ") failed:", e6, f5);
                  rc = capi.SQLITE_IOERR_WRITE;
                }
                mTimeEnd();
                return rc;
              }
            };
            const vfsSyncWrappers = {
              xAccess: function(pVfs, zName, flags, pOut) {
                mTimeStart("xAccess");
                const rc = opRun("xAccess", wasm.cstrToJs(zName));
                wasm.poke(pOut, rc ? 0 : 1, "i32");
                mTimeEnd();
                return 0;
              },
              xCurrentTime: function(pVfs, pOut) {
                wasm.poke(
                  pOut,
                  24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
                  "double"
                );
                return 0;
              },
              xCurrentTimeInt64: function(pVfs, pOut) {
                wasm.poke(
                  pOut,
                  24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(),
                  "i64"
                );
                return 0;
              },
              xDelete: function(pVfs, zName, doSyncDir) {
                mTimeStart("xDelete");
                const rc = opRun(
                  "xDelete",
                  wasm.cstrToJs(zName),
                  doSyncDir,
                  false
                );
                mTimeEnd();
                return rc;
              },
              xFullPathname: function(pVfs, zName, nOut, pOut) {
                const i4 = wasm.cstrncpy(pOut, zName, nOut);
                return i4 < nOut ? 0 : capi.SQLITE_CANTOPEN;
              },
              xGetLastError: function(pVfs, nOut, pOut) {
                warn("OPFS xGetLastError() has nothing sensible to return.");
                return 0;
              },
              xOpen: function f5(pVfs, zName, pFile, flags, pOutFlags) {
                mTimeStart("xOpen");
                let opfsFlags = 0;
                if (0 === zName) {
                  zName = randomFilename();
                } else if (wasm.isPtr(zName)) {
                  if (capi.sqlite3_uri_boolean(zName, "opfs-unlock-asap", 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
                  }
                  if (capi.sqlite3_uri_boolean(zName, "delete-before-open", 0)) {
                    opfsFlags |= state.opfsFlags.OPFS_UNLINK_BEFORE_OPEN;
                  }
                  zName = wasm.cstrToJs(zName);
                }
                const fh = /* @__PURE__ */ Object.create(null);
                fh.fid = pFile;
                fh.filename = zName;
                fh.sab = new SharedArrayBuffer(state.fileBufferSize);
                fh.flags = flags;
                const rc = opRun("xOpen", pFile, zName, flags, opfsFlags);
                if (!rc) {
                  if (fh.readOnly) {
                    wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, "i32");
                  }
                  __openFiles[pFile] = fh;
                  fh.sabView = state.sabFileBufView;
                  fh.sq3File = new sqlite3_file(pFile);
                  fh.sq3File.$pMethods = opfsIoMethods.pointer;
                  fh.lockType = capi.SQLITE_LOCK_NONE;
                }
                mTimeEnd();
                return rc;
              }
            };
            if (dVfs) {
              opfsVfs.$xRandomness = dVfs.$xRandomness;
              opfsVfs.$xSleep = dVfs.$xSleep;
            }
            if (!opfsVfs.$xRandomness) {
              vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut) {
                const heap = wasm.heap8u();
                let i4 = 0;
                for (; i4 < nOut; ++i4)
                  heap[pOut + i4] = Math.random() * 255e3 & 255;
                return i4;
              };
            }
            if (!opfsVfs.$xSleep) {
              vfsSyncWrappers.xSleep = function(pVfs, ms2) {
                Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms2);
                return 0;
              };
            }
            opfsUtil.getResolvedPath = function(filename, splitIt) {
              const p5 = new URL(filename, "file://irrelevant").pathname;
              return splitIt ? p5.split("/").filter((v8) => !!v8) : p5;
            };
            opfsUtil.getDirForFilename = async function f5(absFilename, createDirs = false) {
              const path2 = opfsUtil.getResolvedPath(absFilename, true);
              const filename = path2.pop();
              let dh = opfsUtil.rootDirectory;
              for (const dirName of path2) {
                if (dirName) {
                  dh = await dh.getDirectoryHandle(dirName, {
                    create: !!createDirs
                  });
                }
              }
              return [dh, filename];
            };
            opfsUtil.mkdir = async function(absDirName) {
              try {
                await opfsUtil.getDirForFilename(
                  absDirName + "/filepart",
                  true
                );
                return true;
              } catch (e6) {
                return false;
              }
            };
            opfsUtil.entryExists = async function(fsEntryName) {
              try {
                const [dh, fn2] = await opfsUtil.getDirForFilename(fsEntryName);
                await dh.getFileHandle(fn2);
                return true;
              } catch (e6) {
                return false;
              }
            };
            opfsUtil.randomFilename = randomFilename;
            opfsUtil.treeList = async function() {
              const doDir = async function callee3(dirHandle, tgt) {
                tgt.name = dirHandle.name;
                tgt.dirs = [];
                tgt.files = [];
                for await (const handle of dirHandle.values()) {
                  if ("directory" === handle.kind) {
                    const subDir = /* @__PURE__ */ Object.create(null);
                    tgt.dirs.push(subDir);
                    await callee3(handle, subDir);
                  } else {
                    tgt.files.push(handle.name);
                  }
                }
              };
              const root = /* @__PURE__ */ Object.create(null);
              await doDir(opfsUtil.rootDirectory, root);
              return root;
            };
            opfsUtil.rmfr = async function() {
              const dir = opfsUtil.rootDirectory, opt = { recurse: true };
              for await (const handle of dir.values()) {
                dir.removeEntry(handle.name, opt);
              }
            };
            opfsUtil.unlink = async function(fsEntryName, recursive = false, throwOnError = false) {
              try {
                const [hDir, filenamePart] = await opfsUtil.getDirForFilename(
                  fsEntryName,
                  false
                );
                await hDir.removeEntry(filenamePart, { recursive });
                return true;
              } catch (e6) {
                if (throwOnError) {
                  throw new Error(
                    "unlink(",
                    arguments[0],
                    ") failed: " + e6.message,
                    {
                      cause: e6
                    }
                  );
                }
                return false;
              }
            };
            opfsUtil.traverse = async function(opt) {
              const defaultOpt = {
                recursive: true,
                directory: opfsUtil.rootDirectory
              };
              if ("function" === typeof opt) {
                opt = { callback: opt };
              }
              opt = Object.assign(defaultOpt, opt || {});
              const doDir = async function callee3(dirHandle, depth) {
                for await (const handle of dirHandle.values()) {
                  if (false === opt.callback(handle, dirHandle, depth))
                    return false;
                  else if (opt.recursive && "directory" === handle.kind) {
                    if (false === await callee3(handle, depth + 1))
                      break;
                  }
                }
              };
              doDir(opt.directory, 0);
            };
            const importDbChunked = async function(filename, callback) {
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true
              );
              const hFile = await hDir.getFileHandle(fnamePart, {
                create: true
              });
              let sah = await hFile.createSyncAccessHandle();
              let nWrote = 0, chunk, checkedHeader = false, err2 = false;
              try {
                sah.truncate(0);
                while (void 0 !== (chunk = await callback())) {
                  if (chunk instanceof ArrayBuffer)
                    chunk = new Uint8Array(chunk);
                  if (0 === nWrote && chunk.byteLength >= 15) {
                    util.affirmDbHeader(chunk);
                    checkedHeader = true;
                  }
                  sah.write(chunk, { at: nWrote });
                  nWrote += chunk.byteLength;
                }
                if (nWrote < 512 || 0 !== nWrote % 512) {
                  toss(
                    "Input size",
                    nWrote,
                    "is not correct for an SQLite database."
                  );
                }
                if (!checkedHeader) {
                  const header = new Uint8Array(20);
                  sah.read(header, { at: 0 });
                  util.affirmDbHeader(header);
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e6) {
                await sah.close();
                sah = void 0;
                await hDir.removeEntry(fnamePart).catch(() => {
                });
                throw e6;
              } finally {
                if (sah)
                  await sah.close();
              }
            };
            opfsUtil.importDb = async function(filename, bytes) {
              if (bytes instanceof Function) {
                return importDbChunked(filename, bytes);
              }
              if (bytes instanceof ArrayBuffer)
                bytes = new Uint8Array(bytes);
              util.affirmIsDb(bytes);
              const n6 = bytes.byteLength;
              const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                filename,
                true
              );
              let sah, err2, nWrote = 0;
              try {
                const hFile = await hDir.getFileHandle(fnamePart, {
                  create: true
                });
                sah = await hFile.createSyncAccessHandle();
                sah.truncate(0);
                nWrote = sah.write(bytes, { at: 0 });
                if (nWrote != n6) {
                  toss(
                    "Expected to write " + n6 + " bytes but wrote " + nWrote + "."
                  );
                }
                sah.write(new Uint8Array([1, 1]), { at: 18 });
                return nWrote;
              } catch (e6) {
                if (sah) {
                  await sah.close();
                  sah = void 0;
                }
                await hDir.removeEntry(fnamePart).catch(() => {
                });
                throw e6;
              } finally {
                if (sah)
                  await sah.close();
              }
            };
            if (sqlite3.oo1) {
              const OpfsDb = function(...args) {
                const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
                opt.vfs = opfsVfs.$zName;
                sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
              };
              OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
              sqlite3.oo1.OpfsDb = OpfsDb;
              OpfsDb.importDb = opfsUtil.importDb;
              sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                opfsVfs.pointer,
                function(oo1Db, sqlite32) {
                  sqlite32.capi.sqlite3_busy_timeout(oo1Db, 1e4);
                  sqlite32.capi.sqlite3_exec(
                    oo1Db,
                    [
                      "pragma journal_mode=DELETE;",
                      "pragma cache_size=-16384;"
                    ],
                    0,
                    0,
                    0
                  );
                }
              );
            }
            const sanityCheck = function() {
              const scope = wasm.scopedAllocPush();
              const sq3File = new sqlite3_file();
              try {
                const fid = sq3File.pointer;
                const openFlags = capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE | capi.SQLITE_OPEN_MAIN_DB;
                const pOut = wasm.scopedAlloc(8);
                const dbFile = "/sanity/check/file" + randomFilename(8);
                const zDbFile = wasm.scopedAllocCString(dbFile);
                let rc;
                state.s11n.serialize("This is \xE4 string.");
                rc = state.s11n.deserialize();
                log3("deserialize() says:", rc);
                if ("This is \xE4 string." !== rc[0])
                  toss("String d13n error.");
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                log3("xAccess(", dbFile, ") exists ?=", rc);
                rc = vfsSyncWrappers.xOpen(
                  opfsVfs.pointer,
                  zDbFile,
                  fid,
                  openFlags,
                  pOut
                );
                log3(
                  "open rc =",
                  rc,
                  "state.sabOPView[xOpen] =",
                  state.sabOPView[state.opIds.xOpen]
                );
                if (0 !== rc) {
                  error("open failed with code", rc);
                  return;
                }
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                if (!rc)
                  toss("xAccess() failed to detect file.");
                rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
                if (rc)
                  toss("sync failed w/ rc", rc);
                rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
                if (rc)
                  toss("truncate failed w/ rc", rc);
                wasm.poke(pOut, 0, "i64");
                rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
                if (rc)
                  toss("xFileSize failed w/ rc", rc);
                log3("xFileSize says:", wasm.peek(pOut, "i64"));
                rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
                if (rc)
                  toss("xWrite() failed!");
                const readBuf = wasm.scopedAlloc(16);
                rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
                wasm.poke(readBuf + 6, 0);
                let jRead = wasm.cstrToJs(readBuf);
                log3("xRead() got:", jRead);
                if ("sanity" !== jRead)
                  toss("Unexpected xRead() value.");
                if (vfsSyncWrappers.xSleep) {
                  log3("xSleep()ing before close()ing...");
                  vfsSyncWrappers.xSleep(opfsVfs.pointer, 2e3);
                  log3("waking up from xSleep()");
                }
                rc = ioSyncWrappers.xClose(fid);
                log3("xClose rc =", rc, "sabOPView =", state.sabOPView);
                log3("Deleting file:", dbFile);
                vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 4660);
                vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                rc = wasm.peek(pOut, "i32");
                if (rc)
                  toss(
                    "Expecting 0 from xAccess(",
                    dbFile,
                    ") after xDelete()."
                  );
                warn("End of OPFS sanity checks.");
              } finally {
                sq3File.dispose();
                wasm.scopedAllocPop(scope);
              }
            };
            W4.onmessage = function({ data }) {
              switch (data.type) {
                case "opfs-unavailable":
                  promiseReject(new Error(data.payload.join(" ")));
                  break;
                case "opfs-async-loaded":
                  W4.postMessage({ type: "opfs-async-init", args: state });
                  break;
                case "opfs-async-inited": {
                  if (true === promiseWasRejected) {
                    break;
                  }
                  try {
                    sqlite3.vfs.installVfs({
                      io: { struct: opfsIoMethods, methods: ioSyncWrappers },
                      vfs: { struct: opfsVfs, methods: vfsSyncWrappers }
                    });
                    state.sabOPView = new Int32Array(state.sabOP);
                    state.sabFileBufView = new Uint8Array(
                      state.sabIO,
                      0,
                      state.fileBufferSize
                    );
                    state.sabS11nView = new Uint8Array(
                      state.sabIO,
                      state.sabS11nOffset,
                      state.sabS11nSize
                    );
                    initS11n();
                    if (options.sanityChecks) {
                      warn(
                        "Running sanity checks because of opfs-sanity-check URL arg..."
                      );
                      sanityCheck();
                    }
                    if (thisThreadHasOPFS()) {
                      navigator.storage.getDirectory().then((d4) => {
                        W4.onerror = W4._originalOnError;
                        delete W4._originalOnError;
                        sqlite3.opfs = opfsUtil;
                        opfsUtil.rootDirectory = d4;
                        log3("End of OPFS sqlite3_vfs setup.", opfsVfs);
                        promiseResolve();
                      }).catch(promiseReject);
                    } else {
                      promiseResolve();
                    }
                  } catch (e6) {
                    error(e6);
                    promiseReject(e6);
                  }
                  break;
                }
                default: {
                  const errMsg = "Unexpected message from the OPFS async worker: " + JSON.stringify(data);
                  error(errMsg);
                  promiseReject(new Error(errMsg));
                  break;
                }
              }
            };
          });
          return thePromise;
        };
        installOpfsVfs.defaultProxyUri = "sqlite3-opfs-async-proxy.js";
        globalThis.sqlite3ApiBootstrap.initializersAsync.push(
          async (sqlite32) => {
            try {
              let proxyJs = installOpfsVfs.defaultProxyUri;
              if (sqlite32.scriptInfo.sqlite3Dir) {
                installOpfsVfs.defaultProxyUri = sqlite32.scriptInfo.sqlite3Dir + proxyJs;
              }
              return installOpfsVfs().catch((e6) => {
                sqlite32.config.warn(
                  "Ignoring inability to install OPFS sqlite3_vfs:",
                  e6.message
                );
              });
            } catch (e6) {
              sqlite32.config.error("installOpfsVfs() exception:", e6);
              return Promise.reject(e6);
            }
          }
        );
      });
      globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3) {
        "use strict";
        const toss = sqlite3.util.toss;
        const toss3 = sqlite3.util.toss3;
        const initPromises = /* @__PURE__ */ Object.create(null);
        const capi = sqlite3.capi;
        const util = sqlite3.util;
        const wasm = sqlite3.wasm;
        const SECTOR_SIZE = 4096;
        const HEADER_MAX_PATH_SIZE = 512;
        const HEADER_FLAGS_SIZE = 4;
        const HEADER_DIGEST_SIZE = 8;
        const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
        const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
        const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
        const HEADER_OFFSET_DATA = SECTOR_SIZE;
        const PERSISTENT_FILE_TYPES = capi.SQLITE_OPEN_MAIN_DB | capi.SQLITE_OPEN_MAIN_JOURNAL | capi.SQLITE_OPEN_SUPER_JOURNAL | capi.SQLITE_OPEN_WAL;
        const OPAQUE_DIR_NAME = ".opaque";
        const getRandomName = () => Math.random().toString(36).slice(2);
        const textDecoder = new TextDecoder();
        const textEncoder = new TextEncoder();
        const optionDefaults = Object.assign(/* @__PURE__ */ Object.create(null), {
          name: "opfs-sahpool",
          directory: void 0,
          initialCapacity: 6,
          clearOnInit: false,
          verbosity: 2
        });
        const loggers = [
          sqlite3.config.error,
          sqlite3.config.warn,
          sqlite3.config.log
        ];
        const log3 = sqlite3.config.log;
        const warn = sqlite3.config.warn;
        const error = sqlite3.config.error;
        const __mapVfsToPool = /* @__PURE__ */ new Map();
        const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);
        const setPoolForVfs = (pVfs, pool) => {
          if (pool)
            __mapVfsToPool.set(pVfs, pool);
          else
            __mapVfsToPool.delete(pVfs);
        };
        const __mapSqlite3File = /* @__PURE__ */ new Map();
        const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);
        const setPoolForPFile = (pFile, pool) => {
          if (pool)
            __mapSqlite3File.set(pFile, pool);
          else
            __mapSqlite3File.delete(pFile);
        };
        const ioMethods = {
          xCheckReservedLock: function(pFile, pOut) {
            const pool = getPoolForPFile(pFile);
            pool.log("xCheckReservedLock");
            pool.storeErr();
            wasm.poke32(pOut, 1);
            return 0;
          },
          xClose: function(pFile) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            if (file) {
              try {
                pool.log(`xClose ${file.path}`);
                pool.mapS3FileToOFile(pFile, false);
                file.sah.flush();
                if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {
                  pool.deletePath(file.path);
                }
              } catch (e6) {
                return pool.storeErr(e6, capi.SQLITE_IOERR);
              }
            }
            return 0;
          },
          xDeviceCharacteristics: function(pFile) {
            return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
          },
          xFileControl: function(pFile, opId, pArg) {
            return capi.SQLITE_NOTFOUND;
          },
          xFileSize: function(pFile, pSz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xFileSize`);
            const file = pool.getOFileForS3File(pFile);
            const size3 = file.sah.getSize() - HEADER_OFFSET_DATA;
            wasm.poke64(pSz64, BigInt(size3));
            return 0;
          },
          xLock: function(pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xLock ${lockType}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xRead: function(pFile, pDest, n6, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xRead ${file.path} ${n6} @ ${offset64}`);
            try {
              const nRead = file.sah.read(
                wasm.heap8u().subarray(pDest, pDest + n6),
                { at: HEADER_OFFSET_DATA + Number(offset64) }
              );
              if (nRead < n6) {
                wasm.heap8u().fill(0, pDest + nRead, pDest + n6);
                return capi.SQLITE_IOERR_SHORT_READ;
              }
              return 0;
            } catch (e6) {
              return pool.storeErr(e6, capi.SQLITE_IOERR);
            }
          },
          xSectorSize: function(pFile) {
            return SECTOR_SIZE;
          },
          xSync: function(pFile, flags) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xSync ${flags}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            try {
              file.sah.flush();
              return 0;
            } catch (e6) {
              return pool.storeErr(e6, capi.SQLITE_IOERR);
            }
          },
          xTruncate: function(pFile, sz64) {
            const pool = getPoolForPFile(pFile);
            pool.log(`xTruncate ${sz64}`);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            try {
              file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
              return 0;
            } catch (e6) {
              return pool.storeErr(e6, capi.SQLITE_IOERR);
            }
          },
          xUnlock: function(pFile, lockType) {
            const pool = getPoolForPFile(pFile);
            pool.log("xUnlock");
            const file = pool.getOFileForS3File(pFile);
            file.lockType = lockType;
            return 0;
          },
          xWrite: function(pFile, pSrc, n6, offset64) {
            const pool = getPoolForPFile(pFile);
            pool.storeErr();
            const file = pool.getOFileForS3File(pFile);
            pool.log(`xWrite ${file.path} ${n6} ${offset64}`);
            try {
              const nBytes = file.sah.write(
                wasm.heap8u().subarray(pSrc, pSrc + n6),
                { at: HEADER_OFFSET_DATA + Number(offset64) }
              );
              return n6 === nBytes ? 0 : toss("Unknown write() failure.");
            } catch (e6) {
              return pool.storeErr(e6, capi.SQLITE_IOERR);
            }
          }
        };
        const opfsIoMethods = new capi.sqlite3_io_methods();
        opfsIoMethods.$iVersion = 1;
        sqlite3.vfs.installVfs({
          io: { struct: opfsIoMethods, methods: ioMethods }
        });
        const vfsMethods = {
          xAccess: function(pVfs, zName, flags, pOut) {
            const pool = getPoolForVfs(pVfs);
            pool.storeErr();
            try {
              const name = pool.getPath(zName);
              wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
            } catch (e6) {
              wasm.poke32(pOut, 0);
            }
            return 0;
          },
          xCurrentTime: function(pVfs, pOut) {
            wasm.poke(
              pOut,
              24405875e-1 + (/* @__PURE__ */ new Date()).getTime() / 864e5,
              "double"
            );
            return 0;
          },
          xCurrentTimeInt64: function(pVfs, pOut) {
            wasm.poke(pOut, 24405875e-1 * 864e5 + (/* @__PURE__ */ new Date()).getTime(), "i64");
            return 0;
          },
          xDelete: function(pVfs, zName, doSyncDir) {
            const pool = getPoolForVfs(pVfs);
            pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
            pool.storeErr();
            try {
              pool.deletePath(pool.getPath(zName));
              return 0;
            } catch (e6) {
              pool.storeErr(e6);
              return capi.SQLITE_IOERR_DELETE;
            }
          },
          xFullPathname: function(pVfs, zName, nOut, pOut) {
            const i4 = wasm.cstrncpy(pOut, zName, nOut);
            return i4 < nOut ? 0 : capi.SQLITE_CANTOPEN;
          },
          xGetLastError: function(pVfs, nOut, pOut) {
            const pool = getPoolForVfs(pVfs);
            const e6 = pool.popErr();
            pool.log(`xGetLastError ${nOut} e =`, e6);
            if (e6) {
              const scope = wasm.scopedAllocPush();
              try {
                const [cMsg, n6] = wasm.scopedAllocCString(e6.message, true);
                wasm.cstrncpy(pOut, cMsg, nOut);
                if (n6 > nOut)
                  wasm.poke8(pOut + nOut - 1, 0);
              } catch (e7) {
                return capi.SQLITE_NOMEM;
              } finally {
                wasm.scopedAllocPop(scope);
              }
            }
            return e6 ? e6.sqlite3Rc || capi.SQLITE_IOERR : 0;
          },
          xOpen: function f5(pVfs, zName, pFile, flags, pOutFlags) {
            const pool = getPoolForVfs(pVfs);
            try {
              pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);
              const path2 = zName && wasm.peek8(zName) ? pool.getPath(zName) : getRandomName();
              let sah = pool.getSAHForPath(path2);
              if (!sah && flags & capi.SQLITE_OPEN_CREATE) {
                if (pool.getFileCount() < pool.getCapacity()) {
                  sah = pool.nextAvailableSAH();
                  pool.setAssociatedPath(sah, path2, flags);
                } else {
                  toss("SAH pool is full. Cannot create file", path2);
                }
              }
              if (!sah) {
                toss("file not found:", path2);
              }
              const file = { path: path2, flags, sah };
              pool.mapS3FileToOFile(pFile, file);
              file.lockType = capi.SQLITE_LOCK_NONE;
              const sq3File = new capi.sqlite3_file(pFile);
              sq3File.$pMethods = opfsIoMethods.pointer;
              sq3File.dispose();
              wasm.poke32(pOutFlags, flags);
              return 0;
            } catch (e6) {
              pool.storeErr(e6);
              return capi.SQLITE_CANTOPEN;
            }
          }
        };
        const createOpfsVfs = function(vfsName) {
          if (sqlite3.capi.sqlite3_vfs_find(vfsName)) {
            toss3("VFS name is already registered:", vfsName);
          }
          const opfsVfs = new capi.sqlite3_vfs();
          const pDVfs = capi.sqlite3_vfs_find(null);
          const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;
          opfsVfs.$iVersion = 2;
          opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
          opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
          opfsVfs.addOnDispose(
            opfsVfs.$zName = wasm.allocCString(vfsName),
            () => setPoolForVfs(opfsVfs.pointer, 0)
          );
          if (dVfs) {
            opfsVfs.$xRandomness = dVfs.$xRandomness;
            opfsVfs.$xSleep = dVfs.$xSleep;
            dVfs.dispose();
          }
          if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {
            vfsMethods.xRandomness = function(pVfs, nOut, pOut) {
              const heap = wasm.heap8u();
              let i4 = 0;
              for (; i4 < nOut; ++i4)
                heap[pOut + i4] = Math.random() * 255e3 & 255;
              return i4;
            };
          }
          if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {
            vfsMethods.xSleep = (pVfs, ms2) => 0;
          }
          sqlite3.vfs.installVfs({
            vfs: { struct: opfsVfs, methods: vfsMethods }
          });
          return opfsVfs;
        };
        class OpfsSAHPool {
          vfsDir;
          #dhVfsRoot;
          #dhOpaque;
          #dhVfsParent;
          #mapSAHToName = /* @__PURE__ */ new Map();
          #mapFilenameToSAH = /* @__PURE__ */ new Map();
          #availableSAH = /* @__PURE__ */ new Set();
          #mapS3FileToOFile_ = /* @__PURE__ */ new Map();
          #apBody = new Uint8Array(HEADER_CORPUS_SIZE);
          #dvBody;
          #cVfs;
          #verbosity;
          constructor(options = /* @__PURE__ */ Object.create(null)) {
            this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
            this.vfsName = options.name || optionDefaults.name;
            this.#cVfs = createOpfsVfs(this.vfsName);
            setPoolForVfs(this.#cVfs.pointer, this);
            this.vfsDir = options.directory || "." + this.vfsName;
            this.#dvBody = new DataView(
              this.#apBody.buffer,
              this.#apBody.byteOffset
            );
            this.isReady = this.reset(
              !!(options.clearOnInit ?? optionDefaults.clearOnInit)
            ).then(() => {
              if (this.$error)
                throw this.$error;
              return this.getCapacity() ? Promise.resolve(void 0) : this.addCapacity(
                options.initialCapacity || optionDefaults.initialCapacity
              );
            });
          }
          #logImpl(level, ...args) {
            if (this.#verbosity > level)
              loggers[level](this.vfsName + ":", ...args);
          }
          log(...args) {
            this.#logImpl(2, ...args);
          }
          warn(...args) {
            this.#logImpl(1, ...args);
          }
          error(...args) {
            this.#logImpl(0, ...args);
          }
          getVfs() {
            return this.#cVfs;
          }
          getCapacity() {
            return this.#mapSAHToName.size;
          }
          getFileCount() {
            return this.#mapFilenameToSAH.size;
          }
          getFileNames() {
            const rc = [];
            const iter = this.#mapFilenameToSAH.keys();
            for (const n6 of iter)
              rc.push(n6);
            return rc;
          }
          async addCapacity(n6) {
            for (let i4 = 0; i4 < n6; ++i4) {
              const name = getRandomName();
              const h7 = await this.#dhOpaque.getFileHandle(name, {
                create: true
              });
              const ah = await h7.createSyncAccessHandle();
              this.#mapSAHToName.set(ah, name);
              this.setAssociatedPath(ah, "", 0);
            }
            return this.getCapacity();
          }
          async reduceCapacity(n6) {
            let nRm = 0;
            for (const ah of Array.from(this.#availableSAH)) {
              if (nRm === n6 || this.getFileCount() === this.getCapacity()) {
                break;
              }
              const name = this.#mapSAHToName.get(ah);
              ah.close();
              await this.#dhOpaque.removeEntry(name);
              this.#mapSAHToName.delete(ah);
              this.#availableSAH.delete(ah);
              ++nRm;
            }
            return nRm;
          }
          releaseAccessHandles() {
            for (const ah of this.#mapSAHToName.keys())
              ah.close();
            this.#mapSAHToName.clear();
            this.#mapFilenameToSAH.clear();
            this.#availableSAH.clear();
          }
          async acquireAccessHandles(clearFiles) {
            const files = [];
            for await (const [name, h7] of this.#dhOpaque) {
              if ("file" === h7.kind) {
                files.push([name, h7]);
              }
            }
            return Promise.all(
              files.map(async ([name, h7]) => {
                try {
                  const ah = await h7.createSyncAccessHandle();
                  this.#mapSAHToName.set(ah, name);
                  if (clearFiles) {
                    ah.truncate(HEADER_OFFSET_DATA);
                    this.setAssociatedPath(ah, "", 0);
                  } else {
                    const path2 = this.getAssociatedPath(ah);
                    if (path2) {
                      this.#mapFilenameToSAH.set(path2, ah);
                    } else {
                      this.#availableSAH.add(ah);
                    }
                  }
                } catch (e6) {
                  this.storeErr(e6);
                  this.releaseAccessHandles();
                  throw e6;
                }
              })
            );
          }
          getAssociatedPath(sah) {
            sah.read(this.#apBody, { at: 0 });
            const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
            if (this.#apBody[0] && (flags & capi.SQLITE_OPEN_DELETEONCLOSE || (flags & PERSISTENT_FILE_TYPES) === 0)) {
              warn(
                `Removing file with unexpected flags ${flags.toString(16)}`,
                this.#apBody
              );
              this.setAssociatedPath(sah, "", 0);
              return "";
            }
            const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
            sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
            const compDigest = this.computeDigest(this.#apBody);
            if (fileDigest.every((v8, i4) => v8 === compDigest[i4])) {
              const pathBytes = this.#apBody.findIndex((v8) => 0 === v8);
              if (0 === pathBytes) {
                sah.truncate(HEADER_OFFSET_DATA);
              }
              return pathBytes ? textDecoder.decode(this.#apBody.subarray(0, pathBytes)) : "";
            } else {
              warn("Disassociating file with bad digest.");
              this.setAssociatedPath(sah, "", 0);
              return "";
            }
          }
          setAssociatedPath(sah, path2, flags) {
            const enc = textEncoder.encodeInto(path2, this.#apBody);
            if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {
              toss("Path too long:", path2);
            }
            this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
            this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);
            const digest = this.computeDigest(this.#apBody);
            sah.write(this.#apBody, { at: 0 });
            sah.write(digest, { at: HEADER_OFFSET_DIGEST });
            sah.flush();
            if (path2) {
              this.#mapFilenameToSAH.set(path2, sah);
              this.#availableSAH.delete(sah);
            } else {
              sah.truncate(HEADER_OFFSET_DATA);
              this.#availableSAH.add(sah);
            }
          }
          computeDigest(byteArray) {
            let h1 = 3735928559;
            let h22 = 1103547991;
            for (const v8 of byteArray) {
              h1 = 31 * h1 + v8 * 307;
              h22 = 31 * h22 + v8 * 307;
            }
            return new Uint32Array([h1 >>> 0, h22 >>> 0]);
          }
          async reset(clearFiles) {
            await this.isReady;
            let h7 = await navigator.storage.getDirectory();
            let prev, prevName;
            for (const d4 of this.vfsDir.split("/")) {
              if (d4) {
                prev = h7;
                h7 = await h7.getDirectoryHandle(d4, { create: true });
              }
            }
            this.#dhVfsRoot = h7;
            this.#dhVfsParent = prev;
            this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
              OPAQUE_DIR_NAME,
              { create: true }
            );
            this.releaseAccessHandles();
            return this.acquireAccessHandles(clearFiles);
          }
          getPath(arg) {
            if (wasm.isPtr(arg))
              arg = wasm.cstrToJs(arg);
            return (arg instanceof URL ? arg : new URL(arg, "file://localhost/")).pathname;
          }
          deletePath(path2) {
            const sah = this.#mapFilenameToSAH.get(path2);
            if (sah) {
              this.#mapFilenameToSAH.delete(path2);
              this.setAssociatedPath(sah, "", 0);
            }
            return !!sah;
          }
          storeErr(e6, code) {
            if (e6) {
              e6.sqlite3Rc = code || capi.SQLITE_IOERR;
              this.error(e6);
            }
            this.$error = e6;
            return code;
          }
          popErr() {
            const rc = this.$error;
            this.$error = void 0;
            return rc;
          }
          nextAvailableSAH() {
            const [rc] = this.#availableSAH.keys();
            return rc;
          }
          getOFileForS3File(pFile) {
            return this.#mapS3FileToOFile_.get(pFile);
          }
          mapS3FileToOFile(pFile, file) {
            if (file) {
              this.#mapS3FileToOFile_.set(pFile, file);
              setPoolForPFile(pFile, this);
            } else {
              this.#mapS3FileToOFile_.delete(pFile);
              setPoolForPFile(pFile, false);
            }
          }
          hasFilename(name) {
            return this.#mapFilenameToSAH.has(name);
          }
          getSAHForPath(path2) {
            return this.#mapFilenameToSAH.get(path2);
          }
          async removeVfs() {
            if (!this.#cVfs.pointer || !this.#dhOpaque)
              return false;
            capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
            this.#cVfs.dispose();
            try {
              this.releaseAccessHandles();
              await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {
                recursive: true
              });
              this.#dhOpaque = void 0;
              await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {
                recursive: true
              });
              this.#dhVfsRoot = this.#dhVfsParent = void 0;
            } catch (e6) {
              sqlite3.config.error(this.vfsName, "removeVfs() failed:", e6);
            }
            return true;
          }
          exportFile(name) {
            const sah = this.#mapFilenameToSAH.get(name) || toss("File not found:", name);
            const n6 = sah.getSize() - HEADER_OFFSET_DATA;
            const b5 = new Uint8Array(n6 > 0 ? n6 : 0);
            if (n6 > 0) {
              const nRead = sah.read(b5, { at: HEADER_OFFSET_DATA });
              if (nRead != n6) {
                toss(
                  "Expected to read " + n6 + " bytes but read " + nRead + "."
                );
              }
            }
            return b5;
          }
          async importDbChunked(name, callback) {
            const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
            sah.truncate(0);
            let nWrote = 0, chunk, checkedHeader = false, err2 = false;
            try {
              while (void 0 !== (chunk = await callback())) {
                if (chunk instanceof ArrayBuffer)
                  chunk = new Uint8Array(chunk);
                if (0 === nWrote && chunk.byteLength >= 15) {
                  util.affirmDbHeader(chunk);
                  checkedHeader = true;
                }
                sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });
                nWrote += chunk.byteLength;
              }
              if (nWrote < 512 || 0 !== nWrote % 512) {
                toss(
                  "Input size",
                  nWrote,
                  "is not correct for an SQLite database."
                );
              }
              if (!checkedHeader) {
                const header = new Uint8Array(20);
                sah.read(header, { at: 0 });
                util.affirmDbHeader(header);
              }
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18
              });
            } catch (e6) {
              this.setAssociatedPath(sah, "", 0);
              throw e6;
            }
            this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            return nWrote;
          }
          importDb(name, bytes) {
            if (bytes instanceof ArrayBuffer)
              bytes = new Uint8Array(bytes);
            else if (bytes instanceof Function)
              return this.importDbChunked(name, bytes);
            const sah = this.#mapFilenameToSAH.get(name) || this.nextAvailableSAH() || toss("No available handles to import to.");
            const n6 = bytes.byteLength;
            if (n6 < 512 || n6 % 512 != 0) {
              toss("Byte array size is invalid for an SQLite db.");
            }
            const header = "SQLite format 3";
            for (let i4 = 0; i4 < header.length; ++i4) {
              if (header.charCodeAt(i4) !== bytes[i4]) {
                toss("Input does not contain an SQLite database header.");
              }
            }
            const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });
            if (nWrote != n6) {
              this.setAssociatedPath(sah, "", 0);
              toss(
                "Expected to write " + n6 + " bytes but wrote " + nWrote + "."
              );
            } else {
              sah.write(new Uint8Array([1, 1]), {
                at: HEADER_OFFSET_DATA + 18
              });
              this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
            }
            return nWrote;
          }
        }
        class OpfsSAHPoolUtil {
          #p;
          constructor(sahPool) {
            this.#p = sahPool;
            this.vfsName = sahPool.vfsName;
          }
          async addCapacity(n6) {
            return this.#p.addCapacity(n6);
          }
          async reduceCapacity(n6) {
            return this.#p.reduceCapacity(n6);
          }
          getCapacity() {
            return this.#p.getCapacity(this.#p);
          }
          getFileCount() {
            return this.#p.getFileCount();
          }
          getFileNames() {
            return this.#p.getFileNames();
          }
          async reserveMinimumCapacity(min6) {
            const c5 = this.#p.getCapacity();
            return c5 < min6 ? this.#p.addCapacity(min6 - c5) : c5;
          }
          exportFile(name) {
            return this.#p.exportFile(name);
          }
          importDb(name, bytes) {
            return this.#p.importDb(name, bytes);
          }
          async wipeFiles() {
            return this.#p.reset(true);
          }
          unlink(filename) {
            return this.#p.deletePath(filename);
          }
          async removeVfs() {
            return this.#p.removeVfs();
          }
        }
        const apiVersionCheck = async () => {
          const dh = await navigator.storage.getDirectory();
          const fn2 = ".opfs-sahpool-sync-check-" + getRandomName();
          const fh = await dh.getFileHandle(fn2, { create: true });
          const ah = await fh.createSyncAccessHandle();
          const close = ah.close();
          await close;
          await dh.removeEntry(fn2);
          if (close?.then) {
            toss(
              "The local OPFS API is too old for opfs-sahpool:",
              "it has an async FileSystemSyncAccessHandle.close() method."
            );
          }
          return true;
        };
        let instanceCounter = 0;
        sqlite3.installOpfsSAHPoolVfs = async function(options = /* @__PURE__ */ Object.create(null)) {
          const vfsName = options.name || optionDefaults.name;
          if (0) {
            throw new Error("Just testing rejection.");
          }
          if (initPromises[vfsName]) {
            return initPromises[vfsName];
          }
          if (!globalThis.FileSystemHandle || !globalThis.FileSystemDirectoryHandle || !globalThis.FileSystemFileHandle || !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle || !navigator?.storage?.getDirectory) {
            return initPromises[vfsName] = Promise.reject(
              new Error("Missing required OPFS APIs.")
            );
          }
          return initPromises[vfsName] = apiVersionCheck().then(async function() {
            if (options.$testThrowInInit) {
              throw options.$testThrowInInit;
            }
            const thePool = new OpfsSAHPool(options);
            return thePool.isReady.then(async () => {
              const poolUtil = new OpfsSAHPoolUtil(thePool);
              if (sqlite3.oo1) {
                const oo1 = sqlite3.oo1;
                const theVfs = thePool.getVfs();
                const OpfsSAHPoolDb = function(...args) {
                  const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
                  opt.vfs = theVfs.$zName;
                  oo1.DB.dbCtorHelper.call(this, opt);
                };
                OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);
                poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
                oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                  theVfs.pointer,
                  function(oo1Db, sqlite32) {
                    sqlite32.capi.sqlite3_exec(
                      oo1Db,
                      [
                        "pragma journal_mode=DELETE;",
                        "pragma cache_size=-16384;"
                      ],
                      0,
                      0,
                      0
                    );
                  }
                );
              }
              thePool.log("VFS initialized.");
              return poolUtil;
            }).catch(async (e6) => {
              await thePool.removeVfs().catch(() => {
              });
              throw e6;
            });
          }).catch((err2) => {
            return initPromises[vfsName] = Promise.reject(err2);
          });
        };
      });
      "use strict";
      if ("undefined" !== typeof Module2) {
        const SABC = Object.assign(
          /* @__PURE__ */ Object.create(null),
          {
            exports: "undefined" === typeof wasmExports ? Module2["asm"] : wasmExports,
            memory: Module2.wasmMemory
          },
          globalThis.sqlite3ApiConfig || {}
        );
        globalThis.sqlite3ApiConfig = SABC;
        let sqlite3;
        try {
          sqlite3 = globalThis.sqlite3ApiBootstrap();
        } catch (e6) {
          console.error("sqlite3ApiBootstrap() error:", e6);
          throw e6;
        } finally {
          delete globalThis.sqlite3ApiBootstrap;
          delete globalThis.sqlite3ApiConfig;
        }
        Module2.sqlite3 = sqlite3;
      } else {
        console.warn(
          "This is not running in an Emscripten module context, so",
          "globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack",
          "of config info for the WASM environment.",
          "It must be called manually."
        );
      }
    });
    return sqlite3InitModule2.ready;
  };
})();
var toExportForESM = function() {
  const originalInit = sqlite3InitModule;
  if (!originalInit) {
    throw new Error(
      "Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build."
    );
  }
  const initModuleState = globalThis.sqlite3InitModuleState = Object.assign(
    /* @__PURE__ */ Object.create(null),
    {
      moduleScript: globalThis?.document?.currentScript,
      isWorker: "undefined" !== typeof WorkerGlobalScope,
      location: globalThis.location,
      urlParams: globalThis?.location?.href ? new URL(globalThis.location.href).searchParams : new URLSearchParams()
    }
  );
  initModuleState.debugModule = initModuleState.urlParams.has(
    "sqlite3.debugModule"
  ) ? (...args) => console.warn("sqlite3.debugModule:", ...args) : () => {
  };
  if (initModuleState.urlParams.has("sqlite3.dir")) {
    initModuleState.sqlite3Dir = initModuleState.urlParams.get("sqlite3.dir") + "/";
  } else if (initModuleState.moduleScript) {
    const li2 = initModuleState.moduleScript.src.split("/");
    li2.pop();
    initModuleState.sqlite3Dir = li2.join("/") + "/";
  }
  globalThis.sqlite3InitModule = function ff(...args) {
    return originalInit(...args).then((EmscriptenModule) => {
      const s3 = EmscriptenModule.sqlite3;
      s3.scriptInfo = initModuleState;
      if (ff.__isUnderTest)
        s3.__isUnderTest = true;
      const f5 = s3.asyncPostInit;
      delete s3.asyncPostInit;
      return f5();
    }).catch((e6) => {
      console.error("Exception loading sqlite3 module:", e6);
      throw e6;
    });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;
  if (globalThis.sqlite3InitModuleState.moduleScript) {
    const sim = globalThis.sqlite3InitModuleState;
    let src = sim.moduleScript.src.split("/");
    src.pop();
    sim.scriptDir = src.join("/") + "/";
  }
  initModuleState.debugModule("sqlite3InitModuleState =", initModuleState);
  if (0) {
    console.warn("Replaced sqlite3InitModule()");
    console.warn("globalThis.location.href =", globalThis.location.href);
    if ("undefined" !== typeof document) {
      console.warn(
        "document.currentScript.src =",
        document?.currentScript?.src
      );
    }
  }
  return globalThis.sqlite3InitModule;
}();
sqlite3InitModule = toExportForESM;

// ../../../node_modules/.pnpm/@eliaspourquoi+sqlite-node-wasm@3.46.0-build2/node_modules/@eliaspourquoi/sqlite-node-wasm/sqlite-wasm/jswasm/sqlite3-worker1-promiser.mjs
globalThis.sqlite3Worker1Promiser = function callee(config2 = callee.defaultConfig) {
  if (1 === arguments.length && "function" === typeof arguments[0]) {
    const f5 = config2;
    config2 = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig);
    config2.onready = f5;
  } else {
    config2 = Object.assign(/* @__PURE__ */ Object.create(null), callee.defaultConfig, config2);
  }
  const handlerMap = /* @__PURE__ */ Object.create(null);
  const noop = function() {
  };
  const err = config2.onerror || noop;
  const debug = config2.debug || noop;
  const idTypeMap = config2.generateMessageId ? void 0 : /* @__PURE__ */ Object.create(null);
  const genMsgId = config2.generateMessageId || function(msg) {
    return msg.type + "#" + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1);
  };
  const toss = (...args) => {
    throw new Error(args.join(" "));
  };
  if (!config2.worker)
    config2.worker = callee.defaultConfig.worker;
  if ("function" === typeof config2.worker)
    config2.worker = config2.worker();
  let dbId;
  let promiserFunc;
  config2.worker.onmessage = function(ev) {
    ev = ev.data;
    debug("worker1.onmessage", ev);
    let msgHandler = handlerMap[ev.messageId];
    if (!msgHandler) {
      if (ev && "sqlite3-api" === ev.type && "worker1-ready" === ev.result) {
        if (config2.onready)
          config2.onready(promiserFunc);
        return;
      }
      msgHandler = handlerMap[ev.type];
      if (msgHandler && msgHandler.onrow) {
        msgHandler.onrow(ev);
        return;
      }
      if (config2.onunhandled)
        config2.onunhandled(arguments[0]);
      else
        err("sqlite3Worker1Promiser() unhandled worker message:", ev);
      return;
    }
    delete handlerMap[ev.messageId];
    switch (ev.type) {
      case "error":
        msgHandler.reject(ev);
        return;
      case "open":
        if (!dbId)
          dbId = ev.dbId;
        break;
      case "close":
        if (ev.dbId === dbId)
          dbId = void 0;
        break;
      default:
        break;
    }
    try {
      msgHandler.resolve(ev);
    } catch (e6) {
      msgHandler.reject(e6);
    }
  };
  return promiserFunc = function() {
    let msg;
    if (1 === arguments.length) {
      msg = arguments[0];
    } else if (2 === arguments.length) {
      msg = /* @__PURE__ */ Object.create(null);
      msg.type = arguments[0];
      msg.args = arguments[1];
      msg.dbId = msg.args.dbId;
    } else {
      toss("Invalid arguments for sqlite3Worker1Promiser()-created factory.");
    }
    if (!msg.dbId && msg.type !== "open")
      msg.dbId = dbId;
    msg.messageId = genMsgId(msg);
    msg.departureTime = performance.now();
    const proxy = /* @__PURE__ */ Object.create(null);
    proxy.message = msg;
    let rowCallbackId;
    if ("exec" === msg.type && msg.args) {
      if ("function" === typeof msg.args.callback) {
        rowCallbackId = msg.messageId + ":row";
        proxy.onrow = msg.args.callback;
        msg.args.callback = rowCallbackId;
        handlerMap[rowCallbackId] = proxy;
      } else if ("string" === typeof msg.args.callback) {
        toss(
          "exec callback may not be a string when using the Promise interface."
        );
      }
    }
    let p5 = new Promise(function(resolve, reject) {
      proxy.resolve = resolve;
      proxy.reject = reject;
      handlerMap[msg.messageId] = proxy;
      debug(
        "Posting",
        msg.type,
        "message to Worker dbId=" + (dbId || "default") + ":",
        msg
      );
      config2.worker.postMessage(msg);
    });
    if (rowCallbackId)
      p5 = p5.finally(() => delete handlerMap[rowCallbackId]);
    return p5;
  };
};
globalThis.sqlite3Worker1Promiser.defaultConfig = {
  worker: function() {
    return new Worker(
      new URL("sqlite3-worker1-bundler-friendly.mjs", import.meta.url),
      {
        type: "module"
      }
    );
  },
  onerror: (...args) => console.error("worker1 promiser error", ...args)
};
sqlite3Worker1Promiser.v2 = function(config2) {
  let oldFunc;
  if ("function" == typeof config2) {
    oldFunc = config2;
    config2 = {};
  } else if ("function" === typeof config2?.onready) {
    oldFunc = config2.onready;
    delete config2.onready;
  }
  const promiseProxy = /* @__PURE__ */ Object.create(null);
  config2 = Object.assign(config2 || /* @__PURE__ */ Object.create(null), {
    onready: async function(func) {
      try {
        if (oldFunc)
          await oldFunc(func);
        promiseProxy.resolve(func);
      } catch (e6) {
        promiseProxy.reject(e6);
      }
    }
  });
  const p5 = new Promise(function(resolve, reject) {
    promiseProxy.resolve = resolve;
    promiseProxy.reject = reject;
  });
  try {
    this.original(config2);
  } catch (e6) {
    promiseProxy.reject(e6);
  }
  return p5;
}.bind({
  original: sqlite3Worker1Promiser
});
var sqlite3_worker1_promiser_default = sqlite3Worker1Promiser.v2;

// ../../../node_modules/.pnpm/@eliaspourquoi+sqlite-node-wasm@3.46.0-build2/node_modules/@eliaspourquoi/sqlite-node-wasm/index.mjs
var sqlite3Worker1Promiser2 = globalThis.sqlite3Worker1Promiser;

// ../../../lix/packages/sqlite-wasm-kysely/dist/util/sqliteWasmBinary.js
function base64ToArrayBuffer(base64) {
  var binaryString = atob(base64);
  var bytes = new Uint8Array(binaryString.length);
  for (var i4 = 0; i4 < binaryString.length; i4++) {
    bytes[i4] = binaryString.charCodeAt(i4);
  }
  return bytes.buffer;
}
var sqliteWasmBase64 = "AGFzbQEAAAAB4AVeYAJ/fwF/YAF/AX9gA39/fwF/YAF/AGADf39/AGAEf39/fwF/YAJ/fwBgBX9/f39/AX9gBH9/f38AYAZ/f39/f38Bf2AEf39/fgF/YAJ/fgF/YAAAYAV/f39/fwBgAXwBfGAAAX9gAX8BfmAHf39/f39/fwF/YAZ/f39/f38AYAJ/fgBgA39/fgF/YAR/fn9/AX9gAX4Bf2ADf35/AX9gCX9/f39/f39/fwF/YAJ/fwF+YAN/f34AYAR/fn9/AGADf35+AX9gCH9/f39/f39/AX9gAnx8AXxgAX8BfGAFf39/f34AYAJ/fABgB39/f39/f38AYAl/f39/f39/f38AYAF8AX5gBH9/f34AYAABfGABfgF+YAV/f35/fwF/YAR/f35/AGACf38BfGAKf39/f39/f39/fwF/YAh/f39/f39/fwBgA39/fwF+YAN/fn8BfmAFf35+fn4AYAZ/f39+f38Bf2AHf39/f39+fgBgC39/f39/f39/f39/AX9gAXwBf2AAAX5gBn9/f39/fgF/YAV/fn9/fwF/YAt/f39/f39/f39/fwBgAn9+AX5gBH9/fn8Bf2ADf3x/AX9gA3x8fwF8YAF8AGACfH8BfGAGf3x/f39/AX9gAn5/AX9gBH9+fn8AYAR+fn5+AX9gA398fABgBn9/f35+fwF/YAV/f35/fwBgA39/fAF/YAJ8fgF/YAd/f39/fn9/AX9gCH9/f39/fn9/AGADf39+AX5gAn58AX9gB39/f35/f38Bf2ANf39/f39/f39/f39/fwBgCH9+fn9/f39/AX9gCH9/fn5+f39/AX9gBX9+fn5/AX9gCX9+f35+fn5/fwF/YAd/f39/fn9/AX5gBX9/f35+AGADf35+AGAGfn9/f39/AX5gB39+f39/f38Bf2AEf39+fgBgAnx/AX9gAn98AXxgA3x+fgF8YAR/f39+AX5gA35/fwF/YAJ+fgF+YAJ+fgF8AqIHIwNlbnYTX19zeXNjYWxsX2ZhY2Nlc3NhdAAFFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfY2xvc2UAAQNlbnYJX3R6c2V0X2pzAAQDZW52DV9sb2NhbHRpbWVfanMABgNlbnYTZW1zY3JpcHRlbl9kYXRlX25vdwAmA2VudiBfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYwAPA2VudhJlbXNjcmlwdGVuX2dldF9ub3cAJgNlbnYQX19zeXNjYWxsX2ZjaG1vZAAAA2Vudg9fX3N5c2NhbGxfY2htb2QAAANlbnYSX19zeXNjYWxsX2ZjaG93bjMyAAIDZW52EV9fc3lzY2FsbF9mY250bDY0AAIDZW52EF9fc3lzY2FsbF9vcGVuYXQABQNlbnYPX19zeXNjYWxsX2lvY3RsAAIWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF93cml0ZQAFFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfcmVhZAAFA2VudhFfX3N5c2NhbGxfZnN0YXQ2NAAAA2VudhBfX3N5c2NhbGxfc3RhdDY0AAADZW52FF9fc3lzY2FsbF9uZXdmc3RhdGF0AAUDZW52EV9fc3lzY2FsbF9sc3RhdDY0AAAWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9zeW5jAAEDZW52FV9fc3lzY2FsbF9mdHJ1bmNhdGU2NAALA2VudhBfX3N5c2NhbGxfZ2V0Y3dkAAAWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MRFlbnZpcm9uX3NpemVzX2dldAAAFndhc2lfc25hcHNob3RfcHJldmlldzELZW52aXJvbl9nZXQAABZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsAFQNlbnYRX19zeXNjYWxsX21rZGlyYXQAAgNlbnYKX211bm1hcF9qcwAJA2VudghfbW1hcF9qcwARA2VudhRfX3N5c2NhbGxfcmVhZGxpbmthdAAFA2Vudg9fX3N5c2NhbGxfcm1kaXIAAQNlbnYSX19zeXNjYWxsX3VubGlua2F0AAIDZW52E19fc3lzY2FsbF91dGltZW5zYXQABRZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxDWZkX2Zkc3RhdF9nZXQAAANlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAABA2VudgZtZW1vcnkCAYACgIACA5EWjxYMBQECBQcBAAYGAwEDARAGBgYGBgYGBgQBDwwGDAEDDwABAwEnJxYWAAsLBAQQCx8BBAsABgYEQgEEEAsGAQMUAQEBAQAABQUEBgAAAgcAAAUAAgEFAgMEAgUFBgIAAgACAAAFAAAHARkBBwADAQURAQEAAwkEABMoAgEGAAEAAAMBAwYAAAABAQMBA0MIFgYBAgMNBgYBAwACBQUBAgMAAQIAAAACAQADAwMBAQEAAwEFAwMQFwAAAAIAAwMDAAICBQEBAQQCBQYDAQYDAwYDBgYDAQABAwMBAQIAAQAAAR8fARAQAQAAAQEBAQEBAwgEDQMDASkhIQMEAAAGExMDAwgIAwYIRAMDBgAGCwYGAQQGAQEBAAIDAQABAgAEAAAAAAgLAQEAACoAAgcwAEUCFAAHBwICAQAAAgIBAQEAAgEBAAACAAUCAwMLBwEIAQEBAgEGBUYFA0cFAAIBCQIGFwECAAEHBAcFCQEGCAYBBQUHBRBIBQUBCwIGAAUBAgEBDAcRBgkFBwcAAAAGAQIBAQMFBAECAAACAgIHBwECDwAAAQ8PDwABAAIFEBMQARABAAEABgMBAggAAB0yMhgrAgcEAgACBQICAgIABQIABwcrAQEBAQIABQcJBwcJCQAGAwUHCQUCARgAAQABBQAAAwMCAQAEADMQFgMBAAACSQAAAAEBAQUBAQICAgUrCQAbAQECAgABCwYCMQMGBAIJAAAIGBAABAgIAgICAAABEAIQAhEFAgUBBQADABcHAgcCAgICAAEFBwQFGB0JAwICBAQEBwkYCQECAgICEwQBAgUHBggRAgcCAgMJCQAPDwMBDw8CAw8AAAEABwUHAgAEDwIFBwIAAgsAAQEBNDQnBhADAQAABhQLAAEAAwMKChULCwAAAAABAAIEAQEDAQcAAzYFBQMAFRcCAA8BAAAAAQAAAAAABwIFBQACAAAAAQoCCgQLCwAAEAAAAAIBAQoFCgsAAAIBCgoLAAAAAAIBFRcDAwYDAAMGAwUFAQYGAQEDAQcDAQMCAQEDAAcAAgYEBgUNAgoNEwIDBAEBAQMKCgsAAAQCCgMDAAAHAwIABgIDAAACAQMDAgACAwYAAAIoBwAXAAADAAABBAAEAAAEAAQABxIBAAMABgACAQEDAQECBQcDCQEDAQMFBgENCAMEBgMGBgMBAwYIAAYDAwAGBgMGAwMGAgIAFAAABAEDBgICAAEQARkFAAABBgUACwMBAQQAAQETAwgECAoBBgAFAgIEBgUDAQIAFgEFAQAABQECABAAAAILFUoHBgEDAEsAAQQBAwUABRYLKQUAAgIFBQEBAQQAKAECCAIAAQkAAAQBBAACAQUDAwUABgIABgYEBgMGBgYGAQUAAgEHBwACBAUABREACQkJAgAlEwQACQEKAAICAQQUAggBAAMGAAcFBQAEAgYCAAIABwcJAAEAAQMHAQECAAYGBgAFAAILAQACBBENAgQABwQiAw0DAhEHBAIAAgMGAgACDQQEBAECAA0ACAEGAgUAAQQEIgYGBQUCBwICAAIFAAAABgABBgQAAAAABAYIDQQDCAQHBTcCAAIGBBgEBgIBAAYFCAIEBAgFAgYJEgUIBAQRAhIEBAUDAgABBgIGDQIIBg0GCA0EAAQIAwUCAgMHCAMCBgQBBAIGAAMBBgEDBQQBEgYABgIEAAYAAAAFAhIGAAYAAgQILAQABAYAAQcFBB0GAAQGAw0FEgMEBgYABgEGAAgGCAgGCAAEAAgFAAABAQMCAgUdBggABgUEAQQAAgcFAggABgAdBgY3AwQGAgASABEABCNMEhIjEgEFBQACBAQIAAAEAgYABgYGDQYGEwAAAwEIAwEGDQgdBggEBwEIBgQGAAQGAgAEAQgCCAIGAw0IAAQAAgUEIgIBCAgBAAkjAQQNAAAACQAEBQEABQAAAAACBgcABAYGBAQGAAIAAAAGAwEAAwgIAAANAAYABwAIAgYNEAUEBQ0AAgACAAAABgAAEQUAAAEAAAAGBAQFAAIABAIGBgAwAAkBGRwLHAYGAwMQAwgSCyklCAkIBiAHBAQIBAIGBAkiBA0AAAAGBggCAAAEDREBGQAGFAIEABIDBhkZGQUBBAYAGQUCAQIAAAZNAAUEAgUbBgAAAAAAAAAEDQQHBAcHBQUDAAUSAAAjLAEAAAYFAAANBAAEDRIGBAQDBAQGBAQEBAsEBAMGAwQEBAQEBAQEBAQEBAQEBA0EBAQEBAQEBAQEBAQEBBMhEwMEAwMEAwQEAwMEBA4EDgQEBA4OBAQEBwAAAgEICAYHDQMGBAAABAQEAAYEAwQDBAMEAwQEAwQEAwQEAwMEBAMDBAMEBQMEBAMEAwQDBAEEBAQEAQAhAgADAAQCBQYGAwQGAwYEBAAEAQUAAwQEBAEDAggEBggEBAQFBAAEBAQEBAMGAwQEAwYDAgAADQkIAgYAAAEDAQEGAAIIBgkCAgEIAAYDBAYDAQMAAQEBAwEDAgMDBgMBAgECBAYIBgYDAwEBBQQDAwEHBQcDBAQBBAQEAQEBAQEBAAAFABYEAgUBBQEJAAEBCQMEAAEAAQMDBxgCAQAAAAECAAMYBQAFAgARTgAVBQUAAgMACAIBAAAUAAULCBYLBiIGAgEFAQkCAQUBCQUBAQEBAQEIAQECCREJAAEBCAABAwc4AAAAFgcLBAMNEgUEAQEEAAECAAAFAAABBQIKBwQNAAEGAgABAQEBAQMHAAAAAAEHAQUBCAADAwMAAgcHAhEIIAkCAAYaBgcHBE8LAgcICAUFFQUAFFAcAwgJUQQCAQUJCRoEBQICAgQGAgQCBAQCAAMHAgIAAgUBAgUEAQIGCQABAAEDBwEBAgAJEQkAAQMBBQABAQMHCQA4AQICBQEFAQM5HAECAggaAAILAAUABQMEFwEABRQJFwEDAQMAAwgGBQABBQUIAhQBAQEBAwcEAAEIAAAAAQcDAAIFAQcIBwEDAwMDAQEDAwEBBQMCGwMCCwMLEAsAAAMDAwMDAwMEAAIHBAIFBgMIAwEGCQoKCgoKCwEGLQAGAAAaGiUDBAYGBgYCCAMBUgQaAQABEAQGAQsCAAU2FAgBAgMDAAkjAAYEBhIGBggIGxsEBgQCDQICBgYGBgYGAAQIBAYIBCAaBgYGAQAEAAIGBAgIUwQEBAUEBgYGAwgIAAgIAQEAAgcBAAABBxAFAhcJBQIABwUIBQQHBwkLAwoGAQkDAlRVAgUHCw0BCRgFCAEJDQ0CAAUCAwkAAAEFBAMJBQMJCQkBAAAAAAAAAgkJCQABAQABAwcBAQEAAQIACAUtBhACBCUaBlYJEQkAAQMBAwABAwcVOjkVAQABAwECAAAFAAsFBQEBAQAAAQcBAgAGOgsABAUCAioEAgASKgIIAhUcHAAJAAEAAQcBAQIABQEJAAEAAQMHAQIDAwMBAgAJAAEAAQMHAQEDAQIBAAAJAAEAAQMHAQECAAkAAQABAwcBAQIAAgEBAgICAAgJBwkCAAICAAICAg4OAh4PAA4ODg4ODg4kHiQOAQEeB1c7Dh4ODAAQAABYDh8fDjNZJjwOJA4AAgEDAwECAQ4eJAEuAgIBAAAAAQUABQELAQIFAAwBDw8PDw8BAQMDPAEODi4AAgAAAAkMNQAFAA8MAQIGDRIGLAYBBAEBCAICAgE9Dg4FDgAAAAAAAQ8MAAAAAQECAgAAAVotATsODg4BBQIAAQA9BxEEAQhbPz8NAj4GJAUCAQECAAIBAwAAAAAGDwEvQEFBIVwTEw8PQC8vXQ8DAQQFAXAAuwUGCAF/AUHQqCgLB8Aw9gERX193YXNtX2NhbGxfY3RvcnMAIhBzcWxpdGUzX3N0YXR1czY0ACMOc3FsaXRlM19zdGF0dXMAJhFzcWxpdGUzX2RiX3N0YXR1cwAnDXNxbGl0ZTNfbXNpemUAMBBzcWxpdGUzX3Zmc19maW5kADoSc3FsaXRlM19pbml0aWFsaXplADsOc3FsaXRlM19tYWxsb2MAPwxzcWxpdGUzX2ZyZWUAQBRzcWxpdGUzX3Zmc19yZWdpc3RlcgBCFnNxbGl0ZTNfdmZzX3VucmVnaXN0ZXIARRBzcWxpdGUzX21hbGxvYzY0AEkPc3FsaXRlM19yZWFsbG9jAEoRc3FsaXRlM19yZWFsbG9jNjQATBJzcWxpdGUzX3ZhbHVlX3RleHQAXxJzcWxpdGUzX3JhbmRvbW5lc3MAaw9zcWxpdGUzX3N0cmljbXAAbBBzcWxpdGUzX3N0cm5pY21wAG4Vc3FsaXRlM191cmlfcGFyYW1ldGVyAHMQX19lcnJub19sb2NhdGlvbgDsFBNzcWxpdGUzX3VyaV9ib29sZWFuAHcRc3FsaXRlM19zZXJpYWxpemUAhQESc3FsaXRlM19wcmVwYXJlX3YyAIgBDHNxbGl0ZTNfc3RlcACJARRzcWxpdGUzX2NvbHVtbl9pbnQ2NACKAQ1zcWxpdGUzX3Jlc2V0AIsBDHNxbGl0ZTNfZXhlYwCMARJzcWxpdGUzX2NvbHVtbl9pbnQAjQEQc3FsaXRlM19maW5hbGl6ZQCPARRzcWxpdGUzX2ZpbGVfY29udHJvbACQARNzcWxpdGUzX2NvbHVtbl9uYW1lAKYBE3NxbGl0ZTNfY29sdW1uX3RleHQApwETc3FsaXRlM19jb2x1bW5fdHlwZQCoAQ5zcWxpdGUzX2Vycm1zZwCqARNzcWxpdGUzX2Rlc2VyaWFsaXplAK4BFnNxbGl0ZTNfY2xlYXJfYmluZGluZ3MA9wESc3FsaXRlM192YWx1ZV9ibG9iAPoBE3NxbGl0ZTNfdmFsdWVfYnl0ZXMA/gEUc3FsaXRlM192YWx1ZV9kb3VibGUAggIRc3FsaXRlM192YWx1ZV9pbnQAhAITc3FsaXRlM192YWx1ZV9pbnQ2NACGAhVzcWxpdGUzX3ZhbHVlX3N1YnR5cGUAhwIVc3FsaXRlM192YWx1ZV9wb2ludGVyAIgCEnNxbGl0ZTNfdmFsdWVfdHlwZQCKAhZzcWxpdGUzX3ZhbHVlX25vY2hhbmdlAIsCFnNxbGl0ZTNfdmFsdWVfZnJvbWJpbmQAjAIRc3FsaXRlM192YWx1ZV9kdXAAjQISc3FsaXRlM192YWx1ZV9mcmVlAJACE3NxbGl0ZTNfcmVzdWx0X2Jsb2IAkQIbc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnAJQCGnNxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtAJUCFXNxbGl0ZTNfcmVzdWx0X2RvdWJsZQCYAhRzcWxpdGUzX3Jlc3VsdF9lcnJvcgCbAhJzcWxpdGUzX3Jlc3VsdF9pbnQAngIUc3FsaXRlM19yZXN1bHRfaW50NjQAoAITc3FsaXRlM19yZXN1bHRfbnVsbAChAhZzcWxpdGUzX3Jlc3VsdF9wb2ludGVyAKMCFnNxbGl0ZTNfcmVzdWx0X3N1YnR5cGUApgITc3FsaXRlM19yZXN1bHRfdGV4dACnAhdzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYgCtAhlzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0AK4CGXNxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUAsAIRc3FsaXRlM191c2VyX2RhdGEAtAIZc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZQC1AhVzcWxpdGUzX3Z0YWJfbm9jaGFuZ2UAtgIVc3FsaXRlM192dGFiX2luX2ZpcnN0ALcCFHNxbGl0ZTNfdnRhYl9pbl9uZXh0AMACGXNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQAwQITc3FsaXRlM19nZXRfYXV4ZGF0YQDDAhNzcWxpdGUzX3NldF9hdXhkYXRhAMQCFHNxbGl0ZTNfY29sdW1uX2NvdW50AMYCEnNxbGl0ZTNfZGF0YV9jb3VudADHAhNzcWxpdGUzX2NvbHVtbl9ibG9iAMgCFHNxbGl0ZTNfY29sdW1uX2J5dGVzAMkCFXNxbGl0ZTNfY29sdW1uX2RvdWJsZQDKAhRzcWxpdGUzX2NvbHVtbl92YWx1ZQDLAhFzcWxpdGUzX2JpbmRfYmxvYgDNAhNzcWxpdGUzX2JpbmRfZG91YmxlANACEHNxbGl0ZTNfYmluZF9pbnQA0QISc3FsaXRlM19iaW5kX2ludDY0ANICEXNxbGl0ZTNfYmluZF9udWxsANMCFHNxbGl0ZTNfYmluZF9wb2ludGVyANQCEXNxbGl0ZTNfYmluZF90ZXh0ANUCHHNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQA2AIcc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleADaAhFzcWxpdGUzX2RiX2hhbmRsZQDdAhVzcWxpdGUzX3N0bXRfcmVhZG9ubHkA3gIWc3FsaXRlM19zdG10X2lzZXhwbGFpbgDfAhNzcWxpdGUzX3N0bXRfc3RhdHVzAOECC3NxbGl0ZTNfc3FsAOICFHNxbGl0ZTNfZXhwYW5kZWRfc3FsAOMCFXNxbGl0ZTNfcHJldXBkYXRlX29sZADmAhdzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudADwAhdzcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aADxAhtzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUA8gIVc3FsaXRlM19wcmV1cGRhdGVfbmV3APMCGnNxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlAPQCFnNxbGl0ZTNfc2V0X2F1dGhvcml6ZXIAmwMPc3FsaXRlM19zdHJnbG9iAJ0DD3NxbGl0ZTNfc3RybGlrZQCgAxZzcWxpdGUzX2F1dG9fZXh0ZW5zaW9uAKEDHXNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uAKIDHHNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24AowMSc3FsaXRlM19wcmVwYXJlX3YzAKcDFXNxbGl0ZTNfY3JlYXRlX21vZHVsZQCoAxhzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIAqgMUc3FsaXRlM19kcm9wX21vZHVsZXMAqwMUc3FsaXRlM19kZWNsYXJlX3Z0YWIArAMYc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ALYDFnNxbGl0ZTNfdnRhYl9jb2xsYXRpb24AuAMPc3FsaXRlM192dGFiX2luALsDFnNxbGl0ZTNfdnRhYl9yaHNfdmFsdWUAvAMVc3FsaXRlM192dGFiX2Rpc3RpbmN0AL8DFHNxbGl0ZTNfa2V5d29yZF9uYW1lAMADFXNxbGl0ZTNfa2V5d29yZF9jb3VudADBAxVzcWxpdGUzX2tleXdvcmRfY2hlY2sAwgMQc3FsaXRlM19jb21wbGV0ZQDEAxJzcWxpdGUzX2xpYnZlcnNpb24AxQMZc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlcgDGAxBzcWxpdGUzX3NodXRkb3duAMcDGXNxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQAzQMdc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQAzgMRc3FsaXRlM19jaGFuZ2VzNjQAzwMPc3FsaXRlM19jaGFuZ2VzANADF3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ANEDFXNxbGl0ZTNfdG90YWxfY2hhbmdlcwDSAxFzcWxpdGUzX3R4bl9zdGF0ZQDTAxBzcWxpdGUzX2Nsb3NlX3YyANgDFHNxbGl0ZTNfYnVzeV9oYW5kbGVyANkDGHNxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlcgDaAxRzcWxpdGUzX2J1c3lfdGltZW91dADbAxdzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbgDdAxpzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MgDgAx5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24A4QMZc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbgDiAxBzcWxpdGUzX3RyYWNlX3YyAOgDE3NxbGl0ZTNfY29tbWl0X2hvb2sA6QMTc3FsaXRlM191cGRhdGVfaG9vawDqAxVzcWxpdGUzX3JvbGxiYWNrX2hvb2sA6wMWc3FsaXRlM19wcmV1cGRhdGVfaG9vawDsAxRzcWxpdGUzX2Vycm9yX29mZnNldAD0Aw9zcWxpdGUzX2VycmNvZGUA9QMYc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlAPYDDnNxbGl0ZTNfZXJyc3RyAPcDDXNxbGl0ZTNfbGltaXQA+AMMc3FsaXRlM19vcGVuAPkDD3NxbGl0ZTNfb3Blbl92MgCEBBhzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24AhQQbc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyAIYEGHNxbGl0ZTNfY29sbGF0aW9uX25lZWRlZACIBBZzcWxpdGUzX2dldF9hdXRvY29tbWl0AIkEHXNxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhAIoEHXNxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzAJAED3NxbGl0ZTNfdXJpX2tleQCeBBFzcWxpdGUzX3VyaV9pbnQ2NAChBA9zcWxpdGUzX2RiX25hbWUAowQTc3FsaXRlM19kYl9maWxlbmFtZQCkBBpzcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZACmBBlzcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0AKcEE3NxbGl0ZTNzZXNzaW9uX2RpZmYAqAQVc3FsaXRlM3Nlc3Npb25fYXR0YWNoALcEFXNxbGl0ZTNzZXNzaW9uX2NyZWF0ZQC7BBVzcWxpdGUzc2Vzc2lvbl9kZWxldGUAvQQbc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyAL8EGHNxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldADABB1zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybQDLBBxzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtAMwEF3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0AM0EFXNxbGl0ZTNzZXNzaW9uX2VuYWJsZQDOBBdzcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdADPBBZzcWxpdGUzc2Vzc2lvbl9pc2VtcHR5ANAEGnNxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkANEEHHNxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcA0gQdc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUA0wQWc3FsaXRlM2NoYW5nZXNldF9zdGFydADUBBlzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyANYEG3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybQDXBB5zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0A2AQVc3FsaXRlM2NoYW5nZXNldF9uZXh0ANkEE3NxbGl0ZTNjaGFuZ2VzZXRfb3AA4QQTc3FsaXRlM2NoYW5nZXNldF9wawDiBBRzcWxpdGUzY2hhbmdlc2V0X29sZADjBBRzcWxpdGUzY2hhbmdlc2V0X25ldwDkBBlzcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0AOUEHXNxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzAOYEGXNxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUA5wQXc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQA6AQcc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybQDrBBlzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyAOwEFnNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkA9gQec3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtAPcEG3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybQD4BBZzcWxpdGUzY2hhbmdlZ3JvdXBfbmV3APkEFnNxbGl0ZTNjaGFuZ2Vncm91cF9hZGQA+gQZc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dACHBRtzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0AiQUec3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtAIoFGXNxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUAiwUXc3FsaXRlM2NoYW5nZXNldF9jb25jYXQAjAUcc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybQCNBRVzcWxpdGUzc2Vzc2lvbl9jb25maWcAjgUQc3FsaXRlM19zb3VyY2VpZACPBRhzcWxpdGUzX193YXNtX3BzdGFja19wdHIAkAUcc3FsaXRlM19fd2FzbV9wc3RhY2tfcmVzdG9yZQCRBRpzcWxpdGUzX193YXNtX3BzdGFja19hbGxvYwCSBR5zcWxpdGUzX193YXNtX3BzdGFja19yZW1haW5pbmcAkwUac3FsaXRlM19fd2FzbV9wc3RhY2tfcXVvdGEAlAUWc3FsaXRlM19fd2FzbV9kYl9lcnJvcgCVBRlzcWxpdGUzX193YXNtX3Rlc3Rfc3RydWN0AJYFF3NxbGl0ZTNfX3dhc21fZW51bV9qc29uAJcFGHNxbGl0ZTNfX3dhc21fdmZzX3VubGluawCYBRRzcWxpdGUzX193YXNtX2RiX3ZmcwCZBRZzcWxpdGUzX193YXNtX2RiX3Jlc2V0AJoFH3NxbGl0ZTNfX3dhc21fZGJfZXhwb3J0X2NodW5rZWQAmwUac3FsaXRlM19fd2FzbV9kYl9zZXJpYWxpemUAnAUdc3FsaXRlM19fd2FzbV92ZnNfY3JlYXRlX2ZpbGUAnQUfc3FsaXRlM19fd2FzbV9wb3NpeF9jcmVhdGVfZmlsZQCfBSJzcWxpdGUzX193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrAKAFG3NxbGl0ZTNfX3dhc21fa3Z2ZnNfbWV0aG9kcwCiBRlzcWxpdGUzX193YXNtX3Z0YWJfY29uZmlnAKMFGnNxbGl0ZTNfX3dhc21fZGJfY29uZmlnX2lwAKQFG3NxbGl0ZTNfX3dhc21fZGJfY29uZmlnX3BpaQClBRlzcWxpdGUzX193YXNtX2RiX2NvbmZpZ19zAKYFFnNxbGl0ZTNfX3dhc21fY29uZmlnX2kApwUXc3FsaXRlM19fd2FzbV9jb25maWdfaWkAqAUWc3FsaXRlM19fd2FzbV9jb25maWdfagCpBRhzcWxpdGUzX193YXNtX3FmbXRfdG9rZW4AqgUZc3FsaXRlM19fd2FzbV9pbml0X3dhc21mcwCrBRlzcWxpdGUzX193YXNtX3Rlc3RfaW50cHRyAKwFGnNxbGl0ZTNfX3dhc21fdGVzdF92b2lkcHRyAK0FHHNxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9tYXgArgUcc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0X21pbgCvBR9zcWxpdGUzX193YXNtX3Rlc3RfaW50NjRfdGltZXMyALAFH3NxbGl0ZTNfX3dhc21fdGVzdF9pbnQ2NF9taW5tYXgAsQUbc3FsaXRlM19fd2FzbV90ZXN0X2ludDY0cHRyALIFIXNxbGl0ZTNfX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdwCzBRxzcWxpdGUzX193YXNtX3Rlc3Rfc3RyX2hlbGxvALQFH3NxbGl0ZTNfX3dhc21fU1FMVGVzdGVyX3N0cmdsb2IAtQUGbWFsbG9jAJcWBGZyZWUAmBYHcmVhbGxvYwCZFhlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQAbZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduAJsWCXN0YWNrU2F2ZQCuFgxzdGFja1Jlc3RvcmUArxYKc3RhY2tBbGxvYwCwFgnzCgEAQQELugVAtAG5AsAH0AebBpwGpQKqApIDlAOqCasJrAncA+QD7gP7A/0D/gPKA5oGnQbKAakEqgSrBKwEswS0BLUEtgTVFNYU1xTYFLwE5ATrBuwG7QbuBu8G8AbxBpkIlwjnB/4H/we3CLgIuQihC9oL2wvPC5gLjwroCpQKlQqWCpsKnAqdCjKmCrYKuArFCtEK0wrUCtkKhgzKC8sLhQz5C/oL+wv8C7gMuQzRC5IMtwzCCuQL5QuDDYQN+gz7DNMLlAvnC+gL6Qv3C/0Lvgy/DMUMxgzpDOgM7wyODdUN1g3hDeIN5g3RDoAPgQ+UD5UPhA+FD4YPhw+ID4kPiw+MD40PwQ/CD8oPyw/GD7kP4Q/iD+YP3BDvEOIQ5RDnEOkQ6hDsEPMQrRHgEpATxRHhEYISgxKEEoUShhKHErwSvRK+Er8S1xLjEuQS5RLHEsgSyRLKEssSzBLtEu8S8BL/EooTmxOgE6MTsxOTFJIU4wRvent8fn+AAYEBggGDAYQBugXlBeYFgQbjFOQUuwW/BcAFwgXEBcUFxgW8BckFygXNBc8F0AXUBdYF1wXYBdkF2gX6FO0UrxXjFagVqxWZFdsVlhaTFfwV2wXCFd0VlBW0FccVyBXcBdwVwBXdBd4F3wXgBeEF4wXiBeQF5wXoBekF6gXrBewF7QXuBe8F8AXxBfMF9QX3BfgF+gX7BfwF/QX+Bf8FgAaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GkAaRBpIGvgbABsEGwgbDBsQG0AjRCNII0wjUCNUI1gjXCNgI2QjaCN0I3gjfCOAI4QjjCOQI5QjmCOcIhg2IDY0Njw2QDZINkw2UDZUNlw2YDZkNmw2cDZ0Nng2fDaANoQ2iDaMNpA2lDaYNpw2oDakNqg2sDa0Nrg2vDbANsQ2yDbMNtA21DbYNtw24DbkNvQ2+Db8NwA3BDcINww3EDcUNxg3HDcgNyQ3KDcsN+xXMDYsVzQ3rFM4NnBXuFPEU9BT2FP8U3xX5FYEV4BX6FfAU8xT4FOIVzw3QDdEN0g3TDeAN4w3kDeUN6A3pDeoN6w3sDe0N7g3vDfAN8Q3yDfMN9A31DfYN9w34DfkN+g37DfwN/Q3+Df8NgA6DDoQOhg6IDooOjA6NDo4Ojw6XDp0Oog6kDqkOsA6zDrUOtw65DroOuw68Dr0Ovg7ADsEOwg7DDsUO5A7lDuYO5w7oDukO6g7rDuwO7Q7wDvIO8w72DvgO+Q7vDvsO/g6DD4oPjg+PD5APkQ+SD5MP6w/tD+4P7w/wD/IP8w/1D4QQhxCIEIoQixCaEJwQnRCeEKAQoRCiEKMQpBClEKYQmg+cD50Png+fD6MPpg+nD6gPqQ+sD68Psw+0D7UP1g/XD9gP2Q/aD9sP3A/dD94P3w/ZEOEQ4xDkEPUQ9hD3EPgQ+RD7EPwQ/RD+EP8QgBGCEYMRhBGGEYgRihGMEZYRmhGbEaQRpRG/EcARwRHCEcQRxhHJEcoRyxHMEc0R8RLyEvMS9BL1EvYS9xL4EvoS+xL8Ev0SgBOBE4ITgxOFE4YThxOIE4kTmROhE6ITpROnE6gTrBOuE68TsBOxE7IT4hG0E70TvxPAE8ETwhPDE8QTxhPIE8sTzBPNE9kT2xPcE90T3xPhE+IT5BPrE+0T7hPwE/ET9hP3E/gT+RP6E/sT/BOVFJYUlxSYFJkUmhSbFJwUnRSeFJ8UoBShFKIUoxSkFKUUpxSoFK0UrhSvFLAUsRSyFLMUtBS2FLcUuhS7FL0UvhS/FMAUwRTCFMMUxRTGFMcUyBTJFMoUyxTMFM0UzhTQFNEU0hTTFNQUnxWgFaEVohXaFY0WjhaRFgqFpjKPFggAELAVEOoVC10CAX8BfyAAQQpPBEBBmbsBECQPCyABQQAgAhtFBEBBnLsBECQPCyABIABBAnRBkN4GaiIAKAIAIgStNwMAIAIgACIFQShqIgA1AgA3AwAgAwRAIAUgBDYCKAtBAAsPAEEVIABBpJgBECUaQRULPAEBfyMAQRBrIgMkACADIAE2AgQgAyACNgIAIANBACIBQeKpAWo2AgggAEGRxAEgAxBqIANBEGokACAAC2UBAX8jAEEQayIEJAAgBEIANwMIIARCADcDAAJAIAFBACACG0UEQEGtuwEQJCEDDAELIAAgBEEIaiAEIAMQIyIDDQAgASAEKQMIPgIAIAIgBCkDAD4CAEEAIQMLIARBEGokACADC5IJCQF/AX8BfwF/AX4BfwF/AX4BfyMAQRBrIgYkAAJAIANFIAJFckEBIAAQKCIFGwRAQd67ARAkIQUMAQtBASEFAkACQAJAAkACQAJAAkACQCABDg0AAgMEAQEBBgYGBwIFCAsgAiAAIAMQKTYCAEEAIQUgBEUNByAAKALQAiIHBEAgByEBA0AgASIEKAIAIgENAAsgBCAAQcwCaiIBKAIANgIAIABBADYC0AIgACAHNgLMAgsgACgC2AIiBEUNByAEIQUDQCAFIgEoAgAiBQ0ACyABIABB1AJqIgcoAgA2AgBBACEFIABBADYC2AIgACAENgLUAgwHC0EAIQUgAkEANgIAIAMgAUECdCAAaiILQbACaiIAKAIANgIAIARFDQYgC0EANgKwAgwGC0EAIQRBACEFA0AgBSAAKAIUTkUEQCAAKAIQIAVBBHRqKAIEIgEEQCABKAIEKAIAIgEzAZQBIQkgASkDqAEhDCABKALkASgCNEHQ7AUiBygCfBEBACAJIAx8p0HEAGpsIARqIAFB/OwFKAIAEQEAaiABKAKoAWohBAsgBUEBaiEFDAELCyACIAQ2AgBBACEFIANBADYCAAwFC0EAIQQgBkEANgIMIAAgBkEMajYCkAQgACAAKALgAjYC5AIDQCAEIAAoAhRORQRAAkAgACgCECAEQQR0aigCDCIBRQ0AIAZBEEGA7QUoAgARAQAgASgCPCABKAIcIAEoAiwgASgCDGpqamwgBigCDGoiBTYCDEEAIQdBACEIIAEoAhQiCgRAIApB/OwFKAIAEQEAIQggBigCDCEFCyAGIAUgCGoiBTYCDCABKAI0IggEQCAIQfzsBSgCABEBACEHIAYoAgwhBQsgBiAFIAdqIgU2AgxBACEHQQAhCCABKAIkIgoEQCAKQfzsBSgCABEBACEIIAYoAgwhBQsgBiAFIAhqIgU2AgwgASgCRCIIBEAgCEH87AUoAgARAQAhByAGKAIMIQULIAYgBSAHajYCDCABQTBqIQUDQCAFKAIAIgUEQCAAIAUoAggQKgwBCwsgAUEQaiEFA0AgBSgCACIFRQ0BIAAgBSgCCBArDAALAAsgBEEBaiEEDAELC0EAIQUgAEEANgKQBCAAIAAoAugCNgLkAiADQQA2AgAgAiAGKAIMNgIADAQLIAZBADYCCCAAIAZBCGo2ApAEIAAgACgC4AI2AuQCIABBBGohBQNAIAUoAgAiBQRAIAUQLCAFQQhqIQUMAQsLQQAhBSAAQQA2ApAEIAAgACgC6AI2AuQCIANBADYCACACIAYoAgg2AgAMAwtBCiEBCyABQQdrQQJ0IQdBACEFA0AgBSAAKAIUTkUEQAJAIAAoAhAgBUEEdGooAgQiAUUNACAJIAEoAgQoAgAgB2oiDUHIAWoiATUCAHwhCSAERQ0AIA1BADYCyAELIAVBAWohBQwBCwtBACEFIANBADYCACACIAmnQf////8HcTYCAAwBC0EAIQUgA0EANgIAQQEhASAAKQOIBEIAVwRAIAApA4AEQgBVIQELIAIgATYCAAsgBkEQaiQAIAULMQACfwJAIAAEf0EBIAAtAGFB9gBGDQIaIAAQLUUNAUHmswEFQY/0AQsiABAuC0EACwtVAwF/AX8BfyAAKALMAhAvIQIgACgC0AIQLyEDIAAoAtQCEC8gAmohAiAAKALYAhAvIQQgAQRAIAEgACgCvAIgAms2AgALIAAoArwCIAIgA2ogBGprC0QAAkAgAUUNACABLQAKDQAgACABKAIcEDEgACABKAIAEDIgACABKAIEEDIgACABKAIMEDMgACABKAIQEDQgACABEDULCy8BAX8CQCABRQ0AIAAoApAERQRAIAEgASgCGEEBayICNgIYIAINAQsgACABEDYLC+sBAwF/AX8BfyAAKAIAIQIgACgCdCIBBEAgASAALwGSAUEBdBA3IAIgACgCdBA4CyAAKALgASEBA0AgAQRAIAEoAhghAyACIAEoAgAgASgCBBA5IAIgARA1IAMhAQwBCwsCQCAALQCXAUUNACAAKAJkIAAuARAQNyAAKAKAASIBBEAgAiABEDgLIAAoAswBIgFFDQAgAiABEDgLIAIgACgCaCAAKAJsEDkgACgCyAEiAQRAIAIgARA4CwJAIAIoApAEDQAgACgCBCAAKAIINgIAIAAoAggiAUUNACABIAAoAgQ2AgQLIAIgABA4CzEBAX9BASEBIAAtAGEiAEHtAEYgAEH2AEZyIABBugFGckUEQEGjrQEQLkEAIQELIAELJQEBfyMAQRBrIgEkACABIAA2AgBBFUGz8wAgARBqIAFBEGokAAseAQF/A0AgAARAIAFBAWohASAAKAIAIQAMAQsLIAELGAAgAEUEQEIADwsgAEH87AUoAgARAQCsC2IBAX8DQCABBEAgASgCKCECIAAgASgCFBAzIAAgASgCGBCuAyAAIAEoAggQnwggACABKAIcEDQgACABKAIgEOkIIAAgASgCEBCkCCAAIAEoAiQQMiAAIAEQNSACIQEMAQsLCw0AIAEEQCAAIAEQNQsLDgAgAQRAIAAgARCgCAsLNgEBfyABBEADQCACIAEoAgBORQRAIAAgASACQQN0aigCCBAy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AwAgACkAAEKAgIBgg78iBKE5AyggAyABIAG9QoCAgGCDvyIFoTkDICADIAUgBKI5AxggAyAEIAMrAyCiIAMrAyggBaKgOQMQIAMgAysDGCADKwMQoDkDCCADIAMrAyggAysDIKIgAysDECADKwMYIgQgAysDCCIFoaCgOQMAIAMgAysDACAAKwMAIgQgAqIgACsDCCIFIAGioKA5AwAgACADKwMIIAMrAwCgOQMAIAAgAysDCCAAKwMAoTkDCCAAIAMrAwAgACsDCKA5AwgLFwAgAEUEQEEADwsgABDvFUH/////A3ELMQAgACACrBBUIgJBAEoEQCAAKAIEIAAoAhBqIAEgAhDlFBogACAAKAIQIAJqNgIQCwuaAQMBfgF8AX8gAC8BECIDQSRxBEAgACkDAA8LAkAgA0EIcQRAQoCAgICAgICAgH8hASAAKwMAIgJE////////38NjDQFC////////////ACEBIAJE////////30NkDQEgAplEAAAAAAAA4ENjBEAgArAPC0KAgICAgICAgIB/DwsgA0EScUUNACAAKAIIRQ0AIAAQhQIhAQsgAQsTACAABEAgACABEOwCDwsgARBICygAIAAgAToAFCAAKAIMBEAgABBgCyABQRJGBEAgACgCAEESEJwCGgsLCQAgAEEBEP0BCzUAIAAtABVBBHEEQCAAKAIAIAAoAgQQMiAAIAAtABVB+wFxOgAVCyAAQQA2AhAgAEIANwIEC1oAIAFFBEAgACACEOwCDwsCQAJAIAAoAuQCIAFNDQAgASAAKALcAk8EQCACQoEBWg0BDAILIAAoAuACIAFLDQAgADMBtgIgAloNAQsgACABIAIQuAUhAQsgAQsfAQF/IABFIABB6O4FRnJFBEAgABBjIQEgABBACyABCzoBAX8CQCAAKAIEIgFFDQAgASAAKAIQakEAOgAAIAAoAgxFDQAgAC0AFUEEcQ0AIAAQZA8LIAAoAgQLTQEBfwJAIAAoAgAgACgCEEEBaq0QXSIBBEAgASAAKAIEIAAoAhBBAWoQ5RQaIAAgAC0AFUEEcjoAFQwBCyAAQQcQXgsgACABNgIEIAELSwEBf0IYEEkiAUUEQEHo7gUPCyAABH8gACgCeAVBgJTr3AMLIQAgAUEAOwEUIAFBADYCECABIAA2AgwgAUEANgIIIAFCADcCACABC3cC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IABCADcDQCAAQQA2AjALKgAgACABNgJAAkAgAUUEQCAAKAKkAkUNAQsgACABELYBDwsgAEF/NgJECwsAIAAgAUEAEMwCCxQAIAAgARChARBfIQEgABCiASABCyAAIAAgARChAS8BECEBIAAQogEgAUE/cUHgowNqLQAACx0BAX8gAC0AlwEEfyAAEKMBBUEACyEBIAAQLCABC1UBAX8gAEUEQEGhJQ8LAkACfyAAEC1FBEBBp5ELECQMAQsgAC0AVwRAQaElDwtBACAAKAJARQ0AGiAAKAKkAhBfIgENASAAKAJACyIAELECIQELIAELPAEBfyAALQAcQSBxBEAgACgCFCIBIAEoAoABQQFrNgKAASAAIAEoApABNgIQIAEgADYCkAEPCyAAEJMGCxwBAX8gACgCAEUEQEEVQeA1QQAQakEBIQELIAELwwMFAX8BfwF/AX8BfwJAIAAtAGFBpwFHDQAgABDsAQ0AIABBABDtASAAEO4BA0AgACgCECECIAEgACgCFE5FBEACQCACIAFBBHRqIgIoAgQiA0UNACADEO8BIAJBADYCBCABQQFGDQAgAkEANgIMCyABQQFqIQEMAQsLIAIoAhwiAQRAIAEQygELIAAQywEgABDMASAAQagDaiEDA0AgAygCACIDBEAgAygCCCEBA0AgACABEPABIAEoAgwhAiAAIAEQMiACIgENAAsMAQsLIABBoANqEPEBIABBuANqIQQDQCAEKAIAIgQEQCAEKAIIIQVBACEBA0AgAUEDRwRAIAUgAUEUbGoiAigCECIDBEAgAigCCCADEQMACyABQQFqIQEMAQsLIAAgBRAyDAELCyAAQbADahDxASAAQYwDaiEBA0AgASgCACIBBEAgACABKAIIIgIQ8gEgACACEPMBDAELCyAAQYQDahDxASAAQQAQpQEgACgCpAIQ9AEgAEHVAToAYSAAIAAoAhAoAhwQMiAAKAL4ASIBBEAgACgC9AEgAREDAAsgAEHOAToAYSAALQC4AgRAIAAoAuACEEALIAAQQAsL6AIFAX8BfwF/AX8BfyMAQRBrIgYkACAGQQA2AgwCQCAAEChFBEBB2KMDECQhBwwBCyADQgBTBEBB2qMDECQhBwwBCyAEQgBTBEBB26MDECQhBwwBC0EBIQcgAUUEQCAAKAIQKAIAIQELAkAgACABEIcBIglB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cUUEQEEADwsgACgCDCEBIAJBgAhxBEAgACgCACABaiEBCyABIAAoAhQoAnhKC0EAAkAgAEUEQCADQQFqQQJJDQEgASADEQMADwsgAkKAgICACFoEQCABIAMgABCSAg8LIAAgASACp0EAIAMQkwILCxEAIAAEQCAAKAIAIAEQmQILC0gBAX4gABCaAiABvSICQoCAgICAgID4/wCDQoCAgICAgID4/wBRIAJC/////////weDQgBScUUEQCAAQQg7ARAgACABOQMACwsbACAALQARQZABcQRAIAAQogIPCyAAQQE7ARALIAAgAARAIABBATYCFCAAKAIAIAEgAqxBAUF/EJoBGgsLKwACQCAARQ0AIAAoAoACIgBFDQAgACABNgIMIAAgACgCJEEBajYCJAsgAQswACABIAAoAhhKBEAgACABQQAQ/AEPCyAAIAAoAiA2AgggACAALwEQQS1xOwEQQQALEgAgAARAIAAoAgAgAawQmQELCxUAIAAQmgIgAEEEOwEQIAAgATcDAAsRACAABEAgACgCACABEJkBCwsPACAABEAgACgCABCaAgsLQAEBfyAALgEQIgFBAEgEQCAAIAAoAgAQqQcaIAAvARAhAQsgAUGAIHEEQCAAKAIIIAAoAiQRAwALIABBATsBEAs5AAJAIABFBEAgA0EBakECSQ0BIAEgAxEDAA8LIAAoAgAiABD4ASAAQQE7ARAgACABIAIgAxCkAgsLOAAgABD5ASAAQfAAOgATIABBgTQ7ARAgACABNgIIIAAgA0EIIAMbNgIkIAAgAkHpnwMgAhs2AgALAwABC3QCAX8BfyMAQeABayICJAACQCAARQ0AAkAgACgCBCIDRQ0AIAMtAAdBAXENACACIAMoAiA2AgAgAEHIASACQRBqQeL5AiACEGlBfxCbAgwBCyAAKAIAIgAgAToAEyAAIAAvARBBgBByOwEQCyACQeABaiQACyoAAkAgAEUEQCADQQFqQQJJDQEgASADEQMADwsgACABIAJBASADEJMCCwtnAQF/AkAgAEUEQCADQQFqQQJJDQEgASADEQMADwsgAiACQn6DIARBAUYiBRsiAkKAgICACFoEQCABIAMgABCSAg8LIAAgASACp0EBQQIgBCAEQQRGGyAFGyADEJMCIAAoAgAQqQILC6cBAgF/AX8CQCAALwEQIgFBgsQB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C5kDBAF/AX8BfwF/IABBACACG0UEQEH40wUQJA8LAkACQCAAKAKMAiIEBEAgBCgCCCIFQQlHDQELQf3TBRAkIQMMAQsgBCgCUCIDRSAFQRdGckUEQCADIAHBEOcCIQELQRkhAyABQQBIDQAgASAEKAIELgE0IgZODQACQAJAIAVBEkYEQCAEKAIsIgNFBEAgBCgCACgCWCAEKAIwQShsaiIFLQARQQRxBEAgBRD7ASIDDQULIARBEGogBSgCDCAFKAIIEOkCIgNFDQMgBCADNgIsCyADKAIEIAFBKGxqIQUgBCgCTC4BICABRgRAIAUgBCkDQBCZAQwCC0HA1AMgBSABIAMvARRPGyEFDAELIAQoAkgiA0UEQCAEIAAgBkEobK0QxQIiAzYCSCADRQ0CCyADIAFBKGxqIgUvARANACAEKAJMLgEgIAFGBEAgBSAEKQNAEJkBDAELIAUgBCgCACgCWCABIAQoAjBqQShsakEoahCsAiIDDQILIAIgBTYCAEEAIQMMAQtBByEDCyAAIAMQpQEgACADEJ4BC0ABAX4Cf0KEgJCAgICAAiAAMwEQIgGIQgGDUARAIAFCP4OnDAELIABBABD1AiAALwEQQT9xCyIAQeCjA2otAAALlgIHAXwBfwF/AX4BfwF/AX8jAEEQayIEJAAgACgCCCIGIARBCGogACgCDCIHIAAtABIiCBD2AiIDQQBKBEAgBCsDCCECAkACQCADQQFHDQACQCACAn5CgICAgICAgICAfyIFIAJE////////38NjDQAaQv///////////wAiBSACRP///////99DZA0AGiACmUQAAAAAAADgQ2MEQCACsAwBC0KAgICAgICAgIB/CyIFEPcCBEAgACAFNwMADAELIAYgACAHIAgQ+AINAQsgAC8BEEEEciEDDAELIAAgAjkDACAAIAAvARBBCHIiAzsBECABRQ0AIAAQ+QIgAC8BECEDCyAAIANB/f8DcTsBEAsgBEEQaiQAC+sOEgF/AX4BfwF+AX8BfAF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQYABayIGJAAgAUIANwMAAkAgAkUNAAJAIANBAUYEQCAAIQRBASEDQQEhCgwBC0EDIANrIQQgAkF+cSECA0ACQCACIARMBH9BAQUgACAEai0AAEUNAUGcfwshCiAEQQFzIQIgACAD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U3INABogAUKAgICAgICABFMLC94EBwF/AX8BfwF/AX4BfwF/An8gA0EBRgRAIAAhBEEBDAELQQMgA2shBSACQX5xIQQDQAJAIAQgBUwNACAAIAVqLQAADQAgBUECaiEFDAELCyAFQQFzIQIgBCAFSiEJIAAgA0EBcWohBEECCyEDIAAgAmohAAJAA0BBASEHIAAgBE0NASAELQAAIgVBwKQDai0AAEEBcQRAIAMgBGohBAwBCwsCQAJAIAVBK2sOAwECAAILIAMgBGohBEEAIQcMAQsgAyAEaiEECyAEIQUDQAJAIAAgBUsEQCAFLQAAQTBGDQELQQAhAgNAAkAgAiAFaiIGIABPIgoNACAGLQAAIgZBMGtB/wFxQQlLDQAgAiADaiECIAhCCn4gBq1C/wGDfEIwfSEIDAELCyABQv///////////wBCgICAgICAgICAfyAHGyAIQgAgCH0gBxsgCEIAUxs3AwACfyACRQRAQX8iBiAEIAVGDQEaCyAJIAkNABogCSIGIAoNABogAiEEA0BBASIGIAQgBWotAABBwKQDai0AAEEBcUUNARogBSADIARqIgRqIABJDQALQQALIQYCQCACIANBE2wiBEkNAEEBIQAgAiAETQRAQQAhBEEAIQADQCAAIARBEUtyRQRAIAUgAyAEbGosAAAgBEHs0gJqLAAAa0EKbCEAIARBAWohBAwBCwsgAEUEQCAFIANBEmxqLAAAQThrIQALIABBAEgNAQsgAUL///////////8AQoCAgICAgICAgH8gBxs3AwBBAkEDIAYgBxsgABshBgsgBg8LIAMgBWohBQwACwALqQEDAX4BfAF/AkAgAC8BECIDQSBxRQRAAn5CgICAgICAgICAfyIBIAArAwAiAkT////////fw2MNABpC////////////ACIBIAJE////////30NkDQAaIAKZRAAAAAAAAOBDYwRAIAKwDAELQoCAgICAgICAgH8LIgFC////////////AHxCfVYgAiABuWJyDQEgACABNwMACyAAIANBwOQDcUEEcjsBEAsL+ggNAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEHQAmsiCCQAIAhBADYCzAICfyAGRQRAQZWgBhAkDAELIAZBADYCACADRSACRXJBASAAECgiBxsEQEGboAYQJAwBCyAFQQBH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IQELIAAgAjYCACADQRBqJAAgAQujAQYBfwF/AX4BfwF/AX8gACgCACAAKAIMIgFrQQxtIQRBASECIAAoAgggAWsiBUEMbSIGQRhsQcgJaq0hAwJAAkAgAEEQaiABRgRAQQAgAxDvCCIBRQ0CIAEgACgCDCAFQQxqEOUUGgwBCyABIAMQ7wgiAUUNAQsgACABNgIMIAAgASAEQQxsajYCACAAIAZBGGwgAWpBvAlqNgIIQQAhAgsgAgtLAgF/AX8gACgCBCECA0AgACgCACIBIAAoAgxNRQRAIAAgAUEMazYCACAAIAEvAQIgAUEEahC1AwwBCwsgAigCABCVASAAIAI2AgQLsLEBHgF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQaAGayIGJAAgACgCACEEAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAB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ACAAQdAOakEAQebiAmo2AgAgAEKIgICAwAA3A8gOIABBkTs2AsQOIABBtZ8DNgLADiACQYCBCCACa0GKICAAQcAOahDhFSACaiICQYCACE8NACAAQbAOakEAQYvjAmo2AgAgAEKMgICAwAA3A6gOIABBjyk2AqQOIABBtZ8DNgKgDiACQYCBCCACa0GKICAAQaAOahDhFSACaiICQYCACE8NACAAQZAOakEAQdbjAmo2AgAgAEKQgICAwAA3A4gOIABBhTs2AoQOIABBtZ8DNgKADiACQYCBCCACa0GKICAAQYAOahDhFSACaiICQYCACE8NACAAQfANakEAQdbjAmo2AgAgAEKUgICAwAA3A+gNIABBhiY2AuQNIABBtZ8DNgLgDSACQYCBCCACa0GKICAAQeANahDhFSACaiICQYCACE8NACAAQdANakEAQYvjAmo2AgAgAEKYgICAwAA3A8gNIABBx4QBNgLEDSAAQbWfAzYCwA0gAkGAgQggAmtBiiAgAEHADWoQ4RUgAmoiAkGAgAhPDQAgAEGwDWpBAEHW4wJqNgIAIABCnICAgMAANwOoDSAAQY6aATYCpA0gAEG1nwM2AqANIAJBgIEIIAJrQYogIABBoA1qEOEVIAJqIgJBgIAITw0AIABBkA1qQQBBmOMCajYCACAAQqCAgIDAADcDiA0gAEHg8wA2AoQNIABBtZ8DNgKADSACQYCBCCACa0GKICAAQYANahDhFSACaiICQYCACE8NACAAQfAMakEAQdbjAmo2AgAgAEKkgICAwAA3A+gMIABB7i42AuQMIABBtZ8DNgLgDCACQYCBCCACa0GKICAAQeAMahDhFSACaiICQYCACE8NACAAQdAMakEAQdbjAmo2AgAgAEKogICAwAA3A8gMIABB5ZABNgLEDCAAQbWfAzYCwAwgAkGAgQggAmtBiiAgAEHADGoQ4RUgAmoiAkGAgAhPDQAgAEGwDGpBAEHR5QJqNgIAIABCrICAgMAANwOoDCAAQdyDATYCpAwgAEG1nwM2AqAMIAJBgIEIIAJrQYogIABBoAxqEOEVIAJqIgJBgIAITw0AIABBkAxqQQBBi+MCajYCACAAQrCAgIDAADcDiAwgAEGUrQE2AoQMIABBtZ8DNgKADCACQYCBCCACa0GKICAAQYAMahDhFSACaiICQYCACE8NACAA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AkUNAiABIAAoArwBQQAgAhECABoMAgtBACECIAAtABEiASEDIAFFBEAgABD2BiECIAAtABEhAwsgA0H/AXFBAUYEQCAAQQIQ1AYhAgsCQCACDQAgACgCACICKAIcIgMEQCACIAAoArwBQQAgAxECABoLIAFBAUcNACAAQQEQ3wYaDAILIAENASAAEKUGDAELAkAgAUECaw4DAAEAAQsgACgCRCIBKAIAIgJFDQAgASACKAIEEQEAGiABQQA2AgALIAAtAAULbAIBfgF/IAApAwAhAgJAAkAgAUIAWQRAIAJCAFcNAUEBIQMgAkL///////////8AhSABWg0BDAILIAJCAFkNAEEBIQMgAUIBfEKBgICAgICAgIB/IAJ9Uw0BCyAAIAEgAnw3AwBBACEDCyADCxwBAX8gACAAKAIAIgEoAtQBNgIEIAEgADYC1AELhwEDAX8BfwF/IAAoAhQhAiAAEPgBIAJCIBDsAiIBRQRAQQcPCyACIAEQVSEDIAFBADYCFCABQgA3AgggASACNgIEIAFBADYCACABQQA2AhwgAUEBOwEaIAEgAUEgajYCECABIANB4P8/akEEdjsBGCAAQS42AiQgAEGQIDsBECAAIAE2AghBAAvJAQUBfwF/AX8BfwF/IwBBoAFrIgEkACABQQBBoAEQ5xQhAwNAIAAEQCAAKAIIIQRBACEBIABBADYCCANAIAMgAUECdGoiAigCACIFBEAgBSAAEMQHIQAgAkEANgIAIAFBAWohAQwBCwsgAiAANgIAIAQhAAwBCwsgAygCACEAQQEhAQNAIAFBKEZFBEACQCADIAFBAnRqKAIAIgJFDQAgAEUEQCACIQAMAQsgACACEMQHIQALIAFBAWohAQwBCwsgA0GgAWokACAAC14CAX8BfyMAQRBrIgQkAANAAkAgACIDKAIMIgAEQCAAIAEgBEEMahDDByAEKAIMIAM2AggMAQsgASADNgIACyADQQhqIQEgAygCCCIADQALIAIgAzYCACAEQRBqJAALegUBfwF+AX8BfwF+IwBBEGsiBSECAkADQCAAKQMAIQMgASEEA0AgBCIBKQMAIgYgA1kEQCADIAZTBEAgAiAANgIIIAAhAgsgACgCCCIADQIMAwsgAiABNgIIIAEhAiABKAIIIgQNAAsLIAAhAQsgAiABNgIIIAUoAggLbAQBfwF/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NgIsIAJBBXZBAXEhAUEAIQADQCAAQRdGRQRAIABBAnRBnOAGaiECA0AgAigCACICBEAgBSACQQEgARCbCyACQSRqIQIMAQsLIABBAWohAAwBCwsgB0GoA2ohAgNAIAIoAgAiAkUNByAFIAIoAghBACABEJsLDAALAAsgAEECNgIsIAdBuANqIQJBACEBA0AgAigCACICRQ0GIAYgAigCCCgCADYCxAFBACEAIAYgATYCwAEgBUEBQcTKACAGQcABahCPCyABQQFqIQEMAAsACyAAQQM2AixBACECA0AgAiAHKAIUTg0FIAcoAhAgAkEEdGoiASgCBCIABEAgASgCACEBIAYgABClBDYCuAEgBiABNgK0ASAGIAI2ArABIAVBAUG6wQAgBkGwAWoQjwsLIAJBAWohAgwACwALIAhFDQMgByAIIAQQhAMiAkUNAyAHIAIoAjwQ/AIhASAAQQU2AiwgACABEK8JIAJBCGohAiAGIi9BoAFqIQlBACEBA0AgAigCACICRQ0EIAIvADchACACLQA2IQMgAigCACEEIC8gAigCJEEARzYCoAEgBiAENgKUASAGIANBAEc2ApgBIAZBACIDQaiPBmogAEEDcUECdGooAgA2ApwBIAYgATYCkAEgBUEBQZKLASAGQZABahCPCyACQRRqIQIgAUEBaiEBDAALAAsgCEUNAiAHIAggBBCVCCIBRQRAIABBAiAIIAQQ+wIiAkUNAyACLQAcQYABcUUNAyACEK8DIgFFDQMLIAcgASgCGBD8AiECIAFBMkE0IAopAwhQIgMbai8BACEJIABBA0EGIAMbNgIsIAEoAgwhCyAAIAIQrwlBACECA0AgAiAJRg0DQQAhAyABKAIEIAJBAXRqLgEAIgRBAE4EQCALKAIEIARBDGxqKAIAIQMLIAYgAzYCiAEgBiAENgKEASAGIAI2AoABIAVBAUGdywEgBkGAAWoQjwsgCikDCFBFBEAgASgCHCACai0AACEDIAEoAiAgAkECdGooAgAhBCAGIAIgAS8BMkk2AnggBiAENgJ0IAYgAzYCcCAFQQRBossBIAZB8ABqEI8LCyAFQdQAQQEgACgCLBCKAxogAkEBaiECDAALAAsgAEEGNgIsIAAgBBCeCSAGIjBB1ABqIQwDQCAPIAcoAhRODQIgBygCECECAkAgBARAIAQgAiAPQQR0aigCABBsDQELIAIgD0EEdCILaigCDCIJKAIMIQADQCAJQRBqIQMCQANAIAMhAiAARQ0BA0AgAigCACICRQRAQQAhAAwCCyACKAIIIgEvASINAAsLIAYgASgCADYCYCAHQdqQAyAGQeAAahD9AiICBEAgBkEANgK4AyAHIAJBfyAGQbgDakEAEKQDGiAGKAK4AxCPARogByACEDULIActAFcEQCAHKAKAAkGhJUEAELICIAcoAoACQQc2AgxBACECCyAAQQFrIQAgBygCECALaigCDCEJDAELCyAJQRBqIQEDQCABKAIAIgFFDQEgASgCCCECIAgEQCAIIAIoAgAQbA0BC0HjKyEAAkACQAJAIAItACsiA0EBaw4CAAIBC0GMiAEhAAwBC0H3KkHUpQEgAi0AHSIAQRBxGyEACyAHKAIQIAtqKAIAIQlBACEKAkAgAigCACIDQfHDAUEHEG4NACADQQdqIgpBAEHk8gBqEG1FBEBBi8MBIQMMAQsgCkEAQdHyAGoQbQ0AQfjCASEDCyACLgEiIQogMCACKAIcIgJBEHZBAXE2AlQgBiACQQd2QQFxNgJQIAYgCjYCTCAGIAA2AkggBiADNgJEIAYgCTYCQCAFQQFBxosBIAZBQGsQjwsMAAsACyAPQQFqIQ8MAAsACyAFIA0QigsLIAcgGhA1IAcgCBAyCyAGQeADaiQAC6QBBAF/AX8BfwF/IwBBEGsiBiQAAkAgABDwCCIFRQ0AIAAoAiQNACABBEAgACABIAEgBkEMahCoCSIEQQBIIARBAUZyDQELAkAgAkUNACAAQQBBACACQQAQ+QkNACAAIAAoAixBAWoiAzYCLCAAIAIgAxD3CAsgBUEFIAQgAxCKAxogBSAFKAKcAUEBIAR0cjYCnAELIAAoAgAgAhAzIAZBEGokAAs6AQF/IAAgACgCLEEBaiIBNgIsIAAQ8AgiAARAIABBBEEAIAFBfxDbCBogACAAKAKcAUEBcjYCnAELC5QBAwF/AX8BfyMAQUBqIgQkACAAKAIAKAIQIAFBBHRqKAIAIQVBASEBA0AgAUEFRwRAIAQgATYCEEEYIARBIGpB77gBIARBEGoQaSEGIAAoAgAgBiAFEIQDBEAgBCADNgIMIAQgAjYCCCAEIAY2AgQgBCAFNgIAIABB5OcBIAQQjQkLIAFBAWohAQwBCwsgBEFAayQAC5oBAwF/AX8BfyMAQRBrIgMkACAAEPAIIQUgABCVCSEEIAFBAUwEQCAAQbjDAUEAELICCyAFQZABIAEgBCACENsIGiAAKAJ4IgUgACAFG0EBOgAVIAAoAgAoAhAgAkEEdGooAgAhAiADIAQ2AgwgAyAENgIIIAMgATYCBCADIAI2AgAgAEGougEgAxCNCSAAIAQQlgkgA0EQaiQAC10BAX8jAEEQayIFJAAgACABQQAQwgkhAQJAIANFIARBf0ZxDQAgACgCAC0AsQENACAFIAIpAgBCIIk3AwAgAEHIkwMgBRCyAgsgACABIAJBARDYCSAFQRBqJAAgAQvJAQEBfyAAKAIAIQQCQAJ/AkAgAUUEQCAEQsgAEOwCIgANAQwDCyAAIAFBASABKAIAENUKIgAEQCAAKAIAQQFrDAILIAQgARCkCAwCCyAAQoGAgIAQNwMAIABBCGpBAEHAABDnFBogAEF/NgIwQQALIQECQCADRQ0AIAMoAgBFDQAgACABQQZ0aiIBIAQgAxCECTYCECABIAQgAhCECTYCDCAADwsgBCACEIQJIQQgACABQQZ0aiIBQQA2AgwgASAENgIQIAAPC0EAC7QZDAF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQeABayILJAAgACgCACENIAtBADYCpAEgC0EANgKgAQJAIAAoAiQNACAKQQJHBEAgAC0A1AFBAUYNAQsgABCDAw0AIAAgBBCmCQ0AAkACQAJAAn8gAwRAIAAgASACIAtBpAFqEKgJIgFBAEgNBQJAIA0tALEBDQAgACADEKkJIQwgAigCBCAMRXINAEEBIAEgDCgCPCANKAIQKAIcRhshAQsgACgCACEMIAsgADYCqAEgCyAMKAIQIAFBBHRqIgwoAgA2AtABIAwoAgwhAiALQQEiDEELajYCsAEgC0ENNgK0ASALQQ42ArgBQQAhDCALQQA2ArwBIAtBADsBwAEgCyACNgLIASALIAA2AqwBIAsgC0GoAWo2AsQBIAsgAUEBRjoAzAEgC0H/KDYC1AEgCyALKAKkASITNgLYASALQagBaiADEK0JGiAAQQAgA0EIahCICSICRQ0FAkAgAUEBRw0AIA0oAhAoAhwgAigCPEYNACALIAIoAgA2ApABIABB0ZYDIAtBkAFqELICDAMLQQAgAi0AHEGAAXFFDQEaIAIQrwMMAQsgACgC8AEiAkUNBCANIAIoAjwQ/AIhAUEACyEOIA0oAhAhEQJAIAIoAgAiD0HxwwFBBxBuIANFcg0AIA0tALEBDQAgCyAPNgIAIABBrK8BIAsQsgIMAQsCQAJAAkAgAi0AK0EBaw4CAQACCyAAQfGuAUEAELICDAMLIABBiq8BQQAQsgIMAgsgESABQQR0aiEQAkACQAJAIBMEQCANIBMQhAkiDEUNBCAAIAxB/yggAigCABCYCQ0FIAAtANQBQQFLDQMCQCANLQCxAQ0AIA0gDCAQKAIAEIQDRQ0AIAsgDDYCgAEgAEHW3gAgC0GAAWoQsgIMBgsgDSAMIBAoAgAQlQhFDQEgCUUEQCALIAw2AnAgAEG3PSALQfAAahCyAgwGCyAAIAEQrwkgABC6CQwFCyACQQhqIQxBASEJA0AgDCgCACIMBEAgCUEBaiEJIAxBFGohDAwBCwsgCyAJNgJkIAsgDzYCYCANQZm5ASALQeAAahD9AiIMRQ0DIAAtANQBRQ0BIAwgDC0AB0EBajoABwsgAC0A1AFBAUsNAQsgAEESQcryAEHd8gAgAUEBRiIJG0EAIBAoAgAiDxD5CA0CIABBA0EBIAkbIAwgAigCACAPEPkIDQILAkAgBEUEQCACKAIEIAIuASJBDGxqQQxrIgQgBC8BCkEIcjsBCiALIAQoAgAiBDYCmAEgCyAEEFo2ApwBQQAhCSANQTsgC0GYAWpBABCgCSEEIAAoAgAgBBDBCSIERQ0EIAQoAgBBBHQgBGogCEEAIAhBf0cbOgAADAELIAAgBEH/KBDaCSAAKAIkDQILQQAhECAEKAIAIhJBACASQQBKGyEPQQAhCANAIAggD0ZFBEAgBCAIQQR0aigCCCIJLQAAQfEARgRAIAkoAggQWiAQakEBaiEQCyAIQQFqIQgMAQsLIAwQWiEJQQEhCCAOBEAgDi8BMiEICyANIAggEmrBIAkgEGpBAWogC0GgAWoQiQohCAJAAkAgDS0AVwRAIAQhCQwBCyAIIAsoAqABIg82AgAgCyAPIAlBAWoiCWoiEDYCoAEgDyAMIAkQ5RQaIAggBToANiAIIAI2AgwgCCAKQQNxIhQgCC8AN0H0/wNxIAVBAEdBA3RycjsANyAIIAFBBHQiCSANKAIQaigCDDYCGCAIIAQoAgA7ATIgBwRAIAAgAkECIAdBABD5CRogCCAHNgIkCyAJIBFqKAIMLQBMIQcgBCEJIAAtANQBQQJPBEAgCCAENgIoQQAhCQsgBEEIaiEPIAdB/wFxQQNLIRVBACEEA0AgCC8BMiAESwRAIA8oAgAQiApBACEHIAAgAkEgIA8oAgBBABD5CRogACgCJA0DAkAgDygCABCHCiIRLQAAQacBRwRAIAAoAvABIAJGBEAgAEHEPkEAELICDAYLIAgoAihFBEAgCCAJNgIoQQAhCQsgCCgCBCAEQQF0akH+/wM7AQAgCCAILwA3QfffA3FBgCByOwA3QX4hEQwBCwJAIBEuASAiEUEASARAIAIuASAhEQwBCyACKAIEIhIgEUEMbCIWai0ABEEPcUUEQCAIIAgvADdB9/8DcTsANyACKAIEIRILIBIgFmotAApBIHFFDQAgCCAILwA3QYAwcjsANwsgCCgCBCAEQQF0aiAROwEACwJAIA8oAgAiEi0AAEHxAEYEQCALIBAgEigCCCIRIBEQWkEBaiISEOUUIBJqIhI2AqABDAELIBFBAEgEQCAQIRJBACEQDAELIBAhEiACKAIEIBFBDGxqEI4EIRALIBBBgLQDIBAbIREgDS0AsQFFBEAgACAREPEJRQ0ECyAIKAIgIARBAnRqIBE2AgAgCCgCHCAEaiAPLQAIQQAgFRs6AAAgD0EQaiEPIARBAWohBCASIRAMAQsLAkAgDgRAQQAhBwNAIAcgDi8BMk8NAgJAIAggCC8BMiAOIAcQ9QkEQCAIIAgvATRBAWs7ATQMAQsgCCgCBCAEQQF0aiAOKAIEIAdBAXRqLwEAOwEAIAgoAiAgBEECdGogDigCICAHQQJ0aigCADYCACAIKAIcIARqIA4oAhwgB2otAAA6AAAgBEEBaiEECyAHQQFqIQcMAAsACyAIKAIEIARBAXRqQf//AzsBAEEAIQcgCCgCICAEQQJ0akGAtAM2AgALIAgQmAggACgC8AFFBEAgCBD7CQsgCBD4CQJAIANFDQAgCC8BNCACLgEiSA0AIAggCC8ANyIOQSByOwA3QQAhBCACLgEiIgdBACAHQQBKGyEHA0AgBCAHRg0BAkAgBCACLgEgRg0AIAggBMEQ5wJBAE4NACAIIA5B3/8DcTsANwwCCyAEQQFqIQQMAAsACwJAAkACQCACIAAoAvABRw0AIAJBCGohBANAIAQoAgAiDkUNAQJAAkAgDi8BMiIPIAgvATJHDQBBACEEA0AgBCAPRg0CIARBAXQiByAOKAIEai8BACAIKAIEIAdqLwEARw0BIARBAnQhByAEQQFqIQQgByAOKAIgaigCACAHIAgoAiBqKAIAEG1FDQALCyAOQRRqIQQMAQsLAkAgDi0ANiIEIAgtADYiB0YNACAEQQtGIAdBC0ZyRQRAIAtBADYCUCAAQdO2ASALQdAAahCyAiAOLQA2IQQLIARB/wFxQQtHDQAgDiAILQA2OgA2CyAKQQJGBEAgDiAOLwA3Qfz/A3EgFHI7ADcLQQAhByAALQDUAUECSQ0EIAggACgC9AE2AhQMAQsCQCAALQDUAUEBSw0AIA0tALEBBEACQCADRQ0AIAggDSgCrAE2AiwgCBCWCEUNAEEAIQcgAEHDpwFBABCyAiAAQazWBxDlATYCDAwGCyAIKAIYQRhqIAgoAgAgCBDnAwRAIA0QlQFBACEHDAYLIA0gDSgCGEEBcjYCGAwBCyADRQRAIAIoAhxBgAFxDQELIAAgACgCLEEBaiIHNgIsIAAQ8AgiBEUEQEEAIQcMBAsgAEEBIAEQtQkgCCAEQbsBEPEINgIsIARBkwEgASAHQQIQ2wgaIAYEfyATKAIAIgogACgCzAEgACgCyAEgCmtqIgZBAWsiE2otAAAhDiALIAo2AkggC0EAIgpBzoUCQemfAyAFG2o2AkAgCyATIAYgDkE7Rhs2AkQgDUHr0QAgC0FAaxD9AgVBAAshCiANKAIQIAFBBHRqKAIAIQUgCCgCACEGIAIoAgAhEyALIAo2AjAgCyAHNgIsIAsgEzYCKCALIAY2AiQgCyAFNgIgIABB0rECIAtBIGoQjQkgDSAKEDIgAwRAIAAgCCAHEIoKIAAgARC2CSALIAgoAgA2AhAgBCABIA1B5oMDIAtBEGoQ/QJBABC3CSAEQaYBQQBBARCKAxoLQQAhCiAEKAJsIQcgBCgCAC0AVwR/QZCCCAUgBCgCaCAIKAIsQRhsagsiBCAHNgIICwJAIAMEQCANLQCxAUUNAQsgCCACKAIINgIUIAIgCDYCCAwCC0EAIQcgAC0A1AFBAkkNAgsgACAINgL0AQtBACEHDAQLIAhFDQMLIA0gCBDOBwwCC0EAIQwLIAQhCQsgAkEIaiEKAkADQCAKIgIoAgAiAEUNASAAQRRqIQogAC0ANkEFRw0ACwNAIAooAgAiBEUNASAELQA2QQVGDQEgAiAENgIAIAAgBCgCFDYCFCAEIAA2AhQgBEEUaiECDAALAAsgCSEECyANIAcQMyANIAQQrgMgDSADEKQIIA0gDBAyIAtB4AFqJAALRwEBfwJAIAAtANQBQQNGDQAgACgCAEIQEMUCIgNFDQAgAyABNgIAIAMgAikCADcCBCADIAAoApACNgIMIAAgAzYCkAILIAELPgEBfyAAQtgAEOwCIgJFBEAgACABEDMgAg8LIAJCgYCAgMAANwIAIAIgATYCCCACQgA3AgwgAkEANgIUIAILWwEBfyABRQRAIAAoAgAgAhDBCQ8LIAEoAgAiAyABKAIETgRAIAAoAgAgASACENoKDwsgASADQQFqNgIAIAEgA0EEdGoiAEEANgIUIABCADcCDCAAIAI2AgggAQv7AQYBfwF/AX8BfwF/AX8jAEEQayIEJAAgACgCJEUEQCAEIAEoAgwiAgR/IAIoAhgFQQALIgI2AgwCQCABKAIQIgNFDQAgAygCGCIDIAJMDQAgBCADNgIMCyABKAIUIQUCQCABKAIEIgZBgCBxBEAgBSAEQQxqEIQLDAELIAVFDQAgBSAEQQxqEIULQQAhAyAFKAIAIgJBACACQQBKGyEHQQAhAgNAIAIgB0ZFBEAgBSACQQR0aigCCCgCBCADciEDIAJBAWohAgwBCwsgASADQYiEgAJxIAZyNgIECyABIAQoAgxBAWoiAjYCGCAAIAIQgwoaCyAEQRBqJAALMAAgAQRAIAEgAjYCFCABIAEoAgRBgKCAAnI2AgQgACABEMMJDwsgACgCACACEJ8IC/8BAwF/AX8BfyMAQdAAayILJAAgACgCAELMABDsAiIKIAsgChsiCSABRQRAIAAoAgBBtAFBABDICSEBIAAoAgAgARDBCSEBCyABNgIcIAlBigE6AAAgCUIANwIIIAkgBzYCBCAAIAAoAmxBAWoiATYCbCAJQn83AhQgCSABNgIQIAlBADsBAiACRQRAIAAoAgBCyAAQxQIhAgsgCUEANgJIIAlCADcCQCAJIAg2AjwgCUIANwI0IAkgBjYCMCAJIAU2AiwgCSAENgIoIAkgAzYCJCAJIAI2AiAgACgCACIALQBXBEAgACAJIAkgC0cQoQhBACEKCyALQdAAaiQAIAoLNgAgAQRAIAEoAgBBBnQgAWoiASACNgIAIAFBE2siASABLwAAQQRyOwAADwsgACgCACACEK4DCyQAIAEEQCAALQDUAUECTwRAIAAgARCCCgsgACgCACABEKAICws2AQF/IwBBEGsiAyQAIAMgAjYCCCADIAIQWjYCDCAAIAEgA0EIakEAEKAJIQIgA0EQaiQAIAILPwMBfwF/AX8CQCAAKAIEIgJBgJCAIHENACAAKAIIEIUKIgNFDQAgAEGqAToAACAAIAIgA3I2AgRBASEBCyABCwsAIAAgAUEBEIEKC8wBBQF/AX8BfwF/AX8jAEEQayIEJAACQCABKAI0RQ0AQQEhBSABIQMCQAJ/A0AgAyICIAY2AjggAiACKAIEQYACcjYCBCACKAI0IgNFDQJBACEGIAVBAWohBUGLywEgAygCMA0BGiACIQYgAygCPEUNAAtB19YBCyEDIAQgAi0AABDLCjYCBCAEIAM2AgAgAEG+nAEgBBCyAgsgAS0ABUEEcQ0AIAAoAgAoAogBIgJBAEwgAiAFTnINACAAQZnZAUEAELICCyAEQRBqJAALrwEDAX8BfwF/IwBBEGsiBSQAAkAgACgCACIGQawBIAJBARCgCSIERQRAIAYgARCuAwwBCyAEIAIoAgAgACgC7AFrNgIkAkAgAUUNACABKAIAIAAoAgAoApABTA0AIAAtABINACAFIAI2AgAgAEGu2gEgBRCyAgsgBCABNgIUIAQgBCgCBEEIcjYCBCAAIAQQwwkgA0EBRw0AIAQgBCgCBEEEcjYCBAsgBUEQaiQAIAQLQgACQCABRSACRXINACABLQAAQfkARw0AIAAtANQBQQFLDQAgACgCACEBIAIgAzoAACABIAIoAhAQMyACQQA2AhALC24BAX8gAQRAIAJFBEAgAQ8LAkAgAigCBCABKAIEckGDgICAAnFBgICAgAJHDQAgAC0A1AFBAUsNACAAKAIAIQMgACABEIMLGiAAIAIQgwsaIANBmwFB/NYCEMgJDwsgAEEsIAEgAhChCSECCyACC1UBAX8CQCABBEAgASACNgIsIAEgASgCBCIDQYCAiAhyNgIEIAIgATYCSCADQQRxRQ0BIAItABBBpgFGDQEgAEGmxwBBABCyAg8LIAAoAgAgAhCiCAsLlAECAX8BfwJAIAIEQCAAKAIAIQMgAUUNAQJAIAEoAhQiBARAIAQoAgANAQsgAEE7IAIQkAoaDwsCQCABLQAHQQFxRQ0AIAEoAiwtABBBpgFGDQAgACABEIILDAILIANBkQFBAEEAEKAJIgBFDQEgACACNgIUIAEgADYCDCAAIAAoAgRBgIAIcjYCBAsPCyADIAIQjwMLhAEAIAFFBEAgACACEDMgACADEDMPCyABIAMEfyABIAM2AhAgASABKAIEIAMoAgRBiISAAnFyNgIEIAMoAhhBAWoFQQELIgM2AhgCQCACRQ0AIAEgAjYCDCABIAEoAgQgAigCBEGIhIACcXI2AgQgAigCGCICIANIDQAgASACQQFqNgIYCws8AAJAIAIoAgRFDQAgACgCAEHxACACIAMQoAkiAkUNACACIAE2AgwgAiACKAIEQYDEAHI2AgQgAg8LIAELhwECAX8BfyAAKAIAIQQCQAJAIAFFBEAgBEIQEMUCIgMNAQwCCyAEIAEgASgCAEEDdEEQaq0QYSIDDQAgBCABEDQMAQsgAyADKAIAIgFBAWo2AgAgAyABQQN0aiAEIAIQhAkiATYCCCABRSAALQDUAUECSXJFBEAgACABIAIQwAkaCyADDwtBAAuAAgQBfwF/AX8BfyMAQRBrIgQkACAAKAIAIQMgACgC+AEEQCAAQaf0AEEAELICCyAAQQE6AJcBAkAgA0KQARDFAiICRQRAIAMgARCuAwwBCyAAIAI2AogBIAIgATYCBCACIAA2AgAgAEE8IAIQkAoaIAMtAFcNACAEIAA2AgBBKCACQegAakG++AAgBBBpIQUgAkEBOgASIAJBlgU7ARAgAiAFNgIIIAMoAhAoAhwhACACIAE2AkQgAiACQQhqIgE2AjAgAkGWAToALCACIAJBLGo2AiQgAiAANgIgIAIgADYCHCAAQShqIAUgARDnAyABRw0AIAMQlQELIARBEGokAAtkAQF/IABCMBDFAiIGRQRAIAAgARCuAyAAIAIQMyAAIAMQrgMgACAEEDMgACAFEOkIIAYPCyAGIAQ2AgwgBiADNgIIIAYgAjYCBCAGIAE2AgAgBiAFNgIQIAYgA0EARzoAFCAGC880IwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX4BfwF/AX8jAEHgAmsiCCQAIAhBADYCvAEgCEEANgK4ASAAKAIAIRkCQCAAKAIkBEAgAiEQDAELIAhBADYCnAECf0EAIAJFDQAaAkAgAi0ABUECcUUNACACKAI0DQAgAigCHCEcIAJBADYCHCAZIAIQnwhBAAwBCyACCyEQIAAgARCpCSICRQ0AIABBEiACKAIAQQAgGSgCECAZIAIoAjwQ/AIiFkEEdGooAgAQ+QgNACACKAIcIQcgACACQf8AQQAgCEGUAWoQ2wohICACLQArISMgACACEJkJDQAgACACICAQ3QoNACAAEPAIIgxFDQAgAC0AEkUEQCAMIAwvAZgBQRByOwGYAQsgACAQICByQQBHIBYQtQkCQAJAICAgAyAQRXJyDQAgACgCjAINACAQKAJADQAgAi0AK0EBRg0AAkAgBCIGQQtHDQAgAi4BIEEATgRAIAItACoiBkELRw0BC0ECIQYLIBAoAiAiCygCAEEBRw0AIAsoAhwNACAQKAIkDQAgECgCMA0AIBAoAigNACAQKAI8DQAgECgCNA0AIBAtAARBAXENACAQKAIcIg0oAgBBAUcNACANKAIILQAAQbQBRw0AIAAoAgAhDSAAQQAgC0EIahCICSILRQ0AIAsoAhQgAigCFEYEQCALKAI8IAIoAjxGDQELIAsoAhwiDiACKAIcIgpzQYABcQ0AIAstACsNACACLwEiIgkgCy8BIkcNACACLwEgIAsvASBHQQAgCkGAgARxIA5BgIAEcRtyDQBBACEOA0AgCcEgDkoEQCAOQQxsIgkgAigCBGoiCi8BCkHgAHEiDyALKAIEIAlqIgkvAQpB4ABxRw0CIA8EQEEAIAsgCRCTCSACIAoQkwlBfxD4Cg0DCyAKLQAFIAktAAVHDQIgChCOBCAJEI4EEGwNAiAKLQAEQQ9xBEAgCS0ABEEPcUUNAwsCQCAORSAKLQAKQeAAcXINACACIAoQkwkiCkEARyALIAkQkwkiCUVGDQMgCkUNACAKKAIIIAkoAggQ5hUNAwsgDkEBaiEOIAIvASIhCQwBCwsgC0EIaiEUQQAhDyACIiRBCGoiESEKA0AgCigCACIOBEBBASAPIA4tADYbIQ8gFCEKA0AgCigCACIKRQ0DIA4gChD5CkUEQCAKQRRqIQoMAQsLAkAgCigCLCAOKAIsRw0AIAsoAjwgAigCPEcNAEHQ7gUoAgAiCkUNA0GbAyAKEQEARQ0DCyAOQRRqIQoMAQsLAkAgAigCECIKRQ0AIA0tABhBBHENACALKAIQIApBfxCYCg0BCwJAIA0pAyAiJUKAgAGDUEUEQCACKAIwDQIgJUKAgICAEINQDQEMAgsgJUKAgICAEINCAFINAQsgDSALKAI8EPwCIR4gABDwCCEJIAAgHhCvCSAAIAAoAigiF0ECajYCKCAAIBYgAhD6CiEKIAlBywBBACAAEJUJIhoQigMaIAAQlQkhEyAAIBdBAWoiEiAWIAJB8QAQ9QgCQCANLQAYQQRxDQACQCACLgEgQQBIBEAgJCgCCA0BCyAPDQAgBkEDa0F9Sw0BC0EAIQ8gCUEkIBJBABCKAyEVIAlBCRDxCCEYIAkoAmwhDiAJKAIALQBXBH9BkIIIBSAJKAJoIBVBGGxqCyIPIA42AggLIAstABxBgAFxRQRAIAAgFyAeIAtB8AAQ9QggCUEkIBdBABCKAyEbAkAgAi4BIEEATgRAIAlBhwEgFyATEIoDIQ4gDS0AGEEEcUUEQCAJQR8gEkEAIBMQ2wghFSAAIAYgAhD7CkEAIQ8gCSgCbCEGIAkoAgAtAFcEf0GQgggFIAkoAmggFUEYbGoLIg8gBjYCCAsgACAKIBMQ/AoMAQsCQCAkKAIIDQAgDS0AGEEIcQ0AIAlB/wAgEiATEIoDIQ4MAQsgCUGHASAXIBMQigMhDgtBqQEhBiANKAIYIgpBBHEEQCAJQYkBIBIQ8ggaIA0oAhghCkGYASEGCwJAIApBBHFFBEAgCUGGASAXIBpBARDbCBogBkE5cSEGDAELIAlBgQEgEiAXIBMQ2wgaCyAJQYABIBIgGiATENsIGiANLQAYQQRxRQRAIAlBfyACQXsQvQoLIAkoAmwiCkEASgRAIAkoAmggCkEYbGpBFmsgBjsBAAsgCUEnIBcgDhCKAxogCUH6ACAXQQAQigMaIAlB+gAgEkEAEIoDGgsDQCAUIQYCQAJAIBEoAgAiDgRAA0ACQCAGKAIAIgZFDQAgDiAGEPkKDQAgBkEUaiEGDAELCyAJQfAAIBcgBigCLCAeENsIGiAAIAYQ4AogCCAGKAIANgKQASAJQbPuACAIQZABahDzCCAJQfEAIBIgDigCLCAWENsIGiAAIA4Q4AogCSgCbCIKQQBKBEAgCSgCaCAKQRhsakEWa0EBOwEACyAIIA4oAgA2AoABIAlBs+4AIAhBgAFqEPMIIAlBJCAXQQAQigMhFQJ/IA0tABhBBHEEQCAGLwE0IRFBACEKA0AgCiARRg0EIApBAnQhDyAKQQFqIQpBgLQDIA8gBigCIGooAgAQbEUNAAtBCAwBC0EIIgYgCy0AHEGAAXFFDQAaQQlBCCAOLwA3QQNxQQJGGwshBiAJQYYBIBcgGkEBENsIGiANLQAYQQRxDQIgAi0AHEGAAXFFDQIgDi8AN0EDcUECRw0CIAAgAiASIBoQ/QoMAgsgGwRAQQAhCyAJKAJsIQYgCSgCAC0AVwR/QZCCCAUgCSgCaCAbQRhsagsiCyAGNgIICyAAIBMQlgkgACAaEJYJIBhFBEBBACEGDAULIAAQ5gogCUHGAEEAQQAQigMaQQAhCyAJKAJsIQYgCSgCAC0AVwR/QZCCCAUgCSgCaCAYQRhsagsiCyAGNgIIIAlB+gAgEkEAEIoDGgwDCyAJQYkBIBIQ8ggaIAlBgQEgEiAXEIoDGkGYASEGCyAJQYoBIBIgGhCKAxogCSgCbCIKQQBKBEAgCSgCaCAKQRhsakEWayAGOwEACyAJQScgFyAVQQFqEIoDGkEAIQogCSgCbCEGIAkoAgAtAFcEf0GQgggFIAkoAmggFUEYbGoLIgogBjYCCCAJQfoAIBdBABCKAxogCUH6ACASQQAQigMaIA5BFGohEQwACwALIAAgFiACEPoKIR4gACAAKAIsIgZBAWoiEiACLgEiaiILNgIsIBIhFCACLQArQQFGBEAgACALQQFqNgIsIAZBAmohFAsgB0GAAXEhFyACLwEcQcAIcUUhEQJAAkACQAJAIANFBEBBfyEJDAELIANBAToABEEAIQYgAygCACIHQQAgB0EAShshDgNAIAYgDkYEQEF/IQlBACEKA0AgCiAORg0DQQAhBiACLgEiIgdBACAHQQBKGyELIAMgCkEDdGoiDygCCCEHAkACQANAIAYgC0YNAQJAIAcgBkEMbCINIAIoAgRqKAIAEG1FBEAgDyAGNgIMIAIoAgQiCyANai0ACkHgAHFFDQEgCCALIAZBDGxqKAIANgJwIABBx5QDIAhB8ABqELICDAkLIAZBAWohBgwBCwsgBiACLgEiTg0AIBFBACAGIApGGyERIAogCSAGIAIuASBGGyEJDAELIAcQjAQEQEEAIREgCiEJIBdFDQELIAggBzYCZCAIIAFBCGo2AmAgAEG23gAgCEHgAGoQsgIgAEEBOgARDAULIApBAWohCgwACwAFIAMgBkEDdGpBfzYCDCAGQQFqIQYMAQsACwALIBRBAWohGgJ/AkACQAJ/IBAEQAJAAkAgECgCICIGKAIAQQFHDQAgBi0ALUEgcUUNACAQKAI0DQAgCCAGKAIkNgKcASAGKAIoIRsgBigCHCgCHCgCACEVIAggBkEIajYCUCAAQQBBmeABIAhB0ABqEKAKIBFB/wFxRQ0BIBUgAi4BIkcNASAbQQFrIhQgAi0AK0EBRmshEiAbIRoMAQsgACAAKAIsQQFqIgc2AixBACEGIAxBCyAHQQAgDCgCbCINQQFqENsIGiAIQagBaiILQgA3AwAgCEIANwOgASAIIAc2ApwBIAhBDToAmAEgCCAaQQAgEUH/AXEbNgKkASAIIAIuASI2AqgBIAAgECAIQZgBahDmCQ0KIAAoAiQNCiAIKAKkASEbIAwgBxD9CUEAIQcgDCgCbCEGIAwoAgAtAFcEf0GQgggFIAwoAmggDUEYbGoLIgcgBjYCCCAQKAIcKAIAIRULICANAyAAEPAIIgooAmwhBkEAIQ8gAi0AK0EBRgRAIAAoAgAgAhC6ByEPC0EBIAYgBkEBTBshDiACQQhqIRFBASELA0BBACALIA5GDQIaQQAhBgJAIAooAgAtAFcEf0GQgggFIAooAmggC0EYbGoLIgYtAAAiB0GtAUcEQCAHQfAARw0BIAYoAgwgFkcNASARIQcgBigCCCINIAIoAhRGDQYDQCAHKAIAIgZFDQIgBkEUaiEHIA0gBigCLEcNAAsMBgsgBigCECAPRg0FCyALQQFqIQsMAAsACyAIQgA3AuwBIAhCADcC5AEgCEIANwLcASAIQgA3AtQBIAggADYC0AFBACEbQQAhFSAcBEAgHCgCACEVIAhB0AFqIBwQ/goNAgtBfwshGEEBDAILQQAhBkEAIRAMBgsgACAAKAIoIhhBAWo2AiggABCVCSEGIAAQlQkhByAMQfYAIBggFRCKAxogDEEMIAgoApwBEPIIIQsgDEHhACAbIBUgBhDbCBogDEH/ACAYIAcQigMaIAxBgAEgGCAGIAcQ2wgaIAwgCxD4CBpBACEKIAwoAmwhDSAMKAIALQBXBH9BkIIIBSAMKAJoIAtBGGxqCyILIA02AgggACAGEJYJIAAgBxCWCUEACyEhAkAgAyAVQQBMcg0AQQAhBwJAIAIoAhwiC0HgAHFFIAIuASAiCUEASHINACAJIQYDQCAGQQBMDQEgCSACKAIEIAZBAWsiBkEMbGotAApB4ABxQQBHayEJDAALAAsgAi4BIiENAkAgC0HiAHFFDQAgDUEAIA1BAEobIQtBACEGA0AgBiALRg0BIAcgAigCBCAGQQxsai0ACkHiAHFBAEdqIQcgBkEBaiEGDAALAAsgFSANIAdrIgZGDQAgCCAVNgJIIAggBjYCRCAIIAFBCGo2AkAgAEHZtQEgCEFAaxCyAgwBCwJAIANFDQAgFSADKAIAIgZGDQAgCCAGNgI0IAggFTYCMCAAQd7JACAIQTBqELICDAELQQAhBgJAIBktACRBAXFFDQAgAC0AEg0AIAAoAnwNACAALQCXAQ0AIAAgACgCLEEBaiIdNgIsIAxBxwBBACAdEIoDGgsgI0ECRg0CIBkgACACQfEAQQBBf0EAIAhBvAFqIAhBuAFqEOIKIgtBAnRBCGqtEOwCIgYNAQtBACEGDAMLQQAhByALQQAgC0EAShshCiACQQhqIQsDQCAHIApGRQRAIAsoAgAhCyAAIAAoAixBAWoiDTYCLCAGIAdBAnRqIA02AgAgACAAKAIsIAsvATRqNgIsIAdBAWohByALQRRqIQsMAQsLIAAgACgCLEEBaiIHNgIsIAYgCkECdGogBzYCAAsgBQRAAkACQAJAIAItACtBAWsOAgABAgsgCCACKAIANgIgIABBgpYDIAhBIGoQsgIMBAsgAEHTK0EAELICDAMLIAAgBSgCABCmCQ0CIAEgCCgCvAEiJzYCMCAIQYQCaiEmIAgoArgBISggBSEfA0AgHyAoNgIsIB8gJzYCKCAfIBo2AiQgHyABNgIgAkAgHygCAEUNAEEAISIgCEEANgLYAiAIQgA3AtACIAhCADcCyAIgCEIANwLAAiAIIAE2ArwCIAggADYCuAIgHyETA0AgE0UNASATKAIAIgdFDQEgCEG4AmogBxD+Cg0FIAhBuAJqIBMoAgQQ3woNBSABKAIwIQ4gEygCACEKAkACQCABKAIYIgctABxBgAFxDQAgCigCAEEBRw0AIAooAggiCy0AAEGnAUcNACALLwEgQf//A0YNAQsgCEHQAWpBAEHoABDnFBogCCAONgKgAiAIQacBOgCEAiAIICY2AtwBIAhB8QA6ANABIAdBCGohBwJAA0AgBygCACIPBEACQCAPLQA2RQ0AIAooAgAiDSAPLwEyRw0AIA8oAiQiBwRAIBMoAgQiC0UNASAAIAsgByAOEPgKDQEgDy8BMiENC0EAIREDQCANIBFHBEAgCCAPKAIgIBFBAnRqKAIANgLYAQJAIA8oAgQgEUEBdGovAQAiB0H+/wNGBEAgDygCKCARQQR0aigCCCIWLQAAQfEARg0BIAggFjYC3AEgCEHQAWohFgwBCyAIIAc7AaQCIAggJjYC3AEgCEHQAWohFgtBACEHA0AgByANRg0DIAdBBHQhCyAHQQFqIQdBACAKIAtqKAIIIBYgDhD4CkEBSg0ACyARQQFqIREMAQsLIBMgDzYCHCAFIA8Q/wogE0YNAyATQQE6ABUMAwsgD0EUaiEHDAELCyATKAIcIQ8LIA8NAAJAAkAgIg0AIBMoAhANACAIQQA6AMABDAELIAggIkEBajYCEEEQIAhBwAFqQYaaAyAIQRBqEGkaC0EAIQIgCCAIQcABajYCACAAQe8zIAgQsgIMBgsgIkEBaiEiIBMoAhAhEwwACwALIB8oAhAiHw0ACwsCQCAhRQRAIAxBJCAYEPIIIREgDCgCbCEPDAELIBBFBEBBACEPQQAhEQwBCyAMQQwgCCgCnAEQ8gghDyAJQQBOBEAgDEHQACAJIBtqIBQQigMaCyAPIRELQQAhFiAaIQ1BACELA0AgCyACLgEiIgdORQRAAkAgAi4BICALRgRAIAxBzAAgDRDyCBoMAQsCQAJAAkAgAigCBCALQQxsaiIOLwEKIgdB4gBxBEAgFkEBaiEWIAdBIHEEQCANQQFrIQ0MBQsgB0HAAHEEQCAILQCUAUEBcUUNBSAMQcwAIA0Q8ggaDAULIAMNASAAIAIgDhCTCSANEIALDAQLIANFDQELQQAhByADKAIAIgpBACAKQQBKGyEKA0AgByAKRwRAIAMgB0EDdGooAgwgC0YNAyAHQQFqIQcMAQsLIAAgAiAOEJMJIA0QgAsMAgsgFUUEQCAAIAIgDhCTCSANEIALDAILIAsgFmshBwsgIUUEQCAMQd4AIBggByANENsIGgwBCyAQBEAgGiAbRg0BIAxB0QAgByAbaiANEIoDGgwBCyAAIBwgB0EEdGooAggiByANEIELIgogDUYNACAMQdAAQdEAIAcoAgRBgICAAnEbIAogDRCKAxoLIA1BAWohDSALQQFqIQsMAQsLIAAgACgCOEEBayILNgI4IAgtAJQBQQFxBEAgACAHQQFqEMMKIQcCQCAJQQBIBEAgDEHHAEF/IAcQigMaDAELAkAgIUUEQCAMQd4AIBggCSAHENsIGgwBCyAAIBwgCUEEdGooAgggBxD3CAsgDEEzIAcQ8gghFiAMQccAQX8gBxCKAxpBACEKIAwoAmwhDSAMKAIALQBXBH9BkIIIBSAMKAJoIBZBGGxqCyIKIA02AgggDEENIAcQ8ggaCyAMQdAAIBRBAWogB0EBaiINIAIuASRBAWsQ2wgaIAItABxB4ABxBEAgACANIAIQ7woLICNBAkcEQCAMIAIgDRD+CQsgACAgQf8AQQBBASACIAcgAi4BIkF/c2ogBCALEPAKIAAgByACLgEiQQFqEMQKCwJAICNBAkYNACACLQArQQFGBEAgDEHLAEEAIBIQigMaCwJAAkAgCUEATgRAAkAgIUUEQCAMQd4AIBggCSAUENsIGgwBCyAQDQAgHCAJQQR0aigCCCINLQAAQfkARgRAQQEhByACLQArQQFHDQMLIAAgDSAUEPcICwJAIAItACtBAUcEQCAMQTMgFBDyCCEKIAxB/wAgCCgCvAEgFCAeENsIGkEAIQcgDCgCbCENIAwoAgAtAFcEf0GQgggFIAwoAmggCkEYbGoLIgcgDTYCCAwBCyAMQTIgFCAMKAJsQQJqEIoDGgsgDEENIBQQ8ggaQQAhBwwCCyAXRSACLQArQQFHcUUEQEEAIQcgDEHLAEEAIBQQigMaDAILIAxB/wAgCCgCvAEgFCAeENsIGkEBIQcMAQsgDEH/ACAIKAK8ASAUIB4Q2wgaCyAAIB4gFBD8CiACLQAcQeAAcQRAIAAgFEEBaiACEO8KCyACLQArQQFGBEAgGSACELoHIQcgACACEOQKIAxBB0EBIAIuASJBAmogEiAHQXUQ9AgaIAwoAmwiB0EASgRAIAwoAmggB0EYbGpBFmtBAiAEIARBC0YbOwEACyAAKAJ4IgcgACAHG0EBOgAVDAELIAhBADYC0AEgACACIAYgCCgCvAEiDSAIKAK4ASIKIBJBACAJQX9zQR92IARB/wFxIAsgCEHQAWpBACAFEPEKIBktACFBwABxBEAgACACQQAgEkEAQQAQ8goLIAAgAiANIAogEiAGQQAgByAIKALQAQR/IAwoAuABRQVBAQsiFhD0CgsgHQRAIAxB1gAgHUEBEIoDGgsgIARAIAAgIEH/AEEAQQIgAiAaIAIuASJrQQJrIAQgCxDwCgsgDCALEI0KICFFBEAgDEEnIBggDxCKAxpBACEHIAwoAmwhAiAMKAIALQBXBH9BkIIIBSAMKAJoIBFBGGxqCyIHIAI2AgggDEH6ACAYEPIIGgwBCyAQRQ0AIAwgDxD4CBpBACEHIAwoAmwhAiAMKAIALQBXBH9BkIIIBSAMKAJoIBFBGGxqCyIHIAI2AggLAkAgAC0AEg0AIAAoAnwNACAAEOYKCyAdRQ0AIAwgHUGRsAEQ5woLIBkgARCkCCAZIBwQrgMgGSAFEOkIIBkgEBCfCCAZIAMQNCAGBEAgGSAGEDgLIAhB4AJqJAALrAIGAX8BfwF/AX8BfwF/IwBBEGsiBiQAIAEEfyABKAIABUEACyEIIAAoAgAhBwJAIAJFIANFcg0AAkAgAy0AAEGKAUYNACACKAIAIgQgAxD2CiIFRg0AIAYgBTYCBCAGIAQ2AgAgAEHuywAgBhCyAgwBC0EAIQQDQCAEIAIoAgAiBU5FBEACQCAAIAMgBCAFEPcKIgVFDQAgACABIAUQwgkiAUUEQEEAIQEMAQsgASgCAEEEdCABakEEayACIARBA3RqIglBCGoiBSgCADYCACAJQQA2AggLIARBAWohBAwBCwsgBy0AVw0AIAFFIAMtAABBigFHcg0AIAEgCEEEdGooAggiBCAFNgIcIAQgAzYCEEEAIQMLIAAgAxDHCSAHIAIQNCAGQRBqJAAgAQtVAQF/AkAgAUUNACABKAIAQQR0IAFqQQRrIgQgACgCACACKAIAIAI1AgQQyAgiATYCACADRQ0AIAEQ9AkgAC0A1AFBAkkNACAAIAQoAgAgAhDACRoLC3MEAX8BfwF/AX8CQCABRQ0AIAIoAgQiBUUNACABKAIAQQFrIQNBASEEAkAgBUEBRgRAIAIoAgBFDQELIAEgA0EGdGpBQGsgACgCACACEIQJNgIAQQIhBAsgASADQQZ0aiIGQS1qIgEgBi8ALSAEcjsAAAsLPwEBfyMAQRBrIgMkAAJAIAFFDQAgASgCACAAKAIAKAKAAUwNACADIAI2AgAgAEG/2QAgAxCyAgsgA0EQaiQAC5oDBgF/AX8BfwF/AX8BfyMAQRBrIgkkACAAKAIAIQgCQAJAAkACQCABIAZFcg0AIAkgBigCAAR/QervAQUgBigCBEUNAUHsgAILIgE2AgAgAEG92wAgCRCyAgwBCyAAIAEgAiADEL4JIgEEQCABKAIAQQFrIQcCQCAALQDUAUECSQ0AIAEgB0EGdGooAhAiCkUNAAJAIAMEQCADKAIADQELIAIhAwsgACAKIAMQwAkaCyAEKAIEBEAgASAHQQZ0aiAIIAQQhAk2AhQLAkAgBUUNACABIAdBBnRqIgAgBTYCHCAFLQAFQQhxRQ0AIAAiC0EtaiIAIAsvAC1BgMAAcjsAAAsgBkUEQCABIAdBBnRqQQA2AjQMBAsgBigCBARAIAEgB0EGdGoiACIMQS1qIgUgDC8ALUGACHI7AAAgACAGKAIENgI0DAQLIAEgB0EGdGogBigCADYCNAwDCyAGRQ0BCyAGKAIAIgEEQCAIIAEQoAgMAQsgBigCBCIGRQ0AIAggBhA0CyAIIAUQnwhBACEBCyAJQRBqJAAgAQtpAQF/IAIEQCAAIAEgAigCAEEBENUKIgNFBEAgACgCACACEKQIIAEPCyADQcgAaiACQQhqIAIoAgBBBnQQ5RQaIAAoAgAgAhA1IANBLGoiAiADLQAsIAMtAGxBwABxcjoAACADIQELIAELvSswAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF+IwBB0ABrIhMkACAAKAIAIR8CQCAAKAIkDQAgACABEKkJIghFDQAgACgCACAIKAI8EPwCIRcgACAIQYEBIAIgE0EkahDbCiEaIAEoAgBBAk4EQCACKAIAIRQLIAgtACshICAAIAgQmQkNACAAIAggGhDdCg0AIAAgACgCKCIRQQFqIiI2AiggCC0AHEGAAXEEQCAIEK8DIQ0LICIhBiARIQsgCEEIaiIYIQ4DQCAOKAIAIg4EQCAAIAZBAWoiBzYCKCAGIAsgDSAORhshCyASQQFqIRIgDkEUaiEOIAchBgwBCwsgBQRAIAUoAiwhIiAFKAIoIQsgACARNgIoCyABIAs2AjAgHyASIBIgCC4BImpBAnRqQQZqrRDsAiIORQRAQQAhDgwBC0EAIQYgDiAILgEiQQJ0aiIlIBJBAnRqQQRqQQEgEkEBaiIWEOcUIiYgFmpBADoAACAILgEiIgdBACAHQQBKGyEHA0AgBiAHRkUEQCAOIAZBAnRqQX82AgAgBkEBaiEGDAELCyATQgA3AjwgE0IANwJEIBNCADcCNCATIAU2AjAgEyABNgIsIBMgADYCKCATQYAENgJAIAAQ8AgiCUUNAEF/ITADQAJAAkAgAigCACAPSgRAIAIgD0EEdGoiBiIxQQhqIRsgBiI0QQxqIgwoAgAQjwkhECAURQRAIBNBKGogMSgCCBDfCg0FC0EAIQYgCC4BIiIHQQAgB0EAShshCgNAIAYgCkcEQAJAIAgoAgQgBkEMbGoiBy0AByAQRw0AIAcoAgAiGSA0KAIMEG0NACAILgEgIAZGBEAgMSgCCCEjQQEhJyAPITAMBQsgDUUgBy8BCiIHQQFxRXJFBEBBASEuDAULIAdB4ABxRQ0EIBMgGTYCECAAQY+VAyATQRBqELICDAcLIAZBAWohBgwBCwsgNCgCDCEGAkAgDQ0AIAYQjARFDQBByJUCIRkgMSgCCCEjQQEhJ0F/IQYgDyEwDAMLIBMgBjYCACAAQdvlACATELICIABBAToAEQwECyAnIC5qISggJyEMAkAgCC0AHEHgAHFFDQBBACEHQQAhBgNAIAchCgJ/AkAgCC4BIiAGSgRAIA4gBkECdGoiECgCAEEATg0BIAgoAgQgBkEMbGoiGS0ACkHgAHFFDQEgCiAIIBkQkwkgDiAMEOkKRQ0CGiAQQZ+NBjYCAEEBDAILQQAhB0EAIQYgCg0CDAMLIAoLIQcgBkEBaiEGDAALAAsgAUJ/QgAgCC0AK0EBRhs3AzggKEH/AXEiL0EARyAAIAggDiAvENwKIh5BAUpyIRkgBEEFRiEPIARBC0chG0EAIRADQAJAAkACQAJAAkACfwJAAkACQCAYKAIAIgcEQCAZIAcgDUZyDQEgBygCJCIGBEAgBiAOIAwQ6QoNAgtBACEGA0AgBiAHLwEyTw0JAn8gBygCBCAGQQF0ai4BACIKQQBOBEAgDiAKQf//A3FBAnRqKAIAQX9zQR92DAELIAcoAiggBkEEdGooAgggDiAMEOkKCyEKIAZBAWohBiAKRQ0ACyAAIAAoAixBAWoiBiAHLwE0ajYCLCAbDQdBASAPIActADZBBUYbIQ8MBwsgEyAPNgIgIAAgACgCLEEBaiIGNgIsICUgEEECdGoiKSAGNgIAIA8EQCAmQQEgFhDnFBoLIAAtABJFBEAgCSAJLwGYAUEQcjsBmAELQQAhDCAAIBogHnJBAEcgFxC1CUEAIRdBACEYQQAhEEEAIQogCC0AKyIGQQFHBEAgACgCLCIHQQFqIQwCfyAeIBogLnJyRQRAIAguASIhGSAMDAELIAdBAmohECAMIAguASIiGWoLIQcgKSgCACEKIAAgB0EBaiIXIAcgKEH/AXEgGnIgHnIiGBsiByAZajYCLCAXIAwgGBshFyAHQQFqIRgLAkACQAJ/ICBBAkcEQEEAIQdBACEbQQAiGSAURQ0BGgwDCyAAKAL8ASEHIAAgCCgCADYC/AFBACEbIBQEQCAAIRkMAgsgACAIIAMgCxDeCiAACyEZIBNBKGogAxDfCgRAIAchMgwICyAILQArIQZBASEbCyAHITILIAZB/wFxQQFGBEAgACgCCCEKIAAoAgAiDCAIELoHIRcgASgCMCENIAguASIhBiAAIAAoAigiEkEBajYCKCAKQfYAIBIgBkECaiIFEIoDIRQgACAAKAIsIg8gBWoiBjYCLCAPQQFqIQsCfwJAAkACQCABKAIAQQJOBEACfyAILQAcQYABcUUEQCAjBEBBACENIAwgI0EAEKQJDAILQQAhDSAAQcsAQQBBABChCQwBCyAOIAgQrwMiDSgCBC4BACIHQQJ0aigCACIGQQBOBEAgDCACIAZBBHRqKAIIQQAQpAkMAQsgACAHEOoKCyEGIAAoAgAgBhDBCSEQQQAhBgNAIAYgCC4BIk4NAgJAIA4gBkECdGooAgAiB0EATgRAIAwgAiAHQQR0aigCCEEAEKQJIQcMAQsgACAGEOoKIgdFBEBBACEHDAELIAdBAToAAgsgBkEBaiEGIAAgECAHEMIJIRAMAAsACyAAIAZBAmoiGjYCLCAAIAEgA0EAQQBBAEEEQQAQqwoiDEUNCiAGQQFqIRggD0EDaiEQQQAhBgNAIAYgCC4BIk5FBEACQCAOIAZBAnRqKAIAIgdBAE4EQCAAIAIgB0EEdGooAgggBiAQahD3CAwBCyAKQbABIA0gBiAGIBBqENsIGiAKKAJsIgdBAEwNACAKKAJoIAdBGGxqQRZrQQE7AQALIAZBAWohBgwBCwsCQCAILQAcQYABcUUEQCAKQYcBIA0gCxCKAxogD0ECaiEGICMEQCAAICMgBhD3CAwCCyAKQYcBIA0gBhCKAxoMAQsgCkGwASANIAgQrwMoAgQuAQAiBiALENsIGiAKQdEAIAYgEGogD0ECahCKAxoLIAwtAC4NAiAAKAJ4IgYgACAGG0EBOgAUIApB4QAgCyAFIBgQ2wgaIApB/wAgEiAaEIoDGiAKQYABIBIgGCAaENsIGgwBCyAAIBIgDSAQIAEgAxDrCiAMIBAQrgNBACEMCyABKAIAQQFGBEAgDBC0CgtBACEGIAVBACAFQQBKGyEHIApBJCASEPIIIRQDQCAGIAdGBEBBAQwDBSAKQd4AIBIgBiAGIAtqENsIGiAGQQFqIQYMAQsACwALIAogFBCsCiAKQfoAIA0Q8ggaQQALIQcgACAIEOQKIApBB0EAIAUgCyAXQXUQ9AgaIAooAmwiBkEASgRAIAooAmggBkEYbGpBFmtBAiAEIARBC0YbOwEACyAAKAJ4IgYgACAGG0EBOgAVIAcEQCAKQScgEiAUQQFqEIoDGkEAIQAgCigCbCEGIAooAgAtAFcEf0GQgggFIAooAmggFEEYbGoLIgAgBjYCCCAKQfoAIBJBABCKAxoMBwsgDBC0CgwGCyAAIAAoAjhBAWsiITYCOAJAIB8tACRBAXFFDQAgACgCfA0AIAAtABIgBXINACAALQCXAQ0AIAAgACgCLEEBaiIqNgIsIAlBxwBBACAqEIoDGgsCQAJAAkACQAJAAkACQAJAIBtFDQAgCC0AHEGAAXENAEEAIQcgCUHLAEEAIAogDBDbCBogACAAKAIoIhZBAWo2AiggCUH2ACAWQQAgChDbCCErDAELIAAgFCAAKAIsIgYgDQR/IA0vATIFQQALIi3BIh1qIhVqQQFqIhw2AiwgBkEBaiEHIAUNASAUIB1qISxBACEGICBBAkYEQCAILgEiIQYLIAAgACgCKCIWQQFqNgIoIAYgLGohBiANBEAgCUHLAEEAIAcgFRDbCBoLIAlB9gAgFiAGEIoDISsCQCANRQ0AIAAgDRC8CiIVRQ0AIBUgBjsBCCAJIBVBeBCqCgsgGw0AIAAgFiANIAIgASADEOsKIBYgCyAgQQJGGyELCyAURQ0CIC3BIR0MAQtBACEWIBRFDQILQQEhFCAAKAJ4IgYgACAGG0EBOgAUQQAhFUEBISwgByEcDAgLIAVFDQELIAAgAyAhQRAQwgpBACEsQQEhFQwBC0EEIQYCQCAPIAAtABIgGnIgHiAoQf8BcXJycg0AIAMEQCADLQAGQcAAcQ0BC0EMIQYLIAAgASADQQBBAEEAIAYgIhCrCiIkRQ0GQQEhFSAkLQAwQQFxISwgJCkCFCI1QiCIpyEPIDWnITMgJC0ALiIGQQFGDQAgACgCeCIUIAAgFBtBAToAFEECIRUgBkECRwRAIAYhFQwBCyALIA9GIDVCAFNyDQAgJiAPIBFrai0AAEVBAXQhFQsCQAJAIAgtABxBgAFxBEBBACEGIC3BIh1BACAdQQBKGyEKA0AgBiAKRg0CIAkgCCALIA0oAgQgBkEBdGouAQAgBiAHahCSCSAGQQFqIQYMAAsACyAJQYcBIAsgDBCKAxogFUUEQCAAIAAoAixBAWoiBjYCLCApIAY2AgAgCUGAASAWIAogDBDbCBoMAgsgK0UNBCAJICsQrAoMBAsgFQRAQQAhFCArRQ0DIAkgKxCsCgwDCyAJQeEAIAcgHSAcIB8gDRDhCiAdEPQIGiAJQYoBIBYgHCAHIB0Q/wIaC0EAIRVBAAwDCyAAIAAoAixBAWoiBiAHLwE0ajYCLAwFCyAHIRwMAgtBAAshFEEAIR0LQQAhKQJAIAUEQCAhIREMAQsgFUECRyAbcQRAICQQtAoLAkAgIEECRg0AAn9BACIGIBVFDQAaIDNBAE4EQCAmIDMgEWtqQQA6AAALIA9BAE4EQCAmIA8gEWtqQQA6AAALQQAgFUECRyASIA9BH3VBf3NqQQBMcg0AGiAJQQ8Q8QgLIQYgACAIQfEAQQAgESAmIBNBHGogE0EYahDiChogBkUNACAJIAYQ4woLIBUEQCALIDNGIAsgD0ZyRQRAIAlBHCALICEgHCAdEP8CGgsgISERIBVBAUcEQCAAIAAoAjhBAWsiETYCOAsgCUEyIBwgDCANGyAhEIoDGgwBCyANRSAUQQFzcUUEQCAAIAAoAjhBAWsiETYCOCAJQSQgFiAhEIoDGiAJKAJsISkgFARAICBBAkYNAiANBEBBACEGIC3BIhJBACASQQBKGyEKA0AgBiAKRkUEQCAJQd4AIBYgBiAGIAdqENsIGiAGQQFqIQYMAQsLIAlBHCALIBEgByASEP8CGgwDCyAJQYcBIBYgDBCKAxogCUEfIAsgESAMENsIGgwCCyAJQYYBIBYgHBCKAxogCUEcIAsgESAcQQAQ/wIaDAELIAlBJCAWICEQigMaIAAgACgCOEEBayIRNgI4IAlBhwEgFiAMEIoDISkgCUEfIAsgESAMENsIGgsgJwRAAkAgGwRAIAAgIyAXEPcIDAELIAlB3gAgFiAwIBcQ2wgaCyAJQQ0gFxDyCBoLAkAgHiAuciAackUNAEEAIQYgHgRAIAAgCBDsCiEGCyAAIBogAkEAQQMgCCAEEO0KIAZyIg9Bf0YhEkEAIQYDQAJAAkAgCC4BIiAGSgRAIAgoAgQgBkEMbGovAQohCiAIIAbBEO4KIBBqIQcCQCASDQAgBkEfTQRAIA8gBnZBAXEgCkEBcXINAQwDCyAKQQFxRQ0CCyAJIAggCyAGIAcQkgkMAgsgDSAncg0DIAlB0AAgDCAXEIoDGgwDCyAJQcsAQQAgBxCKAxoLIAZBAWohBgwACwALIC3BIRIgACAaIAJBAUEBIAggBBDtCiEbICBBAkYhDyAYIQdBACEGA0AgBiAILgEiIgpORQRAAkAgCC4BICAGRgRAIAlBywBBACAHEIoDGgwBCyAIKAIEIAZBDGxqLwEKIhBB4ABxBEAgEEEadEEfdSAHaiEHDAELIA4gBkECdGooAgAiEEEATgRAIBQEQCAJQd4AIBYgECAKIBIgDxtqIAcQ2wgaDAILIAAgAiAQQQR0aigCCCAHEPcIDAELIBsgBnZBAXEgEy0AJEEBcUUgBkEfS3JyBEAgCSAIIAsgBiAHEJIJQQAhLAwBCyAJQcsAQQAgBxCKAxoLIAdBAWohByAGQQFqIQYMAQsLIAgtABxB4ABxBEAgACAYIAgQ7woLAkACQCATLQAkQQFxRQ0AIAkgCCAYEP4JIAAgGkGBASACQQEgCCAMIAQgERDwCiAgQQJGDQECQCANBEAgCUEcIAsgESAcIB0Q/wIaDAELIAlBHyALIBEgDBDbCBoLQQAhBiAYIQcDQCAGIAguASJORQRAAkAgCCgCBCAGQQxsai8BCiIKQeAAcQRAIApBGnRBH3UgB2ohBwwBCyAOIAZBAnRqKAIAQQBODQAgBiAILgEgRg0AIAkgCCALIAYgBxCSCQsgB0EBaiEHIAZBAWohBgwBCwsgCC0AHEHgAHFFDQAgACAYIAgQ7woLICBBAkYNACAAIAggJSALICIgFyAMIChB/wFxIARB/wFxIBEgE0EgaiAOQQAQ8QoCQCATKAIgIChB/wFxckUNACANBEAgCUEcIAsgESAcIB0Q/wIaDAELIAlBHyALIBEgDBDbCBoLIB4EQCAAIAggDEEAIA4gLxDyCgsgACAIIAsgIiAlQX8Q8wogLARAIAlBjwEgCxDyCBoLIAlBggEgC0EEQQRBxAAgKEH/AXEbIB5BAUobIBcQ2wgaAkAgFUECRw0AIAkoAmwiBkEATA0AIAkoAmggBkEYbGpBFmtBAjsBAAsgAC0AEkUEQCAJIAhBexCqCgsgHgRAIAAgCEEAIBcgDiAvEPIKIAAgCCALICIgFyAlQQZBBCAVQQJGG0EAQQAQ9AogACAIIAIgDCAOIC8Q9QoMAQsgACAIIAsgIiAXICVBBkEEIBVBAkYbQQBBABD0CgsgKgRAIAlB1gAgKkEBEIoDGgsgGgRAIAAgGkGBASACQQIgCCAMIAQgERDwCgsCQAJAAkAgFUEBaw4CAgABCyAJIBEQjQogJBC0CgwBCyAJIBEQjQogCUEnIBYgKRCKAxoLIAkgIRCNCgJAIAAtABINACAFIAAoAnxyDQAgABDmCgsgKkUNACAJICpBk7EBEOcKCyAZRQ0HIBkgMjYC/AEMBwsgBkUNACAQQQFqIQoMAQtBACEGICYgEEEBaiIKakEAOgAACyAlIBBBAnRqIAY2AgAgB0EUaiEYIAohEAwACwALIA4gBkECdGogDzYCAAsCQAJAIABBFyAIKAIAIBkgHygCECAXQQR0aigCABD5CEEBaw4CAwABCyAOIAZBAnRqQX82AgALIA9BAWohDwwACwALIB8gDhAyIB8gARCkCCAfIAIQrgMgHyADEDMgE0HQAGokAAvYDxkBfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfyMAQTBrIgkkACAJQQA2AiwgCUEANgIoIAAoAgAhDwJAIAAoAiQNACAAIAEQqQkiBEUNACAAIARBgAFBAEEAENsKIRggBC0AKyEQQQEhCyAYRQRAIAAgBEEAQQAQ3ApBAEchCwsgACAEEJkJDQAgACAEIBgQ3QoNACAAQQkgBCgCAEEAIA8oAhAgDyAEKAI8EPwCIgZBBHRqKAIAEPkIIhFBAUYNACAAIAAoAigiDkEBaiISNgIoIAEgDjYCMCASIQcgBEEIaiIKIQUDQCAFKAIAIgUEQCAAIAdBAWoiBzYCKCAIQQFqIQggBUEUaiEFDAELC0EAIQUgEEECRgRAIAAoAvwBIRogACAEKAIANgL8ASAAIRYLAkAgABDwCCIDRQ0AIAAtABJFBEAgAyADLwGYAUEQcjsBmAELIAAgCyAGELUJIBBBAkYEQCAAIAQgAiAOEN4KIAkgDjYCLCAJIA42AigLIAlBADYCICAJQgA3AxggCUIANwMQIAlCADcDCCAJIAE2AgQgCSAANgIAIAkgAhDfCg0AAkAgDy0AJEEBcUUNACAALQASDQAgACgCfA0AIAAtAJcBDQAgACAAKAIsQQFqIgw2AiwgA0HHAEEAIAwQigMaCwJAAkAgAiARciALcg0AIAQtACtBAUYNACAPKAKIAg0AIAQtABxBgAFxRQRAIANBkQEgBCgCFCAGIAxBfyAMGyAEKAIAQX8Q9AgaCyAMQX8gDBshCANAIAooAgAiBQRAAkACQCAFLwA3QQNxQQJHDQAgBC0AHEGAAXFFDQAgA0GRASAFKAIsIAYgCBDbCBoMAQsgA0GRASAFKAIsIAYQigMaCyAFQRRqIQoMAQVBACEHDAMLAAsAC0EUQRRBHCALGyAJLQAYQcAAcUEGdhshBwJ/IAQtABxBgAFxRQRAQQEhDSAAIAAoAixBAWoiFzYCLEEAIQsgA0HLAEEAIBcQigMaQQAMAQsgACAAKAIsIgUgBBCvAyILLgEyIg1qNgIsIAAgACgCKCITQQFqNgIoIANB9gAgEyANEIoDIRQgACALEOAKIAVBAWoLIQZBACEFIAAgASACQQBBAEEAIAcgEhCrCiIRRQ0BIBEpAhQhGSARLQAuIhJBAUcEQCAAKAJ4IgcgACAHG0EBOgAUCyARLQAwQQFxBEAgA0GPASAOEPIIGgsgDARAIANB1gAgDEEBEIoDGgsgGUIgiKchGwJAAkACQAJAAkACQAJAAkACQAJAAkACQCALBEBBACEHIA1BACANQQBKGyEKA0AgByAKRkUEQCADIAQgDiALKAIEIAdBAXRqLgEAIAYgB2oQkgkgB0EBaiEHDAELCyASRQ0CIAYhCgwBC0EBIRUgACAAKAIsQQFqIgo2AiwgAyAEIA5BfyAKEJIJIBJFDQMLIA8gCEECaq0Q7AIiB0UEQCARELQKDA0LIAdBASAIQQFqIggQ5xQiBSAIakEAOgAAIBmnIghBAE4EQCAFIAggDmtqQQA6AAALIBlCAFkEQCAFIBsgDmtqQQA6AAALIBQEQCADIBQQrAoLIAAgACgCOEEBayIFNgI4IBBBAkcNASANIRUMBQsgACAAKAIsQQFqIgo2AiwgA0HhACAGIA0gCiAAKAIAIAsQ4QogDRD0CBogA0GKASATIAogBiANEP8CGgwCC0EAIQggEkECRwRAQQAhBiANIRVBACEUDAMLQQAhBkEBIQggA0EPEPEIIRQgDSEVDAILIANBnAEgFyAKEIoDGgsgERC0CkEBIQZBACEIQQAhB0EAIRRBACENIBBBAkYNAgsgACAEQfEAQQggDiAHIAlBLGogCUEoahDiChogCARAIAMgFBDjCgsgByEIIAUhDSAGDQELQQAhBiAELQArQQFGBEBBACEQDAMLIAcgCSgCLCIIIA5rai0AAARAIANBHCAIIAUgCiAVEP8CGgtBACEQDAELAkAgCwRAIANBJCATEPIIIQZBASEQIAQtACtBAUYEQCADQd4AIBNBACAKENsIGgwCCyADQYYBIBMgChCKAxoMAQtBASEQIANBLiAXQQAgChDbCCEGCyAIIQcgDSEFCyAELQArQQFHDQELIA8gBBC6ByEIIAAgBBDkCiAAKAJ4IgQgACAEG0EBOgAVAkAgEkEBRw0AIANB+gAgDhDyCBogACgCeA0AIABBADoAFAsgA0EHQQBBASAKIAhBdRD0CBogAygCbCIEQQBMDQEgAygCaCAEQRhsakEWa0ECOwEADAELIAAgBCAYIAkoAiwgCSgCKCAKIBUgAC0AEkVBCyASIBsQ5QoLIBBFBEAgAyAFEI0KIBEQtAoMAQsgCwRAIANBJyATIAZBAWoQigMaQQAhBCADKAJsIQUgAygCAC0AVwR/QZCCCAUgAygCaCAGQRhsagsiBCAFNgIIDAELIAMgBhD4CBpBACEEIAMoAmwhBSADKAIALQBXBH9BkIIIBSADKAJoIAZBGGxqCyIEIAU2AggLAkAgAC0AEg0AIAAoAnwNACAAEOYKCyAMBEAgAyAMQfywARDnCgsgByEFCyAWRQ0AIBYgGjYC/AELIA8gARCkCCAPIAIQMyAFBEAgDyAFEDgLIAlBMGokAAtcAgF/AX8CQCAARQ0AIAAgACgCAEEBa0EEdGoiAyIEQRBqIAFBACABQX9HGyIAOgAAIAJBf0YNACADQRFqIgEgAy8AEUEgcjsAACAAIAJGDQAgBCAAQQJyOgAQCwu1AgcBfwF/AX8BfwF/AX8BfyMAQSBrIgQkACAEIAM2AhwgBCACNgIYIAQgATYCFAJAA0AgB0EDRg0BIARBFGogB0ECdGooAgAiCkUNASAKKAIEIQhBACEGAkADQCAGQQdGDQECQCAGQQNsIglBgMQEai0AASAIRgRAIAooAgAgCUGAxARqLQAAQdDDBGogCBBuRQ0BCyAGQQFqIQYMAQsLIAUgCUGAxARqLQACciEFIAdBAWohBwwBCwsgBUGAAXIhBQsgBUGAAXEgBUEhcUEhRnJFIAVBOHFBIEdxRQRAIAQgAzYCECAEIAE2AgAgBEEAIghByp8DaiIGQcufAyIJIAMbNgIMIAQgAjYCCCAEQcqfA0HLnwMgAhs2AgQgAEGM2gEgBBCyAkEBIQULIARBIGokACAFC98BBwF/AX8BfwF/AX8BfwF/AkAgAEUNACAAKAIAIgNBAkgNACAAQQhqIQUgAyEBA0AgBSABQQFrIgZBBnRqIAFBBnQgBWpB3ABrLQAAIgQ6ACQgBCACQf8BcXIhAiABQQJLIQQgBiEBIAQNAAsgAEEAOgAsIAJBEHFFDQADQAJAIAMiAUECSARAQQEhAQwBCyAAIAFBAWsiA0EGdGotACxBEHFFDQELCyABQQJrIQEDQCAAIAFBBnRqIgdBLGoiAiAHLQAsQcAAcjoAACABQQBKIQIgAUEBayEBIAINAAsLC1IBAX8DQCABIgNBAWohASADLQAAQcCkA2otAABBAXENAAsgAiADayEBA0AgAyABIgJBAWsiAWotAABBwKQDai0AAEEBcQ0ACyAAIAMgAqwQyAgLPwMBfwF/AX9BASEDAkADQCACIAEoAgBODQEgAkEEdCEEIAJBAWohAiAAIAEgBGooAggQygkNAAtBACEDCyADC5wCAgF/AX8CQANAIAAtAAAhAQNAAkACfwJAAkACQAJAAkACQAJAAkAgAUH/AXEiAUGnAWsOAwEHAgALAkAgAUGxAWsOAgYFAAsgAUEkRg0DIAFBigFHDQYgACgCFCgCHEEIagwHCyAAKAIsIQIMAQsgACgCLCICRQ0EC0HEACEBIAAuASAiAEEASA0IIAIuASIgAEwNCCACKAIEIABBDGxqLQAFIQEMCAsgACgCCEEAEO0IIQEMBwsgACgCDCgCFCgCHCAALgEgQQR0akEIagwCCyAAKAIUQQhqDAELIAAoAgRBgMAQcUUNASAAQQxqCyIAKAIAIQAMAgsgAUGwAUYEQCAALQACIgFBsAFHDQELCwsgAC0AASEBCyABwAtcAQF/AkAgAUUNACABKAIgIgEoAgBBAEwNACAAKAIIIAEoAiQQ/QkgACgCCCIAKAJsIQIgACgCAC0AVwR/QZCCCAUgACgCaCABKAIgQRhsakEYawsiASACNgIICwvZowE7AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfwF/AX8BfwF/AX8BfyMAQdADayIFJAAgACgCACERQQEhAyAAEPAIIQkCQCABRQ0AIAAoAiQNACAAQRVBAEEAQQAQ+QgNACACLQAAQQZNBEAgASgCMCIDBEAgAEE7IAMQkAoaIAFBADYCMAsgASABKAIEQf7//31xQYCAgAJyNgIECyAAIAFBABCRCkEBIQMCQAJAIAAoAiQNACABKAIEIgtBgICABHEEQCABKAIgIgRBCGogBBCSCgRAIAQoAhQiAUUEQCAEKAIYKAIAIQELIAUgATYCoAIgAEHP5gAgBUGgAmoQsgIMAgsgASALQf///3txNgIECyACLQAAQQlGBEAgACABEJMKCwJAAkAgASgCREUNACABKAI0DQAgAS0ABkEQcQ0AIAAtANQBQQFLDQAgABDwCCEIIAEoAiwhDiABKAIoIRAgASgCJCESIAEoAiAhDCAAKAIAIQogBUEANgKwAiABKAJEIQcgASgCBCEXIApCwAAQxQIiDUUEQCAKQQcQnAIaDAILIAEiIEEgaiEPIAVCADcCjAMgBUIANwKEAyAFIAA2AvgCIAVBAUE8ajYCgAMgBUE+NgL8AiAFQfgCaiABELEJGiABKAIEIgNBCHFFBEAgBUEANgKAAyAFQT82AvwCIAVB+AJqIAEoAjAQswkaIAEoAgQhAwsgIEIANwIgICBCADcCKCABIANB9/+/f3FBgIDAAHI2AgRBACEDAkAgACAAQQAgBygCCEEBEJcKIAcoAgxBARCXCiIYRQ0AIAEoAjAiBEUNACAEKAIAIgYgGCgCACILSg0AIBggBjYCACAYIARBfxCYCkUEQCAKIAEoAjAQrgMgAUEANgIwCyAYIAs2AgALIAcgACgCKCIENgIwIAAgBEEEajYCKCAAIAcgDCABKAIcIA0gBUGwAmoQmQogACAHIAwgASgCMCANIAVBsAJqEJkKIAUoArACIgQEQCAEKAIAIQMLIAcgAzYCTCAFIAAgACAEIAcoAghBABCXCiAHKAIMQQAQlwoiBDYCsAIgByEDA0AgAwRAIAMoAkgoAhQhBgJAIAMoAiwtAAZBEHEEQCAAIAcgDCAGIA0gBUGwAmoQmQogBSgCsAIiBAR/IAQoAgAFQQALIQYgA0EBOgBgIAMgBjYCUAwBCyADIAQEfyAEKAIABUEACyILNgJQIAUgACAEIAZBABCXCiIENgKwAgsgAygCKCIGBEAgBSAAIAQgCiAGQQAQpAkQwgkiBDYCsAILIAMgACgCLCIGQQFqIgs2AjQgACAGQQJqIgY2AiwgAyAGNgI4IAhBywBBACALEIoDGiADKAIkIQMMAQsLQQAhCyAERQRAIApBmwFB/NYCEMgJIQMgACgCACADEMEJIQQLIAAgBCAMIBIgECAOIBhBAEEAEMUJIQMgICAAQQBBAEEAEL4JIgQ2AiACQAJAIAQEQCAEIAM2AhwgBCIuQS1qIgQgLi8ALUEIcjsAACAAICAoAiAQmgogAyADKAIEQcCAgMAAcjYCBCAAIANBwAAQ/AkhBCADIAMoAgQgF0EIcXI2AgQgBEUNASANIARBwAAQ5RQiBiAGKAIcQYCAAXI2AhwgICgCICAGNgIYIAVBgANqIgtCADcDACAFQQA2ApADIAVCADcDiAMgBUEBIgZBP2o2AoADIAVCADcD+AIgBUHBADYChAMgBUHCADYC/AIgBUH4AmogAxCxCRpBASELDAILIAogAxCfCEEBIQsLIA0hBAsgCi0AVyEIIABBwwAgBBCQChpBASEDQQAhBiALRSAIQf8BcXINAgsgASgCICEEIAEoAgQhAyAFQbACakEEckEAQSQQ5xQaIAUgASgCMDYCsAIgA0EDdkEBcSESIAUiKkG8A2ohECABIi9BB2ohDiARIjBB0QBqIRhBACEHA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABKAI0IgZFBEAgByAEKAIATg0CIAQgB0EGdCIPaiIIKAIYIQ0gCCgCHCEMAkAgCCIkQSxqIgYtAAAiA0HIAHFFDQAgASgCJCAIIjFBMGoiCigCACADQcAAcRCeCkUNACAwLQBRQSBxDQACQCAkLQAsIgtBCHFFDQAgC0EQcQRAICQgC0H3AXEiCzoALAwBCyAkIAtB1wFxOgAsIAEoAiQgMSgCMEEAEJ8KICQtACwhCwsgByEDIAtBwABxRQ0AA0AgA0EBaiIDIAQoAgAiBkgEQCAEIANBBnRqIgoiK0EsaiILLQAAIgZBEHFFDQEgBkEIcQRAICsgBkHvAXE6ACwMAgUgKyAGQc8BcToALCABKAIkIAooAjBBARCfCgwCCwALCwNAIAZBAEwNASAEIAZBAWsiBkEGdGoiMkEsaiIDIDItACwiA0G/AXE6AAAgA0EQcUUNAAsLIAxFDQsgDCgCHCgCACIDIA0uASIiBkcEQCANKAIAIQEgBSADNgIIIAUgATYCBCAFIAY2AgAgAEH5vAEgBRCyAgwOCyAILQAuQQFxBEAgCCgCRC0AEkUNDAsgDCgCBCIDQQhxDQsCQCAMKAIwIgZFDQACQCABKAIwRQRAIAQoAgBBAkgNAQsgDCgCPCADQYCAgMAAcXINACAvLQAHQQhxDQAgES0AUkEEcQ0AIABBOyAGEJAKGiAMQQA2AjAMAQsgBw0AIAEtAAZBBHFFDQBBACEDIAQoAgBBAUYNDSAELQBsQSJxDQ0LIAAoAgAiAy0AUEEBcQ0KIAEoAkQNCiABKAIgIgYgD2oiCyIoQRxqIggoAgAiBCgCRA0KIAAoAvwBIQ0gCygCMCEXIAQoAiAhCiAEKAI8IgxFDQEgASgCPA0KIAwoAhANCiABKAIEIhVBgAJxDQoMCQsgACgCACENIAUgAigCGDYC8AIgBSACKQIQNwPoAiAFIAIpAgg3A+ACIAUgAikCADcD2AIgABDwCCERIAUtANgCIgpBDEYEQCARQfYAIAUoAtwCIAEoAhwoAgAQigMaIAVBDjoA2AJBDiEKCwJAIAEoAgQiB0GACHFFDQAgASgCPCIIRSELQQEhCSABIQQDQCAEKAJEDQEgBCgCNCIDBEAgCSALaiEJIAMhBAwBCwsgBSAJNgKQAiAFQQAiA0HpnwNBz+EBIAlBAUYbajYClAJBACEMIABBAEGA0wAgBUGQAmoQoAoDQCAERQ0IIAAgBEF/QQBBACAFQdgCakEBQQEQoQogCA0HIAQgCTsBAiAEKAI4IQQMAAsACyAHQYDAAHFFDQIgASEDA0AgA0UNAyADLQAFQSBxBEAgAygCNCEDDAELCyABKAJEBEAgAEGM0ABBABCyAgwECyAAKAIIIQkgASgCICEEIAEoAhwoAgAhB0EAIQMgAEEhQQBBAEEAEPkIDQMgACAAKAI4QQFrIgo2AjggAUHAAjsBAiAAIAEgChCiCiABKAI8IRggAUEANgI8IAEoAgwhECABKAIIIQ4gAUIANwIIIAQoAgAiBkEAIAZBAEobIQYgASgCMCELA0ACQCADIAZGBH9BAAUgBCADQQZ0ai0ALUHAAHFFDQEgBCADQQZ0aigCMAshDCAAIAAoAigiCEEBaiIDNgIoAn8gAS0AAEGGAUYEQCAAIAhBAmo2AihBBkEFIAsbDAELQQAhA0EHQQggCxsLIQQgBUIANwOIAyAFQgA3A4ADIAUgCDYC/AIgBSAEOgD4AiAAIAAoAixBAWoiDzYCLCAJQfkAIAwgDyAHENsIGgJAIAsEQCAAIAEQowohBCAJQfYAIAggCygCAEECakEAIARBeBD0CBogBSALNgKQAwwBCyAJQfYAIAggBxCKAxoLIAlBu6IBQQAQ8wgCQCADRQRAIAEoAgQhBgwBCyABIAlB9gAgA0EAEIoDNgIUIAEgASgCBEEgciIGNgIECyABQQA2AjAgASEEAkADQCAEIQMgBkEIcQRAIABB2a8BQQAQsgIMAgsgA0GHAToAACADKAI0IgQoAgQiBkGAwABxDQALIARBADYCOCAAQQFBkusBQQAQoAogACAEIAVB+AJqEOYJIQYgBCABNgI4IAYNACAJQSQgCCAKEIoDIQcgCUGIASAMEPIIGgJAIAsEQCAJQd4AIAggCygCAEEBaiAPENsIGgwBCyAJQYYBIAggDxCKAxoLIAlBggEgCBDyCBogACAAKAI4QQFrIgY2AjggCSAQIAYQpAogACABIAxBAEEAIAVB2AJqIAYgChChCiAOBEAgCUE9IA4gChCKAxoLIAkgBhCNCiADQQA2AjQgAEEBQcHsAUEAEKAKIAAgASAFQfgCahDmCRogAyAENgI0IAkgBxD4CBogCSAKEI0KCyAAKAIAIAEoAjAQrgMgASAYNgI8IAEgCzYCMAwFCyADQQFqIQMMAAsACyABKAIEIRUMBwsCQCABKAIkIgNFDQAgAy0AAEEsRw0AIBEtAFFBgAFxDQAgBSAANgL4AiAFIAAoAgBB1wBqNgL8AgNAIAVBADYCkAMgBUIANwOAAyAFQQA2AogDIAUCfwJAIAEoAiAiBkUNACAGKAIAQQBMDQBBAyIDIAYtACxBwABxDQEaC0EBCyIDNgKMAyAFQfgCaiABKAIkEKUKIAUoAoADBEAgBUIANwK8AyAFIAA2ArADIAVBADYCxAMgBUEBIgNBPGo2ArgDIAVBxAA2ArQDIAUgBUH4Amo2AsgDIAVBsANqIAEoAiQQsgkaIAUoAvgCKAIAIAUoApADEDILIAUoAoQDDQALCwJAIBEvAVBBgQRxDQAgAS0ABEEIcUUNACABKAIcIgMoAgBBAUcNACABKAIkDQAgASgCLA0AIAEoAigNACABKAIwDQAgAygCCCIDLQAAQagBRw0AQQAhBiADKAIIQYQzEGwNACADKAIUDQAgASgCICIIKAIAQQFHDQAgAy0AB0EBcQ0AIAgoAhwiBkUNACAGKAI0RQ0AIAYtAAdBBHENACAGIQsDQCALLQAAQYcBRwRAIAsoAjQNAgsgCygCJA0BIAsoAjwNASALLQAEQQhxDQEgCygCNCILDQALIAAoAgAhByAIQQA2AhwgByAIEKQIIAEgACgCAELIABDFAjYCIEEAIQsDQAJAIAshCCAGRQ0AIAZBADsBAiAGKAI0IQQgBkIANwI0IAYgBigCBEH3fXFBCHI2AgQgAEE7IAYoAhwQkAoaIAMhCyAEBEAgByADQQAQpAkhCwsgBiAAKAIAIAsQwQk2AhwgACAAQYoBQQBBABChCSILIAYQxAkgBCEGIAhFDQEgAEHqACALIAgQoQkhCwwBCwsgASgCHCAINgIIIAEgASgCBEF3cTYCBCARLQBXDQsgASgCICEECyAFIiVBgANqIRBBACEHA0ACQAJAIAQoAgAgB0oEQAJAIAQgB0EGdGoiCyIzQThqIgYpAwBCAFINACALKAIQIgNFDQAgAEEUIANB6Z8DIAsoAgwQ+QgaCyALIjRBHGoiAygCACIKRQ0CIAsiKUEgaiINKAIADQIgACABEKcKIAAoAtwBajYC3AECQCARKAJQIghBgCBxDQAgCy0ALkEBcQRAIAsoAkQiDC0AEkUNASAMKAIAQQFKDQELIAAgCiABKAIkIAQgBxCoChogESgCUCEICyAIQYCAgCBxDQEgCy8ALUGIAnENASALKAIYIRggNCgCHCIPIQMDQCADBEAgAy0ABEEJcQ0DIAMoAjQiCARAIAMtAABBhwFHDQQLIAMoAkQhDCAIIQMgDEUNAQwDCwsgMykDOCEmAkAgDygCMCIIRQ0AQQAhAyAIKAIAIgZBACAGQQBKGyEMA0AgAyAMRg0BIAggA0EEdGovARQiBgRAQgFBPyAGQQFrQf//A3EiBiAGQT9PG62GICaEISYLIANBAWohAwwACwALIBguASIiA0EAIANBAEobrSE1QgAhHANAIBwgNVENAgJAQoCAgICAgICAgH9CASAchiAcQj9aGyAmg0IAUg0AIBynIQggDyEDA0AgA0UNASADKAIcIAhBBHRqKAIIIgYtAABB+QBHBEAgBkH5ADoAACAGIAYoAgRB/79fcTYCBCADIAMoAgRBgICACHI2AgQLIAMoAjQhAwwACwALIBxCAXwhHAwACwALIAEoAiwhDCABKAIoIQggASgCJCEPIAEoAhwhCyAFIAEoAgQiA0EBcToA2AICQCADQQlxQQFHDQAgBSgCsAIgC0F/EJgKDQAgASgCRA0AIAEgASgCBEF+cTYCBCABIBEgC0EAEJAJIgg2AiggASABKAIEQQhyNgIEIAVBAjoA2AILIAUgBSgCsAIiAwR/IAAgA0EAIAsoAgAQqQohBiAAIAAoAigiA0EBajYCKCAFIAM2ArgCIAlB9gAgAyAFKAKwAigCACALKAIAakEBakEAIAZBeBD0CAVBfwsiAzYCxAICQCACLQAAQQxHDQAgCUH2ACACKAIEIAsoAgAQigMaIAEtAAVBCHFFDQAgCygCACIHIQMDQAJAIANBAkgNACALIANBAWsiA0EEdGoiBi0AEUHAAHENACARIAYoAggQMyARIAYoAgwQMiALIAsoAgBBAWsiBzYCAAwBCwtBACEDIAdBACAHQQBKGyEHA0AgAyAHRg0BIAsgA0EEdGoiBi0AEUHAAHFFBEAgBigCCEH5ADoAAAsgA0EBaiEDDAALAAsgACAAKAI4QQFrIhg2AjggAS0ABUHAAHFFBEAgAUHAAjsBAgsgASgCPARAIAAgASAYEKIKCwJAIAEoAggNACAFKALEAiIDQQBIDQBBACEGIAkoAgAtAFcEf0GQgggFIAkoAmggA0EYbGoLIgNB9wA6AAAgBSAFLQDQAkEBcjoA0AILQQAhAwJAIAEtAARBAXFFDQAgACAAKAIoIgNBAWo2AiggBSADNgLcAiAFIAlB9gAgA0EAQQAgACABKAIcQQBBABCpCkF4EPQINgLgAkEDIQMgCSgCbCIGQQBMDQAgCSgCaCAGQRhsakEWa0EIOwEACyAFIAM6ANkCAkAgCCASckUEQEEAIQYgASgCBEGAgAFxIAUtANgCQQBHQQh0ciEOAkAgASgCRCIKRQ0AIAEoAiAoAhwoAhwoAgAhAyAAEPAIIgdB9gAgCigCMCADEIoDGiAHQfMAIAooAjAiA0EBaiADEIoDGiAHQfMAIAooAjAiA0ECaiADEIoDGiAHQfMAIAooAjAiA0EDaiADEIoDGiAKKAIIIgMEQCADKAIAIQMgCiAAKAIsIghBAWoiDDYCRCAAIAMgCGoiAzYCLCAHQcsAQQAgDCADENsIGgsgACAAKAIsQQFqIgM2AiwgCiADNgJUIAdBxwBBASADEIoDGiAKLQAURQRAIAohAwNAIANFDQICQAJAIAMoAiwiCC0ABUEQcUUNACADLQARQdoARg0AIAAgAygCSCgCFEEAQQAQqQohCCAAIAAoAigiDEEBajYCKCADIAw2AjwgAyAAKAIsIg1BAWo2AkAgACANQQNqNgIsAkAgCEUNACADKAIsKAIgLQABQekARw0AIAgoAhBBAToAACADKAI8IQwLIAdB9gAgDEECEIoDGiAHIAhBeBCqCiAHQccAQQAgAygCQEEBahCKAxoMAQtBACEMIAgoAiAiCEGAwwRHIAhBisMER3FFBEAgAyAAKAIsIgxBAWo2AkAgACAAKAIoIghBAWo2AiggAyAINgI8IAAgDEECajYCLCAHQfMAIAggCigCMBCKAxoMAQsgCEHHwgRHIAhBzMIER3ENACAAIAAoAigiCEEBajYCKCADIAg2AjwgB0HzACAIIAooAjAQigMaCyADKAIkIQMMAAsACyAKIAAoAiwiA0EBaiIINgJYIAAgA0ECaiIDNgIsIAogAzYCXCAAIAAoAigiA0EBajYCKCAKIAM2AjwgB0HHAEEBIAgQigMaIAdBxwBBACAKKAJcEIoDGiAHQfMAIAooAjwgCigCMBCKAxoLIAAgBCAPIAUoArACIAEoAhwgASAOIAEuAQIQqwoiD0UNESAPLgEyIgMgAS4BAkgEQCABIAM7AQILAkAgBS0A2AJFDQAgDy0ALyIDRQ0AIAUgAzoA2QILAkAgBSgCsAIiAwRAIAUgDywALSIEQQAgBEEAShsiBDYCtAIgBSAPLQAwQQRxBH8gD0EcaiAPLQAsQeAAbCAPaiIGQagFaiAGKALQBRsFIA9BHGoLIgYoAgA2AswCIAMoAgAgBEcNASAFQQA2ArACCyAFKALEAiIDQQBIDQAgCSADEKwKCyAKBEAgACAAKAI4IhNBA2siFTYCOCAAIAAoAixBAWoiGzYCLCABKAJEIgYoAgwhFyAAEPAIIQQgASgCICIDKAIwIQogAygCGC4BIiEMIAAgACgCOEEBayIWNgI4IAVBjANqQQBBJBDnFBogBSAbNgKIAyAFIAQ2AoADIAUgBjYC/AIgBSAANgL4AiAFIBNBAWsiITYChAMgBSAGKAIwIg02AqADIAUgDUEDajYCqANBAiEDIAUgDUECajYCmAMCQAJAAkACQCAGLQARQdYAaw4FAAICAgECCyAGLQAQQdkARg0CQQEhAyAAIAYoAhgQrQoNAQwCCyAGKAJYDQEgBiEDA0AgAwRAQQAhByADKAIsKAIgIghBzMIERiAIQcfCBEZyIAhBgMMERiAIQYrDBEZycg0DIAMoAiQhAwwBCwtBASEDIAYtABJB2ABHDQAgBi0AEEHZAEYNAUEDIQMgACAGKAIcEK0KRQ0BCyAFIAM2ApADCyAAIAAoAiwiAyAMaiIUQQJqIgc2AiwgBSAHNgKUA0EAIRBBACEOAkACQCAGLQARQdYAaw4DAAEAAQsgACAUQQNqIgc2AiwgByEOCwJAAkAgBi0AEkHWAGsOAwABAAELIAAgB0EBaiIHNgIsIAchEAsgA0EBaiEIQQAhA0EAIRJBACEZIAYtABBBzABHBEAgFwR/IBcoAgAFQQALIRIgBigCTCAIaiEZIAYoAggiGgRAIBooAgAgGWohGQsgBSAHIBJqIhpBAWo2ApwDIAUgEiAaaiIaQQFqNgKkAyAFIBIgGmoiGkEBajYCrAMgACASIBpqNgIsIAdBAWohEgsgE0ECayEaIA1BAWohEyAUQQFqIQ0gDEEAIAxBAEobIQcDQCADIAdGRQRAIARB3gAgCiADIAMgCGoQ2wgaIANBAWohAwwBCwsgBEHhACAIIAwgDRDbCBpBACEUQQAhHSAGKAIIIgMEQCADKAIAIQcgBigCTCEKIAAgA0EAQQAQqQohDCAAIAAoAixBAWoiFDYCLCAEQdoAIAggCmoiCCAGKAJEIAcQ2wghAyAEIAxBeBCqCiAEQQ4gA0ECaiIKIANBBGogChDbCBogBEEKIBQQ8gghHSAEQY38AEEAEPMIIARB0AAgCCAGKAJEIAdBAWsQ2wgaQQAhAwsgBEH/ACATIAUoApQDEIoDGiAEQYABIBMgDSAFKAKUAxDbCBogBEE0IAYoAlRBACAFKAKUAxDbCCEeIAAQ8AghByAGIQNBACEMA0AgAwRAIAMoAiwhCCAHQcsAQQAgAygCNBCKAxoCQAJAIAMoAkgoAhQiCkUEQEEAIQogDEEATA0BDAILIAwgCigCACIKSg0BCyAKIQwLAkAgBigCWA0AQQAhCiAIKAIgIg1BgMMERyANQYrDBEdxRQRAIAdBxwBBACADKAJAEIoDGiAHQccAQQAgAygCQEEBahCKAxoLIAgtAAVBEHFFDQAgAygCPCIIRQ0AIAdBkgEgCBDyCBogB0HHAEEAIAMoAkBBAWoQigMaCyADKAIkIQMMAQsLIAAgACgCLCIDIAxqNgIsIAUgA0EBajYCjAMgDgRAIAAgBigCGCAOEPcIIAAgDkEDQQAgBi0AEEHZAEYbEK4KCyAQBEAgACAGKAIcIBAQ9wggACAQQQRBASAGLQAQQdkARhsQrgoLAkAgBi0AEEHZAEcEQCAGLQARIQMgDkUNASADQf8BcSIIIAYtABJHDQEgBEE5QTcgCEHWAEYbIA5BACAQENsIIQcgBUH4AmpBABCvCiAEQSQgBSgCoAMQ8ggaIAVB+AJqELAKIARBkgEgBSgCoAMQ8ggaIARBCUEAIBYQigMaQQAhCCAEKAJsIQMgBCgCAC0AVwR/QZCCCAUgBCgCaCAHQRhsagsiCCADNgIICyAGLQARIQMLAkACQCADQf8BcUHWAEYEQCAQRQ0BIAYtABBB2QBGDQEgBEHrACAOIBAgDhDbCBogBi0AESEDCyADQf8BcUHaAEYNAQsgBEEkIAUoApgDEPIIGgsgBEEkIAUoAqADEPIIGiAEQSQgBSgCqAMQ8ggaIBJFIBdFckUEQCAEQdAAIBkgEiAXKAIAQQFrENsIGiAEQdAAIBIgBSgCnAMgFygCAEEBaxDbCBogBEHQACASIAUoAqQDIBcoAgBBAWsQ2wgaIARB0AAgEiAFKAKsAyAXKAIAQQFrENsIGgsgBEEJQQAgFhCKAxpBACEIIAQoAmwhAyAEKAIALQBXBH9BkIIIBSAEKAJoIB5BGGxqCyIIIAM2AgggEgRAIAAgFyAZIBIgFhCxCgsCQCAGLQARIgNB1gBGBEAgBUH4AmpBA0EAQQAQsgoaIAYtABJB2gBGDQEgBi0AEEHZAEYEQCAAIAAoAjhBAWsiAzYCOCAEKAJsIQggBUH4AmpBOSAFKAKgAyAQIAUoAqgDIAMQswogBUH4AmpBAiAOQQAQsgoaIAVB+AJqQQFBAEEAELIKGiAEQQlBACAIEIoDGiAEIAMQjQoMAgsgBUH4AmpBASAQQQAQsgoaIAVB+AJqQQIgDkEAELIKGgwBCyAGLQASQdgARgRAAkAgA0HYAEYEQCAGLQAQIQMgBUH4AmpBAyAQQQAQsgoaIANB2QBHDQEgBUH4AmpBAiAOQQAQsgoaIAVB+AJqQQFBAEEAELIKGgwDCyAFQfgCakEDIBBBABCyChoLIAVB+AJqQQFBAEEAELIKGiAFQfgCakECIA5BABCyChoMAQsgBUH4AmpBA0EAQQAQsgoaIAYtABJB2gBGDQAgBi0AEEHZAEYEQCAEKAJsIQhBACEDIBAEQCAAIAAoAjhBAWsiAzYCOCAFQfgCakE5IAUoAqADIBAgBSgCqAMgAxCzCgsgBUH4AmpBAUEAQQAQsgoaIAVB+AJqQQIgDkEAELIKGiAQRQ0BIARBCUEAIAgQigMaIAQgAxCNCgwBC0EAIQMgEARAIARBOyAQQQBBARDbCCEDCyAFQfgCakEBQQBBABCyChogBUH4AmpBAiAOQQAQsgoaIBBFDQBBACEHIAQoAmwhCCAEKAIALQBXBH9BkIIIBSAEKAJoIANBGGxqCyIDIAg2AggLIAQgFhCNCiAPELQKQQAhByAGKAIIBEBBACEIIARBxwBBACAUEIoDIQcgBCgCbCEDIAQoAgAtAFcEf0GQgggFIAQoAmggHUEYbGoLIgggAzYCCAsgBUEANgKUAyAEQSQgExDyCCEMIAYtABEhAwJAIAYtABJB2ABGBEACQCADQf8BcUHYAEYEQCAGLQAQIQMgBUH4AmpBAyAQQQAQsgoaIANB2QBHDQEgBUH4AmpBAiAOQQAQsgoaDAELIAVB+AJqQQMgEEEAELIKGgsgBUH4AmpBAUEAQQAQsgoaIAQoAmwhAyAEKAIALQBXIQgMAQsgBUH4AmpBA0EAQQAQsgoaIANB/wFxQdYARgRAAkAgBi0AEEHZAEYEQCAEKAJsIQMgBUH4AmpBAiAOQQEQsgohCiAFQfgCakEBQQBBARCyCiENDAELIAQoAmwhAyAGLQASQdoARgRAIAVB+AJqQQEgDkEBELIKIQ0gBUH4AmpBAkEAQQEQsgohCgwBCyAFQfgCakEBIBBBARCyCiENIAVB+AJqQQIgDkEBELIKIQoLIARBCUEAIAMQigMaQQAhCCAEKAJsIQMgBCgCAC0AVwR/QZCCCAUgBCgCaCAKQRhsagsiCCADNgIIIAVB+AJqQQFBAEEBELIKIQogBEEJQQAgAxCKAxogBCgCbCEDAkAgBCgCAC0AVyIIBEBBkIIIIgogAzYCCAwBCyAEKAJoIg8gDUEYbGogAzYCCCAPIApBGGxqIQoLIAogAzYCCAwBCyAEKAJsIQMgBUH4AmpBAUEAQQEQsgohDSAFQfgCakECIA5BABCyChogBEEJQQAgAxCKAxpBACEKIAQoAmwhAyAEKAIALQBXIggEf0GQgggFIAQoAmggDUEYbGoLIgogAzYCCAtBACEKIAhB/wFxBH9BkIIIBSAEKAJoIAxBGGxqCyIIIAM2AgggBEGSASAFKAKgAxDyCBogBigCCARAIAYoAlgiAwRAIARBxwBBASADEIoDGiAEQccAQQAgBigCXBCKAxoLQQAhBiAEKAJsIQMgBCgCAC0AVwR/QZCCCAUgBCgCaCAHQRhsagsiBiADNgIEIARBwwAgFBDyCBoLQQAhBiAJQQlBACAVEIoDGiAJICEQjQogCUEAIgNBm50BakEAELUKIAVBADYCzAIgACABQX8gBUGwAmogBUHYAmogAiAaIBUQoQogCSAaEI0KIAlBwwAgGxDyCBogCUGXnQFBABDzCCAJIBUQjQoMAgsgACABQX8gBUGwAmogBUHYAmogAiAPKAIcIA8oAiAQoQogDxC0CkEAIQYMAQsCQCAIBEAgASgCHCIDQQhqIQYgAygCACEDA0AgA0EATEUEQCAGQQA7AQ4gBkEQaiEGIANBAWshAwwBCwsgCEEIaiEGIAgoAgAhAwNAIANBAExFBEAgBkEAOwEOIAZBEGohBiADQQFrIQMMAQsLIAEuAQJBwwBOBEAgAUHCADsBAgtBACEQIAUoArACIgdFDQEgCCgCACIGIAcoAgBHDQFBACEDIAZBACAGQQBKGyEKA0AgAyAKRkUEQCAIIANBBHQiBmogBiAHai0AEEEBcToAECADQQFqIQMMAQsLIAggB0F/EJgKRSEQDAELQQAhECABQQA7AQILIAAgACgCOEEBayISNgI4IBFCLBDFAiIDBEAgAEHFACADEJAKGgtBACEGIBEtAFcNECADIAEoAhA2AiggBUIANwKUAyAFQgA3AowDIAVCADcChAMgBSADNgKAAyAFIAQ2AvwCIAUgADYC+AIgCAR/IAgoAgAFQQALIQYgAyAINgIQIAMgBjsBAiAFQfgCaiALELcKIAVB+AJqIAUoArACELcKIAwEQCAIBEAgBUIANwPAAyAFQgA3A7gDIAUgADYCsAMgBUHGADYCtAMgBSABNgLIAyAFQbADaiABKAIsELIJGiABKAIkIQ8LIAVB+AJqIAwQuQoLIAMgAygCGDYCHEEAIQZBACENAkAgASgCKA0AIAEoAiwNACADKAIkQQFHDQAgAygCICgCACIKKAIUIgdFBEAMAQsgBygCAEEBRw0AIAotAAdBAXENACARLQBSQQFxDQACfyAKKAIIIgpBmIQBEG1FBEBBASENIAcoAggQugpBAEdBAXQMAQsgCkGnKRBtDQFBAiENQQELIQogESAHQQAQkAkiBkUEQEEAIQYMAQsgBiAKOgAQCyADIAVB+AJqELsKIBEtAFcNEAJAAn8CfwJAIAgEQEEAIRRBACIbIAMoAiRBAUcNAxpBACADKAIgIgcoAghBAEgNAhogBygCACIHRQ0BQQAgBy0ABUEQcQ0DGiAHKAIUIgdFDQEgESAHKAIIQQAQpAkhB0GACkEAIAAgESAIQQAQkAkgBxDCCSIUGwwDCwJAIAUCfwJAAkAgASgCJA0AIAEoAhwiCCgCAEEBRw0AIAEoAiAiBygCAEEBRw0AIAcoAhwNACADKAIkQQFHDQAgASgCLA0AIAcoAhgiBy0AKw0AIAgoAggiCC0AAEGoAUcNACAIKAIoIANHDQAgAygCICgCBC0ABUEBcUUNACAIKAIEQYSAgAhxDQAgACgCACAHKAI8EPwCIQ8gACAAKAIoIg1BAWo2AiggBygCFCEOIAAgDxCvCUEAIQogBy0AHEGAAXEEQCAHEK8DIQoLAkAgASgCIC0ALUEBcQ0AIAdBCGohBANAIAQoAgAiBEUNAQJAIAQtADdBBHENACAELgEwIgggBy4BKE4NACAEKAIkDQAgCgRAIAggCi4BME4NAQsgBCEKCyAEQRRqIQQMAAsACyAKBH8gCigCLCEOIAAgChC8CgVBAAshBCAJQfAAIA0gDiAPQQEQ/wIaIAQEQCAJQX8gBEF4EL0KCyADIAAoAiwiBEEBaiIINgIMIAAgAygCJCAEIAMoAhgiD2pqNgIsIAlB4gAgDSAIIA9qEIoDGiAJQfoAIA0Q8ggaIAAtANMBQQJHDQMCfyAKRQRAIAcoAgAhBEHpnwMMAQsgBy0AHEGAAXFFBEAgBygCACEEDAMLQQAhAyAHKAIAIQQgCi8AN0EDcUECRw0CQemfAwshA0HpnwMMAgsgAygCJCEOAn8CQAJAIAMoAhwEQEEAIQggDkEAIA5BAEobIQoDQAJAIAggCkcEQCADKAIgIAhBGGxqIgcoAgAtAAdBAXENASAHKAIELQAEQSBxRQ0BIAghCgsgCiAORw0DIAAgACgCLEEBaiIHNgIsQQAhCiAJQccAQQAgBxCKAxogAygCJCEOQQAMBQsgCEEBaiEIDAALAAsgDkEBRw0AQQAhByADKAIgIggoAghBAEgEQEEBIQ4MAgtBASEOQYAKQQAgCCgCACgCFCIKGwwCC0EAIQcLQQAhCkEACyEQIAMgACgCLCIIQQFqNgIMIAAgAygCGCAIIA5qajYCLCAAIAMQvgogACAEIA8gBiAKIAEgDSAQckEAEKsKIghFDRcgACAHIAMgCC0ALyIEEL8KAkAgBEUNACADKAIgIgpFDQAgACAEIAooAgggCigCDBDACgsgBwRAIAlBxwBBASAHEIoDGgsCQCANRQ0AIAgtADBBBHFFDQAgCC0ALUUNACAILQAsIQQgCQJ/AkADQCAEQQBMDQEgCCAEQQFrIgRB4ABsaigCyAYtAChBBHFFDQALIAggBEHgAGxqQYgGagwBCyAIQSBqCyIEKAIAEPgIGgsgCBC0CiAAIAMQwQoMAgtBoZoDIQMgCigCAAsiCDYCyAEgBSADNgLEASAFIAQ2AsABIABBAEHh0gAgBUHAAWoQoAoLIAVBADYCsAIgACAMIBJBEBDCCiAAIAFBf0EAQQAgAiASIBIQoQoMAwtBAAshFEEACyEbIAAgACgCKCIHQQFqNgIoIAMgBzYCBCAAIAhBACADKAIYEKkKIRYgCUH3ACADKAIEIAMvAQJBACAWQXgQ9AghNiAAIAAoAjgiH0ECayIZNgI4IAAgCCgCACIHIAAoAiwiE0EEaiIVaiI3IAdqNgIsIAlBxwBBACATQQJqIiEQigMaIAlB848BQQAQ8wggCUHLAEEAIBNBBWoiHSAIKAIAIBVqENsIGiAJQQogFSAZEIoDGiAAIAQgDyAIIBQgASAQQQl0QYABQcAAIAUtANgCQQJGG3IgG3JBABCrCiIaRQRAIBEgFBCuAwwSCyAAKAJIBEAgAyADKAIcIgc2AhggAy8BAgRAQQAhBCAHQQAgB0EAShshDSABKAIoKAIAQQFrIQcDQCAEIA1GRQRAIAcgAygCFCAEQQR0ai4BDiIKIAcgCkobIQcgBEEBaiEEDAELCyADIAdBAWo7AQILIAMgBUH4AmoQuwoLIAMgACgCLCIEQQFqNgIMIAAgAygCJCAEIAMoAhhqajYCLEEAIQcgGi0ALyEeQQAhDiAIKAIAIicgGiwALSIEQQAgBEEAShsiOEYiDUUEQEEAIQQgBSAFLQDYAgR/QZTLAUGE2AEgASgCBCIEQQFxGwVBlMsBCyIENgLQAUEAIQQgAEEAQdDfACAFQdABahCgCiADKAIYIgdBACAHQQBKGyEXIAgoAgAiCiEPIAohBwNAIAQgF0ZFBEAgByAHIAMoAhQgBEEEdGouAQ5MIg5qIQcgDiAPaiEPIARBAWohBAwBCwtBACEEIAAgCCAAIA8QwwoiDkEAQQAQ6AkgA0EBOgAAA0AgBCADKAIYTkUEQCADKAIUIARBBHRqIgcuAQ4gCk4EQCAAIAcoAgQgCiAOahD3CCAKQQFqIQoLIARBAWohBAwBCwsgA0EAOgAAIAlB4QAgDiAPIAAQlQkiBBDbCBogCUGLASADKAIEIAQQigMaIAAgBBCWCSAAIA4gDxDECiAaELQKIAAgACgCKCIOQQFqNgIoIAMgDjYCCCAJQfkAIA4gABCVCSIHIA8Q2wgaIAlBIiADKAIEIBIQigMaIAlByzFBABDzCCADQQE6AAELAkAgACgCSEUNAEEAIQQgBUEANgLIAyAFQgA3A8ADIAVCADcDuAMgBUIANwOwAyAFQccANgK0AwNAIAQgAygCJE4NASAFQbADaiADKAIgIARBGGxqKAIAELIJGiAEQQFqIQQMAAsACwJAAkAgEEUNACARLQBQQQRxDQACQCAnIDhHDQAgGi0AMEEIcQ0AIAkoAmwhJwwCCyAFQQA2ArACIAkgBSgCxAIQrAoLIAkoAmwhJyANDQAgCUGFASADKAIEIAcgDhDbCBoLIB9BAWshFyATQQNqIQ8gE0EBaiEQIDdBAWohB0EAIQQDQCAEIAgoAgAiCk5FBEACQCANRQRAIAlB3gAgDiAEIAQgB2oQ2wgaDAELIANBAToAACAAIAggBEEEdGooAgggBCAHahD3CAsgBEEBaiEEDAELCyAWBEAgFiAWKAIAQQFqNgIACyAJQdoAIB0gByAKIBZBeBD0CBogCUEOIAkoAmwiCkEBaiIEQQAgBBDbCBogACAHIB0gCCgCABDGCiAJQQogDyAXEIoDGiAJQQAiBEGsKmpBABDzCCAJQTsgISASEIoDGiAJQYSQAUEAEPMIIAlBCiAVIBkQigMaIAlB4fAAQQAQ8wggCSgCbCEIIAkoAgAtAFcEf0GQgggFIAkoAmggCkEYbGoLIgQgCDYCCCAAIBAgAyAeEL8KIAlBxwBBASAQEIoDGiAJQfPwAEEAEPMIAkAgDUUEQCAJQSUgAygCBCAnEIoDGgwBCyAaELQKIAkgNhCsCgsgESAUEK4DIAlBCiAPIBcQigMaIAlBACIEQZsqakEAEPMIIAkgEhD4CBogCSgCbCEIIAlBxwBBASAhEIoDGiAJQeSPAUEAEPMIIAlBwwAgDxDyCBogCSAXEI0KIAlBOyAQIAkoAmwiB0ECahCKAxogCUG3M0EAEPMIIAlBwwAgDxDyCBogACADEMEKIAAgDCAHQQFqIgdBEBDCCiAAIAFBfyAFQbACaiAFQdgCaiACIAcgCBChCiAJQcMAIA8Q8ggaIAlBxPAAQQAQ8wggCSAZEI0KIAAgAxC+CiAJQccAQQAgEBCKAxogCUGlJEEAEPMIIAlBwwAgFRDyCBogG0UgHkVyDQAgACAeIAMoAiAiAygCCCADKAIMEMAKCyAJIBIQjQoLIAUtANkCQQNGBEAgBUEAIgNBhNgBajYCsAEgAEEAQdDfACAFQbABahCgCgsgBSgCsAIiAwRAIAsoAgAhDSAFKALIAiEOIAAgACgCOEEBayIXNgI4IAMoAgAgBSgCtAIiBGshAyABKAIcIQggACgCCCELIAIoAgQhEyACLQAAIRICQCAEQQAgA0EBRxtFBEAgBUEAIgdBw50DQemfAyAEG2o2ApABIABBAEHHygEgBUGQAWoQoAoMAQsgBSADNgKgASAAQQBB5soBIAVBoAFqEKAKCyAFKALAAiIEBEAgC0EKIAUoArwCIAQQigMaIAsgDhD4CBogCyAFKALAAhCNCgsgBSgCuAIhDwJ/AkACQAJAIBJBCWsOBQEAAgIBAgsgASgCDEUNACALQcsAQQAgAigCDBCKAxoLQQAhECACKAIMDAELIAAQlQkhECASQf0BcUEMRgRAQQAhDSAAEJUJDAELIAAgDRDDCgshCkEBIQcCQCAFLQDQAkEBcQRAIAAgACgCLEEBaiIBNgIsIAAgACgCKCIMQQFqNgIoIAUoAsACBH8gC0EPEPEIBUEACyEEIAtB+QAgDCABIAMgDWpBAWoQ2wgaIAQEQEEAIRUgCygCbCEHIAsoAgAtAFcEf0GQgggFIAsoAmggBEEYbGoLIgQgBzYCCAsgC0EiIA8gDhCKAyEVIAtBhQEgDyABIAwQ2wgaQQAhBwwBCyALQSMgDyAOEIoDIRUgCyABKAIMIBcQpAogASgCDEEASgRAIAtB1gAgASgCCEF/EIoDGgsgDyEMCyAIQQhqIQhBACEBIA1BACANQQBKGyEEIAMgB2oiFkEBayEDA0AgASAERgRAIA0hAQNAIAFBAExFBEAgC0HeACAMIAggAUEBayIBQQR0aiIHLwEMIgRBAWsgAyAEGyABIApqENsIGiAFIAcoAgQ2AoABIAtBs+4AIAVBgAFqEPMIIAMgBEVrIQMMAQsLIBVBAWohAwJAAkACQAJAAkACQAJAAkAgEkEJaw4HAgQFAAMAAQMLIAtB3gAgDCAWIAoQ2wgaIAtB/wAgEyAQEIoDGiALQYABIBMgCiAQENsIGiALKAJsIgFBAEwNAyALKAJoIAFBGGxqQRZrQQg7AQAMAwsgC0HhACACKAIIIgFBH3YiBCAKaiANIARrIAAQlQkiBBDbCBogAUEASARAIAtBgAEgEyAEIAoQ2wgaDAMLIAtBigEgEyAEIAogARD/AhoMAgsgC0HUACACKAIMIA0QigMaDAELIAtBDCACKAIEEPIIGgsgEEUNAiAAIAoQlgkMAQsgC0HhACAKIA0gECACKAIUIA0Q9AgaIAtBigEgEyAQIAogDRD/AhogEEUNASAAIAogDRDECgsgACAQEJYJCyALIBcQjQogC0ElQScgBS0A0AJBAXEbIA8gAxCKAxogBSgCvAIiAwRAIAtBwwAgAxDyCBoLIAsgDhCNCgUgAyAIIAFBBHRqLwEMRWohAyABQQFqIQEMAQsLCyAJIBgQjQogACgCJEEASiEDDBALIAtBCGohBiAAKAL8ASEIIAAgCygCEDYC/AEgASgCBCEYAkACQAJAAkAgCyIiQS1qIgwvAABBgAJxIg9FDQAgCygCRCIDLQASIg5FDQEgAygCAEECSA0AIA5BAkcNAQsCQCAELQAsQcAAcQ0AIAAoAgAtAFNBAnENACAEIAYgB0EBaiAEKAIAIgMQxwoNAAJAIAdFBEAgA0EBRg0BIAQtAGxBAnENASAYQYCAgIABcQ0CDAELIAchDiAGIQMgGEGAgICAAXENAQNAIAMtACRBInENAiAORQ0BIA5BAWshDiADQUBqIgMoAhRFDQALDAELIAkoAmwhGCAAIAAoAixBAWoiAzYCLCALQSRqIg8gAzYCACAJQQsgA0EAIBhBAWoiDhDbCBogBSAGNgIgIAlBACIDQc3hAWogBUEgahDzCCApIA42AiAgBSALKAIkNgL8AiAFQQ06APgCICVCADcCiAMgJUIANwKAAyAFIAY2AhAgAEEBQcLhASAFQRBqEKAKIAAgCiAFQfgCahDmCRogCygCGCAKLwECOwEmICIgIi8ALUEgcjsALSALIAUoAoQDNgIoIAkgCygCJBD9CSAJKAJsIQYgCSgCAC0AVwR/QZCCCAUgCSgCaCAYQRhsagsiAyAGNgIIIABBADYCHCAAQQA6ABMMAwsgD0UNASALKAJEIQMLIAMoAgQiD0EATA0AIAlBCiADKAIIIA8QigMaIAsoAjAiCyADKAIMIgxHBEAgCUHzACALIAwQigMaIAUgBjYCcCAJQc3hASAFQfAAahDzCAsgCiADLwEQOwECDAELIAQgBkEAIAcQxwoiAwRAIAMoAhgiBgRAIAlBCiADKAIcIAYQigMaCyAJQfMAIAsoAjAgAygCKBCKAxogCiADKAIULwECOwECDAELIAAgACgCLEEBaiIPNgIsIAsiLEEkaiIDIA82AgAgKSAJQQkQ8QgiF0EBaiIYNgIgICIgIi8ALSIPQRByOwAtAkAgD0EIcUUEQCAJQQ8Q8QghDyAFIAY2AlAgCUGa4QEgBUHQAGoQ8wgMAQsgBSAGNgJgIAlBmuEBIAVB4ABqELUKQQAhDwsgBSALIjlBMGoiDigCADYC/AIgBUEMOgD4AiAlQgA3AogDICVCADcCgAMgBSAGNgJAIABBAUGy4QEgBUFAaxCgCiAAIAogBUH4AmoQ5gkaIAsoAhggCi8BAjsBJiAPBEBBACETIAkoAmwhFSAJKAIALQBXBH9BkIIIBSAJKAJoIA9BGGxqCyIPIBU2AggLIAlBwwAgLCgCJCAYEIoDGiAFIAY2AjAgCUEAIg9BquEBaiAFQTBqEPMIIAkoAmwhBiAJKAIALQBXBH9BkIIIBSAJKAJoIBdBGGxqCyIPIAY2AgggAEEANgIcIABBADoAEyAiLwAtQYgCcUGAAkcNACALKAJEIgYgKSgCIDYCBCAGICwoAiQ2AgggBiA5KAIwNgIMIAYgCi8BAjsBEAsgES0AVw0MIAEQpwohAyAAIAg2AvwBIAAgACgC3AEgA2s2AtwBCyAHQQFqIQcMAAsACwJAIAEoAjAiCARAIAAgACgCOCINQQJrIhg2AjggACgCCCEJIAAoAgAhCiAIKAIAIQsgAS0AACIMQYcBRg0BQQEhBgNAIAotAFcNAiAGIAEoAhwoAgBKDQJBACEDIAtBACALQQBKGyERIAhBCGohBANAAkAgAyARRwRAIAYgBC8BDEcNASADIRELAkAgCyARRw0AIApBmwFBABDICSIDRQRAQQchAwwLCyADIAY2AgggAyADKAIEQYAQcjYCBCABIAAgCCADEMIJIgg2AjAgCEUEQEEAIQgMAQsgCCALQQR0aiAGOwEUIAtBAWohCwsgBkEBaiEGDAILIARBEGohBCADQQFqIQMMAAsACwALIAYoAjRFBEAgAEEBQQAiA0HxxgFqQQAQoAogAEEBQd7GAUEAEKAKCwJAAkACQAJAIAEtAABBhgFrDgMBAAECC0EAIQwgBUEANgL4AiAGIAEoAgg2AgggBiABKAIMNgIMIAYgASgCPDYCPCAAIAYgBUHYAmoQ5gkhAyAGQQA2AjwgAw0HIAFBADYCNCABIAYoAggiAzYCCCABIAYoAgw2AgxBACEEAkAgA0UNAEEAIQkgEUERIAMQ8gghBCARQa63AUEAEPMIIAEoAgwiA0UNACARQaABIAEoAgggA0EBaiADENsIGgsgAEEBQY71AUEAEKAKIAAgASAFQdgCahDmCSEDIAEoAjQhDCABIAY2AjQgASABLgECIAYuAQIQyAoiCTsBAgJAIAEoAjwiBkUNACAGKAIMIAVB+AJqEMkKRQ0AIAUoAvgCIgZBAEwNACAJIAatEJsEIgZMDQAgASAGOwECCyAERQ0CQQAhCSARKAJsIQYgESgCAC0AVwR/QZCCCAUgESgCaCAEQRhsagsiBCAGNgIIDAILAkAgCkEBRgRAIAUoAtwCIQQMAQsgACAAKAIoIgRBAWo2AiggASARQfYAIARBABCKAzYCFCABEMoKIgMgAygCBEEgcjYCBAsgBUIANwOIAyAFQgA3A4ADIAUgBDYC/AIgBUEBOgD4AiAAIAYgBUH4AmoQ5gkiAw0FIAFBADYCNCABKAI8IQkgAUEANgI8IAVBAkEBIAEtAAAiA0GIAUYbOgD4AiAFIAMQywo2AvABIABBAUG9kgIgBUHwAWoQoAogACABIAVB+AJqEOYJIQMgAUEANgIwIAEoAjQhDCABIAY2AjQgAS0AAEGGAUYEQCABIAEuAQIgBi4BAhDICjsBAgsgDSABKAI8EDMgAUIANwIIIAEgCTYCPCAKQQFGDQEgDS0AVw0BIAAgACgCOCIGQQJrIgk2AjggACABIAZBAWsiBhCiCiARQSQgBCAGEIoDGiARKAJsIQsgACABIARBAEEAIAVB2AJqIAkgBhChCiARIAkQjQogEUEnIAQgCxCKAxogESAGEI0KIBFB+gAgBEEAEIoDGgwBCyAAIAAoAigiBEECajYCKEEAIQwgASARQfYAIARBABCKAzYCFCABEMoKIgMgAygCBEEgcjYCBCAFQgA3A4gDIAVCADcDgAMgBSAENgL8AiAFQQE6APgCIAAgBiAFQfgCahDmCSIDDQUgEUH2ACAEQQFqIglBABCKAyEDIAFBADYCNCABIAM2AhggASgCPCELIAFBADYCPCAFIAk2AvwCIAUgAS0AABDLCjYC4AEgAEEBQb2SAiAFQeABahCgCiAAIAEgBUH4AmoQ5gkhAyABKAI0IQwgASAGNgI0IAYuAQIiBiABLgECSARAIAEgBjsBAgsgDSABKAI8EDMgASALNgI8IAMNACAAIAAoAjgiC0ECayIGNgI4IAAgASALQQFrIgsQogogEUEkIAQgCxCKAxogEUGGASAEIAAQlQkiCBCKAyEHIBFBHCAJIAYgCEEAEP8CGiAAIAgQlgkgACABIARBAEEAIAVB2AJqIAYgCxChCiARIAYQjQogEUEnIAQgBxCKAxogESALEI0KIBFB+gAgCUEAEIoDGiARQfoAIARBABCKAxoLIAEoAjgNAiAAEMwKDAILQQAhBkEAIRYgCiALQQJ0QQRqrRDsAiIRBEAgESALNgIAIAhBCGohBCALQQAgC0EAShtBAWohB0EBIQMDQCADIAdGRQRAIBEgA0ECdGogBC8BDEEBazYCACAEQRBqIQQgA0EBaiEDDAELCyAAIAEQowohFgsgDUEBayENQQAhFQJAIAxBhwFHBEAgACAAKAIsQQFqIhUgASgCHCgCACIDajYCLCAJQccAQQAgFRCKAxoCQCAKIANBARDNCiIGRQ0AIANBACADQQBKGyEEQQAhAwNAIAMgBEYNASAGIANBAnRqIAAgASADEM4KNgIUIAYoAhAgA2pBADoAACADQQFqIQMMAAsAC0EAIQMgASEEIAxB/gFxIhlBhgFHDQELQQEhA0GGASEZAkAgCi0AUkEgcQ0AIAEhBANAAkAgBCgCNCIHRQ0AIAQtAAAgDEcNACADQQFqIQMgByEEDAELCyADQQRJBEBBASEDDAELQQIhByABIQQDQCADIAdNBEBBASEDDAMFIAdBAmohByAEKAI0IQQMAQsACwALIAEhBAsgBCgCNCEHIARBADYCNCAHQQA2AjggByAAKAIAIAhBABCQCTYCMCAAIAEgASgCMEGv5gEiCBDPChogACAHIAcoAjBBr+YBEM8KGiAAIAEgDRCiCkEAIRBBACESAkAgDEGHAUcNACABKAIIIghFDQAgACAAKAIsIg9BAmoiEjYCLCAJQdAAIAEoAgwiDkEBaiAIIA4bIA9BAWoiEBCKAxogCUHQACAQIBIQigMaCyAKIAEoAjwQMyABQQA2AjwgACAAKAIsIg5BBGoiFDYCLCAFQgA3A4gDIAVCADcDwAMgBUIANwOAAyAFIA5BAWoiCDYC/AIgBUENOgD4AiAFQgA3A7gDIAUgDkECaiIPNgK0AyAFQQ06ALADIAUgAS0AABDLCjYCgAIgAEEBQQAiF0G64QJqIAVBgAJqEKAKIAlBCyAIQQAgCSgCbEEBahDbCCEbIAlBjdkBQQAQ8wggByAQNgIIIABBAUHT1wFBABCgCiAAIAcgBUH4AmoQ5gkaIAkgCBD9CSAOQQNqIRAgCSgCbCETIAkoAgAtAFcEf0GQgggFIAkoAmggG0EYbGoLIg4gEzYCCCAJQQsgD0EAIBNBAWoQ2wghEyAJQYDZAUEAEPMIIAEpAgghHCABQQA2AgwgASASNgIIIABBAUGy1wFBABCgCiAAIAEgBUGwA2oQ5gkaIAEgHDcCCCAJIA8Q/QkgCUHtpQJBABC1CiAAIAEgBUH4AmogAiAQIBUgBiANENAKIQ4gAwRAIAlBwaQCQQAQtQogACABIAVBsANqIAIgFCAVIAYgDRDQCiEXCyAGEJMHIA0hEiANIQYgGUGIAUcEQCAJQfidAUEAELUKIAlBCiAUIBcQigMhBiAJQQwgDyANEIoDIRIgCSAGEPgIGiABIAEuAQIgBy4BAhDICjsBAgsCQCAMQYkBRgRAIAYhAiAHLgECIhUgAS4BAk4NASABIBU7AQIMAQsgCUHnnQFBABC1CiAJQQogECAOEIoDIQIgCUEMIAggDRCKAxogCSACEPgIGgsgCUGxnQFBABC1CiAJQQogECAOEIoDIQ4gCUEMIAggBhCKAxogCSAYEPgIGgJ/AkAgDEGHAUYEQCAOIRAMAQsgDEGJAUYEQCAOIRAgDkEBagwCCyAJQdWdAUEAELUKIAlBDCAIIAYQigMhECAJIBgQ+AgaCyAOCyEGIAlBw50BQQAQtQogCSgCbCEMIAMEQCAJQQogFCAXEIoDGgsgCUEMIA8gAhCKAxogCSAYEPgIGkEAIQ4gCSgCbCEDIAkoAgAtAFcEf0GQgggFIAkoAmggE0EYbGoLIg4gAzYCCCAJQQwgCCASEIoDGiAJQQwgDyACEIoDGiAJIBgQjQogCUHZAEEAQQBBACARQXIQ9AgaIAlB2gAgBSgChAMgBSgCvAMgCyAWQXgQ9AgaIAkoAmwiA0EASgRAIAkoAmggA0EYbGpBFmtBATsBAAsgCUEOIAYgECAMENsIGiAJIA0QjQogBCgCNCIDBEAgAEHIACADEJAKGgsgBCAHNgI0IAcgBDYCOCAKIAcoAjAQrgMgB0EANgIwIAAQzAogACgCJEEARyEDDAQLQQAhDEEAIQMLIAAoAiQNASABLQAEQSBxRQ0BIA0gASgCHCgCACIKQQEQzQoiBkUEQEEHIQMMAgtBACEEIApBACAKQQBKGyEIIAZBFGohCQNAIAQgCEYEQCABIQcDQEEAIQQgBwRAA0ACQCAEQQJGDQAgByAEQQJ0aiI6QRRqIgsoAgAiCUEASA0AQQAhCCARKAIALQBXBH9BkIIIBSARKAJoIAlBGGxqCyIIIAo2AgggBiAGKAIAQQFqNgIAIBEgCSAGQXgQvQogOkF/NgIUIARBAWohBAwBCwsgBygCNCEHDAELCyAGEJMHDAMLIAkgACABIAQQzgoiCzYCACALRQRAIAkgDSgCCDYCAAsgCUEEaiEJIARBAWohBAwACwALQQAhDAsgAiAFKALkAjYCDCACIAUoAugCNgIQIAxFDQAgAEHIACAMEJAKGgsgASgCOEUNCAwJCyAKKAIAIhNFDQAgBCgCBCIWQQFxDQAgDARAIBINASAGKAIAQQFKDQELIAEoAjAiFARAIAQoAjANAQsgEgRAIAQoAjANAQsCQCAMBEAgASgCJCAVQQFxcg0CIBZBgMAAcUUNAQwCCyAWQYDAAHENAQsCQCALIjtBLGoiIS0AACIMQeAAcSIaRQRAQQAhHQwBCyATQQFKDQEgCigCGC0AK0EBRg0BQQEhHSAVQQFxIAxBEHFyDQELIAdBAEwiDEUEQCAKLQAsQcAAcQ0BCwJAIAQoAjRFBEBBACEWDAELIBINASAEKAIwDQEgBCEKIBogFUEBcXINAQNAIAoEQCAKLQAEQQlxDQMgCigCNCITBEAgCi0AAEGHAUcNBAsgCigCICIWKAIAQQBMDQMgCigCRA0DIBMhCiAMDQEgFi0ALEHAAHFFDQEMAwsLAkAgFEUNAEEAIQogFCgCACIMQQAgDEEAShshEwNAIAogE0YNASAKQQR0IQwgCkEBaiEKIAwgFGovARQNAAsMAgsgFUGAwABxDQEgBCgCHCEWQQAhEwNAIBYoAgAgE0oEQCAWIBNBBHQiDGooAggQ5AkhFSAEIQoDQCAKKAI0IgoEQCAKKAIcIAxqKAIIEOQJIBVGDQEMBQsLIBNBAWohEwwBCwtBACEWIAYoAgBBAkgNACAAKAJsQfQDSg0BIAMtAFJBgAFxDQEgAyAANAIoQgKGQgR8EMUCIgpFDQAgCiAAKAIoNgIAIAohFgsgBEE0aiEEIAAgC0EQaiIKKAIANgL8ASAAQRVBAEEAQQAQ+QgaIAAgDTYC/AEgKCgCHCEfIAMgC0EMaiIMKAIAEDIgAyALKAIQEDIgAyALQRRqIgooAgAQMiALQQA2AhQgC0IANwIMIChBADYCHCALIiNBGGohCwNAIAQoAgAiDARAIAEoAjQhCiAjKAIYIQ0gASgCPCEVIAEoAjAhEyAjQQA2AhggAUEANgI8IAFCADcCMCADIAFBABClCSEEIAEgEzYCMCABIBU2AjwgAUGHAToAACAjIA02AhgCQCAERQRAIAohBAwBCyAAIAAoAmxBAWoiDTYCbCAEIA02AhACQCAWRQ0AIAMtAFcNACAAIBYgBCgCICAHENIKIAVBgANqIg1CADcDACAFQgA3A4gDIAVBASIVQTxqNgKAAyAFQgA3A/gCIAUgFjYCkAMgBUHJADYC/AIgBUH4AmogBBCxCRoLIAQgCjYCNCAKBEAgCiAENgI4CyAEIAE2AjgLIAEgBDYCNCAMQTRqIQQMAQsLIAMgFhAyAkAgAy0AVwRAICggHzYCHAwBCyAjKAIYIgQEQAJAIAQoAhgiCEEBRgRAQQEhCCAAKAJ4IgogACAKG0HKACAEEJAKGgwBCyAEIAhBAWs2AhgLICNBADYCGAsgB0EBaiEeQX8hEyAfIRkgASEUA0ACQCAURQ0AIAYgD2oiPEEsaiEEIBkoAiAiFigCACELQQAhGyABIBRGBEAgOy0ALCEbCyA8LQAsIQQgFCgCICEGIAtBAk4EQCAAIAYgC0EBayAeENUKIgZFDQEgFCAGNgIgCyAEQcAAcSEVQQAhBCALQQAgC0EAShshCgNAIAQgCkcEQCAGIAQgB2pBBnRqIgsiLUEsaiEIIAtBCGohDCALLQAuQQRxBEAgAyALKAI0EDQLIAwgFiAEQQZ0aiILQQhqIg1BwAAQ5RQaIC0gLS0ALCAVcjoALCALKAIwIRMgDUEAQcAAEOcUGiAEQQFqIQQMAQsLIAYgD2oiPUEsaiIEIBsgPS0ALEHAAHFyIBVyOgAAAkAgGSgCMCILRQ0AIBQtAAZBwABxDQBBACEEIAsoAgAiCEEAIAhBAEobIQgDQCAEIAhGRQRAIAsgBEEEdGpBADsBFCAEQQFqIQQMAQsLIBQgCzYCMCAZQQA2AjALIBkoAiQhBCAZQQA2AiQgGgRAIAQgE0EBENYKCyAEBEAgFCgCJCILBEAgAEEsIAQgCxChCSEECyAUIAQ2AiQLIAMtAFdFBEAgBSAdNgKEAyAFIBM2AoADIAUgFzYC/AIgBSAANgL4AiAFIBkoAhw2AogDIAUgGRDXCjYCjAMgBUH4AmogFEEAENgKCyAUIBQoAgQgGSgCBEGAAnFyNgIEIBkoAjwiBARAIBQgBDYCPCAZQQA2AjwLQQAhBANAIAQgCkcEQCAGIAQgB2pBBnRqIgsoAhgEQCAFQYADaiIIQgA3AwAgBUIANwOIAyAFQQEiDEE8ajYCgAMgBUIANwP4AiAFQcsANgL8AiAFIAtBCGo2ApADIAtCADcDOCAFQfgCaiAUELEJGgsgBEEBaiEEDAELCyAZKAI0IRkgFCgCNCEUDAELCyAqQgA3ArwDICpCADcCxAMgBUEBIgRBPGo2ArgDIAVBPjYCtAMgBSAANgKwAyAFQbADaiAfELEJGiADIB8QnwgLQX8hByAAKAIkDQMLIBEtAFcNAiABKAIgIQQgAi0AAEEJSQ0AIAUgASgCMDYCsAILIAchAwsgA0EBaiEHDAELC0EBIQNBACEGDAELQQEhAwsgESAGEK4DCyAAEMwKCyAFQdADaiQAIAMLRwEBfyMAQRBrIgIkAAJAIAEtAAVBAnEEQCAAQf/JAEEAELICDAELIAIgAS0AABDLCjYCACAAQcLIACACELICCyACQRBqJAAL2AILAX8BfwF/AX8BfwF/AX8BfwF/AX8BfyADQQFrIQsgAUEIaiEDIAQgBEH9AXEgAC0AFxsiBUECcSEMIAVBCHEhDSAFQQRxIQ4gASgCACEFIAAoAgghCEEAIQEgBEEBcUHRAHMiCUHQAEchDwNAIAEgBU5FBEAgAygCACEEAkACQCAORQ0AIAMvAQwiBkUNACANBEAgBUEBayEFIAFBAWshAQwCCyAIIAkgBiALaiABIAJqEIoDGgwBCwJAIAxFDQAgACAEELALRQ0AIAAgBCABIAJqELELGgwBCyAAIAQgASACaiIGEIELIgQgBkYNAAJAIA8NACAIEL0LIgctAABB0ABHDQAgBygCDEEBaiIKIAcoAgRqIARHDQAgCiAHKAIIaiAGRw0AIAcvAQINACAHIAo2AgwMAQsgCCAJIAQgBhCKAxoLIANBEGohAyABQQFqIQEMAQsLCyQAIAEEQCABIAI2AkAgACABEMsJIAEPCyAAKAIAIAIQpQggAQuDCgsBfwF/AX8BfwF/AX8BfwF/AX8BfwF/IwBB0ABrIgYkAAJAIAAoAgAiCC0AVw0AIAAQgwMNACADBEAgCCAILQBbQQFqOgBbCyAAIAIgAUEIahCICSEEAkAgA0UEQCAERQ0CDAELIAggCC0AW0EBazoAWyAEDQAgACABKAIMEJ4JIAAQugkMAQsgCCAEKAI8EPwCIQcgBC0AK0EBRgRAIAAgBBCZCQ0BCyAAQQlByvIAQd3yACAHQQFGG0EAIAgoAhAgB0EEdGooAgAiAxD5CA0AAn8gAgR/QQ9BESAHQQFGGwUgBC0AK0EBRgRAQR4hCiAIIAQQugcoAgQoAgQMAgtBDUELIAdBAUYbCyEKQQALIQUgACAKIAQoAgAgBSADEPkIDQAgAEEJIAQoAgBBACADEPkIDQBBACEFAkACQAJ/IAQoAgAiA0HxwwFBBxBuRQRAIANBB2oiBUGkPEEEEG5FDQMgBUGDxABBChBuQQBHDAELIAQoAhwiBUGAIHEEQCAIEK4JDQILIAVBD3ZBAXELIgVFDQELIAYgAzYCQCAAQayzASAGQUBrELICDAELIAQtACshBQJAIAIEQCAFQf8BcUECRg0BIAYgAzYCMCAAQZfdACAGQTBqELICDAILIAVB/wFxQQJHDQAgBiADNgIAIABB5tcAIAYQsgIMAQsgABDwCEUNACAAQQEgBxC1CQJAIAINACAAIAdBhIgBIAQoAgAQuwkgACgCACIFLQAhQcAAcUUNACAELQArDQAgABDwCCEJQQAhAyAEEIsKRQRAIARBMGohAyAFIg1BImohCgNAIAMoAgAiA0UNAiADLQAYRQRAIANBBGohAyANLQAiQQhxRQ0BCwsgACAAKAI4QQFrIgM2AjggCUExQQEgAxCKAxoLIABBAToAmQEgACAFIAFBABCnCUEAEN4JIABBADoAmQEgBS0AIkEIcUUEQCAJQTFBACAJKAJsQQJqEIoDGiAAQZMGQQJBAEF/QQQQjAoLIANFDQAgCSADEI0KCyAAKAIAIgsoAhAhAyAAEPAIIQwgAEEBIAcQtQkgB0EEdCEFIAQtACtBAUYEQCAMQaoBEPEIGgsgAyAFaiEFIAAgBBCOCiEDA0AgAwRAIAAgAxCfCSADKAIgIQMMAQsLIAQtABxBCHEEQCAFKAIAIQMgBiAEKAIANgIkIAYgAzYCICAAQZXoASAGQSBqEI0JCyAFKAIAIQMgBiAEKAIANgIUIAYgAzYCECAAQdiGAyAGQRBqEI0JAkACQAJAIAINACAELQArQQFGDQEgBEEIaiEOIAQoAhQhCUEAIQMDQCAJQQAgA0EBayIKIAlPGyEDIA4hAgNAIAIoAgAiAgRAIAIoAiwiBSADIAMgBUkbIAMgBSAKTRshAyACQRRqIQIMAQsLIANFDQEgACADIAAoAgAgBCgCPBD8AhC8CQwACwALIAQtACtBAUcNAQsgDEGsASAHQQBBACAEKAIAQQAQ9AgaIAAoAngiAyAAIAMbQQE6ABULIAxBlwEgB0EAQQAgBCgCAEEAEPQIGiAAIAcQtgkgCygCECAHQQR0aigCDCIALQBOQQJxRQ0AIABBEGohAANAIAAoAgAiAARAIAAoAggiAy0AK0ECRw0BIAsgAxDoCAwBCwsgCygCECAHQQR0aigCDCIAIAAvAU5B/f8DcTsBTgsgCCABEKQIIAZB0ABqJAALgwEDAX8BfwF/IwBBIGsiAiQAAkAgAUUNACACQQA2AhggAkIANwMQIAJCADcDCCACIAA2AgAgAkHMADYCBCACIAEQswkaA0AgAyABKAIATg0BIAEgA0EEdGoiBC0AEUEDcUUEQCAAQQAgBCgCDBCwCQsgA0EBaiEDDAALAAsgAkEgaiQAC+sGDwF/AX8BfwF/AX8BfwF/AX8BfwF+AX8BfwF/AX8BfyMAQSBrIgwkACAAKAIAIQ0CQCAAKALwASIKRQ0AIAAtANQBQQFGDQACQCABRQRAQQEhCCAKLgEiIgVBAEwNAiADRQ0BIAMoAgBBAUYNASAKKAIEIAVBAWtBDGxqKAIAIQUgDCACNgIUIAwgBTYCECAAQeTaASAMQRBqELICDAILIANFBEAgASgCACEIDAELIAMoAgAiCCABKAIARg0AIABBuaMBQQAQsgIMAQsgAigCBCAIQQN0akElaq0hDgJAIANFDQBBACEFIAMoAgAiB0EAIAdBAEobIQcDQCAFIAdGDQEgDiADIAVBBHRqKAIMEFpBAWqtfCEOIAVBAWohBQwACwALIA0gDhDFAiIGRQ0AIAYgCjYCACAGIAooAjA2AgQgBiAGIAhBA3RqQSRqIgU2AgggAC0A1AFBAk8EQCAAIAUgAhDACRoLIAUgAigCACACKAIEEOUUIg8gAigCBGpBADoAACAPEPQJIAIoAgQhESAGIAg2AhQCQAJAIAEEQCAIQQAgCEEAShshEgNAIAsgEkYNAkEAIQUgCi4BIiIHQQAgB0EAShshCSABIAtBBHRqIhBBDGohBwNAIAUgCUYNBCAKKAIEIAVBDGxqKAIAIBAoAgwiAhBtBEAgBUEBaiEFDAELCyAGIAtBA3RqQSRqIgcgBTYCACAALQDUAUECTwRAIAAgByACELAJCyALQQFqIQsMAAsACyAGIAouASJBAWs2AiQLAkAgA0UNACAPIBFqQQFqIQcgCEEAIAhBAEobIQtBACEFA0AgBSALRg0BIAMgBUEEdGoiE0EMaiIIKAIAIgIQWiEJIAYgBUEDdGogBzYCKCAALQDUAUECTwRAIAAgByACELAJIBMoAgwhAgsgByACIAkQ5RQgCWoiB0EAOgAAIAVBAWohBSAHQQFqIQcMAAsACyAGIAQ6ABkgBkEAOgAYIAYgBEEIdjoAGiAGIAooAjxBOGogBigCCCAGEOcDIgVGBEAgDRCVASAGIQkMAgsgBQRAIAYgBTYCDCAFIAY2AhALIAogBjYCMEEAIQkMAQsgDCAQKAIMNgIAIABBtvwAIAwQsgIgBiEJCyANIAkQMiANIAEQrgMgDSADEK4DIAxBIGokAAsoAAJAIAAoAvABIgBFDQAgAC0AKw0AIAAoAjAiAEUNACAAIAE6ABgLC+8BBAF/AX8BfwF/IwBBEGsiBSQAIAAoAgAhBgJAAkAgACgC8AEiBEUNACAALQDUAUEBRg0AIAYoAhAgBi0AsAFBBHRqKAIEKAIELQAYQQFxDQAgBCAAIAQoAhAgARDCCSIHNgIQIAAoAlQEQCAAIAcgAEHQAGpBARDYCQwCCwNAQQAhBiACLQABIQEgAkEBaiIEIQIgAUHApANqLQAAQQFxDQALA0AgAyICQQFrIgMtAABBwKQDai0AAEEBcQ0ACyAFIAQ2AgggBSACIARrNgIMIAAgByAFQQhqQQEQ2AkMAQsgBiABEDMLIAVBEGokAAvwAwoBfwF/AX8BfwF/AX8BfwF/AX8BfyMAQRBrIgskAAJAIAAoAvABIgVFDQAgBSgCHCIGQQRxBEAgCyAFKAIANgIAIABBgCcgCxCyAgwBCyAFIAZBBHI2AhwCQCABRQRAIAAgBSgCBCAFLgEiQQFrIgZBDGxqIggQhgpBASEHDAELIAEoAgAiDEEAIAxBAEobIQ5BfyEGA0ACQCAJIA5HBEAgASAJQQR0aigCCBCHCiIKEIgKIAotAABBO0cNAUEAIQYgBS4BIiIHQQAgB0EAShshByAKKAIIIQoDQCAGIAdGBEAgByEGDAMLIAogBSgCBCAGQQxsaiINKAIAEG0EQCAGQQFqIQYMAQUgACANEIYKIA0hCAwDCwALAAsgDEEBRiEHDAILIAlBAWohCQwACwALAkAgB0UgCEVyIARBAUZyDQAgCC0ABEFwcUHAAEcNAAJAIAFFDQAgAC0A1AFBAkkNACAAIAVBIGogASgCCBCHChCwCQsgBSACOgAqIAUgBjsBICAFIAUoAhwgA0EDdHI2AhwgAQRAIAAgAS0AEDoA0gELIAAgARCmCRoMAQsgAwRAIABB6ckBQQAQsgIMAQsgAEEAQQBBACABIAJBAEEAIARBAEECEL8JQQAhAQsgACgCACABEK4DIAtBEGokAAv2AgYBfwF/AX8BfwF/AX8jAEEQayIFJAACQAJ/AkACQCAAKALwASIERQ0AIAAtANQBQQFGBEAgAEGUyQBBABCyAgwBCwJAIAQoAgQiByAELgEiQQFrIghBDGxqIgYvAQgNACACRQ0CAkACQCACKAIEQQZrDgIAAQILQfyxASACKAIAQQYQbg0BQcAADAQLQYyIASACKAIAQQcQbkUNAgsgBSAGKAIANgIAIABB8JQDIAUQsgILIAEhAgwCCyAEIAQvASRBAWs7ASRBIAshAiAHIAhBDGxqIgMgAy8BCiIDIAJyOwEKIAQgBCgCHCACcjYCHCADQQFxBEAgACAGEIYKC0EAIQIgACAEIAYCf0EAIgMgAUUNABogAS0AACIDQTtGBEBBACIDIABBrQEgAUEAEKEJIgFFDQEaIAEtAAAhAwsgA0H/AXFBxwBHBEAgASAHIAhBDGxqLQAFOgABCyABCyIDEPoJCyAAKAIAIAIQMyAFQRBqJAALRwMBfwF/AX8gACgCACICIAItAFQiAyABIAItALEBIgQQhwQhAgJAIAQNACACBEAgAigCDA0BCyAAIAMgAiABEOwIIQILIAILbwMBfwF+AX8gASgCACIDEFpBAWoiBa0hBCABLQAKQQRxBEAgAyAFahBaQQFqrSAEfCEECyAAIAMgBCACEFpBAWoiBa18EGEiAwRAIAEgAzYCACADIASnaiACIAUQ5RQaIAEgAS8BCkGABHI7AQoLC4wCBQF/AX8BfwF/AX8jAEFAaiIEJAAgACgCACEFAkAgACgC8AEiB0UNACAHKAIEIAcuASJBAWtBDGxqIQhBACABIAUtALEBBH9BBEEFIAUtALABQQFGGwVBBAsiBhCBCkUEQCAEIAgoAgA2AgAgAEHjNiAEELICDAELIAgtAApB4ABxBEAgAEHSggFBABCyAgwBCyAEQQhqQQBBNBDnFBogBEG1AToACCAFIAIgAxDiCSEGIAQgATYCFCAEIAY2AhAgBEGAwAA2AgwgBSAEQQhqQQEQpAkhBiAFIAQoAhAQMiAAIAcgCCAGEPoJCyAALQDUAUECTwRAIAAgARCCCgsgBSABEDMgBEFAayQAC4gBBAF/AX8BfwF/AkAgAEUNACAALQAAIgFBwKQDaiwAAEEATg0AQd0AIAEgAUHbAEYbIQNBASEBA0ACQCADIAAgAWotAAAiBEYEQCADIQQgACABQQFqIgFqLQAAIANHDQELIAAgAmogBDoAACABQQFqIQEgAkEBaiECDAELCyAAIAJqQQA6AAALC3oDAX8BfwF/IAFBACABQQBKGyEFIAIoAgQgA0EBdGovAQAhBkEAIQEDQAJAIAEgBUcEQCAAKAIEIAFBAXRqLwEAIAZHDQEgACgCICABQQJ0aigCACACKAIgIANBAnRqKAIAEG0NAUEBIQQLIAQPCyABQQFqIQEMAAsACzABAX8DQCABQQBMBEBBAA8LIAFBAWshASAALgEAIQMgAEECaiEAIAIgA0cNAAtBAQuwAQEBfyACIAEvATRKBEAgACACQQlsrBDFAiIARQRAQQcPCyABIAAgASgCICABLwE0QQJ0EOUUIgA2AiAgASAAIAJBAnRqIAEoAgggAS8BMkEBdEECahDlFCIANgIIIAEgACACQQF0IgNqIAEoAgQgAS8BNEEBdBDlFCIANgIEIAAgA2ogASgCHCABLwE0EOUUIQAgASACOwE0IAEgADYCHCABIAEvADdBEHI7ADcLQQALbQQBfwF+AX8BfyAALwE0IQEgACgCDCEEA0AgAUEASgRAIAAoAgQgAUEBayIBQQF0ai4BACIDQQBIDQEgBCgCBCADQQxsai0ACkEgcSADQT5Lcg0BQgEgA62GIAKEIQIMAQsLIAAgAkJ/hTcDQAvLAQIBfwF/IwBB8ABrIgUkACAFQQA2AiAgBUIANwMYIAVCADcDECAFQgA3AwggBUEoakEAQcgAEOcUGiABBEAgBUEBNgIoIAEoAgAhBiAFQX82AlggBUFAayABNgIAIAUgBjYCOCACIAJBgIAQciABKAI8IAAoAgAoAhAoAhxGGyECCyAFIAA2AgAgBSACQYCABHI2AhggBSAFQShqNgIEAn9BASICIAUgAxDfCg0AGkEAIARFDQAaIAUgBBD+CgshAiAFQfAAaiQAIAILhgEDAX8BfwF/IAICfwJAIAIvAQgiBUUgASgCNCIERXJFBEAgBCgCACIGIAVIDQEgACgCACAEQQhqIgQgBUEEdGpBEGsoAgAQMyACLwEIQQR0IARqQRBrIAM2AgAPC0EBIARFDQEaIAQoAgAhBgsgBkEBagsiBTsBCCABIAAgBCADEMIJNgI0C3UGAX8BfwF/AX8BfwF/IAAvATQhBCAAKAIMKAIEIQUDQCABIARGRQRAQQEhAyAAKAIEIAFBAXRqLgEAIgZBAE4EQCAFIAZB//8DcUEMbGotAAYhAwsgAUEBaiEBIAIgA2ohAgwBCwsgACACQQJ0rRCbBDsBMAuoAQMBfwF/AX4gACgCACIDIAMpAyAiBUK7f4NCwACENwMgIAAgAUEAEJEKIAMgBTcDIAJAIAAoAiQNAANAIAEiBCgCNCIBDQALIANCwAAQxQIiAUUNACABQcgBOwEmIAFBADYCACABQQE2AhggACAEKAIcIAFBImogAUEEahDiCyAAIAEgBCACEOMLIAFB//8DOwEgIAMtAFdFBEAgAQ8LIAMgARArC0EACyAAIABBxAAgARDyCBogACgCDCIAQQA2AhwgAEEAOgATC7UCBAF/AX8BfwF/IAEtAB5BAXEEQCACRQRAIAAgAUF7EKoKIAAQvQsiA0HfADoAACAAQeEAIAMoAgQgAygCCCADKAIMENsIGg8LIABB3wAgAiABLgEkEIoDGiAAIAFBexCqCg8LAkAgASgCDCIEDQAgATIBIkIBfBBIIgQEQANAIAEuASIgA0wEQANAAkAgBCAFakEAOgAAIAVBAEwNACAEIAVBAWsiBWosAABBwgBIDQELCyABIAQ2AgwMAwUgASgCBCADQQxsaiIGLQAKQSBxRQRAIAQgBWogBi0ABToAACAFQQFqIQULIANBAWohAwwBCwALAAsgACgCABCVAQ8LIAQQ7xVB/////wNxIgMEQCACBEAgAEHgACACIANBACAEIAMQ9AgaDwsgAEF/IAQgAxC9CgsLOwIBfwF/A0ACQCAALQAAIgJBIkcEQCACDQEgAUECag8LIAFBAWohAQsgAEEBaiEAIAFBAWohAQwACwAL/AEFAX8BfwF/AX8BfyABKAIAIQMDQAJAIAIgBGotAAAiBUUNACAFQcCkA2otAABBBnFFIAVB3wBHcQ0AIARBAWohBAwBCwsCfwJAIAItAABBOmtBdUsNACAFIAIgBBDDAyIGQTtHcg0AQQAgBA0BGgsgACADakEiOgAAIANBAWohA0EBCyEHQQAhBANAIAIgBGoiBS0AACIGBEAgACADaiAGOgAAIANBAWohBiAFLQAAQSJHBH8gBgUgACAGakEiOgAAIANBAmoLIQMgBEEBaiEEDAELCyAHBEAgACADakEiOgAAIANBAWohAwsgACADakEAOgAAIAEgAzYCAAtIAQF/IwBBIGsiAyQAIAMgADYCACADIAI7ARQgA0EBIgBBzABqNgIIIANBzgA2AgQgAyABELIJGiADLwEUIQAgA0EgaiQAIAALWwIBfwF/IwBBIGsiAiQAIAAtANQBIQMgAkIANwIUIAJCADcCDCACQc8ANgIIIAJBzAA2AgQgAiAANgIAIABBAzoA1AEgAiABELIJGiAAIAM6ANQBIAJBIGokAAtBAwF/AX8BfyMAQRBrIgIkACABIAAoAgAoAoQBIgRKBEAgAiAENgIAIABBuOkCIAIQsgJBASEDCyACQRBqJAAgAwssAQF/IAAgACgCBEGAgYAgQYCAgCAgACgCCCIBLQAAQSJGG3I2AgQgARD0CQshACAAQdyVARBtRQRAQYCAgIABDwsgAEGemgEQbUVBHXQLJwEBfyABIAEvAQoiAkEBcjsBCiACQeAAcQRAIABBtckBQQAQsgILCyMAA0ACQCAARQ0AIAAtAAVBIHFFDQAgACgCDCEADAELCyAACzMAAkACQAJAIAAtAABB8QBrDgUAAgICAQILIAAoAgwiAC0AAEH1AEcNAQsgAEE7OgAACwuQAQQBfwF/AX8BfyAAIAFBAnRBB2pBeHEiBSABIAFBAXQiBGogBEECaiIGakEHakF4cWpByABqIgcgAmqsEMUCIgIEQCACIAE7ATQgAiACQcgAaiIANgIgIAIgAUEBazsBMiACIAAgBWoiATYCCCACIAEgBmoiATYCBCACIAEgBGo2AhwgAyACIAdqNgIACyACC4IGCwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEEQayIMJAAgASgCDCEGIAAgACgCKCIJQQJqNgIoAkAgAEEbIAEoAgBBACAAKAIAIgMoAhAgAyABKAIYEPwCIgVBBHRqKAIAEPkIDQAgABDwCCIDRQ0AIAIhCiACQQBIBEAgASgCLCEKCyAAIAEQvAohByAAIAAoAigiCEEBajYCKCABLwEyIQQgBwRAIAcgBygCAEEBajYCAAsgA0H3ACAIQQAgBCAHQXgQ9AgaIAAgCSAFIAZB8AAQ9QggA0EkIAlBABCKAyEEIAAQlQkhBiAAKAJ4IgsgACALG0EBOgAUIAAgASAJIAZBACAMQQxqQQBBABCVCxogA0GLASAIIAYQigMaIAAgDCgCDBCWCyADQScgCSAEQQFqEIoDGiADKAJsIQsgAygCAC0AVwR/QZCCCAUgAygCaCAEQRhsagshDSAJQQFqIQQgDSALNgIIIAJBAEgEQCADQZEBIAogBRCKAxoLIANB8QAgBCAKIAUgB0F4EPQIGiADKAJsIgVBAEoEQCADKAJoIAVBGGxqQRZrIAJBG3ZBEHFBEXM7AQALIANBIiAIQQAQigMhBwJAIAEtADYEQCADQQEQ+AghBSADKAJsIQIgA0GEASAIIAUgBiABLwEyEP8CGiAAQQIgARCIDEEAIQsgAygCbCEKIAMoAgAtAFcEf0GQgggFIAMoAmggBUEYbGoLIgUgCjYCCAwBCyAAKAJ4IgIgACACG0EBOgAVIAMoAmwhAgsgA0GFASAIIAYgBBDbCBogAS0AOEEEcUUEQCADQYkBIAQQ8ggaCyADQYoBIAQgBhCKAxogAygCbCIBQQBKBEAgAygCaCABQRhsakEWa0EQOwEACyAAIAYQlgkgA0ElIAggAhCKAxpBACEBIAMoAmwhACADKAIALQBXBH9BkIIIBSADKAJoIAdBGGxqCyIBIAA2AgggA0H6ACAJEPIIGiADQfoAIAQQ8ggaIANB+gAgCBDyCBoLIAxBEGokAAsSACAAKAI8QThqIAAoAgAQhQMLWQIBfwF/IAAQ8AghBiACQQJGBEAgACgCeCIHIAAgBxtBAToAFQsgBkHGACABIAJBACADIAQQ9AgaIAYoAmwiAkEASgRAIAYoAmggAkEYbGpBFmsgBTsBAAsLPgEBfyABQX9zIQIgACgCDCIBKAI4IAEoAjxqQQBIBEAgASAAIAIQxQsPCyABKAJAIAJBAnRqIAAoAmw2AgALqAEGAX8BfwF/AX8BfwF/IAAoAgAoAhAoAhwiBUEwaiEAIAEoAjghAgNAIAIhBAJAAkADQCAAKAIAIgBFDQICQCAAKAIIIgIoAhgiAyABKAI8IgZHDQAgAigCBCIHRQ0AIAcgASgCABBtDQAgAyAFRw0CIAItAAoNAgsgAi0ACEGWAUcNAAsgASgCACEDIAIgBjYCGCACIAM2AgQLIAIgBDYCIAwBCwsgBAsOACABBEAgACABEI8DCwtrAQF/AkACQEHQ7gUoAgAiA0UNAEGsAiADEQEARQ0AIAAoAgAQlQEMAQsgACgCAEIMEF0iA0UNACADIAAoAoQBNgIAIAAgAzYChAEgAyABNgIIIAMgAjYCBCACDwsgACgCACACIAERBgBBAAu6AQEBfyMAQSBrIgMkAAJAIAAoAgAtAFcNACABLQAEQYABcQ0AIANB0AA2AgQgAyAANgIAIAAtABYEQCADQQA2AgwgA0HRADYCCCADIAEQsQkaCyADQQA7ARQgA0E5NgIMIANB0gA2AgggAyABELEJGiAAKAIkDQAgACABIAIQ8gsgACgCJA0AIAMgADYCACADQQEiAEHSAGo2AgwgA0E9NgIIIANB0AA2AgQgAyABELEJGgsgA0EgaiQAC5EBBAF/AX8BfwF/IAEoAgAiAkEAIAJBAEobIQVBACECAkADQCACIAVGDQECQAJAIAEgAkEGdGoiA0EIaiAARg0AIAAoAhAgAygCGEYEQCAAKAIMIAMoAhQQbEUNAgsgAygCHCIDRQ0AIAMtAAVBCHFFDQAgACADKAIgEJIKDQELIAJBAWohAgwBCwtBASEECyAEC4UECgF/AX8BfwF/AX8BfwF+AX8BfwF+IwBBQGoiBCQAAkAgAC0AEA0AIAAoAgAhByAAKAIIIQYDQCABIgUoAjQiAQ0ACyAFKAIgIQogBSgCHCEFIABBAToAECAHKQMgIQggBiAFKAIAEIYLIAhCxACDIQsgCEIEgyEIQQAhAQNAIAEgBSgCACICTkUEQCAFIAFBBHRqIgIoAgghCQJAAkAgAigCDCIDRQ0AIAItABFBA3ENACAGIAFBACADQX8QhwsMAQsCQCALUA0AIAktAABBpwFHDQAgCSgCLCECAn8CQCAJLgEgIgNBAE4NAEEAIQkgAi4BICIDQQBODQBBjq0BDAELIAIoAgQgA0H//wNxQQxsaigCAAshAyAIUEUEQCACKAIAIQIgBCADNgIUIAQgAjYCEEEBIQIgBiABQQAgB0Hp1gAgBEEQahD9AkECEIcLDAILIAYgAUEAIANBfxCHCwwBCyAGIAFBAAJ/IANFBEAgBCABQQFqNgIAIAdB/bgBIAQQ/QIMAQsgByADEKABCyICQQIQhwsLIAFBAWohAQwBCwsgACgCCCEDQQAhASAEQQA2AiQgBCAANgIYIAQgCjYCHANAIAEgAk4NASADIAFBASAEQRhqIAUgAUEEdGooAggQhAxBfxCHCyABQQFqIQEgBSgCACECDAALAAsgBEFAayQACwQAQQALzAEDAX8BfwF/AkAgASgCBEGAgAVxDQAgASgCKCICRQ0AIAEuASIhAyAAKAIAIgQoAgAhACABLQAAQagBRwRAIAIoAhggA0wNASACKAIUIANBBHRqKAIEIAFHDQEgACABQQAQpAkiAUUNASAEIAEQgwsNASACKAIUIANBBHRqIAE2AgQMAQsgAigCJCADTA0AIAIoAiAgA0EYbGooAgAgAUcNACAAIAFBABCkCSIBRQ0AIAQgARCDCw0AIAIoAiAgA0EYbGogATYCAAtBAAtHAQF/IwBBEGsiAiQAAkAgAS0AAEGoAUcNACABKAIoDQAgACgCACEAIAIgASgCCDYCACAAQY36AiACELICCyACQRBqJABBAAvPAQYBfwF/AX8BfwF/AX8jAEEQayIIJAACQCACRQ0AIAEEQCABKAIAIQYLA0AgBSACKAIATg0BIAAoAgAiBCACIAVBBHRqIgkoAghBABCkCSEHIAQtAFdFBEACQCADRQ0AIAcQpQsiBCAIQQxqEMkKRQ0AIARB+QA6AAAgBEEANgIIIAQgBCgCBEH/7///fHE2AgQLIAAgASAHEMIJIgEEQCABIAUgBmpBBHRqIAktABA6ABALIAVBAWohBQwBCwsgBCAHEDMLIAhBEGokACABC30DAX8BfwF/AkAgACABckUNAEEBIQMgAEUgAUVyDQAgACgCACABKAIARw0AA0AgACgCACAETARAQQAPCyAAIARBBHQiA2oiBS0AECABIANqIgMtABBHBEBBAQ8LIARBAWohBEEAIAUoAgggAygCCCACEPgKIgNFDQALCyADC4kBAgF/AX8jAEFAaiIGJAAgBkEANgI0IAZCADcCLCAGQQA2AhggBSgCACEHIAYgBDYCFCAGIAI2AgwgBiABNgIIIAYgBzYCECAGQQEiBEHTAGo2AiggBkHVADYCJCAGIAA2AiAgBiAGQQhqNgI4IAZBIGogAxCzCRogBSAGKAIQNgIAIAZBQGskAAt5BAF/AX8BfwF/AkAgAUUNACABQQhqIQIgASgCACEFA0AgAyAFTg0BAkAgAigCKEEATg0AIAAgACgCKCIEQQFqNgIoIAIgBDYCKCACKAIUIgRFDQAgACAEKAIgEJoKIAEoAgAhBQsgAkFAayECIANBAWohAwwACwALCxEAIAAgACgCEEEBajYCEEEACw8AIAAgACgCEEEBazYCEAsrAAJAIAEtAABBqAFHDQAgACgCECABLQACIgBKDQAgASAAQQFqOgACC0EAC58BAgF/AX8jAEEgayIDJAACf0EAIAAQpQsiAEUNABoCQCAALQAAIgRBM0cEQANAIARBLEcNAkEBIAAoAgwgASACEJ4KDQMaIAAoAhAiAC0AACEEDAALAAsgACgCDCEACyADIAE2AhggA0IANwMIIANB1gA2AgQgA0EAOwEUIAMgAkEARzsBFiADIAAQsgkaIAMvARQLIQAgA0EgaiQAIAAL3QEDAX8BfwF/IAFBAEghBQNAAkAgAAJ/AkAgAARAIAAoAgQhAyAFDQEgA0EBcUUNAyAAKAIkIAFHDQMgA0F8cUECcgwCCw8LIANBfHELIgM2AgQLAkAgAC0AACIEQawBRwRAIARBpwFHIAJyDQEgACgCHCABRw0BIAAgA0H///9+cTYCBAwBC0EAIQMgACgCFCIERQ0AA0AgAyAEKAIATg0BIAQgA0EEdGooAgggASACEJ8KIANBAWohAyAAKAIUIQQMAAsACyAAKAIMIAEgAhCfCiAAKAIQIQAMAAsAC2UBAX8jAEEQayIEJAACQCAALQDTAUECRw0AIAQgAzYCDCAAKAIAIAIgAxCzASEDIAAoAggiAkG8ASACKAJsIgIgACgC4AFBACADQXoQ9AgaIAFFDQAgACACNgLgAQsgBEEQaiQAC9UMDQF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/IwBBEGsiDyQAIAQEQCAELQABIRALIAUoAgQhDSAFLQAAIQ4gACgCCCEIIAMEQCADQQAgAygCABshCwsgCyAQckUEQCAIIAEoAgwgBhCkCgsgASgCHCgCACEKAkACfyAFKAIMIglFBEAgBQJ/IAtFBEAgACgCLAwBCyALKAIAKAIAIAstACBBAXFFaiIRIAAoAixqCyIDQQFqIgk2AgwgAEEsagwBCyAAKAIsIgMgCSAKak4NASAAQSxqCyIMIAMgCmo2AgALIAUgCjYCEEEAIQMCQAJAIAJBAE4EQCAKQQAgCkEAShshDANAIAMgDEYNAiAIQd4AIAIgAyADIAlqENsIGiAPIAEoAhwgA0EEdGooAgw2AgAgCEGz7gAgDxDzCCADQQFqIQMMAAsAC0EBIRMCQCAOQQlrQQJJDQAgDkEDRg0BIA5BDUYNAEEAIRMLAkAgC0UgEHIgDkEMRiAOQQ5GcnJFBEAgCygCBCEDA0AgCygCACICKAIAIANKBEAgAiADQQR0ai8BFCICBEAgASgCHCACQQR0aiADQQFqIgMgCygCBGs7AQQMAgUgA0EBaiEDDAILAAsLIAEoAhwiFCgCACIDQQAgA0EAShshEiAJIQJBACEDA0AgAyASRkUEQEEAIAIgFCADQQR0ai8BFCIMGyECIANBAWohAyAKIAxBAEdrIQoMAQsLIBNBDHIhEwwBCyAJIQILIA8gEzoADCAPIAk2AgggASgCCEUgE0EIcUVyIBFBAExyRQRAIAsgD0EIajYCJEEAIQIMAgsgACABIA9BCGoQsgwMAQsgCSECCwJAIBBFDQAgACAELQABIgMgACADIAQoAgQgBiABKAIcIAkQswwgBCgCCBDACiALDQAgCCABKAIMIAYQpAoLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgDkEBaw4PAAEFCQIICAIHBgQCBwIDCQsgCEHhACAJIAogABCVCSIDENsIGiAIQYoBIA0gAyAJIAoQ/wIaIAAgAxCWCQwICyAIQYwBIA0gCSAKENsIGgwHCyAIQeEAIAkgCiAAIBFBAWoiDBDDCiIDIBFqIgUQ2wgaIA5BBUYEQCAIQR0gDUEBaiISIAgoAmxBBGogA0EAEP8CGiAIQYoBIBIgAyAJIAoQ/wIaCwJAIAsEQCAAIAsgASAFIAJBASARELQMDAELIAhB/wAgDSAAEJUJIgkQigMaIAhBgAEgDSADIAkQ2wgaIAgoAmwiAkEASgRAIAgoAmggAkEYbGpBFmtBCDsBAAsgACAJEJYJCyAAIAMgDBDECgwGCyALDQcgBSgCCCEDIAAQlQkhAiAIQTIgCSAHEIoDGiAIQeEAIANBH3YiDCAJaiAKIAxrIAIQ2wgaIANBAEgEQCAIQYABIA0gAiAJENsIGgwHCyAIQYoBIA0gAiAJIAMQ/wIaDAYLIAsNBiAIQeEAIAkgCiAAEJUJIgMgBSgCFCAKEPQIGiAIQYoBIA0gAyAJIAoQ/wIaIAAgAxCWCQwFCyAIQccAQQEgDRCKAxoMAwsgCw0EDAMLIAsNAyAOQQ1GBEAgCEEMIAUoAgQQ8ggaDAMLIAhB1AAgCSAKEIoDGgwCCyAFKAIYIgUoAgAhDCAAEJUJIRIgDCAAIAxBAmoiFBDDCiICaiIQQQFqIQNBACEEIA5BBkciDkUEQCAIQR0gDUEBakEAIAkgChD/AiEECyAIQeEAIAkgCiADENsIGgJAIA4NACAIQYoBIA1BAWogAxCKAxogCCgCbCIDQQBMDQAgCCgCaCADQRhsakEWa0EQOwEAC0EAIQMgDEEAIAxBAEobIQwgCUEBayEJA0AgAyAMRkUEQCAIQdEAIAkgBSADQQR0ai8BFGogAiADahCKAxogA0EBaiEDDAELCyAIQf4AIA0gEBCKAxogCEHhACACIBQgEhDbCBogCEGKASANIBIgAiAUEP8CGiAEBEBBACEJIAgoAmwhAyAIKAIALQBXBH9BkIIIBSAIKAJoIARBGGxqCyIJIAM2AggLIAAgEhCWCSAAIAIgFBDECgsgCw0CCyABKAIIIgNFDQEgCEE9IAMgBxCKAxoMAQsgACALIAEgCSACIAogERC0DAsgD0EQaiQAC8wCBQF/AX8BfwF/AX8jAEEQayIHJAACQCABKAIIDQAgASgCPCIFRQ0AIAAgACgCLEEBaiIGNgIsIAEgBjYCCCAAEPAIIQMCQCAFKAIMIgQgB0EMahDJCgRAIANBxwAgBygCDCIEIAYQigMaIANBhPMAQQAQ8wggBEUEQCADIAIQ+AgaDAILIARBAEgNASABLgECIAStEJsEIgJMDQEgASACOwECIAEgASgCBEGAgAFyNgIEDAELIAAgBCAGEPcIIANBDSAGEPIIGiADQYTzAEEAEPMIIANBESAGIAIQigMaCyAFKAIQIgJFDQAgASAAKAIsIgRBAWoiBTYCDCAAIARBAmoiATYCLCAAIAIgBRD3CCADQQ0gBRDyCBogA0EAIgBBl/MAakEAEPMIIANBoAEgBiABIAUQ2wgaIANB99cBQQAQ8wgLIAdBEGokAAvWAQkBfwF/AX8BfwF/AX8BfwF/AX8CQCAAKAIAIgggASgCMCIFBH8gBSgCAAVBAAsiAkEBakEBEM0KIgRFDQAgAkEAIAJBAEobIQkDQCADIAlGDQECQCAFIANBBHRqIgYiCkEIaigCACIHLQAFQQJxBEAgACAHEOsIIQIMAQsgACABIAYvARRBAWsQzgoiAkUEQCAIKAIIIQILIAogACAHIAIoAgAQ+As2AggLIAQgA0ECdGogAjYCFCAEKAIQIANqIAYtABA6AAAgA0EBaiEDDAALAAsgBAsjACABQQBKBEAgAEE7IAEgAkEBENsIGiAAQf3XAUEAEPMICwueAQIBfwF/A0ACQAJAIAFFDQAgACgCFCABKAIEcQ0AIAEtAAAiAkEsRg0BIAJBNUcNACABKAIMIQICQCABKAIQIgMtAABBpwFHDQAgACgCACACEMoJRQ0AIAAgAyACIAEQvAwLIAItAABBpwFHDQAgACgCACADEMoJRQ0AIAAgAiADIAEQvAwLDwsgACABKAIQEKUKIAEoAgwhAQwACwALegIBfwF/AkACQCAAKAIYIgAoAhBFDQAgAS0AAEEtayIDQQxLDQBBASECQQEgA3RBgT5xRQ0AIAAgASgCDEEAEL0MGiAAKAIELQAADQEgASgCDBDkCUHCAEYNACAAIAEoAhBBABC9DBoLIAAgASAAKAIQEL0MIQILIAILLgEBfyMAQRBrIgEkACABQQA2AgwgACABQQxqEIQLIAEoAgwhACABQRBqJAAgAAugBAYBfwF/AX8BfwF/AX8jAEEgayIHJAACQCACRQ0AIAEoAgRBgMCAEHENACADIARBBnRqLQAsQdAAcQ0AAkACQCABKAI0BEAgASEFA0AgBQRAAkACQCAFLQAAQYcBaw4EAQAAAQALQQEhBgsgBSgCRA0EIAUoAjQhBQwBCwsgBkUNASABIQgDQCAIRQ0CIAgoAhwhBkEAIQUDQCAGKAIAIAVKBEAgACAGIAVBBHRqKAIIEOsIIgkEQCAJKAIMQRJHDQYLIAVBAWohBQwBCwsgCCgCNCEIDAALAAsgASgCRCIFRQ0AIAUoAghFDQELQQAhBSABKAI8DQEDQCACLQAAQSxHRQRAIAAgASACKAIQIAMgBBCoCiAFaiEFIAIoAgwhAgwBCwsgAiADIARBARCKDEUNASABIAEoAgRBgICACHI2AgQgBUEBaiEJIAMgBEEGdGoiCkEwaiEDA0AgAUUEQCAJIQUMAwsgACgCACACQQAQpAkiBEF/QQEQnwogByAANgIIIAooAjAhBiAHQQA2AhQgByAGNgIQIAcgBjYCDCAHIAEoAhw2AhggByABENcKNgIcIAdBCGogBBCLDCEEAkAgASgCRCIGRQ0AIAAgBCAGKAIIEIwMDQAgACgCACAEEDMMAwsgAUEsQSQgASgCBEEIcRtqIgYgACAGKAIAIAQQzgk2AgAgASgCNCEBDAALAAtBACEFCyAHQSBqJAAgBQuLAQMBfwF/AX8CQCAAKAIAIAEoAgAiBCACayADQQFqEM0KIgNFDQAgBCACIAIgBEgbIQUgASACQQR0akEIaiEEIAIhAQNAIAEgBUYNASADIAEgAmsiBkECdGogACAEKAIAEI0MNgIUIAMoAhAgBmogBC0ACDoAACAEQRBqIQQgAUEBaiEBDAALAAsgAws6AQF/IAAoAgAiAy0AVwRAIAMgAiABEJEHDwsgACgCaCAAKAJsQRhsakEYayIAIAE2AhAgACACOgABC4xbOwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX4BfwF+AX8BfwF/AX8BfgF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEHQAWsiECQAIAAoAgghCSAAKAIAIR4gEEEANgJsIBBCADcCZCADBEAgBkH//QNxIAYgAygCAEE/SiIIGyEGQQAgAyAIGyEVCwJAAkAgASgCACIDQcEATgRAIBBBwAA2AgAgAEH8gwEgEBCyAgwBCyAeQdgGQQEgAyAGQSBxGyISQeAAbCIDQf8FakF4cSASQQFMGyIIQcgAaq0Q7AIhCyAeLQBXBEAgHiALEDIMAQsgCyAENgIMIAsgFTYCCCALIAE2AgQgCyAANgIAIAsgEjoALCALQn83AhQgACAAKAI4QQFrIhM2AjggCyAHOwEqIAsgBjsBKCALIBM2AiAgCyATNgIcIAAuAZQBIRMgCyAFNgIQIAsgEzYCJEEAIRMgC0EtakEAQSMQ5xQhCiALQfgFaiINQQAgA0HIAGoQ5xQaIAtCgICAgNBzNwL0AyAQIAggC2oiAzYCYCAQIAtB0ABqIiU2AlwgECALNgJYIANBAzsBMCADQQA7ASwgAyADQTxqNgI0IANBADYCKCALQQA6AFkgC0EANgJkIAtBADYCVCALIAtB8ABqNgJoIAtCgICAgIABNwJcIAsgCzYCUCAlIAJBLBCODAJAIBIEQANAIAEgE0EGdGoiAyIsQTBqIgwoAgAhCCALIAsoAvQDIgJBAWo2AvQDIAsgAkECdGogCDYC+AMCQCADLQAtQQRxRQ0AIANBQGsoAgAiDkUNACADIjZBLGohFiADKAIYIQggAyItQThqIQ9BACEDQQAhCgNAIAogDigCAE4NASADIAguASIiAiACIANIGyECAkADQCACIANGDQEgCCgCBCADQQxsai0ACkECcUUEQCADQQFqIQMMAQsLIAAoAgBBpwFBAEEAEKAJIgJFDQIgLCgCMCEiIAIgCDYCLCACIAM7ASAgAiAiNgIcIC0gLSkDOCACEPALhDcDOCAAQTUgAiAAQa0BIAAoAgAgDiAKQQR0aigCCEEAEKQJQQAQoQkQoQkiAiAsKAIwQQFBAiA2LQAsQRhxGxDWCiAlIAJBARCPDBogCkEBaiEKIANBAWohAwwBCwsgCCgCACEDIBAgCjYCVCAQIAM2AlAgAEHVvAEgEEHQAGoQsgILIBNBAWoiEyABKAIASA0ADAILAAsgFQRAIAogFSgCADoAAAsCQCAGQYACcUUNACAeLQBQQRBxDQAgC0EBOgAvCyALKAIQIgNFDQAgAy0ABUEEcQ0AIABBAEG2zgFBABCgCgsgASAlEJAMAkAgBUUNACAFKAI8RQ0AICUgBRCRDAsCQAJAAkACQCAAKAIkDQAgC0HwA2ohBSAQIi5B+ABqIRMgECI3QYgBaiEMICUhCEEAIQMDQCADIAgoAhRORQRAAkAgCCgCGCADQTBsaiIILQAKQQJxDQAgCCkDKEIAUg0AIAgoAgAhAiASBEAgLkIANwN4IBBCADcDgAEgN0EANgKIASAuQQEiCkHMAGo2AnggEEIANwNwIBBB1wA2AnQgEEEBOwGEASAQQfAAaiACELIJGiAQLwGEAUUNAQsgAi0ABEECcQRAIAEtACxBwABxDQELIAAgAiALKAIgQRAQwgogCCI4QQpqIgggOC8BCkEEcjsBAAsgA0EBaiEDIBAoAlwhCAwBCwsCQCAGQYACcUUNACAeLQBQQRBxBEAgCyALLwEoQf/9A3E7ASggBkH//QNxIQYMAQsCQCABKAIAQQFHDQAgBCgCACIDQQAgA0EAShshAiABKAIYIRMgASgCMCEMQQAhAwJAA0AgAiADRwRAAkAgBCADQQR0aigCCBClCyIIRQ0AAkAgCC0AAEGnAWsOAwABAAELIAgoAhwgDEcNACAILgEgQQBIDQMLIANBAWohAwwBCwsgE0EIaiEDA0AgAygCACICRQ0CAkAgAi0ANkUNACACKAIkDQBBACEKA0ACQCAKIAIvATJPDQAgJSAMIApCf0ECIAIQkwxFBEAgAigCICAKQQJ0aigCACEOQQAhAwNAIAMgBCgCAE4NAgJAAkAgBCADQQR0aigCCCITEKULIghFDQACQCAILQAAQacBaw4DAAEAAQsgCC8BICACKAIEIApBAXRqLwEARw0AIAgoAhwgDEcNACAAIBMQjQwoAgAgDhBtRQ0BCyADQQFqIQMMAQsLIAIgChCUDEUNAQsgCkEBaiEKDAELCyAKIAIvATJGDQILIAJBFGohAwwACwALIAtBAToALwwBCyAVDQAgCyAENgIIIAsgCy8BKEGAAXI7ASgLAkAgEkEBRw0AIBAoAlgiAi0AKEEgcQ0AIAIoAgQiDCgCGCIILQArQQFGDQAgDC0ALUEDcQ0AIAwoAjAhDiAQKAJgIgpBADsBLiAKQQA2AiggEEHwAGogAkHQAGoiFiAOQX9BggFBABCVDCEDAkAgCgJ/AkADQCADBEAgAykDIFANAiAQQfAAahCWDCEDDAELCyAIQQhqIQMDQCADKAIAIghFDQMCQCAILQA2RQ0AIAgoAiQNACAILwEyIgNBA0sNAEGCAUECIAgtADdBCHEbIQ9BACETAkADQCATIANB//8DcSIDTw0BIBBB8ABqIBYgDiATIA8gCBCVDCEDAkADQCADRQ0BIAMpAyBQRQRAIBBB8ABqEJYMIQMMAQsLIAooAjQgE0ECdGogAzYCACATQQFqIRMgCC8BMiEDDAELCyAILwEyIQMLIAMgE0cNAEGBJCEPIApBgSQ2AigCQCAILQA3QSBxRQRAIAgpA0AgDCkDOINCAFINAQtBwSQhDyAKQcEkNgIoCyAKIBM7ARggCiATOwEsIAogCDYCIEEnDAMLIAhBFGohAwwACwALQYEiIQ8gCkGBIjYCKCAKKAI0IAM2AgAgCkEBOwEYIApBATsBLEEhCyIDOwEUDAMLIAooAigiDw0CCyAQKAJYIgMoAgAoAgAhIiADKAIEIQggAy0ALCECIBBBoJwBNgJsIAhBCGoiCiACQQZ0aiECIANB8ANqIRMgECgCYCEMQQAhDkEAIRZBACEPAkADQAJAIAIgCk0NACAMIA46ABAgECAQKAJsQegHajYCbCAMIBMgCigCKBCXDDcDCAJ/IBYgCi0AJCIDQeIAcXIEQCAfICiEIR8gA0EEdkEBcSEWQQEgDyADQcAAcRsMAQsgH0IAIA8bIR9BACEWIA9BAEcLIQ9CACEjAkACQAJAAn8gCiIIKAIQLQArQQFGBEADQAJAICMhISAIIgNBQGsiCCACTw0AICFQBEBCACEjIAMtAGRBInFFDQILIBMgAygCaBCXDCAhhCEjDAELCyAQQdgAaiAfICEQmAwMAQtCACEhIBBB2ABqIB8QmQwLIgNFBEAgECgCXC0ACUUEQCAMKQMIICiEISgMAgsgEEHYAGogHyAhEJoMIQMLIAwpAwggKIQhKCADQeUARg0BIAMNBQsgIi0AVw0CDAELQRxBv40BQQAQagsgCkFAayEKIA5BAWohDgwBCwtBACEDCyAiIAwQmwwgAw0AIAtBABCcDCAeLQBXDQAgCygCCARAIAsQnQwgCyALLwEyQQFqwRCcDCAeLQBXDQQLIAstAClBAXFFDQIgCyALLwEyQR5rOwEyDAILIAtFDQMMAgsgCkEBOwEWIAIgCjYCyAYgCkIBNwMIIAJBATsBMiACIA42AvwFIAIoAggiAwRAIAIgAygCADoALQsgAi0AKUEBcQRAIAJBAToALwsgEC0AiQFBAkkNACAKIA9BgICAAXI2AigLAkAgCygCCA0AIB4tACFBEHFFDQAgCxCeDAsgACgCJA0AQn8hHwJAAkAgBEUgBkGACHFyIAstACwiA0ECSXJFBEAgHigCUCIDQYACcQ0BIAsQnwwhHyALLQAsIgMhEgsgA0H/AXFBAkkNASAeKAJQIQMLIANBgIAgcQ0AIAsQoAwLIAsoAgAiAyADLwGUASALLwEyajsBlAECf0EAIAZBBHFFDQAaAkAgCygCyAYiAigCKCIDQYAgcQRAIAEoAhghCEEBIRMMAQtBACAGQQhxRQ0BGkEAIAEoAhgiCC0AK0EBRg0BGiADQYDAAHEEQEEAIAZBEHFFDQIaC0ECIRNBACAeLQBTQQhxDQEaCyALIBM6AC5BACAILQAcQYABcQ0AGkEAIANBwABxRQ0AGiACIANBv39xNgIoIAZBCHELIREgEkEAIBJBAEobIQ8gB0UgBkEgcSIWRXIhIiAeIjlB0wBqIRdBACEMA0AgDCAPRwRAIB4gASANLQA8QQZ0aiIEIjpBGGoiAygCACIKKAI8EPwCIQ4gDSgCUCETAkAgCi0AHUHAAHENACAKLQArIghBAkYNACATKAIoIgJBgAhxBEAgCUGtASAEKAIwQQBBACAeIAoQugdBdRD0CBoMAQsgCEEBRg0AIAJBwABxIBZyBEAgBC0ALEHQAHFFDQELIAstAC4EfyALIAQoAjA2AhRB8QAFQfAACyEIIAAgBCgCMCAOIAogCBD1CAJAIAstAC4NACAKLgEiQT9KDQAgCi0AHEHgAXENACATKAIoQYCAgQJxDQAgBCkDOCEhQQAhCANAICFQRQRAIAhBAWohCCAhQgGIISEMAQsLIAlBfyAIQX0QvQoLIAkoAmwiCEEATA0AIAkoAmggCEEYbGpBFmsgETsBAAsCQCATLQApQQJxRQ0AIBMoAiAhAgJAAkACQAJAIAotABxBgAFxRQ0AIAIvADdBA3FBAkcNACAWDQELIAstAC4EQCA6KAIYQQhqIQMgByEIA0AgAygCACIDRSACIANGcg0DIANBFGohAyAIQQFqIQgMAAsAC0HlACEDIAchCCAiRQ0CIARBCGohFSAAIAAoAigiCEEBajYCKAJAIAItADhBEHFFDQAgOS0AU0EBcQ0AIAAgAiAIIBUQoQwLQfAAIQMgAigCJCISRQ0CIAQtACxBEHENAiAAIAIgEkEAIAggFRCiDAwCCyANIA0oAgQ2AggMAgsgCyAINgIYQfEAIQMLIA0gCDYCCCAJIAMgCCACKAIsIA4Q2wgaIAAgAhDgCgJAIBMoAigiA0EPcUUgA0GCgAJxciADQYCAIHEgA0GAgMAAcXJyDQAgCy0AKEEBcQ0AIAstAC9BAkYNACAJKAJsIgNBAEwNACAJKAJoIANBGGxqQRZrQQI7AQALIBAgAigCADYCQCAJQbPuACAQQUBrEPMICyAOQQBOBEAgACAOEK8JCwJAIAQtACxBEHFFDQAgDSALQhQQowwiAzYCOCADRQ0AIAAgACgCKCIIQQFqNgIoIAMgCDYCACAAIAAoAixBAWoiCDYCLCADIAg2AgQgCUHNAEGAgAQgCBCKAxogACAAKAIsQQFqIgg2AiwgAyAINgIIIAlBywBBACAIEIoDGgJAIAotABxBgAFxRQRAIAlB9gAgAygCAEEBEIoDGiAAKAIAQQFBABDNCiIDRQ0BIANBADYCFCADKAIQQQA6AAAgCSADQXgQqgoMAQsgCUH2ACADKAIAIAoQrwMiAy8BMhCKAxogACADEOAKCyATIBMoAihBv39xNgIoIAtBAzoALyALQQA6AC0LIA1B4ABqIQ0gDEEBaiEMDAELCyALIAkoAmw2AjQgHi0AVw0AIA+tIShCACEjA0ACQCAjIChSBEAgACgCJA0DIAsgI6ciDEHgAGxqIg0iO0HIBmoiAigCACgCKCEDAkAgASANIi9BtAZqLQAAQQZ0aiIILwAtIhNBEHFFDQAgE0EIcQRAIAlBCiAIKAIkIAgoAiAQigMaDAELIAlBDxDxCCEKIAlBCiAIKAIkIAgoAiAQigMaQQAhEyAJKAJsIQggCSgCAC0AVwR/QZCCCAUgCSgCaCAKQRhsagsiEyAINgIICyANQfgFaiEXIANBgICBAnEEQAJAIANBgIABcQRAIAAgJSAfIBcQpAwMAQsgCyAMIBcgHxClDAsgHi0AVw0ECyAAIAEgFyAGEKYMIA0gCSgCbDYCmAYgOygCyAYhCCAAKAIAIRsgDSIqQdAGaiITIB8gBSALKAIEIC8tALQGIgNBBnRqIhYoAjAiFRCXDEJ/hYM3AwAgCykDSCEhIA0iMEGEBmoiDiAAKAI4IgJBAWsiCjYCACANQYgGaiISIAo2AgAgACACQQJrIiI2AjggDSIxQZAGaiAiNgIAICEgI4inIQICQCADRQ0AIBYtACxBCHFFDQAgACAAKAIsQQFqIgM2AiwgFyADNgIAIAlBxwBBACADEIoDGiAJQZWQAUEAEPMICyAWQQhqIQcgAkEBcSEPIAwhAwNAIANBAEwEQEEAIQMMAwsgCyADQeAAbGoiAigC+AUNAiACKAKwBg0CIANBAWshAwwACwALIAsgCSgCbDYCOAwECwJAAkAgFi8ALSIEQSBxBEBBACESIAlBCyAWKAIkIgNBACAWKAIgENsIGiANIAlBDCADIAoQigM2ArwGIBAgFigCGCgCADYCMCAJQcfaACAQQTBqEPMIIA1BCToAtQYMAQsgCCgCKCICQYAIcQRAIAAgCC8BLCIMQQJqEMMKIhRBAmohByAwKAKEBiERQQAhAwNAIAMgDEZFBEACQCAIKAI0IANBAnRqKAIAIgJFDQAgAyAHaiEKIAItAAxBAXEEQCAIKAIkQQEgA3RBACADQSBJG3EEQCAAIAAoAigiDkEBajYCKCAAIAAoAixBAWoiBDYCLCAAIAIoAgAgDhDWCyAJQa8BIA4gCiAEENsIGgwCCyAAIAIgFyADIA8gChCnDBogEigCACERDAELIAAgAigCACgCECAKQQEQqAwgAi0AD0HKAEcNACAILQAcQQJxRQ0AIAlBxwBBACALKAIQKAIMEIoDGiAJQZLzAEEAEPMICyADQQFqIQMMAQsLIAlBxwAgCCgCGCAUEIoDGiAJQccAIAwgFEEBahCKAxogCUEGIBUgESAUIAgoAiBBekF/IAgtABxBAXEbEPQIGiAIIAgtABxB/gFxOgAcIBstAFcEQCAIQQA2AiALIA0gFTYCuAYgDUG7f0E/IAstAC4bOgC1BiANIAkoAmw2ArwGIA0iPEHEBmohFCANIj1BwAZqIRhBACESQQAhAwNAIAMgDEYNAiAIKAI0IANBAnRqKAIAIQ4CQAJAIANBD0sNACAILwEeIAN2QQFxRQ0AIBcgDhCpDAwBCyAOLQAMQQFxRQ0AIAgoAiRBASADdEEAIANBIEkbcQ0AIBstAFcNAEEAIQIgPSgCwAYiCkEAIApBAEobIQ8gAyAHaiERA0ACQCACIA9HBEBBACEKAn8gCSgCAC0AVwR/QZCCCAUgCSgCaCA8KALEBiACQRRsaigCBEEYbGoLIgotAAAiBEGHAUcEQCAEQd4ARw0DIAooAgwgEUcNAyARIQ8gCigCCAwBCyAKKAIIIBFHDQIgCigCDCEPIBELIQIgCSAEIAooAgQgAiAPENsIGgsgAEE1QQBBABChCSECIBstAFdFBEAgDigCACgCDCEKIA4oAhwiDkEASgRAIAooAhQgDkEEdGpBCGsoAgAhCgsgAiAKNgIMIAIgG0GwAUEAEMgJIgo2AhAgCgRAIAogETYCHCAAIAIgMSgCkAZBEBDCCgsgAkEANgIMCyAbIAIQMwwCCyACQQFqIQIMAAsACyADQQFqIQMMAAsACyALIANB4ABsaigChAYhAwJAAkACQCACQYACcUUgAkEFcUVyRQRAIAgoAjQoAgAhCCAAIAAoAixBAWoiAzYCLCADIAAgCCAXQQAgDyADEKcMIghHBEAgACADEJYJCyASKAIAIQMgDSI+QawGaiICKAIABEAgCUENIAggAxCKAxogCUHAACA+KAKsBiADIAhBARD/AhogACALIAwgAyAfEKoMCyAJQR4gFSADIAgQ2wgaIA1BuwE6ALUGDAELIAJBggJxQYICRgRAQQAhDEEAIQ5BACEEIAJBIHEEQCAIKAI0KAIAIQ5BASEECyACQRBxBEAgCCgCNCAEQQJ0aigCACEMCyAOIAwgDxshCAJAIAwgDiAPGyICBEAgCQJ/IAIoAgAiDCgCECIDELkLBEAgABCVCSEDIAAgDCgCECADQQEQqAwgAyEOIAwtAABBAWpBAnFBAXIMAQsgACADIBBB8ABqELULIQ4gFyACEKkMIBAoAnAhAyAMLQAAQTZrCyICQQAiDEGYwwRqai0AACAVIAogDhDbCBogCUGFiQFBABDzCCAAIAMQlgkMAQsgCUEgQSQgDxsgFSADEIoDGgtBACESAkAgCEUEQEG7ASEDQQAhAgwBCyAIKAIAIQMgACAAKAIsQQFqIgI2AiwgACADKAIQIAJBARCoDAJ/AkAgAygCEBC5C0UEQAJAIAMtAABBNmsOAwACAAILQTdBOSAPGwwCC0E4QTYgDxshAwwCC0E4QTYgDxsLIQMgFyAIEKkMCyANIAkoAmw2ArwGIA0gFTYCuAYgDSAPQSdzOgC1BiADQbsBRg0EIAAgACgCLEEBaiIINgIsIAlBhwEgFSAIEIoDGiAJIAMgAiAKIAgQ2wgaIAkoAmwiA0EATA0EIAkoAmggA0EYbGpBFmtB0wA7AQAMBAsgAkGABHEEQCAIIj9BHGohCiANIkBBgAZqIQ4gCC8BGiEaIAgiQUEgaiEEQQAhEUEAIQdBACEUIAgvARgiAyEZIAJBIHEEQCADQQFqIRkgCCgCNCADQQJ0aigCACEUIBohBwsgPy8BHCEYIEAoAoAGIQ4gQSgCICEKAkAgAkEQcUUEQEEAIQIMAQsgByAYSyEEIAgoAjQgGUECdGooAgAiAi0AC0EBcQRAIAAgACgCLEEBaiIZNgIsIA1BpAZqIhEgGTYCACAJQccAQQEgGRCKAxogCUHy8gBBABDzCCANIAkoAmw2AqgGIA0gDSgCpAZBAXQiGTYCpAYgDSAPIAooAhwgA2otAABBAUZzIBlyNgKkBgsgByAYIAQbIQdBACERIBQNAAJAIAooAgQgA0EBdGovAQAiBMEiGUEATgRAIAooAgwoAgQgBEEMbGotAARBD3FFDQEMAgsgGUF+Rw0BC0EBIRELQQAhJ0EAIQQgCCgCKEGwgCBxQYCAIEYEQCAAIAAoAixBAWoiBDYCLCANIAQ2ApwGIBcoAgAEQCAJQccAQQAgBBCKAxoLIAAgACgCOEEBayIHNgI4IA0gBzYCoAZBASERQQEhBwsgAyAKLwE0Tw0CIA8gCigCHCADai0AAEEAR0YNAiAaQf8BcSEZQQAhICARIScgFCERDAMLIAJBgMAAcQRAIAAgACgCKCIgQQFqNgIoIAAgACgCLEEBaiIkNgIsIAAgACgCOEEBayImNgI4IBYoAhghBCAIKAI0KAIAIhgoAhghAiANICQ2ArgGIA1BwwA6ALUGAkAgCy0ALCIIQQJPBEAgGyAIIAxrIgNBBnRBCHKtEOwCIhFFDQcgESADQf8BcSIDNgIAIBEgAzYCBCARQQhqIAdBwAAQ5RQaQQEhA0EBIAggKWoiCCAIQQFMGyEIIAsoAgRBCGohCgNAIAMgCEYNAiARIANBBnRqQQhqIAogFyADQeAAbGotADxBBnRqQcAAEOUUGiADQQFqIQMMAAsACyALKAIEIRELQQAhFEEAIRxBACEdIAstAChBEHFFBEACQCAELQAcQYABcUUEQCAAIAAoAixBAWoiHDYCLCAJQcsAQQAgHBCKAxoMAQsgBBCvAyEDIAAgACgCKCIcQQFqNgIoIAlB9gAgHCADLwEyEIoDGiAAIAMQ4AoLIAAgACgCLEEBaiIdNgIsCyAJQccAQQAgJBCKAyEyQQAhAwJAIAsoAlwiCkECSA0AA0AgAyAKTkUEQAJAIAsoAmggA0EwbGoiCCAYRg0AIAgvAQpBhoACcQ0AIAgvAQxB//8AcUUNACAIKAIAIggtAAZBwABxDQAgACAUIBsgCEEAEKQJEM4JIRQgCygCXCEKCyADQQFqIQMMAQsLIBRFBEBBACEUDAELIABBrIAEQQAgFBChCSEUC0EAIRogAEEBQcriAUEAEKAKQQAhGUEAIQgDQCAIIAIoAgxORQRAAkAgFSACKAIYIAhBMGxqIgMoAhRHBEAgAy0ADUEEcUUNAQsgGyADKAIAQQAQpAkhCgJAIBstAFcNACAKIQMgFARAIBQgCjYCDCAUIQMLIBAgCEEBajYCICAAQQFB8r8BIBBBIGoQoAogACARIANBAEEAQQBBICAgEKsKIgdFDQBBACEDIAAgESAHQfgFakEAEKYMAkAgCy0AKEEQcQ0AQX8gCCAIIAIoAgxBAWtGGyEnIAQtABxBgAFxRQRAIAkgBCAVQX8gHRCSCSAJQS8gHEEAIB0gJxD/AiEDDAELIAAgBBCvAyISLwEyIgwQwwohDwNAIAMgDEZFBEAgCSAEIBUgEigCBCADQQF0ai4BACADIA9qEJIJIANBAWohAwwBCwsCQAJAICdFBEBBACEDDAELIAlBHSAcQQAgDyAMEP8CIQMgJ0EASA0BCyAJQeEAIA8gDCAdENsIGiAJQYoBIBwgHSAPIAwQ/wIaICdFDQAgCSgCbCISQQBMDQAgCSgCaCASQRhsakEWa0EQOwEACyAAIA8gDBDECgsgCUEKICQgJhCKAxogAwRAQQAhDyAJKAJsIQwgCSgCAC0AVwR/QZCCCAUgCSgCaCADQRhsagsiAyAMNgIICyAHLQAwIQNBACEMAkAgBygCyAYiDy0AKUECcUUNACAPKAIgIQ8CQCAIRQRAIA8hGgwBCyAPIBpHDQELIAQtABxBgAFxBEAgGi8AN0EDcUECRg0BCyAaIQwLIANBAnEhDyADQQFxBEAgCyALLQAwQQFyOgAwC0EBIBkgDxshGSAHELQKIAAQzAogDCEaCyAbIAoQMwsgCEEBaiEIDAELCyAAEMwKIA0gGjYCwAYgGgRAIA0gIDYCgAYLIBQEQCAUQQA2AgwgGyAUEKAIC0EAIQggCSgCbCEDIAkoAgAtAFcEf0GQgggFIAkoAmggMkEYbGoLIgggAzYCBCAJIDAoAoQGEPgIGiAJICYQjQogDSAJKAJsNgK8BiALLQAsQQJPBEAgGyAREDULQQAhEiAZDQQgFyAYEKkMDAQLIARBwABxBEAgDUG7AToAtQYMAQsgDSAVNgK4BiANQQAiCEGowwRqIA9qLQAAOgC1BiAJIA9BqsMEai0AACAVIAMQigMhAyANQQE6ALcGIA0gA0EBajYCvAYLQQAhEgwCCyARISAgAiERIBQhAiAYIRkgGiEYCwJAICNQDQAgCC0AKkEQcUUNACAJQYgBIA4Q8ggaC0EAIRogACAXIA8gByAQQfAAahCrDCEHIBAoAnAiFEUgGUVyRQRAIBsgAyAUahCgASEaCyANQaAGaiASIAQbKAIAIRJBASEmQQEhJCACBEAgAi0ADEEocUEARyEkCyARBEAgES0ADEEocUEARyEmCwJAIAIEQCAAIAIoAgAoAhAiHSADIAdqIiAgGBCoDCAJIBcgAhCsDAJAIAItAApBgAFxDQAgHRC6CkUNACAJQTIgICASEIoDGgsgFARAIB0gGCADIBRqEK0MCyADIBhqIRhBASEcQQAhICAdELkLBEBBASEkDAILIBcgAhCpDCAQKAJwIRQMAQsgIARAQQAhJCAJQcsAQQAgAyAHahCKAxpBASEgIANBAWohGEEBIRwMAQsgBEUEQCADQQBHIRxBACEgIAMhGAwBC0EAISAgCUHLAEEAIAMgB2oQigMaQQEhHCADQQFqIRgLIAAgByAYICBrIBQQrgwCQCAILwEuIh1FIBggHUdyRQRAQQAhHQwBCyAEBEAgCUHHAEEBIAQQigMaIAlB2O4AQQAQ8wgLIA0oAqwGIh0EQCAJQcAAIB0gEiAHIAMQ/wIaIAAgCyAMIBIgHxCqDAtBACEdQQRBACAcG0ECQQAgJBtyIA9yIhxBnMMEai0AACEMAkAgCC0AKkEQcUUgHEEGR3INACAJQfwAIAooAgguAQBBCWpBCm0Q8gghHCACIBFyRQRAIBwhHQwBCyAJKAJsIgJBAEoEQCAJKAJoIAJBGGxqQRZrQQE7AQALQQAhMiACQQFqIQIgCSgCAC0AVwR/QZCCCAUgCSgCaCAcQRhsagsiHCACNgIICyAJIAwgDiASIAcgGBD/AhogBEUNACAJQQlBACAJKAJsQQJqEIoDGiAJQQJBBiAYQQJJGyAPckGcwwRqLQAAIA4gEiAHIBggJGsQ/wIaCwJAIBEEQCAAIBEoAgAoAhAiDCADIAdqIgIgGRCoDCAJIBcgERCsDAJAIBEtAApBgAFxDQAgDBC6CkUNACAJQTIgAiASEIoDGgsgGgRAIAwgGSAaEK0MIAAgAiAZIBoQrgwLIAMgGWohAiAMELkLBEBBASEmDAILIBcgERCpDCAQKAJwIRQMAQsgJ0UEQCADIQIMAQsgBEUEQCAJQcsAQQAgAyAHahCKAxpBACEmCyADQQFqIQILIBQEQCAbIBQQOAsgGgRAIBsgGhA4CyANIAkoAmwiDDYCvAYCQCACRQ0AIAQEQCAJQREgBCAMQQNqEIoDGiAJQeLDAEEAEPMICyAJICYgD0EBdHJBpMMEai0AACAOIBIgByACEP8CGiAdRQ0AQQAhESAJKAJsIQwgCSgCAC0AVwR/QZCCCAUgCSgCaCAdQRhsagsiESAMNgIICyAEBEAgCUEQIAQgCSgCbEECahCKAxogCUEAIgxBzMMAakEAEPMIIAkgICAPQQF0ckGkwwRqLQAAIA4gEiAHIAIgIGoQ/wIaCyAIKAIoIgJBgIAQcQRAIAlB/QAgDiADIAMQ2wgaIAgoAighAgsCQAJAIAJBwABxRQ0AIAsvAShBoCBxDQBBASECDAELAkAgCigCDCIMLQAcQYABcUUEQCALKAIAIgMoAgghGyALIAstADBBAXI6ADBBACECIBtBjQEgDkEAIBUQ2wgaIAsvAShBoCBxRQ0CIAMoAngiDCADIAwbKAJYDQIgAygCACAKKAIMIhIyASJCAoZCBHxC/P///w+DEMUCIhFFDQIgESASLgEiNgIAQQEgCi8BNCIDIANBAUwbQQFrIQdBACEDA0AgAyAHRwRAIBIgCigCBCADQQF0ai4BACICEO4KIQwgAkEASARAIANBAWohAwwCBSAMQQJ0IBFqIANBAWoiAzYCBAwCCwALCyAbQX8gEUFyEL0KDAELQQAhAiAOIBVGDQFBACEDIAAgDBCvAyICLwEyEMMKIQwDQCADIAIvATIiEk9FBEAgCUHeACAOIAogAigCBCADQQF0ai4BABDnAiADIAxqENsIGiADQQFqIQMMAQsLIAlBHCAVICIgDCASEP8CGgtBACECCwJAIBcoAgANACAKKAIkIgNFDQAgAyAVICUQrwwLAkACQCAIKAIoIgNBgCBxDQACQCANKALABkUgBHINACAIKAIgIgwtADZFDQAgCC8BLg0AIAgvARgiEiAMLwEyRw0AQQAhDANAIAwgEkYNAiAMQQJ0IQQgDEEBaiEMIAQgCCgCNGooAgAvAQxBgANxRQ0ACwsgDSIzQbUGaiEIIA8EQCAzQSY6ALUGDAILIDNBJzoAtQYMAQsgDUG7AToAtQYLIA0gA0EQdkEBcToAtgYgDSAONgK4BiADQQ9xRQRAIA1BAToAtwYLQQAgCiACGyESCyAWIitBLGohBEEBQQIgEhshFiANIkJBpAZqIREgDSI0QfwFaiEHA0AgCygCXCEIIAsoAmghA0EAIQ4DQCAIQQBMRQRAAkAgAy8BCiICQQZxDQAgKikD0AYiISADKQMog1BFBEAgCyALLQAwQQJyOgAwDAELIAMoAgAhCiArLQAsIgxB2ABxBEAgCigCBCIPQQNxRUEAIAxBCHEgD0EBcRtyDQEgBSAKKAIkEJcMICGDQgBSDQELAkACQCAWQQFGBEAgCiA0KAL8BSASELAMRQRAQQIhDgwECyADLwEKIQIMAQsgFkECSw0BCyACQYAgcUUNACAOQQMgDhshDgwBC0EAIQwCQCACQYAEcUUNACBCKAKkBiICRQ0AIAkgAkEBcUEQciACQQF2EPIIIQwLIAAgCiAiQRAQwgogDARAQQAhCiAJKAJsIQIgCSgCAC0AVwR/QZCCCAUgCSgCaCAMQRhsagsiCiACNgIICyADIAMvAQpBBHI7AQoLIANBMGohAyAIQQFrIQgMAQsLIA4hFiAOQQBKDQALIAsoAmQhCCALKAJoIQMDQCAIQQBMRQRAAkAgAy0ACkEGcQ0AIAMvAQwiAkGCAXFFIAJBgBBxRXINACADKAIUIBVHDQAgKy0ALEHYAHENACADKAIAIQogJSAVIAMoAhggH0GDAUEAEJMMIgJFDQAgAi0ACkEEcQ0AIAIoAgAhDAJAIAItAAxBAXFFDQAgDC0ABUEQcUUNACAMKAIUKAIcKAIAQQFKDQELIBBB8ABqIAxBNBDlFBogECAKKAIMNgJ8IAAgEEHwAGogIkEQEMIKIAIgAi8BCkEEcjsBCgsgA0EwaiEDIAhBAWshCAwBCwsgDSI1QbAGaiIPKAIAIg4EQAJAIAsoAgQgLy0AtAZBBnRqKAIYIgotABxBgAFxRQRAQQEhCCAAQQIQwwohAiAJIAogNCgC/AVBfyACQQFqIgMQkgkMAQtBACEDIAAgChCvAyIMLwEyIghBAWoQwwohAgNAIAMgCEZFBEAgCSAKIBUgDCgCBCADQQF0ai4BACADQQFqIgMgAmoQkgkMAQsLIAJBAWohAwsgCUEdIA4oAgBBACADIAgQ/wIhDCAQIAooAgA2AhAgCUGG2AAgEEEQahDzCCAJQeEAIAMgCCACENsIGiAJQYoBIA4oAgAgAiADIAgQ/wIaIAlBtwEgDigCBEEAIAMgCBD/AhogCSgCbCIDQQBKBEAgCSgCaCADQRhsakEWa0EQOwEAC0EAIQogCSgCAC0AVwR/QZCCCAUgCSgCaCAMQRhsagsiCiADNgIIIAAgAiAIQQFqEMQKCwJAAkACQCAXKAIAIgMEQCANIAkoAmw2ApQGIAlBxwBBASADEIoDGiAJQdI4QQAQ8wggNSgCsAYiAw0BDAILIDUoArAGIgNFDQILIAlBygBBACADKAIIEIoDGiADIAkoAmw2AgwgACAALQAaQQFqOgAaCyALKAJoIQNBACEIA0AgCCALKAJkTg0BAkAgAy0ACkEGcQ0AICopA9AGIAMpAyiDQgBSDQAgKy0ALEHAAHENACAAIAMoAgAgIkEQEMIKIAMgAy8BCkEEcjsBCgsgA0EwaiEDIAhBAWohCAwACwALICopA9AGIR8LIAsgMSgCkAY2AhwgKUEBayEpICNCAXwhIwwACwALIAAgCygCJDsBlAEgHiALELEMC0EAIQsLIBBB0AFqJAAgCws7AQF/IAAoAgAiAi0AV0UEQCACIAAoAmggAUEYbGoiACwAASAAKAIQEJEHIABBADYCECAAQbsBOwEACwtUAgF/AX8jAEEQayICJAAgACgCACEAIAJBADYCDCAAIAEgAC0AVEHDACACQQxqEL0DGiACKAIMIgAEQCAAEFynQQBKIQMLIAAQ9AEgAkEQaiQAIAMLigIEAX8BfwF/AX8gABDwCCIDQccAQQAgABCVCSIFEIoDGgJAIAJBA04EQCADQfUAQQAgABCVCSIGQQBB6Z8DQX8Q9AgaIANBOSAGIAMoAmxBAmogARDbCBogAygCbCIEQQBMDQEgAygCaCAEQRhsakEWa0HTADsBAAwBCyADQQ0gASADKAJsQQJqEIoDGiADKAJsIQQLIAMgAkECdCICQbDDBGooAgAgBSAEQQJqIAEQ2wgaIAMoAmwiAUEASgRAIAMoAmggAUEYbGpBFmtBwwA7AQALIAAoAngiASAAIAEbQQE6ABUgA0HGAEEBQQIQigMaIAMgAkGAjwZqKAIAQX8QqgogACAFEJYJC8ACBAF/AX8BfwF/IAAoAgQhBSAAKAIAEPAIIQIgBSEAA0AgAARAAkACQCAFKAJYDQAgACgCLC0ABUEQcUUNACAALQARQdoARg0AIAJBywBBACAAKAI4EIoDGiACQSAgACgCPBDyCBogAkHeACAAKAI8QQAgACgCOBDbCBpBACEEIAIoAmwhAyACKAIALQBXBH9BkIIIBSACKAJoIANBGGxqQTBrCyIEIAM2AggMAQsgACgCQA0AIAAoAkgoAhQiAwR/IAMoAgAFQQALIQQgACgCNCEDIAEEQCACQaUBIAMgBBCKAxogAiAAKAIsQXkQqgogAkHQACAAKAI0IAAoAjgQigMaIAJBywBBACAAKAI0EIoDGgwBCyACQaQBIAMgBCAAKAI4ENsIGiACIAAoAixBeRCqCgsgACgCJCEADAELCwuZCQ8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8gACgCACEEIAAoAgghAgJAIAAoAgQiBigCWARAIAYoAgwiAQRAIAEoAgAhAwsgBigCPCEFIAQgBCgCOCIBQQJrIgc2AjggBBCVCSEKIAQQlQkhCSADBEAgBCADEMMKIQggBCADEMMKIQsLIAFBAWshDCACQYcBIAYoAjAgChCKAxogACAGKAIwIAgQ7QwgBiEBA0AgAQRAIAJBywBBACABKAI0EIoDGiABKAIkIQEMAQsLIAJBFyAFIAcgBigCWBDbCBogAigCbCEOIAJBhwEgBSAJEIoDGiACQTYgBigCXCAHIAkQ2wgaAkAgBi0AFCIBQcIARg0AIAFB1QBGBEAgAkE1IAogDCAJENsIGgwBC0EAIQcgBigCDCIPBEAgBCAPQQBBABCpCiEHIAYtABQhAQsgAUH/AXFB3gBGBEAgAkE1IApBACAJENsIIQ0LAkAgBwRAIAAgBSALEO0MIAJB2gAgCyAIIAMQ2wgaIAIgB0F4EKoKIAJBDiACKAJsQQFqIgEgDCABENsIGgwBCyACQQlBACAMEIoDGgsgDUUNAEEAIQcgAigCbCEBIAIoAgAtAFcEf0GQgggFIAIoAmggDUEYbGoLIgcgATYCCAsgACAGIAVBACAAKAIUEO4MIAIgDBCNCiACQScgBSAOEIoDGiACKAJsIQECQCACKAIALQBXBEBBkIIIIgUgATYCCAwBCyACKAJoIA5BGGxqIgVBEGsgATYCACAFQRhqIQULIAUgATYCCCAEIAkQlgkgBCAKEJYJIAMEQCAEIAsgAxDECiAEIAggAxDECgsgAEEBEK8KDAELIAYhAQNAIAFFDQFBACEFAkACQCABKAIsIgkoAiAiA0GAwwRHIANBisMER3FFBEAgASgCPCEKIAQgBCgCOEEBayIFNgI4IAQQlQkhAyACQcsAQQAgASgCOBCKAxpBACEIAkAgCSgCIEGAwwRGBEAgAkHeACAGKAIwIAEoAlBBAWogAxDbCBogBCADQQIQrgoMAQsgAkHHAEEBIAMQigMaCyACQeoAIAMgASgCQCADENsIGiACQTYgASgCQEEBaiAFIAMQ2wgaIAJBHiAKQQAgAxDbCBoMAQsgA0HHwgRHIANBzMIER3ENASABKAI8IQogASgCSCgCFCgCACEIIAQgBCgCOEEBayIFNgI4IAQQlQkhAyAGKAIwIQcCQCAIQQJMBEAgAkHLAEEAIAEoAjgQigMaDAELIAJB3gAgByABKAJQQQJqIAEoAjgQ2wgaCyACQYcBIAcgAxCKAxogCSgCICEJAkAgCEEBTARAIAJB1gAgA0EBQX8gCUHHwgRGGxCKAxoMAQsgBBCVCSEIIAJB3gAgByABKAJQQQFqIAgQ2wgaIAJB6gBB6wAgCUHHwgRGGyAIIAMgAxDbCBogBCAIEJYJCyACQR4gCiAFIAMQ2wgaCyACQd4AIAogASgCUCABKAI4ENsIGiACIAUQjQogBCADEJYJCyABKAIkIQEMAAsACyACQQogACgCECAAKAIMEIoDGgtzAgF/AX8gABDwCCEFIAEEQCABKAIAIQYgACABQQBBABCpCiEBIAVB2gAgAyACIAYQ2wgaIAUgAUF4EKoKIAVBDiAFKAJsQQFqIgEgBCABENsIGiAFQdAAIAIgAyAGQQFrENsIGg8LIAVBCUEAIAQQigMaC7cGCQF/AX8BfwF/AX8BfwF/AX8BfyAAKAIIIQQgACgCBCIFLQAQIQcgACgCACIIIAgoAjhBAWsiCTYCOAJAIAFBAkYEQCAFLQARQdoARg0BCwJAAkAgAkEATA0AIAdB/wFxQdkARgRAIAQoAmwhCyABQQJGBEAgBS0AEUHWAEYEQCAAQTcgACgCKCACIAAoAiAgCRCzCgwECyAAQTkgACgCICACIAAoAiggCRCzCgwDCyAAQTYgACgCMCACIAAoAiggCRCzCgwBCyAEQTsgAiAJQQEQ2wgaCyABQQFHDQAgBSgCWA0AIABBABCvCgsgBCgCbCEMAkAgAkUNACAFLQARIAUtABJHDQAgBS0AEEHZAEcNACAIEJUJIQIgCBCVCSEGAkAgBEE5An8gAUECRgRAIARBhwEgACgCICACEIoDGiAEQYcBIAAoAjAgBhCKAxogBgwBCyAAKAIcRQ0BIARBhwEgACgCMCACEIoDGiAAKAIcCyIKIAkgAhDbCBoLIAggAhCWCSAIIAYQlgkLAkACQAJAAkAgAUEBaw4CAAECCyAAKAIsIQogACgCKCECIAAQsAoMAgsgACgCJCEKIAAoAiAhAiAFKAJYIgYEQCAEQdYAIAZBARCKAxoMAgsgACAFIAJBASAAKAIUEO4MDAELIAAoAjQhCiAAKAIwIQIgBSgCWARAIARB1gAgBSgCXEEBEIoDGgwBCyAAIAUgAkEAIAAoAhQQ7gwLAkAgASAAKAIYRwRAIAQoAmwhAQwBCyAEQYIBIAIQ8ggaIAQoAmwiAUEATA0AIAQoAmggAUEYbGpBFmtBAjsBAAsCQAJAIANFBEAgBEEnIAIgAUEBQQIgB0H/AXFBzABGIgcbahCKAxpBACEGIAcNAiAEQQlBACAJEIoDGgwBCyAEQScgAiABQQJqEIoDGiAEQQkQ8QghBiAHQf8BcUHMAEYNAQtBACEHIAAgAgJ/QQAgBSgCDCIDRQ0AGkEAIgEgAygCACIDRQ0AGiAIIAMiBxDDCgsiARDtDCAIIAUoAgwgASAKIAwQsQogCCABIAcQxAoLIAsEQCAEQQlBACALEIoDGgsgBCAJEI0KCyAGC5cECAF/AX8BfwF/AX8BfwF/AX8gACgCACIHEPAIIQYgACgCBCgCDCEMIAcQlQkhCCAHEJUJIQkgByAHKAIsQQFqIgo2AiwgByAHKAI4QQFrIgs2AjggACACIAgQ7QwgACAEIAkQ7QxBN0E4QTkgAUE2RhsgAUE5RhsgASAMLQAQIgRBAXEiAhshACAEQQJxBEAgBkEzIAgQ8gghDQJAAkACQAJAIABBNmsOBAECAwADCyAGQQlBACAFEIoDGgwCCyAGQTMgCSAFEIoDGgwBCyAGQTIgCSAFEIoDGgsgBkEJQQAgCxCKAxpBACEEIAYoAmwhASAGKAIALQBXBH9BkIIIBSAGKAJoIA1BGGxqCyIEIAE2AgggBkEyIAkgCyALIAUgAEE5RhsgAEE2RhsQigMaC0HrAEHqACACGyEBIAZB9QBBACAKQQBB6Z8DQX8Q9AgaIAZBOSAKQQAgCBDbCCEEIAJFIgogAEE5RnFBASAKIABBN0dyGwRAIAYgACAJIAUgCBDbCBoLIAYgASADIAggCBDbCBpBACEKIAYoAmwhASAGKAIALQBXBH9BkIIIBSAGKAJoIARBGGxqCyIKIAE2AgggBiAAIAkgBSAIENsIGiAGIAcgDCgCCBCNDEF+EKoKIAYoAmwiAEEASgRAIAYoAmggAEEYbGpBFmtBgAE7AQALIAYgCxCNCiAHIAgQlgkgByAJEJYJC8ARGwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQRBrIg0kACAALQAsIQEgACgCBCEQIAAoAgAiCSgCACEOIAkoAggiAygCbCERA0AgAUEASgRAIAAgAUEBayILQeAAbGoiBCIXQbAGaiISKAIAIgIEQCADIARBkAZqIgYoAgAQjQogBEEANgKQBiACIAMoAmw2AhAgA0HDACACKAIIIAIoAgxBARDbCBogCkEBaiEKCyAEKALIBiEHAkAgBCIPQbUGaiIMLQAAQbsBRwRAQQAhAgJAIAAtAC9BAkcNACABIAAtACxHDQAgBy0AKUECcUUNACAHKAIgIgEtADdBgAFxRQ0AIAcvAR4iBkUNACABKAIIIAZBAXRqLgEAQSRIDQAgCSgCLEEBaiECIAQiE0GABmohBUEAIQEDQCABIAZGRQRAIANB3gAgEygCgAYgASABIAJqENsIGiABQQFqIQEMAQsLIAkgBiAJKAIsakEBajYCLCADQRVBGCAPLQC1BkEmRhsgEygCgAZBACACIAYQ/wIhAiADQQlBASAEKAK8BhCKAxoLIAQoApAGIgEEQCADIAEQjQoLIAMgDy0AtQYgBCgCuAYgBCIYQbwGaiIBKAIAIAQtALYGENsIGiADKAJsIgZBAEoEQCADKAJoIAZBGGxqQRZrIAQtALcGOwEACyAEIhlBnAZqIgYoAgAEQCADIAQoAqAGEI0KIANBPSAZKAKcBiAYKAK8BkEBaxCKAxoLIAJFDQFBACEGIAMoAmwhASADKAIALQBXBH9BkIIIBSADKAJoIAJBGGxqCyICIAE2AggMAQsgBCgCkAYiAUUNACADIAEQjQoLIAQiFEH4BWohFQJAIActAClBCHFFDQAgBCIWQcAGaiIBKAIAQQBMDQAgAyAEKAKIBhCNCiAEIRogFigCxAYgFigCwAYiBkEUbGpBFGshAQNAIAZBAEwNASADKAJsIQIgAygCAC0AVyIFBH9BkIIIBSADKAJoIAEoAgRBGGxqQRhqCyIIIAI2AgggAS0AEEG7AUcEQAJAIAEoAgxFDQAgBygCKEGAiBBxIQUgFCgC+AUEQCADQRkgASgCACACIAVBgIAQRmpBAmoQigMaCyAFQYCAEEcNACADQRogGigCgAYgAygCbEECaiABKAIIIAEoAgwQ/wIaQQAhBSADKAJsIQIgAygCAC0AVwR/QZCCCAUgAygCaCABKAIEQRhsakEYagsiBSACNgIICyADIAEtABAgASgCACABKAIEEIoDGiADKAIALQBXIQUgAygCbCECC0EAIQggBUH/AXEEf0GQgggFIAMoAmggASgCBEEYbGpBGGsLIgUgAjYCCCABQRRrIQEgBkEBayEGDAALAAsgAyAEKAKEBhCNCiAXKAKwBiIBBEAgA0HDACABKAIIQQBBARDbCBoLIAQiG0GMBmoiAigCACIBBEAgAyABEPgIGiANIAcoAiAoAgA2AgAgA0GU2QAgDRDzCCADKAJsIQECQCADKAIALQBXBEBBkIIIIgIgATYCCAwBCyADKAJoIBsoAowGQRhsaiICIAE2AgggAkEwayECCyACIAE2AggLIAQoAqgGIgEEQCADQT0gBCgCpAZBAXYgARCKAxoLIAshASAUKAL4BSICRQ0BIAcoAighASADQTsgAhDyCCEGIAFBwABxRQRAIBAgBC0AtAZBBnRqIgItAC1BIHEEQCADQcsAQQAgAigCKCIFIAUgAigCGC4BImpBAWsQ2wgaCyADQYgBIAQoAvwFEPIIGgsgAUGAwABxIQICQAJAAkAgAUGABHFFBEAgAkUNAyAEKALABg0BDAMLIAJFDQELIANB5QAgBCgCgAYgBCgCwAYiASgCLCAOIAEoAhgQ/AIQ2wgaIAkgARDgCgsgA0GIASAEKAKABhDyCBoLAkAgDy0AtQZBwwBGBEAgA0EKIAQoArgGIAQoApQGEIoDGgwBCyADIAQoApQGEPgIGgtBACECIAMoAmwhASADKAIALQBXBH9BkIIIBSADKAJoIAZBGGxqCyICIAE2AgggCyEBDAELCyAJQcgAaiESIABB+AVqIQFBACEGA0AgBiAALQAsT0UEQAJAIAEoAjgEQCAAIAYgARC1DAwBCyAQIAEtADxBBnRqIgItAC1BIHEEQCAJIAEoAiAgASgCBCACKAIoQQAQtgwMAQsgAigCGCEHAn8gASgCUCICKAIoIgVBwARxBEAgAkEgagwBCyAFQYDAAHFFDQEgAUHIAGoLIgIoAgAiDEUNACAOLQBXDQACfyARIgUgAC0ALkUNABogESAMKAIMLQAcQYABcQ0AGiAAKAI4CyEFAkAgDC0AOEEQcUUNACASIQIDQCACKAIAIgJFDQEgAigCCCABKAIIRgRAIAJCfzcCBAsgAkEUaiECDAALAAtBACECIAUgASgCIEEBaiIIa0EYbCADKAIALQBXBH9BkIIIBSADKAJoIAhBGGxqCyICaiEVIAEoAgQhCwNAAkAgAigCBCALRw0AAkACQCACLQAAIgVB3QBrQQJPBEAgBUEURg0BIAVBhwFHDQMgASgCCCEFIAJBjgE6AAAgAiAFNgIEDAMLIAIoAgghCCAFQd0ARgRAIAghBAwCCyAHKAIcIgVBgAFxBEAgBxCvAygCBCAIQQF0ai8BACEEDAILIAVBIHFFBEAgCEH//wNxIQQMAgtBACEFA0AgBSAIwSIESg0CIAcoAgQgBUEMbGovAQpBBXZBAXEgCGohCCAFQQFqIQUMAAsACyACIAEoAgg2AgQMAQsgDCAEwRDnAiIFQQBIDQAgAiAFQf//A3E2AgggAiABKAIINgIECyACQRhqIgIgFUkNAAsLIAFB4ABqIQEgBkEBaiEGDAELCyADIAAoAiAQjQogCSAAKAIkOwGUASAOIAAQsQwgCSAJLQAaIAprOgAaIA1BEGokAAsyAQF/IwBBEGsiAyQAIAAEQCAAQbsBEPEIGiADIAI2AgwgACABIAIQpAsLIANBEGokAAsaACAAIAEoAhQQMiAAIAEoAiAQMiAAIAEQNQs9AgF/AX8CQCABRQ0AIAFBCGohAgNAIAMgASgCAE4NASAAIAIoAgAQuQogAkEQaiECIANBAWohAwwACwALC78BBAF/AX8BfwF/IwBBQGoiBCQAAkAgAS0AAEEsRg0AQQEhAiAAKAIAIAEgACgCGCIFKAIoEIwMRQ0AIAEoAgRBgYCAgAJxQYCAgIACRg0AIAEoAigNACAAKAIAKAIAQZsBQbfPAhDICSIDRQ0AIAUoAiQhAiAEQQhqIANBNBDlFBogAyABQTQQ5RQhAyABIARBCGpBNBDlFBogBSAAKAIAIAIgAxDOCTYCJEEBIQIgAEEBOwEUCyAEQUBrJAAgAgtNAQF/IwBBIGsiAiQAIAIgADYCGCACQQA2AhAgAkEANgIAIAJBASIAQUBrNgIMIAJBwAA2AgggAkHYADYCBCACIAEQsgkaIAJBIGokAAusAQMBfwF/AX8CQANAAkACQCAALQAAIgFBrQFrDgQAAAMBAwsgACgCDCEADAELCyAALQACIQELAkAgAUH/AXEiAUGZAWtBA0kgAUH1AEZyDQAgAUGnAUYEQEEBIQIgAC0ABkEgcQ0BIAAoAiwiAUUNAUEAIQIgAC4BICIAQQBIDQEgASgCBCIDRQ0BIAAgAS4BIk4NASADIABBDGxqLQAEQQ9xRQ8LQQEhAgsgAguBAQMBfwF/AX8gASABKAIYQYCACHI2AhgDQCAAKAIkIAJKBEAgASAAKAIgIAJBGGxqKAIAIgMoAhQQtwogAygCDCIEBEAgASAEKAIUELcKCyADLQAHQQFxBEAgASADKAIsKAIoELkKCyACQQFqIQIMAQsLIAEgASgCGEH//3dxNgIYC+0BBgF/AX8BfwF/AX8BfwJAIAAoAiQNACABLwE0IQUgACgCACEDAn8gAS0AN0EIcQRAIAMgAS8BMiIEIAUgBGsQzQoMAQsgAyAFQQAQzQoLIgNFDQADQCACIAVGRQRAQQAhBCACQQJ0IgYgASgCIGooAgAiB0GAtANGBH9BAAUgACAHEPEJCyEEIAMgBmogBDYCFCADKAIQIAJqIAEoAhwgAmotAAA6AAAgAkEBaiECDAELCyAAKAIkRQRAIAMPCyABLwA3IgJBgARxRQRAIAEgAkGABHI7ADcgAEGBBDYCDAsgAxCTB0EAIQILQQALvQEDAX8BfwF/AkAgACgCACIELQBXBEAgA0F1Rg0BIAQgAyACEJEHDwsgAUEASARAIAAoAmxBAWshAQsgACgCaCIFIAFBGGxqIQQCQCADQQBIBEAgBC0AAUUNAQsgACAEIAIgAxCmCw8LIAQiBkEBaiEAIANBfUYEQCAFIAFBGGxqIAI2AhAgBkH9AToAAQ8LIAJFDQAgBSABQRhsaiACNgIQIAYgAzoAASADQXVHDQAgAiACKAIMQQFqNgIMCwurAwcBfwF/AX8BfwF/AX8BfyMAQSBrIgUkAAJAIAEoAhggASgCJGoiAkUNACAAKAIkDQAgACgCCCIIQcsAQQAgASgCDCIDIAIgA2pBAWsQ2wgaIAEoAiAhAgNAIAYgASgCJE4NAQJAIAIoAghBAEgNAAJAIAIoAgAoAhQiAwRAIAMoAgBBAUYNAQsgAEGlNUEAELICIAJBfzYCCAwBCyAAIANBAEEAEKkKIQMgAiAIQfYAIAIoAghBAEEAIANBeBD0CDYCDCAFIAIoAgQoAiA2AhAgAEEAQZDqAiAFQRBqEKAKCyACKAIQQQBOBEAgAi0AFUUhAyACKAIAIgQoAgwhByACLQAUBEAgBCgCFCgCACADaiEDCyACLQAWBEAgBCgCFCgCACADaiEDCyAAIAcoAhQiB0EAIAMQqQohBAJAIAItABUNACAAKAIkDQAgBCAELwEGQQFqOwEGCyAIQfYAIAIoAhAgBygCACADakEAIARBeBD0CBogBSACKAIEKAIgNgIAIABBAEHv6QIgBRCgCgsgAkEYaiECIAZBAWohBgwACwALIAVBIGokAAv0Bw4BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AkAgACgCJA0AIAAoAgghCCACQQE6AAAgAigCICEFA0AgAigCJCAQSgRAIAUoAgAiBCgCFCELQQAhDSAELQAHQQFxBEAgBCgCLCgCKCEEAkAgAigCHEUgAUVyDQAgBSgCBCgCBEEgcUUNACAJRQRAIAAgACgCLEEBaiIJNgIsCyAIQdAAIAEgCRCKAxoLIAAgACgCOEEBayINNgI4IAAgBCANQRAQwgoLAkAgBSgCEEEATgRAIAAgBSgCACgCDCgCFCIEIAAgBCgCACAFLQAVRWogCygCACIKQQAgBS0AFBtqIApBACAFLQAWG2pBAWoiDhDDCiIHQQBBARDoCSAEKAIAIQYgBS0AFUUEQCAIQf4AIAUoAhAgBiAHahCKAxogBkEBaiEGCwJAIAUtABRFBEAgByEPDAELIAAgCyAGIAdqIg9BAEEBEOgJIAYgCmohBgsgBS0AFkUNASAPIAcgBS0AFBshEUEAIQQgCkEAIApBAEobIQwDQCAEIAxGDQIgCEG1ASAEIBFqIAYgB2oQigMaIAZBAWohBiAEQQFqIQQMAAsACyALRQRAQQAhCkEAIQdBACEOQQAhDwwBC0EAIQ4gACALIAAgCygCACIKEMMKIgdBAEEBEOgJIAchDwsgC0UgBSgCCCIEQQBIckUEQCANRQRAIAAgACgCOEEBayINNgI4CyAFIAAgAyAEIA0gCyAPELMMNgIICwJAIAUoAhBBAE4EQCAIQeEAIAcgDkEBayIEIAQgB2oiBhDbCBogCEGKASAFKAIQIAYgByAEEP8CGgwBCyAFKAIELQAEQSBxBEAgC0EIaiEGQQAhDEEAIQQDQCAMIAQgCk5yRQRAIARBAWohBCAAIAYoAgAQ6wghDCAGQRBqIQYMAQsLIAxFBEAgACgCACgCCCEMCwJAIAkNACACKAIcRQRAQQAhCQwBCyAAIAAoAixBAWoiCTYCLAsgCEHVACAJQQBBACAMQX4Q9AgaCyAIQaIBQQAgByACKAIYIAIoAgwgEGpqENsIGiAIIAUoAgRBeRCqCiAIKAJsIgRBAEoEQCAIKAJoIARBGGxqQRZrIApB/wFxOwEACyAKIQ4LIAAgByAOEMQKIA0EQCAIIA0QjQoLIAVBGGohBSAQQQFqIRAMAQsLAkAgCUUEQEEAIQcgAUUNASABIQkgAigCHEUNAQsgCEEQIAkQ8gghBwsgAigCFCEGQQAhBANAIAQgAigCHE5FBEAgACAGKAIEIAIoAgwgBGoQ9wggBkEQaiEGIARBAWohBAwBCwsgAkEAOgAAIAdFDQAgCCAHEOMKCwuSAQEBfwJAIAAoAiQgAUEBa0EBS3INACAAKAIIIgAgAxCsCiADQQFqIQQgACgCAC0AVwR/QZCCCAUgACgCaCAEQRhsagstAABBvAFGBEAgACAEEKwKCyABQQJHDQBBACEBIAAoAgAtAFcEf0GQgggFIAAoAmggA0EYbGoLIgAgAjYCCCAAQQE2AgQgAEHLADoAAAsLhwQLAX8BfwF/AX8BfwF/AX8BfwF/AX8BfyABKAIgIQIgACgCCCEDA0AgASgCJCAHSgRAIAIoAgAoAhQhCiACKAIQQQBOBEAgACAKKAIAIggQwwohCSACLQAUBH8gAigCACgCDCgCFCgCACACLQAVRWoFQQALIQYgA0EkIAIoAhAQ8gghCyAIQQFrIgUhBANAIARBAEhFBEAgA0HeACACKAIQIAQgBmogBCAJahDbCBogBEEBayEEDAELCyACLQAWBEAgBiAIaiEMIAAQlQkhBEEAIQYgAi0AFEUEQCACLQAVRSEGCyAGIAxqIQYDQCAFQQBIRQRAIANB3gAgAigCECAFIAZqIAQQ2wgaIANBtgEgBCAFIAlqEIoDGiAFQQFrIQUMAQsLIAAgBBCWCQsgA0GiAUEAIAkgASgCGCABKAIMIAdqahDbCBogAyACKAIEQXkQqgogAygCbCIEQQBKBEAgAygCaCAEQRhsakEWayAIQf8BcTsBAAsgA0EnIAIoAhAgC0EBahCKAxpBACEFIAMoAmwhBCADKAIALQBXBH9BkIIIBSADKAJoIAtBGGxqCyIFIAQ2AgggACAJIAgQxAoLIANBpQEgASgCGCABKAIMIAdqaiIEIAoEfyAKKAIABUEACyIFEIoDGiADIAIoAgRBeRCqCiACQRhqIQIgB0EBaiEHDAELCwusBQQBfwF/AX8BfyMAQRBrIgYkACAAKAIIIQUgBkEANgIMIAZBADYCCCABRSAFRXJFBEAgAS0AACIEQQFzIQcCfwJAAkACQAJAAkACQAJAAkACQCAEQStrDg8BAQMICAYHBQUEBAQEBAQACwJAIARBqwFrDgUDCAgIAgALIARBE0cNByAAIAEoAgwgAiADEJQLQQAMCAsgASABEMcLIgdHBEAgACAHIAIgAxDCCkEADAgLIARBLEYEQCAAIAEoAgwgAiADEMIKIAAgASgCECACIAMQwgpBAAwICyAAIAAoAjhBAWsiBDYCOCAAIAEoAgwgBCADQRBzEJQLIAAgASgCECACIAMQwgogBSAEEI0KQQAMBwsgAS0AAiIFQasBR0EEdCEDIAEoAgwhBCABKAIQELYLIAVBqwFGRwRAIAAgBCACIAMQwgpBAAwHCyAAIAQgAiADEJQLQQAMBgtBNEE1IARBLUYbIQdBgAEhAwsgASgCDCIEELkLDQMgACAEIAZBDGoQtQshBSAAIAEoAhAgBkEIahC1CyEEIAAgASgCDCABKAIQIAcgBSAEIAIgAyABKAIEQQp2QQFxELwLIAYoAggMBAsgBSAAIAEoAgwgBkEMahC1CyIBEJILIAUgByABIAIQigMaQQAMAwsgACABIAJB2QAgAxCsC0EADAILIAMEQCAAIAEgAiACEK0LQQAMAgsgACAAKAI4QQFrIgM2AjggACABIAIgAxCtCyAFIAMQjQpBAAwBCyABKAIEIgdBgYCAgAJxQYCAgIACRgRAIAUgAhD4CBpBAAwBC0EAIgQgB0GBgICAAXFBgICAgAFGDQAaIAVBESAAIAEgBkEMahC1CyACIANBAEcQ2wgaQQALIQQgACAGKAIMEJYJIAAgBBCWCQsgBkEQaiQAC08BAX8gAUEBRgRAIAAQlQkPCyABIAAoAhwiAkwEQCAAIAIgAWs2AhwgACAAKAIgIgIgAWo2AiAgAg8LIAAgACgCLCICIAFqNgIsIAJBAWoLKwAgAkEBRgRAIAAgARCWCQ8LIAIgACgCHEoEQCAAIAE2AiAgACACNgIcCwuAAQMBfwF/AX8CQCABKAIoIgRFDQAgAS0AAEGoAWsiA0ELTUEAQQEgA3RBgxBxGw0AIAEuASIiAyAEKAIYTg0AIAQoAhQhAiABQakBOgAAIAEgAiADQQR0aiICKAIINgIcIAEgAi8BDDsBICABIAEoAgRB/7tfcTYCBEEBIQILIAILFAAgACgCCEHPACABIAIgAxDbCBoLtgEHAX8BfwF/AX8BfwF/AX8CQCABKAIUIggtAAdBAXENAANAIAIgAyACIANKGyEJA0AgAiIFIAlGDQIgBUEBaiECIAAgBUEGdGoiBCgCHCIHRQ0AIAQtAC1BIHENACAEKAIQIgpFDQAgBCgCGCgCPCIEIAEoAhAoAjxHDQAgCiABKAIIEGwNACAERQRAIAgoAhAgBygCEEcNAQsLIActAAdBAXENAAsgACAFQQZ0akEIaiEGCyAGC3kAAkAgACABTgRAIAFBMWogAEgNASAAIAFBH2pKBEAgAEEBaiEADAILIAAgAWtB4MIEai0AACAAaiEADAELIAEgAEExakoEQCABIQAMAQsgASAAQR9qSgRAIAFBAWohAAwBCyABIABrQeDCBGotAAAgAWohAAsgAMELggECAX8BfyMAQRBrIgIkAAJAAkADQCAARQ0CIAAtAAVBCHEEQCABIAAoAgg2AgAMAgsCQAJAIAAtAABBrQFrDgIAAQQLIAAoAgwhAAwBCwsgAkEANgIMIAAoAgwgAkEMahDJCkUNASABQQAgAigCDGs2AgALQQEhAwsgAkEQaiQAIAMLFAEBfwNAIAAiASgCOCIADQALIAELIgAgAEGHAWsiAEECSwRAQefvAQ8LIABBAnRBuN0GaigCAAtBAgF/AX8gACAAKALgASIBBH8gACgCCCICKAIALQBXBH9BkIIIBSACKAJoIAFBGGxqCyIBKAIIBUEACyIBNgLgAQt0AgF/AX8gACABIAJqIgNBBWwiBEEUaq0Q7AIiAgRAIAIgAzsBCCACIAE7AQYgAiACIANBAnRqQRRqNgIQIAAtAFQhASACIAA2AgwgAiABOgAEIAJBATYCACACQRhqQQAgBEEEaxDnFBogAg8LIAAQlQEgAgtFAQF/AkAgASgCNCIDBEAgACADIAIQzgoiAw0BC0EAIQMgASgCHCIBKAIAIAJMDQAgACABIAJBBHRqKAIIEOsIIQMLIAML3AEGAX8BfwF/AX8BfwF/IwBBEGsiByQAAkAgAkUNACAAKAIAIgQtAFcNACAALQDUAUEBSw0AIAIoAgAiBSAEKAKAAUoEQCAHIAM2AgAgAEGrmAEgBxCyAkEBIQYMAQsgAkEIaiEEIAEoAhwhCEEAIQEDQCABIAVODQEgBC8BDCIJBEAgCSAIKAIAIgVKBEBBASEGIAAgAyABQQFqIAVBABD0CwwDCyAAIAggCUEBayAEKAIAQQAQ7wsgAigCACEFCyAEQRBqIQQgAUEBaiEBDAALAAsgB0EQaiQAIAYL7AQHAX8BfwF/AX8BfwF/AX8gACgCCCIIKAJsIQsgACAAKAI4QQFrIgk2AjggBQRAIAhBESAFEPIIIQwgAigCECEKIAIoAgwhDSAGBEAgBiAGKAIAQQFqNgIACyAIQQ4gCEHaACANIAVBAWoiDiAKIAZBeBD0CEECaiIGIAkgBhDbCBpBACEKIAgoAmwhBiAIKAIALQBXBH9BkIIIBSAIKAJoIAxBGGxqCyIKIAY2AgggCEHQACACKAIMIA4gAigCEEEBaxDbCBogCEHHAEEBIAUQigMaC0EAIQUgACgCAC0AV0UEQCAIIAEoAgwgCRCkCgJAAkACQAJAAkACQCADLQAAQQprDgQCAQADBAsgABCVCSEFIAAQlQkhBiAIQeEAIAIoAgwgAigCECAFENsIGiAIQf8AIAMoAgQgBhCKAxogCEGAASADKAIEIAUgBhDbCBogCCgCbCICQQBKBEAgCCgCaCACQRhsakEWa0EIOwEACyAAIAYQlgkgACAFEJYJDAQLIAAQlQkhBSAIQeEAIAIoAgwgAigCECIGIAUgAygCFCAGEPQIGiAIQYoBIAMoAgQgBSACKAIMIAIoAhAQ/wIaIAAgBRCWCQwDCyAAIAIoAgwgAygCBCACKAIQEMYKDAILIAMoAgwiBUUEQCADIAAgAigCEBDDCiIFNgIMIAMgAigCEDYCEAsgACACKAIMIAUgAigCEBDGCiAIQQwgAygCBBDyCBoMAQsgCEHUACACKAIMIAIoAhAQigMaCyABKAIIIgAEQCAIQT0gACAHEIoDGgsgCCAJEI0KIAhBwwAgBBDyCBogCyEFCyAFCxAAIAEEQCAAIAFBARChCAsLwQEEAX8BfwF/AX8gAkEIaiEFA0AgBiACKAIATkUEQAJAIAMgBkYNACAFKAIoQQFqIQQCQCAFLQAlQcAAcQRAIAEgBEECdGooAgAiBw0BCyAAIAAoAigiB0EBajYCKCABIARBAnRqIAc2AgAgBSgCKEECdCABaigCBCEHCyAFIAc2AiggBUEUaiEEA0AgBCgCACIERQ0BIAAgASAEKAIgQX8Q0gogBEE0aiEEDAALAAsgBUFAayEFIAZBAWohBgwBCwsLOwEBfyABLQAAIgJBswFHIAJBpwFHcUUEQCAAIAFBHGoQuwwLIAEtAARBAXEEQCAAIAFBJGoQuwwLQQALCAAgACABECsLoAIEAX8BfwF/AX4jAEEQayIGJAACQCABKAIAIgQgAmoiBSABKAIESwRAAkACQCAFQcgBTgRAIAZByAE2AgAgAEH7vwEgBhCyAgwBCyAAKAIAIAFCyAEgAqwgBKxCAYZ8IgcgB0LIAVkbIgdCBoZCCIQQYSIBDQELQQAhAQwCCyABIAc+AgQgASgCACEECyABQQhqIQUDQCADIARORQRAIAUgBEEBayIEIAJqQQZ0aiAFIARBBnRqQcAAEOUUGgwBCwsgASABKAIAIAJqNgIAIAEgA0EGdGpBCGpBACACQQZ0EOcUGiADIAIgA2oiBCADIARKGyEEA0AgAyAERg0BIAEgA0EGdGpBfzYCMCADQQFqIQMMAAsACyAGQRBqJAAgAQuDAQIBfwF/A0AgAARAIAAgATYCJCAAIAAoAgQgAnI2AgQCQCAALQAAQawBRw0AQQAhAyAAKAIUIgRFDQADQCADIAQoAgBODQEgBCADQQR0aigCCCABIAIQ1gogA0EBaiEDIAAoAhQhBAwACwALIAAoAgwgASACENYKIAAoAhAhAAwBCwsLFwEBfwNAIAAiASgCNCIADQALIAEoAhwLqgECAX8BfwJAIAFFDQADQCAAIAEoAhwQugwgACABKAIoELoMIAAgASgCMBC6DCABIAAgASgCLBCLDDYCLCABIAAgASgCJBCLDDYCJCABKAIgIgNBCGohBCADKAIAIQMDQCADQQBKBEAgACAEKAIUQQEQ2AogBC0AJUEEcQRAIAAgBCgCOBC6DAsgBEFAayEEIANBAWshAwwBCwsgAkUNASABKAI0IgENAAsLCz4AAkAgAS0AAEGnAUcNACAAKAIYIgAoAiggASgCHEcNACABLgEgQQBIDQAgACAAKQMwIAEQ8AuENwMwC0EAC2YBAX8gASABKAIEIgNBAXQ2AgQgACABIANBBXRBCHKtEGEiA0UEQCAAIAEQrgMgACACEDMgAw8LIAMgAygCACIBQQFqNgIAIAMgAUEEdGoiAUEANgIUIAFCADcCDCABIAI2AgggAwtaAQF/An8CQAJAIAEoAjhFBEAgACgCACgCECgCHCIFRQ0BIAUoAjBFDQELIAAtAJkBRQ0BC0EAIgAgBEUNARogBEEANgIAQQAPCyAAIAEgAiADIAQQ8wwLIgAL2gEDAX8BfwF/AkACQCAAKAIALQAhQcAAcUUNACABLQArDQACQCACRQRAQQEhBSABEIsKDQMgASgCMEEARyEGDAELIAFBMGohBEEBIQUDQCAEKAIAIgQEQCABIAQgAiADEPQMBEBBASEGIAVBAiABKAIAIAQoAggQbBshBQsgBEEEaiEEDAELCyABEIsKIQQDQCAERQ0BAkAgASAEIAIgAxD1DEUNAEEBIQYgACgCAC0AJEEIcQ0AIAQtABpFDQBBAg8LIAQoAgwhBAwACwALIAYNAQtBACEFCyAFC6QCBAF/AX8BfwF/IwBBMGsiAyQAAkACQAJAAkAgAS0AKyIFQQFGBEAgACgCACIFIAEQugcoAgQoAgAoAjRFDQEgACgCeEUNBCABKAI0LQASIAUoAiBBB3ZBAXFNDQQgAyABKAIANgIgIABBsJYDIANBIGoQsgIgAS0AKyEFDAILIAEoAhwiBEGBIHFFDQEgACgCACEGAn8gBEEBcQRAIAYpAyBCgYCAgAGDQgFRDQMgAC0AEkUMAQsgBhCuCQsiBEUNAQsgAyABKAIANgIAIABBtrYBIAMQsgIMAQtBACEEIAVB/wFxQQJHDQEgAgRAIAItAApFDQIgAigCIA0CCyADIAEoAgA2AhAgAEGPKyADQRBqELICC0EBIQQLIANBMGokACAEC7MBBAF/AX8BfwF/IwBBIGsiBCQAIAAoAgAiBSABKAI8EPwCIQYgBSACQQAQpAkhByAAQQBBAEEAEL4JIgIEQCACIAUgASgCABCgATYCECACIAUgBSgCECAGQQR0aigCABCgATYCDAsgAEEAIAIgB0EAQQBBAEGAgAhBABDFCSECIARCADcDECAEQgA3AwggBCADNgIEIARBDDoAACAAIAIgBBDmCRogBSACEJ8IIARBIGokAAvvAQUBfwF/AX8BfwF/IwBBIGsiAiQAAkAgAUUEQAwBCyAAIAAoAhgiBkHv3/2/f3E2AhggACgCACEDIAIgADYCGCACQQEiBEHZAGo2AgQgAiADNgIAIAJBADYCDCACQQBB2wAgBkGAgCBxGzYCCCADIAMoAtwBIAEoAhhqIgU2AtwBIAMgBRCDCg0AIAIgARDNCxogAigCACIDIAMoAtwBIAEoAhhrNgLcASABIAEoAgQgACgCGCIFQZCAAnFyNgIEIAAgBSAGQZCggsAAcXI2AhggACgCFEEASg0AIAMoAiRBAEohBAsgAkEgaiQAIAQLIAEBfyAAKAIIIQIgACABELwKIgAEQCACIABBeBCqCgsLGgEBfyABKAIQIgJFBEAgACABEOsMIQILIAIL+AIFAX8BfwF/AX8BfyMAQRBrIgskAAJAIAEtACtBAUYEQCAHQZl4NgIAIAZBmXg2AgBBACEHDAELIAAoAgAgASgCPBD8AiEMIAAoAgghCSAEQQBIBEAgACgCKCEECyAGIAQ2AgAgBEEBaiEIAkAgAS0AHEGAAXENACAFBEAgBS0AAEUNAQsgACAEIAwgASACEPUICyAHIAg2AgAgAUEIaiEEQQAhBwNAIAQoAgAiBARAAkAgBC8AN0EDcUECRw0AIAEtABxBgAFxRQ0AIAYgCDYCAEEAIQMLAkAgBQRAIAUgB0EBaiIKai0AAEUNAQsgCSACIAggBCgCLCAMENsIGiAAIAQQ4AogCSgCbCIKQQBKBEAgCSgCaCAKQRhsakEWayADQf8BcTsBAAsgCyAEKAIANgIAIAlBs+4AIAsQ8wggB0EBaiEKCyAIQQFqIQggBEEUaiEEIAohBwwBCwsgCCAAKAIoTA0AIAAgCDYCKAsgC0EQaiQAIAcLPgEBfyABIAAoAmwiAkEBa0YEQCAAIAE2AmwPCyAAKAIALQBXBH9BkIIIBSAAKAJoIAFBGGxqCyIAIAI2AggLnAEEAX8BfwF/AX8gACgCeCICIAAgAhsiAigC2AEiBEEAIARBAEobIQUCQANAIAMgBUcEQCADQQJ0IQAgA0EBaiEDIAAgAigCiAJqKAIAIAFHDQEMAgsLIAIoAogCIARBAnRBBGqsEEsiAwRAIAIgAzYCiAIgAiACKALYASIAQQFqNgLYASADIABBAnRqIAE2AgAPCyACKAIAEJUBCwuvBAgBfwF/AX8BfwF/AX8BfwF/IAAgACgCOEEBayIONgI4QRxBHyABLQAcQYABcRshEiAAKAIIIQwgCUUEQCAMIBIgAyAOIAUgBhD/AhoLIAIgACABQQBBABDcCiILcgRAQQAhCyAAIAJBAEEAQQMgASAIEO0KIQ8gACABEOwKIRAgACAAKAIsIhFBAWoiDSABLgEiajYCLCAMQdAAIAUgDRCKAxogEUECaiERIA8gEHIiEEF/RiEPA0AgAS4BIiALSgRAIA9FIBAgC3ZBAXFFIAtBH0tycUUEQCAMIAEgAyALIAEgC8EQ7gogEWoQkgkLIAtBAWohCwwBCwsgDCgCbCELIAAgAkGAAUEAQQEgASANIAggDhDwCiAMKAJsIAtKBEAgDCASIAMgDiAFIAYQ/wIaQX8hCgsgACABIA1BAEEAQQAQ8goLAkAgAS0AK0ECRg0AIAAgASADIARBACAKEPMKIAxBggEgAyAHQQBHEIoDGgJAIAAtABIEQEEAIQsgASgCAEGpxwIQbA0BCyAMIAFBexCqCgsCQCAJRQ0AIAwoAmwiC0EATA0AIAwoAmggC0EYbGpBFmtBBDsBAAsgAyAKRiAKQQBIckUEQCAMQYIBIAoQ8ggaCyAMKAJsIgtBAEwNACAMKAJoIAtBGGxqQRZrIAlBAkZBAXQ7AQALIAAgAUEAIA1BAEEAEPUKIAIEQCAAIAJBgAFBAEECIAEgDSAIIA4Q8AoLIAwgDhCNCgsPACAAKAJ0BEAgABD2DAsLLAAgAEHTABDxCBogAEHUACABQQEQigMaIABBARCGCyAAQQBBACACQQAQhwsLKQAgACgCECgCHEEoaiABQegAakEAEOcDGiAAIAEoAgQQrgMgACABEDILVgEBfyMAQSBrIgMkACADQgA3AxAgA0IANwMIIANCADcDACADIAE2AhggA0HcADYCBCADIAAQsgkaIAMvARQhASADQSBqJAAgASABQf3/A3EgAhtBAEcLHwAgAEHLAEEAQQAQoQkiAARAIAAgAUEBajsBIAsgAAvWAwUBfwF/AX8BfwF/IwBBIGsiBiQAIAQoAhghByAAKAIAIgkgBEEAEKcJIQggCSAFQQAQpAkhCiAIBEAgCEF/NgIwIAhBGGoiBCgCACIFIAUoAhhBAWs2AhggCEEANgIYCwJAIAIEQEEAIQRBACEFA0AgBSACLwEyT0UEQCAAIAQgACACKAIEIAVBAXRqLgEAEOoKEMIJIQQgBUEBaiEFDAELC0EOQQ8gBy0AK0EBRhshBwwBCyAHLQArIgRBAkYEQEEAIQRBACEFA0AgBy4BIiAFTARAQQ4hBwwDBSAAIAQgACAFEOoKEMIJIQQgBUEBaiEFDAELAAsAC0EOQQ8gBEEBRhshByAAQcsAQQBBABChCSEEIAAoAgAgBBDBCSEECwJAIANFDQBBACEFA0AgBSADKAIATg0BIAAgBCAJIAMgBUEEdGooAghBABCkCRDCCSEEIAVBAWohBQwACwALIAAgBCAIIApBAEEAQQBBgICIhAFBABDFCSIEBEAgBCAEKAIEQYCAgMAAcjYCBAsgBkEANgIUIAZCADcCDCAGIAE2AgQgBiAHOgAAIAYgAgR/IAIvATIFQX8LIgU2AgggACAEIAYQ5gkaIAkgBBCfCCAGQSBqJAALnQIHAX8BfwF/AX8BfwF/AX8jAEEQayIGJAACQCAAKAIALQAhQcAAcUUNACABLQArDQAgAUEwaiECA0AgAigCACIEBEBBACECIAQoAhQiBUEAIAVBAEobIQgDQCACIAhGRQRAQX9BASAEIAJBA3RqKAIkIgV0IAVBH0obIANyIQMgAkEBaiECDAELCyAEQQRqIQIMAQsLIAEQiwohBwNAIAdFDQEgBkEANgIMIAAgASAHIAZBDGpBABCZCxoCQCAGKAIMIgRFDQAgBC8BMiEIQQAhAgNAIAIgCEYNAUF/QQEgBCgCBCACQQF0ai8BACIFdCAFwUEfShsgA3IhAyACQQFqIQIMAAsACyAHKAIMIQcMAAsACyAGQRBqJAAgAwuYAQMBfwF/AX9BfyEIAkAgBS0AK0ECRg0AQYEBQYABIAIbIQkgA0ECdCEDA0AgByEIIAFFDQECfwJAIAkgAS0ACEcNACABLQAJIARxRQ0AIAEoAhAgAhD3DEUNAEF/IgcgAS0ACg0BGiAAIAEgBSAGEPgMIgdFDQAgAyAHaigCECAIcgwBCyAICyEHIAEoAiAhAQwACwALIAgLegMBfwF/AX8CQCABQQBIDQAgACgCHEEgcUUNACAAKAIEIQQDQCABIAJGRQRAIAQgAkEMbGovAQpBf3NBBXZBAXEgA2ohAyACQQFqIQIMAQsLIAQgAUEMbGotAApBIHFFBEAgAyEBDAELIAAvASQgASADa2ohAQsgAcELogQIAX8BfwF/AX8BfwF/AX8BfyMAQTBrIgUkACAAKAIIIAIgARD+CQJAIAItABxBwABxRQ0AAkACQCAAKAIIEL0LIgMtAABB3wBrDgIBAAILIAMoAhAhBkEAIQMDQCAEIAZqIgctAABFDQIgAigCBCADQQxsai8BCiIIQSBxRQRAIAhBwABxBEAgB0HAADoAAAsgBEEBaiEECyADQQFqIQMMAAsACyADQQE2AgwLQQAhAyACLgEiIgZBACAGQQBKGyEHA0AgAyAHRwRAIAIoAgQgA0EMbGoiBC8BCiIIQeAAcQRAIAQgCEGAAXI7AQoLIANBAWohAwwBCwsgBUIANwMYIAUgAjYCKCAFQd0ANgIUIABBACABazYCNEEAIQdBACEEQQAhAwNAIAbBIQkDQCAEIQggByEGIAMgCUgEQAJAIAIoAgQgA0EMbGoiBC8BCiIJQYABcQR/IAQiCkEKaiIHIAlBgAJyOwEAIAVBADsBJCAFQRBqIAIgBBCTCRCyCRogBCAELwEKQf/9A3E7AQogBS0AJEGAAXEEQCAGIQcMAgsgACACIAQgAiADwRDuCiABahCoCyAKIAovAQpB//4DcTsBCkEBBSAGCyEHIAghBAsgA0EBaiEDIAIvASIhBgwCCyAIBEBBACEHQQAhBEEAIQMgBg0BCwsLIAgEQCAFIAgoAgA2AgAgAEGplAMgBRCyAgsgAEEANgI0IAVBMGokAAvoCA0BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQeABayILJAAgAkGBAUchFANAIAEEQAJAIAIgAS0ACCIJRwRAIAEtAApFIBRyIAlB/wBHcg0BCyABLQAJIARHDQAgASgCECADEPcMRQ0AIAEtAApFBEAgACABIAUgBiAHIAgQ+QwMAQsgACgCeA0AIAAtAJcBRQ0AIAAoAogBIhBBCGogAUcNACAAKAIAIREgACgCCCESIAtB8ABqQQBBzAAQ5xQaIAtBKGpBAEHIABDnFBogCyARIBAoAgRBABCQCTYCjAEgC0EBNgIoIAsgC0EoajYCkAEgCyAFNgJAIAUoAgAhCSALQX82AlggCyAJNgI4IAAgC0HwAGpBABCRCiAAKAIkRQRAIAAgC0HwAGoQkwoLIBEgCygCjAEQrgMgACgCACENIBAoAgQhE0EAIQ9BACEMA0AgDyATKAIATkUEQAJAIBMgD0EEdGoiCigCCCIJRQ0AAkAgCS0AACIOQbQBRwRAIA5BjQFHDQEgCSgCEC0AAEG0AUcNASAAQeHQAEEAELICC0EAIQkDQCAJIAUuASJODQICQCAJQQxsIg4gBSgCBGoiCi0ACkECcQ0AIAAgDCANQTsgCigCABDICRDCCSEMIA0tAFcNACAMKAIAQQR0IAxqIgpBBGsgDSAFKAIEIA5qKAIAEKABNgIAIAoiFUEBaiIKIBUvAAFB/P8DcTsAAAsgCUEBaiEJDAALAAsgACAMIA0gCUEAEKQJEMIJIQwgDS0AVw0AIAooAgwiCUUNACAMKAIAQQR0IAxqIg5BBGsgDSAJEKABNgIAIA5BAWoiCSAOLwABQfz/A3EgCi8AEUEDcXI7AAALIA9BAWohDwwBCwsCQCAAKAIkDQAgC0EAQSQQ5xQhCSAQKAJgRQRAIBAgDCgCADYCYCAAIAAoAigiCkEBajYCKCAQIAo2AlwLIAlBgAg2AhggCSAGNgIIIAkgADYCACABLQAIIQogACAFNgJ8IAAgCjoAlgEgCSAMEP4KDQAgES0AVw0AIAwoAgAhCiAAKAIsIQ0gCUHIAWoiDkIANwMAIAtCADcD0AEgCUEBIg9B3QBqNgLIASAJQgA3A8ABIAkgBTYC2AEgCUHQADYCxAEgCUHAAWogDBCzCRogDUEBaiEPIAkvAdQBBEAgCUEBIg1BPGo2AsgBIAlB3wA2AsQBIAlBwAFqIAwQswkaCyAAIAogACgCLGpBAmo2AiwgECAPNgJkQQAhCSAKQQAgCkEAShshDgNAIAkgDkcEQCAAIAwgCUEEdGooAggiCiAJIA9qIg0QgAsgChDkCUHFAEYEQCASQdcAIA0Q8ggaCyAJQQFqIQkMAQsLIBJB4QAgDyAOIA4gD2oiCRDbCBogEkH/ACAQKAJcIAlBAWoiChCKAxogEkGAASAQKAJcIAkgChDbCBoLIBEgDBCuAyAAQQA2AnwgAEEAOgCWAQsgASgCICEBDAELCyALQeABaiQAC54gKQF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX8jAEHgAGsiFSQAIAEvASIhDyAAKAIIIQ4gACgCACETAn8gASgCHCINQYABcUUEQEEBDAELIAEQrwMiGC8BMgshKgJAIA1BgBBxRQ0AIA/BIg1BACANQQBKGyESIAVBAWohFkEBISMDQEEAIQ0DQCANIBJGRQRAAkAgASgCBCANQQxsaiIPLQAEQQ9xIhBFDQAgDSABLgEgRg0AIBcgDy8BCkHgAHEiEUVyQQFxRQRAIBRBAWohFAwBCwJAIAtFDQAgCyANQQJ0aigCAEEATg0AIBFFDQELAkACQAJAAkACfwJAQQIgECAQQQtGGyAIIAhBC0YbIhBBBUYEQCAXQQFxDQMgDy8BCEUNAyAOQTMgASANwRDuCiAWaiIQEPIIIREgACABIA8QkwkgEBC+C0EAIQ8gDigCbCEQIA4oAgAtAFdFDQFBkIIIDAILICMgEUEAR3JBAXFFDQYgASANwRDuCiAWaiERIBBBAWsOAwQDBAULIA4oAmggEUEYbGoLIQ8gHUEBaiEdIA8gEDYCCAwECyABIA3BEO4KIBZqIRELIAAoAngiECAAIBAbQQE6ABVBAiEQCyABKAIAIScgFSAPKAIANgJUIBUgJzYCUCATQenWACAVQdAAahD9AiEPIA5BxQBBkwogECARENsIGiAOIA9BehCqCiAOKAJsIg9BAEwNASAOKAJoIA9BGGxqQRZrQQE7AQAMAQsgDkEyIBEgCRCKAxoLIA1BAWohDQwBCwsgFyAUIB1yRXJBAXENAUEBIRdBACEjIB1BAEwNACABLQAcQeAAcUUNACAAIBYgARDvCgwACwALAkAgASgCECISRQ0AIBMtACFBAnENACAAIAVBf3M2AjRBAiAIIAhBC0YbIRAgBUEBaiEUQQAhDQNAIA0gEigCAE5FBEAgEiANQQR0aiIXKAIIIQ8CQCALBEAgDyALIAcQ6QpFDQELIBxFBEAgDiABIBQQ/glBASEcCyAAIAAoAjhBAWsiETYCOCATIA9BABCkCSEPIBMtAFdFBEAgACAPIBFBEBCUCwsgEyAPEDMCQCAQQQRGBEAgDiAJEPgIGkEEIRAMAQsgAEGTAkECIBAgEEEFRhsiECAXKAIMQQBBAxCMCgsgDiAREI0KCyANQQFqIQ0MAQsLIABBADYCNAsgAUEIaiEUIAEoAgghFkEBIS0CQAJAIAxFBEBBACEMDAELIAwoAgBFBEBBBkEEIAwtABQiDRshCCAMQQAgDRshDAwBCyAWRQ0AA0AgFgRAIBpBAWohGiAWKAIUIRYMAQsLIBMgGkEKbK0QxQIiC0UNASAMIAs2AhggCyAaQQN0aiEXQQAhESAMIRIDQAJAIBJFDQAgEigCAEUNAEEAIQ8gFCENAkAgEigCHCIQRQ0AA0AgDSgCACINRSANIBBGckUEQCAPQQFqIQ8gDUEUaiENDAELCyAPIBdqIhAtAAANACAQQQE6AAAgCyARQQN0aiIQIA82AgQgECANNgIAIBFBAWohEQsgEigCECESDAELC0EAIS1BACENIBQhDwNAIA8oAgAiDwRAIA0gF2otAABFBEAgCyARQQN0aiIQIA02AgQgECAPNgIAIBFBAWohEQsgDUEBaiENIA9BFGohDwwBBSAaIRYgCyEaCwsLAkACQAJAIBMpAyAiMEKAwAGDUARADAELAn8gMEKAwACDUEUEQEEBIg0gACABQYABQQBBABDbCiIkDQEaIAAgAUEAQQAQ3ApBAEcMAQsgACABQQBBABDcCgsiDQ0BCwwBCyAAIAAoAixBAWoiHzYCLCAOQccAQQAgHxCKAxogDkH8MkEAEPMIIAAgACgCOEEBayIoNgI4CwJAIAdFBEAMAQsgGA0AIAAgACgCOEEBayIPNgI4IAgiDUELRgRAQQIgAS0AKiINIA1BC0YbIQ0LAkAgDEUEQAwBCyAMQQAQ/woiGQRAQQZBBCAZLQAUGyENCyAMIBlGBEAgDCEZDAELIA5BCRDxCCEiCwJAIAhBBUYgDUEFR3INACAUKAIARSAicg0AQQAhECAOQQkQ8QghEiAOQf8wQQAQ8wggEkEBaiEgCwJAIAZFDQAgDkE1IAUgDyAGENsIGiAOKAJsIhBBAEwNACAOKAJoIBBBGGxqQRZrQZABOwEACyAOQaSVAkEAELUKIA5BHyADIA8gBRDbCBoCfwJAAkACQAJAAkACQCANQQFrDgYBAQEEAgMAC0ECIQ0LIAAgDSABEPsKDAMLIB8EQEEBIR4gACgCeCINIAAgDRtBAToAFCAAIAEgJCADIAQgBUEBQQBBBUEBQX8Q5QogDkHWACAfQQEQigMaQQEMBAsgDkGCASADQcAAEIoDGiAOIAFBexCqCiABKAIIRQRAQQEMBAsgACgCeCINIAAgDRtBAToAFCAAIAEgAyAEQQBBfxDzCkEBDAMLIAAgDCABQQAgAxCFDQsgDiAJEPgIGgtBAAshKyAOIA8QjQogDEUgDCAZRnJFBEAgDkEJEPEIISUMAQsgIEUEQEEAISAMAQtBACEPIA5BCRDxCCEpIA4oAmwhDSAOKAIALQBXBH9BkIIIBSAOKAJoICBBGGxqQRhrCyIPIA02AggLAn8gLUUEQCAaKAIEIRQgGigCAAwBC0EAIRQgFgshDyAGQQBHICRBAEdxITEgIkEBaiEyIAZBAWohMyAFQX9zIREgBUEBaiEnQQAhFyAoISYDQAJAAkACQCAPBEAgAiAUQQJ0aiITKAIARQ0DAkAgDEUNACAiRSAMIA8Q/woiGSAMR3INAEEAIQ0gDigCbCEQIA4oAgAtAFcEf0GQgggFIA4oAmggIkEYbGoLIg0gEDYCCCAMIRkLIAAgACgCOEEBayILNgI4IBxFBEAgDiABICcQ/glBASEcCyAVIA8oAgA2AkAgDkHY1wAgFUFAaxC1CiAPKAIkBEAgDkHLAEEAIBMoAgAQigMaIAAgETYCNCAAIA8oAiQgCxCJDCAAQQA2AjQLIAQgFGohISATKAIAIjRBAWohEkEAIQ0DQCANIA8vATQiEE9FBEACQAJAAkACQAJAIA8oAgQgDUEBdGovAQAiEEH+/wNrDgIAAgELIAAgETYCNCAAIA8oAiggDUEEdGooAgggDSASahC+CyAAQQA2AjQgDygCACEQIBUgDTYCFCAVIBA2AhAgDkHevQEgFUEQahDzCAwDCyAQIAEvASBHDQELIA5B0gAgBSANIBJqEIoDGiAOQY6tAUEAEPMIDAELIA5B0QAgASAQwSIQEO4KICdqIA0gEmoQigMaIBUgASgCBCAQQQxsaigCADYCACAOQbPuACAVEPMICyANQQFqIQ0MAQsLIA5B4QAgEiAQIBMoAgAQ2wgaIBUgDygCADYCMCAOQbTYACAVQTBqEPMIIAZFIAdyRSAPIBhGcQ0CIA8tADYiDUUNAiAZBH9BBkEEIBktABQbBUECIA0gDUELRhsgCCAIQQtGGwshLiAOQRsgISALIBIgDy8BMhD/AiEsIBIhGyAPIBhGIi9FBEAgACAqEMMKIRsLIAZFIC5BBUdxDQEgAS0AHEGAAXFFBEAgDkGOASAhIBsQigMaIAZFDQIgDkE1IBsgCyAGENsIGiAOKAJsIg1BAEwNAiAOKAJoIA1BGGxqQRZrQZABOwEADAILQQAhDQJAIC8NAANAIA0gGC8BMk8NASAOQd4AICEgDyANQQF0IhAgGCgCBGouAQAQ5wIgDSAbahDbCBogASgCACETIBUgASgCBCAYKAIEIBBqLgEAQQxsaigCADYCJCAVIBM2AiAgDkHp1gAgFUEgahDzCCANQQFqIQ0MAAsACyAGRQ0BIBIgGyAPLwA3QQNxQQJGGyE1IBgvATIiECAOKAJsaiETQQAhDUE0IR0DQCANIBBB//8DcU8NAiAAIBgoAiAgDUECdGooAgAQ8QkhECAOQTUgHSANIBgvATJBAWtGIiMbIh0gASAYKAIEIA1BAXRqLgEAEO4KIDNqIAsgEyAjGyITIA0gNWogEEF+EPQIGiAOKAJsIhBBAEoEQCAOKAJoIBBBGGxqQRZrQZABOwEACyANQQFqIQ0gGC8BMiEQDAALAAsgIARAIA4gIBD4CBogDkEAIg9BlpQCakEAEPMIIA4oAmwhDSAOKAIALQBXBH9BkIIIBSAOKAJoIClBGGxqCyIPIA02AggLIB4EQCAOQREgHyAmEIoDGgJAIBhFBEACQCAGRQ0AIA5BNSAFICggBhDbCBogDigCbCINQQBMDQAgDigCaCANQRhsakEWa0GQATsBAAsgDkEfIAMgKCAFENsIGiAAQQIgARD7CgwBCyAOICgQ+AgaCyAOICYQjQoLAkAgAS0AHEGAAXENACAOQeEAICcgAS4BJCACIBRBAnRqKAIAENsIGiAcDQAgDiABQQAQ/gkLIAogKzYCAAwECwJAAkACQAJAAkAgLkEBaw4GAAAAAgMBAwsgACAuIA8QiAwMAwsgACAMIAEgDyAhEIUNCyAOIAkQ+AgaDAELIA4oAmwhDSAfBEAgACgCeCIQIAAgEBtBAToAFCAeQQFqIR4LAkAgMQRAIA5BpwEgAxDyCBogACABICQgAyAEIBsgKsFBAEEFIC8gIRDlCiAOQagBIAMQ8ggaDAELIAAgASAkIAMgBCAbICrBQQBBBSAvICEQ5QoLQQEhKyAfRQ0AIA5B1gAgH0EBEIoDGkEAIRAgDkEJEPEIISEgDkHaiQFBABDzCCAOICYQjQogACAAKAI4QQFrIiY2AjggDygCJARAIA5BMiA0ICYQigMaCyANICxrIRADQCAQQQBMRQRAQQAhDQJAIA4oAgAtAFcEf0GQgggFIA4oAmggLEEYbGoLIg0tAAAiE0GOAUYNACANLwECISNBACEdIA4gEyANKAIEICYgDSgCCCATQfDUA2otAABBAXEbIA0oAgwgDSgCECANLAABEPQIGiAOKAJsIg1BAEwNACAOKAJoIA1BGGxqQRZrICM7AQALICxBAWohLCAQQQFrIRAMAQsLIABBAiAPEIgMQQAhDyAOKAJsIQ0gDigCAC0AVwR/QZCCCAUgDigCaCAhQRhsagsiDyANNgIICyAOIAsQjQogEiAbRwRAIAAgGyAqEMQKCyAZRQ0BIBkhDSAlRQ0BA0ACQCANKAIQIg1FDQAgDSgCAEUNACANKAIcRQ0AIA0tABUNAQwDCwsgDiAyEPgIGkEAIQ8gDigCbCENIA4oAgAtAFcEf0GQgggFIA4oAmggJUEYbGoLIg8gDTYCCEEAISUMAQsgDiALEI0KCyAtBEAgFEEBaiEUIBYoAhQiFiEPBUEAIQ8gF0EBaiIXIRQgFiAXTA0BIBogF0EDdGoiDSgCACEPIA0oAgQhFAsMAAsACyAVQeAAaiQAC8oIEQF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX4jAEEQayIJJAACQCAAKAIAIgotACFBwABxRQ0AIAEtACsNACACQQFqIREgAUEwaiEGIAooAhAgCiABKAI8EPwCIg9BBHRqKAIAIRAgAC0AmQEiEiETA0AgBigCACIGBEAgCUEANgIMIAlBADYCCAJAAkAgBEUNACABKAIAIAYoAggQbEUNACABIAYgBCAFEPQMRQ0BCyAGKAIIIQcCQAJAAn8gAC0AmQEEQCAKIAcgEBCEAwwBCyAAQQAgByAQEPsCCyIIBEAgACAIIAYgCUEMaiAJQQhqEJkLRQ0BCyATRQ0FIAotAFcNBSAIDQIgABDwCCIMKAJsIAYoAhQiCGpBAWohC0EAIQcDQCAHIAhODQIgDEEyIAYoAgAgBiAHQQN0ai4BJBDuCiARaiALEIoDGiAHQQFqIQcgBigCFCEIDAALAAsgCSgCCCINRQRAIAkgBigCJDYCBCAJQQRqIQ0LIAhBIGohFEEAIQsgCSgCDCEOQQAhBwNAIAYoAhQgB0oEQCANIAdBAnRqIgwoAgAgAS4BIEYEQCAMQX82AgALIAooAuwCBEAgCCgCBCELIBQhDCAOBEAgDigCBCAHQQF0aiEMCyAAIAgoAgAgCyAMLgEAQQxsaigCACAPEPELQQJGIQsLIAdBAWohBwwBCwsgACAAKAIoQQFqNgIoIAIEQCAAIA8gCCAOIAYgDSACQX8gCxD8DAsCQCADRQ0AAkAgACgCeCIHIAAgBxsoAoABIgdFDQAgBygCACIHIAYoAhxGBEAgBi0AGUEIRg0CCyAHIAYoAiBHDQAgBi0AGkEIRg0BCyAAIA8gCCAOIAYgDSADQQEgCxD8DAsgCiAJKAIIEDIMAQsgDEGeASAGLQAYQX8QigMaCyAGQQRqIQYMAQsLIARBAEchCyABEIsKIQYgCiIVQSJqIQwDQCAGRQ0BIAlBADYCDCAJQQA2AggCQCAEBEAgASAGIAQgBRD1DEUNAQsCQCAGLQAYDQAgFS0AIkEIcQ0AIAAoAngNACAALQAURQ0BCyAAIAEgBiAJQQxqIAlBCGoQmQsEQCASRQ0DIAotAFdFDQEMAwsgAEEAQQBBABC+CSIHBEAgByAGKAIAIgg2AhggByAIKAIANgIQIAggCCgCGEEBajYCGCAAIAAoAigiCEEBajYCKCAHIAg2AjAgAwRAIAAgByABIAkoAgwgBiAJKAIIIANBfxD9DAsCQCACRQ0AIAYgC2otABkhCCAKKQMgIRYgACAHIAEgCSgCDCAGIAkoAgggAkEBEP0MIAYtABgNAAJAIAhBACAWQoCAgICAAYNQG0H/AXFBCGsOAwEAAQALIAAoAngiCCAAIAgbQQE6ABULIAdBADYCECAKIAcQpAgLIAogCSgCCBAyCyAGKAIMIQYMAAsACyAJQRBqJAAL+wEHAX8BfwF/AX8BfwF/AX8jAEEQayIIJAAgACgCCCEJIAEtABxBgAFxBEAgARCvAyEGCyABQQhqIQFBfyELA0AgASgCACIBBEACQAJAIAQEQCAEIAdBAnRqKAIARQ0CIAEgBkcNAQwCCyABIAZGDQELIAMgB2oiCiAFRg0AIAlBjAEgCiAAIAEgAkEAQQEgCEEMaiAMIAsQlQsiCyABQTJBNCABLwA3QQhxG2ovAQAQ2wgaIAkoAmwiCkEASgRAIAkoAmggCkEYbGpBFmtBATsBAAsgACAIKAIMEJYLIAEhDAsgAUEUaiEBIAdBAWohBwwBCwsgCEEQaiQAC54DCQF/AX8BfwF/AX8BfwF/AX8BfyAIQQBHQQR0Ig8gBkECcXJBAXIhECABQQhqIQkgACgCCCEKA0AgCSgCACIJBEACQCAFIAtBAnRqIgwoAgAiDUUNACAJKAIkBEAgCkEyIA0gCigCbEECahCKAxoLAkAgCS8ANyINQQNxQQJHBEAgDyEODAELIBAgDyABLQAcQYABcSIRGyEOIBFFIAZyDQAgACABIAMgC2ogDCgCABD9CiAJLwA3IQ0gECEOCyAKQYoBIAMgC2ogDCgCACIMIAxBAWogCUEyQTQgDUEIcRtqLwEAEP8CGiAKKAJsIgxBAEwNACAKKAJoIAxBGGxqQRZrIA47AQALIAtBAWohCyAJQRRqIQkMAQsLAkAgAS0AHEGAAXENACAALQASIQkgCkGAASACIAUgC0ECdGooAgAgBBDbCBogAC0AEkUEQCAKIAFBexCqCgsgCigCbCILQQBMDQAgCigCaCALQRhsakEWa0EAIAZBAXJBISAGGyAJGyIJQQhyIAkgBxsiCUEQciAJIAgbQf8BcTsBAAsLrwoXAX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF+AX8BfwF+AX8BfyMAQTBrIggkAAJAIAAoAgAtACFBwABxRQ0AQYF/QYB/IAIbIRQgAUEgaiEVQQBBoI8GaikDACEWQZiPBikDACEXIAEQiwohCiACQQBHIhhBAnQhGQNAIApFDQECQCAEBEAgASAKIAQgBRD1DEUNAQsgCiAYai0AGUEAIAAoAgAiBikDICIaQoCAgICAAYNQGyIRQQdHIhNFIBpCgIAgg0IAUnENAAJAIAogGWoiG0EcaigCACIHIBFFckUEQCAIQQA2AiwgCEEANgIoIAAgASAKIAhBLGogCEEoahCZCw0CQQAhDSATIAJBAEcgEUEKR3JxIRAgCkEkaiEcIAgoAiwhDkEAIRJBACEHQQAhDANAIAooAhQgB0oEQCAIIBc3AyAgCCAWNwMYIAgoAigiCSAHQQJ0aiAcIAkbKAIAIQsgASgCBCEPIBUhCSAOBEAgDigCBCAHQQF0aiEJCyAIIA8gCS4BAEEMbGooAgAiCTYCCCAIIAkQWjYCDCAIIAtBDGwiCyAKKAIAKAIEaigCACIJNgIQIAggCRBaNgIUIAAgDSAAQTUgAEGNASAGQTsgCEEgakEAEKAJIAZBOyAIQQhqQQAQoAkQoQkgBkE7IAhBEGpBABCgCRChCRDOCSENIAIEQCAAIAwgAEEtIABBjQEgBkE7IAhBIGpBABCgCSAGQTsgCEEIakEAEKAJEKEJIABBjQEgBkE7IAhBGGpBABCgCSAGQTsgCEEIakEAEKAJEKEJEKEJEM4JIQwLIBAEQCAAIAAgEgJ/AkACQAJAIBFBCWsOAgEAAgsgAEGNASAGQTsgCEEYakEAEKAJIAZBOyAIQQhqQQAQoAkQoQkMAgsgCigCACIJKAIEIAtqIgstAApB4ABxDQAgCSALEJMJIglFDQAgBiAJQQAQpAkMAQsgBkH5AEEAQQAQoAkLIgkQwgkiEiAIQRBqQQAQ2AkLIAdBAWohBwwBCwsgBiAIKAIoEDJBACEJIAooAgAoAgAiDhBaIQsCfyATBEAgDSEPQQAMAQtBACEHIAYgASgCPBD8AiEPIAZBxwBBtbQBEMgJIhAEQCAQQQI6AAELIABBAEEAQQAQvgkiBwRAIAcgBiAOEKABNgIQIAcgBiAGKAIQIA9BBHRqKAIAEKABNgIMC0EAIQ8gACAAKAIAIBAQwQkgByANQQBBAEEAQQBBABDFCQshDSAGQQA7AbQCIAYgBigCsAJBAWo2ArACAkAgBiALQdUAaq0QxQIiB0UNACAHIAdB1ABqIhA2AjAgByAHQSRqIgk2AhwgECAOIAsQ5RQaIAcgBiAPQQEQpAk2AjggByAGIBJBARCQCTYCPCAHIAYgDUEBEKUJNgIsIAxFBEBBACEMDAELIAcgBiAAQRMgDEEAEKEJIgxBARCkCTYCDAsgBiAGKAKwAkEBayIONgKwAkEAIQsgDkUEQCAGLwG2AiELCyAGIAs7AbQCIAYgDxAzIAYgDBAzIAYgEhCuAyAGIA0QnwggBi0AV0EBRgRAIAYgBxDsBwwDC0GKASEGAkACQAJAIBFBB2sOBAIBAQABCyACDQBBgAEhBgwBC0GBASEGCyAJIAc2AgQgCSAGOgAAIAcgASgCPCIGNgIYIAcgBjYCFCAbIAc2AhwgByAUOgAIDAELIAdFDQELIAAgByABIANBAkEAEPkMCyAKKAIMIQoMAAsACyAIQTBqJAALVgIBfwF/An8CfyAALQAAIgFBsAFGBEAgAC0AAiEBCyABQf8BcSICQYoBRwRAQQEiASACQbEBRw0CGiAAQRRqDAELIAAoAhRBHGoLIgAoAgAoAgALIgELnAECAX8BfwJAAn8CQCABLQAAIgRBsQFHBEAgBEGKAUcNAUEAIgQgAEGyAUEAQQAQoQkiAEUNAhogACACOwEgIAAgAzYCHCAAIAE2AgwgACAAKAIEQYCACHI2AgQgAA8LIAEoAhQgAkEEdGoiBUEIaiIEKAIAIQEgAC0A1AFBAk8NAgsgACgCACABQQAQpAkLIgQPCyAFQQA2AgggAQu8BgYBfwF/AX8BfwF/AX8jAEEQayIIJAACQCABQQAgAhtFBEAgASACR0EBdCEEDAELAkAgAEUNACABLQAAQZwBRw0AIAhBADYCDCAAKAIAIAJBAUHBACAIQQxqEL0DGiAIKAIMIgZFDQAgACgCCCIHIAcoAtwBQYCAgIB4QQEgAS4BICIEQQFrdCAEQR9KG3I2AtwBIAAoAugBIAQQyAsiBARAQoSAkICAgIACIAQzARCIQgGDUEUEQCAEEF8aCyAEIAZBABCyB0UhBQsgBhD0ASAEEPQBQQAhBCAFDQELIAIoAgQiBCABKAIEIgVyIgZBgBBxBEAgBCAFcUGAEHEEQEEAIQQgASgCCCACKAIIRg0CC0ECIQQMAQsgAS0AACIFQccARyAFIAItAAAiBEZxRQRAIAVB8QBGBEBBASEEIAAgASgCDCACIAMQ+ApBAkgNAiACLQAAIQQLIARB/wFxQfEARgRAQQEhBCAAIAEgAigCDCADEPgKQQJIDQILQQIhBCABLQAAQakBRw0BIAItAABBpwFHDQEgAigCHEEATg0BQakBIQUgASgCHCADRw0BCwJAIAEoAggiB0UNAAJAAkACQAJAAkAgBUGoAWsOBQIBAQECAAsgBUHxAEYNAkEAIQQgBUH5AEYNBQsgAigCCCIJRQ0DIAVBpwFrDgMDAgMCC0ECIQQgByACKAIIEG0NAyACLQAHQQFxIAEoAgRBgICACHEiBUEYdkcNAyAFRQ0CIAAgASgCLCACKAIsQQEQyQtFDQIMAwtBAiEEIAcgAigCCBBsRQ0BDAILQQIhBCAHIAkQ5hUNAQtBAiEEIAIoAgQgASgCBHNBhAhxDQACQCAGQYCABHENACAGQYAgcQ0BIAZBIHFFBEAgACABKAIMIAIoAgwgAxD4Cg0CCyAAIAEoAhAgAigCECADEPgKDQEgASgCFCACKAIUIAMQmAoNASAGQYCAAXEgAS0AACIAQfUARiAAQaoBRnJyDQAgAS8BICACLwEgRw0BIABBrwFGBEAgAS0AAiACLQACRw0CCyAAQTFGDQAgASgCHCIBIANGDQAgASACKAIcRw0BC0EAIQQLIAhBEGokACAEC/YBAwF/AX8BfwJAAkAgAC8BMiABLwEyRw0AIAAvATQgAS8BNEcNACAALQA2IAEtADZHDQADQCABLwEyIAJLBEAgAkEBdCIDIAEoAgRqLwEAIgQgACgCBCADai8BAEcNAyAEQf7/A0YEQEEAIQNBACACQQR0IgQgASgCKGooAgggACgCKCAEaigCCEF/EPgKDQMLIAEoAhwgAmotAAAgACgCHCACai0AAEcNAyACQQJ0IQQgAkEBaiECQQAhAyAEIAEoAiBqKAIAIAQgACgCIGooAgAQbEUNAQwCCwtBACABKAIkIAAoAiRBfxD4CkUhAwsgAw8LQQALhgIEAX8BfwF/AX8CQCACLQAcQQhxRQ0AIAAoAgAiBi0AGEEEcQ0AAkACQCAGKAIQIAFBBHRqKAIMKAJIIgNFDQAgAy0AHEGAAXENACADLQArQQFGDQAgAy8BIkECRg0BCyAAQYsENgIMIAAgACgCJEEBajYCJEEADwsgACgCeCIDIAAgAxsiBEH0AGohAwJAA0AgAygCACIDRQ0BIAMoAgQgAkcNAAsgAygCDA8LIARBwwAgBkIQEOwCIgMQkAoaIAAoAgAtAFcNACADIAQoAnQ2AgAgBCADNgJ0IAMgATYCCCADIAI2AgQgAyAEKAIsIgJBAmoiBTYCDCAEIAJBBGo2AiwLIAULnAEEAX8BfwF/AX8jAEEgayIDJAAgAAJ/IAIuASAiBEEATgRAIAAoAgAhBSACKAIAIQYgAyACKAIEIARB//8DcUEMbGooAgA2AgQgAyAGNgIAIAVB6dYAIAMQ/QIhBEGTDAwBCyAAKAIAIQQgAyACKAIANgIQIARBvqwBIANBEGoQ/QIhBEGTFAsiAiABIARBekECEIwKIANBIGokAAsaACABQQBKBEAgACgCCEGfASABIAIQigMaCwtYAgF/AX8gACgCCCIEQccAQQAgABCVCSIFEIoDGiAEQYABIAIgAyAFIAFBexD0CBogBCgCbCIBQQBKBEAgBCgCaCABQRhsakEWa0HAADsBAAsgACAFEJYJC7wCCAF/AX8BfwF/AX8BfwF/AX8jAEEgayICJAACQCABBEAgACgCACEDIAIgADYCGCACQQA2AgwgAkEBIgRB2gBqNgIIIAJB2gA2AgQgAiADNgIAIAAgACgCGCIEQe/f/b9/cSIFNgIYIARBkKCCwABxIQdBACEEA0AgASgCACAESgRAIAEgBEEEdGooAggiBgRAIAMgAygC3AEgBigCGGoiBTYC3AFBAiEIIAMgBRCDCg0EIAIgBhDNCxogAigCACIDIAMoAtwBIAYoAhhrNgLcASAAKAIYIgVBkKCCwABxIgkEQCAGIAYoAgQgBUGQgAJxcjYCBCAAIAVB79/9v39xIgU2AhggByAJciEHCyADKAIkQQBKDQQLIARBAWohBAwBCwsgACAFIAdyNgIYC0EAIQgLIAJBIGokACAICyoAA0ACQCAARQ0AIAAoAgBFDQAgACgCHCABRg0AIAAoAhAhAAwBCwsgAAsrAAJAIAAtABdFDQAgACABELALRQ0AIAAgASACELELGg8LIAAgASACEL4LC+8nEwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/IwBBwAFrIgYkACAAKAIIIQUgBkEANgJ8IAZBADYCeAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkADQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUUNAAJAIAAoAkhFDQAgAS0ABkGAAXENACAAIAEgAhCnCyIEQQBODSYLAkAgAS0AACIDQeYAaw5QFhYWFhYWFhYWFgEJFAEBIAEBAQEBAQEBAQEBAQEBAQEBAQEBDwEBAQEBAQEBAQEBAQEBIR8jHgUBAQEBAQEBAQEDEQIiGBAKFRMdBw4GAQoACwJAIANBE2sOJxQPAQEBAQEBAQEBAQEBAQEBHAEBAQEBARYWGAEBCw0SEhcXFxcXFwALIANBxwBGDQMgA0HNAEYNBwsgBUHLAEEAIAIQigMaDCMLIAEuASIiBCABKAIoIgMoAhhIBEAgAy0AAEUEQCADKAIMIARqIQQMJQsgAy0AAQRAIAMoAhQiACAEQQR0aigCACEBIAVB3gAgAygCCCAAIARBBHRqIgAuAQ4gAhDbCBogAUUNJCAALgEMIgNBAEgEQCAGIAEoAgA2AhAgBUG+rAEgBkEQahDzCAwlCyABKAIAIQQgBiABKAIEIANB//8DcUEMbGooAgA2AiQgBiAENgIgIAVB6dYAIAZBIGoQ8wggASgCBCAALgEMQQxsai0ABUHFAEcNJCAFQdcAIAIQ8ggaDCQLIAEoAiwNASAFQd4AIAEoAhwgAS4BICACENsIGgwjCyAFQcsAQQAgAhCKAxoMFwsgAS0ABEEgcQRAIAAgASgCDCACEIELIQRBxAAhAAJAIAEuASAiAkEASA0AIAEoAiwiAS4BIiACTA0AIAEoAgQgAkEMbGosAAUiAEHCAEgNJAsgBUHgACAEQQFBACAAQf8BcUEBdEH8wARqQX8Q9AgaDCMLIAEoAhwiB0EASARAIAAoAjQiA0EASARAIAEvASAiB8EiBEEASARAIANBf3MhBAwlCyABKAIsIgggBBDuCiADayEEIAgoAgQgB0EMbGoiAy8BCiIBQeAAcQRAIAFBgAJxBEAgBiADKAIANgIAIABBqZQDIAYQsgJBACEEDCYLIAMiEUEKaiICIAFBgAJyIgU7AQAgAUGAAXEEQCAAIAggAyAEEKgLIBEvAQohBQsgAyAFQf/8A3E7AQoMJQsgAy0ABUHFAEcNJCAFQdEAIAQgAhCKAxogBUHXACACEPIIGgwjCyADQQFrIQcMIQsgACgCTCIDRQ0gIAEuASAhBANAIANFDSECQCADKAIMIARHDQAgByADKAIERw0AIAAoAgghBSADLQAQBEAgBUEUIAMoAggQ8gghCAsgACADKAIAIAIQgQshBCAAKAIIQeAAIARBAUEAIANBEWpBARD0CBogCARAIAUoAmwhCiAFKAIALQBXBH9BkIIIBSAFKAJoIAhBGGxqCyIDIAo2AgggAyAENgIMCyAEDSQMIgsgAygCFCEDDAALAAsCQCAAKAJ8IgMNACAALQASDQBBACEEIABB9oUBQQAQsgIMIgsCQAJAAkAgAS0AASIEQQJrDgMBAgACCyAFQcYAQQBBBEEAIAEoAghBABD0CBoMFwsgACgCeCIFIAAgBRtBAToAFQsgAEGTDkEBIAMbIATAIAEoAghBAEEAEIwKDBULIAEoAhQiDygCACEOIAAgACgCOEEBayIJNgI4IAAoAgAhDEEAIQMgASgCDCIKBEAgDCAKQQAQpAkhCyAMLQBXBEAgDCALEDMMFgsgCyAAIAsgBkH8AGoQqQsQqgsgBkGIAWpBAEE0EOcUGiAGIAs2ApQBIAZBNToAiAEgBkEANgJ8IAZBiAFqIQgLIA9BCGohBCAOQQFrIQ0DQCADIA1ORQRAIAQgA0EEdCIHaigCACEBAkAgCkUEQCABIQgMAQsgBiABNgKYAQsgACAAKAI4QQFrIgE2AjggACAIIAFBEBDCCiAAIAQgB0EQcmooAgAgAhD3CCAFIAkQ+AgaIAUgARCNCiADQQJqIQMMAQsLAkAgDkEBcQRAIAAgDyANQQR0aigCCCACEPcIDAELIAVBywBBACACEIoDGgsgDCALEDMgBRCrCyAFIAkQjQoMFAsgAC0AFyEEAkAgASgCKCIDRQ0AIAMtAABFBEAgAygCDCABLgEiagwWCyADLQABRQ0AIAVB3gAgAygCCCADKAIUIAEuASJBBHRqLgEOIAIQ2wgaDBQLIAVBFCABKAIcQQAgAhDbCCEHIABBADoAFyAAIAEoAgwgAhD3CCAAIAQ6ABdBACEDIAUoAmwhASAFKAIALQBXBH9BkIIIBSAFKAJoIAdBGGxqCyIDIAE2AggMEwsgAEGosQFBABCyAgwSCyAFQZ0BIAEoAiwiBCABLgEgIgMQ7gogASgCHCAELgEiQQFqbGpBAWogAhCKAxpBAEH+KkHxqgEgASgCHCIHG2ohByAGIAEuASBBAEgEf0GOrQEFIAEoAiwoAgQgA0EMbGooAgALIgE2AmggBiAHNgJkIAYgAjYCYCAFQbfTACAGQeAAahDzCCADQQBIDREgBCgCBCADQQxsai0ABUHFAEcNESAFQdcAIAIQ8ggaDBELIAEtAAVBAnENACAAIAEoAgwgAhD3CCAFQbQBIAIQ8ggaDBsLIAEoAgwhAQwBCwsgACABIAJBAEEAEKwLDBgLIAAgACgCOCIEQQJrIgM2AjggBUHLAEEAIAIQigMaIAAgASAEQQFrIgQgAxCtCyAFQccAQQEgAhCKAxogBSAEEI0KIAVB1gAgAkEAEIoDGiAFIAMQjQoMFwsCQCABKAIMIgIoAhwiAwRAIAAtABogAi0AAk0NAQsgAiAAIAIQrgsiAzYCHCACIAAtABo6AAILIAEoAhwiBCACEPYKIgVHBEAgBiAFNgJUIAYgBDYCUCAAQe7LACAGQdAAahCyAiACKAIcIQMLIAMgAS4BIGohBAwXC0EAIQQgACgCAC0AVw0WAkACQCADQYoBRw0AIAEtAAVBEHFFDQAgASgCFCgCHCgCACIDQQFHDQELIAAgARCuCyEEDBcLIAAgA0EBEK8LDAoLIAEtAAdBAXEEQCABKAIsKAI4IQQMFgsgACgCACILLQBUIQMCQCAALQAXRQ0AIAAgARCwC0UNACAAIAFBfxCxCyEEDBYLIAEoAhQiBARAIAQoAgAhCQsCQAJAAkAgCyABKAIIIAkgA0H/AXFBABDjAyIHRQRAIAAtANMBRQ0BIAtBrPsAIAkgA0H/AXFBABDjAyIHRQ0BCyAHKAIUDQAgBEUgBygCBCIDQYCAgAJxRXJFBEAgACgCCCEDAkACQAJAAkACQAJAAkACQCAHKAIIDgcABgUEBwECAwsgBCgCACEBIAAgACgCOEEBayIFNgI4IAAgBCgCCCACEPcIQQEgASABQQFMGyEHQQEhAQNAIAEgB0ZFBEAgA0EzIAIgBRCKAxogACAEIAFBBHRqKAIIIAIQ9wggAUEBaiEBDAELCyADEKsLIAMgBRCNCgwfCyAGQYgBakEAQTQQ5xQaIAYgBDYCnAEgBkGdAToAiAEgACAGQYgBaiACEIELIQQMHwsCQCAEKAIIIgEtAABBpwFHDQAgASgCHCIAQQBIDQAgA0HdACAAIAEuASAgAhDbCBoMHgsgA0HLAEEAIAIQigMaDB0LIAAgBCgCCCACEIELIQQMHQsgA0HHAEEAIAQoAgggBCgCGEF/EPgKIAIQigMaDBsLIANBxwAgACAEKAIIIAQoAhhBfxCyCyACEIoDGgwaCyAEKAIYIgEtAABBpwFGBEAgA0HHACAEKAIIIAEoAhxBARCeCiACEIoDGgwaCyADQcsAQQAgAhCKAxoMGQtBACEBIAMgAiAEKAIIEOQJIgBBwQBIBH9Bkp0BBSAAQf8BcUECdEHsigZqKAIACyIBEPYIGgwYCyADQYCAoAFxBEAgACABIAcQswsLIAlBACAJQQBKGyEKQQAhAwNAIAMgCkZFBEACQCADQR9LDQAgACAEIANBBHRqKAIIEMoJRQ0AIA1BASADdHIhDQsgBy0ABEEgcUUgCHJFBEAgACAEIANBBHRqKAIIEOsIIQgLIANBAWohAwwBCwsCQCAERQRAQQAhAwwBCwJ/IA0EQCAAIAAoAiwiAyAJajYCLCADQQFqDAELIAAgCRDDCgshAwJAIAcoAgRBwAFxIgpFDQACQCAEKAIIIgwtAABBpwFrDgMAAQABCyAMIAo6AAILIAAgBCADQQBBAhDoCQsCfwJAIAlBAk4EQCABLQAFQQFxRQ0BIARBGGoMAgsgCUEBRw0DCyAEQQhqCyIEKAIAIQQgBkEANgKIASAGQQA2ArwBIARFDQEgBC0AAEGnAUcNASAEKAIsIgRFDQEgBC0AK0EBRw0BIAsgBBC6BygCCCIEKAIAKAJIIgpFDQEgBCAJIAcoAiAgBkGIAWogBkG8AWogChEHAEUNASALIAcoAiAQWkEpaq0QxQIiBEUNASAEIAdBKBDlFCIKIApBKGoiDDYCICAMIAcoAiAiByAHEFpBAWoQ5RQaIAogBigCiAE2AhAgCiAGKAK8ATYCCCAKIAooAgRBEHI2AgQMAgsgBiABNgJAIABBvfwCIAZBQGsQsgIMCwsgByEECyAELQAEQSBxBEAgCEUEQCALKAIIIQgLIAVB1QBBAEEAQQAgCEF+EPQIGgsgACANIAMgAiAJIAQgAS0AAhC0CyAJRSANcg0UIAAgAyAJEMQKDBQLAkACQCABKAIoIgNFDQAgAS4BIiIEQQBIDQAgAygCJCAESg0BCyAGIAE2AjAgAEHV/AIgBkEwahCyAgwJCyADKAIYIAMoAgwgBGpqIQQMFAsgBUHHAEEBIAIQigMaIAUgAyAAIAEoAgwgBkH8AGoQtQsQ8gghBCAFQccAQQAgAhCKAxpBACEBIAUoAmwhAyAFKAIALQBXBH9BkIIIBSAFKAJoIARBGGxqCyIBIAM2AggMBwsgBUHbACAAIAEoAgwgBkH8AGoQtQsgAiABKAIQELYLIgNFIAMgAS0AAkEtRnMQ/wIaDAYLIAUgAyAAIAEoAgwgBkH8AGoQtQsgAhCKAxoMBQsCQAJAAkAgASgCDCIDLQAAQZkBaw4DAQIAAgsgACADQQEgAhC3CwwRCyAFIAMoAghBASACELgLDBALIAZCgJAENwKMASAGQZsBOgCIASAAIAZBiAFqIAZB/ABqELULIQMgBUHrACAAIAEoAgwgBkH4AGoQtQsgAyACENsIGgwECyAAIAEoAgwgBkH8AGoQtQshBCAFIAMgACABKAIQIAZB+ABqELULIAQgAhDbCBoMAwtBAAwBC0E1QTQgA0EtRhshA0GAASEOQQELIQ8gASgCDCIMELkLBEAgASgCECEQIAAoAgghBCAMEPYKIQUgACAAKAI4QQFrIg02AjggACgCJA0BIAEoAgQhASAQEPYKIAVHBEAgAEGosQFBABCyAgwCCyABQQp2QQFxIRIgACAMELoLIRMgACAQELoLIRQgBEHHAEEBIAIQigMaQTVBNkE4IAMgA0E3RhsgA0E5RhsgA0E0RhshCSAFQQJrIRUgBUEBayELQQAhAQNAIAZBADYCiAEgBkEANgK8ASAGQQA2AoQBIAZBADYCgAEgBwRAQQAhBSAEKAJsIQggBCgCAC0AVwR/QZCCCAUgBCgCaCAHQRhsagsiBSAINgIICyAAIAwgASATIAZBhAFqIAZBiAFqELsLIQggACAQIAEgFCAGQYABaiAGQbwBahC7CyEKIAQoAmwhByAAIAYoAoQBIAYoAoABIAlB/wFxIgUgCCAKIA0gDiASELwLIAAgBigCiAEQlgkgACAGKAK8ARCWCQJAAkAgBUE2aw4DAAEAAQsgASALTg0AIARBOhDxCCEHCwJAIA8EQCAEQccAQQAgAhCKAxoMAQsgBEHcACAIIAIgChDbCBoLIAEgC0cEQAJ/IAVBNUYEQCAEQTMgAiANEIoDGkE1DAELIARBCUEAIA0QigMaIAMgCSABIBVGGwshCSABQQFqIQEMAQsLQQAhBSAEKAJsIQEgBCgCAC0AVwR/QZCCCAUgBCgCaCAHQRhsagsiBSABNgIIIAQgDRCNCiADQTRHDQEgBEETIAIgAhCKAxoMAQsgACAMIAZB/ABqELULIQQgACABKAIQIAZB+ABqELULIQcgBUHHAEEBIAIQigMaIAAgDCABKAIQIAMgBCAHIAUoAmxBAmogDiABKAIEQQp2QQFxELwLIA8EQCAFQccAQQAgAhCKAxoMAQsgBUHcACAEIAIgBxDbCBoLIAILIQQgACAGKAJ8EJYJIAAgBigCeBCWCQwKCyAAIAEoAgwgAhD3CCAFQdgAIAIgASgCCEEAEO0IEIoDGgwICyABKAIcIQQMCAsgBUHOACABLgEgIAIQigMaDAYLIAVBzQAgASgCCEECaiIBEFpBAWsiAEECbSACQQAgBSgCACABIAAQ7ghBehD0CBoMBQsgBSACIAEoAggQ9ggaDAQLIAUgASgCCEEAIAIQuAsMAwsgBUHHACABELYLIAIQigMaDAILIAAgAUEAIAIQtwsMAQsgAS0AAiEDIAAoAgggASgCLCAHIAEuASAgAhCSCSADRQ0AIAAoAggQvQsiAC0AACIBQbABRwRAIAFB3gBHDQEgACADOwECDAELIAAgA0EBcTsBAgsgAiEECyAGQcABaiQAIAQLJgEBfyMAQRBrIgIkACACIAE2AgAgAEHb+wIgAhCyAiACQRBqJAALDQAgAEHgACABEJAKRQucAQEBfwNAIAAEQAJAIAAoAiQiAkUNACACKAIYIgIgASgCAEwNACABIAI2AgALAkAgACgCLCICRQ0AIAIoAhgiAiABKAIATA0AIAEgAjYCAAsCQCAAKAI8IgJFDQAgAigCGCICIAEoAgBMDQAgASACNgIACyAAKAIcIAEQhQsgACgCKCABEIULIAAoAjAgARCFCyAAKAI0IQAMAQsLC1sDAX8BfwF/AkAgAEUNACAAKAIAIQQDQCACIARODQECQCAAIAJBBHRqKAIIIgNFDQAgAygCGCIDIAEoAgBMDQAgASADNgIAIAAoAgAhBAsgAkEBaiECDAALAAsLYwIBfwF/IAAoAgAhAyAALwGSASICBEAgACgCdCACQQF0EDcgAyAAKAJ0EDILIAAgATsBkAEgACABOwGSASAAIAMgAUHQAGytEOwCIgI2AnQgAgRAIAIgAUEBdCADQQEQjgMLCy8AIAAoAgAtAFdFBEAgACgCdCAALwGSASACbCABakEobGogA0J/QQEgBBCaARoLCx4AIAEEQCAAQQEgARD2CBogAEHUAEEBQQEQigMaCwtwAgF/AX8gACABLQAHIgJBASACGxCGCwJAIAJFBEAgAEEAQQAgASgCAEEAEIcLDAELIAEtAAYhA0EAIQEDQCABIAJGDQEgACABQQAgA0ECdEGAiwZqKAIAQQAQhwsgA0EBaiEDIAFBAWohAQwACwALCzkBAX8jAEEQayICJAAgAiABNwMIIABByABBASACQQhqQXMQvwsgAEHUAEEBQQEQigMaIAJBEGokAAs7AQF/IABFBEBBAA8LIAAoAgQiAi8BGCEAIAFBAE4EQCACIABBc3EgAUECdHIiADsBGAsgAEECdkEDcQs2AQF/AkAgAUEASA0AIAAtAAwNACAAKALoASICBEAgAi0AK0ECRg0BCyAAIAE6AAQLIAAtAAQLWgMBfwF/AX8CQCAALQBVRQ0AIAAoAhQhAiAAKAIQIQEDQCACQQBMDQEgASgCBCIDBEAgAyABMQAIIAApAyBCOIOEpxCcCAsgAkEBayECIAFBEGohAQwACwALC1MCAX8BfyAAKAIAIgEoAhAoAhQiAkUEQEEADwsCQCABLQBVBEAgAi0ACEUNAQsgAEHJ/gBBABCyAkEBDwsgAhDvASABKAIQQQA2AhQgARDAAUEAC7MBAgF/AX8jAEEQayIFJAAgBSADNgIMQQAhAwNAAkAgAiADai0AACIEQekARwRAIARB8wBHBEAgBEUEQCAAQdQAIAEgAxCKAxoLIAVBEGokAA8LIAUgBSgCDCIEQQRqNgIMIABB9QBBywAgBCgCACIEG0EAIAEgA2pBACAEQQAQ9AgaDAELIAUgBSgCDCIEQQRqNgIMIABBxwAgBCgCACABIANqEIoDGgsgA0EBaiEDDAALAAtVBAF/AX8BfwF/QQEgACgCbCIBIAFBAUwbIQJBASEBAkADQCABIAJGDQEgAUEYbCEDIAFBAWohASADIAAoAmgiBGotAABBpgFHDQALIARBuwE6ABgLCzEBAX8gAEHUAEEDQQEQigMaIABBO0EBIAAoAmxBAmpBARDbCCEBIABBxgAQ8QgaIAELLQACQCAAEL0LIgAoAgwgAUcNACAALQAAQd4ARw0AIAAgAC8BAkGAAXI7AQILC1QBAX8gASgCBCADQQF0ai4BACIFQX5GBEAgACACQQFqNgI0IAAgASgCKCADQQR0aigCCCAEEL4LIABBADYCNA8LIAAoAgggASgCDCACIAUgBBCSCQuaBQQBfwF/AX8BfyMAQRBrIgYkACAAKAIIIQUgBkEANgIMIAZBADYCCCABRSAFRXJFBEACfwJAAkACQAJAAkACQAJAAkACQCABLQAAIgRBK2sODwEBAwgIBgcFBQQEBAQEBAALAkAgBEGrAWsOBQMICAgCAAsgBEETRw0HIAAgASgCDCACIAMQwgpBAAwICyABIAEQxwsiB0cEQCAAIAcgAiADEJQLQQAMCAsgBEEsRgRAIAAgACgCOEEBayIENgI4IAAgASgCDCAEIANBEHMQwgogACABKAIQIAIgAxCUCyAFIAQQjQpBAAwICyAAIAEoAgwgAiADEJQLIAAgASgCECACIAMQlAtBAAwHCyABLQACQasBRiIFQQR0IQMgASgCDCEEIAEoAhAQtgsgBUcEQCAAIAQgAiADEJQLQQAMBwsgACAEIAIgAxDCCkEADAYLQTVBNCAEQS1GGyEEQYABIQMLIAEoAgwiBxC5Cw0DIAAgByAGQQxqELULIQUgACABKAIQIAZBCGoQtQshByAAIAEoAgwgASgCECAEIAUgByACIAMgASgCBEEKdkEBcRC8CyAGKAIIDAQLIAUgACABKAIMIAZBDGoQtQsiARCSCyAFIAQgASACEIoDGkEADAMLIAAgASACQeEAIAMQrAtBAAwCCyAAIAAoAjhBAWsiBDYCOCAAIAEgBCACIAQgAxsQrQsgBSACEPgIGiAFIAQQjQpBAAwBCyABKAIEIgdBgYCAgAFxQYCAgIABRgRAIAUgAhD4CBpBAAwBC0EAIgQgB0GBgICAAnFBgICAgAJGDQAaIAVBECAAIAEgBkEMahC1CyACIANBAEcQ2wgaQQALIQQgACAGKAIMEJYJIAAgBBCWCQsgBkEQaiQAC+0CAwF/AX8BfyAAKAIIIQogBQRAIAEoAiQiCARAIAAgACgCOEEBayIGNgI4IAUgBjYCACAAIAJBAWo2AjQgACAIIAUoAgAQiQxBACEGIABBNGohBQsgBUEANgIACyAAAn8CQCAERQ0AIAEtADdBCHFFDQAgAUEyagwBCyABQTRqCyIFLwEAIggQwwohCQJ/QQAiBCAGRQ0AGiAHIAlGBEAgBiIEIAYoAiRFDQEaC0EACyEEQQAhBQNAIAUgCEZFBEACQAJAIARFDQAgBUEBdCIGIAQoAgRqLwEAIgdB/v8DRg0AIAcgASgCBCAGai8BAEYNAQsgACABIAIgBSAFIAlqEJMLIAEoAgQgBUEBdGouAQBBAEgNACAKKAJsIgZBAEwNACAKKAJoIAZBAWsiBkEYbGotAABB1wBHDQAgCiAGEKwKCyAFQQFqIQUMAQsLIAMEQCAKQeEAIAkgCCADENsIGgsgACAJIAgQxAogCQsRACABBEAgACgCCCABEI0KCwu0AQMBfwF/AX8jAEEQayIEJAACQCABKAIEIAJBDGxqIgIvAQhFDQAgBEEANgIMIAAoAgAtAFQhBSABKAIAIQYgBCACKAIANgIEIAQgBjYCACAAQenWACAEEPMIIAAoAgAgASACEJMJIAUgAi0ABSAEQQxqEL0DGiAEKAIMIgVFDQAgACAFQXYQqgoLAkAgAi0ABUHFAEcNACABLQArQQFGDQAgAEHXACADEPIIGgsgBEEQaiQAC5sCAwF/AX8BfyMAQRBrIgQkAAJ/IABFBEBBAAwBCyAAKAIEKAIIIQUgACgCACgCFAshAwJAIAIoAgAQ/gEgAygCmAFKBEAgAEG2KEF/EJsCDAELAkAgAUEDRgRAIAQgAigCCBBfIgM2AgQgA0UNAiADEJoJQQFHBEAgAEHo8wBBfxCbAgwDCyAEQQRqEJ8DIgEgBS0AAEcEQCABIAUtAAFHDQILIAQgBSgAACIDNgIIIANB/wFxIAFGBEAgBEEAOgAICyAEQQhqIQUgASADQQh2Qf8BcUcNASAEQQA6AAkMAQsgBS0AAiEBCyACKAIAEF8hAyACKAIEEF8iAkUgA0VyDQAgACADIAIgBSABEJ4DRRCeAgsgBEEQaiQAC7AECwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEEQayIJJAAgAigCKCEKAkACQAJAAkAgAigCFCIIQQFGBEAgAS4BICIEQQBIDQEgCkUNAiABKAIEIARBDGxqKAIAIAoQbQ0BDAQLIARFBEAMAQsgACgCACAIQQJ0rRDsAiIFRQ0CIAQgBTYCAAsgCEEAIAhBAEobIQsgAUEIaiEEA0ACQAJAAkACQCAEKAIAIgYEQCAIIAYvATJHDQMgBi0ANkUNAyAGKAIkDQMgCkUNAUEAIQcDQCAHIAtGBEAgCyEHDAQLIAYoAgQgB0EBdGouAQAiBEEASA0DQQAhDSAHQQJ0Ig4gBigCIGooAgAgASgCBCAEQf//A3FBDGxqIgwQjgQiBEGAtAMgBBsQbQ0DIAwoAgAhDUEAIQQDQCAEIAhGIgwNBCACIARBA3RqIg8oAiggDRBtBEAgBEEBaiEEDAEFIAUEQCAFIA5qIA8oAiQ2AgALIAwNBSAHQQFqIQcMAgsACwALAAsgAC0AmQFFBEAgAigCACgCACEEIAkgAigCCDYCBCAJIAQ2AgAgAEGVkgMgCRCyAgsgACgCACAFEDIMBgsgBi8AN0EDcUECRw0BIAVFDQJBACEEA0AgBCALRg0DIAUgBEECdGogAiAEQQN0aigCJDYCACAEQQFqIQQMAAsACyAHIAhGDQELIAZBFGohBAwBCwsgAyAGNgIAC0EAIQUMAQtBASEFCyAJQRBqJAAgBQsmACAAQQdrIgBB/wFxQQNLBEBB6+4BDwsgAMBBAnRB8N0GaigCAAvTAQUBfwF/AX8BfwF/IwBBIGsiBCQAQX9BgJDwASADGyEHA0AgAQRAAkAgASgCEEUNACADQQEgASgCBCIGQYCAEHEbRQ0AIAEoAhgEf0HmKwVB78MBQbTuACABKAIUIgUbCyEFIAEoAiAhCCAEIAEsAAA2AhAgBCAGIAdxQYCAgAFzNgIUIAQgBTYCCCAEIAI2AgQgBCAINgIAIARBACIFQcCPBmogBkEDcUECdGooAgA2AgwgAEEBQbeLASAEEI8LCyABKAIMIQEMAQsLIARBIGokAAtaBAF/AX8BfwF/IAAoAgAiBSgCECECA0AgAyAFKAIUTkUEQCACKAIMQRBqIQQDQCAEKAIAIgQEQCAAIAQoAgggARCdCwwBCwsgAkEQaiECIANBAWohAwwBCwsLowEDAX8BfwF/AkAgAS0AK0EBRg0AIAFBCGohAwNAIAMoAgAiBEUNAQJAAkAgAkUNACAELwE0IQVBACEDA0AgAyAFRg0CIAQoAgQgA0EBdGouAQBBAE4EQCAEKAIgIANBAnRqKAIAIAIQbUUNAgsgA0EBaiEDDAALAAsgAEEAIAAoAgAgASgCPBD8AhC1CSAAIARBfxCKCgsgBEEUaiEDDAALAAsLggEEAX8BfwF/AX8gACgCACgCECABQQR0aigCDCECIABBACABELUJIAAgACgCKCIDQQNqNgIoIAAgASADQQBBABCJDSACQRBqIQIgACgCLEEBaiEEIAAoAighBQNAIAIoAgAiAgRAIAAgAigCCEEAIAMgBCAFEIoNDAELCyAAIAEQiw0LHAEBfyAAIAAgARCECSIBEIcBIQIgACABEDIgAgt3AgF/AX8gAEEAIAAoAgAgASgCPBD8AiIDELUJIAAgACgCKCIEQQNqNgIoAkAgAgRAIAAgAyAEIAIoAgBBnykQiQ0MAQsgACADIAQgASgCAEGEiAEQiQ0LIAAgASACIAQgACgCLEEBaiAAKAIoEIoNIAAgAxCLDQsJACAAIAEQpQgLSAEBfyMAQRBrIgMkAAJAA0AgAQRAIAEoAgAgAhBtRQ0CIAEoAiQhAQwBCwsgAyACNgIAIABB++AAIAMQsgILIANBEGokACABCzwAQQAgARDKCUUEQCAALQDUAUECTwRAIAAgARCCCgsgACgCACABEDMgACgCAEH5AEEAQQAQoAkhAQsgAQtKAQF/IAAoAmwiAwRAIAAoAgAgACgCaCADQRhsakEEaygCABAyIAAoAgAgASACELMBIQIgACgCaCAAKAJsQRhsakEEayACNgIACwtQAQF/A0ACQCAARQ0AIAAoAgQiAUGAwCBxRQ0AAn8gAUGAgCBxBEAgACgCFEEIagwBCyAALQAAQfEARw0BIABBDGoLIgAoAgAhAAwBCwsgAAtfACABLQABBEAgAUEANgIQIAFBADoAAQsgA0EASARAIAAgASAAKAJoa0EYbSACIAMQvQoPCyADRQRAIAIQWiEDCyAAKAIAIAIgA60QyAghAyABQfoBOgABIAEgAzYCEAvHAwYBfwF/AX8BfwF/AX8jAEEgayIGJAAgAEHIAGohAwNAAkACQCADKAIAIgNFBEBBfyECDAELIAMoAgQiBEEASA0BAkAgACgCNCIHRQRAIAQhBQwBC0F/IQUgBCAHQQFrRw0CC0EAIAEgAygCACAFEPgKDQECQCABEOQJIgRBwQBNBEAgAy0AEUHBAEcNAwwBCyADLQARIQUgBEHCAEYEQCAFQf8BcUHCAEYNAQwDCyAFQf8BcUHDAEcNAgsgACgCCCEEIAMtABAEQCAEQRQgAygCCCAEKAJsIghBA2ogAhDbCBogBEHeACADKAIIIAMoAgwgAhDbCBogAygCGCEFIAYgAygCDDYCFCAGIAU2AhAgBEEAIgdBzL0BaiAGQRBqEPMIIARBABD4CBogACgCSCEDIABBADYCSCAAIAEgAhD3CCAAIAM2AkggBCgCbCEFIAQoAgAtAFcEf0GQgggFIAQoAmggCEEYbGpBMGoLIgMgBTYCCAwBCyAEQd4AIAMoAgggAygCDCACENsIGiADKAIYIQUgBiADKAIMNgIEIAYgBTYCACAEQcy9ASAGEPMICyAGQSBqJAAgAg8LIANBFGohAwwACwALrwEDAX8BfwF/IAAoAiQhBiAAKAIIIQQgACgCNCIFQQBMBH9BAAUgBEEUIAVBAWtBACADENsICyEFIAAgASACEJMJIAMQvgsgAiwABUHCAE4EQCAEQeAAIANBAUEAIAJBBWpBARD0CBoLIAUEQEEAIQMgBCgCbCECIAQoAgAtAFcEf0GQgggFIAQoAmggBUEYbGoLIgQgAjYCCAsgBiAAKAIkSARAIAAoAgBBfzYCRAsLjgECAX8BfyABEPYKIgNBAUYEQCAAIAEgAhC1Cw8LIAJBADYCAAJAIAEtAABBigFGBEAgACABEK4LIQIMAQsgACAAKAIsIgIgA2o2AiwgA0EAIANBAEobIQMgAkEBaiECA0AgAyAERg0BIAAgASgCFCAEQQR0aigCCCACIARqEIALIARBAWohBAwACwALIAILNAAgABClCyIABEAgACABNgIcIAAgAC0AADoAAiAAQbABOgAAIAAgACgCBEH/v39xNgIECws0AQF/AkAgABC9Cy0AAEHQAEcNACAAKAJsIgFBAEwNACAAKAJoIAFBGGxqQRZrQQE7AQALC5YCBAF/AX8BfwF/IwBBsAFrIgUkACAFQQA2AgQgACgCACEHIAVBQGtBAEE0EOcUGiAFQQhqQQBBNBDnFBogBUH4AGpBAEE0EOcUGiAHIAEoAgxBABCkCSEGIActAFdFBEAgBUEsOgB4IAUgBjYCTCAFQTk6AEAgBSAFQQhqNgKIASAFIAVBQGs2AoQBIAEoAhQiASgCCCEIIAUgBjYCFCAFQTc6AAggBSAINgJQIAUgASgCGDYCGCAGIAAgBiAFQQRqEKkLEKoLAkAgAwRAIAAgBUH4AGogAiAEIAMRCAAMAQsgBiAGKAIEQQFyNgIEIAAgBUH4AGogAhCBCxoLIAAgBSgCBBCWCQsgByAGEDMgBUGwAWokAAvSCRABfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQRBrIgokACAKQQA2AgwgCkEANgIEIAEoAgwhDiAALQAXIQYgACABEMELRQRAIAAgARDCCyEPIAAoAgAgASgCDBD2CiIIQQVsQQFqrRDFAiEQAkAgACgCAC0AVw0AIAAoAggiBUGV7wBBABC1CiAAIAFBAyAKQQxqQQAgAiADRyIMGyAQIApBBGoQwwshCSAAQQA6ABcgACAOIApBCGoQqQshESAAIAY6ABcgCEEAIAhBAEobIQcDQAJAIAQgB0YEQCAHIQQMAQsgECAEQQJ0aigCACAERw0AIARBAWohBAwBCwsgESEGAkAgBCAIRg0AIAAgCBDDCiEGQQAhBANAIAQgB0YNASAFQdAAIAQgEWogECAEQQJ0aigCACAGakEAENsIGiAEQQFqIQQMAAsACwJAIAlBBUYEQCAAIAAoAjhBAWsiCTYCOCABKAIUIQtBACEEIAAgASgCDBDrCCEIQQAhASACIANHBEAgBUHmACAGIAYgABCVCSIBENsIGgsDQCAEIAsoAgBORQRAIAAgCyAEQQR0aiISQQhqIg4oAgAgChC1CyEHAkAgAUUNACASKAIIELoKRQ0AIAVB5gAgASAHIAEQ2wgaCyAAIAooAgAQlgkCQAJ/AkAgDEUEQCAEIAsoAgBBAWtODQELIAVBM0E1IAYgB0YbIAYgCSAHIAhBfhD0CBogBSgCbCIHQQBMDQIgDy0AAAwBCyAFQTJBNCAGIAdGGyAGIAIgByAIQX4Q9AgaIAUoAmwiB0EATA0BIA8tAABBEHILIQ4gBSgCaCAHQRhsakEWayAOwDsBAAsgBEEBaiEEDAELCyABBEAgBUEyIAEgAxCKAxogBSACEPgIGgsgBSAJEI0KIAAgARCWCQwBC0EAIQQgAiELIAIgA0cEQCAAIAAoAjhBAWsiDTYCOCANIQsLA0AgBCAHRwRAIAAoAiQNAyABKAIMIAQQxAsQugoEQCAFQTIgBCAGaiALEIoDGgsgBEEBaiEEDAELCwJ/IAlBAUYEQCAFQR4gCigCBCIJIAIgBhDbCBogBUEJEPEIDAELIAVB4AAgBiAIQQAgDyAIEPQIGiAKKAIEIQkgDEUEQCAFQRwgCSACIAYgCBD/AhoMAgsgBUEdIAlBACAGIAgQ/wILIRMgCigCDCIERSAIQQFHckUEQCAFQTMgBCACEIoDGgsgDEUEQCAFIAIQ+AgaCyANBEAgBSANEI0KCyAFQSQgCSACEIoDIQ0gAiEMIAhBAk4EQCAAIAAoAjhBAWsiDDYCOAtBACEEA0AgBCAHRkUEQCAAEJUJIQsgACAOIAQQxAsQ6wghASAFQd4AIAkgBCALENsIGiAFQTQgBCAGaiAMIAsgAUF+EPQIGiAAIAsQlgkgBEEBaiEEDAELCyAFQQlBACADEIoDGiAIQQJOBEAgBSAMEI0KIAVBJyAJIA1BAWoQigMaIAVBCUEAIAIQigMaC0EAIQcgBSgCbCEEIAUoAgAtAFcEf0GQgggFIAUoAmggE0EYbGoLIgcgBDYCCAsgBiARRwRAIAAgBhCWCQsgBUGj7wBBABDzCAsgACgCACAQEDIgACgCACAPEDILIApBEGokAAumBQgBfwF/AX8BfwF/AX8BfwF/IwBBQGoiAyQAAkAgACgCJA0AIAAoAgghBSABKAIUIQQgASgCBCICQYCAgBBxBEAgAyAEKAIQNgIQIABBAEHgvwEgA0EQahCgCiAFQQogASgCMCABKAIsEIoDGiABKAIcIQIMAQsgASACQYCAgBByNgIEQQEhBiAAIAAoAixBAWoiAjYCLCABIAI2AjAgASAFQcoAQQAgAhCKA0EBajYCLCABLQAEQcAAcUUEQCAFQQ8Q8QghCAsgAyAEKAIQNgIEIANBACICQemfA0HEngMgCBtqNgIAIABBAUHLvwEgAxCgCiABLQAAQYoBRyIJRQRAIAQoAhwoAgAhBgsgACgCLCECIANCADcDMCADQgA3AyggAyACQQFqIgc2AiQgACACIAZqIgI2AiwCfyAJRQRAIAMgBjYCMCADIAc2AiwgBUHLAEEAIAcgAhDbCBpBCiEHQZw3DAELIAVBxwBBACAHEIoDGkEDIQdBsTcLIQJBACEGIAUgAkEAEPMIIAMgBzoAICAAKAIAIQICQCAEKAI8BEAgAkGbAUH81gIQyAkiBwRAIAdBwwA6AAEgAEE0IAIgBCgCPCgCDEEAEKQJIAcQoQkhBgsgACAEKAI8KAIMEIMLGiAEKAI8IAY2AgwMAQsgBCAAQZQBIAJBmwFBt88CEMgJQQAQoQk2AjwLQQAhAiAEQQA2AgggACAEIANBIGoQ5gkEQCABIAEtAAA6AAIgAUG2AToAAAwBCyABIAMoAiQiAjYCHCAIBEBBACEGIAUoAmwhBCAFKAIALQBXBH9BkIIIBSAFKAJoIAhBGGxqCyIGIAQ2AggLIAVBwwAgASgCMCABKAIsQQEQ2wgaIABBADYCHCAAQQA6ABMLIANBQGskACACCzYBAX8jAEEQayIDJAAgACgCJEUEQCADIAI2AgQgAyABNgIAIABByb4BIAMQsgILIANBEGokAAsLACAAIAFBAhCBCgvzAgQBfwF/AX8BfwJAIAAoAkQiBUUgAkEATnINACAFQQhqIQMgBSgCACEEA0AgBEEATA0BAkAgAy0ACUEIcQRAQQAgAygCACABQX8Q+ApFDQELIARBAWshBCADQRBqIQMMAQsLIAMoAgwPCwJAIAAoAgAgAUEAEKQJIgNFDQAgAy0ABEEIcUUNACAAKAIIIgRBDxDxCCEFIABBADoAFyAAKAIAIgEtAFdFBEAgAkEASARAIAAgACgCLEEBaiICNgIsCyAAIAMgAhD3CCAAKAIAIQELIABBAToAFyABIAMQoAhBACEBIAQoAmwhAyAEKAIALQBXBH9BkIIIBSAEKAJoIAVBGGxqCyIEIAM2AgggAg8LIAAgBSADEMIJIgMEQCADIAMoAgBBAWtBBHRqIgQiBkERaiIBIAYvABFB9/8DcSACQRx2QQhxcjsAACACQQBIBEAgACAAKAIsQQFqIgI2AiwLIAQgAjYCFAsgACADNgJEIAILbwIBfwF/QQEhBAJAIAAgASACIAMQ+ApFDQAgAi0AACIFQStGBEAgACABIAIoAgwgAxCyCw0BIAAgASACKAIQIAMQsgsNASACLQAAIQULIAVBM0YEQCAAIAEgAigCDCADQQAQ0AsNAQtBACEECyAEC08BAX8jAEEQayIDJAACQCABLQAHQcAAcUUNACACLQAGQQhxRQRAIAAoAgAtACBBgAFxDQELIAMgATYCACAAQcf7AiADELICCyADQRBqJAALqQECAX8BfyAAKAIIIQggACgCACAEQQJ0QRxqrBDsAiIHRQRAIAAoAgAgBRCUBw8LIAcgBDoAGiAHQQA2AhQgB0EANgIMIAcgBTYCBCAHQQA2AgAgByAIKAJsNgIQIAhBwQBBwgAgBhsgASACIAMgB0FxEPQIGiAIKAJsIgdBAEoEQCAIKAJoIAdBGGxqQRZrIAZBLnE7AQALIAAoAngiByAAIAcbQQE6ABULagEBfyABEKULIQMCQCAALQAXRSADRXINACADLQAAQbABRg0AIAAgAxCwC0UNACACQQA2AgAgACADQX8QsQsPCyAAEJUJIgEgACADIAEQgQsiA0cEQCAAIAEQlglBACEBCyACIAE2AgAgAwsOACAAEKULKAIILQAERQuCAgUBfwF/AX8BfwF+IwBBEGsiBCQAIAAoAgghBQJAIAEtAAVBCHEEQCAFQccAQQAgASgCCCIBayABIAIbIAMQigMaDAELAkAgASgCCCIGIARBCGoQogQiB0ECRiACQQBHIAdBA0dyRXJFBEAgAkUgBCkDCCIIQoCAgICAgICAgH9Scg0BCyAGQdYpQQIQbkUEQCAEIAE2AgQgBEEAIgFBztcCQemfAyACG2o2AgAgAEG72wEgBBCyAgwCCyAFIAYgAiADELgLDAELIAIEQCAEQoCAgICAgICAgH9CACAIfSAHQQNGGzcDCAsgBUHIACADIARBCGpBcxC/CwsgBEEQaiQAC0sBAX8jAEEQayIEJAAgAQRAIAEgBEEIaiABEFpBARD2AhogAgRAIAQgBCsDCJo5AwgLIABBmQEgAyAEQQhqQXQQvwsLIARBEGokAAsKACAAEPYKQQFKCxsBAX8gAS0AAEGKAUYEQCAAIAEQrgshAgsgAgt+AQF/An8CQAJAAkAgAS0AACIGQbABaw4CAAIBCyAEIAEgAhDECzYCACABKAIcIAJqDwtBACIFIAZBigFHDQEaIAQgASgCFCgCHCACQQR0aigCCDYCACACIANqDwsgBCABKAIUIAJBBHRqKAIIIgE2AgAgACABIAUQtQsLIgULdgACQCAAKAIkDQACfyAIBEAgACACIAEQugMMAQsgACABIAIQugMLIQggASACEOQJEMALIQIgACgCCCADIAUgBiAEIAhBfhD0CBogACgCCCIAKAJsIgFBAEwNACAAKAJoIAFBGGxqQRZrIAIgB3JB/wFxOwEACwsjACAAKAIALQBXBEBBkIIIDwsgACgCaCAAKAJsQRhsakEYawssAQF/IAAoAgAiAyABQQAQpAkhASADLQBXRQRAIAAgASACEPcICyADIAEQMwsvAQF/IAAoAgBCCBDsAiIF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IAZ8IAdVG0F/EJcCCw8LIAUhCANAIAJB/wFxRSADUHJFBEAgCEEBaiEEAkAgAkH/AXFBvwFLBEADQCAEIghBAWohBCAILQAAIgJBwAFxQYABRg0ADAILAAsgBC0AACECIAQhCAsgA0IBfSEDDAELCyAAIAUgCCAFa6xBf0EBEKgCC+gBAgF/AX8jAEEQayIDJAACQCAAQSgQwQIiAEUgAigCABD0AiIEQQVGcg0AIAAgACkDGEIBfDcDGCAALQAgRQRAIARBAUcEQCAAIAApAxAQug0gAEEBOgAgIAAgAigCABBRELsNDAILIAMgACkDEDcDCCADQQhqIAIoAgAQXBC/B0UEQCAAIAMpAwg3AxAMAgsgAEEBOgAhIAAgACkDEBC6DSAAQQE6ACAgACACKAIAEFwQvA0MAQsgBEEBRgRAIAAgAigCABBcELwNDAELIABBADoAISAAIAIoAgAQURC7DQsgA0EQaiQAC00BAX4gAAJ8IAFCgICAgICAgAh9QoCAgICAgIBwWARAIAAgASABQoCAAYEiAn25OQMAIAK5DAELIAAgAbk5AwBEAAAAAAAAAAALOQMIC3gBAX8jAEEgayICIAE5AxggAiAAKwMAOQMQIAIgAisDECACKwMYoDkDCCAAIAArAwgCfCACKwMQmSACKwMYmWQEQCACKwMQIAIrAwihIAIrAxigDAELIAIrAxggAisDCKEgAisDEKALIgGgOQMIIAAgAisDCDkDAAtAAQF+AkAgAUKAgICAgICACH1CgICAgICAgHBWBEAgASECDAELIAAgASABQoCAAYEiAn25ELsNCyAAIAK5ELsNC4MBAwF/AXwBfAJAIABBABDBAiIBRQ0AIAEpAxhCAFcNACABLQAgBEAgAS0AIQRAIABBwypBfxCbAg8LIAErAwAhAiABKwMIIgO9QoCAgICAgID4/wCDQoCAgICAgID4/wBSBEAgACADIAKgEJgCDwsgACACEJgCDwsgACABKQMQEKACCwunAQIBfgF/IABBKBDBAiIARSACKAIAEPQCIgRBBUZyRQRAIAAgACkDGEIBfTcDGCAALQAgRQRAIAIoAgAQXCEDIAAgACkDECADfTcDEA8LIAIoAgAhAiAEQQFGBEAgAhBcIgNCgICAgICAgICAf1IEQCAAQgAgA30QvA0PCyAAQv///////////wAQ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HBBcIQ8gAigCIBBcIRACQCANRSAMRSAFRXJyDQAgDqciCkEASA0AIAkoAuwCIREgCSAFIAQQhAMiCEUNACAKIAguASJODQAgCCgCBCAKQQxsaigCACELIANBADYCyAIgA0HAAmoiB0IANwMAIANCADcDuAIgA0F/IAogCiAILgEgRhs2AsACIAlBADYC7AIgA0EgaiAEIAkgDCAQpxDUDSEHIANBADYCFCADQgA3AgwgA0EBIgZB7gBqNgIIIANB8AA2AgQgAyAINgLEAiADIANBuAJqNgIYIAMgA0EgajYCAAJAIAcNAAJAAkAgAygCkAIiBgRAAkACQCAGLQArDgMBBAAECyAGKAIsIgQgBCgCBEH///9+cTYCBCADQQA2AiwgA0EgaiAEQQAQkQpBByADKAIsIAktAFcbIgcNBCADIAQQsQkaDAMLIAUgBigCABBsIQcgAyAGNgLEAiAHDQEgBi4BIiAKSgRAIANBIGogA0G4AmogBigCBCAKQQxsaigCABDXDRoLIAMoAsACQQBIBEAgA0EgaiADQbgCaiADKAKQAkEgahDXDRoLIAMgAygCkAIoAhAQswkaIAMoApACQQhqIQQDQCAEKAIAIgQEQCADIAQoAigQswkaIARBFGohBAwBCwsgA0GUAmohBANAIAQoAgAiBARAIAMgBCgCKBCzCRogBEEUaiEEDAEFQQAhBANAIAQgAygCkAIiBi4BIk4NBCADIAYgBigCBCAEQQxsahCTCRCyCRogBEEBaiEEDAALAAsACwALIAMoApQCIgUEQCADIAUoAigQswkaIAMgAygClAIoAiQQsgkaDAILIANBIGoQ2A0iBw0CIAMoApgCQRxqIQUDQCAFKAIAIgUEQAJAIAUoAgwiB0UNACADQSBqQQAgByAEEPsCIAhHDQAgBSgCICIHBEAgA0EgaiADQbgCaiAHKAIIIAsQ2Q0LIANBIGogA0G4AmogBSgCHCALENoNIANBIGogA0G4AmogBSgCGCALENkNCyAFQShqIQUMAQsLIAggAygCnAFGBEAgA0EgaiADQbgCaiADKAKYAigCECALENoNCyADIAMoApgCENsNDAELIAZBMGohBANAIAQoAgAiCEUNAUEAIQQDQCAEIAgoAhRORQRAAkAgBw0AIAggBEEDdGpBJGoiBigCACAKRw0AIANBIGogA0G4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QgBSDQELCyADIAo2AmALQQAhCSAGQQA2AlAgBkEANgJEIAYgBikDOEIBfDcDOCAFrBDRDyAFICdqakEBaiEECyASIBIpAwAgBKx8NwMAIBsgBCAJaiADQeAAahDSECADKAJgIgQNACAGKAJQRQRAIAZBATYCUCAGKAJMQQA6AAALIBsgJiAHIAUgFCAIENYQIgQNACAAIBMQsA8hBAsgBEHkAEcgBigCBCIFIAFIckUEQCADQQA2AhQMAwsgBEHkAEYNAAsgAyAENgIUIAQNAwsgBigCBCEFCyAFQX9zIQ8gBigCzAQhCEEAIQRBACENA0AgCEEATCAEckUEQCAIQQFrIQhBACEHIAYoAswEIgVBACAFQQBKGyEEQQAhBQNAIAQgBUcEQCAFQQJ0IQcgBUEBaiEFIAcgEygCAGooAgAiBygCACAIRw0BCwsgBygCKARAIAcoAgAhCSAHKAI8IQUgBygCQCEHIANBADYCIEIAIQ4gA0IANwMYIANBADYCaCADQgA3A2AgA0IANwNYIANBADYCVEIAIRAgAEEgIANB1ABqQQAQug8iBEUEQCADKAJUIgRBASAMENICGiAEQQIgCRDRAhoCfyAEEIkBQeQARwRAQQAMAQsgBEEEEMgCIQogBEEEEMkCIRQgBEEBEIoBIRAgCiAUIANBGGogByAFIANB2ABqENcQCyIKIAQQiwEgChshBAsDQAJAIAQNACADKQNYIgtQDQAgA0EANgJQIANBADYCTAJAIAAgCyADQdAAaiADQcwAahDADyIEDQAgAygCUCADKAJMIANB4ABqIAcgBSADQdgAahDXECIEDQAgACALIAMoAmAgAygCZBDIECEECyADKAJQEEAgCyEODAELCwJAIA5QIARyDQAgA0EANgJQIABBESADQdAAakEAELoPIgQNACADKAJQIgVBASAQENICGiAFQQIgDkIBfRDSAhogBRCJARogBRCLASEECwJAIAQNACADQQA2AlAgAEEhIANB0ABqQQAQug8iBA0AIAMoAlAiBUEBIA4Q0gIaIAVBAiADKAIYIAMoAhxBABDNAhogBUEDIAwQ0gIaIAVBBCAJENECGiAFEIkBGiAFEIsBIQQgBUEBEM8CGgsgAygCGBBAIAMoAmAQQCANQQFqIQ0MAgUgACAHEMoQIgQNAiAHKAIAIQcgA0EANgIYIABB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KAIARwRAIAdBADoAACAAIAdBAWo2AgBBASEICyAGQTBqJAAgCAuxBQcBfwF/AX8BfwF/AX4BfiMAQTBrIgMkACADIAAoAgA2AiwgAyABKAIAIgY2AiggAyACKAIANgIkA0ACQAJAAkACQAJAAkACQAJAAkAgBi0AACIFRQRAIAMoAiQiBC0AAEUNBUH/////ByEEDAELQQAhBCAFQQFHDQACfyAGLAABIgRBAEgEQCAGQQFqIANBIGoQvw8aIAMoAiAMAQsgBEH/AXELIgRFDQELQf////8HIQUCQCADKAIkIgctAAAOAgMAAgsCfyAHLAABIgVBAEgEQCAHQQFqIANBHGoQvw8aIAMoAhwMAQsgBUH/AXELIgUNAgtBiwIhBQwGC0EAIQULIAQgBUcNAiADQgA3AxAgA0IANwMIIANCADcDACADIAcgA0EsaiAEELkQIgRqNgIkIAMgBCAGajYCKCADQShqIANBEGoQuhAgA0EkaiADQQhqELoQIAMpAxAiCEICWQRAIAMpAwgiCUIBVQ0CCyADKAIkIQQgAygCKCEGCyADIAMoAiwiB0EBajYCLEEAIQUgB0EAOgAAIAAgAygCLDYCACABIAZBAWo2AgAgAiAEQQFqNgIADAMLA0AgA0EsaiADIAggCSAIIAlTGxC7ECADIAMpAwBCAn03AwACQCAIIAlRBEAgA0EoaiADQRBqELwQIANBJGogA0EIahC8EAwBCyAIIAlTBEAgA0EoaiADQRBqELwQDAELIANBJGogA0EIahC8EAsgAykDECIIQv///////////wBSIAMpAwgiCUL///////////8AUnINAAsMAQsgBCAFSARAIAMgA0EsaiAEELkQIAZqNgIoIANBLGogA0EoahDTDwwBCyADIANBLGogBRC5ECAHajYCJCADQSxqIANBJGoQ0w8LIAMoAighBgwBCwsgA0EwaiQAIAULNwEBfyABRQRAQQAPCyAAKAIAIgJBAWogAawQ0g8hASACQQE6AAAgACACIAFBAWoiAWo2AgAgAQs8AQF/IwBBEGsiAiQAIAAgACgCACACQQhqELIPIAAoAgBqNgIAIAEgASkDACACKQMIfDcDACACQRBqJAALJAAgACAAKAIAIAIgASkDAH0Q0g8gACgCAGo2AgAgASACNwMAC4EBBAF/AX8BfwF/IwBBEGsi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BAsgBiAJQShqrRBJIgQ2AgwgBEUNACAEQgA3AgAgBEELNgIgIARCADcCGCAEQgA3AhAgBEIANwIIIAQgBEEoajYCJCAFRQ0BIAYgBSgCADYCCCAAIAZBCGogAiADEMkQIQMgBigCCCECIAUoAgBFBEAgBSACNgIACyAFIAQ2AgQgBSgCCCEAIAQgAjYCACAEIAA2AgggBCAFKAIcNgIcIAQgBSgCGDYCGCAFQQA2AhwMAgtBByEDDAILIAQgBDYCCCAAIAZBDGogAiADEMkQIQMgBigCDCEECyABIAQ2AgALIAZBEGokACADC2YBAX8jAEEQayICJAACQCABKQMIUARAQQAhAAwBCyAAQREgAkEMakEAELoPIgANACACKAIMIgBBASABKQMIENICGiAAQQIgASkDGBDSAhogABCJARogABCLASEACyACQRBqJAAgAAswAgF/AX8gACgCJEEKIAIQ0Q8iA2siBGogAToAACAAKAIkIANrQQtqIAIQ0g8aIAQLwgECAX8BfyMAQSBrIgkkAAJAIABBCyAJQRxqQQAQug8iCg0AIAkoAhwiAEEBIAEQ0gIaIABBAiACENECGiAAQQMgAxDSAhogAEEEIAQQ0gIaAkAgBlAEQCAAQQUgBRDSAhoMAQsgCSAGNwMIIAkgBTcDAEG+qwEgCRBnIgpFBEBBByEKDAILIABBBSAKQX9BARDVAhoLIABBBiAHIAhBABDNAhogABCJARogABCLASEKIABBBRDPAhoLIAlBIGokACAKC4IDBgF/AX8BfwF/AX8BfiMAQSBrIgMkAAJAIABBJSADQRxqQQAQug8iBg0AIAMoAhwiBEEBIAFCAXwQ0gIaIARBAiABQoAIf0IKhkL/B4QQ0gIaIAJCA35CAn8hCANAAkAgBSEHIAQQiQFB5ABHDQAgA0IANwMQIARBAiADQQhqIANBEGoQzxBBACEHIAMpAxAiAkIAVw0AQQEhBSACIAhXDQELCyAEEIsBIQYgB0UNACADQQA2AhAgA0EANgIIIAYNACAAQSYgA0EQakEAELoPIgYNACAAQScgA0EIakEAELoPIgYNACAEQQEgARDSAhogAygCECEFQQAhBwJAA0AgBBCJAUHkAEcNASAFQQEgBxDRAhogBUECIARBABCNARDRAhogBUEDIARBARCNARDRAhogBRCJARogB0EBaiEHIAUQiwEiBkUNAAsgBBCLARoMAQsgBBCLASIGDQAgAygCCCIEQQEgARDSAhogBBCJARogBBCLASEGCyADQSBqJAAgBgtQAgF/AX8CQCAARQ0AIAAoAggiACgCABDOEANAIABFDQEgACgCBCEBIAAoAiQiAiAAQShqRwRAIAIQQAsgACgCHBBAIAAQQCABIQAMAAsACwvjAQMBfgF/AX4gACABEKcBIgAEQEEAIQEDQCAAIAFqLQAAIgVBMGtB/wFxQQlLRQRAIARCCn4gBa1C/wGDQtD///8PfEL/////D4N8IQQgAUEBaiEBDAELCyACIAQ3AwBCASEGA0AgACABai0AACIFQSBHBEAgBUEtRgRAQn8hBiABQQFqIQELQgAhBANAIAAgAWotAAAiBUEwa0H/AXFBCUtFBEAgBEIKfiAFrUL/AYNC0P///w98Qv////8Pg3whBCABQQFqIQEMAQsLIAMgBCAGfjcDAAUgAUEBaiEBDAELCwsLtQECAX8BfyMAQRBrIgYkACAGQQA2AgggBiADIAQgBRDqDyIHNgIMIAcEQCAAIAAoApACIAcoAgAgBWprQRRrNgKQAgsCQAJAIAZBDGogACkDmAIgAawgAqwgBkEIahDAEEUNACADIAQgBSAGKAIMIgcQ/w4gB0cNACAHEEBBByEEDAELIAYoAggiBA0AIAAgACgCkAIgBSAGKAIMKAIAampBFGo2ApACQQAhBAsgBkEQaiQAIAQLawAgAqwgBHwgBEIDhnwiBCADrHwgBEIDhnwiBCAFrHwgBEIDhnwiBCAGrHwgBEIDhnwhBEEAIQIgAUEAIAFBAEobIQEDQCABIAJGRQRAIAAgAmowAAAgBEIJfnwhBCACQQFqIQIMAQsLIAQLPQEBfwJAIAIoAgANACAAKAIIIAFODQAgACgCACABrBBMIgMEQCAAIAM2AgAgACABNgIIDwsgAkEHNgIACwtUACAAQQhqQQBBKBDnFBogACACNgIEIAAgATYCACABRQRAIABBATYCCEEADwsgACABLQAABH8gAUEBaiAAQRBqELIPQQFqBUEBCyIBNgIIIAAQ1BALhQQJAX8BfwF/AX8BfwF/AX4BfwF/IwBBEGsiBCQAIAAoAhwhAiAEQQA2AgwgBEEANgIIIARBADYCBCACRSAAKQMQIgdQckUEQCAAIAdCAXw3AxALAkAgACgCCCIBIAAoAgQiBk4EQEEAIQEgAEEANgIADAELIAAoAgAhAyACBEAgAAJ/IAEgA2oiCCwAACIFQQBIBEAgCCAEQQxqEL8PDAELIAQgBUH/AXE2AgxBAQsiBSABaiIBNgIICyAAAn8gASADaiIFLAAAIgNBAEgEQCAFIARBCGoQvw8MAQsgBCADQf8BcTYCCEEBCyIDIAFqIgM2AghBiwIhASAEKAIMIgUgAkoNACAEKAIIIgIgBiADa0ogAkVyDQAgACIJQRhqIgMgAiAFaiIGIARBBGoQ0hAgBCgCBCIBDQBBACEBIAkoAhgiA0UNACADIAVqIAAoAgAgACgCCGogAhDlFBogACAGNgIcIAAgACgCCCACaiICNgIIIAApAxBCAFINAAJAIAAoAgAgAmoiAywAACIBQQBIBEAgAyAAQShqEL8PIQEgACgCKCEDIAAoAgghAgwBCyAAIAFB/wFxIgM2AihBASEBCyAAIAEgAmoiAjYCCEGLAiEBIAAoAgQgAmsgA0gNACAAIAIgA2o2AgggACAAKAIAIAJqNgIkQQAhAQsgBEEQaiQAIAELOAEBfwJAAkAgAkUgAEVyDQAgASADIAEgA0gbIgRFDQAgACACIAQQ6hQiAg0BCyABIANrIQILIAILqgIFAX8BfwF/AX8BfyMAQRBrIgckACAHQQA2AgwgASgCBCEJIAEgAyAHQQxqENIQAkAgBygCDCIGDQAgAyABKAIAIgogASgCBCACIAMQxxAiCGsiBkEATARAQYsCIQYMAQsgCiACIAMQ5RQaIAEgAzYCBAJAIAlFBEAgACgCBCEBDAELIAAgACgCACAAKAIEaiAIrBDSDyAAKAIEaiIBNgIECyAAIAAoAgAgAWogBq0Q0g8gACgCBGoiATYCBCAAKAIAIAFqIAIgCGogBhDlFBogACAAKAIEIAZqIgE2AgRBACEGIARFDQAgACAAKAIAIAFqIAWsENIPIAAoAgRqIgE2AgQgACgCACABaiAEIAUQ5RQaIAAgACgCBCAFajYCBAsgB0EQaiQAIAYLtwIFAX8BfwF/AX4BfyMAQdAAayIGJAAgBkEANgIYIAZCADcDECAGQQA2AgwCQCABQQBMBEBBiwIhBwwBCyAALQAAIQggAiABIAZBDGoQ0hAgBigCDCIHDQAgAkEANgIEIAZBIGogACABENMQIQcgCEH/AXFBAEchCgNAAkAgBw0AIAYoAiBFDQAgBigCPCEHIAYoAjghAQJAIAIoAgRFBEAgASAHIAMgBBDVECIIQQBIIAogCEVxcg0BIAIgACwAACAGKQMwIgkQ2BAgBSAJNwMACyACIAZBEGogASAHIAYoAkQgBigCSBDWECIHDQELIAZBIGoQ1BAhBwwBCwsgAigCBEUEQCACIAAsAAAgBikDMCIJENgQIAUgCTcDAAsgBigCOBBAIAYoAhAQQAsgBkHQAGokACAHCywAIAAoAgAgAToAACAAIAJQBH9BAQUgACgCAEEBaiACENIPQQFqCyIBNgIEC6sTIwF/AX8BfwF+AX8BfwF/AX4BfgF/AX8BfwF/AX8BfwF/AX8BfwF/AX8BfgF/AX4BfwF/AX4BfwF+AX4BfgF+AX8BfgF+AX4jAEHQAWsiAyQAAkAgAUEHTgRAIABBsvkCQX8QmwIMAQsgAEHUOiACKAIAIANBDGoQ2hANAEEAQfyvAmohFUGCsAIhGkH4rwIhG0EPIQVBfyEPAkACQAJAAkACQAJAIAFBAmsOBQQDAgEABQsgAigCFBBcpyEFCyACKAIQEFynIQ8LIAIoAgwQXyEVCyACKAIIEF8hGgsgAigCBBBfIRsLIBVFIBpFckEBIBsbBEAgABCVAgwBCyAFRQRAIABB6Z8DQX9BABCnAgwBCyAAIAMoAgwiDBCJEA0AIAwoAgAhHSADQQA2AoABIANCADcDeCAMKAIQRQRAIABB6Z8DQQBBABCnAgwBC0EAQcAAQUAgBSAFQUBMGyIBIAFBwABOGyIWayEiQQEhEANAICIhEiAWQQBOBEAgECAWakEBayAQbSESC0EAIRNCACEcQgAhFwJAA0AgECATRwRAIANBEGogE0EYbGoiDUIANwMAIA1CADcDECANQgA3AwhBACEOQX8hGANAAkACQCAdKAIYIA5KBEAgDiAPRyAPQQBOcQ0CIAwgA0HIAWpBABDbECIEDQYgAyADKALIAUEobK0Q+g8iATYCmAEgAUUEQEEHIQQMBwsgAyASNgKQASADIA42AowBIANBfzYCnAEgAyADKALIATYClAFBASEBIAMgDDYCiAEgDCgCEEGLASADQYgBahDdECIEBEBCACEeQQAhASADKAKYASERQQAhFEIAIR9BACEHDAILQQAhCCADKALIASIBQQAgAUEAShshAiADKAKYASEFQQAhAQNAIAEgAkYEQEF/IQJCACEKQgAhCwVCASABQT9xrYZCACAFIAFBKGxqKAIQGyAchCEcIAFBAWohAQwBCwsDQCACIQcgCyEfIAohHiAIIRQDQAJAAkAgAygCnAFBAE4EQEEAIQIgAygClAEiAUEAIAFBAEobIQlB/////wchBSADKAKYASERA0AgAiAJRg0CIBEgAkEobGoiCCgCEARAIAgpAwgiBqcgBSAGIAWsUxshBQsgAkEBaiECDAALAAtBACECIANBADYCnAEDQCACIAMoApQBIgFODQIgAygCmAEgAkEobGoiAUEQaiABQQhqIAMoApABEN4QIAJBAWohAgwACwALIAVB/////wdGBEAgDiEBDAULIAMgBSADKAKQAWtBAWoiCDYCnAEgBUEBaiEFQQAhAgNAIAEgAkwNASADKAKYASACQShsaiIBQRBqIAFBCGogBRDeECABQSBqIAFBGGogCBDeECACQQFqIQIgAygClAEhAQwACwALIAMoApwBIgisISBBACEJQgAhC0IAIQpBACECA0ACQCABIAlKBEAgAygCmAEgCUEobGoiBSgCICIRRQ0BIAMgETYCzAEgAyAFKQMYIgY3A6ABQgEgCUE/ca2GIiMgCoQhIQNAAkAgBiAgUyAGIAMoApABIgEgCGqsWXJFBEAgCiAXhCAjgyEkQgEgBiAgfYYhJSABrCEZIAU0AgAhCkIAIQYDQCAGIApZIAYgGVlyRQRAICUgBoggC4QhCyAGQgF8IQYMAQsLQegHQQEgJFAbIAJqIQIgAygCzAEtAABBAk8NASAhIQoLIAMoApQBIQEMAwsgA0HMAWogA0GgAWoQ3xAgAykDoAEhBiAhIQoMAAsACyACIAdMDQIMAwsgCUEBaiEJDAALAAsACwALIBNBAWohEyANKQMIIBeEIRcMBAsgERBAIAQNBCAHIBhMDQAgDSAfNwMQIA0gHjcDCCANIBQ2AgQgDSABNgIAIAchGAsgDkEBaiEODAALAAsLIBBBBEcgFyAcUnFFBEAgEEEBayEWQQAhBEEAIQUDQCAFIBBPIARyDQIgDCgCACEOIANBADYCvAEgA0EQaiAFQRhsaiIBKQMQIQsgASgCBCECIAwoAgwgASgCAEEBaiIBEKcBIQggDCgCDCEJAkAgCEUEQEEHQQAgCSABEKgBQQVHGyEEDAELIAkgARDJAiENIA4oAiQiASgCACEJIAEgDCgCFCAIIA0gA0G4AWoQ+w8iBA0AQQAhByADKAK4ASERQQAhDwJAA0BBACEEA0AgBA0CIANBfzYCsAEgA0EANgKsASADQQA2AqgBAkAgESADQbQBaiADQbABaiADQawBaiADQagBaiADQbwBaiAJKAIUEQkAIgQEQCAEQeUARw0EIAggD2ohAQwBCyADKAK8ASIBIAJIDQICQCAHRQRAQgAhBgJAIAtQBEBCACELDAELIAggAygCrAEiAWohByANIAFrIQQgDCgCFCEUQgAhGQNAIBkiCkIBfCEZIAsgCohCAYNQDQALA0AgBqchASAGQgF8IQYgCyASIAFBf3NqrYhCAYNQDQALIAqnIAFrIgFBAm0hGCABQQJIDQAgA0EANgKIASAOKAIkIhMoAgAhASATIBQgByAEIANBoAFqEPsPIgQNAiASIBhqIRRBACEEIAMoAqABIQcCQANAIARFBEAgFCADKAKIAUwEQCAHIAEoAhARAQAaDAMFIANBADYCyAEgA0EANgLEASADQQA2AsABIAcgA0HMAWogA0HIAWogA0HEAWogA0HAAWogA0GIAWogASgCFBEJACEEDAILAAsLIAcgASgCEBEBABogBEHlAEcNAwsgAygCiAEgBEEARyASa2oiAUEAIAFBAEobIgEgAmohAiALIAGtiCELCwJAAn8gBUUgAkEATHFFBEAgA0H4AGogFUF/EOAQDAELIAMoAqwBIgFFDQEgA0H4AGogCCABEOAQCyEEQQEhByAEDQQLQQEhByADKAK8ASIBIAJIDQQLIAIgEmogAUwEQEEAIQQgFSEBIAUgFkYNAgwFC0EAIQQgASACSgRAIANB+ABqIAggD2ogAygCrAEgD2sQ4BAhBAsgBEIBIAEgAmuthiIGIAuDIgZQckUEQCADQfgAaiAbQX8Q4BAhBAsCQCAEDQAgA0H4AGogCCADKAKsASIBaiADKAKoASABaxDgECIEIAZQcg0AIANB+ABqIBpBfxDgECEEC0EBIQcgAygCqAEhDwwCC0EBIQcMAQsLCyADQfgAaiABQX8Q4BAhBAsgESAJKAIQEQEAGgsgBUEBaiEFDAALAAsgEEEBaiEQDAELCyAdEKoPIAQEQCAAIAQQsAIgAygCeBBADAELIAAgAygCeEF/QQEQpwILIANB0AFqJAALUAEBfyMAQRBrIgQkACADIAJBkPEAEIgCIgI2AgBBACEDIAJFBEAgBCABNgIAIABBu9gAIAQQZyIDQX8QmwIgAxBAQQEhAwsgBEEQaiQAIAMLUQEBfyMAQRBrIgMkACADQgA3AgQgAyAANgIAIAAoAhBBjAEgAxDdECEAIAEEQCABIAMoAgQ2AgALIAIEQCACIAMoAgg2AgALIANBEGokACAAC64BBAF/AX4BfwF/IwBBEGsiAyQAIAIoAhAiBSABQShsaiIGIAAoAhQoAkA2AgAgAigCACAAIAIoAgQgA0EMahDtECECAkAgAygCDCIARQ0AIANCADcDACAGIAA2AgQgA0EMaiADEN8QIAMpAwAiBEIAUwRAQYsCIQIMAQsgBSABQShsaiIAIAMoAgwiATYCICAAIAE2AhAgACAENwMYIAAgBDcDCAsgA0EQaiQAIAILLQEBfyMAQRBrIgMkACADQQA2AgwgACADQQxqIAEgAhDwECECIANBEGokACACC4oBBAF/AX8BfgF+IwBBEGsiAyQAIAMgACgCACIENgIMAkAgBEUNACADIAEpAwAiBTcDACACrCEGA0AgAygCDCEEAkAgBSAGUwRAIAQtAABBAk8NAUJ/IQVBACEECyABIAU3AwAgACAENgIADAILIANBDGogAxDfECADKQMAIQUMAAsACyADQRBqJAALawQBfwF/AX8BfyMAQRBrIgMkAAJAIAAoAgAiBCwAACICQQBIBEAgBCADQQxqEL8PIQIgAygCDCEFDAELIAJB/wFxIQVBASECCyAAIAIgBGo2AgAgASABKQMAIAVBAmusfDcDACADQRBqJAALmAEDAX8BfwF+IAJBAEgEQCABEO8VIQILAkAgACgCCCIDIAIgACgCBCIEakEBakoEQCAAKAIAIQMMAQsgACgCACACrCADrHxC5AB8IgUQTCIDRQRAQQcPCyAAIAU+AgggACADNgIAIAAoAgQhBAsgAyAEaiABIAIQ5RQaIAAgACgCBCACaiICNgIEIAAoAgAgAmpBADoAAEEAC4kHDgF/AX8BfwF/AX8BfwF/AX8BfgF/AX8BfwF/AX8jAEGwAWsiAyQAAkAgAEGPwQAgAigCACADQRxqENoQDQAgACADKAIcIgQQiRANACAEKAIAIggoAiQoAgAhCiADQQA2AqgBIANCADcDoAEgBCgCEEUEQCAAQemfA0EAQQAQpwIMAQsgA0IANwOYASADQgA3A5ABIANCADcDiAEgA0IANwOAAQJAIARBACADQawBahDbECICDQAgAyADKAKsAUEYbK0Q+g8iAjYCmAECQCACRQ0AIAQpAyAhCyADIAQ2AoABIAMgCzcDkAEDQCAIKAIYIAdMBEBBACECDAMLIANBADYCdCADQQA2AnAgA0EANgJsIANBADYCiAEgAyAHNgKEASADQQA2AmggBCgCEEGNASADQYABahDdECICDQIgBCgCDCAHQQFqIgwQpwEhAiAEKAIMIAwQyQIhBgJAIAJFBEAgBCgCDCAMEKgBQQVHDQMMAQsgCCgCJCAEKAIUIAIgBiADQfwAahD7DyICDQMgAygCfCINIANB+ABqIANB9ABqIANB8ABqIANB7ABqIANB6ABqIAooAhQRCQAhAgNAIAMoAqwBIgZBACAGQQBKGyEOIAMoApgBIQ8CQANAIAINAUEAIQJB/////wchCUEAIQUDQCACIA5GRQRAIA8gAkEYbGoiBigCAARAIAYpAwggBikDEH0iC6cgCSALIAmsUyIQGyEJIAYgBSAQGyEFCyACQQFqIQIMAQsLQeUAIQIgBUUNAAsCQCAFKAIALQAAQQFNBEAgBUEANgIADAELIAUgBUEIahDfEAtBACECIAMoAnwhDQNAAkAgAg0AIAMoAmggCU4NACANIANB+ABqIANB9ABqIANB8ABqIANB7ABqIANB6ABqIAooAhQRCQAhAgwBCwsgAkUEQCADIAc2AgAgAyADKAJwIgI2AgggAyADKAJsIAJrNgIMIAMgBSADKAKYAWtBGG02AgQgA0GgAWpBwAAgA0EgakGUmgMgAxBpQX8Q4BAhAgwCCyACQeUARw0BQeUAQYsCIAgoAigbIQIMAQsLIA0gCigCEBEBABogAkHlAEcNAwsgDCEHDAALAAtBByECCyADKAKYARBAIAgQqg8gAgRAIAAgAhCwAiADKAKgARBADAELIAAgAygCoAEgAygCpAFBAWtBARCnAgsgA0GwAWokAAvCAQcBfwF+AX8BfgF/AX8BfiMAQRBrIgMkACADQgA3AwAgAigCACAAIAIoAgQgA0EMahDtECEIIAAoAhQoAkAhBSADKAIMBEAgA0EM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QSxqIQggASgCGCEEAkADQAJAIAEoAgAiBUUNACAEIAEoAgwoAghIDQAgACABEJYSIAAoAiwNAiABKAIMRQ0CIAZCADcDAEEEIQQMAQsLAkACQCABKAI0IARKBEAgASABKAIMKAIAIARqIANBGGoQ7REgBGqsNwMYIAEgASkDWCADKQMYfDcDWAwBCyABLQAEQQFxDQECQCAFBEBBACEFIANBADYCGCABKAIMENkSIARHBEAgASgCDCgCACAEaiADQRhqEOwRIARqIQQgAygCGCEFCyABIASsNwMYIAAgASAFELcSDAELIANBADYCGCADQQA2AhQgA0EANgIQIAAoAgwiBCAEKAIQKAIENgIQIAQgA0EUaiADQRBqIANBGGogA0EMahDEEiADKAIYIgRFDQIgASgCDCIFIAQ2AgAgBSADKAIMIgc2AgggBSAHNgIEIAEgBzYCNCAIIAFByABqIAMoAhAgAygCFBCtEiABIAQgBhDtEa03AxgLIAJFDQAgAkEBNgIACyAAIAEQlxIMAQsgASgCDBBAIAFBADYCDAsgA0EgaiQAC8EGCQF/AX8BfwF/AX4BfwF/AX8BfyMAQSBrIgQkACABKAIMIQUgBEEANgIcAkACQAJAIAEoAmAgASgCGGoiAyAFKAIISARAIAUoAgAhBgJAIAEoAjQgA0wEQEEBIQggBRDZEiADRg0BIAMgBmogBEEcahDsESADaiEDDAELIAMgBmogBEEQahDtESEFIAEgASkDWCAEKQMQfDcDWCADIAVqIQMLIAEgA6w3AxgMAQsCQCABKAIARQRAIARBADYCECAEQQA2AgwgBEEANgIIIARBADYCBCABLQAEQQFxRQRAIAAoAgwiAyADKAIQKAIENgIQIAMgBEEMaiAEQQhqIARBEGogBEEEahDEEiAEKAIQIgMNAgsgASgCDBBAIAFBADYCDAwECyABQTRqIQogAUHYAGohC0EAIQMDQCADDQIgACABEJYSIAEoAgwiBUUNBCAEIAUoAgAiCS8AACIDQQh0IANBCHZyQf//A3EiAzYCEAJAIANFIAUoAggiBiADTHJFBEAgBCADIAlqIAsQ7REgA2oiAzYCECABIAOtNwMYIAUoAggiBiAFKAIETg0BIAEgBSgCACAGaiAKEOwRIAZqNgIwIAUoAgghBgwBCyAFKAIEIAZMDQAgASAGIAlqIARBEGoQ7BEgBmo2AjAgASAEKAIQIgM2AjQgASADrDcDGEEBIQgLIAMgBkwNAAsgAEGLAjYCLAwDCyABKAIMIgUgAzYCACAFIAQoAgQiBjYCCCAFIAY2AgQgASAGQQFqNgI0IABBLGogAUHIAGogBCgCCCAEKAIMEK0SIAEgAyABQdgAahDtEa0iBzcDGCACQQE2AgAgASgCDCIDRQ0CDAELIAEoAgwiA0UNASAIRQRAIAEpAxghBwwBCyABLQAEQQFxBEAgAxBAIAFBADYCDAwCCyAAIAEgBCgCHBC3EiAAIAEQlxIgAkUNASACQQE2AgAMAQsgAygCACEDIAEgB0IBfDcDGCAEIAMgB6dqIgYsAAAiBUH/AXEiAzYCDCAFQQBIBEAgASAHNwMYIAEgByAGIARBDGoQ7BGtfDcDGCAEKAIMIQMLIAEgA0EBdTYCYCABIANBAXE6AGQLIARBIGokAAvjAwQBfgF/AX8BfiADrCACrUIlhnxCgICAgIACfCEHQQAhAwNAIAAoAiwiBiADckUEQCAFIARCBYZCKHxC6P///w+DEEwiBgRAIAYgBKdBBXRqIgNCADcDICADQgA3AxggA0IANwMQIANBCGoiBUIANwMAIAMgACAHIARCH4Z8EOsRIgM2AgggAwR/IAMoAgAtAABBAXFFBUEACyEDIAYgBEIBfCIEPgIAIAYhBQwCBSAAQQc2AiwgBEIBfCEEQQAhAwwCCwALCwJAIAZFBEAgBSACNgIEAkACQCABRQRAQQAhAwNAIAMgBSgCAE4NAiAFIANBBXRqQQhqEKYSGiADQQFqIQMMAAsACyAFNQIAIQRBACEDA0AgAw0CIASnIgZBAEwNAiAFIAZBAWtBBXRqIgJBCGohAwNAIAMQphJFDQALIAJBADYCECAGQQJOBEAgA0EgayIDKAIAEEAgA0IANwMYIANCADcDECADQgA3AwggA0IANwMAIAMgACACNAIYIARCH4ZCgICAgPD/////AHxCgICAgPj/////AIMgBTUCBEIlhnx8QoCAgICAAnwQ6xE2AgALIARCAX0hBCAAKAIsIQMMAAsACyAAKAIsIQMLIANFDQELIAUQ9BFBACEFCyAFC1wDAX8BfwF/IwBBEGsiAyQAQX8hBCABKAIAIgUgACgCBEgEQCAAKAIAIAVqIANBCGoQ7REhACACIAIpAwAgAykDCHw3AwAgACAFaiEECyABIAQ2AgAgA0EQaiQAC0gBAX8gAUIANwMAIAFCADcDGCABQgA3AxAgAUIANwMIIAAoAgQiAkEASgRAIAEgACgCACIANgIQIAEgACACajYCACABEOsSCwtAAQF/IAEoAhAEQANAAkAgACgCACICRQ0AIAEpAwggAikDCFcNACACQTBqIQAMAQsLIAEgAjYCMCAAIAE2AgALC0QCAX8BfiABKQMgIgNCAFkEQANAAkAgACgCACICRQ0AIAMgAikDIFcNACACQTBqIQAMAQsLIAEgAjYCMCAAIAE2AgALC7wBBQF/AX8BfwF/AX8jAEEQayIDJAACQCAAKAIUIAAoAhAgACgCGGpqIgEgACgCACIFTwRAIABBADYCEAwBCyABIANBCGoQ7REhAiAAIAApAwggAykDCHw3AwgCfyABIAJqIgEsAAAiAkEASARAIAEgA0EEahDsESEEIAMoAgRBAXUMAQtBASEEIAJB/gFxQQF2CyECIAAgBDYCGCAAIAI2AhQgACABQQAgASACaiAFTRs2AhALIANBEGokAAvPAQQBfwF/AX8BfyMAQRBrIgQkAAJAIAMoAgQiBSABKAJgIgZqQQhqIgcgAygCCEsEQCAAQSxqIAMgBxDjEQ0BIAEoAmAhBiADKAIEIQULIAMoAgAgBSAGampCADcAACACRQRAIAAgASADQa0BEOESDAELIAAoAgAoAjhFBEAgBCACNgIEIAQgAzYCACAEIAJBABDuEjYCCCAAIAEgBEGuARDhEgwBCyAEIAI2AgQgBCADNgIAIARCADcDCCAAIAEgBEGvARDhEgsgBEEQaiQACyoAIANBAEoEQCABKAIAIAEoAgRqIAIgAxDlFBogASABKAIEIANqNgIECwtEAwF/AX8BfyAAKAIAIgNBACADQQBKGyEEA0AgAiAERgRAQQAPCyACQQJ0IQMgAkEBaiECIAAgA2ooAgQgAUcNAAtBAQvrAwYBfwF/AX8BfwF/AX8jAEEQayIHJAAgA0EASgRAAkAgASgCCEECRw0AIAcgAiwAACIGQf8BcSIENgIMQQEhBSAGQQBIBEAgAiAHQQxqEOwRIQUgBygCDCEECyABKAIEIAQQ7hIEQCABQQE2AgggASgCACIEKAIAIAQoAgRqQQE6AAAgASgCACIEIAQoAgRBAWo2AgQMAQsgAUEANgIICwNAIAUhBgNAAkAgAyAGTCIFDQAgAiAGai0AAEEBRg0AIAYhBQNAIAIgBWohBCAFQQFqIgYhBSAELAAAQQBIDQALDAELCyABKAIIBEAgASgCACIEKAIAIAQoAgRqIAIgCGogBiAIayIEEOUUGiABKAIAIgkgCSgCBCAEajYCBAsCQCAFBEAgBiEFDAELAkACQCADIAZBAWoiBUwEQCABQQI2AggMAQsgByACIAVqIgksAAAiCEH/AXEiBDYCCAJAIAhBAE4EQCAGQQJqIQUMAQsgCSAHQQhqEOwRIAVqIQUgBygCCCEECyABIAEoAgQgBBDuEiIENgIIIAQNAQsgBiEIDAELIAEoAgAiBCgCACAEKAIEaiACIAZqIAUgBmsiBBDlFBogASgCACIGIAYoAgQgBGo2AgQgBSEICyADIAVKDQALCyAHQRBqJAALpgEGAX8BfwF/AX8BfwF/IwBBEGsiBSQAAkAgA0EATA0AA0AgAyAETA0BIAIgBGogBUEMahDsESEJIAEgBSgCDCABKAIIaiIGQQJrIgg2AgggASgCBCAIEO4SBEAgASgCACIHKAIAIAcoAgRqIAYgASgCDGusEOcRIQYgASgCACIHIAYgBygCBGo2AgQgASAINgIMCyAEIAlqIQQMAAsACyAFQRBqJAALCgAgACgCYCgCCAsNACAAKAIAKAIMKAIMCzUBAX8gACgCACgCFCICQQAQqhEiAEUEQCABIAIpAxA3AwBBiwJBACACKQMQQgBXGyEACyAAC5sBAwF/AX8BfgJAIAAoAgAoAhQiBEEAEKoRIgMNACACQgA3AwAgBCgCACgCDCEAIAFBAEgEQEEAIQMgAEEAIABBAEobIQFBACEAA0AgACABRg0CIAIgBCgCGCAAQQN0aikDACAFfCIFNwMAIABBAWohAAwACwALQRkhAyAAIAFMDQAgAiAEKAIYIAFBA3RqKQMANwMAQQAhAwsgAwstACABRQRAQQAPCyAAKAIAKAIMIgAoAkAgA0EIIAEgAiAEIAAoAkQoAggRCQALFQAgACgCNCIARQRAQQAPCyAAKAIQCzIBAX8CQCABQQBIDQAgACgCNCIAKAIQIAFMDQAgACgCFCABQQJ0aigCACgCECECCyACCysBAX8CQCAALQA8QQhxBEAgABD5EiICDQELIAEgACgCcDYCAEEAIQILIAILggQKAX8BfwF/AX8BfwF/AX8BfgF/AX8jAEEQayIDJAAgA0EANgIMIAAoAgAoAgwhAiAAKAI0IgUEQCAFKAIQIQQLIAIoAgwhCQJAAkAgACgCaCIFDQAgACADQQxqIARBGGytEKERIgU2AmggBQ0AIAMoAgwhAQwBC0EAIQIgAygCDCEBA0AgAiAETiABckUEQCAAIAIgA0EIaiADQQRqEIQTIgFFBEAgAygCCCADKAIEIAUgAkEYbGoQnhILIAJBAWohAgwBCwsCQCABDQAgBEEAIARBAEobIQQDQEF/IQZBACECA0AgAiAERkUEQAJAIAUgAkEYbGoiAS0ADQ0AIAZBAE4EQCABKQMQIAUgBkEYbGopAxBZDQELIAIhBgsgAkEBaiECDAELC0EAIQEgBkEASA0BAkAgB0EBaiICIAAoAmwiAUgEQCAAKAJ0IQEMAQsgACgCdCABQQF0QSAgARsiCkEMbK0QTCIBRQRAQQchAQwDCyAAIAo2AmwgACABNgJ0CyACQQxsIAFqQQxrIgEgBjYCACABIAUgBkEYbGoiBykDECIIp0H/////B3E2AgggASAIQiCIpyIGNgIEQYsCIQEgBiAJTiAIQgBTckUEQCAHEKASGiACIQcMAQsLIAIhBwsgACAHNgJwIAAgACgCPEF3cTYCPAsgA0EQaiQAIAELXwEBfwJAIAAtADxBCHEEQCAAEPkSIgUNAQtBGSEFIAFBAEgNACAAKAJwIAFMDQAgAiAAKAJ0IAFBDGxqIgAoAgA2AgAgAyAAKAIENgIAIAQgACgCCDYCAEEAIQULIAULKAEBfwJ/IAAoAjgiAQRAIAFBCGoMAQsgACgCNCgCCEEYagsiACkDAAuCAQIBfwF/QRkhBAJAIAFBAEgNACAAKAIAKAIMIgUoAgwgAUwNACADAn8CQCAFKAIgQQFHBEAgACgCGEEDRw0BCyACQQA2AgBBAAwBCyAAQQAQnxEiBA0BIAIgACgCMCABQQFqIgEQpwE2AgAgACgCMCABEMkCCyIBNgIAQQAhBAsgBAvLAwUBfwF/AX8BfwF/IwBBEGsiBiQAIAAoAgAiAygCDCEFIAAtADxBBHEEQAJAIAUoAjAEQCADKAIUAn8gACgCOCIEBEAgBEEIagwBCyAAKAI0KAIIQRhqCyIEKQMAIAAoAggQ/hIhBAwBCwJAIAUoAihFBEBBACEDA0AgAyAFKAIMTg0CIAUoAhQgA2otAABFBEAgACgCCCADQQJ0akF/NgIACyADQQFqIQMMAAsAC0EAIQMDQCAEDQIgAyAFKAIMTg0BQQAhBAJAIAUoAhQgA2otAAANACAAKAIIIANBAnRqIgdBADYCACAAIAMgBkEMaiAGQQhqEPwSIgQNACAGKAIMIgRFBEBBACEEDAELIAUoAkAgB0EIIAQgBigCCEGwASAFKAJEKAIIEQkAIQQLIANBAWohAwwACwALQQAhBAsgACAAKAI8QXtxNgI8CwJAIAFBAEgEQEEAIQEgAkEANgIAQQAhAwNAIAMgBSgCDE4NAiACIAEgACgCCCADQQJ0aigCAGoiATYCACADQQFqIQMMAAsACyACAn8gASAFKAIMTgRAQRkhBEEADAELIAAoAgggAUECdGooAgALIgM2AgALIAZBEGokACAEC98BBgF/AX8BfwF/AX8BfyMAQRBrIgUkACAAKAIAKAIMIQMgBUEANgIMIABBCCAFQQxqQQAQqxEhACAFKAIMIgQEQCAEQQEgARDSAhoCf0EBIgYgBBCJAUHkAEcNABpBACEAIANBACADQQBKGyEGIARBABDIAiEIIARBABDJAiEHQQAhAwNAIAAgBkcEQEEBIAMgB04NAhogAyAIaiACIABBAnRqEOwRIANqIQMgAEEBaiEADAELCyADIAdHCyEGIAQQiwEiAEGLAiAAGyAAIAZBAXEbIQALIAVBEGokACAACxoAIAFBAXFFBEAgACAAKAIAQQFqNgIAC0EAC8wGCwF/AX8BfwF/AX8BfwF/AX8BfwF/AX8jAEEgayIFJAAgACgCACELIAVBADYCDCALIAVBDGoQiBEhBCAFKAIMIQgCQCAEDQAgCEL///////////8ANwMoIAhCgICAgICAgICAfzcDICAIQQE2AhggCCALNgIAIAAoAjQhCiAFQQA2AhwgBUEANgIYIAVCADcDEEEZIQQCQAJAAkAgAUEASA0AIAooAhAgAUwNACAKKAIUIAFBAnRqKAIAIQkgBUEcakIYEKERIQYgBSgCHCIEDQEgBiAFQRxqQgQQoRE2AhQgBSgCHCIEDQEgBiAFQRxqQjAQoRE2AgggBSgCHCIEDQEgBUEcakIUEKERIQQgBigCCCAENgIgAkAgBSgCHCIEIAlFckUEQCAJKAIAKAIgKAIEIgRFDQEgBUEcaiAEKAIAQQJ0QQRqIgGtEKERIgAEQCAAIAQgARDlFBoLIAYoAggoAiAgADYCBCAFKAIcIQQLIAQNAgsCQAJAIAkoAhAEQCAFIAooAgQ2AhRBACEEA0AgBA0CIAcgCSgCEE4NAkEAIQRBACEBIAkgB0EYbCIMaiINIg5BFGohAANAIABFIARyRQRAIAVBEGogASAAKAIEIAAoAgwgBCAEEIISIQQgACgCFCEAQQEhAQwBCwsgBEUEQCAFKAIQIAxqIgAgDi0AFDoAFCAAIA0tABU6ABULIAdBAWohBwwACwALIAVBHGpCLBChESEHIAUoAhwhBAwBCyAFKAIQIQcLIAQgB0VyDQEgBiAKKAIANgIAIAooAgQhBCAGQQE2AhAgBiAENgIEIAYoAhQgBzYCACAGKAIIKAIgIAc2AgwgBigCCCIEKAIgQQE2AgggByAENgIAIAQCfwJAIAkoAhBBAUcNACAJKAIoDQBBASEAIAktABUNAEEEIQFBnAEMAQtBCSEBQZsBCyIANgIQIAQgATYCACAIIAY2AjQMAgsLIAYQlxEgBxDwESAIQQA2AjQgBA0BCyALIAhBABCRESEEA38gBA0BIAgtADxBAXEEQEEAIQQMAgtBrNIGIAggAiADEQIAIgQEfyAEQQAgBEHlAEcbBSAIEJYRIQQMAQsLIQQLIAgQihEaIAVBIGokACAEC7oBAgF/AX8jAEEQayIEJAAgAEHkAGohAwJ/AkACQANAIAMoAgAiA0UNASADKAIAIAAoAmBHBEAgA0EMaiEDDAELCyADKAIIIgBFDQEgAygCBCAAEQMADAELIARBADYCDCAEQQxqQhAQoREiA0UEQCACBEAgASACEQMACyAEKAIMDAILIAMgACgCYDYCACADIAAoAmQ2AgwgACADNgJkCyADIAE2AgQgAyACNgIIQQALIQMgBEEQaiQAIAMLSQEBfyAAQeQAaiECA0AgAigCACICRQRAQQAPCyACKAIAIAAoAmBHBEAgAkEMaiECDAELCyACKAIEIQAgAQRAIAJCADcCBAsgAAtaAQF/IwBBEGsiBSQAIAAgASACIAVBDGoQhBMiAUUEQCACIAIoAgAiACAFKAIMakEAIAAbNgIEIANBADYCACAEQQA2AgAgBSACIAMgBBCFEwsgBUEQaiQAIAELkgYOAX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX8BfyMAQSBrIgckAEEZIQQCQAJAIAFBAEgNACAAKAI0IggEQCAIKAIQIQULIAEgBU4NACAAKAI4IQYgACgCACgCDCELIAAtADxBwABxBEACQCALKAI4RQRAQQAhBAwBCwJAIAgoAhBBBHStEEkiDEUEQEEHIQQMAQtBACEEIAxBACAIKAIQQQR0EOcUIQ0gCCgCECIFQQAgBUEAShshDkEAIQUDQCAFIA5GDQEgCCgCFCAFQQJ0aigCACEJAkACQCAGDQACQCAJKAIIRQ0AIAkoAgAiDykDGCAIKAIIKQMYUg0AIA8oAgRFDQELIA0gBUEEdGpBATYCDAwBCyAJQQA2AggLIAVBAWohBQwACwALA0AgCiALNAIMWSAEckUEQAJAIAAgCqcgB0EIaiAHQQxqEPwSIgQNACAAKAI0IQ0gBygCDCERIAcoAgghECAHIApCIIZCAX03AxggByAMNgIUIAcgDTYCEEEAIQYgDSgCECIEQQAgBEEAShshDwNAIAYgD0ZFBEACQCANKAIUIAZBAnRqKAIAKAIAKAIgKAIEIgkEQEEAIQ4gCSgCACIEQQAgBEEAShshCEEAIQQDQCAEIAhGDQIgBEECdCEFIARBAWohBCAKIAUgCWo1AgRSDQALCyAMIAZBBHRqKAIMRSEOCyAMIAZBBHRqIA42AgggBkEBaiEGDAELCyAQRQRAQQAhBAwBCyALKAJAIAdBEGpBBCAQIBFBsQEgCygCRCgCCBEJACEECyAKQgF8IQoMAQsLIAwQQCAAKAI4IgVFDQAgACgCNCgCCCAFKQMIEIsTGgsgACAAKAI8Qb9/cTYCPCAEDQEgACgCOCEGCwJAIAZFDQAgCygCOA0AQQAhBEEAIQUgAQRAIAFBAnQgBmooAhQhBQsgAyAGIAFBAnRqKAIYIAVrNgIAIAIgBigCECAFajYCAAwCCyADIAAoAjQgASACEJwRNgIAQQAhBAwBCyACQQA2AgAgA0EANgIACyAHQSBqJAAgBAuzAQMBfwF/AX8jAEEQayIFJAACQCABKAIAIgQgASgCBE8EQCACQX82AgAgA0F/NgIADAELIAEgBCAFQQxqEOwRIARqIgY2AgAgAwJ/IAUoAgwiBEEBRwRAIAMoAgAMAQsgASAGIAVBDGoQ7BEgBmoiBDYCACACIAUoAgw2AgAgA0EANgIAIAEgBCAFQQxqEOwRIARqNgIAIAUoAgwhBEEACyICIARqQQJrNgIACyAFQRBqJAALowIDAX8BfwF/IwBBEGsiBSQAAkAgACgCACgCDCgCOEECRgRAAn8gACgCOCIEBEAgAQR/IAFBAnQgBGooAhQFQQALIQYgBCABQQJ0aigCGCEBIAIgBCgCECAGaiIENgIAIAEgBmsMAQsgACgCNCABIAIgBUEMahCjESIBDQIgAigCACEEIAUoAgwLIQZBACEBIAIgBCAGakEAIAQbNgIEIANBADYCACAAIAIgAxCHEwwBCyAAIAEgAiAFQQhqEIQTIgENACACIAIoAgAiACAFKAIIIgRqQQAgABs2AgQgBEEATARAIANBfzYCAAwBCyAALQAAQQFGBEAgAiAAQQFqIAMQ7BEgAigCAGpBAWo2AgAMAQsgA0EANgIACyAFQRBqJAAgAQvFAQIBfwF/IwBBEGsiAyQAAkAgACgCACgCDCgCOEECRwRAIAEoAgAhACABKAIEIQQDQCAAIARPBEAgAkF/NgIADAMLIAAtAABBAUcEQCABIAAgA0EIahDsESAAaiIANgIADAELCyABIABBAWogAhDsESABKAIAakEBajYCAAwBCyABKAIAIgAgASgCBE8EQCACQX82AgAMAQsgASAAIANBDGoQ7BEgAGo2AgAgAiADKAIMIAIoAgBqQQJrNgIACyADQRBqJAALYQEBf0EZIQUCQCABQQBIDQAgAkEASCAAKAI0IgAoAhAgAUxyDQAgACgCFCABQQJ0aigCACIBKAIQIAJMDQAgAyABIAJBGGxqIgEoAhg2AgAgBCABKAIgNgIAQQAhBQsgBQu0AwcBfwF/AX4BfwF+AX4BfwJAIAAtADxBCHEEQCAAEPkSIggNAQtBGSEIIAFBAEgNACAAKAJwIAFMDQAgACgCdCABQQxsaiIFKAIAIQECfyAAKAI4IgYEQCAAKAI0IQAgBkEIagwBCyAAKAI0IgAoAghBGGoLIQYgAUEASA0AIAJBAEggACgCECABTHINACAAKAIUIAFBAnRqKAIAIgEoAhAgAkwNAEEAIQggASACQRhsai0AFA0AIAQCfyAAKAIEKAI0BEAgBikDACEJIAUoAgggAmqsIAU1AgRCIIZ8IQogASACQRhsaigCJCgCGCILKAIIIQEgCygCECEFQQAhAANAIAAgAU4EQEEADwsCQAJAIAkgBSAAIAFqQQJtIgJBGGxqIgYpAwAiB1cEQCAHIAlVBEAgAiEBDAQLIAYpAwgiByAKWQ0BIAdCAFMNAgsgAkEBaiEADAILIAIhASAHIApVDQELCyADIAsgBSACQRhsaigCEEECdGooAhwiACgCmAFBAWo2AgAgACgCnAFBAWsMAQsgAyABIAJBGGxqIgAoAhg2AgAgACgCIAsiADYCAAsgCAvaAwkBfwF/AX8BfwF/AX8BfwF+AX5BgIACIAMgA0GAgAJOGyEHIAAoAgAiCigCCCEIAkAgCigCBCgCNEUNACAHQQAgB0EAShshBwN/IAYgB0YNASACIAZqLQAABH8gBkEBaiEGDAEFIAYLCyEHCyAIKQMYIQ0gAUEBcUUEQCAAIAApAwhCAXw3AwgLQQAhCANAAkAgCigCECAITARAQQAhAQwBCwJAIAAoAgQgCEEEdGoiCSgCCEUNACAKKAIUIAhBAnRqKAIAIgtBFGohBgNAIAZFDQECQCAHIAYoAggiAUcEQCABIAdODQEgBi0AAEUNAQsgBigCBCACIAEQ6hQNACALQQRqIAkgACkDCBCsEiIBDQMgCigCBCgCNEUNAiAGLQAADQJBACEBIAYoAhAiBigCGCILKAIAIglBACAJQQBKGyEJIAApAwghDiAGKAIcIQwCQANAIAEgCUYNAQJAIAMgCyABQQJ0aigCHCIGKAKcAUEBa0YEQCACIAYoApgBQQFqIAMQ6hRFDQELIAFBAWohAQwBCwsgDCALIAEgDSAOQv////93gxCdEgsgDCgCLCEBIAxBADYCLCABDQMMAgsgBigCFCEGDAALAAsgCEEBaiEIDAELCyABC9ABAwF/AX8BfyAAQQA2AgQgACABNwMYAkACQAJAAkACQAJAIAAoAgBBAWsOCQIBAwADAwMDAAMLIAAoAiAoAgwoAghBAEoPC0EBIQMDQCACIAAoAiRODQMgAkECdCEEIAJBAWohAiAAIARqKAIoIAEQixMNAAsMAwsDQCACIAAoAiRODQJBASADIAAgAkECdGooAiggARCLExshAyACQQFqIQIMAAsACyAAKAIoIAEQixNFDQEgACgCLCABEIsTDQFBASEDCyADDwsgABCME0EAC1EBAX8CQCAAKAIAIgFBBEYgAUEJRnJFBEBBACEBA0AgASAAKAIkTg0CIAAgAUECdGooAigQjBMgAUEBaiEBDAALAAsgACgCICgCDEEANgIICwu/AwYBfwF/AX8BfwF/AX4gAyACrIBBASAAKAIEIgJBCGtBAkEDIAAoAgAiBi0AACIIQQRGIgQbdiACQRBMGyICrYIhCSAGQQRqEKISIQcCf0ECIgUgA0KAgICAEFpBACAEGw0AGgJAIANQBEAgBkEBOgABDAELIAFFBEBBASIFIAcgAkEBdk4NAhoLIAmnIQUgBiAHQQFqIgRBGHQgBEGA/gNxQQh0ciAEQQh2QYD+A3EgBEEYdnJyNgAEIAAoAgBBCGohBiAIQQRGBEAgAiEEA0ACQCAEIQAgBiAFQQJ0aiIEKAIARQ0AIABBAWshBCAFQQFqIAJwIQUgAA0BDAMLCyAEIAOnIgVBGHQgBUGA/gNxQQh0ciAFQQh2QYD+A3EgBUEYdnJyNgAADAELIAIhBANAAkAgBCEAIAYgBUEDdGoiBCkDAFANACAAQQFrIQQgBUEBaiACcCEFIAANAQwCCwsgBCADQjiGIANCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISENwAAC0EACyIFCzsBAX8gAARAIAFBACABQQBKGyEBA0AgASACRkUEQCAAIAJBAnRqKAIAEEAgAkEBaiECDAELCyAAEEALCzQBAX8jAEEQayIBJAAgAUEANgIMIAAgAUEMakKAEBChETYCACABKAIMIQAgAUEQaiQAIAAL2AIIAX8BfwF/AX8BfwF/AX8BfyMAQRBrIggkACADQYCAAkghC0EBIQcgACgCDCEGAkACQCABQQFxRQRAIAZBAWohBwwBCyAGDQELIAAgBzYCDCAHIQYLIANBgIACIAsbIQwgACgCGCENAkACQAJAIAAoAhwoAjgOAwACAQILIAZBAWshCSAAKAIIIQoMAQsgACgCCCEJCyANQQAgAiAMIAhBDGoQlxMiAyAIKAIMckUEQCAAIAApAxAgACkDACAKIAlBACACIAwQkxOFNwMQC0EAIQYDQAJAIAMNACAGIAAoAhwiASgCGE4NACAGQQJ0IQtBACEDIAZBAWoiByEGIAIgDCALIAEoAhxqKAIAEJUTIgFFDQEgDSAHIAIgASAIQQxqEJcTIQMgCCgCDA0BIAAgACkDECAAKQMAIAogCSAHIAIgARCTE4U3AxAMAQsLIAhBEGokACADC00DAX8BfwF/IAAEQANAIAFBgARGRQRAIAAgAUECdGooAgAhAgNAIAIEQCACKAIMIQMgAhBAIAMhAgwBCwsgAUEBaiEBDAELCyAAEEALC5UBAwF/AX8BfiMAQRBrIgMkACAAKAIAIgQpAgQhBSADIAE2AgggAyAFNwMAAkBB8oQDIAMQZyIARQRAQQchAQwBCyADQQA2AgwgBCgCACAAQX8gA0EMakEAEIgBIgENACADKAIMEIkBQeQARgRAIAIgAygCDEEAEIoBNwMACyADKAIMEI8BIQELIAAQQCADQRBqJAAgAQtpACABrCAAQgl+fCIAIAKsfCAAQgOGfCEAQQAhASAAIANBMGqtfCAAQgOGfCAAIANBAE4bIQAgBUEAIAVBAEobIQUDQCABIAVGRQRAIAEgBGowAAAgAEIJfnwhACABQQFqIQEMAQsLIAAL1gcLAX8BfwF/AX8BfwF/AX8BfwF/AX8BfiAGQQFqIQ0gACgCFCIPIAAoAgwiCCAEQf8BcSIJIAUgBhCWEyIKQQJ0aiEHIAAoAgBFIQ4CQAJAAn8CQAJAAkADQCAHKAIAIgdFDQEgBy0AKCAJRw0AIAcoAhQgDUcNACAHQSlqIAUgBhDqFA0ACyAHKAIIIgggBygCECIJa0EVTA0BIAchCAwCCyAIIAAoAghBAXRMBEAgCEEDdCIHrRBJIglFDQUgCEEBdCEKIAlBACAHEOcUIQsgACgCDCIHQQAgB0EAShshEANAIAwgEEZFBEAgDyAMQQJ0aiEJA0AgCSgCACIHBEAgCSAHKAIANgIAIAcgCyAKIAdBKGogBygCFBDFEkECdGoiCCgCADYCACAIIAc2AgAMAQsLIAxBAWohDAwBCwsgDxBAIAAgCzYCFCAAIAo2AgwgCiAEQf8BcSAFIAYQlhMhCgtBgAEgBkHqAGoiByAHQYABTRsiCa0QSSIIRQ0EQQAhCyAIQQBBKBDnFCIHIAQ6ACggByAJNgIIIAdBKWogBSAGEOUUGiAHIA02AhQgB0EoaiANakEAOgAAIAcgBkEpaiIJNgIQIAcgACgCFCAKQQJ0aiIKKAIANgIAIAogBzYCACAAIAAoAghBAWo2AgggByAJaiABEOcRIQkgByABNwMgIAcgCSAHKAIQaiIJNgIQIAcgCTYCDCAAKAIAIgpBAUYNAyAHQX9BACAKGzsBGiAJQQFqDAILIAcgCEEBdCIJrBBMIghFDQMgCCAJNgIIIAAoAhQgCkECdGohCQNAIAkiCigCACIJIAdHDQALIAogCDYCACAIKAIQIQkLQQAgCWshCyAIKQMgIhEgAVENASAAIAhBABDGEhogCCAIKAIQaiABIBF9EOcRIQcgCCABNwMgIAggByAIKAIQaiIJNgIQIAggCTYCDEEBIQ4gACgCACIHQQFGDQEgCEEANgIcIAhBf0EAIAcbOwEaIAlBAWoLIQkgCCAJNgIQCwJAAkACQCACQQBOBEAgACgCACIHQQFGBEAgCEEBOgAZDAQLIAIgCC4BGkcEQCAHDQIgCCAJQQFqNgIQIAggCWpBAToAACAIIAgoAhBqIAKtEOcRIQcgCEEANgIcIAggAjsBGiAIIAcgCCgCEGoiCTYCEAsgDkUNAwwCCyAIQQE6ABgMAgsgCCACOwEaIAIhAwsgCCAJaiADIAgoAhxrQQJqrBDnESEHIAggAzYCHCAIIAcgCCgCEGoiCTYCEAsgACgCBCIHIAcoAgAgCSALamo2AgBBAA8LQQcLlQEFAX8BfwF/AX8BfyACQQAgAkEAShshBwNAAkAgBSAHRgRAIAMhBgwBCyABIANMDQAgA0EBaiEEAkACQCAAIANqLQAAQcABSQ0AIAEgBEwNAgNAIAAgBGotAABBwAFxQYABRw0BIARBAWoiBCABRw0ACyABIQMgBUEBaiACRw0CDAELIAQhAwsgBUEBaiEFDAELCyAGCzwBAX9BDSEEA0AgA0EATEUEQCACIANBAWsiA2otAAAgBEEDdHMgBHMhBAwBCwsgBEEDdCABcyAEcyAAcAuKAgMBfwF/AX8jAEEQayIHJAAgB0EANgIMIARBADYCAAJAIABFDQBBDSEFIAMhBgNAIAZBAExFBEAgAiAGQQFrIgZqLAAAIAVBA3RzIAVzIQUMAQsLIAAgBUEDdCABcyAFc0H/A3FBAnRqIgYhBQNAIAUoAgAiBQRAAkAgBSgCCCABRw0AIAUoAgQgA0cNACAFKAIAIAIgAxDqFA0AIARBATYCAAwDCyAFQQxqIQUMAQsLIAdBDGogA0EQaq0QoREiBUUNACAFIAE2AgggBSADNgIEIAUgBUEQaiIBNgIAIAEgAiADEOUUGiAFIAYoAgA2AgwgBiAFNgIACyAHKAIMIQUgB0EQaiQAIAULLgAgAEEsaiEAA0ACQCAAKAIAIgBFDQAgACkDECABUQ0AIABBBGohAAwBCwsgAAvpCRIBfwF/AX8BfwF/AX8BfwF/AX4BfwF/AX8BfwF/AX8BfwF/AX8jAEGAAWsiBSQAIAVBADYCMCAFQQA2AiwCQCADQQVHBEAgAkGy+QJBfxCbAgwBCyABIAAoAggRAQAhBiAFQThqQQBBxAAQ5xQaIAQoAgAQXCENIAUgBCgCBBCaEzYCQCAEKAIIEJoTIQMgBUF/NgI8IAUgAzYCRCANpyIOQQBKIQcgBCgCDBCaEyEPIAQoAhAQXCENIAEgACgCGBEBACIQED8iEQR/IAEgBUEwaiAAKAIgEQAABUEHCyEDIA5BACAHGyEJIA2nIQogBUEoaiIVQQA2AgAgBUIANwMgIAVCADcDGCAGQQAgBkEAShshFkEAIQcCQAJAA0AgByAWRwRAAkAgByAORyAOQQBOcQ0AIAVBADYCICAFQQA2AhggASAHIBUgBUEUaiAAKAIsEQUAIgQNAyABIAUoAiggBSgCFCAFQRhqQbIBIAAoAhQRBwAiBA0DQQAhAyABIAcgBUEQaiAAKAIwEQIAIgQNA0EAIQQDQCADDQEgBCAFKAIwTg0BIAEgBCAFQTRqIAVBDGogBUEIaiAAKAIkEQcAIQMCQCAFKAIMIAdHDQAgBSgCCCAFKAIQSgRAQYsCIQMMAQsgAw0AIBFBACAQEOcUIRICQCAAIAEgBSgCECASIAcgBSgCCCAKIAUgBUEEahCcEyIDDQAgBSgCACIGIAtMDQAgBSAFKAIQNgIsIAUoAgQhCCAGIQsgByEJCyADDQAgBSgCICIGRQ0AIAUoAhAgCkwNAEEBIAYgBkEBTBtBAWshDEEAIQMgBSgCCCETIAUoAiQhFANAAkAgDCADIgZGBEAgDCEGDAELIBQgBkEBaiIDQQJ0aigCACATTA0BCwtBACEDIBQgBkECdCIGaigCACATTg0AIBJBACAQEOcUIQMgACABIAUoAhAgAyAHIAUoAiQgBmooAgAgCiAFQQAQnBMiAw0AIAUoAgBB5ABB+AAgBSgCJCAGaigCACIGG2oiDCALTA0AIAUgBSgCEDYCLEEAIQMgBiEIIAwhCyAHIQkLIARBAWohBAwACwALIAdBAWohBwwBCwsgBSADNgI0IAMiBA0BIAEgCSAFQcgAaiAFQcwAaiAAKAIsEQUAIQQLIAUgBDYCNAsgBCAFKAIsckUEQCAFIAEgCSAFQSxqIAAoAjARAgAiBDYCNAsCQCAFKAJIRQ0AIARFBEAgBSAAIAEgCSAFQdAAahCdEyIENgI0CyAFIAg2AjggBSAIIApqQQFrNgI8IAhBAEoEQCAFQTRqIAVBOGogD0F/EJ4TIAUoAjQhBAsgBUHQAGohBgNAIAQgBSgCZCIDQQBIIAMgCE5yckUEQCAGEJ8TIQQMAQsLIAUgBDYCNCAERQRAIAUgASAFKAJIIAUoAkwgBUE4akGzASAAKAIUEQcANgI0QQEhBAsgBSgCdARAIAVBNGogBUE4aiAFKAJEQX8QnhMLIAUoAjwgBSgCLEEBa04EQCAFQTRqIAVBOGogBSgCcCIEIAUoAkhqIAUoAkwgBGsQnhMMAQsgBUE0aiAFQThqIA9BfxCeEwsCQCAFKAI0IgRFBEAgAiAFKAJ4QX9BfxCnAgwBCyACIAQQsAILIAUoAngQQCAREEAgBSgCJBBACyAFQYABaiQACw8AIAAQXyIAQemfAyAAGwu8AQQBfwF/AX8BfyABQQFxRQRAAkACQCAAKAIAIghBAEwEQEEAIQgMAQtBfyAEQQFrIgcgB0F/ThshCSAHIQZBACEEAkADQCAGQQBIDQEgACgCECAGai0AACIEQQlrIgFBF0tBASABdEGTgIAEcUVyRQRAIAZBAWshBgwBCwsgBiEJC0EAIQYgByAJRg0BIARB/wFxIgFBOkYNACABQS5HDQELIAAgCBCkEyEGCyAAIAAoAgBBAWo2AgALIAYLtAILAX8BfgF/AX8BfwF/AX8BfwF+AX8BfyMAQRBrIgkkACAJQQA2AgwgCUEANgIIIAlBADYCBCAGrCIRIAWsfCEKQX8hCyABIAkgACgCIBEAACEOA0AgDCAJKAIATiAOckUEQAJAIAEgDCAJQQxqIAlBCGogCUEEaiAAKAIkEQcAIg4NACAJKAIIIARHDQAgCSgCBCIQIAVIIAogEKxXcg0AIAMgCSgCDCINaiISLQAAIRMgEkEBOgAAIAEgDSAAKAIcEQAAIBBqIQ0gECALIAtBAEgbIQtBAUHoByATGyAPaiEPCyAMQQFqIQwMAQsLIAcgDzYCACAIBEAgCCACIAZrrCAGIAtqIA1rQX5tIAtqrCIKIAKsIAogEXxTGyIKQgAgCkIAVRs+AgALIAlBEGokACAOC0MAIANCADcCDCADIAI2AgggAyABNgIEIAMgADYCACADQgA3AhQgASADQRBqIAAoAiARAAAiAUUEQCADEJ8TIQELIAELagIBfwF/IwBBEGsiBCQAAkAgAkUNACAAKAIADQAgA0EASARAIAIQ7xUhAwsgASgCQCEFIAQgAjYCCCAEIAM2AgQgBCAFNgIAIAFBydEAIAQQZyICNgJAIAINACAAQQc2AgALIARBEGokAAviAQYBfwF/AX8BfwF/AX8jAEEQayIBJAAgAEJ/NwIUA0ACQCACDQAgACgCDCIDIAAoAhBODQAgACgCBCADIAFBDGogAUEIaiABQQRqIAAoAgAoAiQRBwAiA0UEQAJAIAEoAgggACgCCEcNACABKAIEIAAoAgQgASgCDCAAKAIAKAIcEQAAakEBayEEIAEoAgQhBQJAIAAoAhRBAEgEQCAAIAU2AhQMAQsgBSAAKAIYIgZKDQMgBCAGTA0BCyAAIAQ2AhgLIAAgACgCDEEBajYCDAsgAyECDAELCyABQRBqJAAgAguCBAQBfwF/AX8BfyMAQRBrIgckACAHQQA2AgwCQCABQQFxDQAgACAAKAI0IgFBAWo2AjQCQCAAKAIEIghBAEgNACABIAAoAgAiCUggASAISnINASAJRSABIAlHcg0AIAAgBDYCOAtBASEGAkAgACgCPEUNAEEAIQYgACgCLCIIIAFIIAhBAE5xDQAgACgCOCAETg0AIAdBDGogACAAKAIMQX8QnhMgAEEANgI8QQEhBgsCQAJAIAAoAiwgAUZBACAGG0UEQCABIAAoAjBHDQIgBkUNASAHQQxqIAAgACgCCEF/EJ4TIABBATYCPAwBCyAHQQxqIAAgACgCOCIGIAAoAhBqIAQgBmsQnhMgB0EMaiAAIAAoAghBfxCeEyAAQQE2AjwgACAENgI4IAEgACgCMEcNAQsgB0EMaiAAIAAoAjgiBiAAKAIQaiAFIAZrEJ4TIAAgBTYCOCAHKAIMDQAgByAAQRhqEJ8TNgIMCyAAKAIEIAFGBEAgACgCPARAIAAoAiwiBkEASCABIAZIckUEQCAHQQxqIAAgACgCOCIGIAAoAhBqIAUgBmsQnhMgACAFNgI4CyAHQQxqIAAgACgCDEF/EJ4TIABBADYCPAsgB0EMaiAAIAAoAjgiBiAAKAIQaiAFIAZrEJ4TIAAgBTYCOAsgBygCDCEGCyAHQRBqJAAgBgvYAgIBfwF+IwBB0ABrIgUkAAJAIANBA0cEQCACQYD5AkF/EJsCDAELIAQoAgAQXCEGIAVBCGpBAEHEABDnFBogBSAEKAIEEF82AhAgBCgCCBBfIQQgBUF/NgIMIAUgBDYCFCAFIAEgBqciAyAFQRhqIAVBHGogACgCLBEFACIENgIEIARBGUYEQCACQemfA0F/QQAQpwIMAQsgBSgCGARAAkAgBA0AIAUgACABIAMgBUEgahCdEyIENgIEIAQNAEEBIQQgBSABIAUoAhggBSgCHCAFQQhqQbMBIAAoAhQRBwA2AgQLIAUoAkQEQCAFQQRqIAVBCGogBSgCFEF/EJ4TCyAFQQRqIAVBCGogBSgCQCIEIAUoAhhqIAUoAhwgBGsQnhMgBSgCBCIERQRAIAIgBSgCSEF/QX8QpwILIAUoAkgQQAsgBEUNACACIAQQsAILIAVB0ABqJAAL/QULAX8BfwF/AXwBfwF/AX8BfwF+AXwBfCMAQSBrIgYkACAGQQA2AgQCfyABQQAgACgCPBEAACIJRQRAIAZCADcDGCAGQgA3AxACQCABIAAoAhgRAQAiCkEEdEEYaiIFrRBJIglFBEBBByEHDAELIAlBACAFEOcUIgUgBUEYaiIHNgIQIAUgCjYCACAFIAcgCkEDdGo2AhQgASAGQRhqIAAoAgwRAAAiBw0AIAFBfyAGQRBqIAAoAhARAgAiBw0AIAUgBikDELkgBikDGLmjOQMIQQAhBwtBACEFA0AgByAFIApOckUEQCAGQgA3AwggASAFIAZBCGpBtAEgACgCNBEFACIHRQRAIAYpAxggBikDCCINfblEAAAAAAAA4D+gIA25RAAAAAAAAOA/oKMQ6RQhCCAJKAIQIAVBA3RqRI3ttaD3xrA+IAggCEQAAAAAAAAAAGUbOQMACyAFQQFqIQUMAQsLIAcEQCAJEEBBAAwCC0EAIAEgCUEBIAAoAjgiBRECACIHDQEaCyAJKAIUIgtBACAJKAIAQQN0EOcUGiABIAZBBGogACgCIBEAACEHIAkLIQxBACEFA0ACQCAHDQAgBSAGKAIETg0AIAEgBSAGQRhqIAZBEGogBkEIaiAAKAIkEQcAIgdFBEBEAAAAAAAA8D8hCCADIAYoAhAiCkoEQCAEIApBAnRqKAIAEFEhCAsgCyAGKAIYQQN0aiIKIAggCisDAKA5AwALIAVBAWohBQwBCwsCQAJAIAcNACABQX8gBkEYaiAAKAIwEQIAIgcNACAGKAIYt0QAAAAAAADoP6IhDkEAIQUgDCgCACIHQQAgB0EAShshAEQAAAAAAAAAACEIA0AgACAFRkUEQCAFQQN0IgcgDCgCEGorAwAgByALaisDACIPRJqZmZmZmQFAoiAOIAwrAwijRAAAAAAAANA/oEQzMzMzMzPzP6IgD6CjoiAIoCEIIAVBAWohBQwBCwsgAiAImhCYAgwBCyACIAcQsAILIAZBIGokAAsRACACIAIpAwBCAXw3AwBBAAtzAgF/AX8CQCAAKAIEIgIgACgCCCIDRwRAIAAoAgwhAgwBCyAAKAIMIAJBAXRBwAAgAhsiA0ECdK0QTCICRQRAQQcPCyAAIAM2AgQgACACNgIMIAAoAgghAwsgACADQQFqNgIIIAIgA0ECdGogATYCAEEAC/wLCQF/AX8BfwF/AX8BfwF/AX8Bf0EBIQUgAkEBcUUEQAJAAkBBtAEQPyIKRQRAQQchBQwBC0EAIQUgCkEAQbQBEOcUIgRCwICAgBA3AoQBIARCwAAQSSIJNgKAAUGj+wAhBgNAIAlFIAIgBUxyRQRAIAEgBUECdCIIaigCAEH2zwAQbEUEQCABIAhBBHJqKAIAIQYLIAVBAmohBQwBCwsCQCAJRQRAQQchBQwBCyAEQZQBaiEJIAYtAAAhBSAEIgtBmQFqIgghDANAAkAgBUH/AXFFBEBBACEIQQAhBgwBCwNAIAVB/wFxIgVBCUcgBUEgR3FFBEAgBi0AASEFIAZBAWohBgwBCwsCQCAFRQ0AIAlBAToAAAJAAkACQAJAAkACQAJAIAYsAAAiBUHMAGsODwECAwcEBwcFBwcHBwcHBgALIAVBwwBHDQZBASEFAkACQAJAAkACQCAGLAABIgdB7gBrDgYBBA4ODgIACwJAAkAgB0HjAGsOBAAPDwEECyAEQQE6AJUBDAsLIARBAToAlgEMCgsgBEEBOgCXAQwJCyAEQQE6AJgBDAgLIAdBKkcNCiAEQYGChAg2AJUBCyAEQQE6ALMBDAYLQQEhBQJAAkACQAJAAkACQAJAIAYsAAEiB0HsAGsOCgECDwMPDw8PBAUACyAHQSpGDQUgB0HDAEcNDiAEQQE6ALIBDAsLIAtBAToAmQEMCgsgBEEBOgCaAQwJCyAEQQE6AJsBDAgLIARBAToAnAEMBwsgBEEBOgCdAQwGCyAEQQE6ALIBIAxBAToABCALQYGChAg2AJkBDAULQQEhBQJAAkACQAJAIAYsAAEiB0HjAGsOAwELAgALIAdBKkYNAiAHQe4ARw0KIARBAToAoAEMBwsgBEEBOgCeAQwGCyAEQQE6AJ8BDAULIARBAToAoAEgBEGBAjsAngEMBAtBASEFAkACQAJAAkAgBiwAASIHQewAaw4EAQoKAgALIAdBKkYNAiAHQeQARw0JIARBAToAoQEMBgsgBEEBOgCiAQwFCyAEQQE6AKMBDAQLIARBAToAowEgBEGBAjsAoQEMAwtBASEFAkACQAJAAkACQAJAAkACQCAGLAABIgdB4wBrDhEAAQIDDQ0EDQ0NDQ0FDQ0NBgcLIARBAToApAEMCQsgBEEBOgClAQwICyAEQQE6AKYBDAcLIARBAToApwEMBgsgBEEBOgCoAQwFCyAEQQE6AKkBDAQLIARBAToAqgEMAwsgB0EqRw0FIARBgYKECDYApAEgBEGBgoQINgCnAQwCC0EBIQUCQAJAAkACQAJAIAYsAAEiB0HrAGsOBQEJAgkDAAsgB0EqRg0DIAdB4wBHDQggBEEBOgCrAQwFCyAEQQE6AKwBDAQLIARBAToArQEMAwsgBEEBOgCuAQwCCyAEQYGChAg2AKsBDAELQQEhBQJAAkACQAJAIAYsAAEiB0HwAGsOBAEHBwIACyAHQSpGDQIgB0HsAEcNBiAEQQE6AK8BDAMLIARBAToAsAEMAgsgBEEBOgCxAQwBCyAEQQE6ALEBIARBgQI7AK8BCwNAIAYtAAAiBUUgBUEJRnIgBUEgRnINAiAGQQFqIQYMAAsACwsDQAJAIAZB/wBMBEAgCEEBdEGw6gRqLwEAIgdBBXYgBmohBSAJIAdBH3FqLQAAIQcDQCAFIAZMIAZB/wBKcg0CIAQgBmogBzoAACAGQQFqIQYMAAsAC0EAIQUgBEEAOgAADAILIAhBAWohCAwACwALQQAhBgNAIAUgAiAGTHJFBEAgASAGQQJ0IgVBBHJqKAIAIQhBACEHAkAgASAFaigCACIFQbPRABBsRQRAQQEhBSAILQAAQTBrIgdB/wFxQQJLDQEgCC0AAQ0BIAQgBzYCiAFBACEFDAELIAVBwsYAEGxFBEAgBCAIQQEQphMhBQwBCyAFQfjDABBsRQRAIAQgCEEAEKYTIQUMAQsgBUH2zwAQbEEARyEFCyAGQQJqIQYMAQsLIAUNAEEAIQUMAQsgChCnE0EAIQoLIAMgCjYCAAsgBQubAwYBfwF/AX8BfwF/AX8CQCABEO8VIgNBAEwNACAAKAKQASAAKAKMASADakECdK0QTCIHRQRAQQcPCyABIANqIQggACgCjAEhBQNAAkACQAJAIAEgCEkEQCABQQFqIQMgAS0AACIEQcABSQ0BIARB8NQDai0AACEEA0ACQCADIAhGBH8gCAUgAy0AACIBQcABcUGAAUYNASADCyEBQf3/A0H9/wNB/f8DIAQgBEGAcHFBgLADRhsgBEGAAUkbIARBfnFB/v8DRhshBAwECyABQT9xIARBBnRyIQQgA0EBaiEDDAALAAsgACAFNgKMASAAIAc2ApABDAQLIATAQQBODQEgAyEBCyAEELUTIABqLQCUASACRg0BIAQQqxMNAUEAIQMgBUEAIAVBAEobIQYDQAJAIAMgBkcEQCAHIANBAnRqKAIAIARNDQEgAyEGCyAHIAZBAnRqIgNBBGogAyAFIAZrQQJ0EOYUGiADIAQ2AgAgBUEBaiEFDAMLIANBAWohAwwACwALIAAgBGogAjoAACADIQEMAAsAC0EACxsAIAAEQCAAKAKQARBAIAAoAoABEEAgABBACwujBwoBfwF/AX8BfwF/AX8BfwF/AX8BfyADIARqIQogACgChAEiDCAAKAKAASILakEGayEOIAMhBANAIAZFBEACfwNAIAogBCIITQRAQQAPCyAILAAAIglB/wFxIQYCQAJAIAlBAEgEQCAIQQFqIQQgCUFASQ0CIAZB8NQDai0AACEGA0AgBCAKRgRAIAohBAwDCyAELQAAIgdBwAFxQYABRw0CIAdBP3EgBkEGdHIhBiAEQQFqIQQMAAsACwJAIAAgBmotAAAEQCAIIANrIQ8gCyEHDAELIAhBAWohBAwDC0EBDAMLQf3/A0H9/wNB/f8DIAYgBkGAcHFBgLADRhsgBkGAAUkbIAZBfnFB/v8DRhshBgsgACAGEKkTRQ0ACyAIIANrIQ8gCyEHQQALIQ0DQAJAAkACQAJAAkACfyANRQRAAkAgBiAAKAKIARCqEyIGRQ0AIAZB/wBNBEAgByAGOgAAIAdBAWohBwwBCyAGQf8PTQRAIAcgBkE/cUGAAXI6AAEgByAGQQZ2QcABcjoAACAHQQJqIQcMAQsgBkH//wNNBEAgByAGQT9xQYABcjoAAiAHIAZBDHZB4AFyOgAAIAcgBkEGdkE/cUGAAXI6AAEgB0EDaiEHDAELIAcgBkE/cUGAAXI6AAMgByAGQQZ2QT9xQYABcjoAAiAHIAZBDHZBP3FBgAFyOgABIAcgBkESdkEHcUHwAXI6AAAgB0EEaiEHCyAEDAELIAcgCUEgaiAJIAlBwQBrQf8BcUEaSRs6AAAgB0EBaiEHIAhBAWoLIgggCk8NACAHIA5LBEAgDKxCAYYQSSILRQRAQQcPCyALIAAoAoABIgkgDBDlFCEGIAAoAoABEEAgACAMQQF0Igw2AoQBIAAgBjYCgAEgBiAMakEGayEOIAYgByAJa2ohBwsgCCwAACIJQf8BcSEGIAlBAEgEQCAIQQFqIQQgCUFASQ0DIAZB8NQDai0AACEGA0AgBCAKRgRAIAohBAwECyAELQAAIg1BwAFxQYABRw0DIA1BP3EgBkEGdHIhBiAEQQFqIQQMAAsACyAAIAZqLQAARQ0AQQEhDQwFCyAIIQQMAgtB/f8DQf3/A0H9/wMgBiAGQYBwcUGAsANGGyAGQYABSRsgBkF+cUH+/wNGGyEGCyAAIAYQqRMNASAGEKsTDQELIAFBACALIAcgC2sgDyAIIANrIAURCQAhBgwDC0EAIQ0MAAsACwsgBkEAIAZB5QBHGwuQAQYBfwF/AX8BfwF/AX8gARC1EyAAai0AlAEhBgJAIAAoAowBIgJBAEwEQAwBCyACQQFrIQIgACgCkAEhB0EAIQADfyAAIAJKDQEgASAHIAAgAmpBAm0iBUECdGooAgAiBEYEf0EBBSACIAVBAWsgASAESiIEGyECIAVBAWogACAEGyEADAELCyEDCyADIAZzC5IDBgF/AX8BfwF/AX8BfyAAQf8ATARAIABBIGogACAAQcEAa0EaSRsPCwJAIABB//8DTQRAQaIBIQJBfyEEA0AgAiADSEUEQCACIANqQQJtIgVBAWsgAiAFQQJ0QYCiBWovAQAgAEoiBhshAiAEIAUgBhshBCADIAVBAWogBhshAwwBCwsCQCAEQQJ0IgNBgKIFaiICLQADIAIvAQAiAmogAEwNACAAIAJzIANBgKIFai0AAiICcUEBcQ0AIAJB/gFxQZCnBWovAQAgAGpB//8DcSEACyABRQ0BIABBA3RBB3IhB0H9ACECQQAhBEEAIQMDQCACIANIRQRAIAMgAiADakECbSIFQQFqIAcgBUEBdEGwqAVqLwEASSIGGyEDIAVBAWsgAiAGGyECIAQgBSAGGyEEDAELCyABQQJHBEAgBEGwqgVqLAAAQQBIDQILIARBAXRBsKgFai8BACICQQN2IAJBB3FqIABIDQEgBEGwqgVqLQAAQf8AcQ8LIABBKGogACAAQYCIBGtBKEkbIQALIAALPAEBfyAAQbIGa0FOTwRAIABBnwZNBEBBASAAQYAGa3RB37+KwABxDwtBASAAQaAGa3RB+MMNcSEBCyABC7sBBQF/AX8BfwF/AX9BASEGAkAgAkEBcQ0AQYABED8iBEUEQEEHIQYMAQsgBEGwqwVBgAEQ5RQhB0EAIQQDQCAEIAIgBUxyRQRAAn8gByABIAVBAnQiBEEEcmooAgAgASAEaigCACIIQcLGABBsBH9BASIEIAhB+MMAEGwNARpBAAVBAQsiBBCtE0EACyEEIAVBAmohBQwBCwsgBEUEQEEAIQYgByEFDAELIAcQQEEAIQULIAMgBTYCACAGCzMCAX8BfwNAIAEgA2osAAAiBARAIARBgAFxRQRAIAAgBGogAjoAAAsgA0EBaiEDDAELCwsGACAAEEALigMLAX8BfwF/AX8BfwF/AX8BfwF/AX8BfyMAQUBqIgwkACAMIQlBwAAhDQJAAkADQAJAIAQgCEwgBnINAANAQQAhBiAEIAhGIgoNAQJAIAMgCGoiECwAACIHQYABcQ0AIAAgB2otAAANACAIQQFqIQgMAQsLIAoNACAEIAhBAWoiByAEIAdKGyIOQQFrIQYgCCEKA0ACQCAGIAoiD0YEQCAGIQ8gDiEKDAELIAMgD0EBaiIKaiwAACIHQYABcQ0BIAAgB2otAAANAQsLIA0gCiAIayILSARAIAkgDEcEQCAJEEALIAusQgGGEEkiCUUEQEEAIQlBByEGDAQLIAtBAXQhDQtBACEHIAtBACALQQBKGyEOA0AgByAORkUEQCAHIAlqIAcgEGotAAAiBkEgaiAGIAZBwQBrQf8BcUEaSRs6AAAgB0EBaiEHDAELCyABQQAgCSALIAggCiAFEQkAIQYgD0ECaiEIDAELCyAJIAxGDQELIAkQQAsgDEFAayQAIAZBACAGQeUARxsLtAEEAX8BfwF/AX8jAEEQayIFJAAgBUEANgIMIAJBAEwEf0HrygIFIAEoAgALIQcCQAJAQZABED8iBEUEQEEHIQAMAQsgACAHIAVBDGogBEEAQZABEOcUIgYgACgCCBEFACIADQAgBSgCDCABQQRqQQAgAkEBa0EAIAJBAEobIgIbIAIgBkEMaiAGKAIAEQUAIgANAEEAIQAMAQsgBBCxE0EAIQQLIAMgBDYCACAFQRBqJAAgAAshAQF/IAAEQCAAKAIMIgEEQCABIAAoAgQRAwALIAAQQAsLTAEBfyMAQRBrIgYkACAGIAE2AgAgBiAFNgIEIAYgAEEQajYCCEEBIQEgACgCDCAGIAIgAyAEQbUBIAAoAggRCQAhACAGQRBqJAAgAAv6GwYBfwF/AX8BfwF/AX8CQAJAIANBwQBrQUJPBEAgACgCCCACIAMQ5RQiAiADQQFrIgZqLQAAQfMARw0BIAIgA0ECayIHai0AACIIQfMARg0BAkAgCEHlAEcNAAJAIANBBU8EQCACIANqIghBBGstAABB8wBHDQEgCEEDay0AAEHzAEcNAQwFCyADQQRHDQELIAIgA2pBA2stAABB6QBGDQMLIAYhBwwCCyAAKAIAIAEgAiADIAQgBSAAKAIEEQkADwsgAyEHCwJAAkACQCACIAdBAmsiA2oiCCwAACIGQe4ARwRAIAZB5QBHDQICQCAHQQRPBEBB5rcBIAIgB0EDayIGaiIJQQMQ6hQNASACIAYQthNFDQQgCUHlygE7AAAgB0EBayEGDAULQQIhBiAHQQNHDQQLIAgvAABB5cgBRw0CIAchBiACIAMQtxMNAQwDCyAHQQRJDQFBt48BIAIgB0EDayIDakEDEOoUDQEgByEGIAIgAxC3E0UNAgsCQAJAAkACQAJAIAIgA2oiCUECayIGLAAAIghB4QBrDgIAAQILIANBA0kNAyAGLwAAQeHoAUcNAyAGQYWYASIHLwAAOwAAIAZBh5gBLQAAOgACDAILIANBA0kNAiAGLwAAQeLYAUcNAiAGQaGmASIHLwAAOwAAIAZBo6YBLQAAOgACDAELIAhB6QBHIANBA0lyDQEgBi8AAEHp9AFHDQEgBkH8kgEiBy8AADsAACAGQf6SAS0AADoAAgsgA0EBaiEGDAILAkAgAiADQQFrIgZqLQAAIgpB4QBrIgdBB3QgB0H+AXFBAXZyQf8BcSIHQQpNQQBBASAHdEGVCXEbDQAgCkHsAGsiB0EOTUEAQQEgB3RBgYEBcRsNACAKIAhB/wFxRg0CCwJAIAIgAxC4E0UNACACIAMQuRNFDQAgCUHlADoAACADQQFqIQYMAgsgAyEGDAELIAchBgsCQCACIAZBAWsiB2oiAy0AAEH5AEcNACACIAcQtxNFDQAgA0HpADoAAAsCQAJAAkACQAJAAkACQAJAAkACQCACIAYiA0ECayIIaiwAAEHhAGsOFAAJAQkCCQMJCQkJBAkJBQkJCQYHCQsCQCAGQQhPBEBBzYgBIAIgBkEHayIHaiIDQQcQ6hQNASACIAcQthNFDQkgA0GFmAEiBy8AADsAACADQYeYAS0AADoAAiAGQQRrIQMMCgsgBkEHRw0IC0HOiAEgAiAGQQZrIgdqIglBBhDqFA0HIAYhAyACIAcQthNFDQggCUH00r3zBjYAACAIIQMMCAsgBkEFSQ0GIAIgBkEEayIHaiIDKAAAQeXcjcsGRgRAIAIgBxC2E0UNByADQeXcjasGNgAADAcLIAMoAABB4dyNywZHDQYgAiAHELYTRQ0GIANB4dyNqwY2AAAMBgsgBkEFSQ0FIAIgBkEEayIJaiIIKAAAQen0lZMHRw0FIAIgCRC2E0UNBiAIQfySASIDLwAAOwAAIAhB/pIBLQAAOgACIAchAwwGCyAGQQVJDQQgAiAGQQRrIglqIggoAABB7N6dywZHDQQgAiAJELYTRQ0FIAhBuI4BIgMvAAA7AAAgCEG6jgEtAAA6AAIgByEDDAULIAZBBEkNA0GziwEgAiAGQQNrIglqIgdBAxDqFEUEQCACIAkQthNFDQQgB0GhpgEiAy8AADsAACAHQaOmAS0AADoAAgwEC0EAIQMCQCAGQQVJDQAgAiAGQQRrIgpqIgsoAABB4dixywZGBEAgBiEDIAIgChC2E0UNBiALQeHYATsAACAIIQMMBgsgBkEGSQ0AQQEhA0GjiwEgAiAGQQVrIgtqIgpBBRDqFA0AIAYhAyACIAsQthNFDQUgCkHfNiIDLwAAOwAAIApB4TYtAAA6AAIgCCEDDAULQa+LASAHQQMQ6hRFBEAgBiEDIAIgCRC2E0UNBSAHQeUAOgAAIAghAwwFCyADRQ0DQamLASACIAZBBWsiCWoiB0EFEOoUDQMgBiEDIAIgCRC2E0UNBCAHQbM9IgMvAAA7AAAgB0G1PS0AADoAAiAIIQMMBAsCQAJAAkAgBkEITwRAQeT/ACACIAZBB2siCWoiA0EHEOoUDQEgAiAJELYTRQ0GIANB/JIBIgcvAAA7AAAgA0H+kgEtAAA6AAIgBkEEayEDDAcLIAZBBkkNAQtBmIABIAIgBkEFayIKaiIJQQUQ6hQNASAGIQMgAiAKELYTRQ0FIAlBhZgBIgMvAAA7AAAgCUGHmAEtAAA6AAIgCCEDDAULIAZBBUcNAwsgAiAGQQRrIglqIggoAABB4ei9kwdHDQIgBiEDIAIgCRC2E0UNAyAIQYWYASIDLwAAOwAAIAhBh5gBLQAAOgACIAchAwwDCyAGQQZJDQFBnoUBIAIgBkEFayIDaiIHQQUQ6hRFBEAgAiADELYTRQ0CIAdB4dgBOwAAIAZBA2shAwwDCyAGQQhJDQFBtcMAIAIgBkEHayIHaiIDQQcQ6hRFBEAgAiAHELYTRQ0CIANB2JUBIgcvAAA7AAAgA0HalQEtAAA6AAIgBkEEayEDDAMLQa3DACADQQcQ6hRFBEAgAiAHELYTRQ0CIANBsIYBIgcvAAA7AAAgA0GyhgEtAAA6AAIgBkEEayEDDAMLQZnDACADQQcQ6hQNASACIAcQthNFDQEgA0GzPSIHLwAAOwAAIANBtT0tAAA6AAIgBkEEayEDDAILIAZBBkkNAEH/igEgAiAGQQVrIglqIgdBBRDqFEUEQCACIAkQthNFDQEgB0Hh2AE7AAAgBkEDayEDDAILQfKKASAHQQUQ6hRFBEAgAiAJELYTRQ0CIAdB2JUBIgMvAAA7AAAgB0HalQEtAAA6AAIgCCEDDAILQQYhAyAGQQdJDQFB+IoBIAIgBkEGayIHaiIDQQYQ6hQNACACIAcQthNFDQAgA0GhpgEiBy8AADsAACADQaOmAS0AADoAAiAGQQNrIQMMAQsgBiEDCwJAAkACQAJAAkACQAJAAkAgAiADQQJrIgZqLAAAIgdB8wBrDggBAgMEBwcHBQALIAdB4QBHIANBBUlyDQYgAiADQQRrIghqIgkoAABB6caF4wZHDQYgAiAIELYTRQ0GIAlB6cYBOwAAIAYhCAwFCyADQQVJDQUgAiADQQRrIghqKAAAQe7KzZsHRw0FIAIgCBC2Ew0EDAULIANBBkkNBEGDmAEgAiADQQVrIglqIghBBRDqFEUEQCACIAkQthNFDQUgCEHpxgE7AAAgA0EDayEIDAQLQYWLASAIQQUQ6hQNBCACIAkQthNFDQQgCEHpxgE7AAAgA0EDayEIDAMLIANBBEkNA0GwhgEgAiADQQNrIghqQQMQ6hQNAyACIAgQthMNAgwDCyADQQZJDQJBzJUBIAIgA0EFayIIakEFEOoUDQIgAiAIELYTDQEMAgsgA0EGSQ0BQduSASACIANBBWsiCGoiCUEFEOoUDQEgAiAIELYTRQ0BIAlB4dgBOwAAIANBA2shCAsgAiAIQQJrIgZqLQAAIQcgCCEDCyACIAZqIQgCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAfAQeEAaw4aAA0BDQINDQ0DDQ0EDQUGDQ0NBwgJCg0NDQsNCyADQQNJDQwgCC8AAEHh2AFHDQwgAiAGELoTDQsMDAsgA0EFSQ0LIAIgA0EEayIGaiIHKAAAQeHcjasGRgRAIAIgBhC6Ew0LDAwLIAcoAABB5dyNqwZHDQsgAiAGELoTDQoMCwsgA0EDSQ0KIAgvAABB5eQBRw0KIAIgBhC6Ew0JDAoLIANBA0kNCSAILwAAQenGAUcNCSACIAYQuhMNCAwJCyADQQVJDQggAiADQQRrIgZqIgcoAABB4cSxqwZGBEAgAiAGELoTDQgMCQsgBygAAEHpxLGrBkcNCCACIAYQuhMNBwwICyADQQRJDQdBjDcgAiADQQNrIgZqIgdBAxDqFEUEQCACIAYQuhMNBwwICwJAAkAgA0EGTwRAQd02IAIgA0EFayIIakEFEOoUDQEgAiAIIgYQuhMNCQwKCyADQQVHDQELIAIgA0EEayIIaigAAEHtyrmjB0cNACACIAgiBhC6Ew0HDAgLQd82IAdBAxDqFA0HIAIgBhC6Ew0GDAcLAkAgA0EETwRAQdmBASACIANBA2siB2pBAxDqFA0BIAIgA2pBBGstAABB8wBrQf8BcUEBSw0IIAIgByIGELoTDQcMCAsgA0EDRw0HCyAILwAAQe/qAUcNBiACIAYQuhMNBQwGCyADQQRJDQVBoIUBIAIgA0EDayIGakEDEOoUDQUgAiAGELoTDQQMBQsgA0EESQ0EQYWYASACIANBA2siBmoiB0EDEOoURQRAIAIgBhC6Ew0EDAULQYeLASAHQQMQ6hQNBCACIAYQuhMNAwwECyADQQRJDQNBsz0gAiADQQNrIgZqQQMQ6hQNAyACIAYQuhMNAgwDCyADQQRJDQJB2JUBIAIgA0EDayIGakEDEOoUDQIgAiAGELoTDQEMAgsgA0EESQ0BQfySASACIANBA2siBmpBAxDqFA0BIAIgBhC6E0UNAQsgBiEDCwJAIAIgA0EBayIGai0AAEHlAEcNACACIAYQuhNFBEAgAiAGELgTRQ0BIAIgBhC5Ew0BCyAGIQMLAkAgA0ECSA0AIAIgA0EBayIGai0AAEHsAEcNACACIANqQQJrLQAAQewARw0AIAYgAyACIAYQuhMbIQMLIAAoAgAgASACIAMgBCAFIAAoAgQRCQALhwgJAX8BfwF/AX8BfwF/AX8BfwF+IwBBMGsiCSQAIAMgBGohDCAJQRBqIQggAyEEAkADQCAKQQNHBEAgCUEEaiAKQQJ0aiELIAQhBwNAIAsgByADazYCACAHQQFqIQQCQAJAIActAAAiBkHAAU8EQCAGQfDUA2otAAAhBgNAIAQgDEYEQCAMIQQMAwsgBC0AACIHQcABcUGAAUcNAiAHQT9xIAZBBnRyIQYgBEEBaiEEDAALAAsgBg0BQQAhBwwFC0H9/wNB/f8DQf3/AyAGIAZBgHBxQYCwA0YbIAZBgAFJGyAGQX5xQf7/A0YbIQYLIAAoAgAEQCAEIQcgBiAAKAIEEKoTIgZFDQELCwJ/IAZB/wBNBEAgCCAGOgAAIAhBAWoMAQsgBkH/D00EQCAIIAZBP3FBgAFyOgABIAggBkEGdkHAAXI6AAAgCEECagwBCyAGQf//A00EQCAIIAZBP3FBgAFyOgACIAggBkEMdkHgAXI6AAAgCCAGQQZ2QT9xQYABcjoAASAIQQNqDAELIAggBkE/cUGAAXI6AAMgCCAGQQZ2QT9xQYABcjoAAiAIIAZBDHZBP3FBgAFyOgABIAggBkESdkEHcUHwAXI6AAAgCEEEagshCCAKQQFqIQoMAQsLIAlBEGpBAXIhCgNAIAQiC0EBaiEEAkACQAJAIAstAAAiBkHAAU8EQCAGQfDUA2otAAAhBgNAIAQgDEYEQCAMIQQMAwsgBC0AACIHQcABcUGAAUcNAiAHQT9xIAZBBnRyIQYgBEEBaiEEDAALAAsgBg0BQQAhBgwCC0H9/wNB/f8DQf3/AyAGIAZBgHBxQYCwA0YbIAZBgAFJGyAGQX5xQf7/A0YbIQYLIAAoAgBFDQAgBiAAKAIEEKoTIgZFDQELIAFBACAJQRBqIAggCUEQamsgCSgCBCALIANrIg0gBREJACIHIAZFcg0BIAohCyAKIQcgCS0AEEHAAU8EQANAIAsiB0EBaiELIActAABBwAFxQYABRg0ACwsgCUEQaiAHIAggB2sQ5hQaIAggCUEQaiAHa2ohBwJ/IAZB/wBNBEAgByAGOgAAIAdBAWoMAQsgBkH/D00EQCAHIAZBP3FBgAFyOgABIAcgBkEGdkHAAXI6AAAgB0ECagwBCyAGQf//A00EQCAHIAZBP3FBgAFyOgACIAcgBkEMdkHgAXI6AAAgByAGQQZ2QT9xQYABcjoAASAHQQNqDAELIAcgBkE/cUGAAXI6AAMgByAGQQZ2QT9xQYABcjoAAiAHIAZBDHZBP3FBgAFyOgABIAcgBkESdkEHcUHwAXI6AAAgB0EEagshCCAJKQIIIQ4gCSANNgIMIAkgDjcCBAwACwALIAlBMGokACAHC90BBgF/AX8BfwF/AX8BfwJAIABB//8/Sw0AIABBD3ZB/v8HcUGAhgVqIgIvAQAhASACLwECIQIgAEH//wNxIQZBfyEEA0AgASACTkUEQCAEIAEgAmoiA0EBdiIFIAYgA0F+cUGwhgVqLwEASSIDGyEEIAUgAiADGyECIAEgBUEBaiADGyEBDAELC0EAIQEgBEEASA0AIAYgBEEBdCIFQQAiAkGw6gRqai8BACIDQQV2IAVBsIYFai8BACICak8NACADQR9xIgFBHkcNAEEFQQkgACACa0EBcRshAQsgAQsOACAAIAFBABC8E0EARwtKAwF/AX8BfyABQQAgAUEAShshAkEAIQEDQCABIAJGBEBBAA8LIAFBAEchAyAAIAFqIQQgAUEBaiEBIAQsAAAgAxC7E0UNAAtBAQssAQF/An8gACABQQAQvBMiAgRAQQEgACACaiABIAJrQQEQvBNFDQEaC0EACwtqAwF/AX8BfyAAIAFqQQFrLQAAQfcAa0H/AXFBA08EQCABQQAgAUEAShshBEEAIQEDQCACIARGRQRAIAAgAmosAAAgAxC7E0UiAyABQQF0ciEBIAJBAWohAgwBCwsgAUEHcUEFRiECCyACCysBAX8CfyAAIAFBABC8EyICBEBBASAAIAJqIAEgAmtBARC8Ew0BGgtBAAsLQAEBfyAAQeEAayICQQd0IAJB/gFxQQF2ckH/AXEiAkELT0GVCSACdkEBcUVyRQRAQQEPCyAAQfkARiABQQBHcQt7AwF/AX8BfyABQQAgAUEAShshBANAAkAgAyAERgRAIAQhAwwBCyAAIANqLAAAIAIQuxMEQEEAIQIFQQEhAiADQQFqIQMMAgsLCwNAIAEgAyIFQQFqIgNMBEBBAA8LIAAgA2osAAAgAhC7EyEEQQAhAiAEDQALIAVBAmoLEQAgACABIAIgAyAEIAUQvhML4wMHAX8BfwF/AX8BfwF/AX8jAEEQayIHJAACQCACQQZHDQAgAygCBCIJEO8VQQRHDQAgCSgAAEH0yrWDB0YhBgsCQCACQQVGIAZyRQRAQQAhBiAFQd8/QQAQZzYCACAHQQE2AggMAQsgA0EUQRAgBhtqKAIAIQggA0EMQQQgBhtqKAIAIgsQ7xUhCSADQRBBDCAGG2ooAgAiDBDvFSEGQQAhAyAHQQA2AgwgBkEBaiECIAdBDGogCEF/ENARIQYCQCAHKAIMIggEQCAHIAg2AggMAQsgBhDdEUEAIQgCfyAGQeSGARBsRQRAQQEhCkEADAELQQEhCkEBIAZBtyoQbEUNABpBAiAGQZypARBsRQ0AGiAHIAY2AgAgBUHR6gEgBxBnNgIAQQEhCEEAIQpBAAshAyAGEEAgByAINgIIIApFDQAgByAAIANBAnRBhNUGaigCABCsAzYCCAsgB0EIaiACIAlqQSVqrBChESIGRQRAQQAhBgwBCyAGIAM2AhwgBiABNgIYIAYgADYCFCAGIAZBJGoiAzYCDCAGIAIgA2oiBTYCECADIAwgAhDlFBogBSALIAlBAWoQ5RQaIAYoAgwQ3REgBigCEBDdEQsgBCAGNgIAIAcoAgghBiAHQRBqJAAgBgsRACAAIAEgAiADIAQgBRC+Ewv/AgcBfwF/AX8BfwF/AXwBfyABKAIAIgNBACADQQBKGyEIQX8hBEF/IQVBfyEGA0AgAiAIRkUEQAJAIAEoAgQgAkEMbGoiAy0ABUUNACADKAIADQAgAiACIAUgAy0ABCIDQSBGGyADQQRGGyEFIAIgAiAGIANBCEYbIANBEEYbIQYgAiAEIANBAkYbIQQLIAJBAWohAgwBCwtBACECAkAgBEEATgRAQQEhAiABKAIQIARBA3RqQQE2AgAgAUKAgICAgIDArMAANwMoDAELIAFCgICAgICQoZfBADcDKAJ/IAVBAEgEQEQAAAAAgIQeQSEHQQEMAQsgASgCECAFQQN0akEBNgIAIAFCgICAgICQoY/BADcDKEECIQJEAAAAAICEDkEhB0ECCyEDIAZBAEgNACABKAIQIAZBA3RqIAM2AgAgASAHOQMoIAJBBHIhAgsCQCABKAIIQQFHDQAgASgCDCIDKAIADQAgAy0ABA0AIAFBATYCIAsgASACNgIUQQALCAAgABBAQQALCAAgABBAQQAL9AMFAX8BfwF/AX8BfiMAQTBrIgIkACACQQA2AiwgAkEANgIoAn8gACgCIARAIAIgACkCDEIgiTcDICAAQePTACACQSBqEGc2AghBAQwBCyAAKAIQIQMgAiAAKAIMIgQ2AhwgAiAENgIYIAIgAzYCFCACIAQ2AhACQCACQSxqQdiJAyACQRBqEKARIgMEQCACIAAoAhQgA0F/IAJBKGpBABCIASIENgIsDAELIAIoAiwhBAsgAxBAIARBAUYEQCACQQA2AixBACEECyAAQQE2AiACf0EAIgMgAigCKCIFRQ0AGkEAIAUQiQFB5ABHDQAaIAIoAihBABCKASEGQQAgACgCGCAGEJgTIgVFDQAaIAUoAgALIQMgAEEANgIgAkACQCAEDQAgA0UEQCACKAIoEI8BIQQgAkEANgIoIAIgBDYCLCAEDQEgAiAAKQIMQiCJNwMAIABBqtYAIAIQZzYCCCACQQE2AiwMAQsgAiADELkRIgA2AiwgAA0AIAJBLGogAygCDCgCDEEEdEHYAGqtEKERIgBFDQAgACADNgIIIAIoAighBCAAIABB2ABqIgU2AiQgACAENgIEIAAgBSADKAIMKAIMQQN0ajYCKAwBCyACKAIoEI8BGkEAIQALIAEgADYCACACKAIsCyEAIAJBMGokACAACx4AIAAQxRMgAEE4ahDoESAAKAIEEI8BGiAAEEBBAAtCAQF/IABCADcDMCAAKAIQEPERIAAoAhQiAQRAIAEQtBELIABCADcDECAAKAIcEEAgAEEANgIMIABC/////w83AxgL6gIFAX8BfwF/AX8BfyAAKAIAKAIcIQkgABDFEyABQQFxBEAgBCgCACEHQQEhBQsgAUECcQR/IAQgBUECdGooAgAhBiAFQQFqBSAFCyEIQQAhBSABQQRxBEAgBCAIQQJ0aigCACEFCwJAIAcEQEGAASEBIAcQXyEEIAcQ/gEhBwwBCwJ/IAZFBEBBACEEQQAMAQsgBhBfIQQgBhD+AQshB0EIIQEgBUUNACAFEF8hBiAAIAUQ/gEiBTYCGCAAIAVBAWoQPyIFNgIcIAVFBEBBBw8LIAUgBkHpnwMgBhsgACgCGCIIQQFqEOUUGgsCQCAAKAIIKAIQIgUgBCAHIAFBACAAQRBqELMSIgENACAFKAJoIgEgASgCAEEBajYCACAAIAE2AhQCQCAJQQJGBEAgABDHEyIBDQJBACEBIAAoAgwNAiAAKAIIKAIMKAI4QQFGDQIMAQtBACEBIAAoAgwNAQsgABDIEyEBCyABC6UBBQF/AX8BfwF/AX8jAEEQayICJAAgAkEANgIMAkAgACgCECIDLQAQBEAgAEEBNgIMDAELIAMgAkEIahDKEyEDIAIoAgghAQJAIAAoAhgiBEEASA0AIAAoAhwgAyABIAQgASAESBsQ6hQiBUEATkEAIAUgASAETHIbDQAgAEEBNgIMCyACQQxqIABBOGogASADEK0SIAIoAgwhAQsgAkEQaiQAIAELlQgLAX8BfwF/AX8BfwF/AX8BfwF/AX4BfiMAQSBrIgQkACAAKAIAIQcgACgCCCIBKAIMIgUoAgwhBiAEIAEoAhAoAmggACgCFEciAkECdCIDNgIcQQQhAQJAIAINACAAIAApAzBCAXw3AzACQAJAAkACQAJAAkACQCAHKAIcDgMBAgACCyAAQdAAaiEHIABByABqIQMgACgCECECIAUoAjhBAUYhBgNAIAZFBEAgAigCCCACKAIMIAcgAxCqEkUNBwsgAEEANgJQIABCADcDSCAAKAIQEMkTIgFFBEAgABDHEyEBIAYNCCAAKAIMDQggAUUNAQsLIABBATYCDAwGCyAGIAAoAiAiAUEBaiICIAIgBkgbIQUDQCABQQFqIgEgBkgiAkUEQCAAIAU2AiAMAgsgACgCKCABQQN0aikDAFANAAsgACABNgIgIAINAQsgACgCECIBLQAQRQ0BIABBATYCDAsgAyEBDAELIAEgBEEYahDKEyEDIAQoAhghAQJAIAAoAhgiAkEASA0AIAAoAhwgAyABIAIgASACSBsQ6hQiBUEATkEAIAUgASACTHIbDQAgAEEBNgIMDAILIARBHGogAEE4aiABIAMQrRIgACgCJEEAIAZBA3QiARDnFBogACgCKEEAIAEQ5xQaIABBADYCICAEKAIcIgENACAHKAIcIQMgBqwhCgNAAkAgACgCCCgCDCgCOCEJIARCADcDECAEQQA2AgwgACgCECIIKAIMIQEgCCgCCCECAkACQAJAAkAgAw4CAQADCyAJDQEDQCACIAEgBEEMaiAEQRBqEKoSDQIgACgCJCIDIAMpAwBCAXw3AwAMAAsAC0F/IQUCQAJAIAkOAwACAQILA0AgAiABIARBDGogBEEQahCqEg0DIAQoAhQiAyAFRwRAIAMgBk4NBSAAKAIoIANBA3RqIgUgBSkDAEIBfDcDACADIQULIAAoAiQgA0EDdGoiAyADKQMAQgF8NwMADAALAAsDQCACIAEgBEEMaiAEQRBqEKoSDQIgBCkDECILIApZDQMgACgCKCALp0EDdGoiAyADKQMAQgF8NwMADAALAAsgACgCKCIBIAEpAwBCAXw3AwALIAgQyRMiASAHKAIcIgNBAkZyDQIgACgCECIFIARBGGoQyhMhCEEAIQEgBCgCGCICIAAoAjxHDQIgAkEASgRAIAggACgCOCACEOoUDQMLIAUtABBFDQEMAgsLQYsCIQELIAENAUEAIQEgACgCDA0BIAcoAhwNASAAKAIgIgEgBiABIAZKGyECA0ACQCABIAJHBEAgACgCKCABQQN0aikDAFANASABIQILQYsCQQAgAiAGRhshAQwDCyAAIAFBAWoiATYCIAwACwALQQAhAQsgBEEgaiQAIAELdgMBfwF/AX8gACgCHCIBIABBAEIAEJISAkAgASgCLA0AIAAgACgCSC8BBEHoAGxqIgEiAkHcAGooAgAiA0UNACABKAKYAS0AAEEwRg0AIAMQQCACQQA2AlwgAEEBOgAQCyAAKAIcIgAoAiwhASAAQQA2AiwgAQszAQF/IAAgACgCSC8BBEHoAGxqIgIoApgBIQAgASACKAKcAUEBazYC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BCAFRgRAQYsCDwUgBSgCACEFDAILAAsLIARFDQAgACAEKAIAEOoTGiACBEAgAiACKAIQQQFqNgIQCyAEIAI2AgALIAAgASACKQMIQbUBQbYBIAMbQQFqERwACy0AIAAoAlhBASABENICGiAAKAJYQQIgAhDSAhogACgCWBCJARogACgCWBCLAQstACAAKAJkQQEgARDSAhogACgCZEECIAIQ0gIaIAAoAmQQiQEaIAAoAmQQiwELywEEAX8BfwF/AX8jAEHgAGsiAyQAAkAgASgCACIFRQRADAELIAEoAhgiAi0AAyEEIAItAAIhAiAAIAFBACADQTBqEM4TQQEgBCACQQh0ciICIAJBAU0bIQRBASECA0AgAiAERkUEQCAAIAEgAiADEM4TIAAgA0EwaiADEIkUIAJBAWohAgwBCwsgAyAENgIAIAMgASkDCDcDMCAAIAEgAxCOFCICDQAgACAFIANBMGogAygCABCPFCAAIAUQlBQhAgsgA0HgAGokACACC2IDAX8BfwF/IABBA0EAELcDGiAAQQRBABC3AxoCQCAAQZntAhCsAyIHDQBCEBBJIgZFBEBBByEHDAELIAZCADcCACAGIAA2AgxBACEHIAZBADYCCCAGIQgLIAQgCDYCACAHC9kCBgF/AX8BfwF/AX8BfyABKAIAIgZBACAGQQBKGyEHAkADQCADIAdGDQECQAJAIAEoAgQiBSADQQxsaiICKAIAQQJHDQAgAi0ABEECRw0AIAUgA0EMbGotAAUNAUETDwsgA0EBaiEDDAELCyABKAIQIANBA3RqIgJBAToABCACQQE2AgBBAiEECyABQoCAgICAkKGXwQA3AyhBACECA0ACQCACIAdHBEAgASgCBCACQQxsaiIFLQAFRQ0BIAUoAgBBAEoNASAFLQAEQQJHDQEgAUEBNgI4IAFCATcDMCABQoCAgICAgID4PzcDKCABKAIQIAJBA3RqIgJBAToABCACQQJBASADIAZIGzYCACAEQQFyIQQLIAEgBDYCFCABKAIIQQBMBEBBAA8LAkAgASgCDCICKAIAQQBKDQAgAi0ABA0AIAFBATYCIAtBAA8LIAJBAWohAgwACwALCAAgABBAQQALPQEBf0IcEEkiAkUEQEEHDwsgAkIANwIIIAJBfzYCBCACIAA2AgAgAkEANgIYIAJCADcCECABIAI2AgBBAAsZAQF/IAAoAhAiAQRAIAEQ/wYLIAAQQEEAC/QBAgF/AX8gACgCACgCDCEFIABCATcCBAJAAkAgAUECcQRAIAAgBSAEKAIAEF8QhwEiBjYCFCAGQQBODQEMAgsgAEEANgIUCyAFKAIQIAZBBHRqKAIEIgVFDQAgACAFKAIEIgUoAgA2AgwgACAFKAIkNgIYIAAgBSgCMDYCCCABQQFxBEAgACAEIAFBAXRBfHFqKAIAEFynIgE2AgQCQCABQQBKBEAgACgCCCABTg0BCyAAQQE2AgRBACEBCyAAIAE2AggLIABBEGohASAAKAIQIgUEQCAFEP8GCyAAKAIMIgBBASABQQAgACgC3AERBQAPC0EACxEAIAAgACgCBEEBajYCBEEACw0AIAAoAgQgACgCCEoLzwEDAX8BfwF/IwBBEGsiAyQAAkACQAJAAkAgAg4CAAECCyABIAAoAgQQngJBACECDAILQQAhAiADQQA2AgwgACgCBCIEQezxBSgCACAAKAIYIgVtQQFqRgRAIAEgBRCtAgwCCyAAKAIMIgIgBCADQQxqQQAgAigC3AERBQAiAkUEQCABIAMoAgwoAgQgACgCGEF/EJECCyADKAIMEI4BDAELQQAhAiABIAEoAgAoAhQoAhAgACgCFEEEdGooAgBBf0EAEKcCCyADQRBqJAAgAgsOACABIAA0AgQ3AwBBAAu+AwYBfwF/AX8BfwF/AX4jAEEQayIEJAAgBEEANgIMAkACQCAAKAIMLQAjQRBxBEBB6CYhAQwBCyABQQFGBEBBj5cBIQEMAQtBACEBIAIoAgAQXCEJQqrVqtWq1arVqn8gAigCADMBEIinQQFxBEBBgTIhAQwBCyAJpyIFIAIoAgQQXKdHBEBBgTIhAQwBCyACKAIQEF8iAUUEQEHHwwEhAQwBCyAAKAIMIgYgARCHASIHQQBIBEBBx8MBIQEMAQtBlPcAIQEgBUUNACAGKAIQIAdBBHRqKAIEIgZFDQBBACEBIAUgBigCBCIHKAIwSwRAQZT3ACEBDAELQoGAhICAgMAAIAIoAgwiCDMBEIhCAYNQBEBBrpYBIQEMAQsgBygCJCEBQQAhByAIEP4BIAFHBEBBrpYBIQEMAQsCQCAGKAIEKAIAIgAgBSAEQQxqQQAgACgC3AERBQAiAA0AIAIoAgwQ+gEiAgRAIAQoAgwQwgEiAA0BIAQoAgwoAgQgAiABEOUUGgtBACEACyAEKAIMEI4BDAELIAAoAggQQCAEIAE2AgAgAEGz7gAgBBBnNgIIQQEhAAsgBEEQaiQAIAALRwIBfwF/IAAoAgwhAUEAIQADQCABKAIUIABKBEAgASgCECAAQQR0aigCBCICBEAgAkEBQQAQuwEaCyAAQQFqIQAMAQsLQQALvwEDAX8BfwF/IwBBEGsiBiQAAkACQCACQQRIDQAgBiADKAIMIgI2AgggBiACEFo2AgwgACAGQQhqEJ8LIghBAE4NACAGIAMoAgw2AgAgBUHg5wAgBhBnNgIAQQEhAgwBCyAAQQNBABC3AxoCQCAAQbCsBRCsAyICDQBCFBBJIgNFBEBBByECDAELIANCADcCACADIAg2AhAgAyAANgIMQQAhAiADQQA2AgggAyEHCyAEIAc2AgALIAZBEGokACACC48DBgF/AX8BfwF/AX8BfyABKAIAIgNBACADQQBKGyEHQX8hBEF/IQVBfyEGA0AgAiAHRwRAAkAgASgCBCACQQxsaiIDLQAEQQJHDQAgAy0ABUUEQEETDwsCQAJAAkAgAygCACIDQQprDgIBAgALIAMNAiACIQUMAgsgAiEEDAELIAIhBgsgAkEBaiECDAELC0EAIQIgBEEATgRAIAEoAhAgBEEDdGoiA0EBOgAEIANBATYCACABIAEoAhRBAXI2AhRBASECCyAFQQBOBEAgASgCECAFQQN0aiACQQFqIgI2AgAgASABKAIUQQJyNgIUCyAGQQBOBEAgASgCECAGQQN0aiACQQFqNgIAIAEgASgCFEEEcjYCFAsgAUKAgICAgICA+D83AygCQAJAAkACQCABKAIIQQFrDgIAAQMLIAEoAgwiAigCAA0CIAItAARFDQEMAgsgASgCDCICKAIADQEgAi0ABA0BIAIoAghBAUcNASACLQAMDQELIAFBATYCICABIAEoAhRBCHI2AhQLQQALCAAgABBAQQALNgEBf0LQChBJIgJFBEBBBw8LIAJBAEHQChDnFCICIAA2AgAgAiAAKAIQNgIMIAEgAjYCAEEACxYAIAAQphQgACgCBBCPARogABBAQQALagMBfwF/AX8DQCABQSBGRQRAIAAgAUEobGoiAkEQahCrFCACIgNBFGoiAigCABBAIANBADYCFCABQQFqIQEMAQsL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IAAtAAlFBEAgBiAHKAIcNgIAIABBs+4AIAYQZyIBNgKcCkEAQQcgARshAyAqKAIkIQELIAFBACABQQBKGyEEIAciK0EsaiEFQQAhAQNAIAEgBEZFBEAgKygCLCABQRhsaigCACACaiECIAFBAWohAQwBCwsgACAAKQO4CiACrHw3A7gKIAAtAAkNAQsLIAZBQGskACADC6UBAwF/AX8BfyMAQRBrIgMkACAAKAIEIgQoAiQhBSADQQA2AgwCQCACKAIERQRAIAIgBUGAAmoQPyIENgIEIARFBEBBByEADAILIAQgBWpBAEGAAhDnFBogACgCBCEECyAEKAIAIgAgASADQQxqQQAgACgC3AERBQAiAA0AIAIoAgQgAygCDCgCBCAFEOUUGiADKAIMEI4BQQAhAAsgA0EQaiQAIAALygEHAX8BfwF/AX8BfwF/AX4jAEEQayIBJAAgACgCACICKAIMKAIQIAIoAhBBBHRqKAIEIgUoAgQiAygCACgCQCECIAEgACgClAoiBK03AwACQAJAIAIoAgAiBgRAIAJBqIgOIAEgBigCKBECAEUNASAAKAKUCiEEIAUoAgQhAwsgACAAKQPICiADNAIkfCIHNwPICiAAIAcgBEEBa61+NwPACgwBCyAAIAEpAwA3A8AKIAAgACkDyAogASkDCHw3A8gKCyABQRBqJAALJQEBfyAAKAIEIQEgABCsFCAAKAIMEEAgAEEAQSgQ5xQgATYCBAtMAgF/AX8gACgCHARAA0AgACgCHCECIAEgACgCFE5FBEAgAiABQRhsaigCDBBAIAFBAWohAQwBCwsgAhBACyAAQQA2AhwgAEEANgIUCwcAIAAtAAgLnwIAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4LAAECAwQFBgcICQoLCyABIAAoApgKQX9BfxCnAgwLCyAALQAJDQogASAAKAKcCkF/QX8QpwIMCgsgAC0ACQRAIAEgADQCpAoQoAIMCgsgASAANQKUChCgAgwJCyAALQAJDQggASAAKAKgCkF/QQAQpwIMCAsgASAANAKoChCgAgwHCyABIAApA7gKEKACDAYLIAEgACkDsAoQoAIMBQsgASAANAKsChCgAgwECyAALQAJDQMgASAAKQPAChCgAgwDCyABIAApA8gKEKACDAILIAEgASgCACgCFCgCECAA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nhYgAEkEQCAAECFFDQELQYDeBiAANgIAIAEPCxDsFEEwNgIAQX8LuwoIAX4BfwF/AX4BfwF+AX8BfiMAQfAAayIHJAAgBEL///////////8AgyEIAkACQCABUCIGIAJC////////////AIMiBUKAgICAgIDA//8AfUKAgICAgIDAgIB/VCAFUBtFBEAgA0IAUiAIQoCAgICAgMD//wB9IgpCgICAgICAwICAf1YgCkKAgICAgIDAgIB/URsNAQsgBiAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgCEKAgICAgIDA//8AVCAIQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASAFQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiBhshBEIAIAEgBhshAwwCCyADIAhCgICAgICAwP//AIWEUA0BIAEgBYRQBEAgAyAIhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAIhFBFDQAgASEDIAIhBAwBCyADIAEgASADVCAFIAhUIAUgCFEbIgkbIQggBCACIAkbIgpC////////P4MhBSACIAQgCRsiAkIwiKdB//8BcSELIApCMIinQf//AXEiBkUEQCAHQeAAaiAIIAUgCCAFIAVQIgYbeSAGQQZ0rXynIgZBD2sQoRZBECAGayEGIAcpA2AhCCAHKQNoIQULIAEgAyAJGyEDIAJC////////P4MhBCALRQRAIAdB0ABqIAMgBCADIAQgBFAiCRt5IAlBBnStfKciCUEPaxChFkEQIAlrIQsgBykDWCEEIAcpA1AhAwsgBEIDhiADQj2IhEKAgICAgICABIQhASAFQgOGIAhCPYiEIQQgA0IDhiEFIAIgCoUhAwJAIAYgC0YNACAGIAtrIglB/wBLBEBCACEBQgEhBQwBCyAHQUBrIAUgAUGAASAJaxChFiAHQTBqIAUgASAJEKoWIAcpAzAgBykDQCAHKQNIhEIAUq2EIQUgBykDOCEBCyAEQoCAgICAgIAEhCEMIAhCA4YhCAJAIANCAFMEQEIAIQNCACEEIAUgCIUgASAMhYRQDQIgCCAFfSECIAwgAX0gBSAIVq19IgRC/////////wNWDQEgB0EgaiACIAQgAiAEIARQIgkbeSAJQQZ0rXynQQxrIgkQoRYgBiAJayEGIAcpAyghBCAHKQMgIQIMAQsgBSAIfCICIAVUrSABIAx8fCIEQoCAgICAgIAIg1ANACAFQgGDIARCP4YgAkIBiISEIQIgBkEBaiEGIARCAYghBAsgCkKAgICAgICAgIB/gyEFIAZB//8BTgRAIAVCgICAgICAwP//AIQhBEIAIQMMAQtBACEJAkAgBkEASgRAIAYhCQwBCyAHQRBqIAIgBCAGQf8AahChFiAHIAIgBEEBIAZrEKoWIAcpAwAgBykDECAHKQMYhEIAUq2EIQIgBykDCCEECyAEQj2GIAJCA4iEIQMgBEIDiEL///////8/gyAJrUIwhoQgBYQhBCACp0EHcSEGAkACQAJAAkACQBCoFg4DAAECAwsgBCADIAZBBEutfCIFIANUrXwhBCAGQQRHBEAgBSEDDAMLIAQgBUIBgyIBIAV8IgMgAVStfCEEDAMLIAQgAyAGQQBHIAVCAFJxrXwiBSADVK18IQQgBSEDDAELIAQgAyAFUCAGQQBHca18IgUgA1StfCEEIAUhAwsgBkUNAQsQqRYaCyAAIAM3AwAgACAENwMIIAdB8ABqJAALUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgL3QEDAX8BfgF+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC9UBAwF/AX4BfkF/IQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQAgACAChCAFIAaEhFAEQEEADwsgASADg0IAWQRAIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPCyAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLgAIFAX4BfwF+AX4BfyMAQRBrIgMkAAJ+IAG9IgRC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQUgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCAEQjyGIQUgBEIEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgAyACQgAgBKdnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahChFiADKQMAIQUgAykDCEKAgICAgIDAAIVBjPgAIAZrrUIwhoQLIQIgACAFNwMAIAAgAiAEQoCAgICAgICAgH+DhDcDCCADQRBqJAALcgMBfwF+AX8jAEEQayICJAACQCABQgBTDQAgAUIwiKdB//8BcSIEQf//AEkNAEJ/IQMgBEG/gAFrQUBJDQAgAiAAIAFC////////P4NCgICAgICAwACEQe+AASAEaxCqFiACKQMAIQMLIAJBEGokACADC4MBAwF+AX8BfyMAQRBrIgMkACAAAn4gAVAEQEIADAELIAMgASABQj+HIgKFIAJ9IgJCACACeaciBEExahChFiADKQMIQoCAgICAgMAAhUG+gAEgBGutQjCGfCABQoCAgICAgICAgH+DhCECIAMpAwALIgE3AwAgACACNwMIIANBEGokAAtnAwF/AX4BfyMAQRBrIgIkACAAAn4gAVAEQEIADAELIAIgAUIAIAF5pyIEQTFqEKEWIAIpAwhCgICAgICAwACFQb6AASAEa61CMIZ8IQMgAikDAAsiATcDACAAIAM3AwggAkEQaiQACwQAQQALBABBAAtQAQF+AkAgA0HAAHEEQCACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAvvChQBfwF+AX4BfwF+AX8BfgF+AX4BfgF/AX4BfgF+AX8BfgF+AX4BfgF+IwBB4ABrIgUkACAEQv///////z+DIQsgAiAEhUKAgICAgICAgIB/gyEGIAJC////////P4MiCUIgiCEOIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIPQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiB0KAgICAgIDA//8AVCAHQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQYMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBiADIQEMAgsgASAHQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhBkIAIQEMAwsgBkKAgICAgIDA//8AhCEGQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgB4QhAkIAIQEgAlAEQEKAgICAgIDg//8AIQYMAwsgBkKAgICAgIDA//8AhCEGDAILIAEgB4RQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAdC////////P1gEQCAFQdAAaiABIAkgASAJIAlQIgobeSAKQQZ0rXynIgpBD2sQoRZBECAKayEKIAUpA1giCUIgiCEOIAUpA1AhAQsgAkL///////8/Vg0AIAVBQGsgAyALIAMgCyALUCITG3kgE0EGdK18pyITQQ9rEKEWIAogE2tBEGohCiAFKQNIIQsgBSkDQCEDCyADQg+GIgdCgID+/w+DIgIgAUIgiCIEfiIQIAdCIIgiByABQv////8PgyIBfnwiDUIghiIRIAEgAn58IgwgEVStIAIgCUL/////D4MiCX4iFSAEIAd+fCIRIAtCD4YiEiADQjGIhEL/////D4MiAyABfnwiCyANIBBUrUIghiANQiCIhHwiECACIA5CgIAEhCINfiIWIAcgCX58Ig4gEkIgiEKAgICACIQiAiABfnwiEiADIAR+fCIUQiCGfCIXfCEBIAggD2ogCmpB//8AayEIAkAgAiAEfiIYIAcgDX58IgQgGFStIAQgAyAJfnwiByAEVK18IAIgDX58IAcgESAVVK0gCyARVK18fCIEIAdUrXwgAyANfiIDIAIgCX58IgIgA1StQiCGIAJCIIiEfCAEIAJCIIZ8IgIgBFStfCACIBIgFFatIA4gFlStIA4gElatfHxCIIYgFEIgiIR8IgQgAlStfCAEIAsgEFatIBAgF1atfHwiAiAEVK18IgRCgICAgICAwACDUEUEQCAIQQFqIQgMAQsgDEI/iCEDIARCAYYgAkI/iIQhBCACQgGGIAFCP4iEIQIgDEIBhiEMIAMgAUIBhoQhAQsgCEH//wFOBEAgBkKAgICAgIDA//8AhCEGQgAhAQwBCyAGAn4gCEEATARAQQEgCGsiD0H/AE0EQCAFQTBqIAwgASAIQf8AaiIIEKEWIAVBIGogAiAEIAgQoRYgBUEQaiAMIAEgDxCqFiAFIAIgBCAPEKoWIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQwgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAILQgAhAQwCCyAEQv///////z+DIAitQjCGhAsiBIQhBiAMUCABQgBZIAFCgICAgICAgICAf1EbRQRAIAYgAkIBfCIBIAJUrXwhBgwBCyAMIAFCgICAgICAgICAf4WEUEUEQCACIQEMAQsgBiACIAJCAYN8IgEgAlStfCEGCyAAIAE3AwAgACAGNwMIIAVB4ABqJAALdQEBfiAAIAEgBH4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCABIAJ+IANC/////w+DfCIBQiCIfDcDCCAAIAVC/////w+DIAFCIIaENwMAC9cDBAF+AX4BfwF/IwBBIGsiBCQAAkAgAUL///////////8AgyICQoCAgICAgMCAPH0gAkKAgICAgIDA/8MAfVQEQCABQgSGIABCPIiEIQIgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIAJCgYCAgICAgIDAAHwhAwwCCyACQoCAgICAgICAQH0hAyAAQoCAgICAgICACFINASADIAJCAYN8IQMMAQsgAFAgAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCEDDAELQoCAgICAgID4/wAhAyACQv///////7//wwBWDQBCACEDIAJCMIinIgVBkfcASQ0AIARBEGogACABQv///////z+DQoCAgICAgMAAhCICIAVBgfcAaxChFiAEIAAgAkGB+AAgBWsQqhYgBCkDCEIEhiAEKQMAIgJCPIiEIQMgBCkDECAEKQMYhEIAUq0gAkL//////////w+DhCICQoGAgICAgICACFoEQCADQgF8IQMMAQsgAkKAgICAgICAgAhSDQAgA0IBgyADfCEDCyAEQSBqJAAgAyABQoCAgICAgICAgH+DhL8LBAAjAAsGACAAJAALEgEBfyMAIABrQXBxIgEkACABCwuHogagAwBBgCALp4EDMy40Ni4wAHt9ACVzIiVzIjogeyJvZmZzZXQiOiVkLCJzaXplb2YiOiAlZCwic2lnbmF0dXJlIjoiJXMifQAlc3sAJXMiY2hhbmdlc2V0IjogewAlcyJzdG10U3RhdHVzIjogewAlcyJkYlN0YXR1cyI6IHsAJXMic3FsaXRlM1N0YXR1cyI6IHsAJXMibGltaXRzIjogewAlcyJhY2Nlc3MiOiB7ACVzImJsb2JGaW5hbGl6ZXJzIjogewAsIm1lbWJlcnMiOiB7ACVzImVuY29kaW5ncyI6IHsAJXMib3BlbkZsYWdzIjogewAlcyJ1ZGZGbGFncyI6IHsAJXMicHJlcGFyZUZsYWdzIjogewAlcyJzeW5jRmxhZ3MiOiB7ACVzImRhdGFUeXBlcyI6IHsAJXMicmVzdWx0Q29kZXMiOiB7ACVzImF1dGhvcml6ZXIiOiB7ACVzImlvQ2FwIjogewAlcyJzZXNzaW9uIjogewAlcyJ2ZXJzaW9uIjogewAlcyJmY250bCI6IHsAJXMiZmxvY2siOiB7ACVzImNvbmZpZyI6IHsAJXMiZGJDb25maWciOiB7ACVzInNlcmlhbGl6ZSI6IHsAJXMidHhuU3RhdGUiOiB7ACVzInRyYWNlIjogewAlcyJ2dGFiIjogewBwZ3N6ACV6JXMlegAlcy4legBJbiBSVHJlZSAlcy4lczoKJXoAanNvbl9wcmV0dHkAaW5kaWNhdGUgYWNjdW11bGF0b3IgZW1wdHkAaW5maW5pdHkAYWZmaW5pdHkAYnVzeQB0ZW1wX3N0b3JlX2RpcmVjdG9yeQBub3QgYSB3cml0YWJsZSBkaXJlY3RvcnkAb3BlbkRpcmVjdG9yeQBzaHJpbmtfbWVtb3J5AG91dCBvZiBtZW1vcnkAZmFpbGVkIHRvIGFsbG9jYXRlICV1IGJ5dGVzIG9mIG1lbW9yeQBIQVZJTkcgY2xhdXNlIG9uIGEgbm9uLWFnZ3JlZ2F0ZSBxdWVyeQB0ZW1wb3JhcnkAeERlc3Ryb3kAU0FWRVBPSU5UIGNoYW5nZXNldF9hcHBseQBST0xMQkFDSyBUTyBjaGFuZ2VzZXRfYXBwbHkAUkVMRUFTRSBjaGFuZ2VzZXRfYXBwbHkAcXVlcnlfb25seQByZWFkLW9ubHkAdW5saWtlbHkAZmtleQB0YWJsZSAiJXMiIGhhcyBtb3JlIHRoYW4gb25lIHByaW1hcnkga2V5AGZvcmVpZ24ga2V5AGpzb25fZ3JvdXBfYXJyYXkAanNvbmJfZ3JvdXBfYXJyYXkAanNvbl9hcnJheQBqc29uYl9hcnJheQBqdWxpYW5kYXkAbk9yZGVyQnkAYU9yZGVyQnkAZnRzNGF1eAB1bml4AHNxbGl0ZV9yZW5hbWVfcXVvdGVmaXgAcHJlZml4AExJS0Ugb3IgR0xPQiBwYXR0ZXJuIHRvbyBjb21wbGV4AHVuaGV4AGF1dG9tYXRpY19pbmRleABhdXRvLWluZGV4AG9ycGhhbiBpbmRleABhcmd2SW5kZXgAeEJlc3RJbmRleAB0YmwsIGlkeABwY3gAbWF4ACVzJS4zeCslLjZ4ACUwMngALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAAgRlJPTSAnJXEnLiclcSVzJyBBUyB4AENSRUFURSBUQUJMRSB4AHJ3AHBzb3cAaW1wbGllc19ub25udWxsX3JvdwBvdXRwdXQgZmluYWwgcm93AG91dHB1dCBvbmUgcm93AHBvdwBub3cAaW50ZWdlciBvdmVyZmxvdwBmdHM1OiBwYXJzZXIgc3RhY2sgb3ZlcmZsb3cAd2luZG93AHNoYWRvdwBuZXcAbm8gc3VjaCB2aWV3AGNhbm5vdCBtb2RpZnkgJXMgYmVjYXVzZSBpdCBpcyBhIHZpZXcAQ2Fubm90IGFkZCBhIGNvbHVtbiB0byBhIHZpZXcAY2Fubm90IFVQU0VSVCBhIHZpZXcAayBQUklNQVJZIEtFWSwgdgAgJWxsdQAlYyV1AEZhaWxlZCB0byByZWFkIHB0cm1hcCBrZXk9JXUAJS4qejoldQBPZmZzZXQgJXUgb3V0IG9mIHJhbmdlICV1Li4ldQBpbnZhbGlkIHBhZ2UgbnVtYmVyICV1AGZhaWxlZCB0byBnZXQgcGFnZSAldQAybmQgcmVmZXJlbmNlIHRvIHBhZ2UgJXUARnJhZ21lbnRhdGlvbiBvZiAldSBieXRlcyByZXBvcnRlZCBhcyAldSBvbiBwYWdlICV1AGZyZWVsaXN0IGxlYWYgY291bnQgdG9vIGJpZyBvbiBwYWdlICV1AE11bHRpcGxlIHVzZXMgZm9yIGJ5dGUgJXUgb2YgcGFnZSAldQAlcyBpcyAldSBidXQgc2hvdWxkIGJlICV1AFJlc3VsdCBvZiBTRUxFQ1QgJXUAdW5hYmxlIHRvIHVzZSBmdW5jdGlvbiAlcyBpbiB0aGUgcmVxdWVzdGVkIGNvbnRleHQAeE5leHQAcE5leHQAaW5jb21wbGV0ZSBpbnB1dABidXN5X3RpbWVvdXQAbG9jYWxob3N0AGVzdGltYXRlZENvc3QAY2Fubm90IGRyb3AgY29sdW1uICIlcyI6IG5vIG90aGVyIGNvbHVtbnMgZXhpc3QAcGVyc2lzdABmb3JlaWduX2tleV9saXN0AGluZGV4X2xpc3QAZnVuY3Rpb25fbGlzdABjb2xsYXRpb25fbGlzdABkYXRhYmFzZV9saXN0AG1vZHVsZV9saXN0AFBSQUdNQSB0YWJsZV9saXN0AHByYWdtYV9saXN0AHNldCBsaXN0AFZhbHVlTGlzdABzcWxpdGVfcmVuYW1lX3Rlc3QAZGVmZXIgSVBLIFJFUExBQ0UgdW50aWwgbGFzdABBdXhpbGlhcnkgcnRyZWUgY29sdW1ucyBtdXN0IGJlIGxhc3QAZmFzdABzcXJ0AEdST1VQIEJZIHNvcnQAYWJvcnQAIlwvYmZucnQAanNvbl9pbnNlcnQAanNvbmJfaW5zZXJ0AGNhbm5vdCBpbnNlcnQAcmVzdGFydABEaW1lbnNpb24gJWQgb2YgY2VsbCAlZCBvbiBub2RlICVsbGQgaXMgY29ycnVwdABmcmVlbGlzdF9jb3VudABtYXhfcGFnZV9jb3VudABQUkFHTUEgIiV3Ii5wYWdlX2NvdW50AHRyaWdnZXIgY291bnQAd2FsX2F1dG9jaGVja3BvaW50AHdhbF9jaGVja3BvaW50AHhTYXZlcG9pbnQAR3JvdXBieSByZXN1bHQgZ2VuZXJhdG9yIGVudHJ5IHBvaW50AGEgQ0hFQ0sgY29uc3RyYWludAAlc09OIENPTkZMSUNUIGNsYXVzZSBkb2VzIG5vdCBtYXRjaCBhbnkgUFJJTUFSWSBLRVkgb3IgVU5JUVVFIGNvbnN0cmFpbnQAbkNvbnN0cmFpbnQAYUNvbnN0cmFpbnQAX2NvbnRlbnQAJV9wYXJlbnQARGltZW5zaW9uICVkIG9mIGNlbGwgJWQgb24gbm9kZSAlbGxkIGlzIGNvcnJ1cHQgcmVsYXRpdmUgdG8gcGFyZW50AERJU1RJTkNUIGFnZ3JlZ2F0ZXMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFyZ3VtZW50AGNvbW1lbnQAQVBJIGNhbGxlZCB3aXRoIGZpbmFsaXplZCBwcmVwYXJlZCBzdGF0ZW1lbnQAQVBJIGNhbGxlZCB3aXRoIE5VTEwgcHJlcGFyZWQgc3RhdGVtZW50AGFyZ3VtZW50IHRvICVzKCkgaXMgbm90IGEgdmFsaWQgU1FMIHN0YXRlbWVudABkZWZhdWx0IHZhbHVlIG9mIGNvbHVtbiBbJXNdIGlzIG5vdCBjb25zdGFudABzcWxpdGVfc3RtdABJbml0IHN1YnF1ZXJ5IHJlc3VsdABJbml0IEVYSVNUUyByZXN1bHQAQ2Fubm90IGFkZCBhIGNvbHVtbiB3aXRoIG5vbi1jb25zdGFudCBkZWZhdWx0AGxhbm9pdABzdGF0X2luaXQAb21pdAB4Q29tbWl0AGFuYWx5c2lzX2xpbWl0AHNvZnRfaGVhcF9saW1pdABoYXJkX2hlYXBfbGltaXQAam91cm5hbF9zaXplX2xpbWl0AHJlY29yZCBMRUZUIEpPSU4gaGl0AE9OIGNsYXVzZSByZWZlcmVuY2VzIHRhYmxlcyB0byBpdHMgcmlnaHQAaGlnaGxpZ2h0AGhnaHQAc3FsaXRlX29mZnNldABpVGVybU9mZnNldAByZXNldABTQVZFUE9JTlQgY2hhbmdlc2V0AFJFTEVBU0UgY2hhbmdlc2V0AGpzb25fc2V0AGpzb25iX3NldAB0b28gbWFueSBjb2x1bW5zIGluIHJlc3VsdCBzZXQAJXIgT1JERVIgQlkgdGVybSBkb2VzIG5vdCBtYXRjaCBhbnkgY29sdW1uIGluIHRoZSByZXN1bHQgc2V0AHNuaXBwZXQAc3RhdF9nZXQAc3FsaXRlX2NvbXBpbGVvcHRpb25fZ2V0AHN0cmljdAB4RGlzY29ubmVjdAB4Q29ubmVjdABqc29uX2dyb3VwX29iamVjdABqc29uYl9ncm91cF9vYmplY3QAanNvbl9vYmplY3QAanNvbmJfb2JqZWN0AGpzb25fZXh0cmFjdABqc29uYl9leHRyYWN0AGxzdGF0AGZzdGF0AGRic3RhdAAlc19zdGF0AHRibCxpZHgsc3RhdAB0YmwsID8yLCBzdGF0AHVuc3VwcG9ydGVkIGZpbGUgZm9ybWF0AGdyb3VwX2NvbmNhdABkZWZlcl9mb3JlaWduX2tleXMAYWx3YXlzAGVzdGltYXRlZFJvd3MAcGFyYW1ldGVycyBhcmUgbm90IGFsbG93ZWQgaW4gdmlld3MAY29uY2F0X3dzAHN0YXR1cwBzeW5jaHJvbm91cwBpbmRleCAlcyBhbHJlYWR5IGV4aXN0cwBvdXRwdXQgZmlsZSBhbHJlYWR5IGV4aXN0cwAlcyAlVCBhbHJlYWR5IGV4aXN0cwB0cmlnZ2VyICVUIGFscmVhZHkgZXhpc3RzAGlnbm9yZV9jaGVja19jb25zdHJhaW50cwBDSEVDSyBjb25zdHJhaW50cwBleHByZXNzaW9ucyBwcm9oaWJpdGVkIGluIFBSSU1BUlkgS0VZIGFuZCBVTklRVUUgY29uc3RyYWludHMAanNvbl9vYmplY3QoKSByZXF1aXJlcyBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMAanNvbl8lcygpIG5lZWRzIGFuIG9kZCBudW1iZXIgb2YgYXJndW1lbnRzAHdyb25nIG51bWJlciBvZiB2dGFibGUgYXJndW1lbnRzACVzX3NlZ21lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IHVzZXItZnVuY3Rpb24gZHVlIHRvIGFjdGl2ZSBzdGF0ZW1lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IGNvbGxhdGlvbiBzZXF1ZW5jZSBkdWUgdG8gYWN0aXZlIHN0YXRlbWVudHMAb2Zmc2V0cwByZXZlcnNlX3Vub3JkZXJlZF9zZWxlY3RzAGlpc3Nzc3NzAGlzcwBzZXNzAHVuY29tcHJlc3MAY2Fubm90IG9wZW4gc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IHJlbGVhc2Ugc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IGNvbW1pdCB0cmFuc2FjdGlvbiAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGNhbm5vdCBWQUNVVU0gLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBvdXNuZXNzAHhSYW5kb21uZXNzAGZ1bG5lc3MAaXZlbmVzcwBhY2Nlc3MAeEFjY2VzcwBJZiBOVUxMLXNjYW4gMXN0IHBhc3MASWYgTlVMTC1zY2FuIDJuZCBwYXNzAHNlcGFyYXRvcnMAcGFyYW1ldGVycwByZWN1cnNpdmVfdHJpZ2dlcnMAdGhlIElOREVYRUQgQlkgY2xhdXNlIGlzIG5vdCBhbGxvd2VkIG9uIFVQREFURSBvciBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAdGhlIE5PVCBJTkRFWEVEIGNsYXVzZSBpcyBub3QgYWxsb3dlZCBvbiBVUERBVEUgb3IgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAHF1YWxpZmllZCB0YWJsZSBuYW1lcyBhcmUgbm90IGFsbG93ZWQgb24gSU5TRVJULCBVUERBVEUsIGFuZCBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAQ2hpbGQgcGFnZSBkZXB0aCBkaWZmZXJzAHRva2VuY2hhcnMAdW5hYmxlIHRvIGNsb3NlIGR1ZSB0byB1bmZpbmFsaXplZCBzdGF0ZW1lbnRzIG9yIHVuZmluaXNoZWQgYmFja3VwcwBhY29zAGNvbXBpbGVfb3B0aW9ucwBESVNUSU5DVCBpcyBub3Qgc3VwcG9ydGVkIGZvciB3aW5kb3cgZnVuY3Rpb25zAEZJTFRFUiBjbGF1c2UgbWF5IG9ubHkgYmUgdXNlZCB3aXRoIGFnZ3JlZ2F0ZSB3aW5kb3cgZnVuY3Rpb25zAG5vbi1kZXRlcm1pbmlzdGljIGZ1bmN0aW9ucwBpbmRleCBleHByZXNzaW9ucwBTRUxFQ1RzIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBvZiAlcyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcmVzdWx0IGNvbHVtbnMAdmlydHVhbCB0YWJsZXMgY2Fubm90IHVzZSBjb21wdXRlZCBjb2x1bW5zAGdlbmVyYXRlZCBjb2x1bW5zAHRhYmxlICVzIGhhcyAlZCB2YWx1ZXMgZm9yICVkIGNvbHVtbnMAcmFkaWFucwBhbGwgVkFMVUVTIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgdGVybXMAZW1wdHlfcmVzdWx0X2NhbGxiYWNrcwBpcwBmbGdzAGZsYWdzAGlkeEZsYWdzAGZpbGU6c2Vzc2lvbj92ZnM9a3Z2ZnMAZmlsZTpsb2NhbD92ZnM9a3Z2ZnMAbXVsdGlwbGUgY29udGVudD0uLi4gZGlyZWN0aXZlcwBtdWx0aXBsZSB0b2tlbml6ZT0uLi4gZGlyZWN0aXZlcwBtdWx0aXBsZSBjb250ZW50X3Jvd2lkPS4uLiBkaXJlY3RpdmVzACVkIGNvbHVtbnMgYXNzaWduZWQgJWQgdmFsdWVzAEpTT04gY2Fubm90IGhvbGQgQkxPQiB2YWx1ZXMAZmFpbGVkIG1lbW9yeSByZXNpemUgJXUgdG8gJXUgYnl0ZXMAcGFydGlhbCBpbmRleCBXSEVSRSBjbGF1c2VzAHNob3J0X2NvbHVtbl9uYW1lcwBmdWxsX2NvbHVtbl9uYW1lcwB1bmFibGUgdG8gb3BlbiBhIHRlbXBvcmFyeSBkYXRhYmFzZSBmaWxlIGZvciBzdG9yaW5nIHRlbXBvcmFyeSB0YWJsZXMAY2Fubm90IGNyZWF0ZSB0cmlnZ2VycyBvbiBzaGFkb3cgdGFibGVzAGNhbm5vdCBjcmVhdGUgdHJpZ2dlcnMgb24gdmlydHVhbCB0YWJsZXMAJXMgUkVUVVJOSU5HIGlzIG5vdCBhdmFpbGFibGUgb24gdmlydHVhbCB0YWJsZXMAY2Fubm90IGpvaW4gdXNpbmcgY29sdW1uICVzIC0gY29sdW1uIG5vdCBwcmVzZW50IGluIGJvdGggdGFibGVzAEFVVE9JTkNSRU1FTlQgbm90IGFsbG93ZWQgb24gV0lUSE9VVCBST1dJRCB0YWJsZXMAJXMgY2Fubm90IHVzZSB2YXJpYWJsZXMAdG9vIG1hbnkgU1FMIHZhcmlhYmxlcwBjYXRlZ29yaWVzAHN1YnF1ZXJpZXMAY2Fubm90IHVzZSB3aW5kb3cgZnVuY3Rpb25zIGluIHJlY3Vyc2l2ZSBxdWVyaWVzAGNvdW50X2NoYW5nZXMAdG90YWxfY2hhbmdlcwBkZWdyZWVzAFJFVFVSTklORyBtYXkgbm90IHVzZSAiVEFCTEUuKiIgd2lsZGNhcmRzAHBNZXRob2RzAHRocmVhZHMAeERldmljZUNoYXJhY3RlcmlzdGljcwByZW1vdmVfZGlhY3JpdGljcwBhYnMAJXolLipzAC4lLipzACwlLipzAENSRUFURSAlcyAlLipzAENSRUFURSVzIElOREVYICUuKnMAaW52YWxpZCB1cmkgYXV0aG9yaXR5OiAlLipzAHVua25vd24gc3BlY2lhbCBxdWVyeTogJS4qcwB1bmtub3duIHRhYmxlIG9wdGlvbjogJS4qcwAlLipzJXMALCVzJXMlcwBTQ0FOICVzJXMlcwBzcWxpdGVfYWx0ZXJ0YWJfJXMAU0NBTiAlZCBDT05TVEFOVCBST1clcwAlUSVzACBWSVJUVUFMIFRBQkxFIElOREVYICVkOiVzAHJbJWRdPSVzLiVzACVzOiAlcy4lcy4lcwBBbmFseXNpcyBmb3IgJXMuJXMAcmVjdXJzaXZlIGRlZmluaXRpb24gZm9yICVzLiVzAG1pc3NpbmcgZGF0YXR5cGUgZm9yICVzLiVzAGNhbm5vdCBzdG9yZSAlcyB2YWx1ZSBpbiAlcyBjb2x1bW4gJXMuJXMAbm9uLSVzIHZhbHVlIGluICVzLiVzAFRFWFQgdmFsdWUgaW4gJXMuJXMATlVMTCB2YWx1ZSBpbiAlcy4lcwBOVU1FUklDIHZhbHVlIGluICVzLiVzAG1hbGZvcm1lZCBpbnZlcnRlZCBpbmRleCBmb3IgRlRTJWQgdGFibGUgJXMuJXMAbWFsZm9ybWVkIGludmVydGVkIGluZGV4IGZvciBGVFM1IHRhYmxlICVzLiVzACVzOiAlcy4lcwBubyBzdWNoIHRhYmxlIGNvbHVtbjogJXMuJXMAQ2FsbDogJXMuJXMAbm8gc3VjaCBmdHM1IHRhYmxlOiAlcy4lcwBFbmQ6ICVzLiVzAFVOSVFVRSBjb25zdHJhaW50IGZhaWxlZDogJXMuJXMAREVMRVRFIEZST00gJVEuJXMALi4lcwAlLjE4cy0lcwBrdnZmcy0lcy0lcwBDUkVBVEUgVEFCTEUgJVEuJyVxXyVxJyglcyklcwAgVVNJTkcgSU5URUdFUiBQUklNQVJZIEtFWSAoJXMAcHJlcCBpbmRleCAlcwB1c2UgRFJPUCBWSUVXIHRvIGRlbGV0ZSB2aWV3ICVzAG1hdGNoIGFnYWluc3QgJXMAcm93IG5vdCBpbiBQUklNQVJZIEtFWSBvcmRlciBmb3IgJXMAaWxsZWdhbCBmaXJzdCBhcmd1bWVudCB0byAlcwBtaXN1c2Ugb2YgYWxpYXNlZCB3aW5kb3cgZnVuY3Rpb24gJXMAdG9vIG1hbnkgY29sdW1ucyBvbiAlcwBuZXh0IHNraXAtc2NhbiBvbiAlcwBiZWdpbiBza2lwLXNjYW4gb24gJXMAdG9vIG1hbnkgY29sdW1ucyBpbiAlcwAlcyBwcm9oaWJpdGVkIGluICVzAENIRUNLIGNvbnN0cmFpbnQgZmFpbGVkIGluICVzAG5vbi1kZXRlcm1pbmlzdGljIHVzZSBvZiAlcygpIGluICVzAHJlY292ZXJlZCAlZCBwYWdlcyBmcm9tICVzAG5leHQgcm93IG9mICVzAG1pc3VzZSBvZiBhbGlhc2VkIGFnZ3JlZ2F0ZSAlcwAlcyAlVCBjYW5ub3QgcmVmZXJlbmNlIG9iamVjdHMgaW4gZGF0YWJhc2UgJXMAY2Fubm90IGRldGFjaCBkYXRhYmFzZSAlcwBhIEpPSU4gY2xhdXNlIGlzIHJlcXVpcmVkIGJlZm9yZSAlcwBjYW5ub3Qgb3BlbiB2YWx1ZSBvZiB0eXBlICVzAGNhbm5vdCBmc3RhdCBkYiBmaWxlICVzAHJlY292ZXJlZCAlZCBmcmFtZXMgZnJvbSBXQUwgZmlsZSAlcwBzcWxpdGUzY2hhbmdlc2V0X2FwcGx5KCk6IHByaW1hcnkga2V5IG1pc21hdGNoIGZvciB0YWJsZSAlcwBQUklNQVJZIEtFWSBtaXNzaW5nIG9uIHRhYmxlICVzAHVzZSBEUk9QIFRBQkxFIHRvIGRlbGV0ZSB0YWJsZSAlcwBTRUxFQ1QgJXMgT1JERVIgQlkgcm93aWQgJXMAU0VMRUNUICVzIFdIRVJFIHJvd2lkIEJFVFdFRU4gJWxsZCBBTkQgJWxsZCBPUkRFUiBCWSByb3dpZCAlcwB0aGVyZSBpcyBhbHJlYWR5IGFuIGluZGV4IG5hbWVkICVzAHRhYmxlICVTIGhhcyBubyBjb2x1bW4gbmFtZWQgJXMAdGhlcmUgaXMgYWxyZWFkeSBhIHRhYmxlIG5hbWVkICVzAHN0YXRlbWVudCBhYm9ydHMgYXQgJWQ6IFslc10gJXMAQ09WRVJJTkcgSU5ERVggJXMAU0VMRUNUICVzAHVuc3VwcG9ydGVkIHVzZSBvZiBOVUxMUyAlcwBVU0UgVEVNUCBCLVRSRUUgRk9SICVzAC0tIFRSSUdHRVIgJXMAUklHSFQtSk9JTiAlcwA+PyBBTkQgJXMAOyAlcwAlejogJXMAcmVjdXJzaXZlIHJlZmVyZW5jZSBpbiBhIHN1YnF1ZXJ5OiAlcwB2dGFibGUgY29uc3RydWN0b3IgY2FsbGVkIHJlY3Vyc2l2ZWx5OiAlcwBubyBzdWNoIGluZGV4OiAlcwBubyBzdWNoIHdpbmRvdzogJXMAY2Fubm90IG92ZXJyaWRlICVzIG9mIHdpbmRvdzogJXMAY2Fubm90IG9wZW4gdmlldzogJXMAbm8gc3VjaCBzYXZlcG9pbnQ6ICVzAG5vIHN1Y2ggdmZzOiAlcwBtdWx0aXBsZSByZWN1cnNpdmUgcmVmZXJlbmNlczogJXMAZXJyb3IgaW4gJXMgJXMlcyVzOiAlcwBmdHM1OiBlcnJvciBjcmVhdGluZyBzaGFkb3cgdGFibGUgJXFfJXM6ICVzAHVuYWJsZSB0byB2YWxpZGF0ZSB0aGUgaW52ZXJ0ZWQgaW5kZXggZm9yIEZUUyVkIHRhYmxlICVzLiVzOiAlcwB1bmFibGUgdG8gdmFsaWRhdGUgdGhlIGludmVydGVkIGluZGV4IGZvciBGVFM1IHRhYmxlICVzLiVzOiAlcwBlcnJvciBpbiAlcyAlcyBhZnRlciAlczogJXMAdW5rbm93biB0b2tlbml6ZXI6ICVzAG5vIHN1Y2ggdG9rZW5pemVyOiAlcwBlcnJvciBwYXJzaW5nIHByZWZpeCBwYXJhbWV0ZXI6ICVzAHVucmVjb2duaXplZCBwYXJhbWV0ZXI6ICVzAHVucmVjb2duaXplZCBvcmRlcjogJXMAdW5yZWNvZ25pemVkIG1hdGNoaW5mbzogJXMAdW5yZWNvZ25pemVkIGNvbHVtbiBvcHRpb246ICVzAHBhcnNlIGVycm9yIGluIHJhbmsgZnVuY3Rpb246ICVzAG5vIHN1Y2ggZnVuY3Rpb246ICVzAG5vIHN1Y2ggY29sdW1uOiAlcwBmaWxlIHJlbmFtZWQgd2hpbGUgb3BlbjogJXMAZmlsZSB1bmxpbmtlZCB3aGlsZSBvcGVuOiAlcwBjYW5ub3QgbGltaXQgV0FMIHNpemU6ICVzAE1KIGRlbGV0ZTogJXMAdGFyZ2V0IG9iamVjdC9hbGlhcyBtYXkgbm90IGFwcGVhciBpbiBGUk9NIGNsYXVzZTogJXMAb2JqZWN0IG5hbWUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzZTogJXMAdW5rbm93biBkYXRhYmFzZTogJXMAdW5hYmxlIHRvIG9wZW4gZGF0YWJhc2U6ICVzAG5vIHN1Y2ggZGF0YWJhc2U6ICVzAHRoZXJlIGlzIGFscmVhZHkgYW5vdGhlciB0YWJsZSBvciBpbmRleCB3aXRoIHRoaXMgbmFtZTogJXMAZHVwbGljYXRlIGNvbHVtbiBuYW1lOiAlcwByZXNlcnZlZCBmdHM1IGNvbHVtbiBuYW1lOiAlcwBkdXBsaWNhdGUgV0lUSCB0YWJsZSBuYW1lOiAlcwByZXNlcnZlZCBmdHM1IHRhYmxlIG5hbWU6ICVzAG5vIHN1Y2ggbW9kdWxlOiAlcwBtdWx0aXBsZSBsaW5rcyB0byBmaWxlOiAlcwBjYW5ub3Qgb3BlbiB2aXJ0dWFsIHRhYmxlOiAlcwBzcWxpdGUzY2hhbmdlc2V0X2FwcGx5KCk6IG5vIHN1Y2ggdGFibGU6ICVzAG11bHRpcGxlIHJlZmVyZW5jZXMgdG8gcmVjdXJzaXZlIHRhYmxlOiAlcwBjYW5ub3QgVVBEQVRFIGEgc3Vic2V0IG9mIGNvbHVtbnMgb24gZnRzNSBjb250ZW50bGVzcy1kZWxldGUgdGFibGU6ICVzAGNhbm5vdCAlcyBjb250ZW50bGVzcyBmdHM1IHRhYmxlOiAlcwBubyBzdWNoICVzIG1vZGU6ICVzAE1KIGNvbGxpZGU6ICVzAG5vIHN1Y2ggY29sbGF0aW9uIHNlcXVlbmNlOiAlcwBjaXJjdWxhciByZWZlcmVuY2U6ICVzAGNhbm5vdCBvcGVuIHRhYmxlIHdpdGhvdXQgcm93aWQ6ICVzACVzIG1vZGUgbm90IGFsbG93ZWQ6ICVzAHZ0YWJsZSBjb25zdHJ1Y3RvciBmYWlsZWQ6ICVzAGF1dG9tYXRpYyBleHRlbnNpb24gbG9hZGluZyBmYWlsZWQ6ICVzAHZ0YWJsZSBjb25zdHJ1Y3RvciBkaWQgbm90IGRlY2xhcmUgc2NoZW1hOiAlcwBhYm9ydCBhdCAlZCBpbiBbJXNdOiAlcwAtLSAlcwAleiAtICVzAG9zX3VuaXguYzolZDogKCVkKSAlcyglcykgLSAlcwBTRUxFQ1Qgcm93aWQsIHJhbmsgRlJPTSAlUS4lUSBPUkRFUiBCWSAlcygiJXciJXMlcykgJXMAd3IAaW5zdHIAY3N0cgBzdWJzdHIAZnRzNV9hcGlfcHRyAE5VTEwtc2NhbiBwYXNzIGN0cgBpZHhTdHIAbmVlZFRvRnJlZUlkeFN0cgBleHByX2ltcGxpZXNfZXhwcgBiZWdpbiBJTiBleHByAGVuZCBJTiBleHByAGludmFsaWQgYXJndW1lbnRzIHRvIGZ0czRhdXggY29uc3RydWN0b3IAZXJyb3IgaW4gdG9rZW5pemVyIGNvbnN0cnVjdG9yAG1pc3NpbmcgJXMgcGFyYW1ldGVyIGluIGZ0czQgY29uc3RydWN0b3IAUkhTIG9mIElOIG9wZXJhdG9yAHRoZSAiLiIgb3BlcmF0b3IAZW5kIGdyb3VwYnkgcmVzdWx0IGdlbmVyYXRvcgByZXNldCBhY2N1bXVsYXRvcgBpbmRpY2F0ZSBkYXRhIGluIGFjY3VtdWxhdG9yAGZ0czNjdXJzb3IAbmVhciAiJVQiOiBzeW50YXggZXJyb3IAdW5rbm93biBlcnJvcgBub3QgYW4gZXJyb3IAU1FMIGxvZ2ljIGVycm9yAGRpc2sgSS9PIGVycm9yAHhHZXRMYXN0RXJyb3IAeERsRXJyb3IAZmxvb3IAcm1kaXIAbWtkaXIAc2VnZGlyAGZ0czNfdG9rZW5pemVyAHVua25vd24gdG9rZW5pemVyAHBvd2VyAGxvd2VyAHNxbGl0ZV90ZW1wX21hc3RlcgBzcWxpdGVfbWFzdGVyAHBvcnRlcgBMSUtFIGxvb3AgY291bnRlcgBMSU1JVCBjb3VudGVyAFplcm8gT0ZGU0VUIGNvdW50ZXIAc3RtdC1wb2ludGVyAEFQSSBjYWxsIHdpdGggJXMgZGF0YWJhc2UgY29ubmVjdGlvbiBwb2ludGVyAHhGaWx0ZXIARVNDQVBFIGV4cHJlc3Npb24gbXVzdCBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIAdXBwZXIAeFNobUJhcnJpZXIAY2Fubm90IHVzZSBSRVRVUk5JTkcgaW4gYSB0cmlnZ2VyAHNlY29uZCBhcmd1bWVudCB0byBudGhfdmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAYXJndW1lbnQgb2YgbnRpbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAZnJhbWUgc3RhcnRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBmcmFtZSBlbmRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBSb3dpZCAlbGxkIG91dCBvZiBvcmRlcgBmcmFtZSBzdGFydGluZyBvZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIAZnJhbWUgZW5kaW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcgBiYWQgcGFnZSBudW1iZXIAYWRkcgBjaGFyAHllYXIAc2VxACVxAHJlZ2V4cABTQVZFUE9JTlQgcmVwbGFjZV9vcABSRUxFQVNFIHJlcGxhY2Vfb3AAL3Vzci90bXAAL3Zhci90bXAAdGVtcABjdXJyZW50X3RpbWVzdGFtcAB4U2xlZXAAbXVubWFwAHhTaG1Vbm1hcABtbWFwAG1yZW1hcAB4U2htTWFwAHNxbGl0ZV9yZXR1cm5pbmdfJXAAdnRhYjolcABzc2Vuc3VvAGlsc3VvAGF1dG8AaW50bwBpbmNyZW1lbnRhbF92YWN1dW0gZW5hYmxlZCB3aXRoIGEgbWF4IHJvb3RwYWdlIG9mIHplcm8Ac2Vxbm8ASU5TRVJUIElOVE8iJXciLiIld19yb3dpZCIocm93aWQsbm9kZW5vKVZBTFVFUyg/MSw/MilPTiBDT05GTElDVChyb3dpZClETyBVUERBVEUgU0VUIG5vZGVubz1leGNsdWRlZC5ub2Rlbm8AQ1JFQVRFIFRBQkxFICIldyIuIiV3X3Jvd2lkIihyb3dpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLG5vZGVubwBoZWxsbwBpbmRleF94aW5mbwB0YWJsZV94aW5mbwBtYXRjaGluZm8AaW5kZXhfaW5mbwB0YWJsZV9pbmZvAHhSb2xsYmFja1RvAEwqIE4qIENvAHVua25vd24AZmNob3duAGpzb24Abm8gcXVlcnkgc29sdXRpb24AaW5kZXggY29ycnVwdGlvbgBkYXRhYmFzZSBjb3JydXB0aW9uAGZyZWUgc3BhY2UgY29ycnVwdGlvbgBjYWxsIGZsdXNoX3BhcnRpdGlvbgBqc29uX2Vycm9yX3Bvc2l0aW9uAHVua25vd24gY29sdW1uICIlcyIgaW4gZm9yZWlnbiBrZXkgZGVmaW5pdGlvbgAlcy54QmVzdEluZGV4IG1hbGZ1bmN0aW9uAGF1dGhvcml6ZXIgbWFsZnVuY3Rpb24AJSNUKCkgbWF5IG5vdCBiZSB1c2VkIGFzIGEgd2luZG93IGZ1bmN0aW9uACclcycgaXMgbm90IGEgZnVuY3Rpb24AeEZpbmRGdW5jdGlvbgBjYW5ub3Qgc3RhcnQgYSB0cmFuc2FjdGlvbiB3aXRoaW4gYSB0cmFuc2FjdGlvbgBjYW5ub3QgY2hhbmdlICVzIHdhbCBtb2RlIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AdGVtcG9yYXJ5IHN0b3JhZ2UgY2Fubm90IGJlIGNoYW5nZWQgZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgBjYW5ub3QgVkFDVVVNIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AU2FmZXR5IGxldmVsIG1heSBub3QgYmUgY2hhbmdlZCBpbnNpZGUgYSB0cmFuc2FjdGlvbgBpemF0aW9uAHVua25vd24gb3BlcmF0aW9uAHVuc3VwcG9ydGVkIGZyYW1lIHNwZWNpZmljYXRpb24Ac2Vzc2lvbgBSQU5HRSB3aXRoIG9mZnNldCBQUkVDRURJTkcvRk9MTE9XSU5HIHJlcXVpcmVzIG9uZSBPUkRFUiBCWSBleHByZXNzaW9uAHRvbyBtYW55IGxldmVscyBvZiB0cmlnZ2VyIHJlY3Vyc2lvbgB1c2VyX3ZlcnNpb24Ac3FsaXRlX3ZlcnNpb24AUFJBR01BICVRLmRhdGFfdmVyc2lvbgBzY2hlbWFfdmVyc2lvbgBpVmVyc2lvbgBzcWxpdGVfZHJvcF9jb2x1bW4Ac3FsaXRlX3JlbmFtZV9jb2x1bW4AYWZ0ZXIgZHJvcCBjb2x1bW4Abm8gc3VjaCBjb2x1bW4AbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub24tZ2VuZXJhdGVkIGNvbHVtbgBjYW5ub3QgdXNlIERFRkFVTFQgb24gYSBnZW5lcmF0ZWQgY29sdW1uAGFkZCBjb2x1bW4AQ2Fubm90IGFkZCBhIFBSSU1BUlkgS0VZIGNvbHVtbgBDYW5ub3QgYWRkIGEgVU5JUVVFIGNvbHVtbgBjYW5ub3QgYWRkIGEgU1RPUkVEIGNvbHVtbgB4Q29sdW1uAGlDb2x1bW4AbG4AYnVpbHRpbgBhc2luAGF0IG1vc3QgJWQgdGFibGVzIGluIGEgam9pbgBtaW4ALG9yaWdpbgB4QmVnaW4AbWFpbgBleHBsYWluAHNpZ24Ac3NlbgBvcGVuAHhPcGVuAHhEbE9wZW4AaGlkZGVuAGF0YW4AbmFuAHhEbFN5bQBhdXRvX3ZhY3V1bQBpbmNyZW1lbnRhbF92YWN1dW0Ac3VtAGZsZXhudW0AaWR4TnVtAGFsaXNtAHBtAGRyb3AgY29sdW1uIGZyb20AREVMRVRFIGZyb20AL2Rldi91cmFuZG9tAHJ0cmltAGx0cmltAHJlYWRvbmx5X3NobQAlcy1zaG0AdG5lbQBSQUlTRSgpIG1heSBvbmx5IGJlIHVzZWQgd2l0aGluIGEgdHJpZ2dlci1wcm9ncmFtAHRyaWdyYW0AZnVsAGZjbnRsAGlvY3RsAHhGaWxlQ29udHJvbABpZ29sAGxvY2tpbmcgcHJvdG9jb2wAbmNvbABqcm5sAG5vdG51bGwAaWZudWxsAC9kZXYvbnVsbABkYXRhYmFzZSBvciBkaXNrIGlzIGZ1bGwAY29sbABjYWNoZV9zcGlsbAB4TmV4dFN5c3RlbUNhbGwAeFNldFN5c3RlbUNhbGwAeEdldFN5c3RlbUNhbGwAZGVsZXRlLWFsbABjZWlsAGRldGFpbABmYWlsAHVuaXgtZXhjbAB0YmwAd2FsAHZpcnR1YWwAdG90YWwAaW5jcmVtZW50YWwAc2Vzc2lvbi1qb3VybmFsAGxvY2FsLWpvdXJuYWwAaW50ZXJuYWwAYXRpb25hbABub3JtYWwASW5kZXggYWxyZWFkeSBvcHRpbWFsAHBhcnRpYWwAcmVhbABsb2NhbABwawBvawB1bmxpbmsAcmVhZGxpbmsAbm9sb2NrAHhVbmxvY2sAYmxvY2sAJXMubG9jawB4TG9jawB4U2htTG9jawB4Q2hlY2tSZXNlcnZlZExvY2sAYnlwYXNzIHJlY2hlY2sAcnRyZWVjaGVjawBpbnRlZ3JpdHlfY2hlY2sAZm9yZWlnbl9rZXlfY2hlY2sAcXVpY2tfY2hlY2sAY2VsbF9zaXplX2NoZWNrAGludGVncml0eS1jaGVjawByb2xsYmFjawB4Um9sbGJhY2sAagByZXppAG5vaXRhemkAaXRpdmkAc3NlbmV2aQBpdml0aQBiaWxpdGkAYWxpdGkAaWNpdGkAaXNzaXNpAGlzaXNpAHBpAG5vaQBnbmkAZW50bGkAb3VzbGkAZWxpAGJsaQBzaXNzaWkAaXNzaXNpaQBzc3NpaWkAYXNjaWkAc2VpAGl0aWNpAGV0YWNpAGxhY2kAcnRyZWVkZXB0aABtb250aABqc29uX2FycmF5X2xlbmd0aABvY3RldF9sZW5ndGgAb3ZlcmZsb3cgbGlzdCBsZW5ndGgAd2R0aABzdGF0X3B1c2gAZmx1c2gAYWNvc2gAYXNpbmgAYXRhbmgAeFVuZmV0Y2gAeEZldGNoAGpzb25fcGF0Y2gAanNvbmJfcGF0Y2gAZGF0YXR5cGUgbWlzbWF0Y2gAYXJndW1lbnQgdHlwZSBtaXNtYXRjaAB0YWJsZSBzY2hlbWFzIGRvIG5vdCBtYXRjaABhYmJyZXZpYXRlZCBxdWVyeSBhbGdvcml0aG0gc2VhcmNoAHVuaXhlcG9jaABzcWxpdGVfYXR0YWNoAHNxbGl0ZV9kZXRhY2gAanNvbl9lYWNoAGF2ZwB6RXJyTXNnAG5hcmcAUnRyZWVNYXRjaEFyZwBzcWxpdGVfbG9nAHN0YXRlbWVudCB0b28gbG9uZwBjYW5ub3Qgb3BlbiAlcyBjb2x1bW4gZm9yIHdyaXRpbmcAc3Vic3RyaW5nAHVudGVybWluYXRlZCBzdHJpbmcAJXM6IHRhYmxlIGRvZXMgbm90IHN1cHBvcnQgc2Nhbm5pbmcAY2VpbGluZwBjb25maWcAc3RyaW5nIG9yIGJsb2IgdG9vIGJpZwBzdHJpbmdfYWdnAHNldCBhYm9ydCBmbGFnAGNsZWFyIGFib3J0IGZsYWcAY2hlY2sgYWJvcnQgZmxhZwBpbml0IExFRlQgSk9JTiBtYXRjaCBmbGFnACUuMTZnACUhMC4xNWcAJSEuMTVnACAlZwBzc2VubHVmAHByaW50ZgB0eXBlb2YAbW9kZW9mAHhFb2YAb3V0IG9mAHJlbmFtZSBjb2x1bW5zIG9mAGluZgAtSW5mAG51bGxpZgBpaWYAb2ZmAHRpbWVkaWZmADAxMjM0NTY3ODlhYmNkZWYAblJlZgBsZWFmACVjJTA0ZC0lMDJkLSUwMmQgJTAyZDolMDJkOiUwNi4zZgAlLjNmADUwZgA0MGYAJSEuKmYAY29sdW1uc2l6ZQBoYXNoc2l6ZQBnZXRwYWdlc2l6ZQBkb2NzaXplAG1tYXBfc2l6ZQBjYWNoZV9zaXplAFBSQUdNQSAlUS5wYWdlX3NpemUAZnRzM3Rva2VuaXplAG9wdGltaXplAGFsaXplAG5LZXlTaXplAHhTZWN0b3JTaXplAHhGaWxlU2l6ZQBqc29uX3JlbW92ZQBqc29uYl9yZW1vdmUAY2FzZV9zZW5zaXRpdmUAcGFyc2UgZXJyb3IgaW4gdG9rZW5pemUgZGlyZWN0aXZlAG1hbGZvcm1lZCBwcmVmaXg9Li4uIGRpcmVjdGl2ZQBtYWxmb3JtZWQgZGV0YWlsPS4uLiBkaXJlY3RpdmUAbWFsZm9ybWVkIGNvbHVtbnNpemU9Li4uIGRpcmVjdGl2ZQBtYWxmb3JtZWQgY29udGVudGxlc3NfZGVsZXRlPS4uLiBkaXJlY3RpdmUAbWFsZm9ybWVkIHRva2VuZGF0YT0uLi4gZGlyZWN0aXZlAGNhbm5vdCBjb21taXQgLSBubyB0cmFuc2FjdGlvbiBpcyBhY3RpdmUAY2Fubm90IHJvbGxiYWNrIC0gbm8gdHJhbnNhY3Rpb24gaXMgYWN0aXZlAGF0aXZlAGV4Y2x1c2l2ZQB0cnVlAHVuaXF1ZQBkZmx0X3ZhbHVlAENhbm5vdCBhZGQgYSBSRUZFUkVOQ0VTIGNvbHVtbiB3aXRoIG5vbi1OVUxMIGRlZmF1bHQgdmFsdWUAYmFkIHBhZ2UgdmFsdWUAanNvbl9xdW90ZQBwd3JpdGUAeFdyaXRlAGNvbnRlbnRsZXNzX2RlbGV0ZQBvbl9kZWxldGUAc2VjdXJlX2RlbGV0ZQBzZWN1cmUtZGVsZXRlAGNhbm5vdCBkZWxldGUAeERlbGV0ZQBwcml2YXRlAGFnZ3JlZ2F0ZQBjcmVhdGUAeENyZWF0ZQBvbl91cGRhdGUAeFVwZGF0ZQBjdXJyZW50X2RhdGUAZmFsbG9jYXRlAGZ0cnVuY2F0ZQB4VHJ1bmNhdGUAaWNhdGUAYmFkIHBhcmFtZXRlciBvciBvdGhlciBBUEkgbWlzdXNlAHRvbyBtYW55IHRlcm1zIGluICVzIEJZIGNsYXVzZQB0b28gbWFueSB0ZXJtcyBpbiBPUkRFUiBCWSBjbGF1c2UAYWdncmVnYXRlIGZ1bmN0aW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gdGhlIEdST1VQIEJZIGNsYXVzZQBQQVJUSVRJT04gY2xhdXNlAGEgTkFUVVJBTCBqb2luIG1heSBub3QgaGF2ZSBhbiBPTiBvciBVU0lORyBjbGF1c2UAZGF0YWJhc2UgJXMgaXMgYWxyZWFkeSBpbiB1c2UAY2xvc2UAeENsb3NlAHhEbENsb3NlAGZhbHNlAHBocmFzZQB4UmVsZWFzZQBhdHRlbXB0IHRvIHdyaXRlIGEgcmVhZG9ubHkgZGF0YWJhc2UAY29ycnVwdCBkYXRhYmFzZQBhdHRhY2hlZCBkYXRhYmFzZXMgbXVzdCB1c2UgdGhlIHNhbWUgdGV4dCBlbmNvZGluZyBhcyBtYWluIGRhdGFiYXNlAE5vZGUgJWxsZCBtaXNzaW5nIGZyb20gZGF0YWJhc2UAZmlsZSBpcyBub3QgYSBkYXRhYmFzZQB0ZW1wX3N0b3JlAGlnbm9yZQBzcWxpdGUzY2hhbmdlc2V0X2FwcGx5KCk6IHRhYmxlICVzIGhhcyAlZCBjb2x1bW5zLCBleHBlY3RlZCAlZCBvciBtb3JlACVzIGNsYXVzZSBzaG91bGQgY29tZSBhZnRlciAlcyBub3QgYmVmb3JlAGV4cHJfY29tcGFyZQBzdWJ0eXBlAGpzb25fdHlwZQBpbHRuZQB1bml4LW5vbmUAZW5kIGlubmVyLWxvb3Agc3Vicm91dGluZQBBLWx0LUIgc3Vicm91dGluZQBBLWd0LUIgc3Vicm91dGluZQBBLWVxLUIgc3Vicm91dGluZQBlb2YtQiBzdWJyb3V0aW5lAGVvZi1BIHN1YnJvdXRpbmUAaWNuZQBsb2NhbHRpbWUAc3RyZnRpbWUAZGF0ZXRpbWUAY3VycmVudF90aW1lAHhDdXJyZW50VGltZQB0bmVtZQBteFBhdGhuYW1lAHhGdWxsUGF0aG5hbWUAYWZ0ZXIgcmVuYW1lAG5vbi10ZXh0IGZpbGVuYW1lAHhSZW5hbWUAYW1iaWd1b3VzIGNvbHVtbiBuYW1lAHRlbXBvcmFyeSB0cmlnZ2VyIG1heSBub3QgaGF2ZSBxdWFsaWZpZWQgbmFtZQAgT1JERVIgQlkgbmFtZQB6TmFtZQB4U2hhZG93TmFtZQBwTW9kdWxlAHNpbXBsZQB1bml4LWRvdGZpbGUAY2Fubm90IG9wZW4gZmlsZQB1bmFibGUgdG8gb3BlbiBkYXRhYmFzZSBmaWxlAHN6T3NGaWxlAGltbXV0YWJsZQBsZWdhY3lfYWx0ZXJfdGFibGUAc3FsaXRlX3JlbmFtZV90YWJsZQByZWN1cnNpdmVseSBkZWZpbmVkIGZ0czUgY29udGVudCB0YWJsZQBjb250ZW50bGVzc19kZWxldGU9MSByZXF1aXJlcyBhIGNvbnRlbnRsZXNzIHRhYmxlAE1hcHBpbmcgKCVsbGQgLT4gJWxsZCkgbWlzc2luZyBmcm9tICVzIHRhYmxlAGNhbm5vdCBjcmVhdGUgdHJpZ2dlciBvbiBzeXN0ZW0gdGFibGUAdmlydHVhbCB0YWJsZQBubyBzdWNoIHRhYmxlAFF1ZXVlIHRhYmxlAFRvbyBtYW55IGNvbHVtbnMgZm9yIGFuIHJ0cmVlIHRhYmxlAFRvbyBmZXcgY29sdW1ucyBmb3IgYW4gcnRyZWUgdGFibGUAV3JvbmcgbnVtYmVyIG9mIGNvbHVtbnMgZm9yIGFuIHJ0cmVlIHRhYmxlAG51bWJlciBvZiBjb2x1bW5zIGluIGZvcmVpZ24ga2V5IGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgcmVmZXJlbmNlZCB0YWJsZQAnZGVsZXRlLWFsbCcgbWF5IG9ubHkgYmUgdXNlZCB3aXRoIGEgY29udGVudGxlc3Mgb3IgZXh0ZXJuYWwgY29udGVudCBmdHM1IHRhYmxlACdyZWJ1aWxkJyBtYXkgbm90IGJlIHVzZWQgd2l0aCBhIGNvbnRlbnRsZXNzIGZ0czUgdGFibGUAJ2RlbGV0ZScgbWF5IG5vdCBiZSB1c2VkIHdpdGggYSBjb250ZW50bGVzc19kZWxldGU9MSB0YWJsZQB1c2FibGUAbG9jYWwgdGltZSB1bmF2YWlsYWJsZQBhbm90aGVyIHJvdyBhdmFpbGFibGUAbm8gbW9yZSByb3dzIGF2YWlsYWJsZQB1dGYxNmxlAGNhc2Vfc2Vuc2l0aXZlX2xpa2UAY2FjaGUAY3Jpc2lzbWVyZ2UAdXNlcm1lcmdlAGF1dG9tZXJnZQBkZWxldGVtZXJnZQBjb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlAG5vdGlmaWNhdGlvbiBtZXNzYWdlAHdhcm5pbmcgbWVzc2FnZQBhQ29uc3RyYWludFVzYWdlAGludmFsaWQgcm9vdHBhZ2UAc3FsaXRlX2RicGFnZQBFeHRlbmRzIG9mZiBlbmQgb2YgcGFnZQBNQVhfUEFHRV9DT1VOVD0weGZmZmZmZmZlAFNjaGVtYSBjb3JydXB0IG9yIG5vdCBhbiBydHJlZQBqc29uX3RyZWUAZGVlAHJ0cmVlbm9kZQBfbm9kZQBqb3VybmFsX21vZGUAbG9ja2luZ19tb2RlAG9wY29kZQB1bmljb2RlAGJ5dGVjb2RlAGNvYWxlc2NlAHNxbGl0ZV9zZXF1ZW5jZQBpbnN0YW5jZQBqc29uX3JlcGxhY2UAanNvbmJfcmVwbGFjZQB1dGYxNmJlAGZ0czU6IDIwMjQtMDUtMjMgMTM6MjU6MjcgOTZjOTJhYmEwMGM4Mzc1YmMzMmZhZmNkZjEyNDI5YzU4YmQ4YWFiZmNhZGFiNjY4M2UzNWJiYjljZGViZjE5ZQAyMGM6MjBlADIwYjoyMGUAJSEwLjIwZQBnZXRjd2QAdGhzdG5kcmQAbGlrZWxpaG9vZABmY2htb2QAcm91bmQAc3Vic2Vjb25kAGVuZABvbGQAeyVsbGQAV3JvbmcgbnVtYmVyIG9mIGVudHJpZXMgaW4gJSUlcyB0YWJsZSAtIGV4cGVjdGVkICVsbGQsIGFjdHVhbCAlbGxkACVsbGQgJWxsZABubyBzdWNoIGN1cnNvcjogJWxsZABubyBzdWNoIHJvd2lkOiAlbGxkACwiU1FMSVRFX1dBU01fREVBTExPQyI6ICVsbGQAcmVidWlsZABsYXN0X2luc2VydF9yb3dpZABjb250ZW50X3Jvd2lkACVfcm93aWQAJXMucm93aWQAU0VMRUNUKkZST00iJXciLiVzIE9SREVSIEJZIHJvd2lkAFNFTEVDVCpGUk9NIiV3Ii4lcyBXSEVSRSAlcyBPUkRFUiBCWSByb3dpZAB4Um93aWQAZ2V0ZXVpZABpbnZhbGlkAGpzb25fdmFsaWQAZmtpZABfX2xhbmdpZAAleiwgbGFuZ2lkAGxhbmd1YWdlaWQAZG9jaWQAYXBwbGljYXRpb25faWQAc3FsaXRlX3NvdXJjZV9pZABmdHM1X3NvdXJjZV9pZABub3QgYXV0aG9yaXplZABJbmRleCBvcHRpbWl6ZWQAbm90aW5kZXhlZAB1bmluZGV4ZWQAdW5hYmxlIHRvIGlkZW50aWZ5IHRoZSBvYmplY3QgdG8gYmUgcmVpbmRleGVkAHZpZXdzIG1heSBub3QgYmUgaW5kZXhlZAB2aXJ0dWFsIHRhYmxlcyBtYXkgbm90IGJlIGluZGV4ZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBpbmRleGVkAHJlYWRfdW5jb21taXR0ZWQAcmVjdXJzaXZlIGFnZ3JlZ2F0ZSBxdWVyaWVzIG5vdCBzdXBwb3J0ZWQAcXVlcnkgYWJvcnRlZAByb3dzIGluc2VydGVkAGNvcnJ1cHRlZABpbnRlcnJ1cHRlZABjaGVja3BvaW50ZWQAYWNjZXNzIHRvICV6IGlzIHByb2hpYml0ZWQAYWNjZXNzIHRvIHZpZXcgIiVzIiBwcm9oaWJpdGVkAHJvd3MgZGVsZXRlZABnZW5lcmF0ZWQAcm93cyB1cGRhdGVkAG5vdHVzZWQAcm93IHZhbHVlIG1pc3VzZWQAdGFibGVzX3VzZWQAc3FsaXRlX2NvbXBpbGVvcHRpb25fdXNlZABQYWdlICV1OiBuZXZlciB1c2VkAGNvbFVzZWQAc3RvcmVkAHZpcnR1YWwgdGFibGVzIG1heSBub3QgYmUgYWx0ZXJlZAB2aWV3ICVzIG1heSBub3QgYmUgYWx0ZXJlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGFsdGVyZWQAc2hhcmVkAGluZGV4IGFzc29jaWF0ZWQgd2l0aCBVTklRVUUgb3IgUFJJTUFSWSBLRVkgY29uc3RyYWludCBjYW5ub3QgYmUgZHJvcHBlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGRyb3BwZWQAdmlldyAlcyBpcyBjaXJjdWxhcmx5IGRlZmluZWQAdW5vcGVuZWQAb3JkZXJCeUNvbnN1bWVkAGRhdGFiYXNlIGRpc2sgaW1hZ2UgaXMgbWFsZm9ybWVkACVzIGNvbnN0cmFpbnQgZmFpbGVkAEZPUkVJR04gS0VZIGNvbnN0cmFpbnQgZmFpbGVkAGZ0czN0b2tlbml6ZSBkaXNhYmxlZABkYXRhYmFzZSAlcyBpcyBsb2NrZWQAZGF0YWJhc2UgaXMgbG9ja2VkAGRhdGFiYXNlIHRhYmxlIGlzIGxvY2tlZABhdXRob3JpemF0aW9uIGRlbmllZABhY2Nlc3MgcGVybWlzc2lvbiBkZW5pZWQAdGFibGUgJVMgaGFzICVkIGNvbHVtbnMgYnV0ICVkIHZhbHVlcyB3ZXJlIHN1cHBsaWVkAHRlbXBvcmFyeSB0YWJsZSBuYW1lIG11c3QgYmUgdW5xdWFsaWZpZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBtb2RpZmllZABjb25mbGljdGluZyBPTiBDT05GTElDVCBjbGF1c2VzIHNwZWNpZmllZABubyB0YWJsZXMgc3BlY2lmaWVkAGRhdGFiYXNlIGlzIGFscmVhZHkgYXR0YWNoZWQASnVtcCBhaGVhZCBpZiBMSU1JVCByZWFjaGVkAGRhdGFiYXNlIHNjaGVtYSBoYXMgY2hhbmdlZABlZWQAZXhjbHVkZWQAUGFnZSAldTogcG9pbnRlciBtYXAgcmVmZXJlbmNlZABwcmVhZAB4UmVhZAAlMDRkACUwM2QAJTAyZDolMDJkOiUwMmQAJTA0ZC0lMDJkLSUwMmQAJTJkADQwZi0yMWEtMjFkADUwZi0yMGEtMjBkADQwZi0yMGEtMjBkAHNxbGl0ZV9zdGF0JWQAY29sdW1uJWQALCBULmMlZAAsIGMlZAAsYSVkAHNxbGl0ZV9hdXRvaW5kZXhfJXNfJWQAYSVkPT8lZAB2YXJpYWJsZSBudW1iZXIgbXVzdCBiZSBiZXR3ZWVuID8xIGFuZCA/JWQAdXNlc1N0bXRKb3VybmFsPSVkAHVuYWJsZSB0byBnZXQgdGhlIHBhZ2UuIGVycm9yIGNvZGU9JWQAJWQuLiVkAGsoJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHJvb3RwYWdlPSVkIFdIRVJFICMlZCBBTkQgcm9vdHBhZ2U9IyVkAFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCB0eXBlPSclcycsIG5hbWU9JVEsIHRibF9uYW1lPSVRLCByb290cGFnZT0jJWQsIHNxbD0lUSBXSEVSRSByb3dpZD0jJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHR5cGU9J3RhYmxlJywgbmFtZT0lUSwgdGJsX25hbWU9JVEsIHJvb3RwYWdlPTAsIHNxbD0lUSBXSEVSRSByb3dpZD0jJWQAdG9vIG1hbnkgYXR0YWNoZWQgZGF0YWJhc2VzIC0gbWF4ICVkAHRvbyBtYW55IGFyZ3VtZW50cyBvbiAlcygpIC0gbWF4ICVkAGV4cGVjdGVkICVkIGNvbHVtbnMgZm9yICclcycgYnV0IGdvdCAlZABhdHRlbXB0IHRvIG9wZW4gIiVzIiBhcyBmaWxlIGRlc2NyaXB0b3IgJWQAJXMgZXhwci1jb2x1bW4gJWQAJXMgY29sdW1uICVkAGJ0cmVlSW5pdFBhZ2UoKSByZXR1cm5zIGVycm9yIGNvZGUgJWQAJXIgJXMgQlkgdGVybSBvdXQgb2YgcmFuZ2UgLSBzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAlZABzdWItc2VsZWN0IHJldHVybnMgJWQgY29sdW1ucyAtIGV4cGVjdGVkICVkAElOKC4uLikgZWxlbWVudCBoYXMgJWQgdGVybSVzIC0gZXhwZWN0ZWQgJWQAJXNMSVNUIFNVQlFVRVJZICVkAFJFVVNFIExJU1QgU1VCUVVFUlkgJWQAJXNTQ0FMQVIgU1VCUVVFUlkgJWQAUkVVU0UgU1VCUVVFUlkgJWQASU5ERVggJWQAdG9vIG1hbnkgRlJPTSBjbGF1c2UgdGVybXMsIG1heDogJWQAJXMiJXMiOiAlZAAic2l6ZW9mIjogJWQAcndjAHV0YwBkZXNjAGFzYwBjaGVja3BvaW50X2Z1bGxmc3luYwBmdWxsX2ZzeW5jAHhTeW5jAHRydW5jAHhGdW5jAGVuYwBudW1lcmljAHN1YnNlYwAlLjRjJXMlLjE2YwBhcGkvc3FsaXRlMy13YXNtLmMAJXMvZXRpbHFzXyVsbHglYwB1bnJlY29nbml6ZWQgbWF0Y2hpbmZvIHJlcXVlc3Q6ICVjAHdiAHJiAGdsb2IAemVyb2Jsb2IAcmFuZG9tYmxvYgBqc29uYgBpbGIAaXRpbGliAG1lbWRiAEFUVEFDSCAlUSBBUyB2YWN1dW1fZGIAcFZ0YWIAZnRzNXZvY2FiAHJ3YQByb3RhAGV2aXRhAGxhbm9pdGEAZXRhAHRva2VuZGF0YQAlc19kYXRhAHBBcHBEYXRhAGljbmEAc3FsaXRlX3RlbXBfc2NoZW1hAHNxbGl0ZV9zY2hlbWEAd3JpdGFibGVfc2NoZW1hAHRydXN0ZWRfc2NoZW1hAGNvcnJ1cHQgc2NoZW1hAG5vIHN1Y2ggc2NoZW1hAGlsbGEAZXppbGEAaXRpbGEAbXNpbGEAbi9hAHNxbGl0ZV8AcHJhZ21hXwBTUUxJVEVfAF9ST1dJRF8AJXMgYXQgbGluZSAlZCBvZiBbJS4xMHNdAGJpbmQgb24gYSBidXN5IHByZXBhcmVkIHN0YXRlbWVudDogWyVzXQBtYWxmb3JtZWQgTUFUQ0ggZXhwcmVzc2lvbjogWyVzXQBbJWxsZF0AW10ALCAic3RydWN0cyI6IFsAU1FMSVRFX0NPTkZJR19QQ0FDSEVfSERSU1oAU1FMSVRFX0NPTkZJR19QTUFTWgBTUUxJVEVfRU1QVFkAU1FMSVRFX0JVU1kAU1FMSVRFX0ZDTlRMX1dJTjMyX0FWX1JFVFJZAFNRTElURV9FUlJPUl9SRVRSWQBTUUxJVEVfUkVBRE9OTFlfRElSRUNUT1JZAFNRTElURV9PUEVOX01FTU9SWQBTUUxJVEVfQlVTWV9SRUNPVkVSWQBTUUxJVEVfUkVBRE9OTFlfUkVDT1ZFUlkATEVGVC1NT1NUIFNVQlFVRVJZAENPTVBPVU5EIFFVRVJZAFNRTElURV9TRVJJQUxJWkVfTk9DT1BZAFNRTElURV9ERU5ZAEFOWQBTUUxJVEVfT0tfTE9BRF9QRVJNQU5FTlRMWQBTUUxJVEVfRElSRUNUT05MWQBTUUxJVEVfVlRBQl9ESVJFQ1RPTkxZAFNRTElURV9PUEVOX1JFQURPTkxZAFNRTElURV9ERVNFUklBTElaRV9SRUFET05MWQBTUUxJVEVfUkVBRE9OTFkAU1FMSVRFX1NZTkNfREFUQU9OTFkAU1FMSVRFX0NIQU5HRVNFVF9GT1JFSUdOX0tFWQBTUUxJVEVfQ09OU1RSQUlOVF9QUklNQVJZS0VZAFNRTElURV9DT05TVFJBSU5UX0ZPUkVJR05LRVkAU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9GS0VZAGdlbmVyYXRlZCBjb2x1bW5zIGNhbm5vdCBiZSBwYXJ0IG9mIHRoZSBQUklNQVJZIEtFWQBBVVRPSU5DUkVNRU5UIGlzIG9ubHkgYWxsb3dlZCBvbiBhbiBJTlRFR0VSIFBSSU1BUlkgS0VZAGRvY2lkIElOVEVHRVIgUFJJTUFSWSBLRVkARk9SRUlHTiBLRVkAVVNFIFRFTVAgQi1UUkVFIEZPUiAlc09SREVSIEJZAFVTRSBURU1QIEItVFJFRSBGT1IgTEFTVCAlZCBURVJNUyBPRiBPUkRFUiBCWQBHUk9VUCBCWQBpaXNYAGlzaVgAU1FMSVRFX0NPTkZJR19NVVRFWABTUUxJVEVfQ09ORklHX0dFVE1VVEVYAFNRTElURV9PUEVOX05PTVVURVgAU1FMSVRFX09QRU5fRlVMTE1VVEVYAFNRTElURV9DT1JSVVBUX0lOREVYAFNRTElURV9EUk9QX0lOREVYAFNRTElURV9EUk9QX1RFTVBfSU5ERVgAU1FMSVRFX0NSRUFURV9URU1QX0lOREVYAFNRTElURV9DUkVBVEVfSU5ERVgAU1FMSVRFX1NUTVRTVEFUVVNfQVVUT0lOREVYAFNRTElURV9XQVJOSU5HX0FVVE9JTkRFWABTUUxJVEVfUkVJTkRFWABBVVRPTUFUSUMgUEFSVElBTCBDT1ZFUklORyBJTkRFWABBVVRPTUFUSUMgQ09WRVJJTkcgSU5ERVgAU1FMSVRFX0RCU1RBVFVTX01BWABTUUxJVEVfREJDT05GSUdfTUFYAC1taiUwNlg5JTAyWABTUUxJVEVfUk9XAFNRTElURV9UUkFDRV9ST1cAU0NBTiBDT05TVEFOVCBST1cAU1FMSVRFX09QRU5fTk9GT0xMT1cAU1FMSVRFX1NUQVRVU19QQUdFQ0FDSEVfT1ZFUkZMT1cAU1FMSVRFX0RST1BfVklFVwBTUUxJVEVfRFJPUF9URU1QX1ZJRVcAU1FMSVRFX0NSRUFURV9URU1QX1ZJRVcAU1FMSVRFX0NSRUFURV9WSUVXAFNRTElURV9EQkNPTkZJR19FTkFCTEVfVklFVwBwcFYAU1FMSVRFX0ZDTlRMX1JCVQBTUUxJVEVfVEVYVABqc29uX29iamVjdCgpIGxhYmVscyBtdXN0IGJlIFRFWFQAU1FMSVRFX0JVU1lfVElNRU9VVABTUUxJVEVfRkNOVExfTE9DS19USU1FT1VUAEZJUlNUAExBU1QAU1FMSVRFX1NUTVRTVEFUVVNfU09SVABTUUxJVEVfVlRBQl9DT05TVFJBSU5UX1NVUFBPUlQAU1FMSVRFX0NIQU5HRVNFVF9BQk9SVABTUUxJVEVfQUJPUlQAU1FMSVRFX0NIQU5HRVNFVEFQUExZX0lOVkVSVABTUUxJVEVfQ0hBTkdFU0VUU1RBUlRfSU5WRVJUAEJlZ2luIERPIFVQREFURSBvZiBVUFNFUlQARW5kIERPIFVQREFURSBvZiBVUFNFUlQAU1FMSVRFX0lOU0VSVABTUUxJVEVfRkNOVExfQ0tQVF9TVEFSVABTUUxJVEVfQ09SUlVQVABTUUxJVEVfSU5URVJSVVBUAEVYQ0VQVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9JU05PVABTUUxJVEVfQlVTWV9TTkFQU0hPVABTUUxJVEVfRVJST1JfU05BUFNIT1QAU1FMSVRFX1NUQVRVU19NQUxMT0NfQ09VTlQAU1FMSVRFX1NBVkVQT0lOVABTUUxJVEVfQ0hBTkdFU0VUQVBQTFlfTk9TQVZFUE9JTlQAU1FMSVRFX0ZDTlRMX1NJWkVfSElOVABTUUxJVEVfQ0hBTkdFU0VUX0NPTlNUUkFJTlQAU1FMSVRFX0NPTlNUUkFJTlQALCUuKnMgSU5UAENSRUFURSBUQUJMRSB4KCUuKnMgSU5UAFNRTElURV9QUkVQQVJFX1BFUlNJU1RFTlQAU1FMSVRFX0lPRVJSX0RFTEVURV9OT0VOVABTUUxJVEVfVFJBQ0VfU1RNVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9MVABTRVQgREVGQVVMVABTUUxJVEVfUkVBRE9OTFlfQ0FOVElOSVQATVVURVhfT01JVABTUUxJVEVfQ0hBTkdFU0VUX09NSVQAQ09NTUlUAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0xJTUlUAFNRTElURV9GQ05UTF9TSVpFX0xJTUlUAFNRTElURV9TVE1UU1RBVFVTX0ZJTFRFUl9ISVQAU1FMSVRFX0RCU1RBVFVTX0NBQ0hFX0hJVABTUUxJVEVfREJTVEFUVVNfTE9PS0FTSURFX0hJVABSSUdIVABTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9HVABMRUZUAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX09GRlNFVABMSU1JVCtPRkZTRVQARElTVElOQ1QAUkVTVFJJQ1QAU1FMSVRFX0NIQU5HRVNFVF9DT05GTElDVABJTlRFUlNFQ1QAU1FMSVRFX1NFTEVDVABTUUxJVEVfTUFYX0NPTVBPVU5EX1NFTEVDVABTUUxJVEVfTElNSVRfQ09NUE9VTkRfU0VMRUNUAHJpZ2h0IFNFTEVDVABsZWZ0IFNFTEVDVAB0b28gbWFueSB0ZXJtcyBpbiBjb21wb3VuZCBTRUxFQ1QAU1FMSVRFX0lPRVJSX0ZTVEFUAFNRTElURV9GTE9BVABTUUxJVEVfRk9STUFUAFNRTElURV9EQkNPTkZJR19MRUdBQ1lfRklMRV9GT1JNQVQAdW5rbm93biBqb2luIHR5cGU6ICVUJXMlVCVzJVQALSVUAHRvbyBtYW55IGFyZ3VtZW50cyBvbiBmdW5jdGlvbiAlVAB1bmtub3duIGRhdGFiYXNlICVUAGZvcmVpZ24ga2V5IG9uICVzIHNob3VsZCByZWZlcmVuY2Ugb25seSBvbmUgY29sdW1uIG9mIHRhYmxlICVUAENSRUFURSBWSVJUVUFMIFRBQkxFICVUAGhleCBsaXRlcmFsIHRvbyBiaWc6ICVzJSNUAG5vIHN1Y2ggZnVuY3Rpb246ICUjVABub3QgYXV0aG9yaXplZCB0byB1c2UgZnVuY3Rpb246ICUjVABTRUxFQ1QgJXMgRlJPTSAlcyBBUyBUAFNRTElURV9EQkNPTkZJR19TVE1UX1NDQU5TVEFUVVMAU1FMSVRFX0NPTkZJR19NRU1TVEFUVVMAU1FMSVRFX0lOTk9DVU9VUwBTUUxJVEVfVlRBQl9JTk5PQ1VPVVMAU1FMSVRFX0FDQ0VTU19FWElTVFMARU5BQkxFX0VYUExBSU5fQ09NTUVOVFMAU1FMSVRFX1NUTVRTVEFUVVNfRklMVEVSX01JU1MAU1FMSVRFX0RCU1RBVFVTX0NBQ0hFX01JU1MAU1FMSVRFX0lPRVJSX0FDQ0VTUwBERUZBVUxUX1JFQ1VSU0lWRV9UUklHR0VSUwBFTkFCTEVfTUFUSF9GVU5DVElPTlMASU5TAFNRTElURV9EQlNUQVRVU19ERUZFUlJFRF9GS1MAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfSVMAU1FMSVRFX0ZDTlRMX1pJUFZGUwBTUUxJVEVfSU9FUlJfQ09SUlVQVEZTAFNRTElURV9OT0xGUwBTUUxJVEVfRkNOVExfUkVTRVJWRV9CWVRFUwBTUUxJVEVfTUFYX1dPUktFUl9USFJFQURTAFNRTElURV9MSU1JVF9XT1JLRVJfVEhSRUFEUwBTUUxJVEVfVlRBQl9VU0VTX0FMTF9TQ0hFTUFTACVzICVTAFNDQU4gJVMAbm8gc3VjaCBpbmRleDogJVMAY2Fubm90IGNyZWF0ZSAlcyB0cmlnZ2VyIG9uIHZpZXc6ICVTAG5vIHN1Y2ggdHJpZ2dlcjogJVMAY2Fubm90IGNyZWF0ZSBJTlNURUFEIE9GIHRyaWdnZXIgb24gdGFibGU6ICVTAG1hdGVyaWFsaXplICUhUwBlbmQgJSFTAE1BVEVSSUFMSVpFICUhUwBDTy1ST1VUSU5FICUhUwBTUUxJVEVfSU9FUlIAVVNJTkcgSU5ERVggJXMgRk9SIElOLU9QRVJBVE9SAFVTSU5HIFJPV0lEIFNFQVJDSCBPTiBUQUJMRSAlcyBGT1IgSU4tT1BFUkFUT1IAU1FMSVRFX0VSUk9SAEVOQUJMRV9BUElfQVJNT1IATVVMVEktSU5ERVggT1IAU1FMSVRFX0NBTlRPUEVOX0lTRElSAFNRTElURV9UTVBESVIAU1FMSVRFX0NBTlRPUEVOX05PVEVNUERJUgBTUUxJVEVfREJDT05GSUdfRU5BQkxFX0ZUUzNfVE9LRU5JWkVSAFNRTElURV9GQ05UTF9WRlNfUE9JTlRFUgBTUUxJVEVfRkNOVExfSk9VUk5BTF9QT0lOVEVSAFNRTElURV9GQ05UTF9GSUxFX1BPSU5URVIAQUZURVIAU1FMSVRFX0FVVEhfVVNFUgBTUUxJVEVfRkNOVExfQlVTWUhBTkRMRVIAU1FMSVRFX0NPTlNUUkFJTlRfVFJJR0dFUgBTUUxJVEVfRFJPUF9UUklHR0VSAFNRTElURV9EUk9QX1RFTVBfVFJJR0dFUgBTUUxJVEVfQ1JFQVRFX1RFTVBfVFJJR0dFUgBTUUxJVEVfQ1JFQVRFX1RSSUdHRVIAU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9UUklHR0VSAFNRTElURV9JTlRFR0VSAGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIHN6IEJMT0IsIG9yaWdpbiBJTlRFR0VSAFNRTElURV9EQkNPTkZJR19SRVZFUlNFX1NDQU5PUkRFUgBTUUxJVEVfRkNOVExfRVhURVJOQUxfUkVBREVSAFNRTElURV9WRVJTSU9OX05VTUJFUgBTUUxJVEVfTUFYX1ZBUklBQkxFX05VTUJFUgBTUUxJVEVfTElNSVRfVkFSSUFCTEVfTlVNQkVSAE5FQVIAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfRVEAU1FMSVRFX0VSUk9SX01JU1NJTkdfQ09MTFNFUQAleiVzJVEAREVMRVRFIEZST00gJVEuJXMgV0hFUkUgJXM9JVEAbmFtZT0lUSBBTkQgc3FsPSVRAERFTEVURSBGUk9NICVRLnNxbGl0ZV9zZXF1ZW5jZSBXSEVSRSBuYW1lPSVRACwgeC4lUQAsIFQuJVEAU0VMRUNUICogRlJPTSAlUS4lUQBBVFRBQ0ggeCBBUyAlUQBVUERBVEUgIiV3Ii5zcWxpdGVfc2VxdWVuY2Ugc2V0IG5hbWUgPSAlUSBXSEVSRSBuYW1lID0gJVEAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gcHJpbnRmKCclJS4lZHMsICcsc3FsKSB8fCAlUSB8fCBzdWJzdHIoc3FsLDErbGVuZ3RoKHByaW50ZignJSUuJWRzJyxzcWwpKSkgV0hFUkUgdHlwZSA9ICd0YWJsZScgQU5EIG5hbWUgPSAlUQBiYWQgSlNPTiBwYXRoOiAlUQBmdHM1dm9jYWI6IHVua25vd24gdGFibGUgdHlwZTogJVEAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfUkVHRVhQAFNFVFVQAEdST1VQAFNRTElURV9EQkNPTkZJR19UUklHR0VSX0VRUABTUUxJVEVfTUFYX1ZEQkVfT1AAU1FMSVRFX0xJTUlUX1ZEQkVfT1AAU1FMSVRFX0NIQU5HRVNFVEFQUExZX0lHTk9SRU5PT1AAQE5QAFNRTElURV9TVE1UU1RBVFVTX0ZVTExTQ0FOX1NURVAAU1FMSVRFX1NUTVRTVEFUVVNfVk1fU1RFUABSRUNVUlNJVkUgU1RFUABTUUxJVEVfSU9FUlJfTU1BUABTUUxJVEVfSU9FUlJfU0hNTUFQAFNRTElURV9DT05GSUdfSEVBUABAUABTUUxJVEVfRkNOVExfQ09NTUlUX1BIQVNFVFdPAFNRTElURV9GQ05UTF9MQVNUX0VSUk5PAFNOYU4AUU5hTgBTUUxJVEVfU1RNVFNUQVRVU19SVU4AbWFsZm9ybWVkIEpTT04AU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfRlVOQ1RJT04AU1FMSVRFX0NPTlNUUkFJTlRfRlVOQ1RJT04ARU5BQkxFX1VOS05PV05fU1FMX0ZVTkNUSU9OAFNRTElURV9GVU5DVElPTgBTUUxJVEVfVFJBTlNBQ1RJT04ATk8gQUNUSU9OAEVOQUJMRV9TRVNTSU9OAFNRTElURV9WRVJTSU9OAFNRTElURV9GQ05UTF9EQVRBX1ZFUlNJT04AT01JVF9MT0FEX0VYVEVOU0lPTgBTUUxJVEVfREJDT05GSUdfRU5BQkxFX0xPQURfRVhURU5TSU9OAFVOSU9OAFNRTElURV9NQVhfQ09MVU1OAFNRTElURV9MSU1JVF9DT0xVTU4AIExFRlQtSk9JTgBCRUdJTgBTUUxJVEVfSU9DQVBfVU5ERUxFVEFCTEVfV0hFTl9PUEVOAFNRTElURV9DQU5UT1BFTgBTUUxJVEVfSU9FUlJfU0hNT1BFTgAsYXJnIEhJRERFTgAsc2NoZW1hIEhJRERFTgBOQU4AU1FMSVRFX0NPTkZJR19DT1ZFUklOR19JTkRFWF9TQ0FOAERFRkFVTFRfQVVUT1ZBQ1VVTQAgTlVNAFNRTElURV9QRVJNAFBNAFJUUklNAFNRTElURV9JT0VSUl9OT01FTQBTUUxJVEVfTk9NRU0AQU0AU1FMSVRFX1BST1RPQ09MAFNRTElURV9EQkNPTkZJR19EUVNfRE1MAFNRTElURV9OVUxMAFNRTElURV9DT05TVFJBSU5UX05PVE5VTEwAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfSVNOT1ROVUxMAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0lTTlVMTABDYW5ub3QgYWRkIGEgTk9UIE5VTEwgY29sdW1uIHdpdGggZGVmYXVsdCB2YWx1ZSBOVUxMAE5PVCBOVUxMAFNFVCBOVUxMAFNFTEVDVCAxIEZST00gJVEuJyVxX3NlZ21lbnRzJyBXSEVSRSBibG9ja2lkPT8gQU5EIGJsb2NrIElTIE5VTEwAU1FMSVRFX0RCU1RBVFVTX0xPT0tBU0lERV9NSVNTX0ZVTEwAU1FMSVRFX0ZVTEwAU1FMSVRFX1NZTkNfRlVMTABTUUxJVEVfQ09ORklHX1NUTVRKUk5MX1NQSUxMAFNRTElURV9EQlNUQVRVU19DQUNIRV9TUElMTABVTklPTiBBTEwAU1FMSVRFX0ZBSUwAU1FMSVRFX0RCQ09ORklHX0RRU19EREwAU1FMSVRFX0ZDTlRMX1BFUlNJU1RfV0FMAFNRTElURV9OT1RJQ0VfUkVDT1ZFUl9XQUwAU1FMSVRFX09QRU5fV0FMAFNRTElURV9PUEVOX1NVUEVSX0pPVVJOQUwAU1FMSVRFX09QRU5fVEVNUF9KT1VSTkFMAFNRTElURV9PUEVOX01BSU5fSk9VUk5BTABTUUxJVEVfT1BFTl9TVUJKT1VSTkFMAFNRTElURV9JTlRFUk5BTABTUUxJVEVfU1lOQ19OT1JNQUwAU1FMSVRFX0lPQ0FQX1NFUVVFTlRJQUwALCUuKnMgUkVBTABTUUxJVEVfT0sARU5BQkxFX1BSRVVQREFURV9IT09LAFNRTElURV9DT05TVFJBSU5UX0NPTU1JVEhPT0sAU1FMSVRFX0NBTlRPUEVOX1NZTUxJTksAU1FMSVRFX0lPRVJSX1NFRUsAU1FMSVRFX0lPRVJSX0xPQ0sAU1FMSVRFX1JFQURPTkxZX0NBTlRMT0NLAFNRTElURV9JT0VSUl9VTkxPQ0sAU1FMSVRFX0lPRVJSX1NITUxPQ0sAU1FMSVRFX0lPRVJSX1JETE9DSwBTUUxJVEVfSU9FUlJfQ0hFQ0tSRVNFUlZFRExPQ0sAU1FMSVRFX0ZDTlRMX1dBTF9CTE9DSwBTUUxJVEVfQ09OU1RSQUlOVF9DSEVDSwBTUUxJVEVfU1RBVFVTX1BBUlNFUl9TVEFDSwBTUUxJVEVfUkVBRE9OTFlfUk9MTEJBQ0sAU1FMSVRFX0FCT1JUX1JPTExCQUNLAFNRTElURV9OT1RJQ0VfUkVDT1ZFUl9ST0xMQkFDSwBTUUxJVEVfUk9MTEJBQ0sAYWJvcnQgZHVlIHRvIFJPTExCQUNLAFNRTElURV9JT0NBUF9BVE9NSUM4SwBTUUxJVEVfSU9DQVBfQVRPTUlDMTZLAFNRTElURV9JT0NBUF9BVE9NSUM0SwBTUUxJVEVfSU9DQVBfQVRPTUlDNjRLAFNRTElURV9JT0NBUF9BVE9NSUMySwBTUUxJVEVfSU9DQVBfQVRPTUlDMzJLAFNRTElURV9JT0NBUF9BVE9NSUMxSwBTUUxJVEVfT1BFTl9VUkkAU1FMSVRFX0NPTkZJR19VUkkAVVNFX1VSSQBTUUxJVEVfSU9FUlJfQVVUSABTUUxJVEVfQVVUSABTUUxJVEVfTUFYX0VYUFJfREVQVEgAU1FMSVRFX0xJTUlUX0VYUFJfREVQVEgAU1FMSVRFX01BWF9UUklHR0VSX0RFUFRIAFNRTElURV9MSU1JVF9UUklHR0VSX0RFUFRIAFNRTElURV9NQVhfTEVOR1RIAFNRTElURV9MSU1JVF9MRU5HVEgAU1FMSVRFX01BWF9MSUtFX1BBVFRFUk5fTEVOR1RIAFNRTElURV9MSU1JVF9MSUtFX1BBVFRFUk5fTEVOR1RIAFNRTElURV9NQVhfU1FMX0xFTkdUSABTUUxJVEVfTElNSVRfU1FMX0xFTkdUSABTUUxJVEVfSU9FUlJfQ09OVlBBVEgAU1FMSVRFX0NBTlRPUEVOX0NPTlZQQVRIAFNRTElURV9JT0VSUl9HRVRURU1QUEFUSABTUUxJVEVfQ0FOVE9QRU5fRlVMTFBBVEgAU1FMSVRFX0NPTkZJR19TQ1JBVENIAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX01BVENIAFNRTElURV9NSVNNQVRDSABTRUFSQ0gAU1FMSVRFX0FUVEFDSABTUUxJVEVfREVUQUNIAFNRTElURV9EQkNPTkZJR19FTkFCTEVfUVBTRwBTUUxJVEVfTUFYX0ZVTkNUSU9OX0FSRwBTUUxJVEVfTElNSVRfRlVOQ1RJT05fQVJHAFNRTElURV9DT05GSUdfTE9HAFNRTElURV9DT05GSUdfU1FMTE9HAFVTSU5HAFNRTElURV9XQVJOSU5HAFNRTElURV9MT0NLX1BFTkRJTkcAU1FMSVRFX1RPT0JJRwBJTkYAMDEyMzQ1Njc4OUFCQ0RFRgBTUUxJVEVfQU5BTFlaRQBTUUxJVEVfREJTVEFUVVNfTE9PS0FTSURFX01JU1NfU0laRQBTUUxJVEVfRkNOVExfTU1BUF9TSVpFAFNRTElURV9DT05GSUdfTU1BUF9TSVpFAFNRTElURV9NQVhfQUxMT0NBVElPTl9TSVpFAFNRTElURV9GQ05UTF9DSFVOS19TSVpFAFNRTElURV9TRVNTSU9OX09CSkNPTkZJR19TSVpFAFNRTElURV9DT05GSUdfU09SVEVSUkVGX1NJWkUAU1FMSVRFX1NUQVRVU19QQUdFQ0FDSEVfU0laRQBTUUxJVEVfU1RBVFVTX01BTExPQ19TSVpFAFNRTElURV9DT05GSUdfTUVNREJfTUFYU0laRQBTUUxJVEVfQ09ORklHX1dJTjMyX0hFQVBTSVpFAFNRTElURV9TRVNTSU9OX0NPTkZJR19TVFJNU0laRQBTUUxJVEVfSU9FUlJfU0hNU0laRQBTUUxJVEVfUFJFUEFSRV9OT1JNQUxJWkUAU1FMSVRFX09QRU5fRVhDTFVTSVZFAFNRTElURV9MT0NLX0VYQ0xVU0lWRQBTUUxJVEVfUkVDVVJTSVZFAFNRTElURV9EQkNPTkZJR19ERUZFTlNJVkUAU1FMSVRFX0NPTlNUUkFJTlRfVU5JUVVFAFNRTElURV9JTkRFWF9TQ0FOX1VOSVFVRQAgVU5JUVVFAFNRTElURV9JT0VSUl9XUklURQBTUUxJVEVfVFhOX1dSSVRFAFNRTElURV9EQlNUQVRVU19DQUNIRV9XUklURQBTUUxJVEVfRkNOVExfQ09NTUlUX0FUT01JQ19XUklURQBTUUxJVEVfRkNOVExfQkVHSU5fQVRPTUlDX1dSSVRFAFNRTElURV9GQ05UTF9ST0xMQkFDS19BVE9NSUNfV1JJVEUAU1FMSVRFX0ZDTlRMX09WRVJXUklURQBTUUxJVEVfSU9DQVBfUE9XRVJTQUZFX09WRVJXUklURQBTUUxJVEVfRkNOVExfUE9XRVJTQUZFX09WRVJXUklURQBTUUxJVEVfQUNDRVNTX1JFQURXUklURQBTUUxJVEVfT1BFTl9SRUFEV1JJVEUAU1FMSVRFX0lPRVJSX0RFTEVURQBTUUxJVEVfREVMRVRFAFNRTElURV9GQ05UTF9MT0NLU1RBVEUAU1FMSVRFX09QRU5fQ1JFQVRFAFNRTElURV9VUERBVEUAU1FMSVRFX0lPRVJSX1RSVU5DQVRFAFNRTElURV9NSVNVU0UAJXUtUk9XIFZBTFVFUyBDTEFVU0UAU1FMSVRFX0lPRVJSX0NMT1NFAFNRTElURV9JT0VSUl9ESVJfQ0xPU0UAU1FMSVRFX0RCQ09ORklHX05PX0NLUFRfT05fQ0xPU0UAU1FMSVRFX1RSQUNFX0NMT1NFAFNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UAU1FMSVRFX0RFU0VSSUFMSVpFX0ZSRUVPTkNMT1NFAFJFTEVBU0UATk9DQVNFAFNRTElURV9EQkNPTkZJR19SRVNFVF9EQVRBQkFTRQBTUUxJVEVfSUdOT1JFAEJFRk9SRQBDUkUAU1FMSVRFX1NUTVRTVEFUVVNfUkVQUkVQQVJFAFNRTElURV9SRVNVTFRfU1VCVFlQRQBTUUxJVEVfU1VCVFlQRQBTUUxJVEVfQ09OU1RSQUlOVF9EQVRBVFlQRQBTUUxJVEVfSU5ERVhfQ09OU1RSQUlOVF9ORQBTUUxJVEVfVFhOX05PTkUAU1FMSVRFX0xPQ0tfTk9ORQBTUUxJVEVfRkNOVExfQ0tQVF9ET05FAFNRTElURV9ET05FAFNRTElURV9GQ05UTF9WRlNOQU1FAFNRTElURV9GQ05UTF9URU1QRklMRU5BTUUAU1FMSVRFX0RCQ09ORklHX01BSU5EQk5BTUUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfTEUAU1FMSVRFX0ZDTlRMX0NLU01fRklMRQBTUUxJVEVfRkNOVExfU0VUX0xPQ0tQUk9YWUZJTEUAU1FMSVRFX0ZDTlRMX0dFVF9MT0NLUFJPWFlGSUxFAFNRTElURV9UUkFDRV9QUk9GSUxFAFNRTElURV9GQ05UTF9XSU4zMl9TRVRfSEFORExFAFNRTElURV9GQ05UTF9XSU4zMl9HRVRfSEFORExFAFNRTElURV9EQkNPTkZJR19MRUdBQ1lfQUxURVJfVEFCTEUAU1FMSVRFX0FMVEVSX1RBQkxFAFNRTElURV9EUk9QX1RBQkxFAFNRTElURV9EUk9QX1RFTVBfVEFCTEUAU1FMSVRFX0NSRUFURV9URU1QX1RBQkxFAFNRTElURV9DUkVBVEVfVEFCTEUAU1FMSVRFX0RST1BfVlRBQkxFAFNRTElURV9DUkVBVEVfVlRBQkxFAFNRTElURV9JT0NBUF9JTU1VVEFCTEUAU1FMSVRFX0RFU0VSSUFMSVpFX1JFU0laRUFCTEUAU1FMSVRFX1VURjE2TEUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfTElLRQBTUUxJVEVfRkNOVExfUkVTRVRfQ0FDSEUAT01JVF9TSEFSRURfQ0FDSEUAU1FMSVRFX0NPTkZJR19QQ0FDSEUAU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEUAU1FMSVRFX09QRU5fUFJJVkFURUNBQ0hFAFNRTElURV9DT05GSUdfUEFHRUNBQ0hFAFNRTElURV9PUEVOX1NIQVJFRENBQ0hFAFNRTElURV9MT0NLRURfU0hBUkVEQ0FDSEUAU1FMSVRFX0lOREVYX0NPTlNUUkFJTlRfR0UAU1FMSVRFX1JBTkdFAEVOQUJMRV9SVFJFRQAlcyBVU0lORyBURU1QIEItVFJFRQBTUUxJVEVfSU9FUlJfVk5PREUAU1FMSVRFX09QRU5fRVhSRVNDT0RFAFNRTElURV9DT05GSUdfTE9PS0FTSURFAFNRTElURV9EQkNPTkZJR19MT09LQVNJREUAQ0FTQ0FERQBTUUxJVEVfQ09SUlVQVF9TRVFVRU5DRQBTUUxJVEVfTk9USUNFAFNRTElURV9GQ05UTF9UUkFDRQBTUUxJVEVfQ0hBTkdFU0VUX1JFUExBQ0UAU1FMSVRFX1JFUExBQ0UARG8gSVBLIFJFUExBQ0UAU1FMSVRFX1VURjE2QkUAU1FMSVRFX0NIQU5HRVNFVF9OT1RGT1VORABTUUxJVEVfTk9URk9VTkQAU1FMSVRFX0lPQ0FQX1NBRkVfQVBQRU5EAEFORABTUUxJVEVfU09VUkNFX0lEAFNRTElURV9DT05TVFJBSU5UX1JPV0lEAHVuaXF1ZW5lc3MgY2hlY2sgZm9yIFJPV0lEACBXSVRIT1VUIFJPV0lEAE9JRABTUUxJVEVfQ09ORklHX1NFUklBTElaRUQAU1FMSVRFX0xPQ0tfUkVTRVJWRUQAU1FMSVRFX0ZDTlRMX0hBU19NT1ZFRABTUUxJVEVfUkVBRE9OTFlfREJNT1ZFRABTUUxJVEVfRkNOVExfU1lOQ19PTUlUVEVEAE9NSVRfREVQUkVDQVRFRABTUUxJVEVfU1RBVFVTX01FTU9SWV9VU0VEAFNRTElURV9EQlNUQVRVU19TVE1UX1VTRUQAU1FMSVRFX0RCU1RBVFVTX0NBQ0hFX1VTRUQAU1FMSVRFX1NUQVRVU19QQUdFQ0FDSEVfVVNFRABTUUxJVEVfREJTVEFUVVNfTE9PS0FTSURFX1VTRUQAU1FMSVRFX0RCU1RBVFVTX1NDSEVNQV9VU0VEAFNRTElURV9TVE1UU1RBVFVTX01FTVVTRUQAU1FMSVRFX0xPQ0tfU0hBUkVEAFNRTElURV9EQlNUQVRVU19DQUNIRV9VU0VEX1NIQVJFRABTUUxJVEVfQ09OU1RSQUlOVF9QSU5ORUQAU1FMSVRFX1VURjE2X0FMSUdORUQAU1FMSVRFX0xPQ0tFRABTUUxJVEVfSU9FUlJfQkxPQ0tFRABTUUxJVEVfTUFYX0FUVEFDSEVEAFNRTElURV9MSU1JVF9BVFRBQ0hFRABESVJFQ1RfT1ZFUkZMT1dfUkVBRABTUUxJVEVfSU9FUlJfU0hPUlRfUkVBRABTUUxJVEVfQUNDRVNTX1JFQUQAU1FMSVRFX0lPRVJSX1JFQUQAU1FMSVRFX1RYTl9SRUFEAFNRTElURV9SRUFEAFNRTElURV9DT05GSUdfTVVMVElUSFJFQUQAU1FMSVRFX0NPTkZJR19TSU5HTEVUSFJFQUQAU0VMRUNUICVzIEZST00gJXMgVCBXSEVSRSBULiVRIDw9ID8gQU5EIFQuJVEgPj0gPyBPUkRFUiBCWSBULiVRIERFU0MAU0VMRUNUIGlkeCwgc3RhcnRfYmxvY2ssIGxlYXZlc19lbmRfYmxvY2ssIGVuZF9ibG9jaywgcm9vdCBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPyBPUkRFUiBCWSBpZHggQVNDAFNFTEVDVCBpZHgsIHN0YXJ0X2Jsb2NrLCBsZWF2ZXNfZW5kX2Jsb2NrLCBlbmRfYmxvY2ssIHJvb3QgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID9PUkRFUiBCWSBsZXZlbCBERVNDLCBpZHggQVNDAFNFTEVDVCBsZXZlbCwgaWR4LCBlbmRfYmxvY2sgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID8gT1JERVIgQlkgbGV2ZWwgREVTQywgaWR4IEFTQwBTRUxFQ1QgJXMgRlJPTSAlcyBUIFdIRVJFIFQuJVEgPj0gPyBBTkQgVC4lUSA8PSA/IE9SREVSIEJZIFQuJVEgQVNDAFNFTEVDVCBpZHggRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbD0/IE9SREVSIEJZIDEgQVNDAFNZU1RFTV9NQUxMT0MAU1FMSVRFX0NPTkZJR19TTUFMTF9NQUxMT0MAU1FMSVRFX0NPTkZJR19NQUxMT0MAU1FMSVRFX0NPTkZJR19HRVRNQUxMT0MAU1FMSVRFX0ZDTlRMX1NZTkMAU1FMSVRFX0lPRVJSX0ZTWU5DAFNRTElURV9JT0VSUl9ESVJfRlNZTkMARU5BQkxFX09GRlNFVF9TUUxfRlVOQwBTUUxJVEVfREVURVJNSU5JU1RJQwBTUUxJVEVfSU9FUlJfQ09NTUlUX0FUT01JQwBTUUxJVEVfSU9DQVBfQVRPTUlDAFNRTElURV9JT0VSUl9CRUdJTl9BVE9NSUMAU1FMSVRFX0lPRVJSX1JPTExCQUNLX0FUT01JQwBTUUxJVEVfSU9DQVBfQkFUQ0hfQVRPTUlDAFNRTElURV9JTkRFWF9DT05TVFJBSU5UX0dMT0IAU1FMSVRFX0JMT0IAaWQgSU5URUdFUiBQUklNQVJZIEtFWSwgc3ogQkxPQgBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBibG9jayBCTE9CAFNRTElURV9PUEVOX1RSQU5TSUVOVF9EQgBTUUxJVEVfT1BFTl9URU1QX0RCAFNRTElURV9PUEVOX01BSU5fREIAU1FMSVRFX0ZDTlRMX1BEQgBTUUxJVEVfTk9UQURCAEJCQgBTUUxJVEVfQ09SUlVQVF9WVEFCAFNRTElURV9DT05TVFJBSU5UX1ZUQUIARU5BQkxFX0RCU1RBVF9WVEFCAFNRTElURV9QUkVQQVJFX05PX1ZUQUIARU5BQkxFX0RCUEFHRV9WVEFCAEVOQUJMRV9CWVRFQ09ERV9WVEFCAFNRTElURV9MT0NLRURfVlRBQgBFTkFCTEVfU1RNVFZUQUIAT3V0cHV0IHJvdXRpbmUgZm9yIEIAU1FMSVRFX0NIQU5HRVNFVF9EQVRBAFNRTElURV9JT0VSUl9EQVRBAFNRTElURV9GQ05UTF9QUkFHTUEAU1FMSVRFX1BSQUdNQQBTUUxJVEVfU0NIRU1BAFNRTElURV9EQkNPTkZJR19XUklUQUJMRV9TQ0hFTUEAU1FMSVRFX0RCQ09ORklHX1RSVVNURURfU0NIRU1BAE91dHB1dCByb3V0aW5lIGZvciBBAEAAJXM6ICIlcyIgLSBzaG91bGQgdGhpcyBiZSBhIHN0cmluZyBsaXRlcmFsIGluIHNpbmdsZS1xdW90ZXM/AFVQREFURSBPUiBGQUlMICVRLiclcV9zZWdkaXInIFNFVCBsZXZlbD0tMSxpZHg9PyBXSEVSRSBsZXZlbD0/IEFORCBpZHg9PwBVUERBVEUgJVEuJyVxX3NlZ2RpcicgU0VUIGlkeCA9ID8gV0hFUkUgbGV2ZWw9PyBBTkQgaWR4PT8AJXM9PwBTRUxFQ1QgZGF0YSBGUk9NICVRLiclcV9ub2RlJyBXSEVSRSBub2Rlbm89PwBTRUxFQ1QgJXMgV0hFUkUgcm93aWQ9PwBERUxFVEUgRlJPTSAnJXEnLiclcV9pZHgnIFdIRVJFIHNlZ2lkPT8AU0VMRUNUIHNpemUgRlJPTSAlUS4nJXFfZG9jc2l6ZScgV0hFUkUgZG9jaWQ9PwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcgV0hFUkUgaWQ9PwBTRUxFQ1QgdmFsdWUgRlJPTSAlUS4nJXFfc3RhdCcgV0hFUkUgaWQ9PwBTRUxFQ1Qgc3olcyBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBpZD0/AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBpZD0/AFNFTEVDVCAlcyBGUk9NICVzIFQgV0hFUkUgVC4lUT0/AERFTEVURSBGUk9NICclcScuJyVxX2RhdGEnIFdIRVJFIGlkPj0/IEFORCBpZDw9PwAsPwApIFZBTFVFUyg/ACBBTkQgKD8AIElTID8AREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgQkVUV0VFTiA/IEFORCA/AFNFTEVDVCBtYXgobGV2ZWwpIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgQkVUV0VFTiA/IEFORCA/AERFTEVURSBGUk9NICVRLiclcV9zZWdtZW50cycgV0hFUkUgYmxvY2tpZCBCRVRXRUVOID8gQU5EID8AVVBEQVRFICVRLiclcV9zZWdkaXInIFNFVCBzdGFydF9ibG9jayA9ID8sIHJvb3QgPSA/V0hFUkUgbGV2ZWwgPSA/IEFORCBpZHggPSA/AFNFTEVDVCBpZHgsIHN0YXJ0X2Jsb2NrLCBsZWF2ZXNfZW5kX2Jsb2NrLCBlbmRfYmxvY2ssIHJvb3QgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8gQU5EIGlkeCA9ID8AREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/IEFORCBpZHggPSA/AERFTEVURSBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPwBTRUxFQ1QgY291bnQoKikgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8AU0VMRUNUICVzIFdIRVJFIHJvd2lkID0gPwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcgV0hFUkUgcm93aWQgPSA/AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBkb2NpZCA9ID8ALCA/ADxleHByPgA8Yj4APGI+Li4uPC9iPgAtPj4ALT4Ac2VwYXJhdG9ycz0AdG9rZW5jaGFycz0AYXV0b21lcmdlPQA8AEJFR0lOIElNTUVESUFURTsgQ09NTUlUOwBDUkVBVEUgVEFCTEUgIiV3Ii4iJXdfcGFyZW50Iihub2Rlbm8gSU5URUdFUiBQUklNQVJZIEtFWSxwYXJlbnRub2RlKTsAKTtDUkVBVEUgVEFCTEUgIiV3Ii4iJXdfbm9kZSIobm9kZW5vIElOVEVHRVIgUFJJTUFSWSBLRVksZGF0YSk7AElOU0VSVCBJTlRPICVRLnNxbGl0ZV9tYXN0ZXIgVkFMVUVTKCdpbmRleCcsJVEsJVEsIyVkLCVRKTsAQ1JFQVRFIFRBQkxFIHgodHlwZSBURVhULHNjaGVtYSBURVhULG5hbWUgVEVYVCx3ciBJTlQsc3VicHJvZyBURVhULHN0bXQgSElEREVOKTsAQ1JFQVRFIFRBQkxFIHgoYWRkciBJTlQsb3Bjb2RlIFRFWFQscDEgSU5ULHAyIElOVCxwMyBJTlQscDQgVEVYVCxwNSBJTlQsY29tbWVudCBURVhULHN1YnByb2cgVEVYVCxuZXhlYyBJTlQsbmN5Y2xlIElOVCxzdG10IEhJRERFTik7AENSRUFURSBUQUJMRSAlUS4nJXFfc2VnbWVudHMnKGJsb2NraWQgSU5URUdFUiBQUklNQVJZIEtFWSwgYmxvY2sgQkxPQik7AENSRUFURSBUQUJMRSAlUS4nJXFfZG9jc2l6ZScoZG9jaWQgSU5URUdFUiBQUklNQVJZIEtFWSwgc2l6ZSBCTE9CKTsAQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJVEuJyVxX3N0YXQnKGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIHZhbHVlIEJMT0IpOwBDUkVBVEUgVEFCTEUgJVEuJyVxX3NlZ2RpcicobGV2ZWwgSU5URUdFUixpZHggSU5URUdFUixzdGFydF9ibG9jayBJTlRFR0VSLGxlYXZlc19lbmRfYmxvY2sgSU5URUdFUixlbmRfYmxvY2sgSU5URUdFUixyb290IEJMT0IsUFJJTUFSWSBLRVkobGV2ZWwsIGlkeCkpOwBVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgdGJsX25hbWUgPSAlUSwgbmFtZSA9IENBU0UgV0hFTiB0eXBlPSd0YWJsZScgVEhFTiAlUSBXSEVOIG5hbWUgTElLRSAnc3FsaXRlWF9hdXRvaW5kZXglJScgRVNDQVBFICdYJyAgICAgIEFORCB0eXBlPSdpbmRleCcgVEhFTiAnc3FsaXRlX2F1dG9pbmRleF8nIHx8ICVRIHx8IHN1YnN0cihuYW1lLCVkKzE4KSBFTFNFIG5hbWUgRU5EIFdIRVJFIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlIEFORCAodHlwZT0ndGFibGUnIE9SIHR5cGU9J2luZGV4JyBPUiB0eXBlPSd0cmlnZ2VyJyk7AERFTEVURSBGUk9NICVRLiclcV9kYXRhJztERUxFVEUgRlJPTSAlUS4nJXFfaWR4JzsARFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX3NlZ21lbnRzJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfc2VnZGlyJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfZG9jc2l6ZSc7RFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX3N0YXQnOyVzIERST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9jb250ZW50JzsAQUxURVIgVEFCTEUgJVEuJyVxX2NvbnRlbnQnICBSRU5BTUUgVE8gJyVxX2NvbnRlbnQnOwBEUk9QIFRBQkxFICclcScuJyVxX25vZGUnO0RST1AgVEFCTEUgJyVxJy4nJXFfcm93aWQnO0RST1AgVEFCTEUgJyVxJy4nJXFfcGFyZW50JzsAQUxURVIgVEFCTEUgJVEuJyVxX3N0YXQnICBSRU5BTUUgVE8gJyVxX3N0YXQnOwBBTFRFUiBUQUJMRSAlUS4nJXFfc2VnbWVudHMnIFJFTkFNRSBUTyAnJXFfc2VnbWVudHMnOwBBTFRFUiBUQUJMRSAlUS4nJXFfJXMnIFJFTkFNRSBUTyAnJXFfJXMnOwBBTFRFUiBUQUJMRSAlUS4nJXFfc2VnZGlyJyAgIFJFTkFNRSBUTyAnJXFfc2VnZGlyJzsARFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX2RhdGEnO0RST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9pZHgnO0RST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9jb25maWcnOwBEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfZG9jc2l6ZSc7AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJzsAQUxURVIgVEFCTEUgJVEuJyVxX2RvY3NpemUnICBSRU5BTUUgVE8gJyVxX2RvY3NpemUnOwBBTFRFUiBUQUJMRSAlUS4nJXFfbm9kZScgICBSRU5BTUUgVE8gIiV3X25vZGUiO0FMVEVSIFRBQkxFICVRLiclcV9wYXJlbnQnIFJFTkFNRSBUTyAiJXdfcGFyZW50IjtBTFRFUiBUQUJMRSAlUS4nJXFfcm93aWQnICBSRU5BTUUgVE8gIiV3X3Jvd2lkIjsAOm1lbW9yeToAZmlsZToAOnNlc3Npb25TdG9yYWdlOgA6bG9jYWxTdG9yYWdlOgAtOWU5OTkAOS4wZTk5OQArLSAKCTAxMjM0NTY3ODkAXHUwMDA5AHY4AHV0ZjgAU1FMSVRFX1VURjgATUFYX0ZVTkNUSU9OX0FSRz0xMjcAREVGQVVMVF9TRUNUT1JfU0laRT00MDk2AE1BWF9WQVJJQUJMRV9OVU1CRVI9MzI3NjYATUFYX1BBR0VfU0laRT02NTUzNgBPTUlUX1VURjE2AFNRTElURV9VVEYxNgBmdHM1AHA1AEVOQUJMRV9GVFM1AHRvbyBtYW55IHJlZmVyZW5jZXMgdG8gIiVzIjogbWF4IDY1NTM1AGJtMjUARkxBR1MgcGFyYW1ldGVyIHRvIGpzb25fdmFsaWQoKSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMTUAdjQAc3FsaXRlX3N0YXQ0AGZ0czQAcDQARU5BQkxFX0ZUUzQAREVGQVVMVF9GSUxFX0ZPUk1BVD00AERFRkFVTFRfQ0FDSEVfU0laRT0tMTYzODQAeEN1cnJlbnRUaW1lSW50NjQAcHdyaXRlNjQAcHJlYWQ2NABNQUxMT0NfU09GVF9MSU1JVD0xMDI0AHNxbGl0ZV9zdGF0MwBTQVZFUE9JTlQgZnRzMwBST0xMQkFDSyBUTyBmdHMzAFJFTEVBU0UgZnRzMwBwMwBFTkFCTEVfRlRTMwAuLlAzAHAyAGF0YW4yAGxvZzIAaWYgJXMgZ290byBQMgBTUUxJVEVfQ09ORklHX1BDQUNIRTIAU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEUyAHJlbW92ZV9kaWFjcml0aWNzPTIAREVGQVVMVF9TWU5DSFJPTk9VUz0yAERFRkFVTFRfV0FMX1NZTkNIUk9OT1VTPTIAVEVNUF9TVE9SRT0yAE1BWF9ERUZBVUxUX1BBR0VfU0laRT04MTkyAHJ0cmVlX2kzMgBTUUxJVEVfSU9DQVBfQVRPTUlDNTEyAFNFTEVDVCBzZWdpZCwgdGVybSwgKHBnbm8+PjEpLCAocGdubyYxKSBGUk9NICVRLiclcV9pZHgnIFdIRVJFIHNlZ2lkPSVkIE9SREVSIEJZIDEsIDIAU0VMRUNUIHRibCxpZHgsc3RhdCBGUk9NICVRLnNxbGl0ZV9zdGF0MQBwMQBTRUxFQ1QgcGFyZW50bm9kZSBGUk9NICVRLiclcV9wYXJlbnQnIFdIRVJFIG5vZGVubz0/MQBTRUxFQ1Qgbm9kZW5vIEZST00gJVEuJyVxX3Jvd2lkJyBXSEVSRSByb3dpZD0/MQBTRUxFQ1QgKiBGUk9NICIldyIuIiV3X3Jvd2lkIiBXSEVSRSByb3dpZD0/MQBTRUxFQ1QgcGFyZW50bm9kZSBGUk9NICclcScuJyVxX3BhcmVudCcgV0hFUkUgbm9kZW5vID0gPzEAREVMRVRFIEZST00gJyVxJy4nJXFfcGFyZW50JyBXSEVSRSBub2Rlbm8gPSA/MQBERUxFVEUgRlJPTSAnJXEnLiclcV9ub2RlJyBXSEVSRSBub2Rlbm8gPSA/MQBTRUxFQ1Qgbm9kZW5vIEZST00gJyVxJy4nJXFfcm93aWQnIFdIRVJFIHJvd2lkID0gPzEAREVMRVRFIEZST00gJyVxJy4nJXFfcm93aWQnIFdIRVJFIHJvd2lkID0gPzEAcmVtb3ZlX2RpYWNyaXRpY3M9MQBBVE9NSUNfSU5UUklOU0lDUz0xAHVuaWNvZGU2MQBVUERBVEUgT1IgRkFJTCAlUS4nJXFfc2VnZGlyJyBTRVQgbGV2ZWw9PyBXSEVSRSBsZXZlbD0tMQBERUZBVUxUX0pPVVJOQUxfU0laRV9MSU1JVD0tMQAiU1FMSVRFX1NUQVRJQyI6MCwgIlNRTElURV9UUkFOU0lFTlQiOi0xACsxAFNFTEVDVCBwZ25vIEZST00gJyVxJy4nJXFfaWR4JyBXSEVSRSBzZWdpZD0/IEFORCB0ZXJtPD0/IE9SREVSIEJZIHRlcm0gREVTQyBMSU1JVCAxAFNFTEVDVCBsZXZlbCwgY291bnQoKikgQVMgY250IEZST00gJVEuJyVxX3NlZ2RpcicgICBHUk9VUCBCWSBsZXZlbCBIQVZJTkcgY250Pj0/ICBPUkRFUiBCWSAobGV2ZWwgJSUgMTAyNCkgQVNDLCAyIERFU0MgTElNSVQgMQBTRUxFQ1QgcGdubyBGUk9NICclcScuJyVxX2lkeCcgV0hFUkUgc2VnaWQ9PyBBTkQgdGVybT4/IE9SREVSIEJZIHRlcm0gQVNDIExJTUlUIDEAUFJBR01BIGRlZmVyX2ZvcmVpZ25fa2V5cyA9IDEAU0VMRUNUIGxlbmd0aChkYXRhKSBGUk9NICclcScuJyVxX25vZGUnIFdIRVJFIG5vZGVubyA9IDEALCAxAFNFTEVDVCAoU0VMRUNUIG1heChpZHgpIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/KSArIDEAU0VMRUNUJ0lOU0VSVCBJTlRPIHZhY3V1bV9kYi4nfHxxdW90ZShuYW1lKXx8JyBTRUxFQ1QqRlJPTSIldyIuJ3x8cXVvdGUobmFtZSlGUk9NIHZhY3V1bV9kYi5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGU9J3RhYmxlJ0FORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0ndGFibGUnQU5EIG5hbWU8PidzcWxpdGVfc2VxdWVuY2UnIEFORCBjb2FsZXNjZShyb290cGFnZSwxKT4wAHJlbW92ZV9kaWFjcml0aWNzPTAAY29udGVudGxlc3NfZGVsZXRlPTEgaXMgaW5jb21wYXRpYmxlIHdpdGggY29sdW1uc2l6ZT0wAERRUz0wAE1BWF9XT1JLRVJfVEhSRUFEUz0wAERFRkFVTFRfV09SS0VSX1RIUkVBRFM9MABNQVhfTU1BUF9TSVpFPTAAREVGQVVMVF9NTUFQX1NJWkU9MABUSFJFQURTQUZFPTAAOTIyMzM3MjAzNjg1NDc3NTgwAERFRkFVTFRfUENBQ0hFX0lOSVRTWj0yMABsb2cxMABNQVhfQVRUQUNIRUQ9MTAAXHUwMABNQVhfQ09NUE9VTkRfU0VMRUNUPTUwMABNQVhfQ09MVU1OPTIwMDAAREVGQVVMVF9XQUxfQVVUT0NIRUNLUE9JTlQ9MTAwMABNQVhfRVhQUl9ERVBUSD0xMDAwAE1BWF9UUklHR0VSX0RFUFRIPTEwMDAAXHUwMDAwAE1BWF9MSUtFX1BBVFRFUk5fTEVOR1RIPTUwMDAwAE1BWF9WREJFX09QPTI1MDAwMDAwMABNQVhfTEVOR1RIPTEwMDAwMDAwMDAATUFYX1NRTF9MRU5HVEg9MTAwMDAwMDAwMABzZWNvbmQgYXJndW1lbnQgdG8gJSNUKCkgbXVzdCBiZSBhIGNvbnN0YW50IGJldHdlZW4gMC4wIGFuZCAxLjAAQ09NUElMRVI9Y2xhbmctMTYuMC4wAFBSQUdNQSBkZWZlcl9mb3JlaWduX2tleXMgPSAwAFNFTEVDVCAwLCAndGJsJywgICcnLCAwLCAnJywgMSAgICAgVU5JT04gQUxMIFNFTEVDVCAxLCAnaWR4JywgICcnLCAwLCAnJywgMiAgICAgVU5JT04gQUxMIFNFTEVDVCAyLCAnc3RhdCcsICcnLCAwLCAnJywgMAAlcyUuM3gvAC9wcm9jL3NlbGYvZmQvAElOU0VSVCBJTlRPIG1haW4uAERFTEVURSBGUk9NIG1haW4uAFVQREFURSBtYWluLgAlUS4ATi4ALS0AIm5hbWUiOiAic3FsaXRlM19pbmRleF9vcmRlcmJ5IiwAIm5hbWUiOiAic3FsaXRlM19pbmRleF9jb25zdHJhaW50IiwAIm5hbWUiOiAiV2FzbVRlc3RTdHJ1Y3QiLAAibmFtZSI6ICJzcWxpdGUzX3ZmcyIsACJuYW1lIjogInNxbGl0ZTNfa3Z2ZnNfbWV0aG9kcyIsACJuYW1lIjogInNxbGl0ZTNfaW9fbWV0aG9kcyIsACJuYW1lIjogInNxbGl0ZTNfdnRhYl9jdXJzb3IiLAAibmFtZSI6ICJzcWxpdGUzX2luZGV4X2luZm8iLAAibmFtZSI6ICJzcWxpdGUzX21vZHVsZSIsACJuYW1lIjogInNxbGl0ZTNfZmlsZSIsACJuYW1lIjogInNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZSIsACJuYW1lIjogInNxbGl0ZTNfdnRhYiIsAG5vc2tpcHNjYW4qAHVub3JkZXJlZCoAc3o9WzAtOV0qAF9yb3dpZF8sICoAU0VMRUNUICVzLCVzIEZST00gIiV3Ii4iJXciLCAiJXciLiIldyIgV0hFUkUgJXMgQU5EICgleikAIEFORCAoPyVkIE9SID8lZCBJUyAldy4ldykAKHN1YnF1ZXJ5LSV1KQAoam9pbi0ldSkAQmFkIHB0ciBtYXAgZW50cnkga2V5PSV1IGV4cGVjdGVkPSgldSwldSkgZ290PSgldSwldSkAbWF4IHJvb3RwYWdlICgldSkgZGlzYWdyZWVzIHdpdGggaGVhZGVyICgldSkAQ1JFQVRFIFRBQkxFIHgodHlwZSB0ZXh0LG5hbWUgdGV4dCx0YmxfbmFtZSB0ZXh0LHJvb3RwYWdlIGludCxzcWwgdGV4dCkAQ1JFQVRFIFRBQmxFIHZvY2FiKHRlcm0sIGRvYywgY250KQBDUkVBVEUgVEFCbEUgdm9jYWIodGVybSwgY29sLCBkb2MsIGNudCkAQ1JFQVRFIFRBQmxFIHZvY2FiKHRlcm0sIGRvYywgY29sLCBvZmZzZXQpACBBTkQgKD82IE9SID8zIElTIHN0YXQpAGkoc3NzKQBpKHNzKQBpKHBzKQBOb2RlICVsbGQgaXMgdG9vIHNtYWxsICglZCBieXRlcykATm9kZSAlbGxkIGlzIHRvbyBzbWFsbCBmb3IgY2VsbCBjb3VudCBvZiAlZCAoJWQgYnl0ZXMpAGkocykAUkVQTEFDRSBJTlRPICVRLiclcV9kb2NzaXplJyBWQUxVRVMoPyw/JXMpAHJ0cmVlIGNvbnN0cmFpbnQgZmFpbGVkOiAlcy4oJXM8PSVzKQBDUkVBVEUgVEFCTEUgJVEuJXMoJXMpAGF1dG9tYXRpYyBpbmRleCBvbiAlcyglcykAQU5ZKCVzKQBJTlNFUlQgSU5UTyAlUS4nJXFfY29udGVudCcgVkFMVUVTKCVzKQBSRVBMQUNFIElOVE8gJVEuJyVxX2NvbnRlbnQnIFZBTFVFUyglcykAQ1JFQVRFIFRBQkxFICVRLiclcV9jb250ZW50JyglcykAbWFsZm9ybWVkIGRhdGFiYXNlIHNjaGVtYSAoJXMpAFNFTEVDVCAlcyVzIEZST00gJVEuJVEgV0hFUkUgKCVzKSBJUyAoJXMpAE1FUkdFICglcykAU3RhcnQ6ICVzLiVzICglcyAlcyVzJXMgT04gJXMpAFNFTEVDVCAlcyBGUk9NICIldyIuIiV3IiBXSEVSRSBOT1QgRVhJU1RTICggIFNFTEVDVCAxIEZST00gIiV3Ii4iJXciIFdIRVJFICVzKQBDUkVBVEUgVEFCTEUgJVEuc3FsaXRlX3NlcXVlbmNlKG5hbWUsc2VxKQBpKHBpc3BwKQBpKHBwaXBwcCkAaShwcHApAGkocGlwcCkAdihwcCkAcChwcCkAaShwcCkAaShwanApAGkocGlzaXApAGkocHBwaXApAGkocHBpcCkAcChwaXApAGkocGlwKQBpKHBqaXApAGkocGlpaXApAHYocCkAaShwKQBDUkVBVEUgVEFCTEUgeChpbnB1dCwgdG9rZW4sIHN0YXJ0LCBlbmQsIHBvc2l0aW9uKQBzZWdpZCwgdGVybSwgcGdubywgUFJJTUFSWSBLRVkoc2VnaWQsIHRlcm0pAENSRUFURSBUQUJMRSB4KHNxbCxuY29sLHJvLGJ1c3ksbnNjYW4sbnNvcnQsbmFpZHgsbnN0ZXAscmVwcmVwLHJ1bixtZW0pAChudWxsKQBmdHM1OiAlcyBxdWVyaWVzIGFyZSBub3Qgc3VwcG9ydGVkIChkZXRhaWwhPWZ1bGwpAGkocGopAGkocHBpaikAaShzc3BpKQBpKHBwaSkAaShwaSkAaShwaWlpKQBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfZHJvcF9jb2x1bW4oJWQsIHNxbCwgJWQpIFdIRVJFICh0eXBlPT0ndGFibGUnIEFORCB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSkAZnRzNTogY29sdW1uIHF1ZXJpZXMgYXJlIG5vdCBzdXBwb3J0ZWQgKGRldGFpbD1ub25lKQBtZW1kYiglcCwlbGxkKQBGb3VuZCAoJWxsZCAtPiAlbGxkKSBpbiAlcyB0YWJsZSwgZXhwZWN0ZWQgKCVsbGQgLT4gJWxsZCkAJXMoJWQpACVzLmV4cHIoJWQpAGZpcnN0X2VudHJ5X2luKCVkKQB6ZXJvYmxvYiglZCkAUnRyZWUgZGVwdGggb3V0IG9mIHJhbmdlICglZCkAdG9vIG1hbnkgcHJlZml4IGluZGV4ZXMgKG1heCAlZCkARlRTIGV4cHJlc3Npb24gdHJlZSBpcyB0b28gbGFyZ2UgKG1heGltdW0gZGVwdGggJWQpAGZ0czUgZXhwcmVzc2lvbiB0cmVlIGlzIHRvbyBsYXJnZSAobWF4aW11bSBkZXB0aCAlZCkARXhwcmVzc2lvbiB0cmVlIGlzIHRvbyBsYXJnZSAobWF4aW11bSBkZXB0aCAlZCkAKGJsb2IpAFVTRSBURU1QIEItVFJFRSBGT1IgJXMoT1JERVIgQlkpAFVTRSBURU1QIEItVFJFRSBGT1IgJXMoRElTVElOQ1QpAFVQREFURSAiJXciLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfY29sdW1uKHNxbCwgdHlwZSwgbmFtZSwgJVEsICVRLCAlZCwgJVEsICVkLCAlZCkgV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyAgQU5EICh0eXBlICE9ICdpbmRleCcgT1IgdGJsX25hbWUgPSAlUSkAQ1JFQVRFIFRBQkxFIHgoa2V5LHZhbHVlLHR5cGUsYXRvbSxpZCxwYXJlbnQsZnVsbGtleSxwYXRoLGpzb24gSElEREVOLHJvb3QgSElEREVOKQAleiwgJVEgSElEREVOLCAlcyBISURERU4pAENSRUFURSBUQUJMRSB4KHRlcm0sIGNvbCwgZG9jdW1lbnRzLCBvY2N1cnJlbmNlcywgbGFuZ3VhZ2VpZCBISURERU4pAENSRUFURSBUQUJMRSB4KHBnbm8gSU5URUdFUiBQUklNQVJZIEtFWSwgZGF0YSBCTE9CLCBzY2hlbWEgSElEREVOKQBDUkVBVEUgVEFCTEUgeCglcyAlUSBISURERU4sIGRvY2lkIEhJRERFTiwgJVEgSElEREVOKQAoTlVMTCkAKEZLKQA/MSwgKENBU0UgV0hFTiA/Mj1YJycgVEhFTiBOVUxMIEVMU0UgPzIgRU5EKQAlYz8pAFNFTEVDVCBOT1QgRVhJU1RTKFNFTEVDVCBkb2NpZCBGUk9NICVRLiclcV9jb250ZW50JyBXSEVSRSByb3dpZCE9PykAUkVQTEFDRSBJTlRPICVRLiclcV9zZWdkaXInIFZBTFVFUyg/LD8sPyw/LD8sPykASU5TRVJUIElOVE8gJyVxJy4nJXFfaWR4JyhzZWdpZCx0ZXJtLHBnbm8pIFZBTFVFUyg/LD8sPykAUkVQTEFDRSBJTlRPICclcScuJyVxX2RhdGEnKGlkLCBibG9jaykgVkFMVUVTKD8sPykAUkVQTEFDRSBJTlRPICVRLiclcV9zdGF0JyBWQUxVRVMoPyw/KQBSRVBMQUNFIElOVE8gJVEuJyVxX2NvbmZpZycgVkFMVUVTKD8sPykAUkVQTEFDRSBJTlRPICVRLiclcV9kb2NzaXplJyBWQUxVRVMoPyw/KQAsJXMoPykAUkVQTEFDRSBJTlRPICVRLiclcV9zZWdtZW50cycoYmxvY2tpZCwgYmxvY2spIFZBTFVFUyg/LCA/KQBwcmVmaXggbGVuZ3RoIG91dCBvZiByYW5nZSAobWF4IDk5OSkAREVMRVRFIEZST00gbWFpbi5zcWxpdGVfc3RhdDEgV0hFUkUgdGJsPT8xIEFORCBpZHggSVMgQ0FTRSBXSEVOIGxlbmd0aCg/Mik9MCBBTkQgdHlwZW9mKD8yKT0nYmxvYicgVEhFTiBOVUxMIEVMU0UgPzIgRU5EIEFORCAoPzQgT1Igc3RhdCBJUyA/MykASU5TRVJUIElOVE8gbWFpbi5zcWxpdGVfc3RhdDEgVkFMVUVTKD8xLCBDQVNFIFdIRU4gbGVuZ3RoKD8yKT0wIEFORCB0eXBlb2YoPzIpPSdibG9iJyBUSEVOIE5VTEwgRUxTRSA/MiBFTkQsID8zKQBJTlNFUlQgT1IgUkVQTEFDRSBJTlRPICclcScuJyVxX3BhcmVudCcgVkFMVUVTKD8xLCA/MikASU5TRVJUIE9SIFJFUExBQ0UgSU5UTyAnJXEnLiclcV9ub2RlJyBWQUxVRVMoPzEsID8yKQBJTlNFUlQgT1IgUkVQTEFDRSBJTlRPICclcScuJyVxX3Jvd2lkJyBWQUxVRVMoPzEsID8yKQBERUxFVEUgRlJPTSAnJXEnLiclcV9pZHgnIFdIRVJFIChzZWdpZCwgKHBnbm8vMikpID0gKD8xLCA/MikAU0VMRUNUIGNvYWxlc2NlKChTRUxFQ1QgbWF4KGJsb2NraWQpIEZST00gJVEuJyVxX3NlZ21lbnRzJykgKyAxLCAxKQBJTlNFUlQgSU5UTyB2YWN1dW1fZGIuc3FsaXRlX3NjaGVtYSBTRUxFQ1QqRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZSBJTigndmlldycsJ3RyaWdnZXInKSBPUih0eXBlPSd0YWJsZSdBTkQgcm9vdHBhZ2U9MCkAU0VMRUNUICogRlJPTSAoU0VMRUNUICdzcWxpdGVfc2NoZW1hJyBBUyBuYW1lLDEgQVMgcm9vdHBhZ2UsJ3RhYmxlJyBBUyB0eXBlIFVOSU9OIEFMTCBTRUxFQ1QgbmFtZSxyb290cGFnZSx0eXBlIEZST00gIiV3Ii5zcWxpdGVfc2NoZW1hIFdIRVJFIHJvb3RwYWdlIT0wKQBJTlNFUlQgSU5UTyAiJXciLiIld19ub2RlIlZBTFVFUygxLHplcm9ibG9iKCVkKSkAd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBoaWdobGlnaHQoKQB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIHNuaXBwZXQoKQBtaXN1c2Ugb2Ygc3FsaXRlM19yZXN1bHRfc3VidHlwZSgpIGJ5ICVzKCkAbWlzdXNlIG9mIGFnZ3JlZ2F0ZTogJXMoKQBwKCkAd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBydHJlZWNoZWNrKCkASW52YWxpZCBhcmd1bWVudCB0byBydHJlZWRlcHRoKCkAbWlzdXNlIG9mICVzIGZ1bmN0aW9uICUjVCgpAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJSNUKCkAdW5zYWZlIHVzZSBvZiAlI1QoKQBPUkRFUiBCWSBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAEZJTFRFUiBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAHVua25vd24gZnVuY3Rpb246ICUjVCgpAG1pc3VzZSBvZiBhZ2dyZWdhdGU6ICUjVCgpAGFtYmlndW91cyByZWZlcmVuY2UgdG8gJXMgaW4gVVNJTkcoKQBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX2NvbHVtbihzcWwsIHR5cGUsIG5hbWUsICVRLCAlUSwgJWQsICVRLCAlZCwgMSkgV0hFUkUgdHlwZSBJTiAoJ3RyaWdnZXInLCAndmlldycpAFVQREFURSBzcWxpdGVfdGVtcF9zY2hlbWEgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfdGFibGUoJVEsIHR5cGUsIG5hbWUsIHNxbCwgJVEsICVRLCAxKSwgdGJsX25hbWUgPSBDQVNFIFdIRU4gdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UgQU5EICAgc3FsaXRlX3JlbmFtZV90ZXN0KCVRLCBzcWwsIHR5cGUsIG5hbWUsIDEsICdhZnRlciByZW5hbWUnLCAwKSBUSEVOICVRIEVMU0UgdGJsX25hbWUgRU5EIFdIRVJFIHR5cGUgSU4gKCd2aWV3JywgJ3RyaWdnZXInKQAsJXMoeC4nYyVkJXEnKQBQUkFHTUEgJyVxJy50YWJsZV9pbmZvKCclcScpAElOU0VSVCBJTlRPICVRLnNxbGl0ZV9tYXN0ZXIgVkFMVUVTKCd0cmlnZ2VyJywlUSwlUSwwLCdDUkVBVEUgVFJJR0dFUiAlcScpAElOU0VSVCBJTlRPICVRLiVRKCVRKSBWQUxVRVMoJ2ZsdXNoJykAU0VMRUNUIDIgKiB0b3RhbCgxICsgbGVhdmVzX2VuZF9ibG9jayAtIHN0YXJ0X2Jsb2NrKSAgIEZST00gKFNFTEVDVCAqIEZST00gJVEuJyVxX3NlZ2RpcicgICAgICAgICBXSEVSRSBsZXZlbCA9ID8gT1JERVIgQlkgaWR4IEFTQyBMSU1JVCA/ICApAAopAENSRUFURSBUQUJMRSB4KABCTE9PTSBGSUxURVIgT04gJVMgKABTRUxFQ1Qgc3FsIEZST00gIiV3Ii5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGU9J2luZGV4JwBERUxFVEUgRlJPTSAlUS5zcWxpdGVfbWFzdGVyIFdIRVJFIG5hbWU9JVEgQU5EIHR5cGU9J2luZGV4JwBuYW1lPSclcScgQU5EIHR5cGU9J2luZGV4JwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcAREVMRVRFIEZST00gJVEuJyVxX3N0YXQnAERFTEVURSBGUk9NICVRLiclcV9zZWdtZW50cycAU0VMRUNUIGNvdW50KCopIEZST00gJVEuJyVxJXMnAFNFTEVDVCBjb3VudCgqKSBGUk9NICVRLiclcV8lcycAREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicAU0VMRUNUID8gVU5JT04gU0VMRUNUIGxldmVsIC8gKDEwMjQgKiA/KSBGUk9NICVRLiclcV9zZWdkaXInAFNFTEVDVCBtYXgoIGxldmVsICUlIDEwMjQgKSBGUk9NICVRLiclcV9zZWdkaXInAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0ndHJpZ2dlcicAREVMRVRFIEZST00gJVEuc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0lUSBhbmQgdHlwZSE9J3RyaWdnZXInAHRibF9uYW1lPSclcScgQU5EIHR5cGUhPSd0cmlnZ2VyJwAnJS4qcScAJXosICdjJWQlcScAdHlwZT0ndHJpZ2dlcicgQU5EIG5hbWU9JyVxJwAsIHguJyVxJwBpbmRleCAnJXEnAFNFTEVDVCBrLCB2IEZST00gJVEuJyVxX2NvbmZpZycAREVMRVRFIEZST00gJVEuJyVxX2RvY3NpemUnAGludmFsaWQgZnRzNSBmaWxlIGZvcm1hdCAoZm91bmQgJWQsIGV4cGVjdGVkICVkIG9yICVkKSAtIHJ1biAncmVidWlsZCcAU0VMRUNUICogRlJPTSAlUS4nJXFfcm93aWQnAFNFTEVDVCBzdGF0IEZST00gJVEuc3FsaXRlX3N0YXQxIFdIRVJFIHRibCA9ICclcV9yb3dpZCcAU0VMRUNUIHQuJVEgRlJPTSAlUS4lUSBBUyB0IFdIRVJFIHQuJVEgTUFUQ0ggJyppZCcAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV90YWJsZSglUSwgdHlwZSwgbmFtZSwgc3FsLCAlUSwgJVEsICVkKSBXSEVSRSAodHlwZSE9J2luZGV4JyBPUiB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSlBTkQgICBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnAFNFTEVDVCBDQVNFIFdIRU4gcXVpY2tfY2hlY2sgR0xPQiAnQ0hFQ0sqJyBUSEVOIHJhaXNlKEFCT1JULCdDSEVDSyBjb25zdHJhaW50IGZhaWxlZCcpIFdIRU4gcXVpY2tfY2hlY2sgR0xPQiAnbm9uLSogdmFsdWUgaW4qJyBUSEVOIHJhaXNlKEFCT1JULCd0eXBlIG1pc21hdGNoIG9uIERFRkFVTFQnKSBFTFNFIHJhaXNlKEFCT1JULCdOT1QgTlVMTCBjb25zdHJhaW50IGZhaWxlZCcpIEVORCAgRlJPTSBwcmFnbWFfcXVpY2tfY2hlY2soJVEsJVEpIFdIRVJFIHF1aWNrX2NoZWNrIEdMT0IgJ0NIRUNLKicgT1IgcXVpY2tfY2hlY2sgR0xPQiAnTlVMTConIE9SIHF1aWNrX2NoZWNrIEdMT0IgJ25vbi0qIHZhbHVlIGluKicAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9xdW90ZWZpeCglUSwgc3FsKVdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScAVVBEQVRFIHRlbXAuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9xdW90ZWZpeCgndGVtcCcsIHNxbClXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnIEFORCBzcWwgTk9UIExJS0UgJ2NyZWF0ZSB2aXJ0dWFsJSUnAHNxbGl0ZVxfJQAkAFNFTEVDVCpGUk9NIiV3IgBTRUxFQ1QqRlJPTSIldyIuIiV3IgAleiVzIiV3Ii4iJXciLiIldyIAJXolcyIldyIuIiV3Ii4iJXciPSIldyIuIiV3Ii4iJXciACV6JXMiJXciLiIldyIuIiV3IiBJUyBOT1QgIiV3Ii4iJXciLiIldyIAU0VMRUNUIHJhaXNlKEFCT1JULCVRKSBGUk9NICIldyIuIiV3IgBBTkFMWVpFICIldyIuIiV3IgBmb3JlaWduIGtleSBtaXNtYXRjaCAtICIldyIgcmVmZXJlbmNpbmcgIiV3IgBkb3VibGUtcXVvdGVkIHN0cmluZyBsaXRlcmFsOiAiJXciAGZ0czU6IHN5bnRheCBlcnJvciBuZWFyICIlLjFzIgAuIiUuKnMiAGV4cGVjdGVkIGludGVnZXIsIGdvdCAiJS4qcyIAZnRzNTogc3ludGF4IGVycm9yIG5lYXIgIiUuKnMiAHN5bnRheCBlcnJvciBhZnRlciBjb2x1bW4gbmFtZSAiJS4qcyIAdW5yZWNvZ25pemVkIG9wdGlvbjogIiUuKnMiACVjIiVzIgAoIiVzIgBjYW5ub3QgJXMgJXMgIiVzIgBnZW5lcmF0ZWQgY29sdW1uIGxvb3Agb24gIiVzIgBjYW5ub3QgSU5TRVJUIGludG8gZ2VuZXJhdGVkIGNvbHVtbiAiJXMiAGVycm9yIGluIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgBjYW5ub3QgVVBEQVRFIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgAlcyBpbiAiJXMiAHBhcnNlIGVycm9yIGluICIlcyIAdHJpZ2dlciAiJXMiIG1heSBub3Qgd3JpdGUgdG8gc2hhZG93IHRhYmxlICIlcyIAVVBTRVJUIG5vdCBpbXBsZW1lbnRlZCBmb3IgdmlydHVhbCB0YWJsZSAiJXMiAHVuc2FmZSB1c2Ugb2YgdmlydHVhbCB0YWJsZSAiJXMiAGNhbm5vdCBjcmVhdGUgYSBURU1QIGluZGV4IG9uIG5vbi1URU1QIHRhYmxlICIlcyIAbm8gc3VjaCBpbmRleDogIiVzIgB1bmtub3duIGRhdGF0eXBlIGZvciAlcy4lczogIiVzIgBjYW5ub3QgZHJvcCAlcyBjb2x1bW46ICIlcyIAbm8gc3VjaCBjb2x1bW46ICIlcyIAdW5yZWNvZ25pemVkIHRva2VuOiAiJXMiACVzIiVzIjogIiVzIgB1bmRlcnNpemUgUlRyZWUgYmxvYnMgaW4gIiVxX25vZGUiAFwiAG5vIHN1Y2ggY29sdW1uOiAiJVQiAHVucmVjb2duaXplZCB0b2tlbjogIiVUIgAuIgB3ZWVrZGF5IABub24tdW5pcXVlIGVudHJ5IGluIGluZGV4IAB3cm9uZyAjIG9mIGVudHJpZXMgaW4gaW5kZXggACB2YWx1ZXMgZGlmZmVyIGZyb20gaW5kZXggACBtaXNzaW5nIGZyb20gaW5kZXggACBvZiBpbmRleCAAcm93aWQgbm90IGF0IGVuZC1vZi1yZWNvcmQgZm9yIHJvdyAAJXIgAHN0YXJ0IG9mIAAlZCAlZCAlZCAlZCAAIFVTSU5HIENPVkVSSU5HIElOREVYIABVUERBVEUgIiV3Ii4iJXdfcm93aWQiU0VUIAAgU0VU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AwAAAEAAAOsDAAAAAAQA9wMAAAAAAIDsAwAAAABAAO0DAAAAAAEA7gMAAAAIAADvAwAAAACAAPADAAAAAAAB8QMAAAAAAALyAwAAAAAAEPMDAAABAAAI9AMAAAAAAAT2AwAAAAAAIPUDAAAAAABA+AMAAAIAAAD5AwAAgAAAAPoDAAAABAAA+wMAAAAQAAAAypo7AMqaO9AHAADoAwAA9AEAAICy5g5/AAAACgAAAFDDAAD+fwAA6AMAAAAAAAD///////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0OD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2dUF+SChY9cAQfCzAwuUH1NRTGl0ZSBmb3JtYXQgMwBCSU5BUlkAU2F2ZXBvaW50AABBdXRvQ29tbWl0AABUcmFuc2FjdGlvbgAAQ2hlY2twb2ludAAASm91cm5hbE1vZGUAAFZhY3V1bQAAVkZpbHRlcgBpcGxhbj1yW1AzXSB6cGxhbj0nUDQnAFZVcGRhdGUAZGF0YT1yW1AzQFAyXQBJbml0AFN0YXJ0IGF0IFAyAEdvdG8AAEdvc3ViAABJbml0Q29yb3V0aW5lAABZaWVsZAAATXVzdEJlSW50AABKdW1wAABPbmNlAABJZgAASWZOb3QAAElzVHlwZQBpZiB0eXBlb2YoUDEuUDMpIGluIFA1IGdvdG8gUDIATm90AHJbUDJdPSAhcltQMV0ASWZOdWxsUm93AGlmIFAxLm51bGxSb3cgdGhlbiByW1AzXT1OVUxMLCBnb3RvIFAyAFNlZWtMVABrZXk9cltQM0BQNF0AU2Vla0xFAGtleT1yW1AzQFA0XQBTZWVrR0UAa2V5PXJbUDNAUDRdAFNlZWtHVABrZXk9cltQM0BQNF0ASWZOb3RPcGVuAGlmKCAhY3NyW1Ax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Ml0tcltQMV0ATXVsdGlwbHkAcltQM109cltQMV0qcltQMl0ARGl2aWRlAHJbUDNdPXJbUDJdL3JbUDFdAFJlbWFpbmRlcgByW1AzXT1yW1AyXSVyW1AxXQBDb25jYXQAcltQM109cltQMl0rcltQMV0AT3BlblJlYWQAcm9vdD1QMiBpRGI9UDMAT3BlbldyaXRlAHJvb3Q9UDIgaURiPVAzAEJpdE5vdAByW1AyXT0gfnJbUDFdAE9wZW5EdXAAAE9wZW5BdXRvaW5kZXgAbkNvbHVtbj1QMgBTdHJpbmc4AHJbUDJdPSdQNCcAT3BlbkVwaGVtZXJhbABuQ29sdW1uPVAyAFNvcnRlck9wZW4AAFNlcXVlbmNlVGVzdABpZiggY3Vyc29yW1AxXS5jdHIrKyApIHBjID0gUDIAT3BlblBzZXVkbwBQMyBjb2x1bW5zIGluIHJbUDJdAENsb3NlAABDb2x1bW5zVXNlZAAAU2Vla1NjYW4AU2Nhbi1haGVhZCB1cCB0byBQMSByb3dzAFNlZWtIaXQAc2V0IFAyPD1zZWVrSGl0PD1QMwBTZXF1ZW5jZQByW1AyXT1jdXJzb3JbUDFdLmN0cisrAE5ld1Jvd2lkAHJbUDJdPXJvd2lkAEluc2VydABpbnRrZXk9cltQM10gZGF0YT1yW1AyXQBSb3dDZWxsAABEZWxldGUAAFJlc2V0Q291bnQAAFNvcnRlckNvbXBhcmUAaWYga2V5KFAxKSE9dHJpbShyW1AzXSxQNCkgZ290byBQMgBTb3J0ZXJEYXRhAHJbUDJdPWRhdGEAUm93RGF0YQByW1AyXT1kYXRhAFJvd2lkAHJbUDJdPVBYIHJvd2lkIG9mIFAxAE51bGxSb3cAAFNlZWtFbmQAAElkeEluc2VydABrZXk9cltQMl0AU29ydGVySW5zZXJ0AGtleT1yW1AyXQBJZHhEZWxldGUAa2V5PXJbUDJAUDNdAERlZmVycmVkU2VlawBNb3ZlIFAzIHRvIFAxLnJvd2lkIGlmIG5lZWRlZABJZHhSb3dpZAByW1AyXT1yb3dpZABGaW5pc2hTZWVrAABEZXN0cm95AABDbGVhcgAAUmVzZXRTb3J0ZXIAAENyZWF0ZUJ0cmVlAHJbUDJdPXJvb3QgaURiPVAxIGZsYWdzPVAzAFNxbEV4ZWMAAFBhcnNlU2NoZW1hAABMb2FkQW5hbHlzaXMAAERyb3BUYWJsZQAARHJvcEluZGV4AABSZWFsAHJbUDJdPVA0AERyb3BUcmlnZ2VyAABJbnRlZ3JpdHlDawAAUm93U2V0QWRkAHJvd3NldChQMSk9cltQMl0AUGFyYW0AAEZrQ291bnRlcgBma2N0cltQMV0rPVAyAE1lbU1heAByW1AxXT1tYXgocltQMV0scltQMl0pAE9mZnNldExpbWl0AGlmIHJbUDFdPjAgdGhlbiByW1AyXT1yW1AxXSttYXgoMCxyW1AzXSkgZWxzZSByW1AyXT0oLTEpAEFnZ0ludmVyc2UAYWNjdW09cltQM10gaW52ZXJzZShyW1AyQFA1XSkAQWdnU3RlcABhY2N1bT1yW1AzXSBzdGVwKHJbUDJAUDVdKQBBZ2dTdGVwMQBhY2N1bT1yW1AzXSBzdGVwKHJbUDJAUDVdKQBBZ2dWYWx1ZQByW1AzXT12YWx1ZSBOPVAyAEFnZ0ZpbmFsAGFjY3VtPXJbUDFdIE49UDIARXhwaXJlAABDdXJzb3JMb2NrAABDdXJzb3JVbmxvY2sAAFRhYmxlTG9jawBpRGI9UDEgcm9vdD1QMiB3cml0ZT1QMwBWQmVnaW4AAFZDcmVhdGUAAFZEZXN0cm95AABWT3BlbgAAVkNoZWNrAABWSW5pdEluAHJbUDJdPVZhbHVlTGlzdChQMSxQMykAVkNvbHVtbgByW1AzXT12Y29sdW1uKFAyKQBWUmVuYW1lAABQYWdlY291bnQAAE1heFBnY250AABDbHJTdWJ0eXBlAHJbUDFdLnN1YnR5cGUgPSAwAEdldFN1YnR5cGUAcltQMl0gPSByW1AxXS5zdWJ0eXBlAFNldFN1YnR5cGUAcltQMl0uc3VidHlwZSA9IHJbUDFdAEZpbHRlckFkZABmaWx0ZXIoUDEpICs9IGtleShQM0BQNCkAVHJhY2UAAEN1cnNvckhpbnQAAFJlbGVhc2VSZWcAcmVsZWFzZSByW1AxQFAyXSBtYXNrIFAzAE5vb3AAAEV4cGxhaW4AAEFib3J0YWJsZQAAAAAAAAECAAICAAECAQEBAgECEAEBAQEBAQIBARAQABAAAgIAQZHTAwuYAQECAwQGCAgAAAAAAAABAQICAwMEBAUFBgYHBwgICQkKCgsLDAwNDQ4ODw8QEBEREhITExQUFRUWFhcXGBgZGRoaGxscHB0dHh4fHyAgISEiIiMjJCQlJSYmJycoKCkpKiorKywsLS0uLi8vMDAxMTIyMzM0NDU1NjY3Nzg4OTkQQAJAAAABAgMEBggAAAAAIQAgAB4AHAAaAEGy1AMLCQEBAwAFAAYACABB0NQDCwEBAEH01AMLnQEQAEEAgQEBgYODAQEDAwESAcnJyckBSUlJSclJwQFBQcEBQUFBQUEmJkEjC4EBAwMLCwsLCwsBAwMDAUEBAAACAggAEBAQABAAEBAAABAQAAAAAgICAAASHiBAAAAAEBAAQCYmJiYmJiYmJiZAABJAQBBAAAAAQABAQBAQAAAAAABAAFAAQAQEAEBQQBAAABAAAAAAABAAAAYQAAQaAEGd1gMLCkAQUEAAEBACEhIAQbHWAwtCAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHwABAgMEBQYHCAkKCwwNDg8AAQIDBAUGBwABAgMAAQAAAwIBAEGA1wMLlAJUXIZSaR0AAF4AVUgANSNWDwAqYTZZhxMAAIwAKIEAFmsACQAAe1AATgYAQWeTAIhzAAAwAFoYABEAG0YXGgU8jm56AElbR5E9eEoAMQALKQBxAAAAbQpvdH0OMnwAZAASeZA4gotYUyUefgAAbDODgAAiAACEAGImJwAULXVdAABidKEnOil8QyGEPj8vAkGjJhiKEHafC4OgW4AVFSsyUg2JXjMTQnkviAYcc3aiRwkUd5dFRIJNWV8oky8Fdn17AxpRdg4gMJhckiMfeJ1xEWQIj38uBB5GYQeMLYGLUGCelUgbHWMshVd+DzEkPAoldmRkVVgqVKZJU1aOdpQSkUpdpZZ2DExLWoaQTk+kPSJAh3oAQaXZAws0BAArAABqcgAAAAIAAI8AAAANAAAAAI0AAHc0AACJDAAAPgCKAIUAACQAABxNAAAAADsALwBB49kDCyZFAAAAAACSAwA6AAFLAAAAHwAAAAAAfwBoAEBCPwAAAAAALgAQCABBk9oDCyFRZQBwFQdDAE9gdgAARAAAYywANwBMAF8gITkZAGYAAFcAQcDaAwurAh0cHBwcHBwcHAcHHAcHHBwcHBwcHBwcHBwcHBwcHBwcBw8IBQQWGAgREhUUFwsaEAMDAwMDAwMDAwMFEwwODQYFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAgIJHBwcAggBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQACAhwKHBkcGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbHhsbGxsbGxsbGxsbGxsbGxsAAAAAOwA7ADsAOwAAADsAOwA7AAAAOwA7ADsAOwAAAAAAAAA7AAAAAAA7AEH03AMLKzsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwAAAAAAAAA7ADsAQbjdAwtROwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7AEHA3wMLsVv//f/9AP////7+/v37+v8A/f8A+/4A/f7//gD8+v4AAP79/Pz8/f37/vz8//79/AD/AP7+/f39/v7///79/gD+/gD//vn7+/YAAP0A/v///P4A9/z//fz//f/+//f2/P/7+///AAD7/fv+AAD+/gD7+vj6+gD+//3//fv9//79/P78AAD9/gD9+/3//wD+/gAA/QD+AP78/PoA/gD+/vz3+/n9+/n4AP709/v4/v7/AP39//3//fv//////fr7+Pz69/v/+/39/f39/f39/v37/v39/Pr7/v7+/f/++//++/37+/z7+/z+AAAA/f8A/fT/AAD9+/0A/vz+/f4A/fv6+/r+/vv1//4A///9AP79/v39/vf4+v38+v////z6/QD+//3//fr5+v/4//z4AP/9//79//79+v///f37+/r8+/4A/fr///7//v7+AP7+/v/+/v///P77///+///+/QD//v8A/v/8/v////////4A/vz+/v3/AP/////+//8A/////////////wD9/wD/AAD///3+APz+AP//AAAAAAAAAAAHNAbWBUIBQgGPATIBJwU7BZYFJAckByQHRAKPAY8BjwGPAY8BAAAAANYARQQkByQHJAckByQHJAckByQHJAckByQHJAckByQHJAdqBGoEbQFtATcAFgG0AckCyQLJAMkAyQDJACgAbwACAWkB1QEAAkcCbgK1AtwCIwNKA5EDMQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRZBEUEwAS9A70D8wVCBooGJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAeJALUAtQC1ALUAtQC1ALUAYADeAI8A3QHJAm0E9ATJAskCTwBPAMkCAgNTAEEAQQBBACABogCiAF4IXgi4ArgCuALuANoB2gHaAdoBwQTBBKYC3QFEAY4ByQLJAskCyQLJAskCyQLJAskCyQLJAskCyQLJAskCyQLJAskCyQLEBG4BbgHJApUDGwEbAbIBsgFdAl0CEgVeCF4IXgheCF4IXgheCJsEhQSFBOcBDwJJAoUC7QKSA8gD8ALJAskCyQLJAskCyQLJAskCyQLJAi8ByQLJAskCyQLJAskCyQLJAskCyQLJAskCHQMdAx0DyQLJAskCvwPJAskCyQKRBPcEyQLJAjIFyQLJAskCyQLJAskCyQLJAnUCBwBbAGwDbANsA2wDuQNbAFsA3gQpBFIEXgUxBUQF1AFEBXIFEQMxBTEFEQMxBdQBcgVbA1YDegWpBakFqQWVBJUElQSVBEsFSwUGBD0FlQHOBAMHAwevBq8GJQclB68GtQa3BjoHKQdEB0QHRAdEB68GTAfMBrcGtwbMBjoHKQfMBikHzAavBkwH0QYzB68GTAdfB68GTAevBkwHXwcJBwkHCQc/B2wHbAdfBwkHBQcJBz8HCQcJB+EGeAcmByYHXwevBkYHRgdTB1MHEgcXB5QHrwYPBxIHHQcfB8wGmQerB6sHtge2B7YHXgheCF4IXgheCF4IXgheCF4IXgheCF4IXgheCF4IFADIBAABVwRbBFoEqATYBZAF4QWTBWMBZwUBBuIFAgYRBi8GMAY3BlkGHQKlBRoGqgUkBusFlAX8BTgGXQbwBV4GZwbmBQgGfgaLBg8GMADMB9EHvwc0B8kHygfCB8UHUgdHB10HxwfHB8sHVAfNB1UH1AflB1kHZgfHB2cHrQfGB8cHVge3B7kHuge7B28HfgfSB2gH8gfxB+EHhQdYB7gH4ge8B68H1QdwB4wH6QfuB/AHgQeIB/MHwwf0B/UH9gf4B8QH1gf3B6gH+Qf6B88H5wf8B/sHfwcACAEIAgj+BwMIBQi9B48HCAgJCK4H/wcNCJUHDAgECAYIBwgKCNMH3AfXBwsI3wfYBw4IFwgZCBoIGAgbCBEIqgesBx8IDAgiCCQIJQgnCCYIKQgoCCsILQgzCC4ILwgwCDEINAg1CDYIzgfAB8EH0Ac3CDIIPQhFCFAIAADCABQBFQEWAdgAwgDCANkAwgDCAMIAwgDgAMIAwgAUARUBFgHMABMAzgDKACkB2QDaAM0AzwDZAM0A2QDaAB8A2QDaANkA2gAdANkA2gAnACEA2QDcACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADgBEwDwAPEAPAHwAPEAwgAuAC8AMAAxABYA/gBBAP0A/gD/AP0AwgD/AMIABwECAQMBKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAFAEVARYBHQFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQA7ALoAuwC8AL0AvgC/ADYB7wA9AT4BxABWAMYAWAA9ARMAPwE9AT4BzQAIARkA0wDUANUAzQB5AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5APAA8QB0AHUAdgB3APAA8QB6AHsAfABFACoB/QDCAP8AagBrAIQA/QCNAP8ANgA3ADgAOQA6AM8ADAFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQDWAIAAgQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQCGABkAiACJACwBpQCmAJkAEwCbADYANwA4ADkAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAFAEVARYBcQDCABMAFgAXAMIAQwAYAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxANwA+gA7APwA2QDaACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAGoAawBsAG0AbgBvAHAAcQD+ADsAzQCKAIsAEwAUAMIAFgAHARYAFwDnABkASAAUARUBFgF0AHUAdgBlACQATABmAGcAaABpAGoAawBsAG0AbgBvAHAAcQBZAPAA8QBcAEkAwgDCAEkAEwA7ALwAvQC+AL8A/QBRAP8AlwDEABkAxgBHAHQAdQB2ADcBOAHNANkA2gA8AVEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkADgEWABcAZAAZADsAZQCKAIsAagBrAH8AgACBAH8A8ADxAHIA/gB0AHUAdgBMAEwAeQCKAIsABwH9AAgB/wDNABMBVwATAFkAWQDCAFwAXADHAIoAiwAMAWYAZwBoAGkAagBrAGwAbQBuAG8AcABxAJkAmgCbAJwAnQBRAHQAdQB2AIEA8ADxAOAAEwDiADoBOwEXABkALAE7ABYA6gD9AGUA/wDsAO0AGgDCALcAwgCYAEgAFgCRAJYAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkA2QDaANkA2gATAL0AOwC/ABcAOwCKAIsAxACHAMYA6AAbAegAjAA7AB8BzQATAXQAzQB0AHUAdgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQDCAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAPAA8QDCAPAA8QA6ATsBdAB1AHYAdAB1AHYA/QDCAP8A/QA7AP8AEwB0AHUAdgAXABYA2QDaAI4ADAHNABMBZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAEwDCACwBOwAXAHcA8ADxAHoAewB8ADoBOwHCAOwA7QDCAHUAhAD9AFEA/wDNADsAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkA2QDaAMIAwgDCAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACYB8ADxAHgAdAB1AHYAOwDCANkA2gDTANQA1QD9ABMA/wDCABMAFwD+AIoAiwAYAOgAdQDCAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABMACAFsAEwAFwB/AIAAgQA3ATgBdAB1AHYAPAFXADIBWQA0AcIAXAAWADsAwgAWACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AMIAXwDZANoACQFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQDoADsAcQAZADsAwgDZANoAdwB4AHkAegB7AHwAfQATAJEAwgDCABcAgwDoAHQAdQB2ACMAwgBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQATAMIAQgDCAHQAdQB2AHQAdQB2AEoA8gAmAcIAwgDOABcAwgAZAMIAbwBwAHEAGQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAYAMIAwgDZANoAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA8QDoAMIA1ADVAPIA8gDZANoA8gCCAAsA/QDCAP8AEwAJAZUAOwAyAcIANAHoADUBNgHZANoAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAwgDCADsAwgDvABMAwgAZAP4ALwEwARcAwgAZAH4AMgEyATQBNAEyAQ8BNAF1AB4B2QDaANkA2gDCAMIAnwAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxADsA7wDCAHQAdQB2AAQB/gDCAPAA8QDCAOkAzQDwAPEAzQDvAIAAgQAOAQkB/QDCAP8A2QDaAP0AwgD/AI8AGAFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQB2AJ8A2QDaAPAA8QB2APAA8QDCAMIAwgDvAHQAdQB2ABYA/QD+AP8A/QATAP8A6QDCAI8AGAAHAdQA1QDCAI8A2QDaANkA2gAFAQYBDwH+AI8AEwAHAAgACQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAQABMAFgAXACYBKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOAHCANYAFQA8ASsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AGoAawAeAcIAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAzwCeADsAoAAWAE0AGABPAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAMIAwgDlAMIA5wBlAFAAFgBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAgATsADADZANoAJQHZANoAEwBqAGsAOwATABAAfwCAAIEAGwBzAHQAdQB2AMIAeAA7ABYAwgAYAMIAewBkAIAAKgAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAdQDCANkA2gB5AGQAPwDCAPUAmQDCAJsAdQATAHMAwgBJANYAwgAAAaEAdAB1AMIA2QDaAHkATQDCAE8A2QDaAMIA2QDaAHUAmQCaAJsA/gAuANkA2gCQAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAOgADgGZAJoAmwBzAHQAQgATABQAtwAWAAwAOAH+AMIABgE8AdEA0gAKAe8AwgDCAGwAJABVABsAEwAUAAkBFgC3APUAkABeABkAMADZANoAJQHCACoADgEAASQA2QDaADsAwgAZAIcAwgBzAMIAoQCMAMIAwgAPAEcAwgA4AT8A2QDaADwBwgA7AIMALQEuAdkA2gBVANkA2gDZANoAWgBHANkA2gATANkA2gD1AJIABgFkANkA2gAKAQkBVQBqAGsAAAE4AVoA0QDSADwBcgA8AHQAdQB2AMIAZAB5AMIAwgCRAHMAagBrABMALgATABQAGAAWAHIAwgB0AHUAdgDCAPUAeQDCAKQAwgDZANoAJADCAAIBAwEAAcIAmQCaAJsAnACdANkA2gCWAB8A2QDaAI4A2QDaANkA2gAnADsA2QDaAJkAmgCbAJwAnQCVAJYABQCRAEcAtwD1AAoACwAMAA0ADgDCAHQAEQCBAOMAAAFVAMIAcwDCABcAWgAZALcAYwAeAGEAIAAWABYAwgBkAMIA2QDaACgAmABqAGsAFwDZANoAwgATABQAcgAWAHQAdQB2AAEBwgB5ANkA2gDZANoAwgCFADUAJAAXABcAGQAZAEYAeAB5AD0AjQAHAAgAeQBOANkA2gBRABcA4wAZANkA2gCDADsAmQCaAJsAnACdAAAAAQACADsAYgAFAEcAFwDjABkACgALAAwADQAOAFMAVAARABcAFwAZABkAOwDCAMIAtwAXABcAGQAZAB4AwgAgABMAFABkABYAwgDCAIUAKABqAGsAbACKAIsAwgDZANoAcgAkAHQAdQB2ANkA2gB5AMIAwgDCABcAdQAZAMIAFwAXABkAGQCiAMIARgDCAJEAOwAXAJkAGQCbAE4AwgB1AFEA2QDaAMIARwDZANoAmQCaAJsAnACdAMIA2QDaAMIAFwBiABkAQQHCANkA2gDCABMAFADCABYAmQAXAJsAGQDCAGQAwgDZANoAtwDCAGoAawAkAMIA2QDaAO0AwgByAPMAdAB1AHYAhQDCAHkA2QDaAIoAiwDCAMIAwgAiASEBOwDZANoAwgDCANkA2gDCAMIAjADCAMIARwDCAPQAwgDCAKIA2QDaAMIAwgCZAJoAmwCcAJ0A2QDaAMIA2QDaAMIA2QDaAAEB2QDaANkA2gABAWQAwgABAdkA2gABAWoAawDXACsBwgC3AMAAwgByAMIAdAB1AHYAAQACAHkA3QAFANkA2gARAcUACgALAAwADQAOANkA2gARANkA2gDZANoAjADCAPYAwgARAScB9wARAR4A9wAgAA0BDQGZAJoAmwCcAJ0AKAD2ABEBJwHmAOIA2QDaANkA2gDcAAUB3AAaAdwAEwAUAPQAFgD6AI0A+gD2ADwAyQC3AAUBBQEFAckARgArASQAKwHJACYAlwCWAE4AHQEWAFEAKAEoASsA6wASAO4AyQASARAB7gDuAO4AEgA7AMgAlQBiAPcAEgESAesA9wD3APcA6wBHABAByQDIAJ4AJAE+ACMByQDIABYAyQDeAMgA3gDJAMgAcwDbANsAQADbAOQAFgB+AN0AhQClAN4AZADhAIoAiwDhANsAagBrABgA2wDkANsA2wAzAXIAcQB0AHUAdgA7ARwBeQAcAd4AyQBbAKIAQAFAAVIAlAALAZEACwEWABcByQCeABkB+wCTAJIAGQDLAPoA+QD7APgADQD3AMMAwwAGAJkAmgCbAJwAnQDBAMEAMQHBANAAMQEuAdYA1gDWANAA3wDfANYABADXANcA1gADABYA0ACjAA8AFwAQALcAFwCLAJcAggAZABQAjgAYABAAkAABAI4AggCCAD0AJQA1AJcANQA1ADUAggB0AAEAIgCNAAUAFgBzAKEASwAZAEQAjQApAHMARAAYABQAEwCDAH0AQwBDAGAAFgAWABYAJQAXABYAGAAWADsAQwAXAJUAHAAWABkAFwAXABcAFgCNACIAYQAXABcAIgB0ABYAjwAZACIASwAiACIASwBYACIAVgAXABYAIgAZABgAIgAZAF0AFwAsAI4AFwCOABcAFwAWAAsAGQAXABkAFwAWABYAFgABABcAFwAXABYAFgAPAI0AjQAZABkAAQBCAUIBQgGHAEIBQgFCAUIBQgFCAUIBjQBCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFAAoAAfQDoAFYGJQJAAgoFAQVAAkgBQAIUBdQAQAKAAH0A6ABCApwBQgKHAQYGMwAzAAsClQENBRECMwAzANcDMwAzAFEAUQBTBD0APQDYA1MEDAV8AYcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGACkGnAEfAR8BBwAfAR8BpgEaBBoEKAQrBCEBLALsAT0CDAIxAj0C8QExAuIBEgIGAeUAhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAgAB9AOgA4gWEAIQAhACEAIMAgwCCAIIAggCBAH4AwgG0BOcEAQABAEYCAgDrBCMGpAEuBnsBQAGWBJkAlgQwBpwBegEuBh8CPQVKAW8AOgI6AjoCJQEeBIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAYcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAB8BHwG0BLUEtAT/AB8BHwH+AfsB+gGJAMcBPQLUADECvwG+AfkBPQJQBjEChgCGAIYAhgB/AJAB8wCEAIQAhACEAIMAgwCCAIIAggCBAH4AwgEaAdcBWQGEAIQAhACEAIMAgwCCAIIAggCBAH4AwgE+ApsAqAOoA8YB4wAJAtQEnAHUBIYAhgCGAIYAhACEAIQAhACDAIMAggCCAIIAgQB+AMIBggCCAIIAgQB+AMIBhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAgAB9AOgAwgFAApwBjQHhBLQAXABdAIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAX0BgwG0BH8BUQBRAIcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAYMAgwCCAIIAggCBAH4AwgEsArQELgE/ATcCeQA4AuABBAArAn0EeQZcBnkGLQCAAH0A6AC0BLUEtATiBDsCkQSEAIQAhACEAIMAgwCCAIIAggCBAH4AwgGRBB8BHwGRBPsDQAKmAfsDnAHDAUIGRgICAOsEPQIsADECXwBAAW4AmQA1ArQEtQS0BAoCCgI9BVEAUQAHACwAhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAJwF9BHoGEAR6BrQEewQ/ATcCdwB3AFcB0gFLAVcBHwEfAXgALALDAUECwwGRBJEEBAQ/ATcCtgE9AtIAMQI7BasFIgITApEEkQQ+BpEEkQSgAT8BNwLzAIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAQQEBAQGBAcEIwAsALQEtQS0BNgBHwEfATAFnAEbBXQBOwZnAeEAxgG0BMMAMAU9AnsEMQI1BTUFEgFAAqQEQAJUAS4AxAAZAtkAhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAEwATABMAEwCcAUUCtATrBP8BtAQ/ATcCQAGwA5kAqQHrAa4BrwO0BOgBPQWqBRQC/QS0BLUEtASHAIgAWgDMBMwEJwQqBB0EHQSFAIUAhgCGAIYAhgA/AoQAhACEAIQAgwCDAIIAggCCAIEAfgDCAR8BHwEQAh8BHwF0ATsGtAS1BLQEtAS1BLQEPQLmATECPQJ5AzECnAG0BLUEtAR2AygAFgAWANwA8wANAqkFhACEAIQAhACDAIMAggCCAIIAgQB+AMIBhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAnAG0AMYBtARvA/8AHwEfAf4B+wH6AXQBOwYgBjMFMwVAAnkD+QE9AiwAMQIvArcEhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAUQBRAKYBQAJ5AYQAhACEAIQAgwCDAIIAggCCAIEAfgDCASkBHwEfAcwBtAS1BLQEtAQWAhMAEwDAAcABwAE9ApwBMQLmALQBowQXAj8BNwJrAbABtwSbBYQAhACEAIQAgwCDAIIAggCCAIEAfgDCAYcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAJwB0wC1A5EEEQRWBFYE7gEjAiMCtAS1BLQEBwAbAiIGkQR4AUACkQQFALQE5gEDAIcAiABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAEACAQITABMAqwGEAIQAhACEAIMAgwCCAIIAggCBAH4AwgExAbQEsQHhALQEgQETABMAEQEiAXMBBAJuAQMCBAGcARoCIAYlAgAEagG1AbQEtQS0BIYDEAaEAIQAhACEAIMAgwCCAIIAggCBAH4AwgGHAIgAWgDMBMwEJwQqBB0EHQSFAIUAhgCGAIYAhgCcAZsFAgIBBbQEtQS0BLQEtQS0BIcDMABWASAGIAb/BFsGIAaPA0ACgQB+AMIBbgCHAIgAWgDMBMwEJwQqBB0EHQSFAIUAhgCGAIYAhgAJAUACywETABMAhACEAIQAhACDAIMAggCCAIIAgQB+AMIBQQXMAEACywHKATIALwATABMAMQCyAVEEPQLxATECnAGsAWwAyAQhBhIGeAHNACYCJgJRAFEAhACEAIQAhACDAIMAggCCAIIAgQB+AMIBhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYA4AFAArQEQAIFBpwBmwXJAzsBewaOARwB8QHJA30DIQYhBngBeAEhBs0BeAHIBMsBUABQAFEAUQDxAXYBcgBaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAIQAhACEAIQAgwCDAIIAggCCAIEAfgDCAbQE4QVAArQEtQS0BFYFPAHmARkBGQHxAa8BLQIgASABkgE8BdcBWQEqAa0BPQJAAjECUQBRAD0CdgExAssDggGEAIQAhACEAIMAgwCCAIIAggCBAH4AwgHnAHUAUQBRAB8BHwHnAB8BHwFAAucFQAI4BbQEtQS0BIsAPQIsAjECPQKcATECuQHIAckD1QAuAucF6QUOBskDjwCPAJEAkQBYBToB3gG8AcoDnAFSA1MDVAOHAIgAWgDMBMwEJwQqBB0EHQSFAIUAhgCGAIYAhgBlAZwBjQF8BDABhwCIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYAJwZDAQYAXgMHAIcAfABaAMwEzAQnBCoEHQQdBIUAhQCGAIYAhgCGAJkBmAHnBdQAhACEAIQAhACDAIMAggCCAIIAgQB+AMIBmwF2ALQEdAAKAGABCQFjAYQAhACEAIQAgwCDAIIAggCCAIEAfgDCAUACRAEyAUACMgHiBNUBngCEAIQAhACEAIMAgwCCAIIAggCBAH4AwgHPAMgEZgRBAEEA1gFCAEIAnAG/Ab4BcgMTAk8BAgEBAQABZwTRBLQEtQS0BEcB0wRqA58AQAIQAOABPQQQBNIEaASIAFoAzATMBCcEKgQdBB0EhQCFAIYAhgCGAIYABQRAAlEAUQAEBBAEmgNAAs8B1ARAAtQEyAT2AWsAmwWbAwYAQAKaAdoFcgMFBOABFQAVAAQETAFkBU4BNQA1APEBUQBRAGoDBAQEBAYEvQEDARMAEwAVAoQAhACEAIQAgwCDAIIAggCCAIEAfgDCAScCLQEEBAQEBgRrABQCIQJ5ADgCpAQEAGYEKAbBAUACzgEHAAIFogHOAV4BmwVAAgYCOwIgAmcEeQA4AroBBACkBNABFQKcBMcECQBDAEMA5wFAAmgELwGaATsCNgA2AMMBQAJ7ALADQAKhAUACTQGvA2MFQALsADUCQAImBjQCRABEAAcAQALDAWoBowG2AEUARQAdAkYARgBHAEcAHAI1AkgASADkATcANwDZAZwEKAEQBDgAOAAoAe0BHQJ3AHcAmgElBh4COQKiAQcAeADcBMMBQQLDAdEBEAQEBEACFQYoAtwBdwB3AA8CAwF5ADgC8AAEAHgAQALDAUECwwFAAt0BBARAApwAQAI5ADkAOwJAAh4B5QCaAVABBAQEBAYEBwQjADsAOwDbANcDPAA8ANwASQBJAEoASgDYA8MBSwBLAAQEBAQGBAcEIwBgANgAIwEoAjUCpAQ+AYsBiwGKARQBiAFAAuUBWwPaAR8FmgEdAkACoQH6BXgEHAKPAaQEJAHtAIEERgEmABcAQAIQBEACFAAUAEUBKwF3AHcApABMAEwA+QV5ADgCeAAEAMMBQQLDAcsAQAIEBI0AjQCOAI4AQAJCAScAOwJVAf0DbgAIAe8AhQOEA6cB8gCMA40DcgGtAE0ATQArAN8BHgUIAT4APgBxAcMBBAQEBAYEBwQjAEEGqATFAUQE7gAjATUCowAdBW4AiwGLAYoBFAGIAdoD2wNbA+EBWgEIAW4ACATpAUACpAT3AUAEBQEFAe0AQAJGAXkAOAIQBAQAWwFgBZ0BRQF3AHcAtAM/ATcCXwFOAE4AeAA7AsMBQQLDAU8ATwAEBGIBZAFAAmgBRARuAEACzgOuAwgBewDJAWYB7wBAAgcCwwGrA1AEewBQBK0AQAIIBCsAPwA/ACwFNQKoAKgABAQEBAYEBwQjAEACqQCpABwFaAPuAJ0ANQZAAlYAVgBtAVkAOAJ3AQQATwStA08EewBAAhAEbQVAAEAApASaBXcAdwA7AkACUgBSADMCQAJ4AKUAwwFBAsMBnQFSBQQEkACQAD8BNwJAAl4FMgLyARcBwwFTAFMAnwVAAqYApgBAAgkFKgJAAgAFNQJAAgwAQAL0BMkBkgCSAPMEQAIEBAQEBgQHBCMAjACMAPUEpwCnAEkGoACgAE8FlgCWAJUAlQA3ARAEQAI4AZMAkwA5AXcAdwDeAOsAQAKkBIwBQAJ4AEACwwFBAsMBqATFAQQE/AEjAZQAlACNBUwGiwGLAYoBFAGIAVUAVQBbA1cAVwBUAFQAKQJAAiYBQAKSBVIBUwGRBe0ALAFGAYgFgQUEBAQEBgQHBCMARQFYAZMB4wHiABsFNAA0ADoAOgBwAVsF3gU2At0FeQA4At0ABADQAAwB0QCGAdwEDQakBFwFWgVZBQsG7wC4ADsC6QClAdkEXwDaAK0A4wXBACsAWwBeALIAugDTAbwA1AGOBQ0AvQC+AL8A9QHDAfUAbADuAJEBlAWTBZYF2wGUAdgFxQA1Ag4A6gH5AGUA7gXwAV0BGAH7AMkAYQHzAfwAlgH2BP0ABQIvBS4FswEtBSYFZwB9AxAFnQHjAJcBEARaBj8BNwJZBhEFdwB3ALcBbwElBQ8FWAYOAngAuAHDAUECwwE6BjUBBAQ2AXUBCgELAckBLAYrBrsBigByBSgCcQULAMsFgAFzAD0BRgVtABgCKgBDAn4B1gBFBYQBrgSFARMBFQEWAQQEBAQGBAcEIwBEAvEEngHsBKoAnwG3AP4F/wX9BasAmgAzAfwFTgPfAOAAWADEAdcArABBAeoATgSYAKQETARJAbkArgDHBJ0DuwDxAFEB9ABcBMAArwCwAKgBqgFhAMIAYgBjAGQAsQBfBFsE9gD3AKEAGAD4AFwB1gQIAVQE+gDvAccAxgAPAF0D9AFxAf4A+AH9AQACyABmABkAswBpARoAbAFoAHsDNAGiAGkAiAMIAmoAoQQtBIMEEQDkABsAggQbAR0BBwHSA8oAzAN7ABwAlwQdAB4AmwSTBB8AlQSIBCkAIADOACQCIQBuAJoEOwQIAHAALgRxACwEMAQiADEEMAJlBA0BZAQOASQAEgCqBAkEaQOXAHoAJQCJAQ8BEAE8ArUAqQToBOgE6ASnA+gE6AToBOgE6AToBOgEUQYAAAAAfwZ/Bn8G0wXmBFcF5gTmBOYE5gTTBdMF0wXmBOYE5gTmBOYE5gR1BXUFCAYHBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBNIF5gTmBOYE5gQqBioG5gTmBOYE5gTmBBsGGgbmBOYE5gR+BeYEhQXmBOYE5gTmBOYE1AXVBeYE5gTmBAcGCQbkBYwFiwWKBYkF9gVpBYMFfAWABc8F0AXOBWkG1QXUBeYEfwWvBb8FrgXmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBLcFvgW9BbwFxQW7BbgFsQWwBbIFswX+BOYE+wQxBeYE5gTmBOYE5gS0BQcFqAWnBaYF5gTCBbUFwQXABQ8GTwZOBuUF5gTmBOYE5gTmBOYEKgbmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBGsFKgYqBuYEBwUqBioGbAVsBQMFAwVvBRYGTgVOBU4FTgVXBU4F5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYEDAYKBuYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBFMF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBEgG5gTxBT8FUwVTBVMFUwVVBUAFPgVNBQgF7QR3Bo8FhAVUBYQFdAaCBY8FjwWCBY8FVAV0BhgFXgYTBXUFdQV1BWsFawVrBWsFbwVvBdEFVAVNBeYEdwZ3Bl0FXQV2BnYGXQXlBWYGmAU0BToFOgU6BToFXQX4BIIFZgZmBoIFmAU0BYIFNAWCBV0F+AT1BXEGXQX4BNsFXQX4BF0F+ATbBTIFMgUyBScF5gTmBNsFMgUYBTIFJwUyBTIFPAbmBN8F3wXbBV0FNAY0BngFeAV9BW8F1gVdBeYEfQV7BXkFggUqBUsGSwZHBkcGRwZ8BnwGFgZXBgcFBwUHBQcFVwYaBRoFCAUIBQcFVwbmBOYE5gTmBOYE5gRSBuYEEQbmBWEF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gQcBuYE5gTmBOYE5gTmBOYE5gTmBOYE5gSdBeYE6QQTBuYE5gTmBOYE5gTmBOYE5gSGBYcFYgXmBOYE5gTmBOYE5gTmBJUF5gTmBOYEkAXmBOYE5gTmBOYE5gTmBOYEcwbmBOYE5gTmBOYE5gT0BfMF5gTmBF8F5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gQWBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gR6BeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gQ5BnAF5gTmBOYE5gRqBuYE5gTmBOYESAXmBOYE5gTmBOYE5gTmBOYE5gTmBOYEYgZCBZ4F5gShBfwE5gTyBOYE5gQAAAkAQZC7BAuyBr4AvgC9AL8AwADAAMAAwAC/AL8AvwC/AL8AxADGAMgAyADHAMcAxQDFAMwAzADOAM4AzwDRANEA0QDSANYA1wDYANgA2ADYANgA2ADYANgA2ADYANgA2ADYAOEA4QDdAN0A3wDfAOIA4gDiAOIA4wDjAOMA4wDjAOAA4ADkAOQA5ADLAOYA5wDnAOcA5wDnAOoA2wDbAOsA6wDsAOwAvwDuAO4AvwC/AL8AzQDNAM0A8ADzAPMA8wDxAPEA/QDxAP8A/wD0APQA9AAAAfUA9QD1AAEBAQH2APYAAwEDAQIBAgECAQIBAgHJAMkA7wDvAAgBCAEIAQgBBAEEAQQBBAEFAQUBBQEKAQYBBgH6APoA6ADoANwA3ADcAAsBCwELAfgA+AD5APkA+wD7APsA+wC/APcA9wANAQ0BDQENAb8ADgEOAQ4BDgG/AL8AEQERAREBEQERAREBEgEPAQ8BEAEQAQkBCQHaANoA2gDaANkA2QDZANoA2gDaANoA2gDaANoA2gDaANkA2gDaANoA2gDaANoA2gDaANoAFAHaANoA2gDaANoA2gDaANoA2gDaANoA2gAVARUB2gAWARYB2gDaANoA2gDaANoAGQEZARoBGgEYAQcB/gD+ABcBFwG/ABsBGwHeAN4A6QDpABwBHAG/AL8AvwAdAR0BvwC/AL8AvwC/ANQA1QC/AB8B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ACkASQAlACkCKQFlBF4AJQBpAGUAHgOFAF4AOQB+AF4AJQBpBgUGXgQ6AKwASwD+Bt4BJQAeC8kEJgDVAOUENQAxADcArAUxACwANQBMADUATAA1ACwAZwNnAFUAogB5AFUANwBVAFoAbAE1AFUABwQmAEcBrAJNAZUARwAsAGcMNQAnAOwAIgA6AMwARgBMADoAjABHAE0BZwBaACcA1QEiACcALADHA2wDJwtsAScATQEnBCwBRgA6AHUAJgDHAowAJgAsASYAbAAmAKwA9QEnA2wANQAnAGcBbANsACoAxwYsACoALAAnAGoADAGKACwASgAnAOwARwFMAFUATQE1ACYAxwDnACwASgAHAUcAxwLnACcAhwAsACcAagCMAEoASgAsACcAKgBHAGcATABNAUcAVwDPADoANwBMACoAxwBHAMcC5wBHAEcARwAsAGoATABMAGwALACHACcATQFMAGcALABMACoAJwFnAMcC5wBHAKcALAAnAGoArABMACoASgAsACcARwBMAE0BNQA3ACwASgAHAUcAxwLnAEcApwAsACcAKgAsACoAjABKAEoALAAsACoARwBnAEwATQE6ACcAzwAsACcAxwBnAIcARwAnAEcARwBnAIcBSgAsAEoAagBqACwAJwAqAE0BbwDaADcAOgBqAAcBZwDnAkcBpwAnAGwAigBsAIwATABHAEcATABNAe8AOgBKAAcBZwDnAkcBpwAsACcAKgAsAKoALABKAEoATABKACcARwBMAE0BRwBKAAcBZwAnBScAagCMAGoAagAsACcAKgBHAEwATQHPADoAxwBKAEcCBwMnAScA5wAsAGoAbAAsAAoBSgA1AAcGLABHAOwANwDHACYADAE1AE0BVQBHACcARwAnACcAhwDnAGcAJwAnAEcAhwAsAEcAzABMACcApwAmAMwATQGHACcAegD1AToANQB6AEwA2gBNAU8BOgAsADoALAA6ACwANgAyADYAMgBKAAcBhwTMASoArAA1AEwApwBsAYwEGgEsANoAWgC1AJoAVQBnBUoAjAAqAMwAKgBMAEoATAAnAE0B1QDHAEoATACHAGwAJwBqAEcA6gBnAIwApwEsAEoATADKACwAJwAqAE0BagAsAFoAyQQpACkAZwU1ACYAhymHAOcAJwCHACcFhwAnBIcA5wAnAIcA5wEnB4cAZwhsADUBjwIHAloBpwoxAIdNVQAnAj0ARwM2ADIAZwl1AG4ApwGHAGwARwJsAFUARwJMAKcBZwBMAIcGTAAqAOwACgEsAEoAbAF1ACYAdQA3ACcALABNAU8B1QAxAJUAbAA9AE0BZwQmAIcGJwUsACcAxwinA2wAigBMAGoASgAsAMoAbAA6AFUATQHHA6cAhwUqAucASgBNAS8AWgTnAkwAagBVAKcGKgAsACoA7AAsACoALABKAAwBygBMASwATQFNAfUAJgDVAIwAKgDnBSwAKgCsACoALACqACwASgDnAE0B9QBaASwBOgFMACoAxwMqAIwASgBMACoALABKAEcATQGHBSwAKgBMAGoALAAqAGwASgCVAIcECgEMAUoATAC1AE0BZwBNAccDxgBVABUBbAA1AKwBKgDsAIcALACHAEoALABHAIUF5gelASYARQSmBOwEjADeEgUBXgwFAQkBxQDJAAUBCQEFAQkBxQDJAAUBKQApACkAXgDlAAkBxQEFAQgBBQEIAQUBCAGlAEUAiQAoADgAJQB4AGUARQCJACgAeACFAEUAiQB4AAUBqQB4AGUARQCJACgAWAB9AaIA0QBVADQAMwA2AFQAMwA2ADQAFQE7ADwAogA9ADUBNAAzAJUAUAB1ADkANgAyAHUBOQA1ADAAVQE9AKIAwgAvACYAzwB5ADYAMgAmAE8BeQA2ADIApgFXA6wBiwAsAGsAjAFaACkAmgApAFoAJQBpAEUAaQAlADoAKQBaADkAqQDaACkAOgApADoAKQA6AIkAOgAlAIkAJQCHACUAWgBFAEkAuQBeAGUAOgA5AFoAJQA6AA8CbgReAI4ALwC5ALoAWQCaADkAWgA5AFoAOQD6ADkA+gNZAFoAOQA6ADkA+gOZIRoBmQCaAlkA+gA2ADIAOgo5ANoDOQMaBdkAWgL6BHoBjwfaCc8C+hY5ADoBOQDaBhkB+g05ABoS+gw2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIAzwOaBbkANgAyAPkDNgAyADYAMgA2ADIANgAyADYAMgAZAhogeRA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyAPkHNgAyADYAMgAZBDYAMgBZIBoGuQJaANkAWgHpBeUFfgBJAEUA/gBpACUAXgAlAF4ApQBGAGkAJQBeDCUA2gCeAGwAXgCVAC8AVQDFBCUAJQAHByYANQAsAOcC5wDnAOcA5wDnAOcA5wDnAAwEVQA0ADMANAAzAHUANAAzADUANAAzADUBMQBVADEANQA0ADMAVQA0ADMANgAyADYAMgA2ADIANgAyALUAJgBVAVEAWgM6C9oamgE9AHUAOgAmACcALgA2ADIANgAyADYAMgA2ADIANgAyAFoANgAyADYAMgA2ADIANgAyADEANgBSADoALgGMAEoAMQCmAFoAbgAmACcANQBaAMcKTABYAEYAJwAxAEcLNQBmACcAJwXHC1oAjwBaAWcDmgQHAvoDTwHaAw8BOgDvARoETwH6BO8B+gcaICcAJwAaCCcAJwCnAiYA5476BgcFxgBVAIchJgB1AAcCTQFHAN4FJwAsAGsANQBMATUAJgAeAywAxwhOAUwA1QD4AiYBWADeAUUA3gcmAAUBvgBeASYAWACeAJ4AfgFGACUA5wAsAGcALACHACwA5wJKAEwAKgCaAM8AWgA3ADoAhwaVAEoARwYKAiwAVQBNAUwCxwB1ACcATQGHAwwBVQDnAmwBSgA1AKcDbAAqAOcFLABKAIwASgAsAIoAtQEmAE0BVQAnBcwASgBMAEoATABnACwABwEsACoATQGVAAcCJgDHAHoAJwAqAAcGLAAnAGwARwBMAKcATAAnACwAJwBHACYAVQBnASoATABKAFUAJwBGACoALADHAMcAxwDnAOcAZwRKACwASgAsAEoANQAqACwATQEnACcA5wInBiQARABEACQAPwA/AMctRw3lAKUAJwAsAEcBOQCnAacAJwBHAEcAhw0YAmctNgAyAAcIxwaHATcAOgAMAvUANgAyADUA7AA1AFEAUAA2ADIANgAyADYAMgA2ADIANgAyADYAMgA2ADIANgAyAFUANgAyAJUAcAB1AJUAMQA2ADIANgAyADYAMgB1ADkAMQB5ADUANwBVAKcA5xAiAHUANwB1ADYAMgA1ADkANQAxAFUATQFVAHkAVQBJAzYANQAyADgAMAA4AEUDNgA5ADIAOQA2ADIANQA2ADIAVQBHASYApwVGAOcDxwDHAMcAZwBXADkAOAA6AFcAOgCZAFoAYgBaAIcBRwNnAkcA5wHHAWcPdQCvBToBrgaPADoCLwCaAboFLACnAycG5wOPACcCLgAHAS4AxwM1AIcEBwE1AK4ACQUFBccJTQHHACcAhwVHACcA5wI1AA8BxwLPADUARwM1AAcHRwAnAGwATACMAIcAZwBnA2wALAAPATUBpwNPADUAxwb1AMcCDwFnAg8BJwnvAyoALAAqAKcG7AH1AI8CTQFMACoApwVqAIwASgBMAFUAIgCVACcDTQFsAIcErAAqAAwBTQGVAEwAKgAHBmoALAFKAIcAlQBNAWcFLAAqACwASgDMACoALABNAedtbgyVAOeFJ0enCCcAygWMAKYBRwDaHvoEmgdKAGwAegDKAAIBDAFaAOwA2gOMABoGWghsADoA+gpPAkkDRQNJA+UARQJJA0UDKQBJACkASQCJAAkBhQAlAOUAZQFJA0UDSQCJAAkB6QBFA0kAiQCpACkA6QBFA0kDRQNJA0UDSQNFA0kDRQNJA0UDSQOFAykDOQAlAzkAxQApAzkAJQM5AMUAKQM5ACUDOQDFACkDOQAlAzkAxQApAzkAJQM5AMUAXgBNBocAZwNHACcAJwBHAYcAJwAnACcAJwAnACcAZwBHACcAJwAnACcAJwAnAEcAJwCHAOcAhwCHACcARwEnAmcApwAnAlkAmgWaDPoB2gH6AfoBbwH6A5oHegW6A3oFOgFaADoE2gDaCJoCugS6ADoC+gc6ANoWmgDaB5oAGgPaCHoB2giaDicAJwAnACcAJwAnAMdDIgACDAwePwA/AEGChgULIL8F2QbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbjBuUGAEGyhgUL/CQgACEAJAAlACgAKQAqACsALAAtAC4AMAA6ADwAPwBBAFsAXABdAF4AXwBgAGEAewB8AH0AfgB/AKAAoQCiAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAtAC1ALYAuAC5ALoAuwC8AL8AwADXANgA3wD3APgAAAE4ATkBSQFKAXkBfwGBAYMBhAGHAYoBjAGOAZIBkwGVAZYBmQGcAZ4BnwGhAaIBpwGrAawBrwGyAbQBtQG4AboBuwG8Ab4BwAHEAcUBxgHHAcgByQHKAcsBzAHNAd0B3gHwAfEB8gHzAfQB9wH5AfoBNAI6AjwCPQI/AkECRAJHAkgCUAKUApUCsALCAsYC0gLgAuUC7ALtAu4C7wIAA3ADdAN1A3YDegN7A34DhAOGA4cDiAOMA44DkAORA6MDrAPPA9ED0gPVA9gD8AP0A/YD9wP6A/wD/QMwBGAEggSDBIgEigTBBM8E0AQxBVkFWgVhBYkFigWPBZEFvgW/BcAFwQXDBcQFxgXHBdAF8AXzBQAGBgYJBgsGDAYOBhAGGwYeBiAGQAZBBksGYAZqBm4GcAZxBtQG1QbWBt0G3gbfBuUG5wbpBuoG7gbwBvoG/Qb/BgAHDwcQBxEHEgcwB00HpgexB8AHygfrB/QH9gf3B/oHAAgWCBoIGwgkCCUIKAgpCDAIQAhZCF4IoAiiCOQIAAkDCQQJOgk7CTwJPQk+CUEJSQlNCU4JUAlRCVgJYglkCWYJcAlxCXIJeQmBCYIJhQmPCZMJqgmyCbYJvAm9Cb4JwQnHCcsJzQnOCdcJ3AnfCeIJ5gnwCfIJ9An6CfsJAQoDCgUKDwoTCioKMgo1CjgKPAo+CkEKRwpLClEKWQpeCmYKcApyCnUKgQqDCoUKjwqTCqoKsgq1CrwKvQq+CsEKxwrJCssKzQrQCuAK4grmCvAK8QoBCwILBQsPCxMLKgsyCzULPAs9Cz4LPwtAC0ELRwtLC00LVgtXC1wLXwtiC2YLcAtxC3ILgguDC4ULjguSC5kLnAueC6MLqAuuC74LwAvBC8YLygvNC9AL1wvmC/AL8wv5C/oLAQwFDA4MEgwqDDUMPQw+DEEMRgxKDFUMWAxgDGIMZgx4DH8MggyFDI4MkgyqDLUMvAy9DL4MvwzADMYMxwzKDMwM1QzeDOAM4gzmDPEMAg0FDQ4NEg09DT4NQQ1GDUoNTQ1ODVcNYA1iDWYNcA15DXoNgg2FDZoNsw29DcANyg3PDdIN1g3YDfIN9A0BDjEOMg40Dj8OQA5GDkcOTw5QDloOgQ6EDocOig6NDpQOmQ6hDqUOpw6qDq0OsQ6yDrQOuw69DsAOxg7IDtAO3A4ADwEPBA8TDxQPFQ8YDxoPIA8qDzQPNQ82DzcPOA85DzoPOw88Dz0PPg9AD0kPcQ9/D4APhQ+GD4gPjQ+ZD74Pxg/HD84P0A/VD9kPABArEC0QMRAyEDgQORA7ED0QPxBAEEoQUBBWEFgQWhBeEGEQYhBlEGcQbhBxEHUQghCDEIUQhxCNEI4QjxCQEJoQnRCeEKAQxxDNENAQ+xD8EP0QShJQElgSWhJgEooSkBKyErgSwBLCEsgS2BISExgTXRNgE2kTgBOQE6ATABQBFG0WbxaAFoEWmxacFqAW6xbuFgAXDhcSFyAXMhc1F0AXUhdgF24XcheAF7QXthe3F74XxhfHF8kX1BfXF9gX2xfcF90X4BfwFwAYBhgHGAsYDhgQGCAYQxhEGIAYqRiqGLAYABkgGSMZJxkpGTAZMhkzGTkZQBlEGUYZUBlwGYAZsBnBGcgZ0BnaGd4ZABoXGhkaHhogGlUaVhpXGlgaYBphGmIaYxplGm0acxp/GoAakBqgGqcaqBoAGwQbBRs0GzUbNhs7GzwbPRtCG0MbRRtQG1obYRtrG3QbgBuCG4MboRuiG6YbqBuqG6sbrBuuG7AbuhvmG+cb6BvqG+0b7hvvG/Ib/BsAHCQcLBw0HDYcOxxAHE0cUBxaHHgcfhzAHNAc0xzUHOEc4hzpHO0c7hzyHPQc9RwAHSwdax14HXkdmx3AHfwdAB6WHp4eAB8IHxAfGB8gHygfMB84H0AfSB9QH1kfWx9dH18fYR9oH3AfgB+IH5AfmB+gH6gfsB+2H7gfvB+9H74fvx/CH8YfyB/MH80f0B/WH9gf3R/gH+gf7R/yH/Yf+B/8H/0fACALIBAgFiAYIBkgGiAbIB0gHiAfICAgKCApICogLyAwIDkgOiA7ID8gQSBEIEUgRiBHIFIgUyBUIFUgXyBgIGogcCBxIHQgeiB9IH4gfyCAIIogjSCOIJAgoCDQIN0g4SDiIOUgACECIQMhByEIIQohCyEOIRAhEyEUIRUhFiEYIRkhHiEkISUhJiEnISghKSEqIS4hLyEwITQhNSE5ITohPCE+IUAhRSFHIUohSyFMIU4hTyFQIWAhgyGFIYkhkCGVIZohnCGgIaEhoyGkIaYhpyGuIa8hziHQIdIh0yHUIdUh9CEAIwgjDCMgIyIjKSMqIysjfCN9I5sjtCPcI+IjACRAJGAknCTqJAAltyW4JcElwiX4JQAmbyZwJgEnaCdpJ2onaydsJ20nbidvJ3AncSdyJ3MndCd1J3YnlCfAJ8UnxifHJ+Yn5yfoJ+kn6ifrJ+wn7SfuJ+8n8CcAKAApgymEKYUphimHKYgpiSmKKYspjCmNKY4pjymQKZEpkimTKZQplSmWKZcpmCmZKdgp2SnaKdsp3Cn8Kf0p/ikAKzArRStHK1ArACwwLGAsYyxlLGcsbixxLHIsdCx1LHcsfCx+LIEsgizkLOUs6yzvLPIs+Sz9LP4sAC0nLS0tMC1v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/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/AAEXAh0YEwMeGxkLFAgEDR8WHBIaCgcMFREJBhAFDw5ObyBlcnJvciBpbmZvcm1hdGlvbgBJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhh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";
var wasmBinary = base64ToArrayBuffer(sqliteWasmBase64);

// ../../../lix/packages/sqlite-wasm-kysely/dist/kysely/ConnectionMutex.js
var _ConnectionMutex_promise;
var _ConnectionMutex_resolve;
_ConnectionMutex_promise = /* @__PURE__ */ new WeakMap(), _ConnectionMutex_resolve = /* @__PURE__ */ new WeakMap();

// ../../../lix/packages/sqlite-wasm-kysely/dist/kysely/SqliteWasmConnection.js
var _SqliteWasmConnection_db;
_SqliteWasmConnection_db = /* @__PURE__ */ new WeakMap();

// ../../../lix/packages/sqlite-wasm-kysely/dist/kysely/SqliteWasmDriver.js
var _SqliteWasmDriver_config;
var _SqliteWasmDriver_connectionMutex;
var _SqliteWasmDriver_db;
var _SqliteWasmDriver_connection;
_SqliteWasmDriver_config = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_connectionMutex = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_db = /* @__PURE__ */ new WeakMap(), _SqliteWasmDriver_connection = /* @__PURE__ */ new WeakMap();

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex.push((i4 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset3 = 0) {
  return (byteToHex[arr[offset3 + 0]] + byteToHex[arr[offset3 + 1]] + byteToHex[arr[offset3 + 2]] + byteToHex[arr[offset3 + 3]] + "-" + byteToHex[arr[offset3 + 4]] + byteToHex[arr[offset3 + 5]] + "-" + byteToHex[arr[offset3 + 6]] + byteToHex[arr[offset3 + 7]] + "-" + byteToHex[arr[offset3 + 8]] + byteToHex[arr[offset3 + 9]] + "-" + byteToHex[arr[offset3 + 10]] + byteToHex[arr[offset3 + 11]] + byteToHex[arr[offset3 + 12]] + byteToHex[arr[offset3 + 13]] + byteToHex[arr[offset3 + 14]] + byteToHex[arr[offset3 + 15]]).toLowerCase();
}

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js
import crypto2 from "node:crypto";
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto2.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/native.js
import crypto3 from "node:crypto";
var native_default = {
  randomUUID: crypto3.randomUUID
};

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset3) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset3 = offset3 || 0;
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset3 + i4] = rnds[i4];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s3) => s3.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s3) => s3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i4 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i4 < glob.length) {
      const c5 = glob.charAt(i4);
      if ((c5 === "!" || c5 === "^") && i4 === pos + 1) {
        negate = true;
        i4++;
        continue;
      }
      if (c5 === "]" && sawStart && !escaping) {
        endPos = i4 + 1;
        break;
      }
      sawStart = true;
      if (c5 === "\\") {
        if (!escaping) {
          escaping = true;
          i4++;
          continue;
        }
      }
      if (c5 === "[" && !escaping) {
        for (const [cls, [unip, u3, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i4)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i4 += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u3;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c5 > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c5));
        } else if (c5 === rangeStart) {
          ranges.push(braceEscape(c5));
        }
        rangeStart = "";
        i4++;
        continue;
      }
      if (glob.startsWith("-]", i4 + 1)) {
        ranges.push(braceEscape(c5 + "-"));
        i4 += 2;
        continue;
      }
      if (glob.startsWith("-", i4 + 1)) {
        rangeStart = c5;
        i4 += 2;
        continue;
      }
      ranges.push(braceEscape(c5));
      i4++;
    }
  if (endPos < i4) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r6 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r6), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/unescape.js
var unescape = (s3, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s3.replace(/\[([^\/\\])\]/g, "$1") : s3.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c5) => types.has(c5);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s3) => s3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p5 of this.#parts) {
      if (typeof p5 === "string")
        continue;
      if (p5.type || p5.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p5) => String(p5)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p5) => String(p5)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n6;
    while (n6 = this.#negs.pop()) {
      if (n6.type !== "!")
        continue;
      let p5 = n6;
      let pp = p5.#parent;
      while (pp) {
        for (let i4 = p5.#parentIndex + 1; !pp.type && i4 < pp.#parts.length; i4++) {
          for (const part of n6.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i4]);
          }
        }
        p5 = pp;
        pp = p5.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p5 of parts) {
      if (p5 === "")
        continue;
      if (typeof p5 !== "string" && !(p5 instanceof _AST && p5.#parent === this)) {
        throw new Error("invalid part: " + p5);
      }
      this.#parts.push(p5);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p5) => typeof p5 === "string" ? p5 : p5.toJSON()) : [this.type, ...this.#parts.map((p5) => p5.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p5 = this.#parent;
    for (let i4 = 0; i4 < this.#parentIndex; i4++) {
      const pp = p5.#parts[i4];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c5 = new _AST(this.type, parent);
    for (const p5 of this.#parts) {
      c5.copyIn(p5);
    }
    return c5;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i5 = pos;
      let acc2 = "";
      while (i5 < str.length) {
        const c5 = str.charAt(i5++);
        if (escaping || c5 === "\\") {
          escaping = !escaping;
          acc2 += c5;
          continue;
        }
        if (inBrace) {
          if (i5 === braceStart + 1) {
            if (c5 === "^" || c5 === "!") {
              braceNeg = true;
            }
          } else if (c5 === "]" && !(i5 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c5;
          continue;
        } else if (c5 === "[") {
          inBrace = true;
          braceStart = i5;
          braceNeg = false;
          acc2 += c5;
          continue;
        }
        if (!opt.noext && isExtglobType(c5) && str.charAt(i5) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c5, ast);
          i5 = _AST.#parseAST(str, ext2, i5, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c5;
      }
      ast.push(acc2);
      return i5;
    }
    let i4 = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i4 < str.length) {
      const c5 = str.charAt(i4++);
      if (escaping || c5 === "\\") {
        escaping = !escaping;
        acc += c5;
        continue;
      }
      if (inBrace) {
        if (i4 === braceStart + 1) {
          if (c5 === "^" || c5 === "!") {
            braceNeg = true;
          }
        } else if (c5 === "]" && !(i4 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c5;
        continue;
      } else if (c5 === "[") {
        inBrace = true;
        braceStart = i4;
        braceNeg = false;
        acc += c5;
        continue;
      }
      if (isExtglobType(c5) && str.charAt(i4) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c5, part);
        part.push(ext2);
        i4 = _AST.#parseAST(str, ext2, i4, opt);
        continue;
      }
      if (c5 === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c5 === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i4;
      }
      acc += c5;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i4;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob = this.toString();
    const [re3, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re3}$`, flags), {
      _src: re3,
      _glob: glob
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p5) => {
        const [re3, _5, hasMagic, uflag] = typeof p5 === "string" ? _AST.#parseGlob(p5, this.#hasMagic, noEmpty) : p5.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re3;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s3 = this.toString();
      this.#parts = [s3];
      this.type = null;
      this.#hasMagic = void 0;
      return [s3, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p5) => {
      if (typeof p5 === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re3, _5, _hasMagic, uflag] = p5.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re3;
    }).filter((p5) => !(this.isStart() && this.isEnd()) || !!p5).join("|");
  }
  static #parseGlob(glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re3 = "";
    let uflag = false;
    for (let i4 = 0; i4 < glob.length; i4++) {
      const c5 = glob.charAt(i4);
      if (escaping) {
        escaping = false;
        re3 += (reSpecials.has(c5) ? "\\" : "") + c5;
        continue;
      }
      if (c5 === "\\") {
        if (i4 === glob.length - 1) {
          re3 += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c5 === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob, i4);
        if (consumed) {
          re3 += src;
          uflag = uflag || needUflag;
          i4 += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c5 === "*") {
        if (noEmpty && glob === "*")
          re3 += starNoEmpty;
        else
          re3 += star;
        hasMagic = true;
        continue;
      }
      if (c5 === "?") {
        re3 += qmark;
        hasMagic = true;
        continue;
      }
      re3 += regExpEscape(c5);
    }
    return [re3, unescape(glob), !!hasMagic, uflag];
  }
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/escape.js
var escape = (s3, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s3.replace(/[?*()[\]]/g, "[$&]") : s3.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../../node_modules/.pnpm/minimatch@10.0.1/node_modules/minimatch/dist/esm/index.js
var minimatch = (p5, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p5);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f5) => !f5.startsWith(".") && f5.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f5) => f5.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f5) => !f5.startsWith(".") && f5.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f5) => f5.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f5) => !f5.startsWith(".") && f5.includes(".");
var starDotStarTestDot = (f5) => f5 !== "." && f5 !== ".." && f5.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f5) => f5 !== "." && f5 !== ".." && f5.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f5) => f5.length !== 0 && !f5.startsWith(".");
var starTestDot = (f5) => f5.length !== 0 && f5 !== "." && f5 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f5) => noext(f5) && f5.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f5) => noext(f5) && f5.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f5) => noext(f5) && f5.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f5) => noext(f5) && f5.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f5) => f5.length === len && !f5.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f5) => f5.length === len && f5 !== "." && f5 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p5) => minimatch(p5, pattern, options);
minimatch.filter = filter;
var ext = (a3, b5 = {}) => Object.assign({}, a3, b5);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m7 = (p5, pattern, options = {}) => orig(p5, pattern, ext(def, options));
  return Object.assign(m7, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s3, options = {}) => orig.unescape(s3, ext(def, options)),
    escape: (s3, options = {}) => orig.escape(s3, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f5) => mm.match(f5));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s3) => s3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._5) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s3) => this.slashSplit(s3));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s3, _5, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s3[0] === "" && s3[1] === "" && (s3[2] === "?" || !globMagic.test(s3[2])) && !globMagic.test(s3[3]);
        const isDrive = /^[a-z]:/i.test(s3[0]);
        if (isUNC) {
          return [...s3.slice(0, 4), ...s3.slice(4).map((ss2) => this.parse(ss2))];
        } else if (isDrive) {
          return [s3[0], ...s3.slice(1).map((ss2) => this.parse(ss2))];
        }
      }
      return s3.map((ss2) => this.parse(ss2));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s3) => s3.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i4 = 0; i4 < this.set.length; i4++) {
        const p5 = this.set[i4];
        if (p5[0] === "" && p5[1] === "" && this.globParts[i4][2] === "?" && typeof p5[3] === "string" && /^[a-z]:$/i.test(p5[3])) {
          p5[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i4 = 0; i4 < globParts.length; i4++) {
        for (let j5 = 0; j5 < globParts[i4].length; j5++) {
          if (globParts[i4][j5] === "**") {
            globParts[i4][j5] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs2 = -1;
      while (-1 !== (gs2 = parts.indexOf("**", gs2 + 1))) {
        let i4 = gs2;
        while (parts[i4 + 1] === "**") {
          i4++;
        }
        if (i4 !== gs2) {
          parts.splice(gs2, i4 - gs2);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i4 = 1; i4 < parts.length - 1; i4++) {
          const p5 = parts[i4];
          if (i4 === 1 && p5 === "" && parts[0] === "")
            continue;
          if (p5 === "." || p5 === "") {
            didSomething = true;
            parts.splice(i4, 1);
            i4--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p5 = parts[dd - 1];
        if (p5 && p5 !== "." && p5 !== ".." && p5 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs2 = -1;
        while (-1 !== (gs2 = parts.indexOf("**", gs2 + 1))) {
          let gss = gs2;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs2) {
            parts.splice(gs2 + 1, gss - gs2);
          }
          let next = parts[gs2 + 1];
          const p5 = parts[gs2 + 2];
          const p22 = parts[gs2 + 3];
          if (next !== "..")
            continue;
          if (!p5 || p5 === "." || p5 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs2, 1);
          const other = parts.slice(0);
          other[gs2] = "**";
          globParts.push(other);
          gs2--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i4 = 1; i4 < parts.length - 1; i4++) {
            const p5 = parts[i4];
            if (i4 === 1 && p5 === "" && parts[0] === "")
              continue;
            if (p5 === "." || p5 === "") {
              didSomething = true;
              parts.splice(i4, 1);
              i4--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p5 = parts[dd - 1];
          if (p5 && p5 !== "." && p5 !== ".." && p5 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i4 = 0; i4 < globParts.length - 1; i4++) {
      for (let j5 = i4 + 1; j5 < globParts.length; j5++) {
        const matched = this.partsMatch(globParts[i4], globParts[j5], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i4] = [];
          globParts[j5] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs2) => gs2.length);
  }
  partsMatch(a3, b5, emptyGSMatch = false) {
    let ai2 = 0;
    let bi2 = 0;
    let result = [];
    let which = "";
    while (ai2 < a3.length && bi2 < b5.length) {
      if (a3[ai2] === b5[bi2]) {
        result.push(which === "b" ? b5[bi2] : a3[ai2]);
        ai2++;
        bi2++;
      } else if (emptyGSMatch && a3[ai2] === "**" && b5[bi2] === a3[ai2 + 1]) {
        result.push(a3[ai2]);
        ai2++;
      } else if (emptyGSMatch && b5[bi2] === "**" && a3[ai2] === b5[bi2 + 1]) {
        result.push(b5[bi2]);
        bi2++;
      } else if (a3[ai2] === "*" && b5[bi2] && (this.options.dot || !b5[bi2].startsWith(".")) && b5[bi2] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a3[ai2]);
        ai2++;
        bi2++;
      } else if (b5[bi2] === "*" && a3[ai2] && (this.options.dot || !a3[ai2].startsWith(".")) && a3[ai2] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b5[bi2]);
        ai2++;
        bi2++;
      } else {
        return false;
      }
    }
    return a3.length === b5.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i4 = 0; i4 < pattern.length && pattern.charAt(i4) === "!"; i4++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi2 = 0, pi2 = 0, fl = file.length, pl = pattern.length; fi2 < fl && pi2 < pl; fi2++, pi2++) {
      this.debug("matchOne loop");
      var p5 = pattern[pi2];
      var f5 = file[fi2];
      this.debug(pattern, p5, f5);
      if (p5 === false) {
        return false;
      }
      if (p5 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p5, f5]);
        var fr2 = fi2;
        var pr2 = pi2 + 1;
        if (pr2 === pl) {
          this.debug("** at the end");
          for (; fi2 < fl; fi2++) {
            if (file[fi2] === "." || file[fi2] === ".." || !options.dot && file[fi2].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr2 < fl) {
          var swallowee = file[fr2];
          this.debug("\nglobstar while", file, fr2, pattern, pr2, swallowee);
          if (this.matchOne(file.slice(fr2), pattern.slice(pr2), partial)) {
            this.debug("globstar found match!", fr2, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr2, pattern, pr2);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr2++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr2, pattern, pr2);
          if (fr2 === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p5 === "string") {
        hit = f5 === p5;
        this.debug("string match", p5, f5, hit);
      } else {
        hit = p5.test(f5);
        this.debug("pattern match", p5, f5, hit);
      }
      if (!hit)
        return false;
    }
    if (fi2 === fl && pi2 === pl) {
      return true;
    } else if (fi2 === fl) {
      return partial;
    } else if (pi2 === pl) {
      return fi2 === fl - 1 && file[fi2] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m7;
    let fastTest = null;
    if (m7 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m7 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m7[1]);
    } else if (m7 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m7);
    } else if (m7 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m7 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re3 = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re3 === "object") {
      Reflect.defineProperty(re3, "test", { value: fastTest });
    }
    return re3;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re3 = set.map((pattern) => {
      const pp = pattern.map((p5) => {
        if (p5 instanceof RegExp) {
          for (const f5 of p5.flags.split(""))
            flags.add(f5);
        }
        return typeof p5 === "string" ? regExpEscape2(p5) : p5 === GLOBSTAR ? GLOBSTAR : p5._src;
      });
      pp.forEach((p5, i4) => {
        const next = pp[i4 + 1];
        const prev = pp[i4 - 1];
        if (p5 !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i4 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i4] = twoStar;
          }
        } else if (next === void 0) {
          pp[i4 - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i4 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i4 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p5) => p5 !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re3 = "^" + open + re3 + close + "$";
    if (this.negate)
      re3 = "^(?!" + re3 + ").+$";
    try {
      this.regexp = new RegExp(re3, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p5) {
    if (this.preserveMultipleSlashes) {
      return p5.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p5)) {
      return ["", ...p5.split(/\/+/)];
    } else {
      return p5.split(/\/+/);
    }
  }
  match(f5, partial = this.partial) {
    this.debug("match", f5, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f5 === "";
    }
    if (f5 === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f5 = f5.split("\\").join("/");
    }
    const ff = this.slashSplit(f5);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i4 = ff.length - 2; !filename && i4 >= 0; i4--) {
        filename = ff[i4];
      }
    }
    for (let i4 = 0; i4 < set.length; i4++) {
      const pattern = set[i4];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// ../../../node_modules/.pnpm/dedent@1.5.1/node_modules/dedent/dist/dedent.mjs
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var dedent_default = createDedent({});
function createDedent(options) {
  dedent.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings)
    } = options;
    let result = "";
    for (let i4 = 0; i4 < raw.length; i4++) {
      let next = raw[i4];
      if (escapeSpecialCharacters) {
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\{/g, "{");
      }
      result += next;
      if (i4 < values.length) {
        result += values[i4];
      }
    }
    const lines = result.split("\n");
    let mindent = null;
    for (const l3 of lines) {
      const m7 = l3.match(/^(\s+)\S+/);
      if (m7) {
        const indent = m7[1].length;
        if (!mindent) {
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m7 = mindent;
      result = lines.map((l3) => l3[0] === " " || l3[0] === "	" ? l3.slice(m7) : l3).join("\n");
    }
    return result.trim().replace(/\\n/g, "\n");
  }
}

// ../sdk2/dist/json-schema/pattern.js
var import_typebox = __toESM(require_typebox(), 1);
var VariableReference = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("variable"),
  name: import_typebox.Type.String()
});
var Literal = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("literal"),
  name: import_typebox.Type.String()
});
var Option = import_typebox.Type.Object({
  name: import_typebox.Type.String(),
  value: import_typebox.Type.Union([Literal, VariableReference])
});
var FunctionAnnotation = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("function"),
  name: import_typebox.Type.String(),
  options: import_typebox.Type.Array(Option)
});
var Expression = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("expression"),
  arg: import_typebox.Type.Union([VariableReference, Literal]),
  annotation: import_typebox.Type.Optional(FunctionAnnotation)
});
var Text2 = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("text"),
  value: import_typebox.Type.String()
});
var Declaration = import_typebox.Type.Object({
  type: import_typebox.Type.Literal("input"),
  name: import_typebox.Type.String(),
  value: Expression
});
var Pattern = import_typebox.Type.Array(import_typebox.Type.Union([Text2, Expression]));

// ../sdk2/dist/human-id/human-id.js
var import_murmurhash3js = __toESM(require_murmurhash3js(), 1);

// ../sdk2/dist/json-schema/settings.js
var import_typebox2 = __toESM(require_typebox(), 1);
var SDKSettings = import_typebox2.Type.Object({
  // TODO SDK-v2 SETTINGS do we need to generate a settings v2 schema?
  $schema: import_typebox2.Type.Optional(import_typebox2.Type.Literal("https://inlang.com/schema/project-settings")),
  baseLocale: import_typebox2.Type.String({
    title: "Base locale",
    description: "The base locale of the project. We recommend BCP-47 language tags."
  }),
  locales: import_typebox2.Type.Array(import_typebox2.Type.String(), {
    uniqueItems: true,
    title: "Project Locales",
    description: "Set the locales that are available in your project. All locales needs to be a valid BCP-47 language tag. Needs to include the base locale tag."
  }),
  // exits for backwards compatibility
  // remove in SDK-v3
  sourceLanguageTag: import_typebox2.Type.Optional(import_typebox2.Type.String({
    description: "Use baseLocale instead.",
    deprecated: true
  })),
  // exits for backwards compatibility
  // remove in SDK-v3
  languageTags: import_typebox2.Type.Optional(import_typebox2.Type.Array(import_typebox2.Type.String(), {
    uniqueItems: true,
    deprecated: true,
    description: "Use locales instead."
  })),
  /**
   * The modules to load.
   *
   * @example
   *  modules: [
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
   *  ]
   */
  modules: import_typebox2.Type.Optional(import_typebox2.Type.Array(import_typebox2.Type.Intersect([
    import_typebox2.Type.String({
      description: "The module must be a valid URI according to RFC 3986.",
      pattern: "(?:[A-Za-z][A-Za-z0-9+.-]*:/{2})?(?:(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})+(?::([A-Za-z0-9-._~]?|[%][A-Fa-f0-9]{2})+)?@)?(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.){1,126}[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?::[0-9]+)?(?:/(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})*)*(?:\\?(?:[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)(?:&|;[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)*)?"
    }),
    import_typebox2.Type.String({
      description: "The module must end with `.js`.",
      pattern: ".*\\.js$"
    }),
    import_typebox2.Type.String({
      description: "The module can only contain a major version number.",
      pattern: "^(?!.*@\\d\\.)[^]*$"
    })
  ]), {
    uniqueItems: true,
    description: "The modules to load. Must be a valid URI but can be relative.",
    examples: [
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
      "./local-testing-plugin.js"
    ]
  })),
  telemetry: import_typebox2.Type.Optional(import_typebox2.Type.Union([
    import_typebox2.Type.Literal("off", {
      description: "No telemetry events "
    })
  ], { description: "If not set, defaults to all" })),
  experimental: import_typebox2.Type.Optional(import_typebox2.Type.Record(import_typebox2.Type.String(), import_typebox2.Type.Literal(true), {
    title: "Experimental settings",
    description: "Experimental settings that are used for product development."
  }))
  /**
   * plugin.*: JSONObject
   *
   * The plugin settings are validated when importing plugins
   */
});
var ExternalSettings = import_typebox2.Type.Record(
  import_typebox2.Type.String({
    pattern: `^((plugin)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)|\\$schema|${// pattern must include the settings properties
    Object.keys(SDKSettings.properties).map((key) => key.replaceAll(".", "\\.")).join("|")})$`,
    description: "The key must be conform to `plugin.*`.",
    examples: ["plugin.csv-importer", "plugin.i18next"]
  }),
  // Using JSON (array and object) as a workaround to make the
  // intersection between `InternalSettings`, which contains an array,
  // and `ExternalSettings` which are objects possible
  import_typebox2.Type.Record(import_typebox2.Type.String(), import_typebox2.Type.Any()),
  { description: "Settings defined by apps, plugins, etc." }
);
var ProjectSettings = import_typebox2.Type.Intersect([SDKSettings, ExternalSettings]);

// ../sdk2/dist/helper.js
function createVariant(args) {
  return {
    messageId: args.messageId,
    id: args.id ? args.id : v4_default(),
    match: args.match ? args.match : {},
    pattern: args.pattern ? args.pattern : [toTextElement(args.text ?? "")]
  };
}
function toTextElement(text) {
  return {
    type: "text",
    value: text
  };
}

// ../bundle-component/dist/helper/event.js
var createChangeEvent = (props) => {
  const onChangeEvent = new CustomEvent("change", {
    bubbles: true,
    composed: true,
    detail: {
      argument: {
        type: props.type,
        operation: props.operation,
        newData: props.newData,
        meta: props.meta
      }
    }
  });
  return onChangeEvent;
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7DUCI5S4.js
var spinner_styles_default = i`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+localize@3.2.1/node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var translations = /* @__PURE__ */ new Map();
var fallback;
var documentDirection = "ltr";
var documentLanguage = "en";
var isClient = typeof MutationObserver !== "undefined" && typeof document !== "undefined" && typeof document.documentElement !== "undefined";
if (isClient) {
  const documentElementObserver = new MutationObserver(update);
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  documentElementObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["dir", "lang"]
  });
}
function registerTranslation(...translation2) {
  translation2.map((t5) => {
    const code = t5.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t5));
    } else {
      translations.set(code, t5);
    }
    if (!fallback) {
      fallback = t5;
    }
  });
  update();
}
function update() {
  if (isClient) {
    documentDirection = document.documentElement.dir || "ltr";
    documentLanguage = document.documentElement.lang || navigator.language;
  }
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a;
    const { primary, secondary } = this.getTranslationData((_a = options.lang) !== null && _a !== void 0 ? _a : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MAS2SHYD.js
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num2) => {
    if (num2 === 0)
      return "No options selected";
    if (num2 === 1)
      return "1 option selected";
    return `${num2} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WLV3FVBR.js
var LocalizeController2 = class extends LocalizeController {
};
registerTranslation(en_default);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUVJKY7S.js
var component_styles_default = i`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IFDWM6P4.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a3, b5) => {
  for (var prop in b5 || (b5 = {}))
    if (__hasOwnProp2.call(b5, prop))
      __defNormalProp(a3, prop, b5[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b5)) {
      if (__propIsEnum.call(b5, prop))
        __defNormalProp(a3, prop, b5[prop]);
    }
  return a3;
};
var __spreadProps = (a3, b5) => __defProps(a3, __getOwnPropDescs(b5));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
    if (decorator = decorators[i4])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RVOOE4AQ.js
var ShoelaceElement = class extends h3 {
  constructor() {
    super();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      customElements.define(name, class extends elementConstructor {
      }, options);
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.14.0";
ShoelaceElement.dependencies = {};
__decorateClass([
  n4()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass([
  n4()
], ShoelaceElement.prototype, "lang", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TY4GUJRD.js
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
  }
  render() {
    return ke`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DL5222VR.js
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a = formCollections.get(this.form)) == null ? void 0 : _a.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.getElementById(formId);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a;
        return (_a = input.disabled) != null ? _a : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a;
    return (_a = this.form) != null ? _a : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  customError: true
}));

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QPYT3OK4.js
var button_styles_default = i`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      .sl-button-group__button:not(
          .sl-button-group__button--first,
          .sl-button-group__button--radio,
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host(.sl-button-group__button--focus),
  :host(.sl-button-group__button[checked]) {
    z-index: 2;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NYIIDP5N.js
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
function getTextContent(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({ flatten: true });
  let text = "";
  [...nodes].forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3Y6SB6QS.js
var basePath = "";
function setBasePath(path2) {
  basePath = path2;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s3) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s3.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s3.src);
      });
      let path2 = "";
      if (fallbackScript) {
        path2 = fallbackScript.getAttribute("src");
      }
      setBasePath(path2.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P7ZG6EMR.js
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`)
};
var library_default_default = library;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3TFKS637.js
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZL53POKZ.js
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QLXRCYS4.js
var icon_styles_default = i`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2FB5TK5H.js
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update2 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update2.call(this, changedProps);
    };
  };
}

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directive-helpers.js
var { I: et2 } = si;
var nt = (o5, t5) => void 0 === t5 ? void 0 !== o5?._$litType$ : o5?._$litType$ === t5;
var rt = (o5) => void 0 === o5.strings;
var ht = {};
var dt = (o5, t5 = ht) => o5._$AH = t5;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7YG67M3U.js
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library2) {
    var _a;
    let fileData;
    if (library2 == null ? void 0 : library2.spriteSheet) {
      return ke`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e6) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR;
      if (!parser)
        parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e6) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return {
        url: library2.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a;
    const { url, fromLibrary } = this.getIconSource();
    const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library2);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (nt(svg)) {
      this.svg = svg;
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a = library2 == null ? void 0 : library2.mutator) == null ? void 0 : _a.call(library2, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([
  r4()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  n4({ reflect: true })
], SlIcon.prototype, "name", 2);
__decorateClass([
  n4()
], SlIcon.prototype, "src", 2);
__decorateClass([
  n4()
], SlIcon.prototype, "label", 2);
__decorateClass([
  n4({ reflect: true })
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directive.js
var t3 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e4 = (t5) => (...e6) => ({ _$litDirective$: t5, values: e6 });
var i2 = class {
  constructor(t5) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t5, e6, i4) {
    this.t = t5, this._$AM = e6, this.i = i4;
  }
  _$AS(t5, e6) {
    return this.update(t5, e6);
  }
  update(t5, e6) {
    return this.render(...e6);
  }
};

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/class-map.js
var Rt = e4(class extends i2 {
  constructor(s3) {
    if (super(s3), s3.type !== t3.ATTRIBUTE || "class" !== s3.name || s3.strings?.length > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t5) {
    return " " + Object.keys(t5).filter((s3) => t5[s3]).join(" ") + " ";
  }
  update(t5, [s3]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t5.strings && (this.nt = new Set(t5.strings.join(" ").split(/\s/).filter((t6) => "" !== t6)));
      for (const t6 in s3)
        s3[t6] && !this.nt?.has(t6) && this.st.add(t6);
      return this.render(s3);
    }
    const i4 = t5.element.classList;
    for (const t6 of this.st)
      t6 in s3 || (i4.remove(t6), this.st.delete(t6));
    for (const t6 in s3) {
      const r6 = !!s3[t6];
      r6 === this.st.has(t6) || this.nt?.has(t6) || (r6 ? (i4.add(t6), this.st.add(t6)) : (i4.remove(t6), this.st.delete(t6)));
    }
    return R;
  }
});

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/static.js
var $e = Symbol.for("");
var xe = (t5) => {
  if (t5?.r === $e)
    return t5?._$litStatic$;
};
var er = (t5, ...r6) => ({ _$litStatic$: r6.reduce((r7, e6, a3) => r7 + ((t6) => {
  if (void 0 !== t6._$litStatic$)
    return t6._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t6}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e6) + t5[a3 + 1], t5[0]), r: $e });
var Te = /* @__PURE__ */ new Map();
var Ee = (t5) => (r6, ...e6) => {
  const a3 = e6.length;
  let o5, s3;
  const i4 = [], l3 = [];
  let n6, u3 = 0, c5 = false;
  for (; u3 < a3; ) {
    for (n6 = r6[u3]; u3 < a3 && void 0 !== (s3 = e6[u3], o5 = xe(s3)); )
      n6 += o5 + r6[++u3], c5 = true;
    u3 !== a3 && l3.push(s3), i4.push(n6), u3++;
  }
  if (u3 === a3 && i4.push(r6[a3]), c5) {
    const t6 = i4.join("$$lit$$");
    void 0 === (r6 = Te.get(t6)) && (i4.raw = i4, Te.set(t6, r6 = i4)), e6 = l3;
  }
  return t5(r6, ...e6);
};
var ke2 = Ee(ke);
var Oe2 = Ee(Oe);
var Se2 = Ee(Se);

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/if-defined.js
var to = (t5) => t5 ?? D;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.64QWL6LI.js
var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? er`a` : er`button`;
    return ke2`
      <${tag}
        part="base"
        class=${Rt({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${to(isLink ? void 0 : this.name)}
        value=${to(isLink ? void 0 : this.value)}
        href=${to(isLink ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink ? this.rel : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? ke2` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? ke2`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e3(".button")
], SlButton.prototype, "button", 2);
__decorateClass([
  r4()
], SlButton.prototype, "hasFocus", 2);
__decorateClass([
  r4()
], SlButton.prototype, "invalid", 2);
__decorateClass([
  n4()
], SlButton.prototype, "title", 2);
__decorateClass([
  n4({ reflect: true })
], SlButton.prototype, "variant", 2);
__decorateClass([
  n4({ reflect: true })
], SlButton.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "caret", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "loading", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "outline", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "pill", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "circle", 2);
__decorateClass([
  n4()
], SlButton.prototype, "type", 2);
__decorateClass([
  n4()
], SlButton.prototype, "name", 2);
__decorateClass([
  n4()
], SlButton.prototype, "value", 2);
__decorateClass([
  n4()
], SlButton.prototype, "href", 2);
__decorateClass([
  n4()
], SlButton.prototype, "target", 2);
__decorateClass([
  n4()
], SlButton.prototype, "rel", 2);
__decorateClass([
  n4()
], SlButton.prototype, "download", 2);
__decorateClass([
  n4()
], SlButton.prototype, "form", 2);
__decorateClass([
  n4({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass([
  n4({ attribute: "formenctype" })
], SlButton.prototype, "formEnctype", 2);
__decorateClass([
  n4({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass([
  n4({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass([
  n4({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlButton.prototype, "handleDisabledChange", 1);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXP7GVU3.js
var dropdown_styles_default = i`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXDTFLWU.js
var computedStyleMap = /* @__PURE__ */ new WeakMap();
function getCachedComputedStyle(el) {
  let computedStyle = computedStyleMap.get(el);
  if (!computedStyle) {
    computedStyle = window.getComputedStyle(el, null);
    computedStyleMap.set(el, computedStyle);
  }
  return computedStyle;
}
function isVisible(el) {
  if (typeof el.checkVisibility === "function") {
    return el.checkVisibility({ checkOpacity: false, checkVisibilityCSS: true });
  }
  const computedStyle = getCachedComputedStyle(el);
  return computedStyle.visibility !== "hidden" && computedStyle.display !== "none";
}
function isOverflowingAndTabbable(el) {
  const computedStyle = getCachedComputedStyle(el);
  const { overflowY, overflowX } = computedStyle;
  if (overflowY === "scroll" || overflowX === "scroll") {
    return true;
  }
  if (overflowY !== "auto" || overflowX !== "auto") {
    return false;
  }
  const isOverflowingY = el.scrollHeight > el.clientHeight;
  if (isOverflowingY && overflowY === "auto") {
    return true;
  }
  const isOverflowingX = el.scrollWidth > el.clientWidth;
  if (isOverflowingX && overflowX === "auto") {
    return true;
  }
  return false;
}
function isTabbable(el) {
  const tag = el.tagName.toLowerCase();
  const tabindex = Number(el.getAttribute("tabindex"));
  const hasTabindex = el.hasAttribute("tabindex");
  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.closest("[inert]")) {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) {
    return false;
  }
  if (!isVisible(el)) {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
    return true;
  }
  const isNativelyTabbable = [
    "button",
    "input",
    "select",
    "textarea",
    "a",
    "audio",
    "video",
    "summary",
    "iframe"
  ].includes(tag);
  if (isNativelyTabbable) {
    return true;
  }
  return isOverflowingAndTabbable(el);
}
function getTabbableBoundary(root) {
  var _a, _b;
  const tabbableElements = getTabbableElements(root);
  const start = (_a = tabbableElements[0]) != null ? _a : null;
  const end = (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;
  return { start, end };
}
function getSlottedChildrenOutsideRootElement(slotElement, root) {
  var _a;
  return ((_a = slotElement.getRootNode({ composed: true })) == null ? void 0 : _a.host) !== root;
}
function getTabbableElements(root) {
  const walkedEls = /* @__PURE__ */ new WeakMap();
  const tabbableElements = [];
  function walk(el) {
    if (el instanceof Element) {
      if (el.hasAttribute("inert") || el.closest("[inert]")) {
        return;
      }
      if (walkedEls.has(el)) {
        return;
      }
      walkedEls.set(el, true);
      if (!tabbableElements.includes(el) && isTabbable(el)) {
        tabbableElements.push(el);
      }
      if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root)) {
        el.assignedElements({ flatten: true }).forEach((assignedEl) => {
          walk(assignedEl);
        });
      }
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    for (const e6 of el.children) {
      walk(e6);
    }
  }
  walk(root);
  return tabbableElements.sort((a3, b5) => {
    const aTabindex = Number(a3.getAttribute("tabindex")) || 0;
    const bTabindex = Number(b5.getAttribute("tabindex")) || 0;
    return bTabindex - aTabindex;
  });
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3KSWVBQ5.js
var popup_styles_default = i`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

// ../../../node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min5 = Math.min;
var max5 = Math.max;
var round8 = Math.round;
var floor5 = Math.floor;
var createCoords = (v8) => ({
  x: v8,
  y: v8
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max5(start, min5(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr2 = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt3 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr2;
      return isStart ? lr2 : rl;
    case "left":
    case "right":
      return isStart ? tb : bt3;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x6,
    y: y7,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y7,
    left: x6,
    right: x6 + width,
    bottom: y7 + height,
    x: x6,
    y: y7
  };
}

// ../../../node_modules/.pnpm/@floating-ui+core@1.6.7/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x6,
    y: y7
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i4 = 0; i4 < validMiddleware.length; i4++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i4];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x6,
      y: y7,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x6 = nextX != null ? nextX : x6;
    y7 = nextY != null ? nextY : y7;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x6,
          y: y7
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i4 = -1;
    }
  }
  return {
    x: x6,
    y: y7,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x6,
    y: y7,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x6,
    y: y7,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent2 = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent2)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent2)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent: offsetParent2,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x6,
      y: y7,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x6,
      y: y7
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min5(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min5(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max6 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max6);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max6 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d4) => d4.overflows[0] <= 0).sort((a3, b5) => a3.overflows[1] - b5.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d4) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d4.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d4) => [d4.placement, d4.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b5) => a3[1] - b5[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x6,
        y: y7,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x6 + diffCoords.x,
        y: y7 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x6,
        y: y7,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x7,
              y: y8
            } = _ref;
            return {
              x: x7,
              y: y8
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x6,
        y: y7
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min6 = mainAxisCoord + overflow[minSide];
        const max6 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min6, mainAxisCoord, max6);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min6 = crossAxisCoord + overflow[minSide];
        const max6 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min6, crossAxisCoord, max6);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x6,
          y: limitedCoords.y - y7
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min5(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min5(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min5(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min5(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max5(overflow.left, 0);
        const xMax = max5(overflow.right, 0);
        const yMin = max5(overflow.top, 0);
        const yMax = max5(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max5(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max5(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../../node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e6) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../../node_modules/.pnpm/@floating-ui+dom@1.6.10/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round8(width) !== offsetWidth || round8(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $5
  } = getCssDimensions(domElement);
  let x6 = ($5 ? round8(rect.width) : rect.width) / width;
  let y7 = ($5 ? round8(rect.height) : rect.height) / height;
  if (!x6 || !Number.isFinite(x6)) {
    x6 = 1;
  }
  if (!y7 || !Number.isFinite(y7)) {
    y7 = 1;
  }
  return {
    x: x6,
    y: y7
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent2) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent2) {
      if (isElement(offsetParent2)) {
        scale = getScale(offsetParent2);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent2) ? getVisualOffsets(domElement) : createCoords(0);
  let x6 = (clientRect.left + visualOffsets.x) / scale.x;
  let y7 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent2 && isElement(offsetParent2) ? getWindow(offsetParent2) : offsetParent2;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent2 && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x6 *= iframeScale.x;
      y7 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x6 += left;
      y7 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x6,
    y: y7
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent: offsetParent2,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent2);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent2 === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent2);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent2) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent2);
    }
    if (isHTMLElement(offsetParent2)) {
      const offsetRect = getBoundingClientRect(offsetParent2);
      scale = getScale(offsetParent2);
      offsets.x = offsetRect.x + offsetParent2.clientLeft;
      offsets.y = offsetRect.y + offsetParent2.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max5(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max5(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x6 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y7 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x6 += max5(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x6,
    y: y7
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x6 = 0;
  let y7 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x6 = visualViewport.offsetLeft;
      y7 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x6,
    y: y7
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x6 = left * scale.x;
  const y7 = top * scale.y;
  return {
    width,
    height,
    x: x6,
    y: y7
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max5(rect.top, accRect.top);
    accRect.right = min5(rect.right, accRect.right);
    accRect.bottom = min5(rect.bottom, accRect.bottom);
    accRect.left = max5(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent2, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent2);
  const documentElement = getDocumentElement(offsetParent2);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent2);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent2) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent2);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent2, true, isFixed, offsetParent2);
      offsets.x = offsetRect.x + offsetParent2.clientLeft;
      offsets.y = offsetRect.y + offsetParent2.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x6 = rect.left + scroll.scrollLeft - offsets.x;
  const y7 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x6,
    y: y7,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent2 = getTrueOffsetParent(element, polyfill);
  while (offsetParent2 && isTableElement(offsetParent2) && isStaticPositioned(offsetParent2)) {
    offsetParent2 = getTrueOffsetParent(offsetParent2, polyfill);
  }
  if (offsetParent2 && isLastTraversableNode(offsetParent2) && isStaticPositioned(offsetParent2) && !isContainingBlock(offsetParent2)) {
    return win;
  }
  return offsetParent2 || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor5(top);
    const insetRight = floor5(root.clientWidth - (left + width));
    const insetBottom = floor5(root.clientHeight - (top + height));
    const insetLeft = floor5(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max5(0, min5(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e6) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../../node_modules/.pnpm/composed-offset-position@0.0.4/node_modules/composed-offset-position/dist/composed-offset-position.mjs
function offsetParent(element) {
  return offsetParentPolyfill(element);
}
function flatTreeParent(element) {
  if (element.assignedSlot) {
    return element.assignedSlot;
  }
  if (element.parentNode instanceof ShadowRoot) {
    return element.parentNode.host;
  }
  return element.parentNode;
}
function offsetParentPolyfill(element) {
  for (let ancestor = element; ancestor; ancestor = flatTreeParent(ancestor)) {
    if (!(ancestor instanceof Element)) {
      continue;
    }
    if (getComputedStyle(ancestor).display === "none") {
      return null;
    }
  }
  for (let ancestor = flatTreeParent(element); ancestor; ancestor = flatTreeParent(ancestor)) {
    if (!(ancestor instanceof Element)) {
      continue;
    }
    const style = getComputedStyle(ancestor);
    if (style.display === "contents") {
      continue;
    }
    if (style.position !== "static" || style.filter !== "none") {
      return ancestor;
    }
    if (ancestor.tagName === "BODY") {
      return ancestor;
    }
  }
  return null;
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JLIBGQ2M.js
function isVirtualElement(e6) {
  return e6 !== null && typeof e6 === "object" && "getBoundingClientRect" in e6;
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset2({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size2({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip2({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift2({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size2({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow2({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent2 = this.strategy === "absolute" ? (element) => platform.getOffsetParent(element, offsetParent) : platform.getOffsetParent;
    computePosition2(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: getOffsetParent2
      })
    }).then(({ x: x6, y: y7, middlewareData, placement }) => {
      const isRtl = getComputedStyle(this).direction === "rtl";
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x6}px`,
        top: `${y7}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return ke`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${Rt({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${Rt({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? ke`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([
  e3(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass([
  e3(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass([
  n4()
], SlPopup.prototype, "anchor", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlPopup.prototype, "active", 2);
__decorateClass([
  n4({ reflect: true })
], SlPopup.prototype, "placement", 2);
__decorateClass([
  n4({ reflect: true })
], SlPopup.prototype, "strategy", 2);
__decorateClass([
  n4({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass([
  n4({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass([
  n4({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass([
  n4({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass([
  n4({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p5) => p5.trim()).filter((p5) => p5 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass([
  n4({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass([
  n4({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass([
  n4({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass([
  n4({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass([
  n4()
], SlPopup.prototype, "sync", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass([
  n4({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass([
  n4({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DHU6MIVB.js
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B4BZKR24.js
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LHI6QEL2.js
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function parseDuration(delay) {
  delay = delay.toString().toLowerCase();
  if (delay.indexOf("ms") > -1) {
    return parseFloat(delay);
  }
  if (delay.indexOf("s") > -1) {
    return parseFloat(delay) * 1e3;
  }
  return parseFloat(delay);
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5KKDCP3M.js
var SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
    this.handleKeyDown = (event) => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
        this.focusOnTrigger();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      var _a;
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.stopPropagation();
        this.focusOnTrigger();
        this.hide();
        return;
      }
      if (event.key === "Tab") {
        if (this.open && ((_a = document.activeElement) == null ? void 0 : _a.tagName.toLowerCase()) === "sl-menu-item") {
          event.preventDefault();
          this.hide();
          this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var _a2, _b, _c;
          const activeElement = ((_a2 = this.containingElement) == null ? void 0 : _a2.getRootNode()) instanceof ShadowRoot ? (_c = (_b = document.activeElement) == null ? void 0 : _b.shadowRoot) == null ? void 0 : _c.activeElement : document.activeElement;
          if (!this.containingElement || (activeElement == null ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {
            this.hide();
          }
        });
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path2 = event.composedPath();
      if (this.containingElement && !path2.includes(this.containingElement)) {
        this.hide();
      }
    };
    this.handlePanelSelect = (event) => {
      const target = event.target;
      if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
        this.hide();
        this.focusOnTrigger();
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.popup.active = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
  }
  focusOnTrigger() {
    const trigger = this.trigger.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    return this.panel.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
      this.focusOnTrigger();
    }
  }
  async handleTriggerKeyDown(event) {
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.getAllItems();
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
          await this.updateComplete;
        }
        if (menuItems.length > 0) {
          this.updateComplete.then(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const assignedElements = this.trigger.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary(el).start);
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var _a;
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        this.hide();
        this.focusOnTrigger();
      };
    } else {
      this.panel.addEventListener("keydown", this.handleKeyDown);
    }
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a;
    if (this.panel) {
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      this.panel.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.panel.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "dropdown.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "dropdown.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.panel.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  render() {
    return ke`
      <sl-popup
        part="base"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        class=${Rt({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = { "sl-popup": SlPopup };
__decorateClass([
  e3(".dropdown")
], SlDropdown.prototype, "popup", 2);
__decorateClass([
  e3(".dropdown__trigger")
], SlDropdown.prototype, "trigger", 2);
__decorateClass([
  e3(".dropdown__panel")
], SlDropdown.prototype, "panel", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlDropdown.prototype, "open", 2);
__decorateClass([
  n4({ reflect: true })
], SlDropdown.prototype, "placement", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlDropdown.prototype, "disabled", 2);
__decorateClass([
  n4({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass([
  n4({ attribute: false })
], SlDropdown.prototype, "containingElement", 2);
__decorateClass([
  n4({ type: Number })
], SlDropdown.prototype, "distance", 2);
__decorateClass([
  n4({ type: Number })
], SlDropdown.prototype, "skidding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlDropdown.prototype, "hoist", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDropdown.prototype, "handleOpenChange", 1);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VVA35HTY.js
var menu_styles_default = i`
  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2SLLA5P2.js
var SlMenu = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menu");
  }
  handleClick(event) {
    const menuItemTypes = ["menuitem", "menuitemcheckbox"];
    const target = event.composedPath().find((el) => {
      var _a;
      return menuItemTypes.includes(((_a = el == null ? void 0 : el.getAttribute) == null ? void 0 : _a.call(el, "role")) || "");
    });
    if (!target)
      return;
    const item = target;
    if (item.type === "checkbox") {
      item.checked = !item.checked;
    }
    this.emit("sl-select", { detail: { item } });
  }
  handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      const item = this.getCurrentItem();
      event.preventDefault();
      event.stopPropagation();
      item == null ? void 0 : item.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
      const items = this.getAllItems();
      const activeItem = this.getCurrentItem();
      let index = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "ArrowDown") {
          index++;
        } else if (event.key === "ArrowUp") {
          index--;
        } else if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = items.length - 1;
        }
        if (index < 0) {
          index = items.length - 1;
        }
        if (index > items.length - 1) {
          index = 0;
        }
        this.setCurrentItem(items[index]);
        items[index].focus();
      }
    }
  }
  handleMouseDown(event) {
    const target = event.target;
    if (this.isMenuItem(target)) {
      this.setCurrentItem(target);
    }
  }
  handleSlotChange() {
    const items = this.getAllItems();
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  isMenuItem(item) {
    var _a;
    return item.tagName.toLowerCase() === "sl-menu-item" || ["menuitem", "menuitemcheckbox", "menuitemradio"].includes((_a = item.getAttribute("role")) != null ? _a : "");
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: true })].filter((el) => {
      if (el.inert || !this.isMenuItem(el)) {
        return false;
      }
      return true;
    });
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((i4) => i4.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(item) {
    const items = this.getAllItems();
    items.forEach((i4) => {
      i4.setAttribute("tabindex", i4 === item ? "0" : "-1");
    });
  }
  render() {
    return ke`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu.styles = [component_styles_default, menu_styles_default];
__decorateClass([
  e3("slot")
], SlMenu.prototype, "defaultSlot", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWZXGPBI.js
var menu_item_styles_default = i`
  :host {
    --submenu-offset: -2px;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item.menu-item--loading {
    outline: none;
    cursor: wait;
  }

  .menu-item.menu-item--loading *:not(sl-spinner) {
    opacity: 0.5;
  }

  .menu-item--loading sl-spinner {
    --indicator-color: currentColor;
    --track-width: 1px;
    position: absolute;
    font-size: 0.75em;
    top: calc(50% - 0.5em);
    left: 0.65rem;
    opacity: 1;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x, 0) var(--safe-triangle-cursor-y, 0),
      var(--safe-triangle-submenu-start-x, 0) var(--safe-triangle-submenu-start-y, 0),
      var(--safe-triangle-submenu-end-x, 0) var(--safe-triangle-submenu-end-y, 0)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/async-directive.js
var mt = (i4, t5) => {
  const e6 = i4._$AN;
  if (void 0 === e6)
    return false;
  for (const i5 of e6)
    i5._$AO?.(t5, false), mt(i5, t5);
  return true;
};
var _t = (i4) => {
  let t5, e6;
  do {
    if (void 0 === (t5 = i4._$AM))
      break;
    e6 = t5._$AN, e6.delete(i4), i4 = t5;
  } while (0 === e6?.size);
};
var wt = (i4) => {
  for (let t5; t5 = i4._$AM; i4 = t5) {
    let e6 = t5._$AN;
    if (void 0 === e6)
      t5._$AN = e6 = /* @__PURE__ */ new Set();
    else if (e6.has(i4))
      break;
    e6.add(i4), gt(t5);
  }
};
function bt(i4) {
  void 0 !== this._$AN ? (_t(this), this._$AM = i4, wt(this)) : this._$AM = i4;
}
function yt(i4, t5 = false, e6 = 0) {
  const s3 = this._$AH, o5 = this._$AN;
  if (void 0 !== o5 && 0 !== o5.size)
    if (t5)
      if (Array.isArray(s3))
        for (let i5 = e6; i5 < s3.length; i5++)
          mt(s3[i5], false), _t(s3[i5]);
      else
        null != s3 && (mt(s3, false), _t(s3));
    else
      mt(this, i4);
}
var gt = (i4) => {
  i4.type == t3.CHILD && (i4._$AP ??= yt, i4._$AQ ??= bt);
};
var $t = class extends i2 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i4, t5, e6) {
    super._$AT(i4, t5, e6), wt(this), this.isConnected = i4._$AU;
  }
  _$AO(i4, t5 = true) {
    i4 !== this.isConnected && (this.isConnected = i4, i4 ? this.reconnected?.() : this.disconnected?.()), t5 && (mt(this, i4), _t(this));
  }
  setValue(i4) {
    if (rt(this.t))
      this.t._$AI(i4, this);
    else {
      const t5 = [...this.t._$AH];
      t5[this.i] = i4, this.t._$AI(t5, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/ref.js
var ii = () => new Zt();
var Zt = class {
};
var qt = /* @__PURE__ */ new WeakMap();
var Kt = e4(class extends $t {
  render(t5) {
    return D;
  }
  update(t5, [i4]) {
    const s3 = i4 !== this.Y;
    return s3 && void 0 !== this.Y && this.rt(void 0), (s3 || this.lt !== this.ct) && (this.Y = i4, this.ht = t5.options?.host, this.rt(this.ct = t5.element)), D;
  }
  rt(t5) {
    if (this.isConnected || (t5 = void 0), "function" == typeof this.Y) {
      const i4 = this.ht ?? globalThis;
      let s3 = qt.get(i4);
      void 0 === s3 && (s3 = /* @__PURE__ */ new WeakMap(), qt.set(i4, s3)), void 0 !== s3.get(this.Y) && this.Y.call(this.ht, void 0), s3.set(this.Y, t5), void 0 !== t5 && this.Y.call(this.ht, t5);
    } else
      this.Y.value = t5;
  }
  get lt() {
    return "function" == typeof this.Y ? qt.get(this.ht ?? globalThis)?.get(this.Y) : this.Y?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GZKJ6PRL.js
var SubmenuController = class {
  constructor(host, hasSlotController, localize) {
    this.popupRef = ii();
    this.enableSubmenuTimer = -1;
    this.isConnected = false;
    this.isPopupConnected = false;
    this.skidding = 0;
    this.submenuOpenDelay = 100;
    this.handleMouseMove = (event) => {
      this.host.style.setProperty("--safe-triangle-cursor-x", `${event.clientX}px`);
      this.host.style.setProperty("--safe-triangle-cursor-y", `${event.clientY}px`);
    };
    this.handleMouseOver = () => {
      if (this.hasSlotController.test("submenu")) {
        this.enableSubmenu();
      }
    };
    this.handleKeyDown = (event) => {
      switch (event.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          if (event.target !== this.host) {
            event.preventDefault();
            event.stopPropagation();
            this.host.focus();
            this.disableSubmenu();
          }
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(event);
          break;
        default:
          break;
      }
    };
    this.handleClick = (event) => {
      var _a;
      if (event.target === this.host) {
        event.preventDefault();
        event.stopPropagation();
      } else if (event.target instanceof Element && (event.target.tagName === "sl-menu-item" || ((_a = event.target.role) == null ? void 0 : _a.startsWith("menuitem")))) {
        this.disableSubmenu();
      }
    };
    this.handleFocusOut = (event) => {
      if (event.relatedTarget && event.relatedTarget instanceof Element && this.host.contains(event.relatedTarget)) {
        return;
      }
      this.disableSubmenu();
    };
    this.handlePopupMouseover = (event) => {
      event.stopPropagation();
    };
    this.handlePopupReposition = () => {
      const submenuSlot = this.host.renderRoot.querySelector("slot[name='submenu']");
      const menu = submenuSlot == null ? void 0 : submenuSlot.assignedElements({ flatten: true }).filter((el) => el.localName === "sl-menu")[0];
      const isRtl = this.localize.dir() === "rtl";
      if (!menu) {
        return;
      }
      const { left, top, width, height } = menu.getBoundingClientRect();
      this.host.style.setProperty("--safe-triangle-submenu-start-x", `${isRtl ? left + width : left}px`);
      this.host.style.setProperty("--safe-triangle-submenu-start-y", `${top}px`);
      this.host.style.setProperty("--safe-triangle-submenu-end-x", `${isRtl ? left + width : left}px`);
      this.host.style.setProperty("--safe-triangle-submenu-end-y", `${top + height}px`);
    };
    (this.host = host).addController(this);
    this.hasSlotController = hasSlotController;
    this.localize = localize;
  }
  hostConnected() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
    }
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
      this.updateSkidding();
    } else {
      this.removeListeners();
    }
  }
  addListeners() {
    if (!this.isConnected) {
      this.host.addEventListener("mousemove", this.handleMouseMove);
      this.host.addEventListener("mouseover", this.handleMouseOver);
      this.host.addEventListener("keydown", this.handleKeyDown);
      this.host.addEventListener("click", this.handleClick);
      this.host.addEventListener("focusout", this.handleFocusOut);
      this.isConnected = true;
    }
    if (!this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.addEventListener("mouseover", this.handlePopupMouseover);
        this.popupRef.value.addEventListener("sl-reposition", this.handlePopupReposition);
        this.isPopupConnected = true;
      }
    }
  }
  removeListeners() {
    if (this.isConnected) {
      this.host.removeEventListener("mousemove", this.handleMouseMove);
      this.host.removeEventListener("mouseover", this.handleMouseOver);
      this.host.removeEventListener("keydown", this.handleKeyDown);
      this.host.removeEventListener("click", this.handleClick);
      this.host.removeEventListener("focusout", this.handleFocusOut);
      this.isConnected = false;
    }
    if (this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.removeEventListener("mouseover", this.handlePopupMouseover);
        this.popupRef.value.removeEventListener("sl-reposition", this.handlePopupReposition);
        this.isPopupConnected = false;
      }
    }
  }
  handleSubmenuEntry(event) {
    const submenuSlot = this.host.renderRoot.querySelector("slot[name='submenu']");
    if (!submenuSlot) {
      console.error("Cannot activate a submenu if no corresponding menuitem can be found.", this);
      return;
    }
    let menuItems = null;
    for (const elt of submenuSlot.assignedElements()) {
      menuItems = elt.querySelectorAll("sl-menu-item, [role^='menuitem']");
      if (menuItems.length !== 0) {
        break;
      }
    }
    if (!menuItems || menuItems.length === 0) {
      return;
    }
    menuItems[0].setAttribute("tabindex", "0");
    for (let i4 = 1; i4 !== menuItems.length; ++i4) {
      menuItems[i4].setAttribute("tabindex", "-1");
    }
    if (this.popupRef.value) {
      event.preventDefault();
      event.stopPropagation();
      if (this.popupRef.value.active) {
        if (menuItems[0] instanceof HTMLElement) {
          menuItems[0].focus();
        }
      } else {
        this.enableSubmenu(false);
        this.host.updateComplete.then(() => {
          if (menuItems[0] instanceof HTMLElement) {
            menuItems[0].focus();
          }
        });
        this.host.requestUpdate();
      }
    }
  }
  setSubmenuState(state) {
    if (this.popupRef.value) {
      if (this.popupRef.value.active !== state) {
        this.popupRef.value.active = state;
        this.host.requestUpdate();
      }
    }
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(delay = true) {
    if (delay) {
      this.enableSubmenuTimer = window.setTimeout(() => {
        this.setSubmenuState(true);
      }, this.submenuOpenDelay);
    } else {
      this.setSubmenuState(true);
    }
  }
  disableSubmenu() {
    clearTimeout(this.enableSubmenuTimer);
    this.setSubmenuState(false);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var _a;
    if (!((_a = this.host.parentElement) == null ? void 0 : _a.computedStyleMap)) {
      return;
    }
    const styleMap = this.host.parentElement.computedStyleMap();
    const attrs = ["padding-top", "border-top-width", "margin-top"];
    const skidding = attrs.reduce((accumulator, attr) => {
      var _a2;
      const styleValue = (_a2 = styleMap.get(attr)) != null ? _a2 : new CSSUnitValue(0, "px");
      const unitValue = styleValue instanceof CSSUnitValue ? styleValue : new CSSUnitValue(0, "px");
      const pxValue = unitValue.to("px");
      return accumulator - pxValue.value;
    }, 0);
    this.skidding = skidding;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : false;
  }
  renderSubmenu() {
    const isLtr = this.localize.dir() === "ltr";
    if (!this.isConnected) {
      return ke` <slot name="submenu" hidden></slot> `;
    }
    return ke`
      <sl-popup
        ${Kt(this.popupRef)}
        placement=${isLtr ? "right-start" : "left-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    `;
  }
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5V2K4DXW.js
var SlMenuItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.type = "normal";
    this.checked = false;
    this.value = "";
    this.loading = false;
    this.disabled = false;
    this.localize = new LocalizeController2(this);
    this.hasSlotController = new HasSlotController(this, "submenu");
    this.submenuController = new SubmenuController(this, this.hasSlotController, this.localize);
    this.handleHostClick = (event) => {
      if (this.disabled) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleMouseOver = (event) => {
      this.focus();
      event.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.handleHostClick);
    this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.handleHostClick);
    this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = false;
      console.error('The checked attribute can only be used on menu items with type="checkbox"', this);
      return;
    }
    if (this.type === "checkbox") {
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.removeAttribute("aria-checked");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    if (this.type === "checkbox") {
      this.setAttribute("role", "menuitemcheckbox");
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.setAttribute("role", "menuitem");
      this.removeAttribute("aria-checked");
    }
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const isSubmenuExpanded = this.submenuController.isExpanded();
    return ke`
      <div
        id="anchor"
        part="base"
        class=${Rt({
      "menu-item": true,
      "menu-item--rtl": isRtl,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--loading": this.loading,
      "menu-item--has-submenu": this.isSubmenu(),
      "menu-item--submenu-expanded": isSubmenuExpanded
    })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${isSubmenuExpanded ? true : false}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${isRtl ? "chevron-left" : "chevron-right"} library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
        ${this.loading ? ke` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> ` : ""}
      </div>
    `;
  }
};
SlMenuItem.styles = [component_styles_default, menu_item_styles_default];
SlMenuItem.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e3("slot:not([name])")
], SlMenuItem.prototype, "defaultSlot", 2);
__decorateClass([
  e3(".menu-item")
], SlMenuItem.prototype, "menuItem", 2);
__decorateClass([
  n4()
], SlMenuItem.prototype, "type", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "checked", 2);
__decorateClass([
  n4()
], SlMenuItem.prototype, "value", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "loading", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlMenuItem.prototype, "disabled", 2);
__decorateClass([
  watch("checked")
], SlMenuItem.prototype, "handleCheckedChange", 1);
__decorateClass([
  watch("disabled")
], SlMenuItem.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("type")
], SlMenuItem.prototype, "handleTypeChange", 1);

// ../bundle-component/dist/styling/base.js
var baseStyling = i`
	:host {
		font-family: "Inter", sans-serif;

		/*
		* Color Primitives
		*/

		/* Gray */
		--sl-color-gray-50: hsl(0 0% 97.5%);
		--sl-color-gray-100: hsl(240 4.8% 95.9%);
		--sl-color-gray-200: hsl(240 5.9% 90%);
		--sl-color-gray-300: hsl(240 4.9% 83.9%);
		--sl-color-gray-400: hsl(240 5% 64.9%);
		--sl-color-gray-500: hsl(240 3.8% 46.1%);
		--sl-color-gray-600: hsl(240 5.2% 33.9%);
		--sl-color-gray-700: hsl(240 5.3% 26.1%);
		--sl-color-gray-800: hsl(240 3.7% 15.9%);
		--sl-color-gray-900: hsl(240 5.9% 10%);
		--sl-color-gray-950: hsl(240 7.3% 8%);

		/* Red */
		--sl-color-red-50: hsl(0 85.7% 97.3%);
		--sl-color-red-100: hsl(0 93.3% 94.1%);
		--sl-color-red-200: hsl(0 96.3% 89.4%);
		--sl-color-red-300: hsl(0 93.5% 81.8%);
		--sl-color-red-400: hsl(0 90.6% 70.8%);
		--sl-color-red-500: hsl(0 84.2% 60.2%);
		--sl-color-red-600: hsl(0 72.2% 50.6%);
		--sl-color-red-700: hsl(0 73.7% 41.8%);
		--sl-color-red-800: hsl(0 70% 35.3%);
		--sl-color-red-900: hsl(0 62.8% 30.6%);
		--sl-color-red-950: hsl(0 60% 19.6%);

		/* Orange */
		--sl-color-orange-50: hsl(33.3 100% 96.5%);
		--sl-color-orange-100: hsl(34.3 100% 91.8%);
		--sl-color-orange-200: hsl(32.1 97.7% 83.1%);
		--sl-color-orange-300: hsl(30.7 97.2% 72.4%);
		--sl-color-orange-400: hsl(27 96% 61%);
		--sl-color-orange-500: hsl(24.6 95% 53.1%);
		--sl-color-orange-600: hsl(20.5 90.2% 48.2%);
		--sl-color-orange-700: hsl(17.5 88.3% 40.4%);
		--sl-color-orange-800: hsl(15 79.1% 33.7%);
		--sl-color-orange-900: hsl(15.3 74.6% 27.8%);
		--sl-color-orange-950: hsl(15.2 69.1% 19%);

		/* Amber */
		--sl-color-amber-50: hsl(48 100% 96.1%);
		--sl-color-amber-100: hsl(48 96.5% 88.8%);
		--sl-color-amber-200: hsl(48 96.6% 76.7%);
		--sl-color-amber-300: hsl(45.9 96.7% 64.5%);
		--sl-color-amber-400: hsl(43.3 96.4% 56.3%);
		--sl-color-amber-500: hsl(37.7 92.1% 50.2%);
		--sl-color-amber-600: hsl(32.1 94.6% 43.7%);
		--sl-color-amber-700: hsl(26 90.5% 37.1%);
		--sl-color-amber-800: hsl(22.7 82.5% 31.4%);
		--sl-color-amber-900: hsl(21.7 77.8% 26.5%);
		--sl-color-amber-950: hsl(22.9 74.1% 16.7%);

		/* Yellow */
		--sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
		--sl-color-yellow-100: hsl(54.9 96.7% 88%);
		--sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
		--sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
		--sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
		--sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
		--sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
		--sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
		--sl-color-yellow-800: hsl(31.8 81% 28.8%);
		--sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
		--sl-color-yellow-950: hsl(33.1 69% 13.9%);

		/* Lime */
		--sl-color-lime-50: hsl(78.3 92% 95.1%);
		--sl-color-lime-100: hsl(79.6 89.1% 89.2%);
		--sl-color-lime-200: hsl(80.9 88.5% 79.6%);
		--sl-color-lime-300: hsl(82 84.5% 67.1%);
		--sl-color-lime-400: hsl(82.7 78% 55.5%);
		--sl-color-lime-500: hsl(83.7 80.5% 44.3%);
		--sl-color-lime-600: hsl(84.8 85.2% 34.5%);
		--sl-color-lime-700: hsl(85.9 78.4% 27.3%);
		--sl-color-lime-800: hsl(86.3 69% 22.7%);
		--sl-color-lime-900: hsl(87.6 61.2% 20.2%);
		--sl-color-lime-950: hsl(86.5 60.6% 13.9%);

		/* Green */
		--sl-color-green-50: hsl(138.5 76.5% 96.7%);
		--sl-color-green-100: hsl(140.6 84.2% 92.5%);
		--sl-color-green-200: hsl(141 78.9% 85.1%);
		--sl-color-green-300: hsl(141.7 76.6% 73.1%);
		--sl-color-green-400: hsl(141.9 69.2% 58%);
		--sl-color-green-500: hsl(142.1 70.6% 45.3%);
		--sl-color-green-600: hsl(142.1 76.2% 36.3%);
		--sl-color-green-700: hsl(142.4 71.8% 29.2%);
		--sl-color-green-800: hsl(142.8 64.2% 24.1%);
		--sl-color-green-900: hsl(143.8 61.2% 20.2%);
		--sl-color-green-950: hsl(144.3 60.7% 12%);

		/* Emerald */
		--sl-color-emerald-50: hsl(151.8 81% 95.9%);
		--sl-color-emerald-100: hsl(149.3 80.4% 90%);
		--sl-color-emerald-200: hsl(152.4 76% 80.4%);
		--sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
		--sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
		--sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
		--sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
		--sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
		--sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
		--sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
		--sl-color-emerald-950: hsl(164.3 87.5% 9.4%);

		/* Teal */
		--sl-color-teal-50: hsl(166.2 76.5% 96.7%);
		--sl-color-teal-100: hsl(167.2 85.5% 89.2%);
		--sl-color-teal-200: hsl(168.4 83.8% 78.2%);
		--sl-color-teal-300: hsl(170.6 76.9% 64.3%);
		--sl-color-teal-400: hsl(172.5 66% 50.4%);
		--sl-color-teal-500: hsl(173.4 80.4% 40%);
		--sl-color-teal-600: hsl(174.7 83.9% 31.6%);
		--sl-color-teal-700: hsl(175.3 77.4% 26.1%);
		--sl-color-teal-800: hsl(176.1 69.4% 21.8%);
		--sl-color-teal-900: hsl(175.9 60.8% 19%);
		--sl-color-teal-950: hsl(176.5 58.6% 11.4%);

		/* Cyan */
		--sl-color-cyan-50: hsl(183.2 100% 96.3%);
		--sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
		--sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
		--sl-color-cyan-300: hsl(187 92.4% 69%);
		--sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
		--sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
		--sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
		--sl-color-cyan-700: hsl(192.9 82.3% 31%);
		--sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
		--sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
		--sl-color-cyan-950: hsl(196.8 61% 16.1%);

		/* Sky */
		--sl-color-sky-50: hsl(204 100% 97.1%);
		--sl-color-sky-100: hsl(204 93.8% 93.7%);
		--sl-color-sky-200: hsl(200.6 94.4% 86.1%);
		--sl-color-sky-300: hsl(199.4 95.5% 73.9%);
		--sl-color-sky-400: hsl(198.4 93.2% 59.6%);
		--sl-color-sky-500: hsl(198.6 88.7% 48.4%);
		--sl-color-sky-600: hsl(200.4 98% 39.4%);
		--sl-color-sky-700: hsl(201.3 96.3% 32.2%);
		--sl-color-sky-800: hsl(201 90% 27.5%);
		--sl-color-sky-900: hsl(202 80.3% 23.9%);
		--sl-color-sky-950: hsl(202.3 73.8% 16.5%);

		/* Blue */
		--sl-color-blue-50: hsl(213.8 100% 96.9%);
		--sl-color-blue-100: hsl(214.3 94.6% 92.7%);
		--sl-color-blue-200: hsl(213.3 96.9% 87.3%);
		--sl-color-blue-300: hsl(211.7 96.4% 78.4%);
		--sl-color-blue-400: hsl(213.1 93.9% 67.8%);
		--sl-color-blue-500: hsl(217.2 91.2% 59.8%);
		--sl-color-blue-600: hsl(221.2 83.2% 53.3%);
		--sl-color-blue-700: hsl(224.3 76.3% 48%);
		--sl-color-blue-800: hsl(225.9 70.7% 40.2%);
		--sl-color-blue-900: hsl(224.4 64.3% 32.9%);
		--sl-color-blue-950: hsl(226.2 55.3% 18.4%);

		/* Indigo */
		--sl-color-indigo-50: hsl(225.9 100% 96.7%);
		--sl-color-indigo-100: hsl(226.5 100% 93.9%);
		--sl-color-indigo-200: hsl(228 96.5% 88.8%);
		--sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
		--sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
		--sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
		--sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
		--sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
		--sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
		--sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
		--sl-color-indigo-950: hsl(243.5 43.6% 22.9%);

		/* Violet */
		--sl-color-violet-50: hsl(250 100% 97.6%);
		--sl-color-violet-100: hsl(251.4 91.3% 95.5%);
		--sl-color-violet-200: hsl(250.5 95.2% 91.8%);
		--sl-color-violet-300: hsl(252.5 94.7% 85.1%);
		--sl-color-violet-400: hsl(255.1 91.7% 76.3%);
		--sl-color-violet-500: hsl(258.3 89.5% 66.3%);
		--sl-color-violet-600: hsl(262.1 83.3% 57.8%);
		--sl-color-violet-700: hsl(263.4 70% 50.4%);
		--sl-color-violet-800: hsl(263.4 69.3% 42.2%);
		--sl-color-violet-900: hsl(263.5 67.4% 34.9%);
		--sl-color-violet-950: hsl(265.1 61.5% 21.4%);

		/* Purple */
		--sl-color-purple-50: hsl(270 100% 98%);
		--sl-color-purple-100: hsl(268.7 100% 95.5%);
		--sl-color-purple-200: hsl(268.6 100% 91.8%);
		--sl-color-purple-300: hsl(269.2 97.4% 85.1%);
		--sl-color-purple-400: hsl(270 95.2% 75.3%);
		--sl-color-purple-500: hsl(270.7 91% 65.1%);
		--sl-color-purple-600: hsl(271.5 81.3% 55.9%);
		--sl-color-purple-700: hsl(272.1 71.7% 47.1%);
		--sl-color-purple-800: hsl(272.9 67.2% 39.4%);
		--sl-color-purple-900: hsl(273.6 65.6% 32%);
		--sl-color-purple-950: hsl(276 59.5% 16.5%);

		/* Fuchsia */
		--sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
		--sl-color-fuchsia-100: hsl(287 100% 95.5%);
		--sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
		--sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
		--sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
		--sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
		--sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
		--sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
		--sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
		--sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
		--sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);

		/* Pink */
		--sl-color-pink-50: hsl(327.3 73.3% 97.1%);
		--sl-color-pink-100: hsl(325.7 77.8% 94.7%);
		--sl-color-pink-200: hsl(325.9 84.6% 89.8%);
		--sl-color-pink-300: hsl(327.4 87.1% 81.8%);
		--sl-color-pink-400: hsl(328.6 85.5% 70.2%);
		--sl-color-pink-500: hsl(330.4 81.2% 60.4%);
		--sl-color-pink-600: hsl(333.3 71.4% 50.6%);
		--sl-color-pink-700: hsl(335.1 77.6% 42%);
		--sl-color-pink-800: hsl(335.8 74.4% 35.3%);
		--sl-color-pink-900: hsl(335.9 69% 30.4%);
		--sl-color-pink-950: hsl(336.2 65.4% 15.9%);

		/* Rose */
		--sl-color-rose-50: hsl(355.7 100% 97.3%);
		--sl-color-rose-100: hsl(355.6 100% 94.7%);
		--sl-color-rose-200: hsl(352.7 96.1% 90%);
		--sl-color-rose-300: hsl(352.6 95.7% 81.8%);
		--sl-color-rose-400: hsl(351.3 94.5% 71.4%);
		--sl-color-rose-500: hsl(349.7 89.2% 60.2%);
		--sl-color-rose-600: hsl(346.8 77.2% 49.8%);
		--sl-color-rose-700: hsl(345.3 82.7% 40.8%);
		--sl-color-rose-800: hsl(343.4 79.7% 34.7%);
		--sl-color-rose-900: hsl(341.5 75.5% 30.4%);
		--sl-color-rose-950: hsl(341.3 70.1% 17.1%);

		/*
   * Theme Tokens
   */

		/* Primary */
		--sl-color-primary-50: var(--sl-color-sky-50);
		--sl-color-primary-100: var(--sl-color-sky-100);
		--sl-color-primary-200: var(--sl-color-sky-200);
		--sl-color-primary-300: var(--sl-color-sky-300);
		--sl-color-primary-400: var(--sl-color-sky-400);
		--sl-color-primary-500: var(--sl-color-sky-500);
		--sl-color-primary-600: var(--sl-color-sky-600);
		--sl-color-primary-700: var(--sl-color-sky-700);
		--sl-color-primary-800: var(--sl-color-sky-800);
		--sl-color-primary-900: var(--sl-color-sky-900);
		--sl-color-primary-950: var(--sl-color-sky-950);

		/* Success */
		--sl-color-success-50: var(--sl-color-green-50);
		--sl-color-success-100: var(--sl-color-green-100);
		--sl-color-success-200: var(--sl-color-green-200);
		--sl-color-success-300: var(--sl-color-green-300);
		--sl-color-success-400: var(--sl-color-green-400);
		--sl-color-success-500: var(--sl-color-green-500);
		--sl-color-success-600: var(--sl-color-green-600);
		--sl-color-success-700: var(--sl-color-green-700);
		--sl-color-success-800: var(--sl-color-green-800);
		--sl-color-success-900: var(--sl-color-green-900);
		--sl-color-success-950: var(--sl-color-green-950);

		/* Warning */
		--sl-color-warning-50: var(--sl-color-amber-50);
		--sl-color-warning-100: var(--sl-color-amber-100);
		--sl-color-warning-200: var(--sl-color-amber-200);
		--sl-color-warning-300: var(--sl-color-amber-300);
		--sl-color-warning-400: var(--sl-color-amber-400);
		--sl-color-warning-500: var(--sl-color-amber-500);
		--sl-color-warning-600: var(--sl-color-amber-600);
		--sl-color-warning-700: var(--sl-color-amber-700);
		--sl-color-warning-800: var(--sl-color-amber-800);
		--sl-color-warning-900: var(--sl-color-amber-900);
		--sl-color-warning-950: var(--sl-color-amber-950);

		/* Danger */
		--sl-color-danger-50: var(--sl-color-red-50);
		--sl-color-danger-100: var(--sl-color-red-100);
		--sl-color-danger-200: var(--sl-color-red-200);
		--sl-color-danger-300: var(--sl-color-red-300);
		--sl-color-danger-400: var(--sl-color-red-400);
		--sl-color-danger-500: var(--sl-color-red-500);
		--sl-color-danger-600: var(--sl-color-red-600);
		--sl-color-danger-700: var(--sl-color-red-700);
		--sl-color-danger-800: var(--sl-color-red-800);
		--sl-color-danger-900: var(--sl-color-red-900);
		--sl-color-danger-950: var(--sl-color-red-950);

		/* Neutral */
		--sl-color-neutral-50: var(--sl-color-gray-50);
		--sl-color-neutral-100: var(--sl-color-gray-100);
		--sl-color-neutral-200: var(--sl-color-gray-200);
		--sl-color-neutral-300: var(--sl-color-gray-300);
		--sl-color-neutral-400: var(--sl-color-gray-400);
		--sl-color-neutral-500: var(--sl-color-gray-500);
		--sl-color-neutral-600: var(--sl-color-gray-600);
		--sl-color-neutral-700: var(--sl-color-gray-700);
		--sl-color-neutral-800: var(--sl-color-gray-800);
		--sl-color-neutral-900: var(--sl-color-gray-900);
		--sl-color-neutral-950: var(--sl-color-gray-950);

		/* Neutral one-offs */
		--sl-color-neutral-0: hsl(0, 0%, 100%);
		--sl-color-neutral-1000: hsl(0, 0%, 0%);

		/*
   * Border radii
   */

		--sl-border-radius-small: 0.1875rem; /* 3px */
		--sl-border-radius-medium: 0.25rem; /* 4px */
		--sl-border-radius-large: 0.5rem; /* 8px */
		--sl-border-radius-x-large: 1rem; /* 16px */

		--sl-border-radius-circle: 50%;
		--sl-border-radius-pill: 9999px;

		/*
   * Elevations
   */

		--sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
		--sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);

		/*
   * Spacings
   */

		--sl-spacing-3x-small: 0.125rem; /* 2px */
		--sl-spacing-2x-small: 0.25rem; /* 4px */
		--sl-spacing-x-small: 0.5rem; /* 8px */
		--sl-spacing-small: 0.75rem; /* 12px */
		--sl-spacing-medium: 1rem; /* 16px */
		--sl-spacing-large: 1.25rem; /* 20px */
		--sl-spacing-x-large: 1.75rem; /* 28px */
		--sl-spacing-2x-large: 2.25rem; /* 36px */
		--sl-spacing-3x-large: 3rem; /* 48px */
		--sl-spacing-4x-large: 4.5rem; /* 72px */

		/*
   * Transitions
   */

		--sl-transition-x-slow: 1000ms;
		--sl-transition-slow: 500ms;
		--sl-transition-medium: 250ms;
		--sl-transition-fast: 150ms;
		--sl-transition-x-fast: 50ms;

		/*
   * Typography
   */

		/* Fonts */
		--sl-font-mono: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
		--sl-font-sans: Inter, sans-serif;
		--sl-font-serif: Inter, "Times New Roman", serif;

		/* Font sizes */
		--sl-font-size-2x-small: 0.625rem; /* 10px */
		--sl-font-size-x-small: 0.75rem; /* 12px */
		--sl-font-size-small: 0.875rem; /* 14px */
		--sl-font-size-medium: 1rem; /* 16px */
		--sl-font-size-large: 1.25rem; /* 20px */
		--sl-font-size-x-large: 1.5rem; /* 24px */
		--sl-font-size-2x-large: 2.25rem; /* 36px */
		--sl-font-size-3x-large: 3rem; /* 48px */
		--sl-font-size-4x-large: 4.5rem; /* 72px */

		/* Font weights */
		--sl-font-weight-light: 300;
		--sl-font-weight-normal: 400;
		--sl-font-weight-semibold: 500;
		--sl-font-weight-bold: 700;

		/* Letter spacings */
		--sl-letter-spacing-denser: -0.03em;
		--sl-letter-spacing-dense: -0.015em;
		--sl-letter-spacing-normal: normal;
		--sl-letter-spacing-loose: 0.075em;
		--sl-letter-spacing-looser: 0.15em;

		/* Line heights */
		--sl-line-height-denser: 1;
		--sl-line-height-dense: 1.4;
		--sl-line-height-normal: 1.8;
		--sl-line-height-loose: 2.2;
		--sl-line-height-looser: 2.6;

		/* Focus rings */
		--sl-focus-ring-color: var(--sl-color-primary-600);
		--sl-focus-ring-style: solid;
		--sl-focus-ring-width: 3px;
		--sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width)
			var(--sl-focus-ring-color);
		--sl-focus-ring-offset: 1px;

		/*
   * Forms
   */

		/* Buttons */
		--sl-button-font-size-small: var(--sl-font-size-x-small);
		--sl-button-font-size-medium: var(--sl-font-size-small);
		--sl-button-font-size-large: var(--sl-font-size-medium);

		/* Inputs */
		--sl-input-height-small: 1.875rem; /* 30px */
		--sl-input-height-medium: 2.5rem; /* 40px */
		--sl-input-height-large: 3.125rem; /* 50px */

		--sl-input-background-color: var(--sl-color-neutral-0);
		--sl-input-background-color-hover: var(--sl-color-neutral-50);
		--sl-input-background-color-focus: var(--sl-input-background-color);
		--sl-input-background-color-disabled: var(--sl-color-neutral-100);
		--sl-input-border-color: var(--sl-color-neutral-300);
		--sl-input-border-color-hover: var(--sl-color-neutral-400);
		--sl-input-border-color-focus: var(--sl-color-primary-500);
		--sl-input-border-color-disabled: var(--sl-color-neutral-300);
		--sl-input-border-width: 1px;
		--sl-input-required-content: "*";
		--sl-input-required-content-offset: -2px;
		--sl-input-required-content-color: var(--sl-input-label-color);

		--sl-input-border-radius-small: var(--sl-border-radius-medium);
		--sl-input-border-radius-medium: var(--sl-border-radius-medium);
		--sl-input-border-radius-large: var(--sl-border-radius-medium);

		--sl-input-font-family: var(--sl-font-sans);
		--sl-input-font-weight: var(--sl-font-weight-normal);
		--sl-input-font-size-small: var(--sl-font-size-small);
		--sl-input-font-size-medium: var(--sl-font-size-medium);
		--sl-input-font-size-large: var(--sl-font-size-large);
		--sl-input-letter-spacing: var(--sl-letter-spacing-normal);

		--sl-input-color: var(--sl-color-neutral-700);
		--sl-input-color-hover: var(--sl-color-neutral-700);
		--sl-input-color-focus: var(--sl-color-neutral-700);
		--sl-input-color-disabled: var(--sl-color-neutral-900);
		--sl-input-icon-color: var(--sl-color-neutral-500);
		--sl-input-icon-color-hover: var(--sl-color-neutral-600);
		--sl-input-icon-color-focus: var(--sl-color-neutral-600);
		--sl-input-placeholder-color: var(--sl-color-neutral-500);
		--sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
		--sl-input-spacing-small: var(--sl-spacing-small);
		--sl-input-spacing-medium: var(--sl-spacing-medium);
		--sl-input-spacing-large: var(--sl-spacing-large);

		--sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
		--sl-input-focus-ring-offset: 0;

		--sl-input-filled-background-color: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
		--sl-input-filled-color: var(--sl-color-neutral-800);
		--sl-input-filled-color-hover: var(--sl-color-neutral-800);
		--sl-input-filled-color-focus: var(--sl-color-neutral-700);
		--sl-input-filled-color-disabled: var(--sl-color-neutral-800);

		/* Labels */
		--sl-input-label-font-size-small: var(--sl-font-size-small);
		--sl-input-label-font-size-medium: var(--sl-font-size-medium);
		--sl-input-label-font-size-large: var(--sl-font-size-large);
		--sl-input-label-color: inherit;

		/* Help text */
		--sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
		--sl-input-help-text-font-size-medium: var(--sl-font-size-small);
		--sl-input-help-text-font-size-large: var(--sl-font-size-medium);
		--sl-input-help-text-color: var(--sl-color-neutral-500);

		/* Toggles (checkboxes, radios, switches) */
		--sl-toggle-size-small: 0.875rem; /* 14px */
		--sl-toggle-size-medium: 1.125rem; /* 18px */
		--sl-toggle-size-large: 1.375rem; /* 22px */

		/*
   * Overlays
   */

		--sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);

		/*
   * Panels
   */

		--sl-panel-background-color: var(--sl-color-neutral-0);
		--sl-panel-border-color: var(--sl-color-neutral-200);
		--sl-panel-border-width: 1px;

		/*
   * Tooltips
   */

		--sl-tooltip-border-radius: var(--sl-border-radius-medium);
		--sl-tooltip-background-color: var(--sl-color-neutral-800);
		--sl-tooltip-color: var(--sl-color-neutral-0);
		--sl-tooltip-font-family: var(--sl-font-sans);
		--sl-tooltip-font-weight: var(--sl-font-weight-normal);
		--sl-tooltip-font-size: var(--sl-font-size-small);
		--sl-tooltip-line-height: var(--sl-line-height-dense);
		--sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
		--sl-tooltip-arrow-size: 6px;

		/*
   * Z-indexes
   */

		--sl-z-index-drawer: 700;
		--sl-z-index-dialog: 800;
		--sl-z-index-dropdown: 900;
		--sl-z-index-toast: 950;
		--sl-z-index-tooltip: 1000;
	}
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SI4ACBFK.js
var form_control_styles_default = i`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OZYH3LSG.js
var input_styles_default = i`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear:not(.input__clear--visible) {
    visibility: hidden;
  }

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GI7VDIWX.js
var defaultValue = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || b;
      const fromAttribute = typeof converter === "function" ? converter : (_a = converter == null ? void 0 : converter.fromAttribute) != null ? _a : b.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/live.js
var Ft = e4(class extends i2 {
  constructor(r6) {
    if (super(r6), r6.type !== t3.PROPERTY && r6.type !== t3.ATTRIBUTE && r6.type !== t3.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!rt(r6))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(r6) {
    return r6;
  }
  update(r6, [e6]) {
    if (e6 === R || e6 === D)
      return e6;
    const i4 = r6.element, n6 = r6.name;
    if (r6.type === t3.PROPERTY) {
      if (e6 === i4[n6])
        return R;
    } else if (r6.type === t3.BOOLEAN_ATTRIBUTE) {
      if (!!e6 === i4.hasAttribute(n6))
        return R;
    } else if (r6.type === t3.ATTRIBUTE && i4.getAttribute(n6) === e6 + "")
      return R;
    return dt(r6), e6;
  }
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.54TJVTKO.js
var SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.title = "";
    this.__numberInput = Object.assign(document.createElement("input"), { type: "number" });
    this.__dateInput = Object.assign(document.createElement("input"), { type: "date" });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return ((_a = this.input) == null ? void 0 : _a.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a;
    this.__numberInput.value = this.value;
    return ((_a = this.input) == null ? void 0 : _a.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    this.value = "";
    this.emit("sl-clear");
    this.emit("sl-input");
    this.emit("sl-change");
    this.input.focus();
    event.stopPropagation();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible = hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      input: true,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${to(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${to(this.placeholder)}
              minlength=${to(this.minlength)}
              maxlength=${to(this.maxlength)}
              min=${to(this.min)}
              max=${to(this.max)}
              step=${to(this.step)}
              .value=${Ft(this.value)}
              autocapitalize=${to(this.autocapitalize)}
              autocomplete=${to(this.autocomplete)}
              autocorrect=${to(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${to(this.pattern)}
              enterkeyhint=${to(this.enterkeyhint)}
              inputmode=${to(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${hasClearIcon ? ke`
                  <button
                    part="clear-button"
                    class=${Rt({
      input__clear: true,
      "input__clear--visible": isClearIconVisible
    })}
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? ke`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? ke`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : ke`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e3(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass([
  r4()
], SlInput.prototype, "hasFocus", 2);
__decorateClass([
  n4()
], SlInput.prototype, "title", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "type", 2);
__decorateClass([
  n4()
], SlInput.prototype, "name", 2);
__decorateClass([
  n4()
], SlInput.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlInput.prototype, "defaultValue", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "filled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "pill", 2);
__decorateClass([
  n4()
], SlInput.prototype, "label", 2);
__decorateClass([
  n4({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass([
  n4({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "disabled", 2);
__decorateClass([
  n4()
], SlInput.prototype, "placeholder", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "readonly", 2);
__decorateClass([
  n4({ attribute: "password-toggle", type: Boolean })
], SlInput.prototype, "passwordToggle", 2);
__decorateClass([
  n4({ attribute: "password-visible", type: Boolean })
], SlInput.prototype, "passwordVisible", 2);
__decorateClass([
  n4({ attribute: "no-spin-buttons", type: Boolean })
], SlInput.prototype, "noSpinButtons", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "form", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "required", 2);
__decorateClass([
  n4()
], SlInput.prototype, "pattern", 2);
__decorateClass([
  n4({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass([
  n4({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass([
  n4()
], SlInput.prototype, "min", 2);
__decorateClass([
  n4()
], SlInput.prototype, "max", 2);
__decorateClass([
  n4()
], SlInput.prototype, "step", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocorrect", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocomplete", 2);
__decorateClass([
  n4({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass([
  n4()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass([
  n4({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (value) => !value || value === "false" ? false : true,
      toAttribute: (value) => value ? "true" : "false"
    }
  })
], SlInput.prototype, "spellcheck", 2);
__decorateClass([
  n4()
], SlInput.prototype, "inputmode", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("step", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleStepChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleValueChange", 1);

// ../bundle-component/dist/stories/actions/add-input/inlang-add-input.js
var __decorate = function(decorators, target, key, desc) {
  var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r6 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r6 = (c5 < 3 ? d4(r6) : c5 > 3 ? d4(target, key, r6) : d4(target, key)) || r6;
  return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
if (!customElements.get("sl-dropdown"))
  customElements.define("sl-dropdown", SlDropdown);
if (!customElements.get("sl-input"))
  customElements.define("sl-input", SlInput);
var InlangAddInput = class InlangAddInput2 extends h3 {
  static {
    this.styles = [
      baseStyling,
      i`
			.button-wrapper {
				height: 44px;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.dropdown-container {
				font-size: 13px;
				width: 240px;
				background-color: var(--sl-panel-background-color);
				border: 1px solid var(--sl-input-border-color);
				padding: 12px;
				border-radius: 6px;
				display: flex;
				flex-direction: column;
				gap: 16px;
			}
			.dropdown-item {
				display: flex;
				flex-direction: column;
				gap: 2px;
			}
			.dropdown-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				color: var(--sl-input-color);
				font-size: 12px;
			}
			.dropdown-title {
				font-size: 12px;
				font-weight: 500;
				margin: 6px 0;
			}
			.help-text {
				display: flex;
				gap: 8px;
				color: var(--sl-input-help-text-color);
			}
			.help-text p {
				flex: 1;
				margin: 0;
				font-size: 12px;
				line-height: 1.5;
			}
			.actions {
				width: 100%;
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
		`
    ];
  }
  async firstUpdated() {
    await this.updateComplete;
    this._newInput = "";
  }
  render() {
    return ke`
			<sl-dropdown
				distance="-4"
				class="dropdown"
				@sl-show=${(e6) => {
      const dropdown = this.shadowRoot?.querySelector("sl-dropdown");
      if (dropdown && e6.target === dropdown) {
        const input = this.shadowRoot?.querySelector("sl-input");
        setTimeout(() => {
          if (input)
            input.focus();
        });
      }
    }}
			>
				<div slot="trigger" class="button-wrapper">
					<slot></slot>
				</div>
				<div class="dropdown-container">
					<div class="dropdown-item">
						<div class="dropdown-header">
							<p class="dropdown-title">Add input</p>
						</div>
						<sl-input
							size="small"
							value=${this._newInput}
							placeholder="Enter name"
							@input=${(e6) => {
      this._newInput = e6.target.value;
    }}
							@keydown=${(e6) => {
      if (e6.key === "Enter") {
        if (this._newInput && this._newInput.trim() !== "") {
          for (const message of this.messages ?? []) {
            const newMessage = structuredClone(message);
            newMessage.declarations.push({
              type: "input",
              name: this._newInput,
              value: {
                type: "expression",
                arg: {
                  type: "variable",
                  name: this._newInput
                }
              }
            });
            this.dispatchEvent(createChangeEvent({
              type: "Message",
              operation: "update",
              newData: newMessage
            }));
          }
        }
        this._newInput = "";
        const dropdown = this.shadowRoot?.querySelector(".dropdown");
        dropdown.hide();
      }
    }}
							><svg
								slot="suffix"
								xmlns="http://www.w3.org/2000/svg"
								width="20"
								height="20"
								viewBox="0 0 24 24"
							>
								<path
									fill="currentColor"
									d="M19 6a1 1 0 0 0-1 1v4a1 1 0 0 1-1 1H7.41l1.3-1.29a1 1 0 0 0-1.42-1.42l-3 3a1 1 0 0 0-.21.33a1 1 0 0 0 0 .76a1 1 0 0 0 .21.33l3 3a1 1 0 0 0 1.42 0a1 1 0 0 0 0-1.42L7.41 14H17a3 3 0 0 0 3-3V7a1 1 0 0 0-1-1"
								/></svg
						></sl-input>
					</div>
					<div class="help-text">
						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="24px"
							height="24px"
							viewBox="0 0 256 256"
						>
							<path
								fill="currentColor"
								d="M140 180a12 12 0 1 1-12-12a12 12 0 0 1 12 12M128 72c-22.06 0-40 16.15-40 36v4a8 8 0 0 0 16 0v-4c0-11 10.77-20 24-20s24 9 24 20s-10.77 20-24 20a8 8 0 0 0-8 8v8a8 8 0 0 0 16 0v-.72c18.24-3.35 32-17.9 32-35.28c0-19.85-17.94-36-40-36m104 56A104 104 0 1 1 128 24a104.11 104.11 0 0 1 104 104m-16 0a88 88 0 1 0-88 88a88.1 88.1 0 0 0 88-88"
							/>
						</svg>
						<p>As soon as added this input can be used in all messages of the bundle.</p>
					</div>
				</div>
			</sl-dropdown>
		`;
  }
};
__decorate([
  n4({ type: Array })
], InlangAddInput.prototype, "messages", void 0);
__decorate([
  r4()
], InlangAddInput.prototype, "_newInput", void 0);
InlangAddInput = __decorate([
  t2("inlang-add-input")
], InlangAddInput);

// ../bundle-component/dist/stories/inlang-bundle.js
var __decorate2 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r6 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r6 = (c5 < 3 ? d4(r6) : c5 > 3 ? d4(target, key, r6) : d4(target, key)) || r6;
  return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
if (!customElements.get("sl-button"))
  customElements.define("sl-button", SlButton);
if (!customElements.get("sl-dropdown"))
  customElements.define("sl-dropdown", SlDropdown);
if (!customElements.get("sl-menu"))
  customElements.define("sl-menu", SlMenu);
if (!customElements.get("sl-menu-item"))
  customElements.define("sl-menu-item", SlMenuItem);
var InlangBundle = class InlangBundle2 extends h3 {
  constructor() {
    super(...arguments);
    this._bundleActionsPresent = false;
    this._inputs = () => {
      const inputs = [];
      if (this.messages) {
        for (const message of this.messages) {
          for (const declaration of message.declarations) {
            if (declaration.type === "input" && !inputs.some((d4) => d4.name === declaration.name)) {
              inputs.push(declaration);
            }
          }
        }
      }
      return inputs;
    };
  }
  static {
    this.styles = [
      baseStyling,
      i`
			div {
				box-sizing: border-box;
				font-size: 14px;
			}
			.header {
				display: flex;
				justify-content: space-between;
				background-color: var(--sl-color-neutral-300);
				padding: 0 12px;
				min-height: 44px;
			}
			.header-left {
				font-weight: 600;
				display: flex;
				align-items: center;
				gap: 16px;
				min-height: 44px;
				color: var(--sl-input-color);
			}
			.header-right {
				display: flex;
				align-items: center;
				gap: 12px;
				min-height: 44px;
			}
			.separator {
				height: 20px;
				width: 1px;
				background-color: var(--sl-input-border-color-hover);
				opacity: 0.7;
				border-radius: 1px;
			}
			.slotted-menu-wrapper {
				display: flex;
				flex-direction: column;
			}
			.inputs-wrapper {
				display: flex;
				align-items: center;
				min-height: 44px;
				gap: 8px;
				color: var(--sl-input-color);
			}
			.inputs {
				display: flex;
				align-items: center;
				min-height: 44px;
				gap: 1px;
			}
			.input-tag::part(base) {
				height: 28px;
				font-weight: 500;
				cursor: pointer;
			}
			.text-button::part(base) {
				background-color: transparent;
				border: 1px solid transparent;
			}
			.text-button::part(base):hover {
				background-color: var(--sl-panel-border-color);
				border: 1px solid transparent;
				color: var(--sl-input-color-hover);
			}
			.alias-wrapper {
				display: flex;
				align-items: center;
				gap: 8px;
			}
			.alias {
				font-weight: 400;
				color: var(--sl-input-placeholder-color);
			}
			.alias-counter {
				height: 20px;
				width: 24px;
				font-weight: 500;
				font-size: 11px;
				color: var(--sl-input-color-hover);
				padding: 4px;
				border-radius: 4px;
				background-color: var(--sl-input-background-color-hover);
				display: flex;
				align-items: center;
				justify-content: center;
			}
			sl-button::part(base) {
				background-color: var(--sl-input-background-color);
				color: var(--sl-input-color);
				border: 1px solid var(--sl-input-border-color);
				font-size: 13px;
			}
			sl-button::part(base):hover {
				background-color: var(--sl-input-background-color-hover);
				color: var(--sl-input-color-hover);
				border: 1px solid var(--sl-input-border-color-hover);
			}
			sl-menu-item::part(label) {
				font-size: 14px;
				padding-left: 12px;
			}
			sl-menu-item::part(base) {
				color: var(--sl-input-color);
			}
			sl-menu-item::part(base):hover {
				background-color: var(--sl-input-background-color-hover);
			}
			sl-menu-item::part(checked-icon) {
				display: none;
			}
			.selector:hover {
				background-color: var(--sl-input-background-color-hover);
			}
		`
    ];
  }
  async firstUpdated() {
    await this.updateComplete;
    if ([...this.children].some((child) => child.tagName === "INLANG-BUNDLE-ACTION")) {
      this._bundleActionsPresent = true;
    }
    overridePrimitiveColors_default();
  }
  render() {
    return ke`
			<div>
				<div class=${`header`} part="base">
					<div class="header-left">
						<span># ${this.bundle?.id}</span>
						${this.bundle?.alias && Object.keys(this.bundle.alias).length > 0 ? ke` <div class="alias-wrapper">
									<span class="alias">Alias: ${this.bundle?.alias?.default}</span>
									${Object.keys(this.bundle.alias).length > 1 ? ke`<div class="alias-counter">
												+${Object.keys(this.bundle.alias).length - 1}
										  </div>` : ``}
							  </div>` : ``}
					</div>

					<div class="header-right">
						${this._inputs() && this._inputs().length > 0 ? ke`<div class="inputs-wrapper">
									Inputs:
									<div class="inputs">
										${this._inputs()?.map((input) => ke`<sl-dropdown
													><sl-button
														slot="trigger"
														class="input-tag"
														variant="neutral"
														size="small"
														>${input.name}</sl-button
													><sl-menu>
														<sl-menu-item
															value="delete"
															@click=${() => {
      for (const message of this.messages) {
        const newMessage = structuredClone(message);
        const index = newMessage.declarations.findIndex((declaration) => declaration.name === input.name);
        newMessage.declarations.splice(index, 1);
        this.dispatchEvent(createChangeEvent({
          type: "Message",
          operation: "update",
          newData: newMessage
        }));
      }
    }}
															>Delete</sl-menu-item
														>
													</sl-menu>
												</sl-dropdown>`)}
										<inlang-add-input .messages=${this.messages}>
											<sl-tooltip content="Add input to message bundle">
												<sl-button class="text-button" variant="neutral" size="small"
													><svg
														viewBox="0 0 24 24"
														width="18"
														height="18"
														style="margin: 0 -2px"
														slot="prefix"
													>
														<path
															fill="currentColor"
															d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"
														></path></svg
												></sl-button>
											</sl-tooltip>
										</inlang-add-input>
									</div>
							  </div>` : ke`<div class="inputs-wrapper">
									<inlang-add-input .messages=${this.messages}>
										<sl-tooltip content="Add input to message bundle">
											<sl-button class="text-button" variant="text" size="small"
												><svg
													viewBox="0 0 24 24"
													width="18"
													height="18"
													slot="prefix"
													style="margin-right: -2px"
												>
													<path
														fill="currentColor"
														d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"
													></path></svg
												>Input</sl-button
											>
										</sl-tooltip>
									</inlang-add-input>
							  </div>`}
						${this._bundleActionsPresent ? ke`<div class="separator"></div>
									<sl-dropdown class="bundle-actions">
										<sl-button class="text-button" variant="text" size="small" slot="trigger"
											><svg
												xmlns="http://www.w3.org/2000/svg"
												width="18"
												height="18"
												viewBox="0 0 24 24"
												slot="prefix"
												style="margin: 0 -2px"
											>
												<path
													fill="currentColor"
													d="M7 12a2 2 0 1 1-4 0a2 2 0 0 1 4 0m7 0a2 2 0 1 1-4 0a2 2 0 0 1 4 0m7 0a2 2 0 1 1-4 0a2 2 0 0 1 4 0"
												/></svg
										></sl-button>
										<sl-menu>
											<slot name="bundle-action"></slot>
										</sl-menu>
									</sl-dropdown>` : ``}
					</div>
				</div>
				<slot name="message"></slot>
				<!-- TODO: workaround for slot needs a better solution | when conditionally rendered, the slot doesn't get passed into the dom and then can not be queried. That's why we put it here additionally. Will never be renedered under a message. -->
				<slot name="bundle-action"></slot>
			</div>
		`;
  }
};
__decorate2([
  n4({ type: Object })
], InlangBundle.prototype, "bundle", void 0);
__decorate2([
  n4({ type: Array })
], InlangBundle.prototype, "messages", void 0);
__decorate2([
  r4()
], InlangBundle.prototype, "_bundleActionsPresent", void 0);
InlangBundle = __decorate2([
  t2("inlang-bundle")
], InlangBundle);
var inlang_bundle_default = InlangBundle;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.V2OL7VMD.js
var tag_styles_default = i`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6I2T3DLI.js
var icon_button_styles_default = i`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7XLSSP47.js
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? er`a` : er`button`;
    return ke2`
      <${tag}
        part="base"
        class=${Rt({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : "button")}
        href=${to(isLink ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${to(this.name)}
          library=${to(this.library)}
          src=${to(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e3(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass([
  r4()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "name", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "library", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "src", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "href", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "target", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "download", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "label", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7J6CPMBU.js
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return ke`
      <span
        part="base"
        class=${Rt({
      tag: true,
      // Types
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      // Sizes
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      // Modifiers
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? ke`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  n4({ reflect: true })
], SlTag.prototype, "variant", 2);
__decorateClass([
  n4({ reflect: true })
], SlTag.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlTag.prototype, "pill", 2);
__decorateClass([
  n4({ type: Boolean })
], SlTag.prototype, "removable", 2);

// ../bundle-component/dist/stories/message/inlang-message.js
var __decorate3 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r6 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r6 = (c5 < 3 ? d4(r6) : c5 > 3 ? d4(target, key, r6) : d4(target, key)) || r6;
  return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
if (!customElements.get("sl-tag"))
  customElements.define("sl-tag", SlTag);
if (!customElements.get("sl-dropdown"))
  customElements.define("sl-dropdown", SlDropdown);
if (!customElements.get("sl-menu"))
  customElements.define("sl-menu", SlMenu);
if (!customElements.get("sl-menu-item"))
  customElements.define("sl-menu-item", SlMenuItem);
var InlangMessage = class InlangMessage2 extends h3 {
  constructor() {
    super(...arguments);
    this._refLocale = () => {
      return this.settings?.baseLocale;
    };
  }
  static {
    this.styles = [
      baseStyling,
      i`
			div {
				box-sizing: border-box;
				font-size: 14px;
			}
			:host {
				position: relative;
				display: flex;
				min-height: 44px;
				border: 1px solid var(--sl-input-border-color) !important;
				border-top: none !important;
			}
			.message:first-child {
				border-top: 1px solid var(--sl-input-border-color) !important;
			}
			.language-container {
				font-weight: 500;
				width: 80px;
				min-height: 44px;
				padding-top: 12px;
				padding-left: 12px;
				padding-right: 12px;
				background-color: var(--sl-input-background-color-disabled);
				border-right: 1px solid var(--sl-input-border-color);
				color: var(--sl-input-color);
			}
			.message-body {
				flex: 1;
				display: flex;
				flex-direction: column;
			}
			.message-header {
				width: 100%;
				min-height: 44px;
				display: flex;
				justify-content: space-between;
				background-color: var(--sl-input-background-color-disabled);
				color: var(--sl-input-color);
				border-bottom: 1px solid var(--sl-input-border-color);
			}
			.no-bottom-border {
				border-bottom: none;
			}
			.selector-container {
				min-height: 44px;
				display: flex;
			}
			.selector {
				height: 44px;
				width: 120px;
				display: flex;
				align-items: center;
				padding: 12px;
				border-right: 1px solid var(--sl-input-border-color);
				font-weight: 500;
				cursor: pointer;
			}
			sl-menu-item::part(label) {
				font-size: 14px;
				padding-left: 12px;
			}
			sl-menu-item::part(base) {
				color: var(--sl-input-color);
			}
			sl-menu-item::part(base):hover {
				background-color: var(--sl-input-background-color-hover);
			}
			sl-menu-item::part(checked-icon) {
				display: none;
			}
			.selector:hover {
				background-color: var(--sl-input-background-color-hover);
			}
			.add-selector-container {
				height: 44px;
				width: 44px;
				display: flex;
				align-items: center;
				padding: 12px;
			}
			.add-selector::part(base) {
				height: 28px;
				width: 28px;
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 4px;
				cursor: pointer;
				font-size: 13px;
			}
			.message-actions {
				height: 44px;
				display: flex;
				align-items: center;
				padding: 12px;
				gap: 8px;
			}
			sl-button::part(base) {
				background-color: var(--sl-input-background-color);
				color: var(--sl-input-color);
				border: 1px solid var(--sl-input-border-color);
			}
			sl-button::part(base):hover {
				background-color: var(--sl-input-background-color-hover);
				color: var(--sl-input-color-hover);
				border: 1px solid var(--sl-input-border-color-hover);
			}
			.variants-container {
				width: 100%;
				height: 44px;
				display: flex;
				flex-direction: column;
				height: auto;
			}
			.new-variant {
				box-sizing: border-box;
				min-height: 44px;
				width: 100%;
				display: flex;
				gap: 4px;
				align-items: center;
				padding-left: 12px;
				margin: 0;
				background-color: var(--sl-input-background-color);
				color: var(--sl-input-placeholder-color);
				border-top: 1px solid var(--sl-input-border-color);
				cursor: pointer;
				transitions: all 0.5s;
			}
			.new-variant:hover {
				background-color: var(--sl-input-background-color-hover);
				color: var(--sl-input-color-hover);
			}
			.ref-tag::part(base) {
				background-color: var(--sl-input-placeholder-color);
				color: var(--sl-input-background-color);
				height: 22px;
				border: none;
			}
			.selector-button {
				margin-left: 8px;
			}
		`
    ];
  }
  render() {
    return ke`
			<div class="language-container">
				<span>${this.message?.locale}</span>
				${this._refLocale() === this.message?.locale ? ke`<sl-tag class="ref-tag" size="small" variant="neutral">ref</sl-tag>` : ``}
			</div>
			<div class="message-body">
				${this.message && this.message.selectors.length > 0 || this.message && this.message.variants.length > 1 && this.message.selectors.length === 0 ? ke`<div
							class=${`message-header ` + (this.message.variants && this.message.variants.length === 0 ? `no-bottom-border` : ``)}
					  >
							<div class="selector-container">
								${this.message.selectors.map((selector, index) => ke`<sl-dropdown>
										<div class="selector" slot="trigger">
											${// @ts-ignore
    selector.arg.name}
										</div>
										<sl-menu>
											<sl-menu-item
												value="delete"
												@click=${() => {
      if (this.message) {
        for (const variant of this.message.variants) {
          const matchObj = Object.fromEntries(Object.entries(variant.match).filter(([key]) => key !== selector.arg.name));
          this.dispatchEvent(createChangeEvent({
            type: "Variant",
            operation: "update",
            newData: {
              ...variant,
              match: matchObj
            }
          }));
        }
        this.dispatchEvent(createChangeEvent({
          type: "Message",
          operation: "update",
          newData: {
            ...this.message,
            selectors: this.message.selectors.filter((_5, i4) => i4 !== index)
          }
        }));
      }
    }}
												><svg
													xmlns="http://www.w3.org/2000/svg"
													width="18px"
													height="18px"
													viewBox="0 0 24 24"
													slot="prefix"
													style="margin-right: -4px; margin-left: 12px"
												>
													<g fill="none">
														<path
															d="M24 0v24H0V0zM12.593 23.258l-.011.002l-.071.035l-.02.004l-.014-.004l-.071-.035q-.016-.005-.024.005l-.004.01l-.017.428l.005.02l.01.013l.104.074l.015.004l.012-.004l.104-.074l.012-.016l.004-.017l-.017-.427q-.004-.016-.017-.018m.265-.113l-.013.002l-.185.093l-.01.01l-.003.011l.018.43l.005.012l.008.007l.201.093q.019.005.029-.008l.004-.014l-.034-.614q-.005-.019-.02-.022m-.715.002a.02.02 0 0 0-.027.006l-.006.014l-.034.614q.001.018.017.024l.015-.002l.201-.093l.01-.008l.004-.011l.017-.43l-.003-.012l-.01-.01z"
														/>
														<path
															fill="currentColor"
															d="M20 5a1 1 0 1 1 0 2h-1l-.003.071l-.933 13.071A2 2 0 0 1 16.069 22H7.93a2 2 0 0 1-1.995-1.858l-.933-13.07L5 7H4a1 1 0 0 1 0-2zm-3.003 2H7.003l.928 13h8.138zM14 2a1 1 0 1 1 0 2h-4a1 1 0 0 1 0-2z"
														/>
													</g></svg
												>Delete selector</sl-menu-item
											>
										</sl-menu>
									</sl-dropdown>`)}
								<div class="selector-button">
									<slot name="selector-button"></slot>
								</div>
							</div>
							<div class="message-actions"></div>
					  </div>` : ``}
				<div class="variants-container">
					<slot name="variant"></slot>
					${this.message?.selectors && this.message.selectors.length > 0 ? ke`<p
								part="new-variant"
								@click=${() => {
      const variant = createVariant({
        messageId: this.message.id,
        // combine the matches that are already present with the new category -> like a matrix
        match: (() => {
          const match2 = {};
          for (const selector of this.message.selectors) {
            match2[selector.arg.name] = "*";
          }
          return match2;
        })()
      });
      this.dispatchEvent(createChangeEvent({
        type: "Variant",
        operation: "create",
        newData: variant
      }));
    }}
								class="new-variant"
						  >
								<svg viewBox="0 0 24 24" width="18" height="18" slot="prefix" class="w-5 h-5 -mx-1">
									<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path>
								</svg>
								New variant
						  </p>` : ``}
				</div>
			</div>
		`;
  }
};
__decorate3([
  n4()
], InlangMessage.prototype, "message", void 0);
__decorate3([
  n4({ type: Object })
], InlangMessage.prototype, "settings", void 0);
InlangMessage = __decorate3([
  t2("inlang-message")
], InlangMessage);
var inlang_message_default = InlangMessage;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BCNEWSXW.js
var tooltip_styles_default = i`
  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RM47CE43.js
var SlTooltip = class extends ShoelaceElement {
  constructor() {
    super();
    this.localize = new LocalizeController2(this);
    this.content = "";
    this.placement = "top";
    this.disabled = false;
    this.distance = 8;
    this.open = false;
    this.skidding = 0;
    this.trigger = "hover focus";
    this.hoist = false;
    this.handleBlur = () => {
      if (this.hasTrigger("focus")) {
        this.hide();
      }
    };
    this.handleClick = () => {
      if (this.hasTrigger("click")) {
        if (this.open) {
          this.hide();
        } else {
          this.show();
        }
      }
    };
    this.handleFocus = () => {
      if (this.hasTrigger("focus")) {
        this.show();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        this.hide();
      }
    };
    this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.show(), delay);
      }
    };
    this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.hide(), delay);
      }
    };
    this.addEventListener("blur", this.handleBlur, true);
    this.addEventListener("focus", this.handleFocus, true);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("mouseover", this.handleMouseOver);
    this.addEventListener("mouseout", this.handleMouseOut);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  firstUpdated() {
    this.body.hidden = !this.open;
    if (this.open) {
      this.popup.active = true;
      this.popup.reposition();
    }
  }
  hasTrigger(triggerType) {
    const triggers = this.trigger.split(" ");
    return triggers.includes(triggerType);
  }
  async handleOpenChange() {
    var _a, _b;
    if (this.open) {
      if (this.disabled) {
        return;
      }
      this.emit("sl-show");
      if ("CloseWatcher" in window) {
        (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => {
          this.hide();
        };
      } else {
        document.addEventListener("keydown", this.handleDocumentKeyDown);
      }
      await stopAnimations(this.body);
      this.body.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "tooltip.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.reposition();
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      (_b = this.closeWatcher) == null ? void 0 : _b.destroy();
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "tooltip.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.active = false;
      this.body.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    if (this.hasUpdated) {
      await this.updateComplete;
      this.popup.reposition();
    }
  }
  handleDisabledChange() {
    if (this.disabled && this.open) {
      this.hide();
    }
  }
  /** Shows the tooltip. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return ke`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${Rt({
      tooltip: true,
      "tooltip--open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
        hover-bridge
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${this.open ? "polite" : "off"}>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
SlTooltip.styles = [component_styles_default, tooltip_styles_default];
SlTooltip.dependencies = { "sl-popup": SlPopup };
__decorateClass([
  e3("slot:not([name])")
], SlTooltip.prototype, "defaultSlot", 2);
__decorateClass([
  e3(".tooltip__body")
], SlTooltip.prototype, "body", 2);
__decorateClass([
  e3("sl-popup")
], SlTooltip.prototype, "popup", 2);
__decorateClass([
  n4()
], SlTooltip.prototype, "content", 2);
__decorateClass([
  n4()
], SlTooltip.prototype, "placement", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlTooltip.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Number })
], SlTooltip.prototype, "distance", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlTooltip.prototype, "open", 2);
__decorateClass([
  n4({ type: Number })
], SlTooltip.prototype, "skidding", 2);
__decorateClass([
  n4()
], SlTooltip.prototype, "trigger", 2);
__decorateClass([
  n4({ type: Boolean })
], SlTooltip.prototype, "hoist", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlTooltip.prototype, "handleOpenChange", 1);
__decorateClass([
  watch(["content", "distance", "hoist", "placement", "skidding"])
], SlTooltip.prototype, "handleOptionsChange", 1);
__decorateClass([
  watch("disabled")
], SlTooltip.prototype, "handleDisabledChange", 1);
setDefaultAnimation("tooltip.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 150, easing: "ease" }
});
setDefaultAnimation("tooltip.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 150, easing: "ease" }
});

// ../bundle-component/dist/stories/variant/inlang-variant.js
var __decorate4 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r6 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r6 = (c5 < 3 ? d4(r6) : c5 > 3 ? d4(target, key, r6) : d4(target, key)) || r6;
  return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
if (!customElements.get("sl-input"))
  customElements.define("sl-input", SlInput);
if (!customElements.get("sl-tooltip"))
  customElements.define("sl-tooltip", SlTooltip);
if (!customElements.get("sl-button"))
  customElements.define("sl-button", SlButton);
var InlangVariant = class InlangVariant2 extends h3 {
  constructor() {
    super(...arguments);
    this._updateMatch = (selectorName, value) => {
      if (this.variant) {
        const newVariant = structuredClone(this.variant);
        if (newVariant.match[selectorName]) {
          newVariant.match[selectorName] = value;
        }
        this.dispatchEvent(createChangeEvent({
          type: "Variant",
          operation: "update",
          newData: newVariant
        }));
      }
    };
  }
  static {
    this.styles = [
      baseStyling,
      i`
			div {
				box-sizing: border-box;
				font-size: 14px;
			}
			:host {
				border-top: 1px solid var(--sl-input-border-color) !important;
			}
			:host(:first-child) {
				border-top: none !important;
			}
			.variant {
				position: relative;
				min-height: 44px;
				width: 100%;
				display: flex;
				align-items: stretch;
			}
			.match {
				min-height: 44px;
				width: 120px;
				background-color: var(--sl-input-background-color);
				border-right: 1px solid var(--sl-input-border-color);
				position: relative;
				z-index: 0;
			}
			.match:focus-within {
				z-index: 3;
			}
			.match::part(base) {
				border: none;
				border-radius: 0;
				min-height: 44px;
				color: var(--sl-input-color);
			}
			.match::part(input) {
				min-height: 44px;
				background-color: var(--sl-input-background-color);
			}
			.match::part(input):hover {
				background-color: var(--sl-input-background-color-hover);
			}
			.variant {
				position: relative;
				z-index: 0;
			}
			.variant:focus-within {
				z-index: 3;
			}
			.actions {
				position: absolute;
				top: 0;
				right: 0;
				height: 44px;
				display: flex;
				align-items: center;
				gap: 4px;
				padding-right: 12px;
				z-index: 1;
			}
			.add-selector::part(base) {
				border-radius: 4px;
				cursor: pointer;
				font-size: 13px;
			}
			sl-button::part(base) {
				color: var(--sl-input-color);
				background-color: var(--sl-input-background-color);
				border: 1px solid var(--sl-input-border-color);
			}
			sl-button::part(base):hover {
				color: var(--sl-input-color-hover);
				background-color: var(--sl-input-background-color-hover);
				border: 1px solid var(--sl-input-border-color-hover);
			}
			.history-button {
				position: relative;
				z-index: 0;
			}
		`
    ];
  }
  //hooks
  async firstUpdated() {
    await this.updateComplete;
    overridePrimitiveColors_default();
  }
  render() {
    return this.variant ? ke`<div class="variant">
					${this.variant ? Object.entries(this.variant.match).map(([selectorName, match2]) => {
      return ke`
									<sl-input
										id="${this.variant.id}-${match2}"
										class="match"
										size="small"
										value=${match2}
										@sl-blur=${(e6) => {
        const element = this.shadowRoot?.getElementById(`${this.variant.id}-${match2}`);
        if (element && e6.target === element) {
          this._updateMatch(selectorName, e6.target.value);
        }
      }}
									></sl-input>
								`;
    }) : void 0}
					<slot name="pattern-editor" class="pattern-editor"></slot>
					<div class="actions">
						<slot name="variant-action"></slot>
					</div>
			  </div>` : void 0;
  }
};
__decorate4([
  n4()
], InlangVariant.prototype, "variant", void 0);
InlangVariant = __decorate4([
  t2("inlang-variant")
], InlangVariant);
var inlang_variant_default = InlangVariant;

// ../bundle-component/dist/stories/pattern-editor/inlang-pattern-editor.js
await init_Lexical_node();

// ../../../node_modules/.pnpm/@lexical+plain-text@0.16.1/node_modules/@lexical/plain-text/LexicalPlainText.node.mjs
var mod6 = await (process.env.NODE_ENV === "development" ? init_LexicalPlainText_dev().then(() => LexicalPlainText_dev_exports) : init_LexicalPlainText_prod().then(() => LexicalPlainText_prod_exports));
var registerPlainText2 = mod6.registerPlainText;

// ../bundle-component/dist/stories/pattern-editor/inlang-pattern-editor.js
await init_Lexical_node();

// ../bundle-component/dist/helper/patternToString.js
var patternToString = (props) => {
  if (!props.pattern) {
    return "";
  }
  return props.pattern.map((p5) => {
    if ("value" in p5) {
      return p5.value;
    } else if (p5.type === "expression" && p5.arg.type === "variable") {
      return `{{${p5.arg.name}}}`;
    }
    return "";
  }).join("");
};
var patternToString_default = patternToString;

// ../bundle-component/dist/helper/stringToPattern.js
var stringToPattern = (props) => {
  const pattern = [];
  const regex = /{{(.*?)}}/g;
  let lastIndex = 0;
  let match2;
  while ((match2 = regex.exec(props.text)) !== null) {
    if (match2.index > lastIndex) {
      pattern.push({
        type: "text",
        value: props.text.slice(lastIndex, match2.index)
      });
    }
    if (match2[1]) {
      pattern.push({
        type: "expression",
        arg: {
          type: "variable",
          name: match2[1]
        }
      });
      lastIndex = regex.lastIndex;
    }
  }
  if (lastIndex < props.text.length) {
    pattern.push({
      type: "text",
      value: props.text.slice(lastIndex)
    });
  }
  return pattern;
};
var stringToPattern_default = stringToPattern;

// ../bundle-component/dist/stories/pattern-editor/inlang-pattern-editor.js
var __decorate5 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r6 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r6 = (c5 < 3 ? d4(r6) : c5 > 3 ? d4(target, key, r6) : d4(target, key)) || r6;
  return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
var config = {
  namespace: "MyEditor",
  onError: console.error
};
var InlangPatternEditor = class InlangPatternEditor2 extends h3 {
  constructor() {
    super(...arguments);
    this.contentEditableElementRef = ii();
    this.editor = createEditor2(config);
    this._setEditorState = () => {
      this._removeTextContentListener?.();
      this._patternState = this.variant?.pattern;
      this.editor.update(() => {
        const root = $getRoot2();
        if (root.getChildren().length === 0) {
          const paragraphNode = $createParagraphNode2();
          const textNode = $createTextNode2(this.variant?.pattern ? patternToString_default({ pattern: this.variant?.pattern }) : "");
          paragraphNode.append(textNode);
          root.append(paragraphNode);
        } else {
          const paragraphNode = root.getChildren()[0];
          paragraphNode.remove();
          const newpParagraphNode = $createParagraphNode2();
          const textNode = $createTextNode2(this.variant?.pattern ? patternToString_default({ pattern: this.variant?.pattern }) : "");
          newpParagraphNode.append(textNode);
          root.append(newpParagraphNode);
        }
      }, {
        discrete: true
      });
      this._removeTextContentListener = this.editor.registerTextContentListener((textContent) => {
        this._handleListenToTextContent(textContent);
      });
    };
    this._handleListenToTextContent = (textContent) => {
      this._patternState = stringToPattern_default({ text: textContent });
      this.dispatchEvent(createChangeEvent({
        type: "Variant",
        operation: "update",
        newData: { ...this.variant, pattern: this._patternState }
      }));
    };
  }
  //disable shadow root -> because of contenteditable selection API
  createRenderRoot() {
    return this;
  }
  // update editor state when variant prop changes
  updated(changedProperties) {
    if (changedProperties.has("variant") && JSON.stringify(this.variant?.pattern) !== JSON.stringify(this._patternState)) {
      this._setEditorState();
    }
  }
  async firstUpdated() {
    const contentEditableElement = this.contentEditableElementRef.value;
    if (contentEditableElement) {
      this.editor.setRootElement(contentEditableElement);
      registerPlainText2(this.editor);
      this._removeTextContentListener = this.editor.registerTextContentListener((textContent) => {
        this._handleListenToTextContent(textContent);
      });
      contentEditableElement.addEventListener("focus", () => {
        const onPatternEditorFocus = new CustomEvent("pattern-editor-focus");
        this.dispatchEvent(onPatternEditorFocus);
      });
      contentEditableElement.addEventListener("blur", () => {
        const onPatternEditorBlur = new CustomEvent("pattern-editor-blur");
        this.dispatchEvent(onPatternEditorBlur);
      });
    }
  }
  render() {
    return ke`
			<style>
				div {
					box-sizing: border-box;
					font-size: 14px;
				}
				p {
					margin: 0;
				}
				inlang-pattern-editor {
					width: 100%;
				}
				.inlang-pattern-editor-wrapper {
					min-height: 44px;
					width: 100%;
					position: relative;
				}
				.inlang-pattern-editor-wrapper:focus-within {
					z-index: 1;
				}
				.inlang-pattern-editor-contenteditable {
					background-color: #ffffff;
					padding: 14px 12px;
					min-height: 44px;
					width: 100%;
					color: #242424;
					outline: none;
				}
				.inlang-pattern-editor-contenteditable:focus {
					box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
				}
				.inlang-pattern-editor-contenteditable:hover {
					background-color: #f9f9f9;
					color: #000;
				}
				.inlang-pattern-editor-placeholder {
					opacity: 0.5;
					position: absolute;
					top: 14px;
					left: 12px;
					font-size: 14px;
					font-weight: 500;
					pointer-events: none;
					font-family: var(--sl-font-sans);
				}
			</style>
			<div class="inlang-pattern-editor-wrapper">
				<div
					class="inlang-pattern-editor-contenteditable"
					contenteditable
					${Kt(this.contentEditableElementRef)}
				></div>
				${this._patternState === void 0 || this._patternState.length === 0 || this._patternState.length === 1 && this._patternState[0].value.length === 0 ? ke`<p class="inlang-pattern-editor-placeholder">Enter pattern ...</p>` : ""}
			</div>
		`;
  }
};
__decorate5([
  n4({ type: Object })
], InlangPatternEditor.prototype, "variant", void 0);
__decorate5([
  r4()
], InlangPatternEditor.prototype, "_patternState", void 0);
InlangPatternEditor = __decorate5([
  t2("inlang-pattern-editor")
], InlangPatternEditor);
var inlang_pattern_editor_default = InlangPatternEditor;

// ../bundle-component/dist/stories/actions/bundle-action/inlang-bundle-action.js
var __decorate6 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r6 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r6 = (c5 < 3 ? d4(r6) : c5 > 3 ? d4(target, key, r6) : d4(target, key)) || r6;
  return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
if (!customElements.get("sl-button"))
  customElements.define("sl-button", SlButton);
var InlangBundleAction = class InlangBundleAction2 extends h3 {
  static {
    this.styles = [
      baseStyling,
      i`
			div {
				box-sizing: border-box;
				font-size: 13px;
			}
			sl-button::part(base) {
				color: var(--sl-input-color);
				background-color: var(--sl-input-background-color);
				border: 1px solid var(--sl-input-border-color);
				border-radius: 4px;
				font-size: 13px;
			}
			sl-button::part(base):hover {
				color: var(--sl-input-color-hover);
				background-color: var(--sl-input-background-color-hover);
				border: 1px solid var(--sl-input-border-color-hover);
			}
		`
    ];
  }
  render() {
    return ke`<sl-menu-item>${this.actionTitle}</sl-menu-item>`;
  }
};
__decorate6([
  n4()
], InlangBundleAction.prototype, "actionTitle", void 0);
InlangBundleAction = __decorate6([
  t2("inlang-bundle-action")
], InlangBundleAction);
var inlang_bundle_action_default = InlangBundleAction;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AN6YZWTU.js
var select_styles_default = i`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix */
  .select__prefix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RK73WSZS.js
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset3 = getOffset(element, container);
  const offsetTop = offset3.top + container.scrollTop;
  const offsetLeft = offset3.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/node/directives/unsafe-html.js
var le3 = class extends i2 {
  constructor(i4) {
    if (super(i4), this.it = D, i4.type !== t3.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t5) {
    if (t5 === D || null == t5)
      return this._t = void 0, this.it = t5;
    if (t5 === R)
      return t5;
    if ("string" != typeof t5)
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t5 === this.it)
      return this._t;
    this.it = t5;
    const i4 = [t5];
    return i4.raw = i4, this._t = { _$litType$: this.constructor.resultType, strings: i4, values: [] };
  }
};
le3.directiveName = "unsafeHTML", le3.resultType = 1;
var ae2 = e4(le3);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.44XN5ATB.js
var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.typeToSelectString = "";
    this.hasFocus = false;
    this.displayLabel = "";
    this.selectedOptions = [];
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.placeholder = "";
    this.multiple = false;
    this.maxOptionsVisible = 3;
    this.disabled = false;
    this.clearable = false;
    this.open = false;
    this.hoist = false;
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.form = "";
    this.required = false;
    this.getTag = (option) => {
      return ke`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(event) => this.handleTagRemove(event, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
    };
    this.handleDocumentFocusIn = (event) => {
      const path2 = event.composedPath();
      if (this && !path2.includes(this)) {
        this.hide();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      const target = event.target;
      const isClearButton = target.closest(".select__clear") !== null;
      const isIconButton = target.closest("sl-icon-button") !== null;
      if (isClearButton || isIconButton) {
        return;
      }
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.preventDefault();
        event.stopPropagation();
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
      if (event.key === "Enter" || event.key === " " && this.typeToSelectString === "") {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.open) {
          this.show();
          return;
        }
        if (this.currentOption && !this.currentOption.disabled) {
          if (this.multiple) {
            this.toggleOptionSelection(this.currentOption);
          } else {
            this.setSelectedOptions(this.currentOption);
          }
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
          if (!this.multiple) {
            this.hide();
            this.displayInput.focus({ preventScroll: true });
          }
        }
        return;
      }
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
        const allOptions = this.getAllOptions();
        const currentIndex = allOptions.indexOf(this.currentOption);
        let newIndex = Math.max(0, currentIndex);
        event.preventDefault();
        if (!this.open) {
          this.show();
          if (this.currentOption) {
            return;
          }
        }
        if (event.key === "ArrowDown") {
          newIndex = currentIndex + 1;
          if (newIndex > allOptions.length - 1)
            newIndex = 0;
        } else if (event.key === "ArrowUp") {
          newIndex = currentIndex - 1;
          if (newIndex < 0)
            newIndex = allOptions.length - 1;
        } else if (event.key === "Home") {
          newIndex = 0;
        } else if (event.key === "End") {
          newIndex = allOptions.length - 1;
        }
        this.setCurrentOption(allOptions[newIndex]);
      }
      if (event.key.length === 1 || event.key === "Backspace") {
        const allOptions = this.getAllOptions();
        if (event.metaKey || event.ctrlKey || event.altKey) {
          return;
        }
        if (!this.open) {
          if (event.key === "Backspace") {
            return;
          }
          this.show();
        }
        event.stopPropagation();
        event.preventDefault();
        clearTimeout(this.typeToSelectTimeout);
        this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
        if (event.key === "Backspace") {
          this.typeToSelectString = this.typeToSelectString.slice(0, -1);
        } else {
          this.typeToSelectString += event.key.toLowerCase();
        }
        for (const option of allOptions) {
          const label = option.getTextLabel().toLowerCase();
          if (label.startsWith(this.typeToSelectString)) {
            this.setCurrentOption(option);
            break;
          }
        }
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path2 = event.composedPath();
      if (this && !path2.includes(this)) {
        this.hide();
      }
    };
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.open = false;
  }
  addOpenListeners() {
    var _a;
    const root = this.getRootNode();
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        if (this.open) {
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
      };
    }
    root.addEventListener("focusin", this.handleDocumentFocusIn);
    root.addEventListener("keydown", this.handleDocumentKeyDown);
    root.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a;
    const root = this.getRootNode();
    root.removeEventListener("focusin", this.handleDocumentFocusIn);
    root.removeEventListener("keydown", this.handleDocumentKeyDown);
    root.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  handleFocus() {
    this.hasFocus = true;
    this.displayInput.setSelectionRange(0, 0);
    this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(event) {
    const path2 = event.composedPath();
    const isIconButton = path2.some((el) => el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button");
    if (this.disabled || isIconButton) {
      return;
    }
    event.preventDefault();
    this.displayInput.focus({ preventScroll: true });
    this.open = !this.open;
  }
  handleComboboxKeyDown(event) {
    if (event.key === "Tab") {
      return;
    }
    event.stopPropagation();
    this.handleDocumentKeyDown(event);
  }
  handleClearClick(event) {
    event.stopPropagation();
    if (this.value !== "") {
      this.setSelectedOptions([]);
      this.displayInput.focus({ preventScroll: true });
      this.updateComplete.then(() => {
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  handleClearMouseDown(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  handleOptionClick(event) {
    const target = event.target;
    const option = target.closest("sl-option");
    const oldValue = this.value;
    if (option && !option.disabled) {
      if (this.multiple) {
        this.toggleOptionSelection(option);
      } else {
        this.setSelectedOptions(option);
      }
      this.updateComplete.then(() => this.displayInput.focus({ preventScroll: true }));
      if (this.value !== oldValue) {
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
      if (!this.multiple) {
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
    }
  }
  handleDefaultSlotChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    const values = [];
    if (customElements.get("sl-option")) {
      allOptions.forEach((option) => values.push(option.value));
      this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
    } else {
      customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
    }
  }
  handleTagRemove(event, option) {
    event.stopPropagation();
    if (!this.disabled) {
      this.toggleOptionSelection(option, false);
      this.updateComplete.then(() => {
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(option) {
    const allOptions = this.getAllOptions();
    allOptions.forEach((el) => {
      el.current = false;
      el.tabIndex = -1;
    });
    if (option) {
      this.currentOption = option;
      option.current = true;
      option.tabIndex = 0;
      option.focus();
    }
  }
  // Sets the selected option(s)
  setSelectedOptions(option) {
    const allOptions = this.getAllOptions();
    const newSelectedOptions = Array.isArray(option) ? option : [option];
    allOptions.forEach((el) => el.selected = false);
    if (newSelectedOptions.length) {
      newSelectedOptions.forEach((el) => el.selected = true);
    }
    this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(option, force) {
    if (force === true || force === false) {
      option.selected = force;
    } else {
      option.selected = !option.selected;
    }
    this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var _a, _b, _c, _d;
    this.selectedOptions = this.getAllOptions().filter((el) => el.selected);
    if (this.multiple) {
      this.value = this.selectedOptions.map((el) => el.value);
      if (this.placeholder && this.value.length === 0) {
        this.displayLabel = "";
      } else {
        this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length);
      }
    } else {
      this.value = (_b = (_a = this.selectedOptions[0]) == null ? void 0 : _a.value) != null ? _b : "";
      this.displayLabel = (_d = (_c = this.selectedOptions[0]) == null ? void 0 : _c.getTextLabel()) != null ? _d : "";
    }
    this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((option, index) => {
      if (index < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const tag = this.getTag(option, index);
        return ke`<div @sl-remove=${(e6) => this.handleTagRemove(e6, option)}>
          ${typeof tag === "string" ? ae2(tag) : tag}
        </div>`;
      } else if (index === this.maxOptionsVisible) {
        return ke`<sl-tag>+${this.selectedOptions.length - index}</sl-tag>`;
      }
      return ke``;
    });
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.open = false;
      this.handleOpenChange();
    }
  }
  handleValueChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.listbox.hidden = false;
      this.popup.active = true;
      requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const { keyframes, options } = getAnimation(this, "select.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      if (this.currentOption) {
        scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
      }
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "select.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.listbox.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.valueInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(options) {
    this.displayInput.focus(options);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && this.value.length > 0;
    const isPlaceholderVisible = this.placeholder && this.value.length === 0;
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${Rt({
      select: true,
      "select--standard": true,
      "select--filled": this.filled,
      "select--pill": this.pill,
      "select--open": this.open,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--focused": this.hasFocus,
      "select--placeholder-visible": isPlaceholderVisible,
      "select--top": this.placement === "top",
      "select--bottom": this.placement === "bottom",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large"
    })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? ke`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${hasClearIcon ? ke`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag
};
__decorateClass([
  e3(".select")
], SlSelect.prototype, "popup", 2);
__decorateClass([
  e3(".select__combobox")
], SlSelect.prototype, "combobox", 2);
__decorateClass([
  e3(".select__display-input")
], SlSelect.prototype, "displayInput", 2);
__decorateClass([
  e3(".select__value-input")
], SlSelect.prototype, "valueInput", 2);
__decorateClass([
  e3(".select__listbox")
], SlSelect.prototype, "listbox", 2);
__decorateClass([
  r4()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass([
  r4()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass([
  r4()
], SlSelect.prototype, "currentOption", 2);
__decorateClass([
  r4()
], SlSelect.prototype, "selectedOptions", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "name", 2);
__decorateClass([
  n4({
    converter: {
      fromAttribute: (value) => value.split(" "),
      toAttribute: (value) => value.join(" ")
    }
  })
], SlSelect.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlSelect.prototype, "defaultValue", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "size", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "placeholder", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "multiple", 2);
__decorateClass([
  n4({ attribute: "max-options-visible", type: Number })
], SlSelect.prototype, "maxOptionsVisible", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "open", 2);
__decorateClass([
  n4({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "filled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "pill", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "label", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "placement", 2);
__decorateClass([
  n4({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass([
  n4({ reflect: true })
], SlSelect.prototype, "form", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "required", 2);
__decorateClass([
  n4()
], SlSelect.prototype, "getTag", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleValueChange", 1);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleOpenChange", 1);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FXXKMG2P.js
var option_styles_default = i`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWDN2DUL.js
var SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.current = false;
    this.selected = false;
    this.hasHover = false;
    this.value = "";
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "option");
    this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleMouseEnter() {
    this.hasHover = true;
  }
  handleMouseLeave() {
    this.hasHover = false;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    if (this.value.includes(" ")) {
      console.error(`Option values cannot include a space. All spaces have been replaced with underscores.`, this);
      this.value = this.value.replace(/ /g, "_");
    }
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const nodes = this.childNodes;
    let label = "";
    [...nodes].forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!node.hasAttribute("slot")) {
          label += node.textContent;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        label += node.textContent;
      }
    });
    return label.trim();
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      option: true,
      "option--current": this.current,
      "option--disabled": this.disabled,
      "option--selected": this.selected,
      "option--hover": this.hasHover
    })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e3(".option__label")
], SlOption.prototype, "defaultSlot", 2);
__decorateClass([
  r4()
], SlOption.prototype, "current", 2);
__decorateClass([
  r4()
], SlOption.prototype, "selected", 2);
__decorateClass([
  r4()
], SlOption.prototype, "hasHover", 2);
__decorateClass([
  n4({ reflect: true })
], SlOption.prototype, "value", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlOption.prototype, "disabled", 2);
__decorateClass([
  watch("disabled")
], SlOption.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("selected")
], SlOption.prototype, "handleSelectedChange", 1);
__decorateClass([
  watch("value")
], SlOption.prototype, "handleValueChange", 1);

// ../bundle-component/dist/stories/actions/add-selector/inlang-add-selector.js
var __decorate7 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r6 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r6 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r6 = (c5 < 3 ? d4(r6) : c5 > 3 ? d4(target, key, r6) : d4(target, key)) || r6;
  return c5 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
};
if (!customElements.get("sl-dropdown"))
  customElements.define("sl-dropdown", SlDropdown);
if (!customElements.get("sl-select"))
  customElements.define("sl-select", SlSelect);
if (!customElements.get("sl-input"))
  customElements.define("sl-input", SlInput);
if (!customElements.get("sl-option"))
  customElements.define("sl-option", SlOption);
if (!customElements.get("sl-button"))
  customElements.define("sl-button", SlButton);
if (!customElements.get("sl-tooltip"))
  customElements.define("sl-tooltip", SlTooltip);
var InlangAddSelector = class InlangAddSelector2 extends h3 {
  constructor() {
    super(...arguments);
    this._isNewInput = false;
    this._getPluralCategories = () => {
      return this.message?.locale ? [...new Intl.PluralRules(this.message.locale).resolvedOptions().pluralCategories, "*"] : void 0;
    };
    this._getInputs = () => {
      const inputs = [];
      if (this.messages) {
        for (const message of this.messages) {
          for (const declaration of message.declarations) {
            if (declaration.type === "input" && !inputs.some((d4) => d4.name === declaration.name)) {
              inputs.push(declaration);
            }
          }
        }
      }
      return inputs;
    };
    this._handleAddSelector = (newMatchers) => {
      const dropdown = this.shadowRoot?.querySelector(".dropdown");
      if (dropdown)
        dropdown.hide();
      this._addInput();
      if (this._input && this.message) {
        const message = structuredClone(this.message);
        const _variantsMatcher = (message ? message.variants : []).map((variant) => variant.match);
        this._updateSelector();
        this._addMatchToExistingVariants();
        const newCombinations = this._generateNewMatcherCombinations({
          variantsMatcher: _variantsMatcher,
          newMatchers,
          newSelectorName: this._input
        });
        this._addVariantsFromNewCombinations(newCombinations);
        this.dispatchEvent(new CustomEvent("submit"));
      }
    };
    this._addInput = () => {
      if (this._isNewInput && this._newInputSting && this._newInputSting.length > 0) {
        for (const message of this.messages || []) {
          const newMessage = structuredClone(message);
          newMessage.declarations.push({
            type: "input",
            name: this._newInputSting,
            value: {
              type: "expression",
              arg: {
                type: "variable",
                name: this._newInputSting
              }
            }
          });
          this.dispatchEvent(createChangeEvent({
            type: "Message",
            operation: "update",
            newData: newMessage
          }));
        }
        this._input = this._newInputSting;
      }
    };
    this._updateSelector = () => {
      if (this.message && this._input) {
        this.message.selectors.push({
          type: "expression",
          arg: {
            type: "variable",
            name: this._input
          },
          annotation: {
            type: "function",
            name: this._function || "plural",
            options: []
          }
        });
        this.dispatchEvent(createChangeEvent({
          type: "Message",
          operation: "update",
          newData: this.message
        }));
      }
    };
    this._addMatchToExistingVariants = () => {
      if (this.message && this._input) {
        for (const variant of this.message.variants) {
          variant.match[this._input] = "*";
          this.dispatchEvent(createChangeEvent({
            type: "Variant",
            operation: "update",
            newData: variant
          }));
        }
      }
    };
    this._addVariantsFromNewCombinations = (newCombinations) => {
      if (this.message) {
        for (const combination of newCombinations) {
          const newVariant = createVariant({
            messageId: this.message.id,
            match: combination,
            text: ""
          });
          this.dispatchEvent(createChangeEvent({
            type: "Variant",
            operation: "create",
            newData: newVariant
          }));
        }
      }
    };
    this._generateNewMatcherCombinations = (props) => {
      const newMatchers = props.newMatchers.filter((category) => category !== "*");
      const newCombinations = [];
      if (newMatchers) {
        for (const variantMatcher of props.variantsMatcher) {
          for (const category of newMatchers) {
            newCombinations.push({ ...variantMatcher, ...{ [props.newSelectorName]: category } });
          }
        }
      }
      return newCombinations;
    };
  }
  static {
    this.styles = [
      baseStyling,
      i`
			.button-wrapper {
				height: 44px;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.dropdown-container {
				font-size: 14px;
				width: full;
				padding: 20px;
				display: flex;
				flex-direction: column;
				gap: 16px;
			}
			.dropdown-item {
				display: flex;
				flex-direction: column;
				gap: 2px;
			}
			.dropdown-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				color: var(--sl-input-color);
				font-size: 12px;
			}
			.dropdown-title {
				font-size: 14px;
				font-weight: 500;
				margin: 6px 0;
			}
			.add-input::part(base) {
				color: var(--sl-color-neutral-500);
			}
			.add-input::part(base):hover {
				background-color: var(--sl-input-background-color-hover);
				color: var(--sl-input-color-hover);
			}
			sl-select::part(form-control-label) {
				font-size: 14px;
			}
			sl-select::part(display-input) {
				font-size: 14px;
			}
			sl-option::part(label) {
				font-size: 14px;
			}
			sl-menu-item::part(label) {
				font-size: 14px;
				padding-left: 12px;
			}
			sl-menu-item::part(base) {
				color: var(--sl-input-color);
			}
			sl-menu-item::part(base):hover {
				background-color: var(--sl-input-background-color-hover);
			}
			sl-menu-item::part(checked-icon) {
				display: none;
			}
			.options-title {
				font-size: 14px;
				color: var(--sl-input-color);
				background-color: var(--sl-input-background-color);
				margin: 0;
				padding-bottom: 4px;
			}
			.options-wrapper {
				display: flex;
				gap: 4px;
				flex-wrap: wrap;
				margin-top: 4px;
			}
			.option {
				width: 100%;
			}
			.option::part(base) {
				background-color: var(--sl-input-background-color-hover);
				border-radius: var(--sl-input-border-radius-small);
			}
			.option {
				width: 100%;
				background-color: var(--sl-input-background-color-hover);
			}
			.delete-icon {
				color: var(--sl-color-neutral-400);
				cursor: pointer;
			}
			.delete-icon:hover {
				color: var(--sl-input-color-hover);
			}
			.help-text {
				display: flex;
				gap: 8px;
				color: var(--sl-input-help-text-color);
			}
			.help-text p {
				flex: 1;
				margin: 0;
				font-size: 12px;
				line-height: 1.5;
			}
			.empty-image {
				width: 100%;
				display: flex;
				justify-content: center;
				align-items: center;
				margin-top: 12px;
			}
			.actions {
				width: 100%;
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
			sl-input::part(base) {
				font-size: 14px;
			}
			.add-selector::part(base) {
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
			}
			.add-selector::part(base):hover {
				background-color: var(--sl-input-background-color-hover);
				color: var(--sl-input-color-hover);
				border: 1px solid var(--sl-input-border-color-hover);
			}
		`
    ];
  }
  async firstUpdated() {
    await this.updateComplete;
    this._input = this._getInputs()?.[0]?.name;
    this._function = "plural";
    this._matchers = this._getPluralCategories() || ["*"];
  }
  render() {
    return ke`
			<div class="dropdown-container">
				<div class="dropdown-item">
					<div class="dropdown-header">
						<p class="dropdown-title">Input</p>
						${this._isNewInput && this._getInputs() && this._getInputs().length > 0 ? ke`<sl-tooltip content="Show inputs">
									<sl-button
										class="add-input"
										variant="text"
										size="small"
										@click=${() => {
      this._isNewInput = false;
      this.requestUpdate();
    }}
									>
										<svg
											xmlns="http://www.w3.org/2000/svg"
											width="18"
											height="18"
											viewBox="0 0 24 24"
											slot="prefix"
											style="margin: 0 -2px"
										>
											<path
												fill="currentColor"
												fill-rule="evenodd"
												d="M3.25 7A.75.75 0 0 1 4 6.25h16a.75.75 0 0 1 0 1.5H4A.75.75 0 0 1 3.25 7m0 5a.75.75 0 0 1 .75-.75h11a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.75-.75m0 5a.75.75 0 0 1 .75-.75h5a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.75-.75"
												clip-rule="evenodd"
											/>
										</svg>
									</sl-button>
							  </sl-tooltip>` : ``}
						${!this._isNewInput ? ke`<sl-tooltip content="Add a new input">
									<sl-button
										class="add-input"
										variant="text"
										size="small"
										@click=${() => {
      this._isNewInput = true;
      this.requestUpdate();
    }}
										><svg
											viewBox="0 0 24 24"
											width="18"
											height="18"
											slot="prefix"
											style="margin: 0 -2px"
										>
											<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path></svg
									></sl-button>
							  </sl-tooltip>` : ``}
					</div>
					${!this._isNewInput ? ke`<sl-select
								@sl-change=${(e6) => {
      const inputElement = e6.target;
      this._input = inputElement.value;
    }}
								@sl-show=${(e6) => {
      const inputElement = e6.target;
      this._input = inputElement.value;
    }}
								size="small"
								value=${this._input || this._getInputs()?.[0]}
						  >
								${this._getInputs() && this._getInputs().map((input) => {
      return ke`<sl-option value=${input.name}>${input.name}</sl-option>`;
    })}
						  </sl-select>` : ke`<sl-input 
										size="small" 
										placeholder="Enter input name ..." 
										@sl-input=${(e6) => {
      this._newInputSting = e6.target.value;
    }}
										</sl-input>`}
				</div>
				${this._isNewInput ? ke`<div class="help-text">
							<svg
								xmlns="http://www.w3.org/2000/svg"
								width="24px"
								height="24px"
								viewBox="0 0 256 256"
							>
								<path
									fill="currentColor"
									d="M140 180a12 12 0 1 1-12-12a12 12 0 0 1 12 12M128 72c-22.06 0-40 16.15-40 36v4a8 8 0 0 0 16 0v-4c0-11 10.77-20 24-20s24 9 24 20s-10.77 20-24 20a8 8 0 0 0-8 8v8a8 8 0 0 0 16 0v-.72c18.24-3.35 32-17.9 32-35.28c0-19.85-17.94-36-40-36m104 56A104 104 0 1 1 128 24a104.11 104.11 0 0 1 104 104m-16 0a88 88 0 1 0-88 88a88.1 88.1 0 0 0 88-88"
								/>
							</svg>
							<p>No input present. Add a new input to create a selector.</p>
					  </div>` : ``}
				<div class="dropdown-item">
					<div class="dropdown-header">
						<p class="dropdown-title">Function</p>
					</div>
					<sl-select
						size="small"
						value="plural"
						@sl-change=${(e6) => {
      const option = e6.target.value;
      if (option === "string") {
        this._function = "string";
        this._matchers = ["*"];
        this.requestUpdate();
      } else if (option === "plural") {
        this._function = "plural";
        this._matchers = this._getPluralCategories() || ["*"];
        this.requestUpdate();
      }
    }}
					>
						<sl-option value="plural">plural</sl-option>
						<sl-option value="string">string</sl-option>
					</sl-select>
				</div>
				<div class="options-container">
					<div class="dropdown-header">
						<p class="dropdown-title">Match</p>
						<sl-tooltip content="Add a match to this selector">
							<sl-button
								class="add-input"
								variant="text"
								size="small"
								@click=${() => {
      this._matchers?.push("");
      this.requestUpdate();
      setTimeout(() => {
        const inputs = this.shadowRoot?.querySelectorAll(".option");
        const lastInput = inputs && inputs.at(-1);
        lastInput?.focus(), 100;
      });
    }}
								><svg
									viewBox="0 0 24 24"
									width="18"
									height="18"
									slot="prefix"
									style="margin: 0 -2px"
								>
									<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path></svg
							></sl-button>
						</sl-tooltip>
					</div>
					<div class="options-wrapper">
						${this._matchers?.map((category, index) => {
      return ke`<sl-input
								class="option"
								size="small"
								value=${category}
								filled
								@input=${(e6) => {
        this._matchers = this._matchers || [];
        this._matchers[index] = e6.target.value;
      }}
								><svg
									xmlns="http://www.w3.org/2000/svg"
									width="18px"
									height="18px"
									viewBox="0 0 24 24"
									slot="suffix"
									class="delete-icon"
									style="margin-left: -4px; margin-right: 8px"
									@click=${() => {
        this._matchers = this._matchers || [];
        this._matchers.splice(index, 1);
        this.requestUpdate();
      }}
								>
									<path
										fill="currentColor"
										d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
									/></svg
							></sl-input>`;
    })}
					</div>
				</div>
				<div class="help-text">
					<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 256 256">
						<path
							fill="currentColor"
							d="M140 180a12 12 0 1 1-12-12a12 12 0 0 1 12 12M128 72c-22.06 0-40 16.15-40 36v4a8 8 0 0 0 16 0v-4c0-11 10.77-20 24-20s24 9 24 20s-10.77 20-24 20a8 8 0 0 0-8 8v8a8 8 0 0 0 16 0v-.72c18.24-3.35 32-17.9 32-35.28c0-19.85-17.94-36-40-36m104 56A104 104 0 1 1 128 24a104.11 104.11 0 0 1 104 104m-16 0a88 88 0 1 0-88 88a88.1 88.1 0 0 0 88-88"
						/>
					</svg>
					<p>The selector automatically adds the variants from the list of matchers.</p>
				</div>
				<div class="actions">
					<sl-button
						@click=${() => {
      if (this._matchers) {
        this._handleAddSelector(this._matchers);
      } else {
        console.info("No matchers present");
      }
    }}
						size="medium"
						variant="primary"
						>Add selector</sl-button
					>
				</div>
			</div>
		`;
  }
};
__decorate7([
  n4()
], InlangAddSelector.prototype, "message", void 0);
__decorate7([
  n4()
], InlangAddSelector.prototype, "messages", void 0);
__decorate7([
  r4()
], InlangAddSelector.prototype, "_input", void 0);
__decorate7([
  r4()
], InlangAddSelector.prototype, "_function", void 0);
__decorate7([
  r4()
], InlangAddSelector.prototype, "_matchers", void 0);
__decorate7([
  r4()
], InlangAddSelector.prototype, "_isNewInput", void 0);
__decorate7([
  r4()
], InlangAddSelector.prototype, "_newInputSting", void 0);
InlangAddSelector = __decorate7([
  t2("inlang-add-selector")
], InlangAddSelector);
var inlang_add_selector_default = InlangAddSelector;
export {
  inlang_add_selector_default as InlangAddSelector,
  inlang_bundle_default as InlangBundle,
  inlang_bundle_action_default as InlangBundleAction,
  inlang_message_default as InlangMessage,
  inlang_pattern_editor_default as InlangPatternEditor,
  inlang_variant_default as InlangVariant
};
/*! Bundled license information:

@lit-labs/ssr-dom-shim/lib/element-internals.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/ssr-dom-shim/index.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=bundle-component.mjs.map
