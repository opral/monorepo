import { compileBundle } from "./compile-bundle.js";
import { selectBundleNested, type InlangProject } from "@inlang/sdk";
import { lookup } from "../services/lookup.js";
import * as localeModules from "./output-structure/locale-modules.js";
import * as messageModules from "./output-structure/message-modules.js";
import {
	defaultCompilerOptions,
	type CompilerOptions,
} from "./compiler-options.js";
import { createRuntimeFile } from "./runtime/create-runtime.js";
import { createServerFile } from "./server/create-server-file.js";
import { createRegistry } from "./registry.js";

const outputStructures = {
	"locale-modules": localeModules,
	"message-modules": messageModules,
};

/**
 * Takes an inlang project and compiles it into a set of files.
 *
 * Use this function for more programmatic control than `compile()`.
 * You can adjust the output structure and get the compiled files as a return value.
 *
 * @example
 *   const output = await compileProject({ project });
 *   await writeOutput('path', output, fs.promises);
 */
export const compileProject = async (args: {
	project: InlangProject;
	compilerOptions?: Omit<CompilerOptions, "fs" | "project" | "outdir">;
}): Promise<Record<string, string>> => {
	const optionsWithDefaults = {
		...defaultCompilerOptions,
		...args.compilerOptions,
	};

	const settings = await args.project.settings.get();
	const bundles = await selectBundleNested(args.project.db).execute();

	//Maps each language to it's fallback
	//If there is no fallback, it will be undefined
	const fallbackMap = getFallbackMap(settings.locales, settings.baseLocale);

	const outputStructure = outputStructures[optionsWithDefaults.outputStructure];

	const compiledBundles = bundles.map((bundle) =>
		compileBundle({
			bundle,
			fallbackMap,
			messageReferenceExpression: outputStructure.messageReferenceExpression,
			compilerOptions: args.compilerOptions,
			settings,
		})
	);

	const output: Record<string, string> = {
		["runtime.js"]: createRuntimeFile({
			baseLocale: settings.baseLocale,
			locales: settings.locales,
			compilerOptions: optionsWithDefaults,
		}),
		["server.js"]: createServerFile({
			compiledBundles,
			compilerOptions: optionsWithDefaults,
		}),
		["registry.js"]: createRegistry(),
		["messages.js"]: [
			"export * from './messages/_index.js'",
			"// enabling auto-import by exposing all messages as m",
			"export * as m from './messages/_index.js'",
		].join("\n"),
	};

	// generate the output modules
	Object.assign(
		output,
		outputStructure.generateOutput(compiledBundles, settings, fallbackMap)
	);

	if (optionsWithDefaults.emitGitIgnore) {
		output[".gitignore"] = ignoreDirectory;
	}

	if (optionsWithDefaults.emitPrettierIgnore) {
		output[".prettierignore"] = ignoreDirectory;
	}

	for (const [filename, content] of Object.entries(
		optionsWithDefaults.additionalFiles ?? {}
	)) {
		output[filename] = content;
	}

	for (const [filename, content] of Object.entries(output)) {
		if (optionsWithDefaults.includeEslintDisableComment) {
			if (filename.endsWith(".js")) {
				output[filename] = `// eslint-disable\n${content}`;
			}
		}
	}

	return output;
};

export function getFallbackMap<T extends string>(
	locales: T[],
	baseLocale: NoInfer<T>
): Record<T, T | undefined> {
	return Object.fromEntries(
		locales.map((lang) => {
			const fallbackLanguage = lookup(lang, {
				locales: locales.filter((l) => l !== lang),
				baseLocale,
			});

			if (lang === fallbackLanguage) return [lang, undefined];
			else return [lang, fallbackLanguage];
		})
	) as Record<T, T | undefined>;
}

const ignoreDirectory = `# ignore everything because the directory is auto-generated by inlang paraglide-js
# for more info visit https://inlang.com/m/gerre34r/paraglide-js
*
`;
